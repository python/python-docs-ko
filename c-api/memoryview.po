# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-08 08:18+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/c-api/memoryview.rst:9
msgid "MemoryView objects"
msgstr "MemoryView 객체"

#: ../Doc/c-api/memoryview.rst:11
msgid ""
"A :class:`memoryview` object exposes the C level :ref:`buffer interface "
"<bufferobjects>` as a Python object which can then be passed around like "
"any other object."
msgstr ""
":class:`memoryview` 객체는 C 수준 :ref:`버퍼 인터페이스 <bufferobjects>`\\를 다른 객체와 "
"마찬가지로 전달될 수 있는 파이썬 객체로 노출합니다."

#: ../Doc/c-api/memoryview.rst:18
msgid ""
"Create a memoryview object from an object that provides the buffer "
"interface. If *obj* supports writable buffer exports, the memoryview "
"object will be read/write, otherwise it may be either read-only or "
"read/write at the discretion of the exporter."
msgstr ""
"버퍼 인터페이스를 제공하는 객체에서 memoryview 객체를 만듭니다. *obj*\\가 쓰기 가능한 버퍼 제공을 지원하면, "
"memoryview 객체는 읽기/쓰기가 되고, 그렇지 않으면 읽기 전용이거나 제공자의 재량에 따라 읽기/쓰기가 될 수 있습니다."

#: ../Doc/c-api/memoryview.rst:25
msgid ""
"Create a memoryview object using *mem* as the underlying buffer. *flags* "
"can be one of :c:macro:`PyBUF_READ` or :c:macro:`PyBUF_WRITE`."
msgstr ""
"*mem*\\를 하부 버퍼로 사용하여 memoryview 객체를 만듭니다. *flags*\\는 "
":c:macro:`PyBUF_READ` 나 :c:macro:`PyBUF_WRITE` 중 하나일 수 있습니다."

#: ../Doc/c-api/memoryview.rst:32
msgid ""
"Create a memoryview object wrapping the given buffer structure *view*. "
"For simple byte buffers, :c:func:`PyMemoryView_FromMemory` is the "
"preferred function."
msgstr ""
"주어진 버퍼 구조체 *view*\\를 감싸는 memoryview 객체를 만듭니다. 간단한 바이트 버퍼의 경우는, "
":c:func:`PyMemoryView_FromMemory`\\가 선호되는 함수입니다."

#: ../Doc/c-api/memoryview.rst:38
msgid ""
"Create a memoryview object to a :term:`contiguous` chunk of memory (in "
"either 'C' or 'F'ortran *order*) from an object that defines the buffer "
"interface. If memory is contiguous, the memoryview object points to the "
"original memory. Otherwise, a copy is made and the memoryview points to a"
" new bytes object."
msgstr ""
"버퍼 인터페이스를 정의하는 객체로부터 메모리의 :term:`연속 <contiguous>` 청크('C' 나 'F'ortran "
"*order*\\로)로 memoryview 객체를 만듭니다. 메모리가 연속적이면 memoryview 객체는 원래 메모리를 "
"가리킵니다. 그렇지 않으면, 복사본이 만들어지고 memoryview는 새 바이트열 객체를 가리킵니다."

#: ../Doc/c-api/memoryview.rst:47
msgid ""
"Return true if the object *obj* is a memoryview object.  It is not "
"currently allowed to create subclasses of :class:`memoryview`.  This "
"function always succeeds."
msgstr ""
"객체 *obj*\\가 memoryview 객체면 참을 반환합니다. 현재는 :class:`memoryview`\\의 서브 클래스를 "
"만들 수 없습니다. 이 함수는 항상 성공합니다."

#: ../Doc/c-api/memoryview.rst:54
msgid ""
"Return a pointer to the memoryview's private copy of the exporter's "
"buffer. *mview* **must** be a memoryview instance; this macro doesn't "
"check its type, you must do it yourself or you will risk crashes."
msgstr ""
"제공자 버퍼의 memoryview의 비공개 복사본의 포인터를 돌려줍니다. *mview*\\는 **반드시** memoryview "
"인스턴스여야 합니다; 이 매크로는 형을 확인하지 않으므로 직접 검사해야 합니다, 그렇지 않으면 충돌 위험이 있습니다."

#: ../Doc/c-api/memoryview.rst:60
msgid ""
"Return either a pointer to the exporting object that the memoryview is "
"based on or ``NULL`` if the memoryview has been created by one of the "
"functions :c:func:`PyMemoryView_FromMemory` or "
":c:func:`PyMemoryView_FromBuffer`. *mview* **must** be a memoryview "
"instance."
msgstr ""
"memoryview가 기반으로 하는 제공자 객체에 대한 포인터나 memoryview가 "
":c:func:`PyMemoryView_FromMemory` 나 :c:func:`PyMemoryView_FromBuffer` 함수 "
"중 하나로 만들어졌으면 ``NULL``\\을 반환합니다. *mview*\\는 **반드시** memoryview 인스턴스여야 합니다."

