# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../c-api/float.rst:6
msgid "Floating-Point Objects"
msgstr "부동 소수점 객체"

#: ../../c-api/float.rst:13
msgid ""
"This subtype of :c:type:`PyObject` represents a Python floating-point "
"object."
msgstr "이 :c:type:`PyObject`\\의 서브 형은 파이썬 부동 소수점 객체를 나타냅니다."

#: ../../c-api/float.rst:18
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python floating-"
"point type.  This is the same object as :class:`float` in the Python "
"layer."
msgstr ""
"이 :c:type:`PyTypeObject` 인스턴스는 파이썬 부동 소수점 형을 나타냅니다. 이것은 파이썬 계층에서 "
":class:`float`\\와 같은 객체입니다."

#: ../../c-api/float.rst:24
msgid ""
"Return true if its argument is a :c:type:`PyFloatObject` or a subtype of "
":c:type:`PyFloatObject`.  This function always succeeds."
msgstr ""
"인자가 :c:type:`PyFloatObject` 나 :c:type:`PyFloatObject`\\의 서브 형이면 참을 반환합니다."
" 이 함수는 항상 성공합니다."

#: ../../c-api/float.rst:30
msgid ""
"Return true if its argument is a :c:type:`PyFloatObject`, but not a "
"subtype of :c:type:`PyFloatObject`.  This function always succeeds."
msgstr ""
"인자가 :c:type:`PyFloatObject`\\이지만 :c:type:`PyFloatObject`\\의 서브 형은 아니면 참을 "
"반환합니다. 이 함수는 항상 성공합니다."

#: ../../c-api/float.rst:36
msgid ""
"Create a :c:type:`PyFloatObject` object based on the string value in "
"*str*, or ``NULL`` on failure."
msgstr "*str*\\의 문자열 값을 기반으로 :c:type:`PyFloatObject` 객체를 만들거나, 실패하면 ``NULL``."

#: ../../c-api/float.rst:42
msgid "Create a :c:type:`PyFloatObject` object from *v*, or ``NULL`` on failure."
msgstr "*v*\\로부터 :c:type:`PyFloatObject` 객체를 만들거나, 실패하면 ``NULL``."

#: ../../c-api/float.rst:47
msgid ""
"Return a C :c:expr:`double` representation of the contents of *pyfloat*."
"  If *pyfloat* is not a Python floating-point object but has a "
":meth:`~object.__float__` method, this method will first be called to "
"convert *pyfloat* into a float. If :meth:`!__float__` is not defined then"
" it falls back to :meth:`~object.__index__`. This method returns ``-1.0``"
" upon failure, so one should call :c:func:`PyErr_Occurred` to check for "
"errors."
msgstr ""
"*pyfloat* 의 내용의 C :c:expr:`double` 표현을 반환합니다. *pyfloat*\\가 파이썬 부동 소수점 객체가"
" 아니지만 :meth:`~object.__float__` 메서드가 있으면, *pyfloat*\\를 float로 변환하기 위해 이 "
"메서드가 먼저 호출됩니다. :meth:`!__float__`\\가 정의되지 않았으면 "
":meth:`~object.__index__`\\로 대체합니다. 이 메서드는 실패하면 ``-1.0``\\을 반환하므로, "
":c:func:`PyErr_Occurred`\\를 호출하여 에러를 확인해야 합니다."

#: ../../c-api/float.rst:54
msgid "Use :meth:`~object.__index__` if available."
msgstr "사용할 수 있으면 :meth:`~object.__index__`\\를 사용합니다."

#: ../../c-api/float.rst:60
msgid ""
"Return a C :c:expr:`double` representation of the contents of *pyfloat*, "
"but without error checking."
msgstr "에러 검사 없이 *pyfloat* 의 내용의 C :c:expr:`double` 표현을 반환합니다."

#: ../../c-api/float.rst:66
msgid ""
"Return a structseq instance which contains information about the "
"precision, minimum and maximum values of a float. It's a thin wrapper "
"around the header file :file:`float.h`."
msgstr ""
"float의 정밀도, 최솟값, 최댓값에 관한 정보를 포함한 structseq 인스턴스를 돌려줍니다. 헤더 파일 "
":file:`float.h`\\를 감싸는 얇은 래퍼입니다."

#: ../../c-api/float.rst:73
msgid ""
"Return the maximum representable finite float *DBL_MAX* as C "
":c:expr:`double`."
msgstr "최대 표현 가능한 유한 float *DBL_MAX*\\를 C :c:expr:`double`\\로 반환합니다."

#: ../../c-api/float.rst:78
msgid ""
"Return the minimum normalized positive float *DBL_MIN* as C "
":c:expr:`double`."
msgstr "최소 정규화된(normalized) 양의 float *DBL_MIN*\\를 C :c:expr:`double`\\로 반환합니다."

#: ../../c-api/float.rst:82
msgid "Pack and Unpack functions"
msgstr ""

#: ../../c-api/float.rst:84
msgid ""
"The pack and unpack functions provide an efficient platform-independent "
"way to store floating-point values as byte strings. The Pack routines "
"produce a bytes string from a C :c:expr:`double`, and the Unpack routines"
" produce a C :c:expr:`double` from such a bytes string. The suffix (2, 4 "
"or 8) specifies the number of bytes in the bytes string."
msgstr ""

#: ../../c-api/float.rst:90
msgid ""
"On platforms that appear to use IEEE 754 formats these functions work by "
"copying bits. On other platforms, the 2-byte format is identical to the "
"IEEE 754 binary16 half-precision format, the 4-byte format (32-bit) is "
"identical to the IEEE 754 binary32 single precision format, and the "
"8-byte format to the IEEE 754 binary64 double precision format, although "
"the packing of INFs and NaNs (if such things exist on the platform) isn't"
" handled correctly, and attempting to unpack a bytes string containing an"
" IEEE INF or NaN will raise an exception."
msgstr ""

#: ../../c-api/float.rst:99
msgid ""
"On non-IEEE platforms with more precision, or larger dynamic range, than "
"IEEE 754 supports, not all values can be packed; on non-IEEE platforms "
"with less precision, or smaller dynamic range, not all values can be "
"unpacked. What happens in such cases is partly accidental (alas)."
msgstr ""

#: ../../c-api/float.rst:107
msgid "Pack functions"
msgstr ""

#: ../../c-api/float.rst:109
msgid ""
"The pack routines write 2, 4 or 8 bytes, starting at *p*. *le* is an "
":c:expr:`int` argument, non-zero if you want the bytes string in little-"
"endian format (exponent last, at ``p+1``, ``p+3``, or ``p+6`` ``p+7``), "
"zero if you want big-endian format (exponent first, at *p*). The "
":c:macro:`PY_BIG_ENDIAN` constant can be used to use the native endian: "
"it is equal to ``1`` on big endian processor, or ``0`` on little endian "
"processor."
msgstr ""

#: ../../c-api/float.rst:116
msgid ""
"Return value: ``0`` if all is OK, ``-1`` if error (and an exception is "
"set, most likely :exc:`OverflowError`)."
msgstr ""

#: ../../c-api/float.rst:119
msgid "There are two problems on non-IEEE platforms:"
msgstr ""

#: ../../c-api/float.rst:121
msgid "What this does is undefined if *x* is a NaN or infinity."
msgstr ""

#: ../../c-api/float.rst:122
msgid "``-0.0`` and ``+0.0`` produce the same bytes string."
msgstr ""

#: ../../c-api/float.rst:126
msgid "Pack a C double as the IEEE 754 binary16 half-precision format."
msgstr ""

#: ../../c-api/float.rst:130
msgid "Pack a C double as the IEEE 754 binary32 single precision format."
msgstr ""

#: ../../c-api/float.rst:134
msgid "Pack a C double as the IEEE 754 binary64 double precision format."
msgstr ""

#: ../../c-api/float.rst:138
msgid "Unpack functions"
msgstr ""

#: ../../c-api/float.rst:140
msgid ""
"The unpack routines read 2, 4 or 8 bytes, starting at *p*.  *le* is an "
":c:expr:`int` argument, non-zero if the bytes string is in little-endian "
"format (exponent last, at ``p+1``, ``p+3`` or ``p+6`` and ``p+7``), zero "
"if big-endian (exponent first, at *p*). The :c:macro:`PY_BIG_ENDIAN` "
"constant can be used to use the native endian: it is equal to ``1`` on "
"big endian processor, or ``0`` on little endian processor."
msgstr ""

#: ../../c-api/float.rst:147
msgid ""
"Return value: The unpacked double.  On error, this is ``-1.0`` and "
":c:func:`PyErr_Occurred` is true (and an exception is set, most likely "
":exc:`OverflowError`)."
msgstr ""

#: ../../c-api/float.rst:151
msgid ""
"Note that on a non-IEEE platform this will refuse to unpack a bytes "
"string that represents a NaN or infinity."
msgstr ""

#: ../../c-api/float.rst:156
msgid "Unpack the IEEE 754 binary16 half-precision format as a C double."
msgstr ""

#: ../../c-api/float.rst:160
msgid "Unpack the IEEE 754 binary32 single precision format as a C double."
msgstr ""

#: ../../c-api/float.rst:164
msgid "Unpack the IEEE 754 binary64 double precision format as a C double."
msgstr ""

#: ../../c-api/float.rst:8
msgid "object"
msgstr "객체"

#: ../../c-api/float.rst:8
msgid "floating-point"
msgstr "부동 소수점"

