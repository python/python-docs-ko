# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-08 08:18+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/c-api/capsule.rst:6
msgid "Capsules"
msgstr "캡슐"

#: ../Doc/c-api/capsule.rst:10
msgid ""
"Refer to :ref:`using-capsules` for more information on using these "
"objects."
msgstr "이 객체 사용에 대한 자세한 정보는 :ref:`using-capsules`\\를 참조하십시오."

#: ../Doc/c-api/capsule.rst:17
msgid ""
"This subtype of :c:type:`PyObject` represents an opaque value, useful for"
" C extension modules who need to pass an opaque value (as a "
":c:type:`void*` pointer) through Python code to other C code.  It is "
"often used to make a C function pointer defined in one module available "
"to other modules, so the regular import mechanism can be used to access C"
" APIs defined in dynamically loaded modules."
msgstr ""
"이 :c:type:`PyObject`\\의 서브 형은 불투명한 값을 나타내며, 파이썬 코드를 통해 다른 C 코드로 불투명한 "
"값(:c:type:`void*` 포인터로)을 전달해야 하는 C 확장 모듈에 유용합니다. 이것은 한 모듈에서 정의된 C 함수 포인터를"
" 다른 모듈에서 사용할 수 있게 만드는 데 종종 사용되므로, 일반 임포트 메커니즘을 사용하여 동적으로 로드된 모듈에 정의된 C "
"API에 액세스할 수 있습니다."

#: ../Doc/c-api/capsule.rst:27
msgid "The type of a destructor callback for a capsule.  Defined as::"
msgstr "캡슐에 대한 파괴자(destructor) 콜백 형. 이렇게 정의됩니다::"

#: ../Doc/c-api/capsule.rst:31
msgid ""
"See :c:func:`PyCapsule_New` for the semantics of PyCapsule_Destructor "
"callbacks."
msgstr "PyCapsule_Destructor 콜백의 의미는 :c:func:`PyCapsule_New`\\를 참조하십시오."

#: ../Doc/c-api/capsule.rst:37
#, fuzzy
msgid ""
"Return true if its argument is a :c:type:`PyCapsule`.  This function "
"always succeeds."
msgstr "인자가 :c:type:`PyCapsule`\\이면 참을 돌려줍니다."

#: ../Doc/c-api/capsule.rst:43
msgid ""
"Create a :c:type:`PyCapsule` encapsulating the *pointer*.  The *pointer* "
"argument may not be ``NULL``."
msgstr ""
"*pointer*\\를 캡슐화하는 :c:type:`PyCapsule`\\을 만듭니다. *pointer* 인자는 ``NULL``\\이"
" 아닐 수도 있습니다."

#: ../Doc/c-api/capsule.rst:46
msgid "On failure, set an exception and return ``NULL``."
msgstr "실패하면, 예외를 설정하고 ``NULL``\\을 반환합니다."

#: ../Doc/c-api/capsule.rst:48
msgid ""
"The *name* string may either be ``NULL`` or a pointer to a valid C "
"string.  If non-``NULL``, this string must outlive the capsule.  (Though "
"it is permitted to free it inside the *destructor*.)"
msgstr ""
"*name* 문자열은 ``NULL`` 이나 유효한 C 문자열에 대한 포인터일 수 있습니다. ``NULL``\\이 아니면, 이 "
"문자열은 캡슐보다 오래 유지되어야 합니다. (*destructor* 내부에서 해제할 수는 있습니다.)"

#: ../Doc/c-api/capsule.rst:52
msgid ""
"If the *destructor* argument is not ``NULL``, it will be called with the "
"capsule as its argument when it is destroyed."
msgstr "*destructor* 인자가 ``NULL``\\이 아니면, 캡슐이 파괴될 때 캡슐을 인자로 호출됩니다."

#: ../Doc/c-api/capsule.rst:55
msgid ""
"If this capsule will be stored as an attribute of a module, the *name* "
"should be specified as ``modulename.attributename``.  This will enable "
"other modules to import the capsule using :c:func:`PyCapsule_Import`."
msgstr ""
"이 캡슐을 모듈의 어트리뷰트로 저장하려면, *name*\\을 ``modulename.attributename``\\로 지정해야 "
"합니다. 이렇게 하면 다른 모듈이 :c:func:`PyCapsule_Import`\\를 사용하여 캡슐을 임포트 할 수 있습니다."

#: ../Doc/c-api/capsule.rst:62
msgid ""
"Retrieve the *pointer* stored in the capsule.  On failure, set an "
"exception and return ``NULL``."
msgstr "캡슐에 저장된 *pointer*\\를 가져옵니다. 실패하면, 예외를 설정하고 ``NULL``\\을 반환합니다."

#: ../Doc/c-api/capsule.rst:65
msgid ""
"The *name* parameter must compare exactly to the name stored in the "
"capsule. If the name stored in the capsule is ``NULL``, the *name* passed"
" in must also be ``NULL``.  Python uses the C function :c:func:`strcmp` "
"to compare capsule names."
msgstr ""
"*name* 매개 변수는 캡슐에 저장된 이름과 정확하게 비교되어야 합니다. 캡슐에 저장된 이름이 ``NULL``\\이면, 전달된 "
"*name*\\도 ``NULL`` 이어야 합니다. 파이썬은 C 함수 :c:func:`strcmp`\\를 사용하여 캡슐 이름을 "
"비교합니다."

#: ../Doc/c-api/capsule.rst:73
msgid ""
"Return the current destructor stored in the capsule.  On failure, set an "
"exception and return ``NULL``."
msgstr "캡슐에 저장된 현재 파괴자를 반환합니다. 실패하면, 예외를 설정하고 ``NULL``\\을 반환합니다."

#: ../Doc/c-api/capsule.rst:76
msgid ""
"It is legal for a capsule to have a ``NULL`` destructor.  This makes a "
"``NULL`` return code somewhat ambiguous; use :c:func:`PyCapsule_IsValid` "
"or :c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"캡슐이 ``NULL`` 파괴자를 갖는 것은 합법적입니다. 이것은 ``NULL`` 반환 코드를 다소 모호하게 만듭니다; 명확히 하려면"
" :c:func:`PyCapsule_IsValid` 나 :c:func:`PyErr_Occurred`\\를 사용하십시오."

#: ../Doc/c-api/capsule.rst:83
msgid ""
"Return the current context stored in the capsule.  On failure, set an "
"exception and return ``NULL``."
msgstr "캡슐에 저장된 현재 컨텍스트를 반환합니다. 실패하면, 예외를 설정하고 ``NULL``\\을 반환합니다."

#: ../Doc/c-api/capsule.rst:86
msgid ""
"It is legal for a capsule to have a ``NULL`` context.  This makes a "
"``NULL`` return code somewhat ambiguous; use :c:func:`PyCapsule_IsValid` "
"or :c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"캡슐이 ``NULL`` 컨텍스트를 갖는 것은 합법적입니다. 이것은 ``NULL`` 반환 코드를 다소 모호하게 만듭니다; 명확히 "
"하려면 :c:func:`PyCapsule_IsValid` 나 :c:func:`PyErr_Occurred`\\를 사용하십시오."

#: ../Doc/c-api/capsule.rst:93
msgid ""
"Return the current name stored in the capsule.  On failure, set an "
"exception and return ``NULL``."
msgstr "캡슐에 저장된 현재 이름을 반환합니다. 실패하면, 예외를 설정하고 ``NULL``\\을 반환합니다."

#: ../Doc/c-api/capsule.rst:96
msgid ""
"It is legal for a capsule to have a ``NULL`` name.  This makes a ``NULL``"
" return code somewhat ambiguous; use :c:func:`PyCapsule_IsValid` or "
":c:func:`PyErr_Occurred` to disambiguate."
msgstr ""
"캡슐이 ``NULL`` 이름을 갖는 것은 합법적입니다. 이것은 ``NULL`` 반환 코드를 다소 모호하게 만듭니다; 명확히 하려면 "
":c:func:`PyCapsule_IsValid` 나 :c:func:`PyErr_Occurred`\\를 사용하십시오."

#: ../Doc/c-api/capsule.rst:103
msgid ""
"Import a pointer to a C object from a capsule attribute in a module.  The"
" *name* parameter should specify the full name to the attribute, as in "
"``module.attribute``.  The *name* stored in the capsule must match this "
"string exactly.  If *no_block* is true, import the module without "
"blocking (using :c:func:`PyImport_ImportModuleNoBlock`).  If *no_block* "
"is false, import the module conventionally (using "
":c:func:`PyImport_ImportModule`)."
msgstr ""
"모듈의 캡슐 어트리뷰트에서 C 객체에 대한 포인터를 임포트 합니다. *name* 매개 변수는 ``module.attribute`` "
"처럼 어트리뷰트의 전체 이름을 지정해야 합니다. 캡슐에 저장된 *name*\\은, 이 문자열과 정확히 일치해야 합니다. "
"*no_block*\\이 참이면, 블록하지 않고 모듈을 임포트 합니다 "
"(:c:func:`PyImport_ImportModuleNoBlock`\\를 사용해서). *no_block*\\이 거짓이면, 모듈을"
" 평범하게 임포트 합니다 (:c:func:`PyImport_ImportModule`\\을 사용해서)."

#: ../Doc/c-api/capsule.rst:110
msgid ""
"Return the capsule's internal *pointer* on success.  On failure, set an "
"exception and return ``NULL``."
msgstr "성공하면 캡슐의 내부 *pointer*\\를 반환합니다. 실패하면, 예외를 설정하고 ``NULL``\\를 반환합니다."

#: ../Doc/c-api/capsule.rst:116
msgid ""
"Determines whether or not *capsule* is a valid capsule.  A valid capsule "
"is non-``NULL``, passes :c:func:`PyCapsule_CheckExact`, has a "
"non-``NULL`` pointer stored in it, and its internal name matches the "
"*name* parameter.  (See :c:func:`PyCapsule_GetPointer` for information on"
" how capsule names are compared.)"
msgstr ""
"*capsule*\\이 유효한 캡슐인지를 판단합니다. 유효한 캡슐은 ``NULL``\\이 아니며, "
":c:func:`PyCapsule_CheckExact`\\를 통과하고, ``NULL``\\이 아닌 포인터가 저장되며, 내부 이름이 "
"*name* 매개 변수와 일치합니다. (캡슐 이름을 비교하는 방법에 대한 정보는 "
":c:func:`PyCapsule_GetPointer`\\를 참조하십시오.)"

#: ../Doc/c-api/capsule.rst:122
msgid ""
"In other words, if :c:func:`PyCapsule_IsValid` returns a true value, "
"calls to any of the accessors (any function starting with "
":c:func:`PyCapsule_Get`) are guaranteed to succeed."
msgstr ""
"즉, :c:func:`PyCapsule_IsValid`\\가 참값을 반환하면, 모든 "
"접근자(:c:func:`PyCapsule_Get`\\으로 시작하는 모든 함수)에 대한 호출이 성공함이 보장됩니다."

#: ../Doc/c-api/capsule.rst:126
msgid ""
"Return a nonzero value if the object is valid and matches the name passed"
" in. Return ``0`` otherwise.  This function will not fail."
msgstr ""
"객체가 유효하고 전달된 이름과 일치하면 0이 아닌 값을 반환합니다. 그렇지 않으면 ``0``\\을 반환합니다. 이 함수는 실패하지 "
"않습니다."

#: ../Doc/c-api/capsule.rst:132
msgid "Set the context pointer inside *capsule* to *context*."
msgstr "*capsule* 내부의 컨텍스트 포인터를 *context*\\로 설정합니다."

#: ../Doc/c-api/capsule.rst:134 ../Doc/c-api/capsule.rst:141
#: ../Doc/c-api/capsule.rst:150 ../Doc/c-api/capsule.rst:158
msgid "Return ``0`` on success.  Return nonzero and set an exception on failure."
msgstr "성공하면 ``0``\\을 반환합니다. 실패하면 0이 아닌 값을 반환하고 예외를 설정합니다."

#: ../Doc/c-api/capsule.rst:139
msgid "Set the destructor inside *capsule* to *destructor*."
msgstr "*capsule* 내부의 파괴자를 *destructor*\\로 설정합니다."

#: ../Doc/c-api/capsule.rst:146
msgid ""
"Set the name inside *capsule* to *name*.  If non-``NULL``, the name must "
"outlive the capsule.  If the previous *name* stored in the capsule was "
"not ``NULL``, no attempt is made to free it."
msgstr ""
"*capsule* 내부의 이름을 *name*\\으로 설정합니다. ``NULL``\\이 아니면, 이름은 캡슐보다 오래 유지되어야 "
"합니다. 캡슐에 저장된 이전 *name*\\이 ``NULL``\\이 아니면, 이를 해제하려고 시도하지 않습니다."

#: ../Doc/c-api/capsule.rst:155
msgid ""
"Set the void pointer inside *capsule* to *pointer*.  The pointer may not "
"be ``NULL``."
msgstr "*capsule* 내부의 void 포인터를 *pointer*\\로 설정합니다. 포인터는 ``NULL``\\이 아닐 수 있습니다."

