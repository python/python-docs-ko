# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-19 18:31+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:6
msgid "Module Objects"
msgstr "모듈 객체"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:15
msgid ""
"This instance of :c:type:`PyTypeObject` represents the Python module "
"type.  This is exposed to Python programs as ``types.ModuleType``."
msgstr ""
"이 :c:type:`PyTypeObject` 인스턴스는 파이썬 모듈 형을 나타냅니다. 이것은 "
"``types.ModuleType``\\으로 파이썬 프로그램에 노출됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:21
msgid "Return true if *p* is a module object, or a subtype of a module object."
msgstr "*p*\\가 모듈 객체이거나 모듈 객체의 서브 형이면 참을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:26
msgid ""
"Return true if *p* is a module object, but not a subtype of "
":c:data:`PyModule_Type`."
msgstr "*p*\\가 모듈 객체이지만, :c:data:`PyModule_Type`\\의 서브 형이 아니면 참을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:39
msgid ""
"Return a new module object with the :attr:`__name__` attribute set to "
"*name*. The module's :attr:`__name__`, :attr:`__doc__`, "
":attr:`__package__`, and :attr:`__loader__` attributes are filled in (all"
" but :attr:`__name__` are set to ``None``); the caller is responsible for"
" providing a :attr:`__file__` attribute."
msgstr ""
":attr:`__name__` 어트리뷰트가 *name*\\으로 설정된 새 모듈 객체를 반환합니다. 모듈의 "
":attr:`__name__`, :attr:`__doc__`, :attr:`__package__` 및 "
":attr:`__loader__` 어트리뷰트가 채워집니다 (:attr:`__name__`\\을 제외하고 모두 ``None``\\으로"
" 설정됩니다); :attr:`__file__` 어트리뷰트를 제공하는 것은 호출자의 책임입니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:47
msgid ":attr:`__package__` and :attr:`__loader__` are set to ``None``."
msgstr ":attr:`__package__`\\와 :attr:`__loader__`\\가 ``None``\\으로 설정됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:53
msgid ""
"Similar to :c:func:`PyModule_NewObject`, but the name is a UTF-8 encoded "
"string instead of a Unicode object."
msgstr ""
":c:func:`PyModule_NewObject`\\와 비슷하지만, name이 유니코드 객체 대신 UTF-8로 인코딩된 "
"문자열입니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:61
msgid ""
"Return the dictionary object that implements *module*'s namespace; this "
"object is the same as the :attr:`~object.__dict__` attribute of the "
"module object. If *module* is not a module object (or a subtype of a "
"module object), :exc:`SystemError` is raised and ``NULL`` is returned."
msgstr ""
"*module*\\의 이름 공간을 구현하는 딕셔너리 객체를 반환합니다; 이 객체는 모듈 객체의 "
":attr:`~object.__dict__` 어트리뷰트와 같습니다. *module*\\이 모듈 객체(또는 모듈 객체의 서브 형)가 "
"아니면, :exc:`SystemError`\\가 발생하고 ``NULL``\\이 반환됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:66
msgid ""
"It is recommended extensions use other :c:func:`PyModule_\\*` and "
":c:func:`PyObject_\\*` functions rather than directly manipulate a "
"module's :attr:`~object.__dict__`."
msgstr ""
"확장은 모듈의 :attr:`~object.__dict__`\\를 직접 조작하지 말고 다른 "
":c:func:`PyModule_\\*`\\과 :c:func:`PyObject_\\*` 함수를 사용하는 것이 좋습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:77
msgid ""
"Return *module*'s :attr:`__name__` value.  If the module does not provide"
" one, or if it is not a string, :exc:`SystemError` is raised and ``NULL``"
" is returned."
msgstr ""
"*module*\\의 :attr:`__name__` 값을 반환합니다. 모듈이 제공하지 않거나, 문자열이 아니면, "
":exc:`SystemError`\\가 발생하고 ``NULL``\\이 반환됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:85
msgid ""
"Similar to :c:func:`PyModule_GetNameObject` but return the name encoded "
"to ``'utf-8'``."
msgstr ":c:func:`PyModule_GetNameObject`\\와 비슷하지만 ``'utf-8'``\\로 인코딩된 이름을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:90
msgid ""
"Return the \"state\" of the module, that is, a pointer to the block of "
"memory allocated at module creation time, or ``NULL``.  See "
":c:member:`PyModuleDef.m_size`."
msgstr ""
"모듈의 \"상태\", 즉 모듈 생성 시 할당된 메모리 블록을 가리키는 포인터나 ``NULL``\\을 반환합니다. "
":c:member:`PyModuleDef.m_size`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:97
msgid ""
"Return a pointer to the :c:type:`PyModuleDef` struct from which the "
"module was created, or ``NULL`` if the module wasn't created from a "
"definition."
msgstr ""
"모듈이 만들어진 :c:type:`PyModuleDef` 구조체에 대한 포인터나 모듈이 정의에서 만들어지지 않았으면 "
"``NULL``\\을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:107
msgid ""
"Return the name of the file from which *module* was loaded using "
"*module*'s :attr:`__file__` attribute.  If this is not defined, or if it "
"is not a unicode string, raise :exc:`SystemError` and return ``NULL``; "
"otherwise return a reference to a Unicode object."
msgstr ""
"*module*\\의 :attr:`__file__` 어트리뷰트를 사용하여 *module*\\이 로드된 파일 이름을 반환합니다. "
"정의되지 않았거나 유니코드 문자열이 아니면, :exc:`SystemError`\\를 발생시키고 ``NULL``\\을 반환합니다; "
"그렇지 않으면 유니코드 객체에 대한 참조를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:117
msgid ""
"Similar to :c:func:`PyModule_GetFilenameObject` but return the filename "
"encoded to 'utf-8'."
msgstr ":c:func:`PyModule_GetFilenameObject`\\와 비슷하지만 'utf-8'로 인코딩된 파일명을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:120
msgid ""
":c:func:`PyModule_GetFilename` raises :c:type:`UnicodeEncodeError` on "
"unencodable filenames, use :c:func:`PyModule_GetFilenameObject` instead."
msgstr ""
":c:func:`PyModule_GetFilename`\\은 인코딩할 수 없는 파일명에 대해 "
":c:type:`UnicodeEncodeError`\\를 발생시킵니다, 대신 "
":c:func:`PyModule_GetFilenameObject`\\를 사용하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:128
msgid "Initializing C modules"
msgstr "C 모듈 초기화"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:130
msgid ""
"Modules objects are usually created from extension modules (shared "
"libraries which export an initialization function), or compiled-in "
"modules (where the initialization function is added using "
":c:func:`PyImport_AppendInittab`). See :ref:`building` or :ref"
":`extending-with-embedding` for details."
msgstr ""
"모듈 객체는 일반적으로 확장 모듈(초기화 함수를 내보내는 공유 라이브러리)이나 컴파일된 모듈(초기화 함수가 "
":c:func:`PyImport_AppendInittab`\\을 사용하여 추가된)에서 만들어집니다. 자세한 내용은 "
":ref:`building`\\나 :ref:`extending-with-embedding`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:135
msgid ""
"The initialization function can either pass a module definition instance "
"to :c:func:`PyModule_Create`, and return the resulting module object, or "
"request \"multi-phase initialization\" by returning the definition struct"
" itself."
msgstr ""
"초기화 함수는 모듈 정의 인스턴스를 :c:func:`PyModule_Create`\\에 전달하고 결과 모듈 객체를 반환하거나, 정의"
" 구조체 자체를 반환하여 \"다단계 초기화\"를 요청할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:141
msgid ""
"The module definition struct, which holds all information needed to "
"create a module object. There is usually only one statically initialized "
"variable of this type for each module."
msgstr ""
"모듈 객체를 만드는 데 필요한 모든 정보를 담고 있는 모듈 정의 구조체. 일반적으로 각 모듈에 대해 이 형의 정적으로 초기화된 "
"변수가 하나만 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:147
msgid "Always initialize this member to :const:`PyModuleDef_HEAD_INIT`."
msgstr "이 멤버를 항상 :const:`PyModuleDef_HEAD_INIT`\\로 초기화하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:151
msgid "Name for the new module."
msgstr "새 모듈의 이름."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:155
msgid ""
"Docstring for the module; usually a docstring variable created with "
":c:func:`PyDoc_STRVAR` is used."
msgstr "모듈의 독스트링; 일반적으로 :c:func:`PyDoc_STRVAR`\\로 만들어진 독스트링 변수가 사용됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:160
msgid ""
"Module state may be kept in a per-module memory area that can be "
"retrieved with :c:func:`PyModule_GetState`, rather than in static "
"globals. This makes modules safe for use in multiple sub-interpreters."
msgstr ""
"모듈 상태는 정적 전역이 아닌 :c:func:`PyModule_GetState`\\로 조회할 수 있는 모듈별 메모리 영역에 유지될 "
"수 있습니다. 이것은 여러 서브 인터프리터에서 모듈을 사용하는 것을 안전하게 만듭니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:164
msgid ""
"This memory area is allocated based on *m_size* on module creation, and "
"freed when the module object is deallocated, after the :c:member:`m_free`"
" function has been called, if present."
msgstr ""
"이 메모리 영역은 모듈 생성 시 *m_size*\\를 기준으로 할당되며, 모듈 객체가 할당 해제될 때 (있다면 "
":c:member:`m_free` 함수가 호출된 후에) 해제됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:168
msgid ""
"Setting ``m_size`` to ``-1`` means that the module does not support sub-"
"interpreters, because it has global state."
msgstr "``m_size``\\를 ``-1``\\로 설정하면 모듈이 전역 상태를 갖기 때문에 서브 인터프리터를 지원하지 않는다는 뜻입니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:171
msgid ""
"Setting it to a non-negative value means that the module can be re-"
"initialized and specifies the additional amount of memory it requires for"
" its state. Non-negative ``m_size`` is required for multi-phase "
"initialization."
msgstr ""
"음수가 아닌 값으로 설정하면 모듈을 다시 초기화 할 수 있다는 뜻이며 상태에 필요한 추가 메모리양을 지정합니다. 다단계 초기화에는 "
"음이 아닌 ``m_size``\\가 필요합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:176
msgid "See :PEP:`3121` for more details."
msgstr "자세한 내용은 :PEP:`3121`\\을 참조하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:180
msgid ""
"A pointer to a table of module-level functions, described by "
":c:type:`PyMethodDef` values.  Can be ``NULL`` if no functions are "
"present."
msgstr ""
":c:type:`PyMethodDef` 값으로 기술되는 모듈 수준 함수 테이블에 대한 포인터. 함수가 없으면 ``NULL``\\일 "
"수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:185
msgid ""
"An array of slot definitions for multi-phase initialization, terminated "
"by a ``{0, NULL}`` entry. When using single-phase initialization, "
"*m_slots* must be ``NULL``."
msgstr ""
"다단계 초기화를 위한 슬롯 정의 배열, ``{0, NULL}`` 항목으로 종료됩니다. 단단계 초기화를 사용할 때, "
"*m_slots*\\는 ``NULL``\\이어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:191
msgid ""
"Prior to version 3.5, this member was always set to ``NULL``, and was "
"defined as:"
msgstr "버전 3.5 이전에는, 이 멤버가 항상 ``NULL``\\로 설정되었으며, 다음과 같이 정의되었습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:198
msgid ""
"A traversal function to call during GC traversal of the module object, or"
" ``NULL`` if not needed. This function may be called before module state "
"is allocated (:c:func:`PyModule_GetState()` may return `NULL`), and "
"before the :c:member:`Py_mod_exec` function is executed."
msgstr ""
"모듈 객체의 GC 탐색 중 호출할 탐색 함수나, 필요하지 않으면 ``NULL``. 이 함수는 모듈 상태가 할당되기 전에 "
"(:c:func:`PyModule_GetState()`\\가 `NULL`\\을 반환할 수 있습니다), 그리고 "
":c:member:`Py_mod_exec` 함수가 실행되기 전에 호출될 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:205
msgid ""
"A clear function to call during GC clearing of the module object, or "
"``NULL`` if not needed. This function may be called before module state "
"is allocated (:c:func:`PyModule_GetState()` may return `NULL`), and "
"before the :c:member:`Py_mod_exec` function is executed."
msgstr ""
"모듈 객체의 GC 정리 중에 호출할 정리(clear) 함수나, 필요하지 않으면 ``NULL``. 이 함수는 모듈 상태가 할당되기 "
"전에 (:c:func:`PyModule_GetState()`\\가 `NULL`\\을 반환할 수 있습니다), 그리고 "
":c:member:`Py_mod_exec` 함수가 실행되기 전에 호출될 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:212
msgid ""
"A function to call during deallocation of the module object, or ``NULL`` "
"if not needed. This function may be called before module state is "
"allocated (:c:func:`PyModule_GetState()` may return `NULL`), and before "
"the :c:member:`Py_mod_exec` function is executed."
msgstr ""
"모듈 객체 할당 해제 중에 호출할 함수나, 필요하지 않으면 ``NULL``. 이 함수는 모듈 상태가 할당되기 전에 "
"(:c:func:`PyModule_GetState()`\\가 `NULL`\\을 반환할 수 있습니다), 그리고 "
":c:member:`Py_mod_exec` 함수가 실행되기 전에 호출될 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:218
msgid "Single-phase initialization"
msgstr "단단계 초기화"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:220
msgid ""
"The module initialization function may create and return the module "
"object directly. This is referred to as \"single-phase initialization\", "
"and uses one of the following two module creation functions:"
msgstr ""
"모듈 초기화 함수는 모듈 객체를 직접 만들고 반환할 수 있습니다. 이것을 \"단단계 초기화\"라고 하며, 다음 두 모듈 생성 함수 "
"중 하나를 사용합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:226
msgid ""
"Create a new module object, given the definition in *def*.  This behaves "
"like :c:func:`PyModule_Create2` with *module_api_version* set to "
":const:`PYTHON_API_VERSION`."
msgstr ""
"*def*\\의 정의에 따라, 새 모듈 객체를 만듭니다. 이것은 *module_api_version*\\이 "
":const:`PYTHON_API_VERSION`\\으로 설정된 :c:func:`PyModule_Create2`\\처럼 동작합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:233
msgid ""
"Create a new module object, given the definition in *def*, assuming the "
"API version *module_api_version*.  If that version does not match the "
"version of the running interpreter, a :exc:`RuntimeWarning` is emitted."
msgstr ""
"*def*\\의 정의에 따라, API 버전 *module_api_version*\\을 가정하여 새 모듈 객체를 만듭니다. 해당 "
"버전이 실행 중인 인터프리터 버전과 일치하지 않으면, :exc:`RuntimeWarning`\\을 발생시킵니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:239
msgid ""
"Most uses of this function should be using :c:func:`PyModule_Create` "
"instead; only use this if you are sure you need it."
msgstr "이 함수는 대부분 :c:func:`PyModule_Create`\\를 대신 사용해야 합니다; 확실히 필요할 때만 사용하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:242
msgid ""
"Before it is returned from in the initialization function, the resulting "
"module object is typically populated using functions like "
":c:func:`PyModule_AddObject`."
msgstr ""
"초기화 함수에서 반환되기 전에, 결과 모듈 객체는 일반적으로 :c:func:`PyModule_AddObject`\\와 같은 함수를 "
"사용하여 채워집니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:248
msgid "Multi-phase initialization"
msgstr "다단계 초기화"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:250
msgid ""
"An alternate way to specify extensions is to request \"multi-phase "
"initialization\". Extension modules created this way behave more like "
"Python modules: the initialization is split between the *creation phase*,"
" when the module object is created, and the *execution phase*, when it is"
" populated. The distinction is similar to the :py:meth:`__new__` and "
":py:meth:`__init__` methods of classes."
msgstr ""
"확장을 지정하는 다른 방법은 \"다단계 초기화\"를 요청하는 것입니다. 이 방법으로 만들어진 확장 모듈은 파이썬 모듈과 더 비슷하게"
" 동작합니다: 초기화는 모듈 객체가 만들어질 때의 *생성 단계(creation phase)*\\와 채워질 때의 *실행 "
"단계(execution phase)*\\로 분할됩니다. 구별은 클래스의 :py:meth:`__new__`\\와 "
":py:meth:`__init__` 메서드와 유사합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:257
msgid ""
"Unlike modules created using single-phase initialization, these modules "
"are not singletons: if the *sys.modules* entry is removed and the module "
"is re-imported, a new module object is created, and the old module is "
"subject to normal garbage collection -- as with Python modules. By "
"default, multiple modules created from the same definition should be "
"independent: changes to one should not affect the others. This means that"
" all state should be specific to the module object (using e.g. using "
":c:func:`PyModule_GetState`), or its contents (such as the module's "
":attr:`__dict__` or individual classes created with "
":c:func:`PyType_FromSpec`)."
msgstr ""
"단단계 초기화를 사용하여 만들어진 모듈과 달리, 이 모듈은 싱글톤이 아닙니다: *sys.modules* 항목을 제거하고 모듈을 다시"
" 임포트 하면, 새 모듈 객체가 만들어지고, 이전 모듈은 일반 가비지 수집이 적용됩니다 -- 파이썬 모듈과 마찬가지입니다. "
"기본적으로, 같은 정의에서 만들어진 여러 모듈은 독립적이어야 합니다: 하나를 변경해도 다른 모듈에는 영향을 미치지 않습니다. 즉, "
"모든 상태는 모듈 객체(예를 들어 :c:func:`PyModule_GetState`\\를 사용해서)나 그 내용(가령 모듈의 "
":attr:`__dict__`\\나 :c:func:`PyType_FromSpec`\\으로 만든 개별 클래스)으로 제한되어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:267
msgid ""
"All modules created using multi-phase initialization are expected to "
"support :ref:`sub-interpreters <sub-interpreter-support>`. Making sure "
"multiple modules are independent is typically enough to achieve this."
msgstr ""
"다단계 초기화를 사용하여 만들어진 모든 모듈은 :ref:`서브 인터프리터 <sub-interpreter-support>`\\를 "
"지원할 것으로 기대됩니다. 다중 모듈을 독립적으로 유지하는 것은 일반적으로 이를 달성하기에 충분합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:271
msgid ""
"To request multi-phase initialization, the initialization function "
"(PyInit_modulename) returns a :c:type:`PyModuleDef` instance with non-"
"empty :c:member:`~PyModuleDef.m_slots`. Before it is returned, the "
"``PyModuleDef`` instance must be initialized with the following function:"
msgstr ""
"다단계 초기화를 요청하기 위해, 초기화 함수(PyInit_modulename)는 비어 있지 않은 "
":c:member:`~PyModuleDef.m_slots`\\를 가진 :c:type:`PyModuleDef` 인스턴스를 반환합니다."
" 반환되기 전에, ``PyModuleDef`` 인스턴스를 다음 함수를 사용하여 초기화해야 합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:278
msgid ""
"Ensures a module definition is a properly initialized Python object that "
"correctly reports its type and reference count."
msgstr "모듈 정의가 형과 참조 횟수를 올바르게 보고하는 올바르게 초기화된 파이썬 객체이게 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:281
msgid "Returns *def* cast to ``PyObject*``, or ``NULL`` if an error occurred."
msgstr "*def*\\를 ``PyObject*``\\로 캐스트 하거나, 에러가 발생하면 ``NULL``\\을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:285
msgid ""
"The *m_slots* member of the module definition must point to an array of "
"``PyModuleDef_Slot`` structures:"
msgstr "모듈 정의의 *m_slots* 멤버는 ``PyModuleDef_Slot`` 구조체의 배열을 가리켜야 합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:292
msgid "A slot ID, chosen from the available values explained below."
msgstr "아래 설명된 사용 가능한 값 중에서 선택된, 슬롯 ID."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:296
msgid "Value of the slot, whose meaning depends on the slot ID."
msgstr "슬롯 ID에 따라 그 의미가 달라지는, 슬롯의 값."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:300
msgid "The *m_slots* array must be terminated by a slot with id 0."
msgstr "*m_slots* 배열은 id가 0인 슬롯으로 종료해야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:302
msgid "The available slot types are:"
msgstr "사용 가능한 슬롯 형은 다음과 같습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:306
msgid ""
"Specifies a function that is called to create the module object itself. "
"The *value* pointer of this slot must point to a function of the "
"signature:"
msgstr ""
"모듈 객체 자체를 만들기 위해 호출되는 함수를 지정합니다. 이 슬롯의 *value* 포인터는 다음과 같은 서명을 갖는 함수를 "
"가리켜야 합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:311
msgid ""
"The function receives a :py:class:`~importlib.machinery.ModuleSpec` "
"instance, as defined in :PEP:`451`, and the module definition. It should "
"return a new module object, or set an error and return ``NULL``."
msgstr ""
"이 함수는 :PEP:`451`\\에 정의된 대로, :py:class:`~importlib.machinery.ModuleSpec` "
"인스턴스와 모듈 정의를 받습니다. 새 모듈 객체를 반환하거나, 에러를 설정하고 ``NULL``\\을 반환해야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:316
msgid ""
"This function should be kept minimal. In particular, it should not call "
"arbitrary Python code, as trying to import the same module again may "
"result in an infinite loop."
msgstr ""
"이 함수는 최소한으로 유지해야 합니다. 특히 같은 모듈을 다시 임포트 하려고 시도하면 무한 루프가 발생할 수 있어서, 임의의 파이썬"
" 코드를 호출하면 안 됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:320
msgid ""
"Multiple ``Py_mod_create`` slots may not be specified in one module "
"definition."
msgstr "하나의 모듈 정의에서 여러 ``Py_mod_create`` 슬롯을 지정할 수 없습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:323
msgid ""
"If ``Py_mod_create`` is not specified, the import machinery will create a"
" normal module object using :c:func:`PyModule_New`. The name is taken "
"from *spec*, not the definition, to allow extension modules to "
"dynamically adjust to their place in the module hierarchy and be imported"
" under different names through symlinks, all while sharing a single "
"module definition."
msgstr ""
"``Py_mod_create``\\를 지정하지 않으면, 임포트 절차는 :c:func:`PyModule_New`\\를 사용하여 일반 "
"모듈 객체를 만듭니다. 이름은 정의가 아니라 *spec*\\에서 취합니다, 확장 모듈이 단일 모듈 정의를 공유하면서 모듈 계층 "
"구조에서 해당 위치에 동적으로 조정되고 심볼릭 링크를 통해 다른 이름으로 임포트 될 수 있도록 하기 위함입니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:329
msgid ""
"There is no requirement for the returned object to be an instance of "
":c:type:`PyModule_Type`. Any type can be used, as long as it supports "
"setting and getting import-related attributes. However, only "
"``PyModule_Type`` instances may be returned if the ``PyModuleDef`` has "
"non-``NULL`` ``m_traverse``, ``m_clear``, ``m_free``; non-zero "
"``m_size``; or slots other than ``Py_mod_create``."
msgstr ""
"반환된 객체가 :c:type:`PyModule_Type`\\의 인스턴스 일 필요는 없습니다. 임포트 관련 어트리뷰트 설정과 읽기를 "
"지원하는 한 모든 형을 사용할 수 있습니다. 그러나, ``PyModuleDef``\\에 ``NULL``\\이 아닌 "
"``m_traverse``, ``m_clear``, ``m_free``; 0이 아닌 ``m_size``; 또는 "
"``Py_mod_create`` 이외의 슬롯이 있으면, ``PyModule_Type`` 인스턴스 만 반환될 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:338
msgid ""
"Specifies a function that is called to *execute* the module. This is "
"equivalent to executing the code of a Python module: typically, this "
"function adds classes and constants to the module. The signature of the "
"function is:"
msgstr ""
"모듈을 *실행*\\하기 위해 호출되는 함수를 지정합니다. 이것은 파이썬 모듈의 코드를 실행하는 것과 동등합니다: 일반적으로, 이 "
"함수는 클래스와 상수를 모듈에 추가합니다. 함수의 서명은 다음과 같습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:345
msgid ""
"If multiple ``Py_mod_exec`` slots are specified, they are processed in "
"the order they appear in the *m_slots* array."
msgstr "여러 개의 ``Py_mod_exec`` 슬롯이 지정되면, *m_slots* 배열에 나타나는 순서대로 처리됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:348
msgid "See :PEP:`489` for more details on multi-phase initialization."
msgstr "다단계 초기화에 대한 자세한 내용은 :PEP:`489`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:351
msgid "Low-level module creation functions"
msgstr "저수준 모듈 생성 함수"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:353
msgid ""
"The following functions are called under the hood when using multi-phase "
"initialization. They can be used directly, for example when creating "
"module objects dynamically. Note that both ``PyModule_FromDefAndSpec`` "
"and ``PyModule_ExecDef`` must be called to fully initialize a module."
msgstr ""
"다단계 초기화를 사용할 때 수면 아래에서는 다음 함수가 호출됩니다. 이들은 직접 사용할 수 있는데, 예를 들어 모듈 객체를 동적으로"
" 생성할 때 그렇습니다. 모듈을 완전히 초기화하려면 ``PyModule_FromDefAndSpec``\\과 "
"``PyModule_ExecDef``\\를 모두 호출해야 함에 유의하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:360
msgid ""
"Create a new module object, given the definition in *module* and the "
"ModuleSpec *spec*.  This behaves like :c:func:`PyModule_FromDefAndSpec2` "
"with *module_api_version* set to :const:`PYTHON_API_VERSION`."
msgstr ""
"주어진 *모듈*\\의 정의와 ModuleSpec *spec*\\으로 새 모듈 객체를 만듭니다. 이것은 "
"*module_api_version*\\이 :const:`PYTHON_API_VERSION`\\으로 설정된 "
":c:func:`PyModule_FromDefAndSpec2`\\처럼 동작합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:368
msgid ""
"Create a new module object, given the definition in *module* and the "
"ModuleSpec *spec*, assuming the API version *module_api_version*. If that"
" version does not match the version of the running interpreter, a "
":exc:`RuntimeWarning` is emitted."
msgstr ""
"API 버전 *module_api_version*\\을 가정하여, 주어진 *모듈*\\의 정의와 ModuleSpec "
"*spec*\\으로 새 모듈 객체를 만듭니다. 해당 버전이 실행 중인 인터프리터 버전과 일치하지 않으면, "
":exc:`RuntimeWarning`\\을 발생시킵니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:375
msgid ""
"Most uses of this function should be using "
":c:func:`PyModule_FromDefAndSpec` instead; only use this if you are sure "
"you need it."
msgstr ""
"이 함수는 대부분 :c:func:`PyModule_FromDefAndSpec`\\을 대신 사용해야 합니다; 확실히 필요할 때만 "
"사용하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:382
msgid "Process any execution slots (:c:data:`Py_mod_exec`) given in *def*."
msgstr "*def*\\에 지정된 모든 실행 슬롯(:c:data:`Py_mod_exec`)을 처리합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:388
msgid ""
"Set the docstring for *module* to *docstring*. This function is called "
"automatically when creating a module from ``PyModuleDef``, using either "
"``PyModule_Create`` or ``PyModule_FromDefAndSpec``."
msgstr ""
"*module*\\의 독스트링을 *docstring*\\으로 설정합니다. 이 함수는 ``PyModule_Create``\\나 "
"``PyModule_FromDefAndSpec``\\을 사용하여 ``PyModuleDef``\\에서 모듈을 만들 때 자동으로 "
"호출됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:397
msgid ""
"Add the functions from the ``NULL`` terminated *functions* array to "
"*module*. Refer to the :c:type:`PyMethodDef` documentation for details on"
" individual entries (due to the lack of a shared module namespace, module"
" level \"functions\" implemented in C typically receive the module as "
"their first parameter, making them similar to instance methods on Python "
"classes). This function is called automatically when creating a module "
"from ``PyModuleDef``, using either ``PyModule_Create`` or "
"``PyModule_FromDefAndSpec``."
msgstr ""
"``NULL`` 종료 *functions* 배열의 함수를 *module*\\에 추가합니다. 개별 항목에 대한 자세한 내용은 "
":c:type:`PyMethodDef` 설명서를 참조하십시오 (공유 모듈 이름 공간이 없기 때문에, C로 구현된 모듈 수준 "
"\"함수(functions)\"는 일반적으로 첫 번째 매개 변수로 모듈을 수신하여, 파이썬 클래스의 인스턴스 메서드와 유사하게 "
"만듭니다). 이 함수는 ``PyModule_Create``\\나 ``PyModule_FromDefAndSpec``\\을 사용하여 "
"``PyModuleDef``\\에서 모듈을 만들 때 자동으로 호출됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:409
msgid "Support functions"
msgstr "지원 함수"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:411
msgid ""
"The module initialization function (if using single phase initialization)"
" or a function called from a module execution slot (if using multi-phase "
"initialization), can use the following functions to help initialize the "
"module state:"
msgstr ""
"모듈 초기화 함수(단단계 초기화를 사용하는 경우)나 모듈 실행 슬롯에서 호출되는 함수(다단계 초기화를 사용하는 경우)는, 모듈 상태"
" 초기화를 도우려고 다음 함수를 사용할 수 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:418
msgid ""
"Add an object to *module* as *name*.  This is a convenience function "
"which can be used from the module's initialization function.  This steals"
" a reference to *value* on success.  Return ``-1`` on error, ``0`` on "
"success."
msgstr ""
"*name*\\으로 *module*\\에 객체를 추가합니다. 모듈의 초기화 함수에서 사용할 수 있는 편의 함수입니다. 성공 시 "
"*value*\\에 대한 참조를 훔칩니다. 에러 시 ``-1``\\을, 성공하면 ``0``\\을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:424
msgid ""
"Unlike other functions that steal references, ``PyModule_AddObject()`` "
"only decrements the reference count of *value* **on success**."
msgstr ""
"참조를 훔치는 다른 함수와 달리, ``PyModule_AddObject()``\\는 **성공 시**\\에만 *value*\\의 참조"
" 횟수를 감소시킵니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:427
msgid ""
"This means that its return value must be checked, and calling code must "
":c:func:`Py_DECREF` *value* manually on error. Example usage::"
msgstr ""
"이는 반환 값을 확인해야 하며, 에러 시 호출하는 코드가 수동으로 *value*\\를 :c:func:`Py_DECREF` 해야 함을"
" 뜻합니다. 사용법 예::"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:439
msgid ""
"Add an integer constant to *module* as *name*.  This convenience function"
" can be used from the module's initialization function. Return ``-1`` on "
"error, ``0`` on success."
msgstr ""
"*module*\\에 정수 상수를 *name*\\으로 추가합니다. 이 편의 함수는 모듈의 초기화 함수에서 사용할 수 있습니다. 에러"
" 시 ``-1``\\을, 성공하면 ``0``\\을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:446
msgid ""
"Add a string constant to *module* as *name*.  This convenience function "
"can be used from the module's initialization function.  The string "
"*value* must be ``NULL``-terminated.  Return ``-1`` on error, ``0`` on "
"success."
msgstr ""
"*module*\\에 문자열 상수를 *name*\\으로 추가합니다. 이 편의 함수는 모듈의 초기화 함수에서 사용할 수 있습니다. "
"문자열 *value*\\는 ``NULL``\\로 끝나야 합니다. 에러 시 ``-1``\\을, 성공 시 ``0``\\을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:453
msgid ""
"Add an int constant to *module*. The name and the value are taken from "
"*macro*. For example ``PyModule_AddIntMacro(module, AF_INET)`` adds the "
"int constant *AF_INET* with the value of *AF_INET* to *module*. Return "
"``-1`` on error, ``0`` on success."
msgstr ""
"*module*\\에 int 상수를 추가합니다. 이름과 값은 *macro*\\에서 취합니다. 예를 들어 "
"``PyModule_AddIntMacro(module, AF_INET)``\\은 *AF_INET* 값을 가진 int 상수 "
"*AF_INET*\\을 *module*\\에 추가합니다. 에러 시 ``-1``\\을, 성공하면 ``0``\\을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:461
msgid "Add a string constant to *module*."
msgstr "*module*\\에 문자열 상수를 추가합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:465
msgid "Module lookup"
msgstr "모듈 조회"

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:467
msgid ""
"Single-phase initialization creates singleton modules that can be looked "
"up in the context of the current interpreter. This allows the module "
"object to be retrieved later with only a reference to the module "
"definition."
msgstr ""
"단단계 초기화는 현재 인터프리터의 컨텍스트에서 조회할 수 있는 싱글톤 모듈을 만듭니다. 이는 나중에 모듈 정의에 대한 참조만으로 "
"모듈 객체를 검색할 수 있도록 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:471
msgid ""
"These functions will not work on modules created using multi-phase "
"initialization, since multiple such modules can be created from a single "
"definition."
msgstr ""
"이 함수들은 다단계 초기화를 사용하여 만들어진 모듈에서는 작동하지 않습니다. 단일 정의에서 그러한 모듈이 여러 개 만들어질 수 있기"
" 때문입니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:476
msgid ""
"Returns the module object that was created from *def* for the current "
"interpreter. This method requires that the module object has been "
"attached to the interpreter state with :c:func:`PyState_AddModule` "
"beforehand. In case the corresponding module object is not found or has "
"not been attached to the interpreter state yet, it returns ``NULL``."
msgstr ""
"현재 인터프리터에 대해 *def*\\에서 만들어진 모듈 객체를 반환합니다. 이 메서드를 사용하려면 먼저 모듈 객체가 "
":c:func:`PyState_AddModule`\\로 인터프리터 상태에 연결되어 있어야 합니다. 해당 모듈 객체를 찾을 수 없거나"
" 인터프리터 상태에 아직 연결되지 않았으면, ``NULL``\\을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:483
msgid ""
"Attaches the module object passed to the function to the interpreter "
"state. This allows the module object to be accessible via "
":c:func:`PyState_FindModule`."
msgstr ""
"함수에 전달된 모듈 객체를 인터프리터 상태에 연결합니다. 이는 :c:func:`PyState_FindModule`\\을 통해 모듈 "
"객체에 액세스 할 수 있도록 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:486
msgid "Only effective on modules created using single-phase initialization."
msgstr "단단계 초기화를 사용하여 만든 모듈에만 효과가 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:488
msgid ""
"Python calls ``PyState_AddModule`` automatically after importing a "
"module, so it is unnecessary (but harmless) to call it from module "
"initialization code. An explicit call is needed only if the module's own "
"init code subsequently calls ``PyState_FindModule``. The function is "
"mainly intended for implementing alternative import mechanisms (either by"
" calling it directly, or by referring to its implementation for details "
"of the required state updates)."
msgstr ""
"파이썬은 모듈을 임포트 한 후 자동으로 ``PyState_AddModule``\\을 호출하므로, 모듈 초기화 코드에서 호출하는 것은"
" 불필요합니다 (하지만 무해합니다). 모듈의 자체 초기화 코드가 추후 ``PyState_FindModule``\\을 호출하는 "
"경우에만 명시적인 호출이 필요합니다. 이 함수는 주로 대안 임포트 메커니즘을 구현하기 위한 것입니다 (직접 호출하거나, 필요한 상태"
" 갱신에 대한 자세한 내용에 대해 해당 구현을 참조함으로써)."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:496
msgid "Return 0 on success or -1 on failure."
msgstr "성공하면 0을, 실패하면 -1을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/c-api/module.rst:502
msgid ""
"Removes the module object created from *def* from the interpreter state. "
"Return 0 on success or -1 on failure."
msgstr "*def*\\에서 만들어진 모듈 객체를 인터프리터 상태에서 제거합니다. 성공하면 0을, 실패하면 -1을 반환합니다."

