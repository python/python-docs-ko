# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-23 11:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/reference/simple_stmts.rst:6
msgid "Simple statements"
msgstr "단순문(Simple statements)"

#: ../Doc/reference/simple_stmts.rst:10
msgid ""
"A simple statement is comprised within a single logical line. Several "
"simple statements may occur on a single line separated by semicolons.  "
"The syntax for simple statements is:"
msgstr ""
"단순문은 하나의 논리적인 줄 안에 구성된다. 여러 개의 단순문이 세미콜론으로 분리되어 하나의 줄에 나올 수 있다. 단순문의 문법은 "
"이렇다:"

#: ../Doc/reference/simple_stmts.rst:35
msgid "Expression statements"
msgstr "표현식 문"

#: ../Doc/reference/simple_stmts.rst:42
msgid ""
"Expression statements are used (mostly interactively) to compute and "
"write a value, or (usually) to call a procedure (a function that returns "
"no meaningful result; in Python, procedures return the value ``None``).  "
"Other uses of expression statements are allowed and occasionally useful."
"  The syntax for an expression statement is:"
msgstr ""
"표현식 문은 값을 계산하고 출력하거나, (보통) 프로시저(procedure) (의미 없는 결과를 돌려주는 함수;"
" 파이썬에서 프로시저는 ``None`` 값을 돌려준다)를 호출하기 위해 (대부분 대화형으로) 사용된다. 표현식 문의 다른 사용도 허락되고 때때로 쓸모가 "
"있다."

#: ../Doc/reference/simple_stmts.rst:51
msgid ""
"An expression statement evaluates the expression list (which may be a "
"single expression)."
msgstr "표현식 문은 (하나의 표현식일 수 있는) 표현식 목록의 값을 구한다."

#: ../Doc/reference/simple_stmts.rst:63
msgid ""
"In interactive mode, if the value is not ``None``, it is converted to a "
"string using the built-in :func:`repr` function and the resulting string "
"is written to standard output on a line by itself (except if the result "
"is ``None``, so that procedure calls do not cause any output.)"
msgstr ""
"대화형 모드에서, 값이 ``None`` 이 아니면, 내장 :func:`repr` 함수를 사용해 문자열로 변환되고, 그렇게 나온 "
"문자열을 별도의 줄에 표준 출력으로 보낸다 (결과가 ``None`` 일 때는 그렇지 않아서, 프로시저 호출은 어떤 출력도 만들지 "
"않는다.),"

#: ../Doc/reference/simple_stmts.rst:71
msgid "Assignment statements"
msgstr "대입문"

#: ../Doc/reference/simple_stmts.rst:81
msgid ""
"Assignment statements are used to (re)bind names to values and to modify "
"attributes or items of mutable objects:"
msgstr "대입문은 이름을 값에 (재)연결하고 가변 객체의 어트리뷰트나 항목들을 수정한다."

#: ../Doc/reference/simple_stmts.rst:95
msgid ""
"(See section :ref:`primaries` for the syntax definitions for "
"*attributeref*, *subscription*, and *slicing*.)"
msgstr ""
"(*attributeref*, *subscription*, *slicing* 의 문법 정의는 :ref:`primaries` 섹션을 "
"보면 된다.)"

#: ../Doc/reference/simple_stmts.rst:98
msgid ""
"An assignment statement evaluates the expression list (remember that this"
" can be a single expression or a comma-separated list, the latter "
"yielding a tuple) and assigns the single resulting object to each of the "
"target lists, from left to right."
msgstr ""
"대입문은 표현식 목록 (이것이 하나의 표현식일 수도, 쉼표로 분리된 목록일 수도 있는데, 후자의 경우는 튜플이 만들어진다는 것을 "
"기억하라) 의 값을 구하고, 왼쪽에서 오른쪽으로, 하나의 결과 객체를 타깃 목록의 각각에 대입한다."

#: ../Doc/reference/simple_stmts.rst:107
msgid ""
"Assignment is defined recursively depending on the form of the target "
"(list). When a target is part of a mutable object (an attribute "
"reference, subscription or slicing), the mutable object must ultimately "
"perform the assignment and decide about its validity, and may raise an "
"exception if the assignment is unacceptable.  The rules observed by "
"various types and the exceptions raised are given with the definition of "
"the object types (see section :ref:`types`)."
msgstr ""
"대입은 타깃 (목록)의 형태에 따라 재귀적으로 정의된다. 타깃이 가변 객체의 일부 (어트리뷰트 참조나 서브스크립션이나 슬라이싱) "
"면, 가변 객체가 최종적으로 대입을 수행해야만 하고, 그것이 올바른지 아닌지를 결정하고, 대입이 받아들여질 수 없으면 예외를 일으킬"
" 수 있다. 다양한 형들이 주시하는 규칙들과 발생하는 예외들은 그 객체 형의 정의에서 주어진다 (:ref:`types` 섹션을 "
"보라)."

#: ../Doc/reference/simple_stmts.rst:116
msgid ""
"Assignment of an object to a target list, optionally enclosed in "
"parentheses or square brackets, is recursively defined as follows."
msgstr "객체를 타깃 목록, 괄호나 꺾쇠괄호로 둘러싸일 수 있는데 생략할 수 있다, 에 대입하는 것은 다음과 같이 재귀적으로 정의된다."

#: ../Doc/reference/simple_stmts.rst:119
msgid "If the target list is empty: The object must also be an empty iterable."
msgstr "타깃 목록이 비어있으면: 객체는 빈 이터러블여야만 한다."

#: ../Doc/reference/simple_stmts.rst:121
msgid ""
"If the target list is a single target in parentheses: The object is "
"assigned to that target."
msgstr "타깃 목록이 괄호에 들어있는 하나의 타깃이면: 객체는 타깃에 대입된다."

#: ../Doc/reference/simple_stmts.rst:124
msgid ""
"If the target list is a comma-separated list of targets, or a single "
"target in square brackets: The object must be an iterable with the same "
"number of items as there are targets in the target list, and the items "
"are assigned, from left to right, to the corresponding targets."
msgstr ""
"타깃 목록이 타깃들의 쉼표로 분리된 목록이거나 꺾쇠괄호로 둘러싸인 하나의 타깃이면: 객체는 타깃 목록에 들어있는 타깃의 수와 같은"
" 수의 항목들을 제공하는 이터러블이어야 하고, 왼쪽에서 오른쪽으로 항목들이 대응하는 타깃에 대입된다."

#: ../Doc/reference/simple_stmts.rst:129
msgid ""
"If the target list contains one target prefixed with an asterisk, called "
"a \"starred\" target: The object must be an iterable with at least as "
"many items as there are targets in the target list, minus one.  The first"
" items of the iterable are assigned, from left to right, to the targets "
"before the starred target.  The final items of the iterable are assigned "
"to the targets after the starred target.  A list of the remaining items "
"in the iterable is then assigned to the starred target (the list can be "
"empty)."
msgstr ""
"타깃 목록이 애스터리스크(asterisk)를 앞에 붙인 타깃, \"스타드(starred)\" 타깃이라고 불린다, 하나를 포함하면:"
" 객체는 적어도 타깃 목록에 나오는 타깃의 수보다 하나 작은 개수의 항목을 제공하는 이터러블이어야 한다. 이터러블의 처음 항목들은,"
" 왼쪽에서 오른쪽으로, 스타드 타깃 앞에 나오는 타깃들에 대입된다. 이터러블의 마지막 항목들은 스타드 타깃 뒤에 나오는 타깃들에 "
"대입된다. 이터러블의 나머지 항목들로 구성된 리스트가 스타드 타깃에 대입된다 (이 리스트는 이어있을 수 있다)."

#: ../Doc/reference/simple_stmts.rst:137
msgid ""
"Else: The object must be an iterable with the same number of items as "
"there are targets in the target list, and the items are assigned, from "
"left to right, to the corresponding targets."
msgstr ""
"그렇지 않으면: 객체는 타깃 목록에 나오는 타깃의 수와 같은 수의 항목들을 제공하는 이터러블이어야 하고, 항목들은, 왼쪽에서 "
"오른쪽으로, 대응하는 타깃들에 대입된다."

#: ../Doc/reference/simple_stmts.rst:141
msgid ""
"Assignment of an object to a single target is recursively defined as "
"follows."
msgstr "하나의 타깃에 대한 객체의 대입은 다음과 같이 재귀적으로 정의된다."

#: ../Doc/reference/simple_stmts.rst:143
msgid "If the target is an identifier (name):"
msgstr "타깃이 식별자 (이름) 면:"

#: ../Doc/reference/simple_stmts.rst:145
msgid ""
"If the name does not occur in a :keyword:`global` or :keyword:`nonlocal` "
"statement in the current code block: the name is bound to the object in "
"the current local namespace."
msgstr ""
"그 이름이 현재 코드 블록에 있는 :keyword:`global` 나 :keyword:`nonlocal` 문에 등장하지 않으면: 그"
" 이름은 현재 지역 이름 공간에서 객체에 연결된다."

#: ../Doc/reference/simple_stmts.rst:149
msgid ""
"Otherwise: the name is bound to the object in the global namespace or the"
" outer namespace determined by :keyword:`nonlocal`, respectively."
msgstr ""
"그렇지 않으면: 그 이름은 각각 전역 이름 공간이나 :keyword:`nonlocal` 에 의해 결정되는 외부 이름 공간에서 객체에 "
"연결된다."

#: ../Doc/reference/simple_stmts.rst:154
msgid ""
"The name is rebound if it was already bound.  This may cause the "
"reference count for the object previously bound to the name to reach "
"zero, causing the object to be deallocated and its destructor (if it has "
"one) to be called."
msgstr ""
"그 이름이 이미 연결되어 있으면 재연결된다. 이것은 기존에 연결되어 있던 객체의 참조 횟수가 0이 되도록 만들어서, 객체가 "
"점유하던 메모리가 반납되고 파괴자(destructor) (갖고 있다면) 가 호출되도록 만들 수 있다."

#: ../Doc/reference/simple_stmts.rst:160
msgid ""
"If the target is an attribute reference: The primary expression in the "
"reference is evaluated.  It should yield an object with assignable "
"attributes; if this is not the case, :exc:`TypeError` is raised.  That "
"object is then asked to assign the assigned object to the given "
"attribute; if it cannot perform the assignment, it raises an exception "
"(usually but not necessarily :exc:`AttributeError`)."
msgstr ""
"타깃이 어트리뷰트 참조면: 참조의 프라이머리 표현식의 값을 구한다. 이것은 대입 가능한 어트리뷰트를 가진 객체를 주어야 "
"하는데, 그렇지 않으면 :exc:`TypeError` 가 일어난다. 그에 그 객체에 주어진 어트리뷰트로 객체를 대입하도록 "
"요청한다; 대입을 수행할 수 없다면 예외 (보통 :exc:`AttributeError` 이지만, 꼭 그럴 필요는 없다) 를 "
"일으킨다."

#: ../Doc/reference/simple_stmts.rst:169
msgid ""
"Note: If the object is a class instance and the attribute reference "
"occurs on both sides of the assignment operator, the RHS expression, "
"``a.x`` can access either an instance attribute or (if no instance "
"attribute exists) a class attribute.  The LHS target ``a.x`` is always "
"set as an instance attribute, creating it if necessary.  Thus, the two "
"occurrences of ``a.x`` do not necessarily refer to the same attribute: if"
" the RHS expression refers to a class attribute, the LHS creates a new "
"instance attribute as the target of the assignment::"
msgstr ""
"주의 사항: 객체가 클래스 인스턴스이고 어트리뷰트 참조가 대입 연산자의 양쪽에서 모두 등장하면, RHS 표현식, ``a.x`` 는 "
"인스턴스 어트리뷰트나 (인스턴스 어트리뷰트가 없다면) 클래스 어트리뷰트를 액세스할 수 있다. LHS 타깃 ``a.x`` 는 항상 "
"필요하면 만들어서라도 항상 인스턴스 어트리뷰트를 설정한다. 그래서, 두 ``a.x`` 가 같은 어트리뷰트를 가리키는 것은 필요조건이"
" 아니다: RHS 표현식이 클래스 어트리뷰트를 가리킨다면, LHS 는 대입의 타깃으로 새 인스턴스 어트리뷰트를 만든다::"

#: ../Doc/reference/simple_stmts.rst:183
msgid ""
"This description does not necessarily apply to descriptor attributes, "
"such as properties created with :func:`property`."
msgstr "이 설명이 :func:`property` 로 만들어진 프로퍼티(property)와 같은 디스크립터 어트리뷰트에 적용될 필요는 없다."

#: ../Doc/reference/simple_stmts.rst:190
msgid ""
"If the target is a subscription: The primary expression in the reference "
"is evaluated.  It should yield either a mutable sequence object (such as "
"a list) or a mapping object (such as a dictionary).  Next, the subscript "
"expression is evaluated."
msgstr ""
"타깃이 서브스크립션이면: 참조에 있는 프라이머리 표현식의 값을 구한다. (리스트 같은) 가변 시퀀스 객체나 (딕셔너리 같은) 매핑 "
"객체가 나와야 한다. 그런 다음, 서브 스크립트 표현식의 값을 구한다."

#: ../Doc/reference/simple_stmts.rst:199
msgid ""
"If the primary is a mutable sequence object (such as a list), the "
"subscript must yield an integer.  If it is negative, the sequence's "
"length is added to it.  The resulting value must be a nonnegative integer"
" less than the sequence's length, and the sequence is asked to assign the"
" assigned object to its item with that index.  If the index is out of "
"range, :exc:`IndexError` is raised (assignment to a subscripted sequence "
"cannot add new items to a list)."
msgstr ""
"프라이머리가 (리스트 같은) 가변 시퀀스 객체면, 서브 스크립트는 정수가 나와야 한다. 음수면, 시퀀스의 길이가 더해진다. 결괏값은"
" 시퀀스의 길이보다 작은 음이 아닌 정수여야 하고, 시퀀스에 그 인덱스를 가진 항목에 객체를 대입하라고 요청한다. 인덱스가 "
"범위를 벗어나면, :exc:`IndexError` 를 일으킨다 (서브 스크립트 된 시퀀스에 대한 대입은 리스트에 새 항목을 추가할 수 "
"없다)."

#: ../Doc/reference/simple_stmts.rst:210
msgid ""
"If the primary is a mapping object (such as a dictionary), the subscript "
"must have a type compatible with the mapping's key type, and the mapping "
"is then asked to create a key/datum pair which maps the subscript to the "
"assigned object.  This can either replace an existing key/value pair with"
" the same key value, or insert a new key/value pair (if no key with the "
"same value existed)."
msgstr ""
"프라이머리가 (딕셔너리 같은) 매핑 객체면, 서브 스크립트는 매핑의 키 형과 호환되는 형이어야 하고, 매핑에 그 서브 스크립트를 객체에"
" 매핑하는 키/데이터 쌍을 만들도록 요청한다. 이때 같은 킷값을 갖는 기존의 키/값 쌍을 대체할 수도 있고, (같은 값의 키가 "
"존재하지 않는 경우) 새 키/값 쌍을 삽입할 수도 있다."

#: ../Doc/reference/simple_stmts.rst:216
msgid ""
"For user-defined objects, the :meth:`__setitem__` method is called with "
"appropriate arguments."
msgstr "사용자 정의 객체의 경우는, 적절한 인자로 :meth:`__setitem__` 메서드가 호출된다."

#: ../Doc/reference/simple_stmts.rst:221
msgid ""
"If the target is a slicing: The primary expression in the reference is "
"evaluated.  It should yield a mutable sequence object (such as a list).  "
"The assigned object should be a sequence object of the same type.  Next, "
"the lower and upper bound expressions are evaluated, insofar they are "
"present; defaults are zero and the sequence's length.  The bounds should "
"evaluate to integers. If either bound is negative, the sequence's length "
"is added to it.  The resulting bounds are clipped to lie between zero and"
" the sequence's length, inclusive.  Finally, the sequence object is asked"
" to replace the slice with the items of the assigned sequence.  The "
"length of the slice may be different from the length of the assigned "
"sequence, thus changing the length of the target sequence, if the target "
"sequence allows it."
msgstr ""
"타깃이 슬라이싱이면: 참조의 프라이머리 표현식의 값을 구한다. (리스트 같은) 가변 시퀀스 객체가 나와야 한다. 대입되는 객체는 "
"같은 형의 시퀀스 객체야 한다. 그런 다음, 존재한다면 하한과 상한 표현식의 값을 구한다; 기본값은 0과 시퀀스의 길이다. "
"경곗값은 정수가 되어야 한다. 둘 중 어느 것이건 음수가 나오면, 시퀀스의 길이를 더한다. 그렇게 얻어진 경곗값들을 0과 시퀀스의 "
"길이나 그 사이에 들어가는 값이 되도록 자른다. 마지막으로 시퀀스 객체에 슬라이스를 대입되는 시퀀스로 변경하도록 요청한다. 타깃 "
"시퀀스가 허락한다면, 슬라이스의 길이는 대입되는 시퀀스의 길이와 다를 수 있다."

#: ../Doc/reference/simple_stmts.rst:235
msgid ""
"In the current implementation, the syntax for targets is taken to be the "
"same as for expressions, and invalid syntax is rejected during the code "
"generation phase, causing less detailed error messages."
msgstr ""
"현재 구현에서, 타깃의 문법은 표현식과 같게 유지되고, 잘못된 문법은 코드 생성 단계에서 거부되기 때문에 에러 메시지가 덜 "
"상세해지는 결과를 낳고 있다."

#: ../Doc/reference/simple_stmts.rst:239
msgid ""
"Although the definition of assignment implies that overlaps between the "
"left-hand side and the right-hand side are 'simultaneous' (for example "
"``a, b = b, a`` swaps two variables), overlaps *within* the collection of"
" assigned-to variables occur left-to-right, sometimes resulting in "
"confusion.  For instance, the following program prints ``[0, 2]``::"
msgstr ""
"설사 대입의 정의가 좌변과 우변 간의 중첩이 '동시적(simultaneous)'임을 (예를 들어, ``a, b = b, a`` 는 두"
" 변수를 교환한다) 암시해도, 대입되는 변수들의 컬렉션 *안* 에서의 중첩은 왼쪽에서 오른쪽으로 일어나서, 때로 혼동할 수 있는 "
"결과를 낳는다. 예를 들어, 다음과 같은 프로그램은 ``[0, 2]`` 를 인쇄한다::"

#: ../Doc/reference/simple_stmts.rst:253
msgid ":pep:`3132` - Extended Iterable Unpacking"
msgstr ":pep:`3132` - 확장 이터러블 언 패킹"

#: ../Doc/reference/simple_stmts.rst:254
msgid "The specification for the ``*target`` feature."
msgstr "``*target`` 기능에 대한 규격"

#: ../Doc/reference/simple_stmts.rst:260
msgid "Augmented assignment statements"
msgstr "증분 대입문(Augmented assignment statements)"

#: ../Doc/reference/simple_stmts.rst:278
msgid ""
"Augmented assignment is the combination, in a single statement, of a "
"binary operation and an assignment statement:"
msgstr "증분 대입문은 한 문장에서 이항 연산과 대입문을 합치는 것이다:"

#: ../Doc/reference/simple_stmts.rst:287
msgid ""
"(See section :ref:`primaries` for the syntax definitions of the last "
"three symbols.)"
msgstr "(마지막 세 기호의 문법 정의는 :ref:`primaries` 섹션을 보면 된다.)"

#: ../Doc/reference/simple_stmts.rst:290
msgid ""
"An augmented assignment evaluates the target (which, unlike normal "
"assignment statements, cannot be an unpacking) and the expression list, "
"performs the binary operation specific to the type of assignment on the "
"two operands, and assigns the result to the original target.  The target "
"is only evaluated once."
msgstr ""
"증분 대입은 타깃 (일반 대입문과는 달리 언 패킹이 될 수 없다) 과 표현식 목록의 값을 구하고, 둘을 피연산자로 삼아 대입의 형에 "
"맞는 이항 연산을 수행한 후, 원래의 타깃에 그 결과를 대입한다. 타깃은 오직 한 번만 값이 구해진다."

#: ../Doc/reference/simple_stmts.rst:295
msgid ""
"An augmented assignment expression like ``x += 1`` can be rewritten as "
"``x = x + 1`` to achieve a similar, but not exactly equal effect. In the "
"augmented version, ``x`` is only evaluated once. Also, when possible, the"
" actual operation is performed *in-place*, meaning that rather than "
"creating a new object and assigning that to the target, the old object is"
" modified instead."
msgstr ""
"``x += 1`` 과 같은 증분 대입 표현은 ``x = x + 1`` 처럼 다시 쓸 수 있는데, 정확히 같은 효과는 아니지만 "
"비슷한 결과를 준다. 증분 버전에서는, ``x`` 의 값을 오직 한 번만 구한다. 또한, 가능할 때, 실제 연산은 *제자리(in-"
"place)* 에서 수행되는데, 새 객체를 만들고 그것을 타깃에 대입하기보다는, 예전 객체를 수정한다는 의미다."

#: ../Doc/reference/simple_stmts.rst:301
msgid ""
"Unlike normal assignments, augmented assignments evaluate the left-hand "
"side *before* evaluating the right-hand side.  For example, ``a[i] += "
"f(x)`` first looks-up ``a[i]``, then it evaluates ``f(x)`` and performs "
"the addition, and lastly, it writes the result back to ``a[i]``."
msgstr ""
"일반 대입과는 달리, 증분 대입은 우변의 값을 구하기 *이전에* 좌변의 값을 구한다. 예를 들어, ``a[i] += f(x)`` 는"
" 처음에 ``a[i]`` 를 조회한 다음, ``f(x)`` 의 값을 구하고, 덧셈을 수행하고, 마지막으로 그 결과를 ``a[i]`` "
"에 다시 쓴다."

#: ../Doc/reference/simple_stmts.rst:306
msgid ""
"With the exception of assigning to tuples and multiple targets in a "
"single statement, the assignment done by augmented assignment statements "
"is handled the same way as normal assignments. Similarly, with the "
"exception of the possible *in-place* behavior, the binary operation "
"performed by augmented assignment is the same as the normal binary "
"operations."
msgstr ""
"하나의 문장에서 튜플과 다중 타깃으로 대입하는 것을 예외로 하면, 증분 대입문에 의한 대입은 일반 대입과 같은 방법으로 처리된다. "
"마찬가지로, *제자리* 동작의 가능성을 예외로 하면, 증분 대입 때문에 수행되는 이진 연산은 일반 이진 연산과 같다."

#: ../Doc/reference/simple_stmts.rst:312
msgid ""
"For targets which are attribute references, the same :ref:`caveat about "
"class and instance attributes <attr-target-note>` applies as for regular "
"assignments."
msgstr ""
"어트리뷰트 참조인 타깃의 경우, 일반 대입처럼 :ref:`클래스와 인스턴스 어트리뷰트에 관한 경고 <attr-target-"
"note>` 가 적용된다."

#: ../Doc/reference/simple_stmts.rst:319
msgid "Annotated assignment statements"
msgstr "어노테이트된 대입문(Annotated assignment statements)"

#: ../Doc/reference/simple_stmts.rst:325
msgid ""
"Annotation assignment is the combination, in a single statement, of a "
"variable or attribute annotation and an optional assignment statement:"
msgstr "어노테이션 대입은, 한 문장에서, 변수나 어트리뷰트 어노테이션과 생략할 수 있는 대입문을 합치는 것이다."

#: ../Doc/reference/simple_stmts.rst:331
msgid ""
"The difference from normal :ref:`assignment` is that only single target "
"and only single right hand side value is allowed."
msgstr "일반 :ref:`assignment` 과의 차이점은 오직 하나의 타깃과 오직 하나의 우변 값만 허락된다는 것이다."

#: ../Doc/reference/simple_stmts.rst:334
msgid ""
"For simple names as assignment targets, if in class or module scope, the "
"annotations are evaluated and stored in a special class or module "
"attribute :attr:`__annotations__` that is a dictionary mapping from "
"variable names (mangled if private) to evaluated annotations. This "
"attribute is writable and is automatically created at the start of class "
"or module body execution, if annotations are found statically."
msgstr ""
"대인 타깃에 단순한 이름을 쓰는 경우, 클래스나 모듈 스코프에 있으면, 어노테이션은 값이 구해진 후 특별한 클래스나 모듈의 어트리뷰트"
" :attr:`__annotations__` 에 저장되는데, 이 어트리뷰트는 (만약 비공개면 뒤섞인) 변수 이름을 어노테이션의 "
"값으로 대응시키는 딕셔너리 매핑이다. 이 어트리뷰트는 쓰기가 허락되고, 클래스나 모듈의 실행을 시작할 때 어노테이션이 정적으로 "
"발견되면 만들어진다."

#: ../Doc/reference/simple_stmts.rst:342
msgid ""
"For expressions as assignment targets, the annotations are evaluated if "
"in class or module scope, but not stored."
msgstr "대입 타깃으로 표현식을 쓸 때, 어노테이션은 클래스나 모듈 스코프에 있는 것처럼 값이 구해지지만 저장되지는 않는다."

#: ../Doc/reference/simple_stmts.rst:345
msgid ""
"If a name is annotated in a function scope, then this name is local for "
"that scope. Annotations are never evaluated and stored in function "
"scopes."
msgstr ""
"이름이 함수 스코프에서 어노테이트되면, 이 이름은 그 스코프에 지역적(local)이다. 함수 스코프에서 어노테이션은 값이 구해지거나 "
"저장되지 않는다."

#: ../Doc/reference/simple_stmts.rst:348
msgid ""
"If the right hand side is present, an annotated assignment performs the "
"actual assignment before evaluating annotations (where applicable). If "
"the right hand side is not present for an expression target, then the "
"interpreter evaluates the target except for the last :meth:`__setitem__` "
"or :meth:`__setattr__` call."
msgstr ""
"우변이 존재하면, 어노테이트된 대입은 (적절한 곳에서) 어노테이션의 값을 구하기 전에 실제 대입을 수행한다. 표현식 타깃의 경우 "
"우변이 존재하지 않으면, 인터프리터는 티깃의 값을 구하는데, 마지막 :meth:`__setitem__` 이나 "
":meth:`__setattr__` 호출은 생략한다."

#: ../Doc/reference/simple_stmts.rst:356
msgid ""
":pep:`526` - Variable and attribute annotation syntax :pep:`484` - Type "
"hints"
msgstr ":pep:`526` - 변수와 어트리뷰트 어노테이션 문법 :pep:`484` - 형 힌트"

#: ../Doc/reference/simple_stmts.rst:363
msgid "The :keyword:`assert` statement"
msgstr ":keyword:`assert` 문"

#: ../Doc/reference/simple_stmts.rst:369
msgid ""
"Assert statements are a convenient way to insert debugging assertions "
"into a program:"
msgstr "assert 문은 프로그램에 디버깅 어서션(debugging assertion)을 삽입하는 편리한 방법이다:"

#: ../Doc/reference/simple_stmts.rst:375
msgid "The simple form, ``assert expression``, is equivalent to ::"
msgstr "간단한 형태, ``assert expression`` 은 다음과 동등하다 ::"

#: ../Doc/reference/simple_stmts.rst:380
msgid ""
"The extended form, ``assert expression1, expression2``, is equivalent to "
"::"
msgstr "확장된 형태, ``assert expression1, expression2`` 는 다음과 동등하다 ::"

#: ../Doc/reference/simple_stmts.rst:389
msgid ""
"These equivalences assume that :const:`__debug__` and "
":exc:`AssertionError` refer to the built-in variables with those names.  "
"In the current implementation, the built-in variable :const:`__debug__` "
"is ``True`` under normal circumstances, ``False`` when optimization is "
"requested (command line option -O).  The current code generator emits no "
"code for an assert statement when optimization is requested at compile "
"time.  Note that it is unnecessary to include the source code for the "
"expression that failed in the error message; it will be displayed as part"
" of the stack trace."
msgstr ""
"이 동등성 들은 :const:`__debug__` 과 :exc:`AssertionError` 가 같은 이름의 내장 변수들을 "
"가리킨다고 가정한다. 현재 구현에서, 내장 변수 :const:`__debug__` 은 일반적인 상황에서 ``True`` 이고, "
"최적화가 요청되었을 때 (명령행 옵션 -O) ``False`` 다. 현재의 코드 생성기는 컴파일 시점에 최적화가 요청되면 "
"assert 문을 위한 코드를 만들지 않는다. 에러 메시지에 실패한 표현식의 소스 코드를 포함할 필요가 없음에 주의하라; 그것은"
" 스택 트레이스의 일부로 출력된다."

#: ../Doc/reference/simple_stmts.rst:398
msgid ""
"Assignments to :const:`__debug__` are illegal.  The value for the built-"
"in variable is determined when the interpreter starts."
msgstr ":const:`__debug__` 에 대한 대입은 허락되지 않는다. 이 내장 변수의 값은 인터프리터가 시작할 때 결정된다."

#: ../Doc/reference/simple_stmts.rst:405
msgid "The :keyword:`pass` statement"
msgstr ":keyword:`pass` 문"

#: ../Doc/reference/simple_stmts.rst:415
msgid ""
":keyword:`pass` is a null operation --- when it is executed, nothing "
"happens. It is useful as a placeholder when a statement is required "
"syntactically, but no code needs to be executed, for example::"
msgstr ""
":keyword:`pass` 는 널(null) 연산이다 --- 실행될 때, 아무런 일도 일어나지 않는다. 문법적으로 문장이 "
"필요하기는 하지만 할 일은 없을 때, 자리를 채우는 용도로 쓸모가 있다, 예를 들어::"

#: ../Doc/reference/simple_stmts.rst:427
msgid "The :keyword:`del` statement"
msgstr ":keyword:`del` 문"

#: ../Doc/reference/simple_stmts.rst:437
msgid ""
"Deletion is recursively defined very similar to the way assignment is "
"defined. Rather than spelling it out in full details, here are some "
"hints."
msgstr "삭제는 대입이 정의된 방식과 아주 비슷하게 재귀적으로 정의된다. 전체 세부 사항들을 나열하는 대신, 여기 몇 가지 힌트가 있다."

#: ../Doc/reference/simple_stmts.rst:440
msgid ""
"Deletion of a target list recursively deletes each target, from left to "
"right."
msgstr "타깃 목록의 삭제는 각 타깃을 왼쪽에서 오른쪽으로 재귀적으로 삭제한다."

#: ../Doc/reference/simple_stmts.rst:446
msgid ""
"Deletion of a name removes the binding of that name from the local or "
"global namespace, depending on whether the name occurs in a "
":keyword:`global` statement in the same code block.  If the name is "
"unbound, a :exc:`NameError` exception will be raised."
msgstr ""
"이름의 삭제는 같은 코드 블록에 있는 :keyword:`global` 문에 그 이름이 등장하는지에 따라 지역이나 전역 "
"이름 공간에서 이름의 연결을 제거한다. 이름이 연결되어 있지 않으면, :exc:`NameError` 예외가 일어난다."

#: ../Doc/reference/simple_stmts.rst:453
msgid ""
"Deletion of attribute references, subscriptions and slicings is passed to"
" the primary object involved; deletion of a slicing is in general "
"equivalent to assignment of an empty slice of the right type (but even "
"this is determined by the sliced object)."
msgstr ""
"어트리뷰트 참조, 서브스크립션, 슬라이싱의 삭제는 관련된 프라이머리 객체로 전달된다; 슬라이싱의 삭제는 일반적으로 우변 형의 빈 "
"슬라이스를 대입하는 것과 동등하다 (하지만 이것조차 슬라이싱 되는 객체가 판단한다)."

#: ../Doc/reference/simple_stmts.rst:458
msgid ""
"Previously it was illegal to delete a name from the local namespace if it"
" occurs as a free variable in a nested block."
msgstr "예전에는 이름이 중첩된 블록에서 자유 변수로 등장하는 경우 지역 이름 공간에서 삭제하는 것이 허락되지 않았다."

#: ../Doc/reference/simple_stmts.rst:466
msgid "The :keyword:`return` statement"
msgstr "return 문"

#: ../Doc/reference/simple_stmts.rst:476
msgid ""
":keyword:`return` may only occur syntactically nested in a function "
"definition, not within a nested class definition."
msgstr ":keyword:`return` 은 문법적으로 클래스 정의에 중첩된 경우가 아니라, 함수 정의에만 중첩되어 나타날 수 있다."

#: ../Doc/reference/simple_stmts.rst:479
msgid ""
"If an expression list is present, it is evaluated, else ``None`` is "
"substituted."
msgstr "표현식 목록이 있으면 값을 구하고, 그렇지 않으면 ``None`` 으로 치환된다."

#: ../Doc/reference/simple_stmts.rst:481
msgid ""
":keyword:`return` leaves the current function call with the expression "
"list (or ``None``) as return value."
msgstr ":keyword:`return` 은 표현식 목록 (또는 ``None``)을 반환 값으로 해서, 현재의 함수 호출을 떠난다."

#: ../Doc/reference/simple_stmts.rst:486
msgid ""
"When :keyword:`return` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`finally` clause is "
"executed before really leaving the function."
msgstr ""
":keyword:`return` 이 :keyword:`finally` 절을 가진 :keyword:`try` 문에서 제어가 "
"벗어나도록 만드는 경우, 함수로부터 진짜로 벗어나기 전에 그 :keyword:`finally` 절이 실행된다."

#: ../Doc/reference/simple_stmts.rst:490
msgid ""
"In a generator function, the :keyword:`return` statement indicates that "
"the generator is done and will cause :exc:`StopIteration` to be raised. "
"The returned value (if any) is used as an argument to construct "
":exc:`StopIteration` and becomes the :attr:`StopIteration.value` "
"attribute."
msgstr ""
"제너레이터 함수에서, :keyword:`return` 문은 제너레이터가 끝났음을 가리키고, :exc:`StopIteration` "
"예외를 일으킨다. return 문에 제공되는 값은 (있다면) :exc:`StopIteration` 의 생성자에 인자로 전달되어 "
":attr:`StopIteration.value` 어트리뷰트가 된다."

#: ../Doc/reference/simple_stmts.rst:495
msgid ""
"In an asynchronous generator function, an empty :keyword:`return` "
"statement indicates that the asynchronous generator is done and will "
"cause :exc:`StopAsyncIteration` to be raised.  A non-empty "
":keyword:`return` statement is a syntax error in an asynchronous "
"generator function."
msgstr ""
"비동기 제너레이터 함수에서, 빈 :keyword:`return` 문은 비동기 제너레이터가 끝났음을 알리고, "
":exc:`StopAsyncIteration` 예외를 일으킨다. 비동기 제너레이터 함수에서, 비어있지 않은 "
":keyword:`return` 은 문법 에러다."

#: ../Doc/reference/simple_stmts.rst:503
msgid "The :keyword:`yield` statement"
msgstr "yield 문"

#: ../Doc/reference/simple_stmts.rst:515
msgid ""
"A :keyword:`yield` statement is semantically equivalent to a :ref:`yield "
"expression <yieldexpr>`. The yield statement can be used to omit the "
"parentheses that would otherwise be required in the equivalent yield "
"expression statement. For example, the yield statements ::"
msgstr ""
":keyword:`yield` 문은 :ref:`yield 표현식 <yieldexpr>` 과 같은 의미가 있다. 동등한 yield "
"표현식에서 필요로 하는 괄호를 생략하기 위해 yield 문을 사용한다. 예를 들어, yield 문 ::"

#: ../Doc/reference/simple_stmts.rst:523
msgid "are equivalent to the yield expression statements ::"
msgstr "은 다음과 같은 yield 표현식 문장들과 동등하다 ::"

#: ../Doc/reference/simple_stmts.rst:528
msgid ""
"Yield expressions and statements are only used when defining a "
":term:`generator` function, and are only used in the body of the "
"generator function.  Using yield in a function definition is sufficient "
"to cause that definition to create a generator function instead of a "
"normal function."
msgstr ""
"yield 표현식과 문장은 :term:`제너레이터 <generator>` 함수를 정의할 때만 사용되고, 제너레이터 함수의 바디에서만"
" 사용된다. 함수 정의가 일반 함수 대신 제너레이터 함수를 만들도록 하는 데는 yield를 사용하는 것만으로 충분하다."

#: ../Doc/reference/simple_stmts.rst:533
msgid ""
"For full details of :keyword:`yield` semantics, refer to the "
":ref:`yieldexpr` section."
msgstr ":keyword:`yield` 의 뜻에 대한 전체 세부 사항들은 :ref:`yieldexpr` 섹션을 참고하면 된다."

#: ../Doc/reference/simple_stmts.rst:539
msgid "The :keyword:`raise` statement"
msgstr ":keyword:`raise` 문"

#: ../Doc/reference/simple_stmts.rst:550
msgid ""
"If no expressions are present, :keyword:`raise` re-raises the last "
"exception that was active in the current scope.  If no exception is "
"active in the current scope, a :exc:`RuntimeError` exception is raised "
"indicating that this is an error."
msgstr ""
"표현식이 주어지지 않으면, :keyword:`raise` 는 현재 스코프에서 활성화된 마지막 예외를 다시 일으킨다. 현재 스코프에 "
"활성화된 예외가 없다면, 이것이 에러라는 것을 알리기 위해 :exc:`RuntimeError` 예외를 일으킨다."

#: ../Doc/reference/simple_stmts.rst:555
msgid ""
"Otherwise, :keyword:`raise` evaluates the first expression as the "
"exception object.  It must be either a subclass or an instance of "
":class:`BaseException`. If it is a class, the exception instance will be "
"obtained when needed by instantiating the class with no arguments."
msgstr ""
"그렇지 않으면, :keyword:`raise` 는 예외 객체로, 첫 번째 표현식의 값을 구한다. "
":class:`BaseException` 의 서브 클래스나 인스턴스여야 한다. 클래스면, 예외 인스턴스는 필요할 때 인자 없이 "
"클래스의 인스턴스를 만들어서 사용된다."

#: ../Doc/reference/simple_stmts.rst:560
msgid ""
"The :dfn:`type` of the exception is the exception instance's class, the "
":dfn:`value` is the instance itself."
msgstr "예외의 형(:dfn:`type`)은 예외 인스턴스의 클래스고, 값(:dfn:`value`)은 인스턴스 자신이다."

#: ../Doc/reference/simple_stmts.rst:565
msgid ""
"A traceback object is normally created automatically when an exception is"
" raised and attached to it as the :attr:`__traceback__` attribute, which "
"is writable. You can create an exception and set your own traceback in "
"one step using the :meth:`with_traceback` exception method (which returns"
" the same exception instance, with its traceback set to its argument), "
"like so::"
msgstr ""
"트레이스백 객체는 보통 예외가 일어날 때 자동으로 만들어지고 쓰기 가능한 :attr:`__traceback__` 어트리뷰트로 "
"첨부된다. 다음과 같이, :meth:`with_traceback` 예외 메서드를 사용하면, 예외를 만들고 트레이스백을 직접 설정하는"
" 것을 한 번에 할 수 있다 (같은 예외 인스턴스를 돌려주는데, 그 인자값으로 트레이스백을 설정해준다)::"

#: ../Doc/reference/simple_stmts.rst:577
msgid ""
"The ``from`` clause is used for exception chaining: if given, the second "
"*expression* must be another exception class or instance, which will then"
" be attached to the raised exception as the :attr:`__cause__` attribute "
"(which is writable).  If the raised exception is not handled, both "
"exceptions will be printed::"
msgstr ""
"``from`` 절은 예외 연쇄(exception chaining)에 사용된다. 주어진다면, 두 번째 *표현식(expression)*"
" 은 또 하나의 예외 클래스나 인스턴스야 되는데, 발생한 예외에 (쓰기 가능한) :attr:`__cause__` 어트리뷰트로 "
"첨부된다. 발생한 예외가 처리되지 않으면, 두 예외가 모두 인쇄된다::"

#: ../Doc/reference/simple_stmts.rst:598
msgid ""
"A similar mechanism works implicitly if an exception is raised inside an "
"exception handler or a :keyword:`finally` clause: the previous exception "
"is then attached as the new exception's :attr:`__context__` attribute::"
msgstr ""
"예외 처리기나 :keyword:`finally` 절에서 예외가 발생하면 비슷한 메커니즘이 묵시적으로 적용된다: 앞선 예외가 새 "
"예외의 :attr:`__context__` 어트리뷰트로 첨부된다."

#: ../Doc/reference/simple_stmts.rst:617
msgid ""
"Exception chaining can be explicitly suppressed by specifying "
":const:`None` in the ``from`` clause::"
msgstr "예외 연쇄는 ``from`` 절에 :const:`None` 을 지정해서 명시적으로 중지시킬 수 있다::"

#: ../Doc/reference/simple_stmts.rst:629
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information about handling exceptions is in "
"section :ref:`try`."
msgstr ""
"예외에 대한 더 많은 정보를 :ref:`exceptions` 섹션에서 발견할 수 있고, 예외를 처리하는 것에 대한 정보는 "
":ref:`try` 섹션에 있다."

#: ../Doc/reference/simple_stmts.rst:632
msgid ":const:`None` is now permitted as ``Y`` in ``raise X from Y``."
msgstr "이제 ``raise X from Y`` 에서 ``Y`` 로 :const:`None` 이 허락된다."

#: ../Doc/reference/simple_stmts.rst:635
msgid ""
"The ``__suppress_context__`` attribute to suppress automatic display of "
"the exception context."
msgstr "예외 문백(exception context)의 자동 출력을 제한할 수 있는 ``__suppress_context__`` 어트리뷰트"

#: ../Doc/reference/simple_stmts.rst:642
msgid "The :keyword:`break` statement"
msgstr "break 문"

#: ../Doc/reference/simple_stmts.rst:653
msgid ""
":keyword:`break` may only occur syntactically nested in a :keyword:`for` "
"or :keyword:`while` loop, but not nested in a function or class "
"definition within that loop."
msgstr ""
":keyword:`break` 는 문법적으로 :keyword:`for` 나 :keyword:`while` 루프에 중첩되어서만 나타날"
" 수 있다. 하지만 그 루프 안의 함수나 클래스 정의에 중첩되지는 않는다."

#: ../Doc/reference/simple_stmts.rst:660
msgid ""
"It terminates the nearest enclosing loop, skipping the optional "
":keyword:`else` clause if the loop has one."
msgstr "가장 가까이서 둘러싸고 있는 루프를 종료하고, 그 루프가 :keyword:`else` 절을 갖고 있다면 건너뛴다(skip)."

#: ../Doc/reference/simple_stmts.rst:663
msgid ""
"If a :keyword:`for` loop is terminated by :keyword:`break`, the loop "
"control target keeps its current value."
msgstr ":keyword:`for` 루프가 :keyword:`break` 로 종료되면, 루프 제어 타깃은 현재값을 유지한다."

#: ../Doc/reference/simple_stmts.rst:668
msgid ""
"When :keyword:`break` passes control out of a :keyword:`try` statement "
"with a :keyword:`finally` clause, that :keyword:`finally` clause is "
"executed before really leaving the loop."
msgstr ""
":keyword:`break` 가 :keyword:`finally` 절을 가 :keyword:`try` 문에서 제어가 "
"벗어나도록 만드는 경우, 루프로부터 진짜로 벗어나기 전에 그 :keyword:`finally` 절이 실행된다."

#: ../Doc/reference/simple_stmts.rst:676
msgid "The :keyword:`continue` statement"
msgstr ":keyword:`continue` 문"

#: ../Doc/reference/simple_stmts.rst:688
msgid ""
":keyword:`continue` may only occur syntactically nested in a "
":keyword:`for` or :keyword:`while` loop, but not nested in a function or "
"class definition or :keyword:`finally` clause within that loop.  It "
"continues with the next cycle of the nearest enclosing loop."
msgstr ""
":keyword:`continue` 는 문법적으로 :keyword:`for` 나 :keyword:`while` 루프에 중첩되어서만 "
"나타날 수 있다. 하지만 그 루프 안의 함수나 클래스 정의 또는 그 루프 내의 :keyword:`finally` 에 중첩되지는 "
"않는다. 가장 가까이서 둘러싸고 있는 루프가 다음 사이클로 넘어가도록 만든다."

#: ../Doc/reference/simple_stmts.rst:693
msgid ""
"When :keyword:`continue` passes control out of a :keyword:`try` statement"
" with a :keyword:`finally` clause, that :keyword:`finally` clause is "
"executed before really starting the next loop cycle."
msgstr ""
":keyword:`continue` 가 :keyword:`finally` 절을 가진 :keyword:`try` 문에서 제어가 "
"벗어나도록 만드는 경우, 다음 루트 사이클을 시작하기 전에 그 :keyword:`finally` 절이 실행된다."

#: ../Doc/reference/simple_stmts.rst:702
msgid "The :keyword:`import` statement"
msgstr "임포트(:keyword:`import`) 문"

#: ../Doc/reference/simple_stmts.rst:721
msgid ""
"The basic import statement (no :keyword:`from` clause) is executed in two"
" steps:"
msgstr "(:keyword:`from` 절이 없는) 기본 임포트 문은 두 단계로 실행된다:"

#: ../Doc/reference/simple_stmts.rst:724
msgid "find a module, loading and initializing it if necessary"
msgstr "모듈을 찾고, 로드하고, 필요하면 초기화한다"

#: ../Doc/reference/simple_stmts.rst:725
msgid ""
"define a name or names in the local namespace for the scope where the "
":keyword:`import` statement occurs."
msgstr "임포트(:keyword:`import`) 문이 등장한 스코프의 지역 이름 공간에 이름이나 이름들을 정의한다."

#: ../Doc/reference/simple_stmts.rst:728
msgid ""
"When the statement contains multiple clauses (separated by commas) the "
"two steps are carried out separately for each clause, just as though the "
"clauses had been separated out into individual import statements."
msgstr ""
"문장이 (쉼표로 분리된) 여러 개의 절을 포함하면, 마치 각 절이 별도의 임포트 문에 의해 분리된 것처럼, 두 단계는 "
"절마다 별도로 수행된다."

#: ../Doc/reference/simple_stmts.rst:733
msgid ""
"The details of the first step, finding and loading modules are described "
"in greater detail in the section on the :ref:`import system "
"<importsystem>`, which also describes the various types of packages and "
"modules that can be imported, as well as all the hooks that can be used "
"to customize the import system. Note that failures in this step may "
"indicate either that the module could not be located, *or* that an error "
"occurred while initializing the module, which includes execution of the "
"module's code."
msgstr ""
"첫 번째 단계, 모듈을 찾고 로드하는 것의 세부 사항은 :ref:`임포트 시스템 <importsystem>` 에 있는 섹션에서 아주 "
"상세하게 설명하는데, 임포트될 수 있는 여러 종류의 패키지와 모듈들과 임포트 시스템을 커스터마이즈하는데 사용될 수 있는 모든 "
"훅에 관해서도 설명하고 있다."

#: ../Doc/reference/simple_stmts.rst:741
msgid ""
"If the requested module is retrieved successfully, it will be made "
"available in the local namespace in one of three ways:"
msgstr "요청된 모듈이 성공적으로 읽어 들여지면, 세 가지 중 한 방법으로 지역 이름 공간에 소개된다:"

#: ../Doc/reference/simple_stmts.rst:746
msgid ""
"If the module name is followed by :keyword:`as`, then the name following "
":keyword:`as` is bound directly to the imported module."
msgstr "모듈 이름 뒤에 :keyword:`as` 가 오면, :keyword:`as` 뒤에 오는 이름이 임포트된 모듈에 직접 연결된다."

#: ../Doc/reference/simple_stmts.rst:748
msgid ""
"If no other name is specified, and the module being imported is a top "
"level module, the module's name is bound in the local namespace as a "
"reference to the imported module"
msgstr ""
"다른 이름이 지정되지 않고, 임포트되는 모듈이 최상위 모듈이면, 모듈의 이름이 임포트되는 모듈에 대한 참조로 지역 이름 공간에 "
"연결된다."

#: ../Doc/reference/simple_stmts.rst:751
msgid ""
"If the module being imported is *not* a top level module, then the name "
"of the top level package that contains the module is bound in the local "
"namespace as a reference to the top level package. The imported module "
"must be accessed using its full qualified name rather than directly"
msgstr ""
"임포트되는 모듈이 최상이 모듈이 *아니* 라면, 그 모듈을 포함하는 최상위 패키지의 이름이 최상위 패키지에 대한 참조로 지역 "
"이름 공간에 연결된다. 임포트된 모듈은 직접적이기보다는 완전히 정규화된 이름(full qualified name)을 통해 액세스 되어야 "
"한다."

#: ../Doc/reference/simple_stmts.rst:762
msgid "The :keyword:`from` form uses a slightly more complex process:"
msgstr ":keyword:`from` 형은 약간 더 복잡한 절차를 사용한다:"

#: ../Doc/reference/simple_stmts.rst:764
msgid ""
"find the module specified in the :keyword:`from` clause, loading and "
"initializing it if necessary;"
msgstr ":keyword:`from` 절에 지정된 모듈을 찾고, 로드하고, 필요하면 초기화한다"

#: ../Doc/reference/simple_stmts.rst:766
msgid "for each of the identifiers specified in the :keyword:`import` clauses:"
msgstr ":keyword:`import` 절에 지정된 식별자들 각각에 대해:"

#: ../Doc/reference/simple_stmts.rst:768
msgid "check if the imported module has an attribute by that name"
msgstr "임포트된 모듈이 그 이름의 어트리뷰트를 가졌는지 검사한다"

#: ../Doc/reference/simple_stmts.rst:769
msgid ""
"if not, attempt to import a submodule with that name and then check the "
"imported module again for that attribute"
msgstr "없으면, 그 이름의 서브 모듈을 임포트하는 것을 시도한 다음 임포트된 모듈에서 그 어트리뷰트를 다시 검사한다"

#: ../Doc/reference/simple_stmts.rst:771
msgid "if the attribute is not found, :exc:`ImportError` is raised."
msgstr "어트리뷰트가 발견되지 않으면 :exc:`ImportError` 를 일으킨다."

#: ../Doc/reference/simple_stmts.rst:772
msgid ""
"otherwise, a reference to that value is stored in the local namespace, "
"using the name in the :keyword:`as` clause if it is present, otherwise "
"using the attribute name"
msgstr ""
"그렇지 않으면, 그 값에 대한 참조가 지역 이름 공간에 저장되는데, :keyword:`as` 절이 존재하면 거기에서 지정된 이름을 "
"사용하고, 그렇지 않으면 어트리뷰트 이름을 사용한다"

#: ../Doc/reference/simple_stmts.rst:776
msgid "Examples::"
msgstr "사용 예::"

#: ../Doc/reference/simple_stmts.rst:784
msgid ""
"If the list of identifiers is replaced by a star (``'*'``), all public "
"names defined in the module are bound in the local namespace for the "
"scope where the :keyword:`import` statement occurs."
msgstr ""
"식별자들의 목록을 스타 (``'*'``) 로 바꾸면, 모듈에 정의된 모든 공개 이름들이 :keyword:`import` "
"문이 등장한 스코프의 지역 이름 공간에 연결된다."

#: ../Doc/reference/simple_stmts.rst:790
msgid ""
"The *public names* defined by a module are determined by checking the "
"module's namespace for a variable named ``__all__``; if defined, it must "
"be a sequence of strings which are names defined or imported by that "
"module.  The names given in ``__all__`` are all considered public and are"
" required to exist.  If ``__all__`` is not defined, the set of public "
"names includes all names found in the module's namespace which do not "
"begin with an underscore character (``'_'``).  ``__all__`` should contain"
" the entire public API. It is intended to avoid accidentally exporting "
"items that are not part of the API (such as library modules which were "
"imported and used within the module)."
msgstr ""
"모듈에 정의된 *공개 이름(public names)* 은 모듈의 이름 공간에서 ``__all__`` 이라는 이름의 변수를 검사해서 "
"결정된다; 정의되어 있다면, 문자열의 시퀀스여야 하는데, 그 모듈이 정의하거나 임포트하는 이름들이다. ``__all__`` 에서 "
"지정한 이름들은 모두 공개로 취급되고 반드시 존재해야 한다. ``__all__`` 이 정의되지 않으면, 모듈의 이름 공간에서 발견되는 "
"이름 중, 밑줄 문자 (``'_'``)로 시작하지 않는 모든 이름이 공개로 취급된다. ``__all__`` 는 공개 API "
"전체를 포함해야 한다. 이것의 목적은 의도치 않게 API 일부가 아닌 항목들을 노출하는 것을 방지하는 것이다 (가령 그 모듈이"
" 임포트하고 사용하는 라이브러리 모듈)."

#: ../Doc/reference/simple_stmts.rst:800
msgid ""
"The wild card form of import --- ``from module import *`` --- is only "
"allowed at the module level.  Attempting to use it in class or function "
"definitions will raise a :exc:`SyntaxError`."
msgstr ""
"임포트의 와일드카드 형태 --- ``from module import *`` --- 는 모듈 수준에서만 허락된다. 클래스나 함수 "
"정의에서 사용하려는 시도는 :exc:`SyntaxError` 를 일으킨다."

#: ../Doc/reference/simple_stmts.rst:807
msgid ""
"When specifying what module to import you do not have to specify the "
"absolute name of the module. When a module or package is contained within"
" another package it is possible to make a relative import within the same"
" top package without having to mention the package name. By using leading"
" dots in the specified module or package after :keyword:`from` you can "
"specify how high to traverse up the current package hierarchy without "
"specifying exact names. One leading dot means the current package where "
"the module making the import exists. Two dots means up one package level."
" Three dots is up two levels, etc. So if you execute ``from . import "
"mod`` from a module in the ``pkg`` package then you will end up importing"
" ``pkg.mod``. If you execute ``from ..subpkg2 import mod`` from within "
"``pkg.subpkg1`` you will import ``pkg.subpkg2.mod``. The specification "
"for relative imports is contained within :pep:`328`."
msgstr ""
"임포트할 모듈을 지정할 때 모듈의 절대 이름(absolute name)을 지정할 필요는 없다. 모듈이나 패키지가 다른 패키지 안에 "
"포함될 때, 같은 상위 패키지 내에서는 그 패키지 이름을 언급할 필요 없이 상대 임포트(relative import)를 할 수 "
"있다. :keyword:`from` 뒤에 지정되는 패키지나 모듈 앞에 붙이는 점으로, 정확한 이름을 지정하지 않고도 현재 패키지 "
"계층을 얼마나 거슬러 올라가야 하는지 지정할 수 있다. 하나의 점은 이 임포트를 하는 모듈이 존재하는 현재 패키지를 뜻한다. 두 "
"개의 점은 한 패키지 수준을 거슬러 올라가는 것을 뜻한다. 세 개의 점은 두 개의 수준을, 등등이다. 그래서 ``pkg`` 패키지에 "
"있는 모듈에서 ``from . import mod`` 를 실행하면, ``pkg.mod`` 를 임포트하게 된다. "
"``pkg.subpkg1`` 안에서 ``from ..subpkg2 import mod`` 를 실행하면 "
"``pkg.subpkg2.mod`` 를 임포트하게 된다. 상대 임포트에 대한 규격은 :pep:`328` 안에 들어있다."

#: ../Doc/reference/simple_stmts.rst:820
msgid ""
":func:`importlib.import_module` is provided to support applications that "
"determine dynamically the modules to be loaded."
msgstr "로드할 모듈들을 동적으로 결정하는 응용 프로그램들을 지원하기 위해 :func:`importlib.import_module` 이 제공된다."

#: ../Doc/reference/simple_stmts.rst:827
msgid "Future statements"
msgstr "퓨처 문"

#: ../Doc/reference/simple_stmts.rst:831
msgid ""
"A :dfn:`future statement` is a directive to the compiler that a "
"particular module should be compiled using syntax or semantics that will "
"be available in a specified future release of Python where the feature "
"becomes standard."
msgstr ""
"퓨처 문(:dfn:`future statement`)은 컴파일러가 특정한 모듈을 특별한 문법이나 개념을 사용해서 컴파일하도록"
" 만드는 지시어(directive)인데, 그 기능은 미래에 출시되는 파이썬에서 표준이 되는 것이다."

#: ../Doc/reference/simple_stmts.rst:835
msgid ""
"The future statement is intended to ease migration to future versions of "
"Python that introduce incompatible changes to the language.  It allows "
"use of the new features on a per-module basis before the release in which"
" the feature becomes standard."
msgstr ""
"퓨처 문의 목적은 언어에 호환되지 않는 변경이 도입된 미래 버전의 파이썬으로 옮겨가는 것을 쉽게 만드는 것이다. 그 기능이 "
"표준이 되는 배포 이전에 모듈 단위로 새 기능을 사용할 수 있도록 만든다."

#: ../Doc/reference/simple_stmts.rst:848
msgid ""
"A future statement must appear near the top of the module.  The only "
"lines that can appear before a future statement are:"
msgstr "퓨처 문은 모듈의 거의 처음에 나와야 한다. 퓨처 문 앞에 나올 수 있는 줄들은:"

#: ../Doc/reference/simple_stmts.rst:851
msgid "the module docstring (if any),"
msgstr "모듈 독스트링(docstring) (있다면),"

#: ../Doc/reference/simple_stmts.rst:852
msgid "comments,"
msgstr "주석"

#: ../Doc/reference/simple_stmts.rst:853
msgid "blank lines, and"
msgstr "빈 줄, 그리고"

#: ../Doc/reference/simple_stmts.rst:854
msgid "other future statements."
msgstr "다른 퓨처 문들"

#: ../Doc/reference/simple_stmts.rst:858
msgid ""
"The features recognized by Python 3.0 are ``absolute_import``, "
"``division``, ``generators``, ``unicode_literals``, ``print_function``, "
"``nested_scopes`` and ``with_statement``.  They are all redundant because"
" they are always enabled, and only kept for backwards compatibility."
msgstr ""
"파이썬 3.0 이 인식하는 기능들은 ``absolute_import``, ``division``, ``generators``, "
"``unicode_literals``, ``print_function``, ``nested_scopes``, "
"``with_statement`` 다. 이것들은 잉여물인데 항상 활성화되고, 오직 과거 호환성을 위해 유지되고 있기 때문이다."

#: ../Doc/reference/simple_stmts.rst:863
msgid ""
"A future statement is recognized and treated specially at compile time: "
"Changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in "
"which case the compiler may need to parse the module differently.  Such "
"decisions cannot be pushed off until runtime."
msgstr ""
"퓨처 문은 구체적으로는 컴파일 시점에 인식되고 다뤄진다: 핵심 구성물들의 의미에 대한 변경은 종종 다른 코드 생성을 통해 구현된다."
" 새 기능이 호환되지 않는 (새로운 예약어처럼) 새로운 문법을 도입하는 경우조차 가능한데, 이 경우는 컴파일러가 모듈을 다르게 "
"파싱할 수 있다. 그런 결정들은 실행 시점으로 미뤄질 수 없다.."

#: ../Doc/reference/simple_stmts.rst:870
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future statement contains a"
" feature not known to it."
msgstr ""
"배포마다, 컴파일러는 어떤 기능 이름들이 정의되어 있는지 알고, 만약 퓨처 문이 알지 못하는 기능을 포함하고 있으면 컴파일 "
"시점 에러를 일으킨다."

#: ../Doc/reference/simple_stmts.rst:874
msgid ""
"The direct runtime semantics are the same as for any import statement: "
"there is a standard module :mod:`__future__`, described later, and it "
"will be imported in the usual way at the time the future statement is "
"executed."
msgstr ""
"직접적인 실행 시점의 개념은 다른 임포트 문들과 같다: 표준 모듈 :mod:`__future__`, 후에 설명한다, 다 있고, "
"퓨처 문이 실행되는 시점에 일반적인 방법으로 임포트된다."

#: ../Doc/reference/simple_stmts.rst:878
msgid ""
"The interesting runtime semantics depend on the specific feature enabled "
"by the future statement."
msgstr "흥미로운 실행 시점의 개념들은 퓨처 문에 의해 활성화되는 구체적인 기능들에 달려있다."

#: ../Doc/reference/simple_stmts.rst:881
msgid "Note that there is nothing special about the statement::"
msgstr "이런 문장에는 아무것도 특별한 것이 없음에 주의해야 한다::"

#: ../Doc/reference/simple_stmts.rst:885
msgid ""
"That is not a future statement; it's an ordinary import statement with no"
" special semantics or syntax restrictions."
msgstr "이것은 퓨처 문이 아니다; 아무런 특별한 개념이나 문법적인 제약이 없는 평범한 임포트 문일 뿐이다."

#: ../Doc/reference/simple_stmts.rst:888
msgid ""
"Code compiled by calls to the built-in functions :func:`exec` and "
":func:`compile` that occur in a module :mod:`M` containing a future "
"statement will, by default, use the new syntax or semantics associated "
"with the future statement.  This can be controlled by optional arguments "
"to :func:`compile` --- see the documentation of that function for "
"details."
msgstr ""
"퓨처 문을 포함하는 모듈 :mod:`M` 에 등장하는 내장 함수 :func:`exec` 와 :func:`compile` 를 "
"호출해서 컴파일되는 코드는, 기본적으로는, 퓨처 문이 지정하는 새 문법과 개념을 사용한다. 이것은 :func:`compile` "
"에 주는 생략 가능한 인자로 제어될 수 있다 --- 자세한 내용은 그 함수의 문서를 보면 된다."

#: ../Doc/reference/simple_stmts.rst:894
msgid ""
"A future statement typed at an interactive interpreter prompt will take "
"effect for the rest of the interpreter session.  If an interpreter is "
"started with the :option:`-i` option, is passed a script name to execute,"
" and the script includes a future statement, it will be in effect in the "
"interactive session started after the script is executed."
msgstr ""
"대화형 인터프리터 프롬프트에서 입력된 퓨처 문은 인터프리터 세션의 남은 기간 효과를 발생시킨다. 인터프리터가 "
":option:`-i`, 실행할 스크립트 이름이 전달된다, 옵션으로 시작하고, 그 스크립트가 퓨처 문을 포함하면, 스크립트가 실행된"
" 이후에 시작되는 대화형 세션에서도 효과를 유지한다."

#: ../Doc/reference/simple_stmts.rst:902
msgid ":pep:`236` - Back to the __future__"
msgstr ":pep:`236` - 백 투 더 __future__"

#: ../Doc/reference/simple_stmts.rst:903
msgid "The original proposal for the __future__ mechanism."
msgstr "__future__ 메커니즘에 대한 최초의 제안."

#: ../Doc/reference/simple_stmts.rst:909
msgid "The :keyword:`global` statement"
msgstr ":keyword:`global` 문"

#: ../Doc/reference/simple_stmts.rst:918
msgid ""
"The :keyword:`global` statement is a declaration which holds for the "
"entire current code block.  It means that the listed identifiers are to "
"be interpreted as globals.  It would be impossible to assign to a global "
"variable without :keyword:`global`, although free variables may refer to "
"globals without being declared global."
msgstr ""
":keyword:`global` 문은 현재 코드 블록 전체에 적용되는 선언이다. 나열된 식별자들이 전역으로 해석되어야 한다는 "
"뜻이다. global 선언 없이 자유 변수들이 전역을 가리킬 수 있기는 하지만, :keyword:`global` 없이 전역 변수에 "
"값을 대입하는 것은 불가능하다."

#: ../Doc/reference/simple_stmts.rst:924
msgid ""
"Names listed in a :keyword:`global` statement must not be used in the "
"same code block textually preceding that :keyword:`global` statement."
msgstr ":keyword:`global` 문에 나열된 이름들은 같은 코드 블록에서 :keyword:`global` 문 앞에 등장할 수 없다."

#: ../Doc/reference/simple_stmts.rst:927
msgid ""
"Names listed in a :keyword:`global` statement must not be defined as "
"formal parameters or in a :keyword:`for` loop control target, "
":keyword:`class` definition, function definition, :keyword:`import` "
"statement, or variable annotation."
msgstr ""
":keyword:`global` 문에 나열된 이름들은 형식 파라미터나 :keyword:`for` 루프 제어 타깃, "
"클래스(:keyword:`class`) 정의, 함수 정의, 임포트(:keyword:`import`) 문, 변수 어노테이션으로 "
"정의되지 않아야 한다."

#: ../Doc/reference/simple_stmts.rst:934
msgid ""
"The current implementation does not enforce some of these restrictions, "
"but programs should not abuse this freedom, as future implementations may"
" enforce them or silently change the meaning of the program."
msgstr ""
"현재 구현이 이 제약들의 일부를 강제하지 않지만, 프로그램은 이 자유를 남용하지 말아야 하는데, 미래의 구현은 그것들을 강제하거나 "
"프로그램의 의미를 예고 없이 변경할 수 있기 때문이다."

#: ../Doc/reference/simple_stmts.rst:943
msgid ""
"**Programmer's note:** :keyword:`global` is a directive to the parser.  "
"It applies only to code parsed at the same time as the :keyword:`global` "
"statement. In particular, a :keyword:`global` statement contained in a "
"string or code object supplied to the built-in :func:`exec` function does"
" not affect the code block *containing* the function call, and code "
"contained in such a string is unaffected by :keyword:`global` statements "
"in the code containing the function call.  The same applies to the "
":func:`eval` and :func:`compile` functions."
msgstr ""
"**프로그래머의 주의 사향:** :keyword:`global` 은 파서에 주는 지시자(directive)다. "
":keyword:`global` 문과 같은 시점에 파싱되는 코드에만 적용된다. 특히, 내장 :func:`exec` 함수로 공급되는"
" 문자열이나 코드 객체에 포함된 :keyword:`global` 문은 그 함수 호출을 *포함하는* 코드 블록에는 영향을 주지 않고,"
" 그런 문자열에 포함된 코드 역시 함수 호출을 포함하는 코드에 있는 :keyword:`global` 문에 영향을 받지 않는다. "
":func:`eval` 과 :func:`compile` 함수들도 마찬가지다."

#: ../Doc/reference/simple_stmts.rst:955
msgid "The :keyword:`nonlocal` statement"
msgstr ":keyword:`nonlocal` 문"

#: ../Doc/reference/simple_stmts.rst:966
msgid ""
"The :keyword:`nonlocal` statement causes the listed identifiers to refer "
"to previously bound variables in the nearest enclosing scope excluding "
"globals. This is important because the default behavior for binding is to"
" search the local namespace first.  The statement allows encapsulated "
"code to rebind variables outside of the local scope besides the global "
"(module) scope."
msgstr ""
":keyword:`nonlocal` 문은 나열된 식별자들이 전역을 제외하고 가장 가까이서 둘러싸는 스코프에서 이미 연결된 변수를 "
"가리키도록 만든다. 이것은 중요한데, 연결의 기본 동작이 지역 이름 공간을 먼저 검색하는 것이기 때문이다. 이 문장은 캡슐화된 "
"코드가 전역 (모듈) 스코프 외에 지역 스코프 밖의 변수들에 재연결할 수 있도록 한다."

#: ../Doc/reference/simple_stmts.rst:976
msgid ""
"Names listed in a :keyword:`nonlocal` statement, unlike those listed in a"
" :keyword:`global` statement, must refer to pre-existing bindings in an "
"enclosing scope (the scope in which a new binding should be created "
"cannot be determined unambiguously)."
msgstr ""
":keyword:`nonlocal` 문 에 나열된 이름들은, :keyword:`global` 문에 나열된 것들과는 달리, 둘러싼 "
"스코프에서 이미 존재하는 연결들을 가리켜야만 한다 (새 연결이 어떤 스코프에 만들어져야만 하는지 명확하게 결정할 수 없다)."

#: ../Doc/reference/simple_stmts.rst:981
msgid ""
"Names listed in a :keyword:`nonlocal` statement must not collide with "
"pre-existing bindings in the local scope."
msgstr ":keyword:`nonlocal` 문에 나열되는 이름들은 지역 스코프에 이미 존재하는 연결들과 겹치지 않아야 한다."

#: ../Doc/reference/simple_stmts.rst:986
msgid ":pep:`3104` - Access to Names in Outer Scopes"
msgstr ":pep:`3104` - 바깥 스코프에 있는 이름들에 대한 액세스"

#: ../Doc/reference/simple_stmts.rst:987
msgid "The specification for the :keyword:`nonlocal` statement."
msgstr ":keyword:`nonlocal` 문의 규격."

