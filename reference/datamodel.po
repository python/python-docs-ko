# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-15 15:23+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/reference/datamodel.rst:6
msgid "Data model"
msgstr "데이터 모델"

#: ../Doc/reference/datamodel.rst:12
msgid "Objects, values and types"
msgstr "객체, 값, 형"

#: ../Doc/reference/datamodel.rst:18
msgid ""
":dfn:`Objects` are Python's abstraction for data.  All data in a Python "
"program is represented by objects or by relations between objects. (In a "
"sense, and in conformance to Von Neumann's model of a \"stored program "
"computer,\" code is also represented by objects.)"
msgstr ""
":dfn:`객체 (Objects)`\\는 파이썬이 데이터(data)를 추상화한 것(abstraction)입니다. 파이썬 프로그램의 "
"모든 데이터는 객체나 객체 간의 관계로 표현됩니다. (폰 노이만(Von Neumann)의 \"프로그램 내장식 컴퓨터(stored "
"program computer)\" 모델을 따르고, 또 그 관점에서 코드 역시 객체로 표현됩니다.)"

#: ../Doc/reference/datamodel.rst:35
msgid ""
"Every object has an identity, a type and a value.  An object's *identity*"
" never changes once it has been created; you may think of it as the "
"object's address in memory.  The ':keyword:`is`' operator compares the "
"identity of two objects; the :func:`id` function returns an integer "
"representing its identity."
msgstr ""
"모든 객체는 아이덴티티(identity), 형(type), 값(value)을 갖습니다. 객체의 *아이덴티티* 는 한 번 만들어진 "
"후에는 변경되지 않습니다. 메모리상에서의 객체의 주소로 생각해도 좋습니다. ':keyword:`is`' 연산자는 두 객체의 "
"아이덴티티를 비교합니다; :func:`id` 함수는 아이덴티티를 정수로 표현한 값을 돌려줍니다."

#: ../Doc/reference/datamodel.rst:42
msgid "For CPython, ``id(x)`` is the memory address where ``x`` is stored."
msgstr "CPython 의 경우, ``id(x)`` 는 ``x`` 가 저장된 메모리의 주소입니다."

#: ../Doc/reference/datamodel.rst:44
msgid ""
"An object's type determines the operations that the object supports "
"(e.g., \"does it have a length?\") and also defines the possible values "
"for objects of that type.  The :func:`type` function returns an object's "
"type (which is an object itself).  Like its identity, an object's "
":dfn:`type` is also unchangeable. [#]_"
msgstr ""
"객체의 형은 객체가 지원하는 연산들을 정의하고 (예를 들어, \"길이를 갖고 있나?\") 그 형의 객체들이 가질 수 있는 가능한 "
"값들을 정의합니다. :func:`type` 함수는 객체의 형(이것 역시 객체다)을 돌려줍니다. 아이덴티티와 마찬가지로, 객체의 "
":dfn:`형 (type)` 역시 변경되지 않습니다. [#]_"

#: ../Doc/reference/datamodel.rst:50
msgid ""
"The *value* of some objects can change.  Objects whose value can change "
"are said to be *mutable*; objects whose value is unchangeable once they "
"are created are called *immutable*. (The value of an immutable container "
"object that contains a reference to a mutable object can change when the "
"latter's value is changed; however the container is still considered "
"immutable, because the collection of objects it contains cannot be "
"changed.  So, immutability is not strictly the same as having an "
"unchangeable value, it is more subtle.) An object's mutability is "
"determined by its type; for instance, numbers, strings and tuples are "
"immutable, while dictionaries and lists are mutable."
msgstr ""
"어떤 객체들의 *값* 은 변경할 수 있습니다. 값을 변경할 수 있는 객체들을 *가변(mutable)* 이라고 합니다. 일단 만들어진"
" 후에 값을 변경할 수 없는 객체들을 *불변(immutable)* 이라고 합니다. (가변 객체에 대한 참조를 저장하고 있는 불변 "
"컨테이너의 값은 가변 객체의 값이 변할 때 변경된다고 볼 수도 있습니다; 하지만 저장하고 있는 객체들의 집합이 바뀔 수 없으므로 "
"컨테이너는 여전히 불변이라고 여겨집니다. 따라서 불변성은 엄밀하게는 변경 불가능한 값을 갖는 것과는 다릅니다. 좀 더 미묘합니다.)"
" 객체의 가변성(mutability)은 그것의 형에 의해 결정됩니다; 예를 들어 숫자, 문자열, 튜플(tuple)은 불변이지만, "
"딕셔너리(dictionary) 와 리스트(list)는 가변입니다."

#: ../Doc/reference/datamodel.rst:65
msgid ""
"Objects are never explicitly destroyed; however, when they become "
"unreachable they may be garbage-collected.  An implementation is allowed "
"to postpone garbage collection or omit it altogether --- it is a matter "
"of implementation quality how garbage collection is implemented, as long "
"as no objects are collected that are still reachable."
msgstr ""
"객체는 결코 명시적으로 파괴되지 않습니다; 더 참조되지 않을 때(unreachable) 가비지 수거(garbage "
"collect)됩니다. 구현이 가비지 수거를 지연시키거나 아예 생략하는 것이 허락됩니다 --- 아직 참조되는 객체들을 수거하지 않는"
" 이상 가비지 수거가 어떤 식으로 구현되는지는 구현의 품질 문제입니다."

#: ../Doc/reference/datamodel.rst:73
msgid ""
"CPython currently uses a reference-counting scheme with (optional) "
"delayed detection of cyclically linked garbage, which collects most "
"objects as soon as they become unreachable, but is not guaranteed to "
"collect garbage containing circular references.  See the documentation of"
" the :mod:`gc` module for information on controlling the collection of "
"cyclic garbage. Other implementations act differently and CPython may "
"change. Do not depend on immediate finalization of objects when they "
"become unreachable (so you should always close files explicitly)."
msgstr ""
"CPython 은 현재 참조 횟수 계산(reference-counting) 방식을 사용하는데, (선택 사항으로) 순환적으로 연결된 "
"가비지의 지연된 감지가 추가됩니다. 이 방법으로 대부분 객체를 참조가 제거되자마자 수거할 수 있습니다. 하지만 순환 참조가 있는 "
"가비지들을 수거한다는 보장은 없습니다. 순환적 가비지 수거의 제어에 관한 정보는 :mod:`gc` 모듈 문서를 참조하면 됩니다. "
"다른 구현들은 다른 식으로 동작하고, CPython 도 변경될 수 있습니다. 참조가 제거될 때 즉각적으로 "
"파이널리제이션(finalization)되는 것에 의존하지 말아야 합니다 (그래서 항상 파일을 명시적으로 닫아주어야 합니다)."

#: ../Doc/reference/datamodel.rst:82
msgid ""
"Note that the use of the implementation's tracing or debugging facilities"
" may keep objects alive that would normally be collectable. Also note "
"that catching an exception with a ':keyword:`try`...\\ :keyword:`except`'"
" statement may keep objects alive."
msgstr ""
"구현이 제공하는 추적이나 디버깅 장치의 사용은 그렇지 않으면 수거될 수 있는 객체들을 살아있도록 만들 수 있음에 주의해야 합니다. "
"또한 ':keyword:`try`...\\ :keyword:`except`' 문으로 예외를 잡는 것도 객체를 살아있게 만들 수 "
"있습니다."

#: ../Doc/reference/datamodel.rst:87
msgid ""
"Some objects contain references to \"external\" resources such as open "
"files or windows.  It is understood that these resources are freed when "
"the object is garbage-collected, but since garbage collection is not "
"guaranteed to happen, such objects also provide an explicit way to "
"release the external resource, usually a :meth:`close` method. Programs "
"are strongly recommended to explicitly close such objects.  The "
"':keyword:`try`...\\ :keyword:`finally`' statement and the "
"':keyword:`with`' statement provide convenient ways to do this."
msgstr ""
"어떤 객체들은 열린 파일이나 창 같은 \"외부(external)\" 자원들에 대한 참조를 포함합니다. 이 자원들은 객체가 가비지 "
"수거될 때 반납된다고 이해되지만, 가비지 수거는 보장되는 것이 아니므로, 그런 객체들은 외부자원을 반납하는 명시적인 방법 또한 "
"제공합니다. 보통 :meth:`close` 메서드다. 프로그램을 작성할 때는 그러한 객체들을 항상 명시적으로 닫아야(close) "
"합니다. ':keyword:`try`...\\ :keyword:`finally`' 문과 ':keyword:`with`' 문은 이렇게"
" 하는 편리한 방법을 제공합니다."

#: ../Doc/reference/datamodel.rst:97
msgid ""
"Some objects contain references to other objects; these are called "
"*containers*. Examples of containers are tuples, lists and dictionaries."
"  The references are part of a container's value.  In most cases, when we"
" talk about the value of a container, we imply the values, not the "
"identities of the contained objects; however, when we talk about the "
"mutability of a container, only the identities of the immediately "
"contained objects are implied.  So, if an immutable container (like a "
"tuple) contains a reference to a mutable object, its value changes if "
"that mutable object is changed."
msgstr ""
"어떤 객체들은 다른 객체에 대한 참조를 포함하고 있습니다. 이런 것들을 *컨테이너(container)* 라고 부릅니다. 튜플, "
"리스트, 딕셔너리등이 컨테이너의 예입니다. 이 참조들은 컨테이너의 값의 일부입니다. 대부분은, 우리가 컨테이너의 값을 논할 때는, "
"들어있는 객체들의 아이덴티티 보다는 값을 따집니다. 하지만, 컨테이너의 가변성에 대해 논할 때는 직접 가진 객체들의 아이덴티티만을 "
"따집니다. 그래서, (튜플 같은) 불변 컨테이너가 가변 객체로의 참조를 하고 있다면, 그 가변 객체가 변경되면 컨테이너의 값도 "
"변경됩니다."

#: ../Doc/reference/datamodel.rst:106
msgid ""
"Types affect almost all aspects of object behavior.  Even the importance "
"of object identity is affected in some sense: for immutable types, "
"operations that compute new values may actually return a reference to any"
" existing object with the same type and value, while for mutable objects "
"this is not allowed.  E.g., after ``a = 1; b = 1``, ``a`` and ``b`` may "
"or may not refer to the same object with the value one, depending on the "
"implementation, but after ``c = []; d = []``, ``c`` and ``d`` are "
"guaranteed to refer to two different, unique, newly created empty lists. "
"(Note that ``c = d = []`` assigns the same object to both ``c`` and "
"``d``.)"
msgstr ""
"형은 거의 모든 측면에서 객체가 동작하는 방법에 영향을 줍니다. 객체의 아이덴티디가 갖는 중요성조차도 어떤 면에서는 영향을 "
"받습니다: 불변형의 경우, 새 값을 만드는 연산은 실제로는 이미 존재하는 객체 중에서 같은 형과 값을 갖는 것을 돌려줄 수 "
"있습니다. 반면에 가변 객체에서는 이런 것이 허용되지 않습니다. 예를 들어, ``a = 1; b = 1`` 후에, ``a`` 와 "
"``b`` 는 값 1을 갖는 같은 객체일 수도 있고, 아닐 수도 있습니다. 하지만 ``c = []; d = []`` 후에, "
"``c`` 와 ``d`` 는 두 개의 서로 다르고, 독립적이고, 새로 만들어진 빈 리스트임이 보장됩니다. (``c = d = "
"[]`` 는 객은 객체를 ``c`` 와 ``d`` 에 대입합니다.)"

#: ../Doc/reference/datamodel.rst:120
msgid "The standard type hierarchy"
msgstr "표준형 계층"

#: ../Doc/reference/datamodel.rst:129
msgid ""
"Below is a list of the types that are built into Python.  Extension "
"modules (written in C, Java, or other languages, depending on the "
"implementation) can define additional types.  Future versions of Python "
"may add types to the type hierarchy (e.g., rational numbers, efficiently "
"stored arrays of integers, etc.), although such additions will often be "
"provided via the standard library instead."
msgstr ""
"아래에 파이썬에 내장된 형들의 목록이 있습니다. (구현에 따라 C 나 자바나 다른 언어로 작성된) 확장 모듈들은 추가의 형을 정의할"
" 수 있습니다. 파이썬의 미래 버전 역시 형 계층에 형을 더할 수 있는데 (예를 들어, 유리수, 효율적으로 저장된 정수 배열 "
"등등), 표준 라이브러리를 통해 추가될 가능성이 더 크기는 합니다."

#: ../Doc/reference/datamodel.rst:140
msgid ""
"Some of the type descriptions below contain a paragraph listing 'special "
"attributes.'  These are attributes that provide access to the "
"implementation and are not intended for general use.  Their definition "
"may change in the future."
msgstr ""
"아래에 나오는 몇몇 형에 대한 설명은 '특수 어트리뷰트(special attribute)' 를 나열하는 문단을 포함합니다. 이것들은"
" 구현에 접근할 방법을 제공하는데, 일반적인 사용을 위한 것이 아닙니다. 정의는 앞으로 변경될 수 있습니다."

#: ../Doc/reference/datamodel.rst:150
msgid "None"
msgstr "None"

#: ../Doc/reference/datamodel.rst:147
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``None``. It is used to"
" signify the absence of a value in many situations, e.g., it is returned "
"from functions that don't explicitly return anything. Its truth value is "
"false."
msgstr ""
"이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 ``None`` 을 통해 "
"접근합니다. 여러 가지 상황에서 값의 부재를 알리는 데 사용됩니다. 예를 들어, 명시적으로 뭔가를 돌려주지 않는 함수의 반환 "
"값입니다. 논리값은 거짓입니다."

#: ../Doc/reference/datamodel.rst:165
msgid "NotImplemented"
msgstr "NotImplemented"

#: ../Doc/reference/datamodel.rst:155
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the built-in name ``NotImplemented``. "
"Numeric methods and rich comparison methods should return this value if "
"they do not implement the operation for the operands provided.  (The "
"interpreter will then try the reflected operation, or some other "
"fallback, depending on the operator.)  Its truth value is true."
msgstr ""
"이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 내장된 이름 "
"``NotImplemented`` 을 통해 접근합니다. 숫자 메서드(numeric method)와 비교(rich "
"comparison) 메서드는 제공된 피연산자에 대해 연산이 구현되지 않으면 이 값을 돌려줘야 합니다. (그러면 인터프리터는 "
"연산자에 따라 뒤집힌 연산이나, 어떤 다른 대안을 시도합니다.) 논리값은 참입니다."

#: ../Doc/reference/datamodel.rst:162
msgid "See :ref:`implementing-the-arithmetic-operations` for more details."
msgstr "더 자세한 내용은 :ref:`implementing-the-arithmetic-operations` 을 참고하십시오."

#: ../Doc/reference/datamodel.rst:174
msgid "Ellipsis"
msgstr "Ellipsis"

#: ../Doc/reference/datamodel.rst:172
msgid ""
"This type has a single value.  There is a single object with this value. "
"This object is accessed through the literal ``...`` or the built-in name "
"``Ellipsis``.  Its truth value is true."
msgstr ""
"이 형은 하나의 값만을 갖습니다. 이 값을 갖는 하나의 객체가 존재합니다. 이 객체에는 리터럴 ``...`` 이나 내장된 이름 "
"``Ellipsis`` 을 통해 접근합니다. 논리값은 참입니다. "

#: ../Doc/reference/datamodel.rst:244
msgid ":class:`numbers.Number`"
msgstr ":class:`numbers.Number`"

#: ../Doc/reference/datamodel.rst:179
msgid ""
"These are created by numeric literals and returned as results by "
"arithmetic operators and arithmetic built-in functions.  Numeric objects "
"are immutable; once created their value never changes.  Python numbers "
"are of course strongly related to mathematical numbers, but subject to "
"the limitations of numerical representation in computers."
msgstr ""
"이것들은 숫자 리터럴에 의해 만들어지고, 산순 연산과 내장 산술 함수들이 결과로 돌려줍니다. 숫자 객체는 불변입니다; 한 번 값이 "
"만들어지면 절대 변하지 않습니다. 파이썬의 숫자는 당연히 수학적인 숫자들과 밀접하게 관련되어 있습니다, 하지만 컴퓨터의 숫자 "
"표현상의 제약을 받고 있습니다."

#: ../Doc/reference/datamodel.rst:185
msgid ""
"Python distinguishes between integers, floating point numbers, and "
"complex numbers:"
msgstr "파이썬은 정수, 실수, 복소수를 구분합니다:"

#: ../Doc/reference/datamodel.rst:219
msgid ":class:`numbers.Integral`"
msgstr ":class:`numbers.Integral`"

#: ../Doc/reference/datamodel.rst:191
msgid ""
"These represent elements from the mathematical set of integers (positive "
"and negative)."
msgstr "이것들은 수학적인 정수 집합(양과 음)에 속하는 요소들을 나타냅니다."

#: ../Doc/reference/datamodel.rst:194
msgid "There are two types of integers:"
msgstr "두 가지 종류의 정수가 있습니다:"

#: ../Doc/reference/datamodel.rst:196
msgid "Integers (:class:`int`)"
msgstr "정수 (:class:`int`)"

#: ../Doc/reference/datamodel.rst:198
msgid ""
"These represent numbers in an unlimited range, subject to available "
"(virtual) memory only.  For the purpose of shift and mask operations, a "
"binary representation is assumed, and negative numbers are represented in"
" a variant of 2's complement which gives the illusion of an infinite "
"string of sign bits extending to the left."
msgstr ""
"이것은 (가상) 메모리가 허락하는 한, 제약 없는 범위의 숫자를 표현합니다. 시프트(shift)와 마스크(mask) 연산이 목적일 "
"때는 이진 표현이 가정되고, 음수는 일종의 2의 보수(2's complement)로 표현되는데, 부호 비트가 왼쪽으로 무한히 확장된"
" 것과 같은 효과를 줍니다."

#: ../Doc/reference/datamodel.rst:214
msgid "Booleans (:class:`bool`)"
msgstr "불린 (:class:`bool`)"

#: ../Doc/reference/datamodel.rst:210
msgid ""
"These represent the truth values False and True.  The two objects "
"representing the values ``False`` and ``True`` are the only Boolean "
"objects. The Boolean type is a subtype of the integer type, and Boolean "
"values behave like the values 0 and 1, respectively, in almost all "
"contexts, the exception being that when converted to a string, the "
"strings ``\"False\"`` or ``\"True\"`` are returned, respectively."
msgstr ""
"이것은 논리값 거짓과 참을 나타냅니다. ``False`` 와 ``True`` 두 객체만 불린 형 객체입니다. 불린 형은 int 형의"
" 자식형(subtype)이고, 대부분 상황에서 각기 0과1처럼 동작합니다. 예외는 문자열로 변환되는 경우인데, 각기 문자열 "
"``\"False\"`` 와 ``\"True\"`` 가 반환됩니다."

#: ../Doc/reference/datamodel.rst:218
msgid ""
"The rules for integer representation are intended to give the most "
"meaningful interpretation of shift and mask operations involving negative"
" integers."
msgstr "정수 표현 규칙은 음수가 포함된 시프트와 마스크 연산에 가장 의미 있는 해석을 제공하기 위한 것입니다."

#: ../Doc/reference/datamodel.rst:234
msgid ":class:`numbers.Real` (:class:`float`)"
msgstr ":class:`numbers.Real` (:class:`float`)"

#: ../Doc/reference/datamodel.rst:228
msgid ""
"These represent machine-level double precision floating point numbers. "
"You are at the mercy of the underlying machine architecture (and C or "
"Java implementation) for the accepted range and handling of overflow. "
"Python does not support single-precision floating point numbers; the "
"savings in processor and memory usage that are usually the reason for "
"using these are dwarfed by the overhead of using objects in Python, so "
"there is no reason to complicate the language with two kinds of floating "
"point numbers."
msgstr ""
"이것들은 기계 수준의 배정도(double precision) 부동 소수점 수를 나타냅니다. 허락되는 값의 범위와 오버플로의 처리에 "
"관해서는 하부 기계의 설계(와 C 나 자바 구현)에 따르는 수밖에 없습니다. 파이썬은 단정도(single precision) 부동 "
"소수점 수를 지원하지 않습니다; 이것들을 사용하는 이유가 되는 프로세서와 메모리의 절감은 파이썬에서 객체를 사용하는데 들어가는 "
"비용과 상쇄되어 미미해집니다. 그 때문에 두 가지 종류의 부동 소수점 수로 언어를 복잡하게 만들만한 가치가 없습니다."

#: ../Doc/reference/datamodel.rst:244
msgid ":class:`numbers.Complex` (:class:`complex`)"
msgstr ":class:`numbers.Complex` (:class:`complex`)"

#: ../Doc/reference/datamodel.rst:241
msgid ""
"These represent complex numbers as a pair of machine-level double "
"precision floating point numbers.  The same caveats apply as for floating"
" point numbers. The real and imaginary parts of a complex number ``z`` "
"can be retrieved through the read-only attributes ``z.real`` and "
"``z.imag``."
msgstr ""
"이것들은 기계 수준 배정도 부동 소수점 수의 쌍으로 복소수를 나타냅니다. 부동 소수점 수와 한계와 문제점을 공유합니다. 복소수 "
"``z`` 의 실수부와 허수부는, 읽기 전용 어트리뷰트 ``z.real`` 와 ``z.imag`` 로 꺼낼 수 있습니다."

#: ../Doc/reference/datamodel.rst:361
msgid "Sequences"
msgstr "시퀀스들"

#: ../Doc/reference/datamodel.rst:254
msgid ""
"These represent finite ordered sets indexed by non-negative numbers. The "
"built-in function :func:`len` returns the number of items of a sequence. "
"When the length of a sequence is *n*, the index set contains the numbers "
"0, 1, ..., *n*-1.  Item *i* of sequence *a* is selected by ``a[i]``."
msgstr ""
"음이 아닌 정수로 인덱싱(indexing)될 수 있는 유한한 길이의 순서 있는 집합을 나타냅니다. 내장함수 :func:`len` 은"
" 시퀀스가 가진 항목들의 개수를 돌려줍니다. 시퀀스의 길이가 *n* 일 때, 인덱스(index) 집합은 숫자 0, 1, ..., "
"*n*-1을 포함합니다. 시퀀스 *a* 의 항목 *i* 는 ``a[i]`` 로 선택됩니다."

#: ../Doc/reference/datamodel.rst:261
msgid ""
"Sequences also support slicing: ``a[i:j]`` selects all items with index "
"*k* such that *i* ``<=`` *k* ``<`` *j*.  When used as an expression, a "
"slice is a sequence of the same type.  This implies that the index set is"
" renumbered so that it starts at 0."
msgstr ""
"시퀀스는 슬라이싱도 지원합니다: ``a[i:j]`` 는 *i* ``<=`` *k* ``<`` *j* 를 만족하는 모든 항목 *k* "
"를 선택합니다. 표현식에서 사용될 때, 슬라이스는 같은 형의 시퀀스입니다. 인덱스 집합은 0에서 시작되도록 다시 번호 매겨집니다."

#: ../Doc/reference/datamodel.rst:266
msgid ""
"Some sequences also support \"extended slicing\" with a third \"step\" "
"parameter: ``a[i:j:k]`` selects all items of *a* with index *x* where ``x"
" = i + n*k``, *n* ``>=`` ``0`` and *i* ``<=`` *x* ``<`` *j*."
msgstr ""
"어떤 시퀀스는 세 번째 \"스텝(step)\" 매개변수를 사용하는 \"확장 슬라이싱(extended slicing)\"도 "
"지원합니다: ``a[i:j:k]`` 는 ``x = i + n*k``, *n* ``>=`` ``0``, *i* ``<=`` *x* "
"``<`` *j* 를 만족하는 모든 항목 *x* 를 선택합니다."

#: ../Doc/reference/datamodel.rst:270
msgid "Sequences are distinguished according to their mutability:"
msgstr "시퀀스는 불변성에 따라 구분됩니다"

#: ../Doc/reference/datamodel.rst:327
msgid "Immutable sequences"
msgstr "불변 시퀀스"

#: ../Doc/reference/datamodel.rst:277
msgid ""
"An object of an immutable sequence type cannot change once it is created."
"  (If the object contains references to other objects, these other "
"objects may be mutable and may be changed; however, the collection of "
"objects directly referenced by an immutable object cannot change.)"
msgstr ""
"불변 시퀀스 형의 객체는 일단 만들어진 후에는 변경될 수 없습니다. (만약 다른 객체로의 참조를 포함하면, 그 객체는 가변일 수 "
"있고, 변경될 수 있습니다; 하지만, 불변 객체로부터 참조되는 객체의 집합 자체는 변경될 수 없습니다.)"

#: ../Doc/reference/datamodel.rst:282
msgid "The following types are immutable sequences:"
msgstr "다음과 같은 형들은 불변 시퀀스입니다:"

#: ../Doc/reference/datamodel.rst:305
msgid "Strings"
msgstr "문자열(Strings)"

#: ../Doc/reference/datamodel.rst:295
msgid ""
"A string is a sequence of values that represent Unicode code points. All "
"the code points in the range ``U+0000 - U+10FFFF`` can be represented in "
"a string.  Python doesn't have a :c:type:`char` type; instead, every code"
" point in the string is represented as a string object with length ``1``."
"  The built-in function :func:`ord` converts a code point from its string"
" form to an integer in the range ``0 - 10FFFF``; :func:`chr` converts an "
"integer in the range ``0 - 10FFFF`` to the corresponding length ``1`` "
"string object. :meth:`str.encode` can be used to convert a :class:`str` "
"to :class:`bytes` using the given text encoding, and :meth:`bytes.decode`"
" can be used to achieve the opposite."
msgstr ""
"문자열은 유니코드 코드 포인트(Unicode code point)들을 표현하는 값들의 시퀀스입니다. ``U+0000 - "
"U+10FFFF`` 범위의 모든 코드 포인트들은 문자열로 표현될 수 있습니다. 파이썬에는 :c:type:`char` 형이 없습니다."
" 대신에 문자열에 있는 각 코드 포인트는 길이 ``1`` 인 문자열 객체로 표현됩니다. 내장 함수 :func:`ord` 는 코드 "
"포인트를 문자열 형식에서 ``0 - 10FFFF`` 범위의 정수로 변환합니다; :func:`chr` 은 범위 ``0 - "
"10FFFF`` 의 정수를 해당하는 길이 ``1`` 의 문자열 객체로 변환합니다. :meth:`str.encode` 는 주어진 "
"텍스트 인코딩을 사용해서 :class:`str` 을 :class:`bytes` 로 변환하고, :meth:`bytes.decode` "
"는 그 반대 작업을 수행합니다."

#: ../Doc/reference/datamodel.rst:318
msgid "Tuples"
msgstr "튜플(Tuples)"

#: ../Doc/reference/datamodel.rst:313
msgid ""
"The items of a tuple are arbitrary Python objects. Tuples of two or more "
"items are formed by comma-separated lists of expressions.  A tuple of one"
" item (a 'singleton') can be formed by affixing a comma to an expression "
"(an expression by itself does not create a tuple, since parentheses must "
"be usable for grouping of expressions).  An empty tuple can be formed by "
"an empty pair of parentheses."
msgstr ""
"튜플의 항목은 임의의 파이썬 객체입니다. 두 개 이상의 항목으로 구성되는 튜플은 콤마로 분리된 표현식의 목록으로 만들 수 있습니다."
" 하나의 항목으로 구성된 튜플(싱글턴,singleton)은 표현식에 콤마를 붙여서 만들 수 있습니다(괄호로 표현식을 묶을 수 "
"있으므로, 표현식 만으로는 튜플을 만들지 않습니다). 빈 튜플은 한 쌍의 빈 괄호로 만들 수 있습니다."

#: ../Doc/reference/datamodel.rst:327
msgid "Bytes"
msgstr "바이트열(Bytes)"

#: ../Doc/reference/datamodel.rst:323
msgid ""
"A bytes object is an immutable array.  The items are 8-bit bytes, "
"represented by integers in the range 0 <= x < 256.  Bytes literals (like "
"``b'abc'``) and the built-in :func:`bytes()` constructor can be used to "
"create bytes objects.  Also, bytes objects can be decoded to strings via "
"the :meth:`~bytes.decode` method."
msgstr ""
"바이트열(bytes) 객체는 불변 배열입니다. 항목은 8-비트 바이트인데, 0 <= x < 256 범위의 정수로 표현됩니다. 바이트"
" 객체를 만들 때는 바이트열 리터럴(``b'abc'`` 와 같은) 과 내장 :func:`bytes()` "
"생성자(constructor)를 사용할 수 있습니다. 또한, 바이트열 객체는 :meth:`~bytes.decode` 메서드를 통해 "
"문자열로 디코딩될 수 있습니다."

#: ../Doc/reference/datamodel.rst:361
msgid "Mutable sequences"
msgstr "가변 시퀀스"

#: ../Doc/reference/datamodel.rst:337
msgid ""
"Mutable sequences can be changed after they are created.  The "
"subscription and slicing notations can be used as the target of "
"assignment and :keyword:`del` (delete) statements."
msgstr ""
"가변 시퀀스는 만들어진 후에 변경될 수 있습니다. 서브스크립션(subscription)과 슬라이싱은 대입문과 "
":keyword:`del` (삭제) 문의 대상으로 사용될 수 있습니다."

#: ../Doc/reference/datamodel.rst:341
msgid "There are currently two intrinsic mutable sequence types:"
msgstr "현재 두 개의 내장 가변 시퀀스형이 있습니다:"

#: ../Doc/reference/datamodel.rst:348
msgid "Lists"
msgstr "리스트(Lists)"

#: ../Doc/reference/datamodel.rst:346
msgid ""
"The items of a list are arbitrary Python objects.  Lists are formed by "
"placing a comma-separated list of expressions in square brackets. (Note "
"that there are no special cases needed to form lists of length 0 or 1.)"
msgstr ""
"리스트의 항목은 임의의 파이썬 객체입니다. 리스트는 콤마로 분리된 표현식을 대괄호 안에 넣어서 만들 수 있습니다. (길이 0이나 "
"1의 리스트를 만드는데 별도의 규칙이 필요 없습니다.)"

#: ../Doc/reference/datamodel.rst:356
msgid "Byte Arrays"
msgstr "바이트 배열(Byte Arrays)"

#: ../Doc/reference/datamodel.rst:353
msgid ""
"A bytearray object is a mutable array. They are created by the built-in "
":func:`bytearray` constructor.  Aside from being mutable (and hence "
"unhashable), byte arrays otherwise provide the same interface and "
"functionality as immutable :class:`bytes` objects."
msgstr ""
"바이트 배열(bytearray) 객체는 가변 배열입니다. 내장 :func:`bytearray` 생성자로 만들어집니다. 가변이라는 "
"것(그래서 해싱 불가능하다는 것)을 제외하고, 바이트 배열은 불변 바이트열( :class:`bytes`) 객체와 같은 인터페이스와 "
"기능을 제공합니다."

#: ../Doc/reference/datamodel.rst:360
msgid ""
"The extension module :mod:`array` provides an additional example of a "
"mutable sequence type, as does the :mod:`collections` module."
msgstr ""
"확장 모듈 :mod:`array` 는 추가의 가변 시퀀스 형을 제공하는데, :mod:`collections` 모듈 역시 "
"마찬가지입니다."

#: ../Doc/reference/datamodel.rst:395
msgid "Set types"
msgstr "집합 형들(Set types)"

#: ../Doc/reference/datamodel.rst:368
msgid ""
"These represent unordered, finite sets of unique, immutable objects. As "
"such, they cannot be indexed by any subscript. However, they can be "
"iterated over, and the built-in function :func:`len` returns the number "
"of items in a set. Common uses for sets are fast membership testing, "
"removing duplicates from a sequence, and computing mathematical "
"operations such as intersection, union, difference, and symmetric "
"difference."
msgstr ""
"이것들은 중복 없는 불변 객체들의 순서 없고 유한한 집합을 나타냅니다. 인덱싱할 수 없습니다. 하지만 이터레이트할 수 있고, 내장 "
"함수 :func:`len` 은 집합 안에 있는 항목들의 개수를 돌려줍니다. 집합의 일반적인 용도는 빠른 멤버십 검사(fast "
"membership testing), 시퀀스에서 중복된 항목 제거, 교집합(intersection), 합집합(union), "
"차집합(difference), 대칭차집합(symmetric difference)과 같은 집합 연산을 계산하는 것입니다."

#: ../Doc/reference/datamodel.rst:375
msgid ""
"For set elements, the same immutability rules apply as for dictionary "
"keys. Note that numeric types obey the normal rules for numeric "
"comparison: if two numbers compare equal (e.g., ``1`` and ``1.0``), only "
"one of them can be contained in a set."
msgstr ""
"집합의 원소들에는 딕셔너리 키와 같은 불변성 규칙이 적용됩니다. 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이 적용된다는 점에 "
"주의해야 합니다: 만약 두 숫자가 같다고 비교되면(예를 들어, ``1`` 과 ``1.0``), 그중 하나만 집합에 들어갈 수 "
"있습니다."

#: ../Doc/reference/datamodel.rst:380
msgid "There are currently two intrinsic set types:"
msgstr "현재 두 개의 내장 집합 형이 있습니다:"

#: ../Doc/reference/datamodel.rst:387
msgid "Sets"
msgstr "집합(Sets)"

#: ../Doc/reference/datamodel.rst:385
msgid ""
"These represent a mutable set. They are created by the built-in "
":func:`set` constructor and can be modified afterwards by several "
"methods, such as :meth:`~set.add`."
msgstr ""
"이것들은 가변 집합을 나타냅니다. 내장 :func:`set` 생성자로 만들 수 있고, :meth:`~set.add` 같은 메서드들을"
" 사용해서 나중에 수정할 수 있습니다."

#: ../Doc/reference/datamodel.rst:395
msgid "Frozen sets"
msgstr "불변 집합(Frozen sets)"

#: ../Doc/reference/datamodel.rst:392
msgid ""
"These represent an immutable set.  They are created by the built-in "
":func:`frozenset` constructor.  As a frozenset is immutable and "
":term:`hashable`, it can be used again as an element of another set, or "
"as a dictionary key."
msgstr ""
"이것들은 불변 집합을 나타냅니다. 내장 :func:`frozenset` 생성자로 만들 수 있습니다. 불변 집합(frozenset)은"
" 불변이고 :term:`해시 가능 <hashable>` 하므로, 다른 집합의 원소나, 딕셔너리의 키로 사용될 수 있습니다."

#: ../Doc/reference/datamodel.rst:432
msgid "Mappings"
msgstr "매핑(Mappings)"

#: ../Doc/reference/datamodel.rst:403
msgid ""
"These represent finite sets of objects indexed by arbitrary index sets. "
"The subscript notation ``a[k]`` selects the item indexed by ``k`` from "
"the mapping ``a``; this can be used in expressions and as the target of "
"assignments or :keyword:`del` statements. The built-in function "
":func:`len` returns the number of items in a mapping."
msgstr ""
"이것들은 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 인덱스 표기법(subscript notation) "
"``a[k]`` 는 매핑 ``a`` 에서 ``k`` 로 인덱스 되는 항목을 선택합니다; 이것은 표현식에 사용될 수도 있고, 대입이나"
" :keyword:`del` 문장의 대상이 될 수도 있습니다. 내장 함수 :func:`len` 은 매핑에 포함된 항목들의 개수를 "
"돌려줍니다."

#: ../Doc/reference/datamodel.rst:409
msgid "There is currently a single intrinsic mapping type:"
msgstr "현재 한 개의 내장 매핑 형이 있습니다:"

#: ../Doc/reference/datamodel.rst:432
msgid "Dictionaries"
msgstr "딕셔너리(Dictionaries)"

#: ../Doc/reference/datamodel.rst:414
msgid ""
"These represent finite sets of objects indexed by nearly arbitrary "
"values.  The only types of values not acceptable as keys are values "
"containing lists or dictionaries or other mutable types that are compared"
" by value rather than by object identity, the reason being that the "
"efficient implementation of dictionaries requires a key's hash value to "
"remain constant. Numeric types used for keys obey the normal rules for "
"numeric comparison: if two numbers compare equal (e.g., ``1`` and "
"``1.0``) then they can be used interchangeably to index the same "
"dictionary entry."
msgstr ""
"이것들은 거의 임의의 인덱스 집합으로 인덱싱되는 객체들의 유한한 집합을 나타냅니다. 키로 사용할 수 없는 것들은 리스트, 딕셔너리나"
" 그 외의 가변형 중에서 아이덴티티가 아니라 값으로 비교되는 것들뿐입니다. 딕셔너리의 효율적인 구현이, 키의 해시값이 도중에 "
"변경되지 않고 계속 같은 값으로 유지되도록 요구하고 있기 때문입니다. 키로 사용되는 숫자 형의 경우는 숫자 비교에 관한 일반 원칙이"
" 적용됩니다: 만약 두 숫자가 같다고 비교되면(예를 들어, ``1`` 과 ``1.0``), 둘 다 같은 딕셔너리 항목을 인덱싱하는데"
" 사용될 수 있습니다."

#: ../Doc/reference/datamodel.rst:423
msgid ""
"Dictionaries are mutable; they can be created by the ``{...}`` notation "
"(see section :ref:`dict`)."
msgstr "딕셔너리는 가변입니다; ``{...}`` 표기법으로 만들 수 있습니다 (:ref:`dict` 섹션을 참고하십시오)."

#: ../Doc/reference/datamodel.rst:430
msgid ""
"The extension modules :mod:`dbm.ndbm` and :mod:`dbm.gnu` provide "
"additional examples of mapping types, as does the :mod:`collections` "
"module."
msgstr ""
"확장 모듈 :mod:`dbm.ndbm` 과 :mod:`dbm.gnu` 는 추가의 매핑 형을 제공하는데, "
":mod:`collections` 모듈 역시 마찬가지입니다."

#: ../Doc/reference/datamodel.rst:694
msgid "Callable types"
msgstr "콜러블(Callable types)"

#: ../Doc/reference/datamodel.rst:441
msgid ""
"These are the types to which the function call operation (see section "
":ref:`calls`) can be applied:"
msgstr "이것들은 함수 호출 연산(:ref:`calls` 섹션 참고)이 적용될 수 있는 형들입니다:"

#: ../Doc/reference/datamodel.rst:542
msgid "User-defined functions"
msgstr "사용자 정의 함수"

#: ../Doc/reference/datamodel.rst:450
msgid ""
"A user-defined function object is created by a function definition (see "
"section :ref:`function`).  It should be called with an argument list "
"containing the same number of items as the function's formal parameter "
"list."
msgstr ""
"사용자 정의 함수 객체는 함수 정의를 통해 만들어집니다 (:ref:`function` 섹션 참고). 함수의 형식 "
"매개변수(formal parameter) 목록과 같은 개수의 항목을 포함하는 인자(argument) 목록으로 호출되어야 합니다."

#: ../Doc/reference/datamodel.rst:455
msgid "Special attributes:"
msgstr "특수 어트리뷰트들(Special attributes):"

#: ../Doc/reference/datamodel.rst:473
msgid "Attribute"
msgstr "어트리뷰트"

#: ../Doc/reference/datamodel.rst:473
msgid "Meaning"
msgstr "의미"

#: ../Doc/reference/datamodel.rst:475
msgid ":attr:`__doc__`"
msgstr ":attr:`__doc__`"

#: ../Doc/reference/datamodel.rst:475
msgid ""
"The function's documentation string, or ``None`` if unavailable; not "
"inherited by subclasses."
msgstr "함수를 설명하는 문자열 또는 없는 경우 ``None``; 서브 클래스로 상속되지 않습니다."

#: ../Doc/reference/datamodel.rst:475 ../Doc/reference/datamodel.rst:480
#: ../Doc/reference/datamodel.rst:483 ../Doc/reference/datamodel.rst:488
#: ../Doc/reference/datamodel.rst:492 ../Doc/reference/datamodel.rst:498
#: ../Doc/reference/datamodel.rst:508 ../Doc/reference/datamodel.rst:519
#: ../Doc/reference/datamodel.rst:526
msgid "Writable"
msgstr "쓰기 가능"

#: ../Doc/reference/datamodel.rst:480
msgid ":attr:`~definition.\\ __name__`"
msgstr ":attr:`~definition.\\ __name__`"

#: ../Doc/reference/datamodel.rst:480
msgid "The function's name."
msgstr "함수의 이름."

#: ../Doc/reference/datamodel.rst:483
msgid ":attr:`~definition.\\ __qualname__`"
msgstr ":attr:`~definition.\\ __qualname__`"

#: ../Doc/reference/datamodel.rst:483
msgid "The function's :term:`qualified name`."
msgstr "함수의 :term:`정규화된 이름 <qualified name>`."

#: ../Doc/reference/datamodel.rst:488
msgid ":attr:`__module__`"
msgstr ":attr:`__module__`"

#: ../Doc/reference/datamodel.rst:488
msgid ""
"The name of the module the function was defined in, or ``None`` if "
"unavailable."
msgstr "함수가 정의된 모듈의 이름 또는 (없는 경우) ``None``"

#: ../Doc/reference/datamodel.rst:492
msgid ":attr:`__defaults__`"
msgstr ":attr:`__defaults__`"

#: ../Doc/reference/datamodel.rst:492
msgid ""
"A tuple containing default argument values for those arguments that have "
"defaults, or ``None`` if no arguments have a default value."
msgstr "인자의 기본값 또는 (없는 경우) `None` 으로 만들어진 튜플."

#: ../Doc/reference/datamodel.rst:498
msgid ":attr:`__code__`"
msgstr ":attr:`__code__`"

#: ../Doc/reference/datamodel.rst:498
msgid "The code object representing the compiled function body."
msgstr "컴파일된 함수의 바디(body) 를 나타내는 코드 객체"

#: ../Doc/reference/datamodel.rst:501
msgid ":attr:`__globals__`"
msgstr ":attr:`__globals__`"

#: ../Doc/reference/datamodel.rst:501
msgid ""
"A reference to the dictionary that holds the function's global variables "
"--- the global namespace of the module in which the function was defined."
msgstr "함수의 전역 변수들을 가진 딕셔너리에 대한 참조 --- 함수가 정의된 모듈의 전역 이름 공간(namespace)"

#: ../Doc/reference/datamodel.rst:501 ../Doc/reference/datamodel.rst:512
msgid "Read-only"
msgstr "읽기 전용"

#: ../Doc/reference/datamodel.rst:508
msgid ":attr:`~object.__dict__`"
msgstr ":attr:`~object.__dict__`"

#: ../Doc/reference/datamodel.rst:508
msgid "The namespace supporting arbitrary function attributes."
msgstr "임의의 함수 어트리뷰트를 지원하는 이름 공간."

#: ../Doc/reference/datamodel.rst:512
msgid ":attr:`__closure__`"
msgstr ":attr:`__closure__`"

#: ../Doc/reference/datamodel.rst:512
msgid ""
"``None`` or a tuple of cells that contain bindings for the function's "
"free variables. See below for information on the ``cell_contents`` "
"attribute."
msgstr ""
"``None`` 또는 함수의 자유 변수(free variable)들에 대한 연결을 가진 셀(cell)들의 튜플. "
"``cell_contents`` 어트리뷰트에 대한 정보는 아래를 보십시오."

#: ../Doc/reference/datamodel.rst:519
msgid ":attr:`__annotations__`"
msgstr ":attr:`__annotations__`"

#: ../Doc/reference/datamodel.rst:519
msgid ""
"A dict containing annotations of parameters.  The keys of the dict are "
"the parameter names, and ``'return'`` for the return annotation, if "
"provided."
msgstr ""
"매개변수의 어노테이션을 가진 dict. dict의 키는 매개변수의 이름인데, 반환 값 어노테이션이 있다면 ``'return'`` 을"
" 키로 사용합니다."

#: ../Doc/reference/datamodel.rst:526
msgid ":attr:`__kwdefaults__`"
msgstr ":attr:`__kwdefaults__`"

#: ../Doc/reference/datamodel.rst:526
msgid "A dict containing defaults for keyword-only parameters."
msgstr "키워드 형태로만 전달 가능한 매개변수들의 기본값을 가진 dict."

#: ../Doc/reference/datamodel.rst:530
msgid ""
"Most of the attributes labelled \"Writable\" check the type of the "
"assigned value."
msgstr "\"쓰기 가능\" 하다고 표시된 대부분의 어트리뷰트들은 값이 대입될 때 형을 검사합니다."

#: ../Doc/reference/datamodel.rst:532
msgid ""
"Function objects also support getting and setting arbitrary attributes, "
"which can be used, for example, to attach metadata to functions.  Regular"
" attribute dot-notation is used to get and set such attributes. *Note "
"that the current implementation only supports function attributes on "
"user-defined functions. Function attributes on built-in functions may be "
"supported in the future.*"
msgstr ""
"함수 객체는 임의의 어트리뷰트를 읽고 쓸 수 있도록 지원하는데, 예를 들어 함수에 메타데이터(metadata)를 붙이는데 사용될 수"
" 있습니다. 어트리뷰트를 읽거나 쓸 때는 일반적인 점 표현법(dot-notation)이 사용됩니다. *현재 구현은 오직 사용자 정의"
" 함수만 함수 어트리뷰트를 지원함에 주의해야 합니다. 내장 함수의 함수 어트리뷰트는 미래에 지원될 수 있습니다.*"

#: ../Doc/reference/datamodel.rst:538
msgid ""
"A cell object has the attribute ``cell_contents``. This can be used to "
"get the value of the cell, as well as set the value."
msgstr ""
"셀 객체는 ``cell_contents`` 어트리뷰트를 가지고 있습니다. 셀의 값을 읽을 뿐만 아니라 값을 설정하는 데도 사용할 수"
" 있습니다."

#: ../Doc/reference/datamodel.rst:541
msgid ""
"Additional information about a function's definition can be retrieved "
"from its code object; see the description of internal types below."
msgstr "함수 정의에 관한 추가적인 정보를 코드 객체로부터 얻을 수 있습니다. 아래에 나오는 내부 형의 기술을 참고하십시오."

#: ../Doc/reference/datamodel.rst:611
msgid "Instance methods"
msgstr "인스턴스 메서드(Instance methods)"

#: ../Doc/reference/datamodel.rst:550
msgid ""
"An instance method object combines a class, a class instance and any "
"callable object (normally a user-defined function)."
msgstr "인스턴스 메서드는 클래스, 클래스 인스턴스와 모든 콜러블 객체 (보통 사용자 정의 함수)을 결합합니다."

#: ../Doc/reference/datamodel.rst:560
msgid ""
"Special read-only attributes: :attr:`__self__` is the class instance "
"object, :attr:`__func__` is the function object; :attr:`__doc__` is the "
"method's documentation (same as ``__func__.__doc__``); "
":attr:`~definition.__name__` is the method name (same as "
"``__func__.__name__``); :attr:`__module__` is the name of the module the "
"method was defined in, or ``None`` if unavailable."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`__self__` 는 클래스 인스턴스 객체, :attr:`__func__` 는 함수 "
"객체; :attr:`__doc__` 은 메서드의 설명 (``__func__.__doc__`` 과 같습니다); "
":attr:`~definition.__name__` 은 메서드의 이름 (``__func__.__name__`` 과 같습니다); "
":attr:`__module__` 은 메서드가 정의된 모듈의 이름이거나 없는 경우 ``None``."

#: ../Doc/reference/datamodel.rst:566
msgid ""
"Methods also support accessing (but not setting) the arbitrary function "
"attributes on the underlying function object."
msgstr "메서드는 기반 함수의 모든 함수 어트리뷰트들을 읽을 수 있도록 지원합니다(하지만 쓰기는 지원하지 않습니다)."

#: ../Doc/reference/datamodel.rst:569
msgid ""
"User-defined method objects may be created when getting an attribute of a"
" class (perhaps via an instance of that class), if that attribute is a "
"user-defined function object or a class method object."
msgstr ""
"어트리뷰트가 사용자 정의 함수 객체이거나 클래스 메서드 객체면, 사용자 정의 메서드 객체는 클래스의 어트리뷰트를 읽을 때 만들어질 "
"수 있습니다 (아마도 그 클래스의 인스턴스를 통해서)."

#: ../Doc/reference/datamodel.rst:573
msgid ""
"When an instance method object is created by retrieving a user-defined "
"function object from a class via one of its instances, its "
":attr:`__self__` attribute is the instance, and the method object is said"
" to be bound.  The new method's :attr:`__func__` attribute is the "
"original function object."
msgstr ""
"인스턴스 메서드 객체가 클래스 인스턴스를 통해 클래스의 사용자 정의 함수 객체를 읽음으로써 만들어질 때, "
":attr:`__self__` 어트리뷰트는 인스턴스이고, 메서드 객체는 결합(bound)하였다고 말합니다. 새 메서드의 "
":attr:`__func__` 어트리뷰트는 원래의 함수 객체입니다."

#: ../Doc/reference/datamodel.rst:579
msgid ""
"When a user-defined method object is created by retrieving another method"
" object from a class or instance, the behaviour is the same as for a "
"function object, except that the :attr:`__func__` attribute of the new "
"instance is not the original method object but its :attr:`__func__` "
"attribute."
msgstr ""
"클래스나 인스턴스로부터 다른 메서드 객체를 읽음으로써 사용자 정의 메서드 객체가 만들어질 때, 새 인스턴스의 "
":attr:`__func__` 어트리뷰트가 원래의 메서드 객체가 아니라, 그것의 :attr:`__func__` 어트리뷰트라는 점만 "
"제외하고는 함수 객체의 경우와 같은 방식으로 동작합니다."

#: ../Doc/reference/datamodel.rst:585
msgid ""
"When an instance method object is created by retrieving a class method "
"object from a class or instance, its :attr:`__self__` attribute is the "
"class itself, and its :attr:`__func__` attribute is the function object "
"underlying the class method."
msgstr ""
"인스턴스 메서드 객체가 클래스나 인스턴스로부터 클래스 메서드 객체를 읽음으로써 만들어질 때, :attr:`__self__` "
"어트리뷰트는 클래스 자신이고, :attr:`__func__` 어트리뷰트는 클래스 메서드가 기반을 두는 함수 객체입니다."

#: ../Doc/reference/datamodel.rst:590
msgid ""
"When an instance method object is called, the underlying function "
"(:attr:`__func__`) is called, inserting the class instance "
"(:attr:`__self__`) in front of the argument list.  For instance, when "
":class:`C` is a class which contains a definition for a function "
":meth:`f`, and ``x`` is an instance of :class:`C`, calling ``x.f(1)`` is "
"equivalent to calling ``C.f(x, 1)``."
msgstr ""
"인스턴스 메서드 객체가 호출될 때, 기반을 두는 함수 (:attr:`__func__`) 가 호출되는데, 인자 목록의 앞에 클래스 "
"인스턴스 (:attr:`__self__`) 가 삽입됩니다. 예를 들어, :class:`C` 가 함수 :meth:`f` 의 정의를 "
"포함하는 클래스이고, ``x`` 가 :class:`C` 의 인스턴스일 때, ``x.f(1)`` 를 호출하는 것은 ``C.f(x, "
"1)`` 을 호출하는 것과 같습니다."

#: ../Doc/reference/datamodel.rst:597
msgid ""
"When an instance method object is derived from a class method object, the"
" \"class instance\" stored in :attr:`__self__` will actually be the class"
" itself, so that calling either ``x.f(1)`` or ``C.f(1)`` is equivalent to"
" calling ``f(C,1)`` where ``f`` is the underlying function."
msgstr ""
"인스턴스 메서드 객체가 클래스 메서드 객체로부터 올 때, :attr:`__self__` 에 저장된 \"클래스 인스턴스\" 는 "
"실제로는 클래스 자신입니다. 그래서 ``x.f(1)`` 이나 ``C.f(1)`` 을 호출하는 것은 ``f(C,1)`` 를 호출하는 "
"것과 같습니다 (``f`` 는 기반 함수입니다)."

#: ../Doc/reference/datamodel.rst:602
msgid ""
"Note that the transformation from function object to instance method "
"object happens each time the attribute is retrieved from the instance.  "
"In some cases, a fruitful optimization is to assign the attribute to a "
"local variable and call that local variable. Also notice that this "
"transformation only happens for user-defined functions; other callable "
"objects (and all non-callable objects) are retrieved without "
"transformation.  It is also important to note that user-defined functions"
" which are attributes of a class instance are not converted to bound "
"methods; this *only* happens when the function is an attribute of the "
"class."
msgstr ""
"함수 객체에서 인스턴스 객체로의 변환은 인스턴스로부터 어트리뷰트를 읽을 때마다 일어남에 주의해야 합니다. 어떤 경우에, 어트리뷰트를"
" 지역 변수에 대입하고, 그 지역 변수를 호출하는 것이 효과적인 최적화가 됩니다. 또한, 이 변환이 사용자 정의 함수에 대해서만 "
"발생함에 주의해야 합니다; 다른 콜러블 객체 (그리고 콜러블이 아닌 모든 객체)는 변환 없이 읽힙니다. 클래스 인스턴스의 "
"어트리뷰트인 사용자 정의 함수는 결합한 메서드로 변환되지 않는다는 것도 중요합니다; 이 변환은 함수가 클래스 어트리뷰트일 때만 "
"일어납니다."

#: ../Doc/reference/datamodel.rst:626
msgid "Generator functions"
msgstr "제너레이터 함수(Generator functions)"

#: ../Doc/reference/datamodel.rst:618
msgid ""
"A function or method which uses the :keyword:`yield` statement (see "
"section :ref:`yield`) is called a :dfn:`generator function`.  Such a "
"function, when called, always returns an iterator object which can be "
"used to execute the body of the function:  calling the iterator's "
":meth:`iterator.__next__` method will cause the function to execute until"
" it provides a value using the :keyword:`!yield` statement.  When the "
"function executes a :keyword:`return` statement or falls off the end, a "
":exc:`StopIteration` exception is raised and the iterator will have "
"reached the end of the set of values to be returned."
msgstr ""
":keyword:`yield` 문(:ref:`yield` 절 참조)을 사용하는 함수나 메서드를 :dfn:`제너레이터 함수 "
"(generator function)` 라고 부릅니다. 이런 함수를 호출하면 항상 이터레이터(iterator) 객체를 돌려주는데, "
"함수의 바디(body)를 실행하는 데 사용됩니다: 이터레이터의 :meth:`iterator.__next__` 메서드를 호출하면 "
":keyword:`!yield` 문이 값을 제공할 때까지 함수가 실행됩니다. 함수가 :keyword:`return` 문을 실행하거나"
" 끝에 도달하면 :exc:`StopIteration` 예외를 일으키고, 이터레이터는 반환하는 값들의 끝에 도달하게 됩니다."

#: ../Doc/reference/datamodel.rst:636
msgid "Coroutine functions"
msgstr "코루틴 함수(Coroutine functions)"

#: ../Doc/reference/datamodel.rst:632
msgid ""
"A function or method which is defined using :keyword:`async def` is "
"called a :dfn:`coroutine function`.  Such a function, when called, "
"returns a :term:`coroutine` object.  It may contain :keyword:`await` "
"expressions, as well as :keyword:`async with` and :keyword:`async for` "
"statements. See also the :ref:`coroutine-objects` section."
msgstr ""
":keyword:`async def` 를 사용해서 정의되는 함수나 메서드를 :dfn:`코루틴 함수 (coroutine "
"function)` 라고 부릅니다. 이런 함수를 호출하면 :term:`코루틴 <coroutine>` 객체를 돌려줍니다. "
":keyword:`await` 표현식을 비롯해, :keyword:`async with` 와 :keyword:`async for` "
"문을 사용할 수 있습니다. :ref:`coroutine-objects` 섹션을 참조하십시오."

#: ../Doc/reference/datamodel.rst:655
msgid "Asynchronous generator functions"
msgstr "비동기 제너레이터 함수(Asynchronous generator functions)"

#: ../Doc/reference/datamodel.rst:643
msgid ""
"A function or method which is defined using :keyword:`async def` and "
"which uses the :keyword:`yield` statement is called a :dfn:`asynchronous "
"generator function`.  Such a function, when called, returns an "
"asynchronous iterator object which can be used in an :keyword:`async for`"
" statement to execute the body of the function."
msgstr ""
":keyword:`async def` 를 사용해서 정의되는 함수가 :keyword:`yield` 문을 사용하면 :dfn:`비동기 "
"제너레이터 함수 (asynchronous generator function)` 라고 부릅니다. 이런 함수를 호출하면 항상 비동기 "
"이터레이터(asynchronous iterator) 객체를 돌려주는데, 함수의 바디(body)를 실행하기 위해 "
":keyword:`async for` 문에서 사용됩니다."

#: ../Doc/reference/datamodel.rst:649
msgid ""
"Calling the asynchronous iterator's :meth:`aiterator.__anext__` method "
"will return an :term:`awaitable` which when awaited will execute until it"
" provides a value using the :keyword:`yield` expression.  When the "
"function executes an empty :keyword:`return` statement or falls off the "
"end, a :exc:`StopAsyncIteration` exception is raised and the asynchronous"
" iterator will have reached the end of the set of values to be yielded."
msgstr ""
"비동기 이터레이터의 :meth:`aiterator.__anext__` 메서드를 호출하면 :term:`어웨이터블 "
"<awaitable>` 을 돌려주는데, await 할 때 :keyword:`yield` 문이 값을 제공할 때까지 함수가 실행됩니다."
" 함수가 빈 :keyword:`return` 문을 실행하거나 끝에 도달하면 :exc:`StopAsyncIteration` 예외를 "
"일으키고, 비동기 이터레이터는 반환하는 값들의 끝에 도달하게 됩니다."

#: ../Doc/reference/datamodel.rst:670
msgid "Built-in functions"
msgstr "내장 함수(Built-in functions)"

#: ../Doc/reference/datamodel.rst:663
msgid ""
"A built-in function object is a wrapper around a C function.  Examples of"
" built-in functions are :func:`len` and :func:`math.sin` (:mod:`math` is "
"a standard built-in module). The number and type of the arguments are "
"determined by the C function. Special read-only attributes: "
":attr:`__doc__` is the function's documentation string, or ``None`` if "
"unavailable; :attr:`~definition.__name__` is the function's name; "
":attr:`__self__` is set to ``None`` (but see the next item); "
":attr:`__module__` is the name of the module the function was defined in "
"or ``None`` if unavailable."
msgstr ""
"내장 함수 객체는 C 함수를 둘러싸고 있습니다(wrapper). 내장 함수의 예로는 :func:`len` 과 "
":func:`math.sin` (:mod:`math` 는 표준 내장 모듈입니다) 가 있습니다. 인자의 개수와 형은 C 함수에 의해 "
"결정됩니다. 특수 읽기 전용 어트리뷰트들: :attr:`__doc__` 은 함수의 설명 문자열 또는 없는 경우 ``None`` "
"입니다; :attr:`~definition.__name__` 은 함수의 이름입니다; :attr:`__self__` 는 "
"``None`` 으로 설정됩니다 (하지만 다음 항목을 보십시오); :attr:`__module__` 은 함수가 정의된 모듈의 "
"이름이거나 없는 경우 ``None`` 입니다."

#: ../Doc/reference/datamodel.rst:682
msgid "Built-in methods"
msgstr "내장 메서드(Built-in methods)"

#: ../Doc/reference/datamodel.rst:678
msgid ""
"This is really a different disguise of a built-in function, this time "
"containing an object passed to the C function as an implicit extra "
"argument.  An example of a built-in method is ``alist.append()``, "
"assuming *alist* is a list object. In this case, the special read-only "
"attribute :attr:`__self__` is set to the object denoted by *alist*."
msgstr ""
"이것은 사실 내장 함수의 다른 모습입니다. 이번에는 묵시적인 추가의 인자로 C 함수에 전달되는 객체를 갖고 있습니다. 내장 메서드의"
" 예로는 ``alist.append()`` 가 있는데, *alist* 는 리스트 객체입니다. 이 경우에, 특수 읽기 전용 어트리뷰트"
" :attr:`__self__` 는 *alist* 로 표현된 객체로 설정됩니다."

#: ../Doc/reference/datamodel.rst:689
msgid "Classes"
msgstr "클래스(Classes)"

#: ../Doc/reference/datamodel.rst:685
msgid ""
"Classes are callable.  These objects normally act as factories for new "
"instances of themselves, but variations are possible for class types that"
" override :meth:`__new__`.  The arguments of the call are passed to "
":meth:`__new__` and, in the typical case, to :meth:`__init__` to "
"initialize the new instance."
msgstr ""
"클래스는 콜러블입니다. 이 객체들은 보통 자신의 새로운 인스턴스를 만드는 팩토리(factory)로 동작하는데, "
":meth:`__new__` 메서드를 재정의(override)하는 클래스 형에서는 달라질 수도 있습니다. 호출 인자는 "
":meth:`__new__` 로 전달되고, 일반적으로, 새 인스턴스를 초기화하기 위해 :meth:`__init__` 로도 "
"전달됩니다."

#: ../Doc/reference/datamodel.rst:694
msgid "Class Instances"
msgstr "클래스 인스턴스(Class Instances)"

#: ../Doc/reference/datamodel.rst:692
msgid ""
"Instances of arbitrary classes can be made callable by defining a "
":meth:`__call__` method in their class."
msgstr "클래스에서 :meth:`__call__` 메서드를 정의함으로써, 클래스 인스턴스를 콜러블로 만들 수 있습니다."

#: ../Doc/reference/datamodel.rst:744
msgid "Modules"
msgstr "모듈(Modules)"

#: ../Doc/reference/datamodel.rst:701
msgid ""
"Modules are a basic organizational unit of Python code, and are created "
"by the :ref:`import system <importsystem>` as invoked either by the "
":keyword:`import` statement, or by calling functions such as "
":func:`importlib.import_module` and built-in :func:`__import__`.  A "
"module object has a namespace implemented by a dictionary object (this is"
" the dictionary referenced by the ``__globals__`` attribute of functions "
"defined in the module).  Attribute references are translated to lookups "
"in this dictionary, e.g., ``m.x`` is equivalent to ``m.__dict__[\"x\"]``."
" A module object does not contain the code object used to initialize the "
"module (since it isn't needed once the initialization is done)."
msgstr ""
"모듈은 파이썬 코드의 기본적인 조직화 단위이고, :keyword:`import` 문이나, "
":func:`importlib.import_module` 과 내장 :func:`__import__` 함수를 호출해서 구동할 수 있는"
" :ref:`임포트 시스템 <importsystem>` 에 의해 만들어집니다. 모듈 객체는 딕셔너리 객체로 구현되는 이름 공간을 "
"갖습니다(이 딕셔너리 객체는 모듈에서 정의되는 함수들의 ``__globals__`` 어트리뷰트로 참조됩니다). 어트리뷰트 참조는 이"
" 딕셔너리에 대한 조회로 변환됩니다. 예를 들어, ``m.x`` 는 ``m.__dict__[\"x\"]`` 와 같습니다. 모듈 "
"객체는 모듈을 초기화하는데 사용된 코드 객체를 갖고 있지 않습니다 (일단 초기화가 끝나면 필요 없으므로)."

#: ../Doc/reference/datamodel.rst:713
msgid ""
"Attribute assignment updates the module's namespace dictionary, e.g., "
"``m.x = 1`` is equivalent to ``m.__dict__[\"x\"] = 1``."
msgstr ""
"어트리뷰트 대입은 모듈의 이름 공간 딕셔너리를 갱신합니다. 예를 들어, ``m.x = 1`` 은 ``m.__dict__[\"x\"]"
" = 1`` 과 같습니다."

#: ../Doc/reference/datamodel.rst:723
msgid ""
"Predefined (writable) attributes: :attr:`__name__` is the module's name; "
":attr:`__doc__` is the module's documentation string, or ``None`` if "
"unavailable; :attr:`__annotations__` (optional) is a dictionary "
"containing :term:`variable annotations <variable annotation>` collected "
"during module body execution; :attr:`__file__` is the pathname of the "
"file from which the module was loaded, if it was loaded from a file. The "
":attr:`__file__` attribute may be missing for certain types of modules, "
"such as C modules that are statically linked into the interpreter; for "
"extension modules loaded dynamically from a shared library, it is the "
"pathname of the shared library file."
msgstr ""
"미리 정의된 (쓰기 가능한) 어트리뷰트들: :attr:`__name__` 은 모듈의 이름입니다; :attr:`__doc__` 은 "
"모듈의 설명 문자열 또는 없는 경우 ``None`` 입니다; (없을 수도 있는) :attr:`__annotations__` 는 "
"모듈의 바디를 실행하면서 수집된 :term:`변수 어노테이션 <variable annotation>` 들을 담은 딕셔너리입니다; "
":attr:`__file__` 은 모듈이 로드된 파일의 경로명입니다. 인터프리터에 정적으로 연결된 C 모듈과 같은 어떤 종류의 "
"모듈들에서는 :attr:`__file__` 어트리뷰트가 제공되지 않습니다; 공유 라이브러리(shared library)로부터 "
"동적으로 로딩되는 확장 모듈의 경우 공유 라이브러리의 경로명이 제공됩니다."

#: ../Doc/reference/datamodel.rst:736
msgid ""
"Special read-only attribute: :attr:`~object.__dict__` is the module's "
"namespace as a dictionary object."
msgstr "특수 읽기 전용 어트리뷰트들: :attr:`~object.__dict__` 는 딕셔너리로 표현되는 모듈의 이름 공간입니다."

#: ../Doc/reference/datamodel.rst:741
msgid ""
"Because of the way CPython clears module dictionaries, the module "
"dictionary will be cleared when the module falls out of scope even if the"
" dictionary still has live references.  To avoid this, copy the "
"dictionary or keep the module around while using its dictionary directly."
msgstr ""
"CPython 이 모듈 딕셔너리를 비우는 방법 때문에, 딕셔너리에 대한 참조가 남아있더라도, 모듈이 스코프를 벗어나면 모듈 "
"딕셔너리는 비워집니다. 이것을 피하려면, 딕셔너리를 복사하거나 딕셔너리를 직접 이용하는 동안은 모듈을 잡아두어야 합니다."

#: ../Doc/reference/datamodel.rst:803
msgid "Custom classes"
msgstr "사용자 정의 클래스(Custom classes)"

#: ../Doc/reference/datamodel.rst:747
msgid ""
"Custom class types are typically created by class definitions (see "
"section :ref:`class`).  A class has a namespace implemented by a "
"dictionary object. Class attribute references are translated to lookups "
"in this dictionary, e.g., ``C.x`` is translated to ``C.__dict__[\"x\"]`` "
"(although there are a number of hooks which allow for other means of "
"locating attributes). When the attribute name is not found there, the "
"attribute search continues in the base classes. This search of the base "
"classes uses the C3 method resolution order which behaves correctly even "
"in the presence of 'diamond' inheritance structures where there are "
"multiple inheritance paths leading back to a common ancestor. Additional "
"details on the C3 MRO used by Python can be found in the documentation "
"accompanying the 2.3 release at "
"https://www.python.org/download/releases/2.3/mro/."
msgstr ""
"사용자 정의 클래스 형들은 보통 클래스 정의 때문에 만들어집니다 (:ref:`class` 섹션 참조). 클래스는 딕셔너리로 구현된 "
"이름 공간을 갖습니다. 클래스 어트리뷰트 참조는 이 딕셔너리에 대한 조회로 변환됩니다. 예를 들어, ``C.x`` 는 "
"``C.__dict__[\"x\"]`` 로 변환됩니다 (하지만 어트리뷰트에 접근하는 다른 방법들을 허락하는 여러 가지 "
"훅(hook)이 있습니다.). 거기에서 어트리뷰트 이름이 발견되지 않으면, 어트리뷰트 검색은 부모 클래스들에서 계속됩니다. 이 부모"
" 클래스 검색은 C3 메서드 결정 순서(method resolution order)를 사용하는데, 다중 상속이 같은 부모 클래스로 "
"모이는 '다이아몬드(diamond)' 계승 구조가 존재해도 올바르게 동작합니다. 파이썬이 사용하는 C3 MRO에 관한 좀 더 자세한"
" 내용은 2.3 배포에 첨부된 문서 https://www.python.org/download/releases/2.3/mro/ 에서 "
"찾아볼 수 있습니다."

#: ../Doc/reference/datamodel.rst:771
msgid ""
"When a class attribute reference (for class :class:`C`, say) would yield "
"a class method object, it is transformed into an instance method object "
"whose :attr:`__self__` attribute is :class:`C`.  When it would yield a "
"static method object, it is transformed into the object wrapped by the "
"static method object. See section :ref:`descriptors` for another way in "
"which attributes retrieved from a class may differ from those actually "
"contained in its :attr:`~object.__dict__`."
msgstr ""
"클래스 어트리뷰트 참조가 (클래스 :class:`C` 라고 하자) 클래스 메서드 객체로 귀결될 때는, :attr:`__self__`"
" 어트리뷰트가 :class:`C` 인 인스턴스 메서드 객체로 변환됩니다. 스태틱 메서드로 귀결될 때는, 스태틱 메서드 객체가 감싸고"
" 있는 객체로 변환됩니다. 클래스로부터 얻은 어트리뷰트가 :attr:`~object.__dict__` 에 저장된 값과 달라지도록 "
"만드는 다른 방법이 :ref:`descriptors` 섹션에 나옵니다."

#: ../Doc/reference/datamodel.rst:781
msgid ""
"Class attribute assignments update the class's dictionary, never the "
"dictionary of a base class."
msgstr "클래스 어트리뷰트 대입은 클래스의 딕셔너리를 갱신할 뿐, 어떤 경우도 부모 클래스의 딕셔너리를 건드리지는 않습니다."

#: ../Doc/reference/datamodel.rst:786
msgid ""
"A class object can be called (see above) to yield a class instance (see "
"below)."
msgstr "클래스 객체는 클래스 인스턴스를 돌려주도록(아래를 보십시오) 호출될 수 있습니다(위를 보십시오)."

#: ../Doc/reference/datamodel.rst:796
msgid ""
"Special attributes: :attr:`~definition.__name__` is the class name; "
":attr:`__module__` is the module name in which the class was defined; "
":attr:`~object.__dict__` is the dictionary containing the class's "
"namespace; :attr:`~class.__bases__` is a tuple containing the base "
"classes, in the order of their occurrence in the base class list; "
":attr:`__doc__` is the class's documentation string, or ``None`` if "
"undefined; :attr:`__annotations__` (optional) is a dictionary containing "
":term:`variable annotations <variable annotation>` collected during class"
" body execution."
msgstr ""
"특수 어트리뷰트들::attr:`~definition.__name__` 은 클래스의 이름입니다. :attr:`__module__` 은"
" 클래스가 정의된 모듈의 이름입니다. :attr:`~object.__dict__` 는 클래스의 이름 공간을 저장하는 딕셔너리입니다;"
" :attr:`~class.__bases__` 는 부모 클래스들을 저장하는 튜플입니다; 부모 클래스 목록에 나타나는 순서를 "
"유지합니다; :attr:`__doc__` 은 클래스의 설명 문자열 이거나 정의되지 않으면 ``None`` 입니다; (없을 수 있는)"
" :attr:`__annotations__` 는 클래스의 바디를 실행하면서 수집된 :term:`변수 어노테이션 <variable "
"annotation>` 들을 담은 딕셔너리입니다."

#: ../Doc/reference/datamodel.rst:846
msgid "Class instances"
msgstr "클래스 인스턴스(Class instances)"

#: ../Doc/reference/datamodel.rst:812
msgid ""
"A class instance is created by calling a class object (see above).  A "
"class instance has a namespace implemented as a dictionary which is the "
"first place in which attribute references are searched.  When an "
"attribute is not found there, and the instance's class has an attribute "
"by that name, the search continues with the class attributes.  If a class"
" attribute is found that is a user-defined function object, it is "
"transformed into an instance method object whose :attr:`__self__` "
"attribute is the instance.  Static method and class method objects are "
"also transformed; see above under \"Classes\".  See section "
":ref:`descriptors` for another way in which attributes of a class "
"retrieved via its instances may differ from the objects actually stored "
"in the class's :attr:`~object.__dict__`.  If no class attribute is found,"
" and the object's class has a :meth:`__getattr__` method, that is called "
"to satisfy the lookup."
msgstr ""
"클래스 인스턴스는 클래스 객체를 호출해서 (위를 보십시오) 만들어집니다. 클래스 인스턴스는 딕셔너리로 구현되는 이름 공간을 갖는데,"
" 어트리뷰트를 참조할 때 가장 먼저 검색되는 곳입니다. 그곳에서 어트리뷰트가 발견되지 않고, 인스턴스의 클래스가 그 이름의 "
"어트리뷰트를 갖고 있으면, 클래스 어트리뷰트로 검색이 계속됩니다. 만약 발견된 클래스 어트리뷰트가 사용자 정의 함수면, "
":attr:`__self__` 어트리뷰트가 인스턴스인 인스턴스 메서드로 변환됩니다. 스태틱 메서드와 클래스 메서드 객체 또한 "
"변환됩니다. 위의 \"사용자 정의 클래스(Custom Classes)\" 부분을 보십시오. 클래스로부터 얻은 어트리뷰트가 클래스의 "
":attr:`~object.__dict__` 에 저장된 값과 달라지도록 만드는 다른 방법이 :ref:`descriptors` 섹션에"
" 나옵니다. 만약 클래스 어트리뷰트도 발견되지 않고, 클래스가 :meth:`__getattr__` 메서드를 가지면, 조회를 "
"만족시키기 위해 그 메서드를 호출합니다."

#: ../Doc/reference/datamodel.rst:828
msgid ""
"Attribute assignments and deletions update the instance's dictionary, "
"never a class's dictionary.  If the class has a :meth:`__setattr__` or "
":meth:`__delattr__` method, this is called instead of updating the "
"instance dictionary directly."
msgstr ""
"어트리뷰트 대입과 삭제는 인스턴스의 딕셔너리를 갱신할 뿐, 결코 클래스의 딕셔너리를 건드리지 않습니다. 만약 클래스가 "
":meth:`__setattr__` 이나 :meth:`__delattr__` 메서드를 가지면, 인스턴스의 딕셔너리를 갱신하는 대신에"
" 그 메서드들을 호출합니다."

#: ../Doc/reference/datamodel.rst:838
msgid ""
"Class instances can pretend to be numbers, sequences, or mappings if they"
" have methods with certain special names.  See section "
":ref:`specialnames`."
msgstr ""
"어떤 특별한 이름들의 메서드들을 가지면, 클래스 인스턴스는 숫자, 시퀀스, 매핑인 척할 수 있습니다. "
":ref:`specialnames` 섹션을 보십시오."

#: ../Doc/reference/datamodel.rst:845
msgid ""
"Special attributes: :attr:`~object.__dict__` is the attribute dictionary;"
" :attr:`~instance.__class__` is the instance's class."
msgstr ""
"특수 어트리뷰트들: :attr:`~object.__dict__` 는 어트리뷰트 딕셔너리입니다; "
":attr:`~instance.__class__` 는 인스턴스의 클래스입니다."

#: ../Doc/reference/datamodel.rst:872
msgid "I/O objects (also known as file objects)"
msgstr "I/O 객체 (파일 객체라고도 알려져 있습니다)"

#: ../Doc/reference/datamodel.rst:862
msgid ""
"A :term:`file object` represents an open file.  Various shortcuts are "
"available to create file objects: the :func:`open` built-in function, and"
" also :func:`os.popen`, :func:`os.fdopen`, and the "
":meth:`~socket.socket.makefile` method of socket objects (and perhaps by "
"other functions or methods provided by extension modules)."
msgstr ""
":term:`파일 객체 <file object>` 는 열린 파일을 나타냅니다. 파일 객체를 만드는 여러 가지 단축법이 있습니다: "
":func:`open` 내장 함수, :func:`os.popen`, :func:`os.fdopen` 과 소켓 객체의 "
":meth:`~socket.socket.makefile` 메서드 (그리고, 아마도 확장 모듈들이 제공하는 다른 함수들이나 "
"메서드들)."

#: ../Doc/reference/datamodel.rst:868
msgid ""
"The objects ``sys.stdin``, ``sys.stdout`` and ``sys.stderr`` are "
"initialized to file objects corresponding to the interpreter's standard "
"input, output and error streams; they are all open in text mode and "
"therefore follow the interface defined by the :class:`io.TextIOBase` "
"abstract class."
msgstr ""
"``sys.stdin``, ``sys.stdout``, ``sys.stderr`` 는 인터프리터의 표준 입력, 출력, 에러 "
"스트림으로 초기화된 파일 객체들입니다; 모두 텍스트 모드로 열려서 :class:`io.TextIOBase` 추상 클래스에 의해 "
"정의된 인터페이스를 따릅니다."

#: ../Doc/reference/datamodel.rst:1110
msgid "Internal types"
msgstr "내부 형(Internal types)"

#: ../Doc/reference/datamodel.rst:879
msgid ""
"A few types used internally by the interpreter are exposed to the user. "
"Their definitions may change with future versions of the interpreter, but"
" they are mentioned here for completeness."
msgstr ""
"인터프리터가 내부적으로 사용하는 몇몇 형들은 사용자에게 노출됩니다. 인터프리터의 미래 버전에서 이들의 정의는 변경될 수 있지만, "
"완전함을 위해 여기서 언급합니다."

#: ../Doc/reference/datamodel.rst:947
msgid "Code objects"
msgstr "코드 객체(Code objects)"

#: ../Doc/reference/datamodel.rst:886
msgid ""
"Code objects represent *byte-compiled* executable Python code, or "
":term:`bytecode`. The difference between a code object and a function "
"object is that the function object contains an explicit reference to the "
"function's globals (the module in which it was defined), while a code "
"object contains no context; also the default argument values are stored "
"in the function object, not in the code object (because they represent "
"values calculated at run-time).  Unlike function objects, code objects "
"are immutable and contain no references (directly or indirectly) to "
"mutable objects."
msgstr ""
"코드 객체는 *바이트로 컴파일된(byte-compiled)* 실행 가능한 파이썬 코드를 나타내는데, 그냥 :term:`바이트 코드 "
"<bytecode>` 라고도 부릅니다. 코드 객체와 함수 객체 간에는 차이가 있습니다; 함수 객체는 함수의 전역 "
"공간(globals) (함수가 정의된 모듈)을 명시적으로 참조하고 있지만, 코드 객체는 어떤 문맥(context)도 갖고 있지 "
"않습니다; 또한 기본 인자값들이 함수 객체에 저장되어 있지만 코드 객체에는 들어있지 않습니다 (실행 시간에 계산되는 값들을 나타내기"
" 때문입니다). 함수 객체와는 달리, 코드 객체는 불변이고 가변 객체들에 대한 어떤 참조도 (직접 혹은 간접적으로도) 갖고 있지 "
"않습니다."

#: ../Doc/reference/datamodel.rst:911
msgid ""
"Special read-only attributes: :attr:`co_name` gives the function name; "
":attr:`co_argcount` is the number of positional arguments (including "
"arguments with default values); :attr:`co_nlocals` is the number of local"
" variables used by the function (including arguments); "
":attr:`co_varnames` is a tuple containing the names of the local "
"variables (starting with the argument names); :attr:`co_cellvars` is a "
"tuple containing the names of local variables that are referenced by "
"nested functions; :attr:`co_freevars` is a tuple containing the names of "
"free variables; :attr:`co_code` is a string representing the sequence of "
"bytecode instructions; :attr:`co_consts` is a tuple containing the "
"literals used by the bytecode; :attr:`co_names` is a tuple containing the"
" names used by the bytecode; :attr:`co_filename` is the filename from "
"which the code was compiled; :attr:`co_firstlineno` is the first line "
"number of the function; :attr:`co_lnotab` is a string encoding the "
"mapping from bytecode offsets to line numbers (for details see the source"
" code of the interpreter); :attr:`co_stacksize` is the required stack "
"size (including local variables); :attr:`co_flags` is an integer encoding"
" a number of flags for the interpreter."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`co_name` 은 함수의 이름입니다; :attr:`co_argcount` 는 위치 "
"인자들 (기본값이 있는 인자들도 포함됩니다)의 개수입니다; :attr:`co_nlocals` 는 함수가 사용하는 지역 변수들 "
"(인자들을 포함합니다)의 개수입니다; :attr:`co_varnames` 는 지역 변수들의 이름을 담고 있는 튜플입니다(인자들의 "
"이름이 먼저 나옵니다); :attr:`co_cellvars` 는 중첩된 함수들이 참조하는 지역 변수들의 이름을 담고 있는 "
"튜플입니다; :attr:`co_freevars` 는 자유 변수(free variables)들의 이름을 담고 있는 튜플입니다; "
":attr:`co_code` 는 바이트 코드 명령 시퀀스를 나타내는 문자열입니다; :attr:`co_consts` 는 바이트 코드가"
" 사용하는 리터럴을 포함하는 튜플입니다; :attr:`co_names` 는 바이트 코드가 사용하는 이름들을 담고 있는 튜플입니다; "
":attr:`co_filename` 은 컴파일된 코드를 제공한 파일의 이름입니다; :attr:`co_firstlineno` 는 "
"함수의 첫 번째 줄 번호입니다; :attr:`co_lnotab` 은 바이트 코드에서의 위치를 줄 번호로 매핑하는 법을 문자열로 "
"인코딩한 값입니다 (자세한 내용은 인터프리터의 소스 코드를 참고하십시오); :attr:`co_stacksize` 는 필요한 스택의 "
"크기입니다 (지역 변수를 포함합니다); :attr:`co_flags` 는 인터프리터의 여러 플래그(flag)들을 정수로 인코딩한 "
"값입니다."

#: ../Doc/reference/datamodel.rst:930
msgid ""
"The following flag bits are defined for :attr:`co_flags`: bit ``0x04`` is"
" set if the function uses the ``*arguments`` syntax to accept an "
"arbitrary number of positional arguments; bit ``0x08`` is set if the "
"function uses the ``**keywords`` syntax to accept arbitrary keyword "
"arguments; bit ``0x20`` is set if the function is a generator."
msgstr ""
"다음과 같은 값들이 :attr:`co_flags` 를 위해 정의되어 있습니다: 함수가 가변 개수의 위치 인자를 받아들이기 위해 "
"사용되는 ``*arguments`` 문법을 사용하면 비트 ``0x04`` 가 1이 됩니다; 임의의 키워드 인자를 받아들이기 위해 "
"사용하는 ``**keywords`` 문법을 사용하면 비트 ``0x08`` 이 1이 됩니다; 비트 ``0x20`` 은 함수가 "
"제너레이터일 때 설정됩니다."

#: ../Doc/reference/datamodel.rst:936
msgid ""
"Future feature declarations (``from __future__ import division``) also "
"use bits in :attr:`co_flags` to indicate whether a code object was "
"compiled with a particular feature enabled: bit ``0x2000`` is set if the "
"function was compiled with future division enabled; bits ``0x10`` and "
"``0x1000`` were used in earlier versions of Python."
msgstr ""
"퓨처 기능 선언 (``from __future__ import division``) 또한 코드 객체가 특정 기능이 활성화된 상태에서"
" 컴파일되었는지를 나타내기 위해 :attr:`co_flags` 의 비트들을 사용합니다: 함수가 퓨처 division이 활성화된 "
"상태에서 컴파일되었으면 비트 ``0x2000`` 이 설정됩니다; 비트 ``0x10`` 과 ``0x1000`` 는 예전 버전의 "
"파이썬에서 사용되었습니다."

#: ../Doc/reference/datamodel.rst:942
msgid "Other bits in :attr:`co_flags` are reserved for internal use."
msgstr ":attr:`co_flags` 의 다른 비트들은 내부 사용을 위해 예약되어 있습니다."

#: ../Doc/reference/datamodel.rst:946
msgid ""
"If a code object represents a function, the first item in "
":attr:`co_consts` is the documentation string of the function, or "
"``None`` if undefined."
msgstr ""
"만약 코드 객체가 함수를 나타낸다면, :attr:`co_consts` 의 첫 번째 항목은 설명 문자열이거나 정의되지 않으면 "
"``None`` 입니다. "

#: ../Doc/reference/datamodel.rst:1006
msgid "Frame objects"
msgstr "프레임 객체(Frame objects)"

#: ../Doc/reference/datamodel.rst:954
msgid ""
"Frame objects represent execution frames.  They may occur in traceback "
"objects (see below), and are also passed to registered trace functions."
msgstr ""
"프레임 객체는 실행 프레임(execution frame)을 나타냅니다. 트레이스백 객체에 등장할 수 있고 (아래를 보십시오), "
"등록된 추적 함수로도 전달됩니다."

#: ../Doc/reference/datamodel.rst:965
msgid ""
"Special read-only attributes: :attr:`f_back` is to the previous stack "
"frame (towards the caller), or ``None`` if this is the bottom stack "
"frame; :attr:`f_code` is the code object being executed in this frame; "
":attr:`f_locals` is the dictionary used to look up local variables; "
":attr:`f_globals` is used for global variables; :attr:`f_builtins` is "
"used for built-in (intrinsic) names; :attr:`f_lasti` gives the precise "
"instruction (this is an index into the bytecode string of the code "
"object)."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`f_back` 은 이전 스택 프레임 (호출자 방향으로)을 가리키거나, 이게 스택의 "
"바닥이라면 ``None``; :attr:`f_code` 는 이 프레임에서 실행되는 코드 객체; :attr:`f_locals` 는 "
"지역 변수를 조회하는데 사용되는 딕셔너리; :attr:`f_globals` 는 전역 변수에 사용됩니다; "
":attr:`f_builtins` 는 내장된(intrinsic) 이름들에 사용됩니다; :attr:`f_lasti` 는 정확한 바이트"
" 코드 명령(instruction)을 제공합니다 (코드 객체의 바이트 코드 문자열에 대한 인덱스입니다). "

#: ../Doc/reference/datamodel.rst:979
msgid ""
"Special writable attributes: :attr:`f_trace`, if not ``None``, is a "
"function called for various events during code execution (this is used by"
" the debugger). Normally an event is triggered for each new source line -"
" this can be disabled by setting :attr:`f_trace_lines` to :const:`False`."
msgstr ""
"특수 쓰기 가능 어트리뷰트들: :attr:`f_trace` 는, ``None`` 이 아니면, 코드 실행 중의 여러 이벤트로 인해 "
"호출되는 함수입니다 (디버거에서 사용됩니다). 보통 이벤트는 각 새 소스 줄에서 발생합니다 - "
":attr:`f_trace_lines`\\를 :const:`False`\\로 설정하면 이것을 비활성화할 수 있습니다."

#: ../Doc/reference/datamodel.rst:984
msgid ""
"Implementations *may* allow per-opcode events to be requested by setting "
":attr:`f_trace_opcodes` to :const:`True`. Note that this may lead to "
"undefined interpreter behaviour if exceptions raised by the trace "
"function escape to the function being traced."
msgstr ""
"구현은 :attr:`f_trace_opcodes`\\를 :const:`True`\\로 설정하는 것으로 요청되는 옵코드(opcode)"
" 당 이벤트를 허용할 수 있습니다. 추적 함수에 의해 발생 된 예외가 추적되는 함수로 빠져나오면 정의되지 않은 인터프리터 동작을 "
"유발할 수 있음에 주의해야 합니다."

#: ../Doc/reference/datamodel.rst:989
msgid ""
":attr:`f_lineno` is the current line number of the frame --- writing to "
"this from within a trace function jumps to the given line (only for the "
"bottom-most frame).  A debugger can implement a Jump command (aka Set "
"Next Statement) by writing to f_lineno."
msgstr ""
":attr:`f_lineno` 는 프레임의 현재 줄 번호입니다 --- 트레이스 함수(f_trace)에서 이 값을 쓰면 해당 줄로 "
"점프합니다 (오직 가장 바닥 프레임에서만 가능합니다). 디버거는 f_lineno 를 쓰기 위한 점프 명령을 구현할 수 있습니다 "
"(소위 Set Next Statement)."

#: ../Doc/reference/datamodel.rst:994
msgid "Frame objects support one method:"
msgstr "프레임 객체는 한가지 메서드를 지원합니다:"

#: ../Doc/reference/datamodel.rst:998
msgid ""
"This method clears all references to local variables held by the frame.  "
"Also, if the frame belonged to a generator, the generator is finalized.  "
"This helps break reference cycles involving frame objects (for example "
"when catching an exception and storing its traceback for later use)."
msgstr ""
"이 메서드는 프레임이 잡은 지역 변수들에 대한 모든 참조를 제거합니다. 또한, 만약 프레임이 제너레이터에 속하면, 제너레이터가 "
"종료됩니다(finalize). 이것은 프레임 객체가 관련된 참조 순환을 깨는 데 도움을 줍니다 (예를 들어, 예외를 잡아서 "
"트레이스백을 추후 사용을 위해 저장할 때)."

#: ../Doc/reference/datamodel.rst:1004
msgid ":exc:`RuntimeError` is raised if the frame is currently executing."
msgstr "만약 프레임이 현재 실행 중이면 :exc:`RuntimeError` 예외가 발생합니다."

#: ../Doc/reference/datamodel.rst:1066
msgid "Traceback objects"
msgstr "트레이스백 객체(Traceback objects)"

#: ../Doc/reference/datamodel.rst:1021
msgid ""
"Traceback objects represent a stack trace of an exception.  A traceback "
"object is implicitly created when an exception occurs, and may also be "
"explicitly created by calling :class:`types.TracebackType`."
msgstr ""
"트레이스백 객체는 예외의 스택 트레이스를 나타냅니다. 트레이스백 객체는 예외가 발생할 때 만들어지고, "
":class:`types.TracebackType` 를 호출해서 명시적으로 만들 수도 있습니다."

#: ../Doc/reference/datamodel.rst:1025
msgid ""
"For implicitly created tracebacks, when the search for an exception "
"handler unwinds the execution stack, at each unwound level a traceback "
"object is inserted in front of the current traceback.  When an exception "
"handler is entered, the stack trace is made available to the program. "
"(See section :ref:`try`.) It is accessible as the third item of the tuple"
" returned by ``sys.exc_info()``, and as the ``__traceback__`` attribute "
"of the caught exception."
msgstr ""
"묵시적으로 만들어진 트레이스백의 경우, 예외 처리기를 찾아서 실행 스택을 되감을 때, 각각 되감기 단계마다 현재 트레이스백의 앞에 "
"트레이스백 객체를 삽입합니다. 예외 처리기에 들어가면, 스택 트레이스를 프로그램이 사용할 수 있습니다. (:ref:`try` 섹션 "
"참조.) ``sys.exc_info()`` 가 돌려주는 튜플의 세 번째 항목이나 잡힌 예외의 ``__traceback__`` "
"어트리뷰트로 액세스할 수 있습니다."

#: ../Doc/reference/datamodel.rst:1033
msgid ""
"When the program contains no suitable handler, the stack trace is written"
" (nicely formatted) to the standard error stream; if the interpreter is "
"interactive, it is also made available to the user as "
"``sys.last_traceback``."
msgstr ""
"프로그램이 적절한 처리기를 제공하지 않는 경우, 스택 트레이스는 표준 에러 스트림으로 (보기 좋게 포맷되어) 출력됩니다; 만약 "
"인터프리터가 대화형이면, ``sys.last_traceback`` 으로 사용자에게 제공합니다."

#: ../Doc/reference/datamodel.rst:1038
msgid ""
"For explicitly created tracebacks, it is up to the creator of the "
"traceback to determine how the ``tb_next`` attributes should be linked to"
" form a full stack trace."
msgstr ""
"명시적으로 생성된 트레이스백의 경우, ``tb_next`` 어트리뷰트를 어떻게 연결하여 전체 스택 트레이스를 형성해야 하는지를 "
"결정하는 것은 트레이스백을 만드는 주체에게 달려 있습니다."

#: ../Doc/reference/datamodel.rst:1048
msgid ""
"Special read-only attributes: :attr:`tb_frame` points to the execution "
"frame of the current level; :attr:`tb_lineno` gives the line number where"
" the exception occurred; :attr:`tb_lasti` indicates the precise "
"instruction. The line number and last instruction in the traceback may "
"differ from the line number of its frame object if the exception occurred"
" in a :keyword:`try` statement with no matching except clause or with a "
"finally clause."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`tb_frame` 은 현 단계에서의 실행 프레임입니다; :attr:`tb_lineno` "
"는 예외가 발생한 줄의 번호를 줍니다; :attr:`tb_lasti` 정확한 바이트 코드 명령을 가리킵니다. 만약 예외가 "
"except 절이나 finally 절이 없는 :keyword:`try` 문에서 발생하면, 줄 번호와 트레이스백의 마지막 "
"명령(last instruction)은 프레임 객체의 줄 번호와 다를 수 있습니다."

#: ../Doc/reference/datamodel.rst:1060
msgid ""
"Special writable attribute: :attr:`tb_next` is the next level in the "
"stack trace (towards the frame where the exception occurred), or ``None``"
" if there is no next level."
msgstr ""
"특수 쓰기 가능 어트리뷰트: :attr:`tb_next` 는 스택 트레이스의 다음 단계 (예외가 발생한 프레임 방향으로)이거나 다음"
" 단계가 없으면 ``None`` 입니다."

#: ../Doc/reference/datamodel.rst:1064
msgid ""
"Traceback objects can now be explicitly instantiated from Python code, "
"and the ``tb_next`` attribute of existing instances can be updated."
msgstr ""
"트레이스백 객체는 이제 파이썬 코드에서 명시적으로 인스턴스를 만들 수 있으며 기존 인스턴스의 ``tb_next`` 어트리뷰트를 "
"변경할 수 있습니다."

#: ../Doc/reference/datamodel.rst:1092
msgid "Slice objects"
msgstr "슬라이스 객체(Slice objects)"

#: ../Doc/reference/datamodel.rst:1071
msgid ""
"Slice objects are used to represent slices for :meth:`__getitem__` "
"methods.  They are also created by the built-in :func:`slice` function."
msgstr ""
"슬라이스 객체는 :meth:`__getitem__` 메서드를 위한 슬라이스를 나타냅니다. 내장 함수 :func:`slice` 로 "
"만들 수도 있습니다."

#: ../Doc/reference/datamodel.rst:1079
msgid ""
"Special read-only attributes: :attr:`~slice.start` is the lower bound; "
":attr:`~slice.stop` is the upper bound; :attr:`~slice.step` is the step "
"value; each is ``None`` if omitted.  These attributes can have any type."
msgstr ""
"특수 읽기 전용 어트리뷰트들: :attr:`~slice.start` 는 하한(lower bound) 입니다; "
":attr:`~slice.stop` 은 상한(upper bound) 입니다; :attr:`~slice.step` 은 스텝 값입니다;"
" 각 값은 생략될 경우 ``None`` 입니다. 이 어트리뷰트들은 임의의 형이 될 수 있습니다."

#: ../Doc/reference/datamodel.rst:1083
msgid "Slice objects support one method:"
msgstr "슬라이스 객체는 하나의 메서드를 지원합니다."

#: ../Doc/reference/datamodel.rst:1087
msgid ""
"This method takes a single integer argument *length* and computes "
"information about the slice that the slice object would describe if "
"applied to a sequence of *length* items.  It returns a tuple of three "
"integers; respectively these are the *start* and *stop* indices and the "
"*step* or stride length of the slice. Missing or out-of-bounds indices "
"are handled in a manner consistent with regular slices."
msgstr ""
"이 메서드는 하나의 정수 인자 *length* 를 받아서 슬라이스 객체가 길이 *length* 인 시퀀스에 적용되었을 때 그 "
"슬라이스에 대한 정보를 계산합니다. 세 개의 정수로 구성된 튜플을 돌려줍니다: 이것들은 각각 *start* 와 *stop* "
"인덱스와, *step* 또는 슬라이스의 스트라이드(stride) 길이입니다. 생략되었거나 범위를 벗어난 인덱스들은 일반적인 "
"슬라이스와 같은 방법으로 다뤄집니다."

#: ../Doc/reference/datamodel.rst:1102
msgid "Static method objects"
msgstr "스태틱 메서드 객체(Static method objects)"

#: ../Doc/reference/datamodel.rst:1095
msgid ""
"Static method objects provide a way of defeating the transformation of "
"function objects to method objects described above. A static method "
"object is a wrapper around any other object, usually a user-defined "
"method object. When a static method object is retrieved from a class or a"
" class instance, the object actually returned is the wrapped object, "
"which is not subject to any further transformation. Static method objects"
" are not themselves callable, although the objects they wrap usually are."
" Static method objects are created by the built-in :func:`staticmethod` "
"constructor."
msgstr ""
"스태틱 메서드 객체는 위에서 설명한 함수 객체를 메서드 객체로 변환하는 과정을 방지하는 방법을 제공합니다. 스태틱 메서드 객체는 "
"다른 임의의 객체, 보통 사용자 정의 메서드를 둘러쌉니다. 스태틱 메서드가 클래스나 클래스 인스턴스로부터 읽힐 때 객체가 실제로 "
"돌려주는 것은 둘러싸여 있던 객체인데, 다른 어떤 변환도 적용되지 않은 상태입니다. 둘러싸는 객체는 그렇더라도, 스태틱 메서드 객체"
" 자체는 콜러블이 아닙니다. 스태틱 메서드 객체는 내장 :func:`staticmethod` 생성자로 만듭니다."

#: ../Doc/reference/datamodel.rst:1110
msgid "Class method objects"
msgstr "클래스 메서드 객체(Class method objects)"

#: ../Doc/reference/datamodel.rst:1105
msgid ""
"A class method object, like a static method object, is a wrapper around "
"another object that alters the way in which that object is retrieved from"
" classes and class instances. The behaviour of class method objects upon "
"such retrieval is described above, under \"User-defined methods\". Class "
"method objects are created by the built-in :func:`classmethod` "
"constructor."
msgstr ""
"스태틱 메서드 객체처럼, 클래스 메서드 객체 역시 다른 객체를 둘러싸는데, 클래스와 클래스 인스턴스로부터 그 객체를 꺼내는 방식에 "
"변화를 줍니다. 그런 조회에서 클래스 메서드 객체가 동작하는 방식에 대해서는 위 \"사용자 정의 메서드(User-defined "
"methods)\" 에서 설명했습니다. 클래스 메서드 객체는 내장 :func:`classmethod` 생성자로 만듭니다."

#: ../Doc/reference/datamodel.rst:1115
msgid "Special method names"
msgstr "특수 메서드 이름들"

#: ../Doc/reference/datamodel.rst:1121
msgid ""
"A class can implement certain operations that are invoked by special "
"syntax (such as arithmetic operations or subscripting and slicing) by "
"defining methods with special names. This is Python's approach to "
":dfn:`operator overloading`, allowing classes to define their own "
"behavior with respect to language operators.  For instance, if a class "
"defines a method named :meth:`__getitem__`, and ``x`` is an instance of "
"this class, then ``x[i]`` is roughly equivalent to "
"``type(x).__getitem__(x, i)``.  Except where mentioned, attempts to "
"execute an operation raise an exception when no appropriate method is "
"defined (typically :exc:`AttributeError` or :exc:`TypeError`)."
msgstr ""
"클래스는 특별한 이름의 메서드들을 정의함으로써 특별한 문법 (산술 연산이나 인덱싱이나 슬라이딩 같은)에 의해 시작되는 어떤 연산들을"
" 구현할 수 있습니다. 이것이 :dfn:`연산자 오버 로딩 (operator overloading)`\\에 대한 파이썬의 "
"접근법인데, 클래스가 언어의 연산자에 대해 자기 자신의 동작을 정의할 수 있도록 합니다. 예를 들어, 클래스가 "
":meth:`__getitem__` 이라는 이름의 메서드를 정의하고, ``x`` 가 이 클래스의 인스턴스라면, ``x[i]`` 는 "
"대략 ``type(x).__getitem__(x, i)`` 와 동등합니다. 언급된 경우를 제외하고, 적절한 메서드가 정의되지 않았을"
" 때 연산은 예외를 일으킵니다 (보통 :exc:`AttributeError` 나 :exc:`TypeError`)."

#: ../Doc/reference/datamodel.rst:1131
msgid ""
"Setting a special method to ``None`` indicates that the corresponding "
"operation is not available.  For example, if a class sets "
":meth:`__iter__` to ``None``, the class is not iterable, so calling "
":func:`iter` on its instances will raise a :exc:`TypeError` (without "
"falling back to :meth:`__getitem__`). [#]_"
msgstr ""
"특수 메서드를 ``None`` 으로 설정하는 것은 해당 연산이 제공되지 않는다는 것을 가리킵니다. 예를 들어, 만약 클래스가 "
":meth:`__iter__` 를 ``None`` 으로 설정하면, 클래스는 이터러블이 아닙니다. 따라서 이 인스턴스에 "
":func:`iter` 를 호출하면 :exc:`TypeError` 가 발생합니다. (:meth:`__getitem__` 을 대안으로"
" 시도하지 않습니다.) [#]_"

#: ../Doc/reference/datamodel.rst:1137
msgid ""
"When implementing a class that emulates any built-in type, it is "
"important that the emulation only be implemented to the degree that it "
"makes sense for the object being modelled.  For example, some sequences "
"may work well with retrieval of individual elements, but extracting a "
"slice may not make sense.  (One example of this is the "
":class:`~xml.dom.NodeList` interface in the W3C's Document Object Model.)"
msgstr ""
"내장형을 흉내 내는 클래스를 구현할 때, 모방은 모형화하는 객체에 말이 되는 수준까지만 구현하는 것이 중요합니다. 예를 들어, 어떤"
" 시퀀스는 개별 항목들을 꺼내는 것만으로도 잘 동작할 수 있습니다. 하지만 슬라이스를 꺼내는 것은 말이 안 될 수 있습니다. (이런"
" 한가지 예는 W3C의 Document Object Model의 :class:`~xml.dom.NodeList` 인터페이스입니다.)"

#: ../Doc/reference/datamodel.rst:1148
msgid "Basic customization"
msgstr "기본적인 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:1154
msgid ""
"Called to create a new instance of class *cls*.  :meth:`__new__` is a "
"static method (special-cased so you need not declare it as such) that "
"takes the class of which an instance was requested as its first argument."
"  The remaining arguments are those passed to the object constructor "
"expression (the call to the class).  The return value of :meth:`__new__` "
"should be the new object instance (usually an instance of *cls*)."
msgstr ""
"클래스 *cls* 의 새 인스턴스를 만들기 위해 호출됩니다. :meth:`__new__` 는 스태틱 메서드입니다 (그렇게 선언하지 "
"않아도 되는 특별한 경우입니다)인데, 첫 번째 인자로 만들려고 하는 인스턴스의 클래스가 전달됩니다. 나머지 인자들은 객체 생성자 "
"표현(클래스 호출)에 전달된 것들입니다. :meth:`__new__` 의 반환 값은 새 객체 인스턴스이어야 합니다 (보통 *cls*"
" 의 인스턴스)."

#: ../Doc/reference/datamodel.rst:1161
msgid ""
"Typical implementations create a new instance of the class by invoking "
"the superclass's :meth:`__new__` method using ``super().__new__(cls[, "
"...])`` with appropriate arguments and then modifying the newly-created "
"instance as necessary before returning it."
msgstr ""
"일반적인 구현은 ``super().__new__(cls[, ...])`` 에 적절한 인자들을 전달하는 방법으로 슈퍼 클래스의 "
":meth:`__new__` 를 호출해서 새 인스턴스를 만든 후에, 돌려주기 전에 필요한 수정을 가합니다."

#: ../Doc/reference/datamodel.rst:1166
msgid ""
"If :meth:`__new__` returns an instance of *cls*, then the new instance's "
":meth:`__init__` method will be invoked like ``__init__(self[, ...])``, "
"where *self* is the new instance and the remaining arguments are the same"
" as were passed to :meth:`__new__`."
msgstr ""
"만약 :meth:`__new__` 가 *cls* 의 인스턴스를 돌려준다면, 새 인스턴스의 :meth:`__init__` 메서드가 "
"``__init__(self[, ...])`` 처럼 호출되는데, *self* 는 새 인스턴스이고, 나머지 인자들은 "
":meth:`__new__` 로 전달된 것들과 같습니다."

#: ../Doc/reference/datamodel.rst:1171
msgid ""
"If :meth:`__new__` does not return an instance of *cls*, then the new "
"instance's :meth:`__init__` method will not be invoked."
msgstr ""
"만약 :meth:`__new__` 가 *cls* 의 인스턴스를 돌려주지 않으면, 새 인스턴스의 :meth:`__init__` 는 "
"호출되지 않습니다."

#: ../Doc/reference/datamodel.rst:1174
msgid ""
":meth:`__new__` is intended mainly to allow subclasses of immutable types"
" (like int, str, or tuple) to customize instance creation.  It is also "
"commonly overridden in custom metaclasses in order to customize class "
"creation."
msgstr ""
":meth:`__new__` 는 주로 불변형(int, str, tuple과 같은)의 서브 클래스가 인스턴스 생성을 커스터마이즈할 수"
" 있도록 하는 데 사용됩니다. 또한, 사용자 정의 메타 클래스에서 클래스 생성을 커스터마이즈하기 위해 자주 사용됩니다."

#: ../Doc/reference/datamodel.rst:1183
msgid ""
"Called after the instance has been created (by :meth:`__new__`), but "
"before it is returned to the caller.  The arguments are those passed to "
"the class constructor expression.  If a base class has an "
":meth:`__init__` method, the derived class's :meth:`__init__` method, if "
"any, must explicitly call it to ensure proper initialization of the base "
"class part of the instance; for example: ``super().__init__([args...])``."
msgstr ""
"(:meth:`__new__` 에 의해) 인스턴스가 만들어진 후에, 하지만 호출자에게 돌려주기 전에 호출됩니다. 인자들은 클래스 "
"생성자 표현으로 전달된 것들입니다. 만약 베이스 클래스가 :meth:`__init__` 메서드를 갖고 있다면, 서브 클래스의 "
":meth:`__init__` 메서드는, 있다면, 인스턴스에서 베이스 클래스가 차지하는 부분이 올바르게 초기화됨을 확실히 하기 위해"
" 명시적으로 호출해주어야 합니다; 예를 들어: ``super().__init__([args...])``."

#: ../Doc/reference/datamodel.rst:1190
msgid ""
"Because :meth:`__new__` and :meth:`__init__` work together in "
"constructing objects (:meth:`__new__` to create it, and :meth:`__init__` "
"to customize it), no non-``None`` value may be returned by "
":meth:`__init__`; doing so will cause a :exc:`TypeError` to be raised at "
"runtime."
msgstr ""
"객체를 만드는데 :meth:`__new__` 와 :meth:`__init__` 가 협력하고 있으므로 (:meth:`__new__` "
"는 만들고, :meth:`__init__` 는 그것을 커스터마이즈합니다), :meth:`__init__` 가 ``None`` 이외의"
" 값을 돌려주면 실행시간에 :exc:`TypeError` 를 일으킵니다."

#: ../Doc/reference/datamodel.rst:1203
msgid ""
"Called when the instance is about to be destroyed.  This is also called a"
" finalizer or (improperly) a destructor.  If a base class has a "
":meth:`__del__` method, the derived class's :meth:`__del__` method, if "
"any, must explicitly call it to ensure proper deletion of the base class "
"part of the instance."
msgstr ""
"인스턴스가 파괴되기 직전에 호출됩니다. 파이널라이저 또는 (부적절하게) 파괴자라고 불립니다. 만약 베이스 클래스가 "
":meth:`__del__` 메서드를 갖고 있다면, 자식 클래스의 :meth:`__del__` 메서드는, 정의되어 있다면, "
"인스턴스에서 베이스 클래스가 차지하는 부분을 적절하게 삭제하기 위해, 명시적으로 베이스 클래스의 메서드를 호출해야 합니다."

#: ../Doc/reference/datamodel.rst:1209
msgid ""
"It is possible (though not recommended!) for the :meth:`__del__` method "
"to postpone destruction of the instance by creating a new reference to "
"it.  This is called object *resurrection*.  It is implementation-"
"dependent whether :meth:`__del__` is called a second time when a "
"resurrected object is about to be destroyed; the current :term:`CPython` "
"implementation only calls it once."
msgstr ""
"(권장하지는 않지만!) :meth:`__del__` 메서드는 인스턴스에 대한 새로운 참조를 만듦으로써 인스턴스의 파괴를 지연시킬 수"
" 있습니다. 이것을 객체 *부활* 이라고 부릅니다. 부활한 객체가 파괴될 때 :meth:`__del__` 이 두 번째로 호출될지는 "
"구현에 따라 다릅니다; 현재 :term:`CPython` 구현은 오직 한 번만 호출합니다."

#: ../Doc/reference/datamodel.rst:1216
msgid ""
"It is not guaranteed that :meth:`__del__` methods are called for objects "
"that still exist when the interpreter exits."
msgstr "인터프리터가 종료할 때 아직 남아있는 객체들에 대해서는 :meth:`__del__` 메서드의 호출이 보장되지 않습니다."

#: ../Doc/reference/datamodel.rst:1221
msgid ""
"``del x`` doesn't directly call ``x.__del__()`` --- the former decrements"
" the reference count for ``x`` by one, and the latter is only called when"
" ``x``'s reference count reaches zero."
msgstr ""
"``del x`` 는 직접 ``x.__del__()`` 를 호출하지 않습니다 --- 앞에 있는 것은 ``x`` 의 참조 "
"횟수(reference count)를 하나 감소시키고, 뒤에 있는 것은 ``x`` 의 참조 횟수가 0 이 될 때 호출됩니다."

#: ../Doc/reference/datamodel.rst:1236
msgid "Documentation for the :mod:`gc` module."
msgstr ":mod:`gc` 모듈에 대한 문서."

#: ../Doc/reference/datamodel.rst:1240
msgid ""
"Due to the precarious circumstances under which :meth:`__del__` methods "
"are invoked, exceptions that occur during their execution are ignored, "
"and a warning is printed to ``sys.stderr`` instead.  In particular:"
msgstr ""
":meth:`__del__` 이 호출되는 불안정한 상황 때문에, 이것이 실행 중에 발생시키는 예외는 무시되고, 대신에 "
"``sys.stderr`` 로 경고가 출력됩니다. 특히:"

#: ../Doc/reference/datamodel.rst:1244
msgid ""
":meth:`__del__` can be invoked when arbitrary code is being executed, "
"including from any arbitrary thread.  If :meth:`__del__` needs to take a "
"lock or invoke any other blocking resource, it may deadlock as the "
"resource may already be taken by the code that gets interrupted to "
"execute :meth:`__del__`."
msgstr ""
":meth:`__del__` 은 (임의의 스레드에서) 임의의 코드가 실행되는 동안 호출될 수 있습니다. :meth:`__del__`"
" 이 록을 얻어야 하거나 다른 블로킹 자원을 호출하면, :meth:`__del__` 을 실행하기 위해 중단된 코드가 자원을 이미 "
"차지했을 수 있으므로 교착 상태에 빠질 수 있습니다."

#: ../Doc/reference/datamodel.rst:1250
msgid ""
":meth:`__del__` can be executed during interpreter shutdown.  As a "
"consequence, the global variables it needs to access (including other "
"modules) may already have been deleted or set to ``None``. Python "
"guarantees that globals whose name begins with a single underscore are "
"deleted from their module before other globals are deleted; if no other "
"references to such globals exist, this may help in assuring that imported"
" modules are still available at the time when the :meth:`__del__` method "
"is called."
msgstr ""
":meth:`__del__` 은 인터프리터를 종료할 때 실행될 수 있습니다. 결과적으로, 액세스해야 하는 전역 변수(다른 모듈 "
"포함)가 이미 삭제되었거나 ``None`` 으로 설정되었을 수 있습니다. 파이썬은 이름이 하나의 밑줄로 시작하는 전역 객체가 다른 "
"전역 객체들보다 먼저 삭제됨을 보장합니다; 이것은, 만약 그 전역 객체들에 대한 다른 참조가 존재하지 않는다면, "
":meth:`__del__` 메서드가 호출되는 시점에, 임포트된 모듈들이 남아있도록 확실히 하는 데 도움이 될 수 있습니다."

#: ../Doc/reference/datamodel.rst:1265
msgid ""
"Called by the :func:`repr` built-in function to compute the \"official\" "
"string representation of an object.  If at all possible, this should look"
" like a valid Python expression that could be used to recreate an object "
"with the same value (given an appropriate environment).  If this is not "
"possible, a string of the form ``<...some useful description...>`` should"
" be returned. The return value must be a string object. If a class "
"defines :meth:`__repr__` but not :meth:`__str__`, then :meth:`__repr__` "
"is also used when an \"informal\" string representation of instances of "
"that class is required."
msgstr ""
":func:`repr` 내장 함수에 의해 호출되어 객체의 \"형식적인(official)\" 문자열 표현을 계산합니다. 만약 "
"가능하다면, 이것은 같은 (적절한 환경이 주어질 때) 값을 갖는 객체를 새로 만들 수 있는 올바른 파이썬 표현식처럼 보여야 합니다."
" 가능하지 않다면, ``<...쓸모있는 설명...>`` 형태의 문자열을 돌려줘야 합니다. 반환 값은 반드시 문자열이어야 합니다. "
"만약 클래스가 :meth:`__str__` 없이 :meth:`__repr__` 만 정의한다면, :meth:`__repr__` 은 그"
" 클래스 인스턴스의 \"비형식적인(informal)\" 문자열 표현이 요구될 때 사용될 수 있습니다."

#: ../Doc/reference/datamodel.rst:1274
msgid ""
"This is typically used for debugging, so it is important that the "
"representation is information-rich and unambiguous."
msgstr "이것은 디버깅에 사용되기 때문에, 표현이 풍부한 정보를 담고 모호하지 않게 하는 것이 중요합니다."

#: ../Doc/reference/datamodel.rst:1285
msgid ""
"Called by :func:`str(object) <str>` and the built-in functions "
":func:`format` and :func:`print` to compute the \"informal\" or nicely "
"printable string representation of an object.  The return value must be a"
" :ref:`string <textseq>` object."
msgstr ""
":func:`str(object) <str>` 와 내장 함수 :func:`format`, :func:`print` 에 의해 호출되어"
" 객체의 \"비형식적인(informal)\" 또는 보기 좋게 인쇄 가능한 문자열 표현을 계산합니다. 반환 값은 반드시 "
":ref:`문자열 <textseq>` 객체여야 합니다."

#: ../Doc/reference/datamodel.rst:1290
msgid ""
"This method differs from :meth:`object.__repr__` in that there is no "
"expectation that :meth:`__str__` return a valid Python expression: a more"
" convenient or concise representation can be used."
msgstr ""
"이 메서드는 :meth:`__str__` 이 올바른 파이썬 표현식을 돌려줄 것이라고 기대되지 않는다는 점에서 "
":meth:`object.__repr__` 과 다릅니다: 더 편리하고 간결한 표현이 사용될 수 있습니다."

#: ../Doc/reference/datamodel.rst:1294
msgid ""
"The default implementation defined by the built-in type :class:`object` "
"calls :meth:`object.__repr__`."
msgstr "내장형 :class:`object` 에 정의된 기본 구현은 :meth:`object.__repr__` 을 호출합니다."

#: ../Doc/reference/datamodel.rst:1304
msgid ""
"Called by :ref:`bytes <func-bytes>` to compute a byte-string "
"representation of an object. This should return a :class:`bytes` object."
msgstr ""
":ref:`bytes <func-bytes>` 에 의해 호출되어 객체의 바이트열 표현을 계산합니다. 반환 값은 반드시 "
":class:`bytes` 객체여야 합니다."

#: ../Doc/reference/datamodel.rst:1315
msgid ""
"Called by the :func:`format` built-in function, and by extension, "
"evaluation of :ref:`formatted string literals <f-strings>` and the "
":meth:`str.format` method, to produce a \"formatted\" string "
"representation of an object. The *format_spec* argument is a string that "
"contains a description of the formatting options desired. The "
"interpretation of the *format_spec* argument is up to the type "
"implementing :meth:`__format__`, however most classes will either "
"delegate formatting to one of the built-in types, or use a similar "
"formatting option syntax."
msgstr ""
":func:`format` 내장 함수, 확대하면, :ref:`포맷 문자열 리터럴(formatted string literals) "
"<f-strings>` 의 계산과 :meth:`str.format` 메서드에 의해 호출되어, 객체의 \"포맷된\" 문자열 표현을 "
"만들어냅니다. *format_spec* 인자는 요구되는 포맷 옵션들을 포함하는 문자열입니다. *format_spec* 인자의 해석은"
" :meth:`__format__` 을 구현하는 형에 달려있으나, 대부분 클래스는 포매팅을 내향형들의 하나로 위임하거나, 비슷한 "
"포맷 옵션 문법을 사용합니다."

#: ../Doc/reference/datamodel.rst:1325
msgid "See :ref:`formatspec` for a description of the standard formatting syntax."
msgstr "표준 포매팅 문법에 대해서는 :ref:`formatspec` 를 참고하면 됩니다."

#: ../Doc/reference/datamodel.rst:1327
msgid "The return value must be a string object."
msgstr "반환 값은 반드시 문자열이어야 합니다."

#: ../Doc/reference/datamodel.rst:1329
msgid ""
"The __format__ method of ``object`` itself raises a :exc:`TypeError` if "
"passed any non-empty string."
msgstr ""
"``object`` 의 __format__ 메서드 자신은, 빈 문자열이 아닌 인자가 전달되면 :exc:`TypeError` 를 "
"발생시킵니다."

#: ../Doc/reference/datamodel.rst:1333
msgid ""
"``object.__format__(x, '')`` is now equivalent to ``str(x)`` rather than "
"``format(str(self), '')``."
msgstr ""
"이제 ``object.__format__(x, '')`` 는 ``format(str(self), '')`` 가 아니라 "
"``str(x)`` 와 동등합니다."

#: ../Doc/reference/datamodel.rst:1349
msgid ""
"These are the so-called \"rich comparison\" methods. The correspondence "
"between operator symbols and method names is as follows: ``x<y`` calls "
"``x.__lt__(y)``, ``x<=y`` calls ``x.__le__(y)``, ``x==y`` calls "
"``x.__eq__(y)``, ``x!=y`` calls ``x.__ne__(y)``, ``x>y`` calls "
"``x.__gt__(y)``, and ``x>=y`` calls ``x.__ge__(y)``."
msgstr ""
"이것들은 소위 \"풍부한 비교(rich comparison)\" 메서드입니다. 연산자 기호와 메서드 이름 간의 관계는 다음과 "
"같습니다: ``x<y`` 는 ``x.__lt__(y)`` 를 호출합니다, ``x<=y`` 는 ``x.__le__(y)`` 를 "
"호출합니다, ``x==y`` 는 ``x.__eq__(y)`` 를 호출합니다, ``x!=y`` 는 ``x.__ne__(y)`` 를 "
"호출합니다, ``x>y`` 는 ``x.__gt__(y)`` 를 호출합니다, ``x>=y`` 는 ``x.__ge__(y)`` 를 "
"호출합니다."

#: ../Doc/reference/datamodel.rst:1355
msgid ""
"A rich comparison method may return the singleton ``NotImplemented`` if "
"it does not implement the operation for a given pair of arguments. By "
"convention, ``False`` and ``True`` are returned for a successful "
"comparison. However, these methods can return any value, so if the "
"comparison operator is used in a Boolean context (e.g., in the condition "
"of an ``if`` statement), Python will call :func:`bool` on the value to "
"determine if the result is true or false."
msgstr ""
"풍부한 비교 메서드는 주어진 한 쌍의 인자에게 해당 연산을 구현하지 않는 경우 단일자(singleton) "
"``NotImplemented`` 를 돌려줄 수 있습니다. 관례상, 성공적인 비교면 ``False`` 나 ``True`` 를 "
"돌려줍니다. 하지만, 이 메서드는 어떤 형의 값이건 돌려줄 수 있습니다, 그래서 비교 연산자가 논리 문맥(Boolean "
"context) (예를 들어 ``if`` 문의 조건)에서 사용되면, 파이썬은 결과의 참 거짓을 파악하기 위해 값에 대해 "
":func:`bool` 을 호출합니다."

#: ../Doc/reference/datamodel.rst:1362
msgid ""
"By default, :meth:`__ne__` delegates to :meth:`__eq__` and inverts the "
"result unless it is ``NotImplemented``.  There are no other implied "
"relationships among the comparison operators, for example, the truth of "
"``(x<y or x==y)`` does not imply ``x<=y``. To automatically generate "
"ordering operations from a single root operation, see "
":func:`functools.total_ordering`."
msgstr ""
"기본적으로, :meth:`__ne__` 는 :meth:`__eq__` 를 호출한 후 ``NotImplemented`` 가 아니라면 "
"그 결과를 뒤집습니다. 비교 연산자 간의 다른 암시적인 관계는 없습니다. 예를 들어, ``(x<y or x==y)`` 가 참이라고 "
"해서 ``x<=y`` 가 참일 필요는 없습니다. 하나의 기본 연산으로부터 대소관계 연산을 자동으로 만들어내려면 "
":func:`functools.total_ordering` 를 보면 됩니다."

#: ../Doc/reference/datamodel.rst:1369
msgid ""
"See the paragraph on :meth:`__hash__` for some important notes on "
"creating :term:`hashable` objects which support custom comparison "
"operations and are usable as dictionary keys."
msgstr ""
"사용자 정의 비교 연산자를 지원하고 딕셔너리 키로 사용될 수 있는 :term:`해시 가능 <hashable>` 객체를 만드는 것에 "
"관한 몇 가지 중요한 내용이 :meth:`__hash__` 에 관한 문단에 나옵니다."

#: ../Doc/reference/datamodel.rst:1373
msgid ""
"There are no swapped-argument versions of these methods (to be used when "
"the left argument does not support the operation but the right argument "
"does); rather, :meth:`__lt__` and :meth:`__gt__` are each other's "
"reflection, :meth:`__le__` and :meth:`__ge__` are each other's "
"reflection, and :meth:`__eq__` and :meth:`__ne__` are their own "
"reflection. If the operands are of different types, and right operand's "
"type is a direct or indirect subclass of the left operand's type, the "
"reflected method of the right operand has priority, otherwise the left "
"operand's method has priority.  Virtual subclassing is not considered."
msgstr ""
"이 메서드들에 대한 (왼편의 인자는 연산을 지원하지 않지만, 오른편 인자가 지원할 때 사용되는) 뒤집힌 버전은 따로 없습니다; "
"대신에 :meth:`__lt__` 와 :meth:`__gt__` 는 서로의 뒤집힌 연산입니다; :meth:`__le__` 와 "
":meth:`__ge__` 는 서로의 뒤집힌 연산입니다; :meth:`__eq__` 와 :meth:`__ne__` 는 서로의 뒤집힌"
" 연산입니다; 만약 피연산자가 서로 다른 형이고, 오른편 피연산자의 형이 왼편 피연산자의 형의 직간접적인 서브 클래스면, 오른편 "
"피연산자의 뒤집힌 버전이 우선순위가 높습니다; 그렇지 않으면 왼편 피연산자의 메서드가 우선순위가 높습니다. 가상 "
"서브클래싱(virtual subclassing)은 고려되지 않습니다."

#: ../Doc/reference/datamodel.rst:1390
msgid ""
"Called by built-in function :func:`hash` and for operations on members of"
" hashed collections including :class:`set`, :class:`frozenset`, and "
":class:`dict`.  :meth:`__hash__` should return an integer. The only "
"required property is that objects which compare equal have the same hash "
"value; it is advised to mix together the hash values of the components of"
" the object that also play a part in comparison of objects by packing "
"them into a tuple and hashing the tuple. Example::"
msgstr ""
"내장 함수 :func:`hash` 와 :class:`set`, :class:`frozenset`, :class:`dict` 와 같은"
" 해시형 컬렉션의 멤버에 대한 연산에서 호출됩니다. :meth:`__hash__` 는 정수를 돌려줘야 합니다. 같다고 비교되는 "
"객체들이 같은 해시값을 가져야 한다는 성질만 요구됩니다. 객체의 비교에 사용되는 요소들로 튜플을 구성하고, 그 튜플의 해시값을 "
"취함으로써 요소들의 해시값을 섞는 것을 권합니다. 예를 들면::"

#: ../Doc/reference/datamodel.rst:1403
msgid ""
":func:`hash` truncates the value returned from an object's custom "
":meth:`__hash__` method to the size of a :c:type:`Py_ssize_t`.  This is "
"typically 8 bytes on 64-bit builds and 4 bytes on 32-bit builds.  If an "
"object's   :meth:`__hash__` must interoperate on builds of different bit "
"sizes, be sure to check the width on all supported builds.  An easy way "
"to do this is with ``python -c \"import sys; "
"print(sys.hash_info.width)\"``."
msgstr ""
":func:`hash` 는 객체가 정의한 :meth:`__hash__` 메서드가 돌려주는 값을 :c:type:`Py_ssize_t`"
" 의 크기로 자릅니다(truncate). 이것은 보통 64-bit 빌드에서는 8바이트고, 32-bit 빌드에서는 4바이트입니다. "
"만약 객체의 :meth:`__hash__` 가 서로 다른 비트 크기를 갖는 빌드들 사이에서 함께 사용되어야 한다면, 모든 지원할 "
"빌드들에서의 폭을 검사해야 합니다. 이렇게 하는 쉬운 방법은 ``python -c \"import sys; "
"print(sys.hash_info.width)\"`` 입니다."

#: ../Doc/reference/datamodel.rst:1411
msgid ""
"If a class does not define an :meth:`__eq__` method it should not define "
"a :meth:`__hash__` operation either; if it defines :meth:`__eq__` but not"
" :meth:`__hash__`, its instances will not be usable as items in hashable "
"collections.  If a class defines mutable objects and implements an "
":meth:`__eq__` method, it should not implement :meth:`__hash__`, since "
"the implementation of hashable collections requires that a key's hash "
"value is immutable (if the object's hash value changes, it will be in the"
" wrong hash bucket)."
msgstr ""
"만약 클래스가 :meth:`__eq__` 를 정의하지 않으면 :meth:`__hash__` 역시 정의하지 말아야 합니다. 만약 "
":meth:`__eq__` 를 정의하지만 :meth:`__hash__` 를 정의하지 않는다면, 그것의 인스턴스는 해시 가능 "
"컬렉션에서 사용될 수 없습니다. 만약 클래스가 가변형 객체를 정의하고 있고 :meth:`__eq__` 를 구현한다면, "
":meth:`__hash__` 를 구현하지 말아야 하는데, 해시 가능 컬렉션들의 구현이 키의 해시값이 불변이도록 요구하고 있기 "
"때문입니다(만약 객체의 해시값이 변하면, 잘못된 해시 버킷(hash bucket)에 있게 됩니다)."

#: ../Doc/reference/datamodel.rst:1420
msgid ""
"User-defined classes have :meth:`__eq__` and :meth:`__hash__` methods by "
"default; with them, all objects compare unequal (except with themselves) "
"and ``x.__hash__()`` returns an appropriate value such that ``x == y`` "
"implies both that ``x is y`` and ``hash(x) == hash(y)``."
msgstr ""
"사용자 정의 클래스는 기본적으로 :meth:`__eq__` 와 :meth:`__hash__` 메서드를 갖습니다; 모든 객체는 (자기"
" 자신을 제외하고) 같지 않다고 비교되고, ``x.__hash__()`` 는 적절한 값을 돌려주어, ``x == y`` 일 때 "
"``x is y`` 와 ``hash(x) == hash(y)`` 가 동시에 성립할 수 있도록 합니다."

#: ../Doc/reference/datamodel.rst:1425
msgid ""
"A class that overrides :meth:`__eq__` and does not define "
":meth:`__hash__` will have its :meth:`__hash__` implicitly set to "
"``None``.  When the :meth:`__hash__` method of a class is ``None``, "
"instances of the class will raise an appropriate :exc:`TypeError` when a "
"program attempts to retrieve their hash value, and will also be correctly"
" identified as unhashable when checking ``isinstance(obj, "
"collections.abc.Hashable)``."
msgstr ""
":meth:`__eq__` 를 재정의하고 :meth:`__hash__` 를 정의하지 않는 클래스는 :meth:`__hash__` 가"
" ``None`` 으로 설정됩니다. 클래스의 :meth:`__hash__` 메서드가 ``None`` 이면, 클래스의 인스턴스는 "
"프로그램이 해시값을 얻으려 시도할 때 :exc:`TypeError` 를 일으키고, ``isinstance(obj, "
"collections.abc.Hashable)`` 로 검사할 때 해시 가능하지 않다고 올바로 감지됩니다."

#: ../Doc/reference/datamodel.rst:1432
msgid ""
"If a class that overrides :meth:`__eq__` needs to retain the "
"implementation of :meth:`__hash__` from a parent class, the interpreter "
"must be told this explicitly by setting ``__hash__ = "
"<ParentClass>.__hash__``."
msgstr ""
"만약 :meth:`__eq__` 를 재정의하는 클래스가 부모 클래스로부터 :meth:`__hash__` 의 구현을 물려받고 싶으면 "
"인터프리터에게 명시적으로 이렇게 지정해주어야 합니다: ``__hash__ = <ParentClass>.__hash__``."

#: ../Doc/reference/datamodel.rst:1436
msgid ""
"If a class that does not override :meth:`__eq__` wishes to suppress hash "
"support, it should include ``__hash__ = None`` in the class definition. A"
" class which defines its own :meth:`__hash__` that explicitly raises a "
":exc:`TypeError` would be incorrectly identified as hashable by an "
"``isinstance(obj, collections.abc.Hashable)`` call."
msgstr ""
"만약 :meth:`__eq__` 를 재정의하지 않는 클래스가 해시 지원을 멈추고 싶으면, 클래스 정의에 ``__hash__ = "
"None`` 을 포함해야 합니다. 자신의 :meth:`__hash__` 을 정의한 후에 직접 :exc:`TypeError` 를 "
"일으키는 경우는 ``isinstance(obj, collections.abc.Hashable)`` 호출이 해시 가능하다고 잘못 "
"인식합니다."

#: ../Doc/reference/datamodel.rst:1445
msgid ""
"By default, the :meth:`__hash__` values of str, bytes and datetime "
"objects are \"salted\" with an unpredictable random value.  Although they"
" remain constant within an individual Python process, they are not "
"predictable between repeated invocations of Python."
msgstr ""
"기본적으로, str, bytes, datetime 객체들의 :meth:`__hash__` 값은 예측할 수 없는 난수값으로 "
"\"솔트되어(salted)\" 있습니다. 개별 파이썬 프로세스 내에서는 변하지 않는 값으로 유지되지만, 파이썬을 반복적으로 실행할 "
"때는 예측할 수 없게 됩니다."

#: ../Doc/reference/datamodel.rst:1450
msgid ""
"This is intended to provide protection against a denial-of-service caused"
" by carefully-chosen inputs that exploit the worst case performance of a "
"dict insertion, O(n^2) complexity.  See "
"http://www.ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""
"이것은 dict 삽입의 최악의 경우 성능(worst case performance), O(n^2) 복잡도, 을 활용하기 위해 주의 "
"깊게 선택한 입력에 의한 서비스 거부(denial-of-service) 공격에 대한 방어를 제공하기 위한 목적입니다. 자세한 내용은"
" http://www.ocert.org/advisories/ocert-2011-003.html 에 있습니다."

#: ../Doc/reference/datamodel.rst:1455
msgid ""
"Changing hash values affects the iteration order of sets. Python has "
"never made guarantees about this ordering (and it typically varies "
"between 32-bit and 64-bit builds)."
msgstr ""
"해시값의 변경은 집합의 이터레이션 순서에 영향을 줍니다, 파이썬은 이 순서에 대해 어떤 보장도 하지 않습니다 (그리고 보통 "
"32-bit 와 64-bit 빌드 사이에서도 다릅니다)."

#: ../Doc/reference/datamodel.rst:1459
msgid "See also :envvar:`PYTHONHASHSEED`."
msgstr ":envvar:`PYTHONHASHSEED` 를 참고하십시오."

#: ../Doc/reference/datamodel.rst:1461
msgid "Hash randomization is enabled by default."
msgstr "해시 난수 화는 기본적으로 활성화됩니다."

#: ../Doc/reference/datamodel.rst:1469
msgid ""
"Called to implement truth value testing and the built-in operation "
"``bool()``; should return ``False`` or ``True``.  When this method is not"
" defined, :meth:`__len__` is called, if it is defined, and the object is "
"considered true if its result is nonzero.  If a class defines neither "
":meth:`__len__` nor :meth:`__bool__`, all its instances are considered "
"true."
msgstr ""
"논리값 검사와 내장 연산 ``bool()`` 구현을 위해 호출됩니다; ``False`` 나 ``True`` 를 돌려줘야 합니다. 이"
" 메서드가 정의되지 않는 경우, 정의되어 있다면 :meth:`__len__` 이 호출되어, 값이 0 이 아니면 참으로 인식합니다. "
"만약 클래스가 :meth:`__len__` 과 :meth:`__bool__` 모두 정의하지 않는다면, 모든 인스턴스는 참으로 "
"취급됩니다."

#: ../Doc/reference/datamodel.rst:1480
msgid "Customizing attribute access"
msgstr "어트리뷰트 액세스 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:1482
msgid ""
"The following methods can be defined to customize the meaning of "
"attribute access (use of, assignment to, or deletion of ``x.name``) for "
"class instances."
msgstr ""
"클래스 인스턴스의 어트리뷰트 참조(읽기, 대입하기, ``x.name`` 을 삭제하기)의 의미를 변경하기 위해 다음과 같은 메서드들이"
" 정의될 수 있습니다."

#: ../Doc/reference/datamodel.rst:1490
msgid ""
"Called when the default attribute access fails with an "
":exc:`AttributeError` (either :meth:`__getattribute__` raises an "
":exc:`AttributeError` because *name* is not an instance attribute or an "
"attribute in the class tree for ``self``; or :meth:`__get__` of a *name* "
"property raises :exc:`AttributeError`).  This method should either return"
" the (computed) attribute value or raise an :exc:`AttributeError` "
"exception."
msgstr ""
"기본 어트리뷰트 액세스가 :exc:`AttributeError` 로 실패할 때 호출됩니다 (*name* 이 인스턴스 어트리뷰트 또는"
" ``self`` 의 클래스 트리에 있는 어트리뷰트가 아니라서 :meth:`__getattribute__` 가 "
":exc:`AttributeError` 를 일으키거나; *name* 프로퍼티의 :meth:`__get__` 이 "
":exc:`AttributeError` 를 일으킬 때). 이 메서드는 (계산된) 어트리뷰트 값을 반환하거나 "
":exc:`AttributeError` 예외를 일으켜야 합니다."

#: ../Doc/reference/datamodel.rst:1497
msgid ""
"Note that if the attribute is found through the normal mechanism, "
":meth:`__getattr__` is not called.  (This is an intentional asymmetry "
"between :meth:`__getattr__` and :meth:`__setattr__`.) This is done both "
"for efficiency reasons and because otherwise :meth:`__getattr__` would "
"have no way to access other attributes of the instance.  Note that at "
"least for instance variables, you can fake total control by not inserting"
" any values in the instance attribute dictionary (but instead inserting "
"them in another object).  See the :meth:`__getattribute__` method below "
"for a way to actually get total control over attribute access."
msgstr ""
"일반적인 메커니즘을 통해 어트리뷰트가 발견되면 :meth:`__getattr__` 이 호출되지 않음에 주의해야 합니다 (이것은 "
":meth:`__getattr__` 과 :meth:`__setattr__` 간의 의도된 비대칭입니다). 이렇게 하는 이유는 효율 "
"때문이기도 하고, 그렇게 하지 않으면 :meth:`__getattr__` 가 인스턴스의 다른 어트리뷰트에 접근할 방법이 없기 "
"때문이기도 합니다. 적어도 인스턴스 변수의 경우, 어떤 값도 인스턴스 어트리뷰트 딕셔너리에 넣지 않음으로써 (대신에 그것들을 다른 "
"객체에 넣습니다) 완전한 제어인 것처럼 조작할 수 있습니다. 어트리뷰트 액세스를 실제로 완전히 조작하는 방법에 대해서는 아래에 "
"나오는 :meth:`__getattribute__` 에서 다룹니다."

#: ../Doc/reference/datamodel.rst:1510
msgid ""
"Called unconditionally to implement attribute accesses for instances of "
"the class. If the class also defines :meth:`__getattr__`, the latter will"
" not be called unless :meth:`__getattribute__` either calls it explicitly"
" or raises an :exc:`AttributeError`. This method should return the "
"(computed) attribute value or raise an :exc:`AttributeError` exception. "
"In order to avoid infinite recursion in this method, its implementation "
"should always call the base class method with the same name to access any"
" attributes it needs, for example, ``object.__getattribute__(self, "
"name)``."
msgstr ""
"클래스 인스턴스의 어트리뷰트 액세스를 구현하기 위해 조건 없이 호출됩니다. 만약 클래스가 :meth:`__getattr__` 도 "
"함께 구현하면, :meth:`__getattribute__` 가 명시적으로 호출하거나 :exc:`AttributeError` 를 "
"일으키지 않는 이상 `__getattr__` 는 호출되지 않습니다. 이 메서드는 어트리뷰트의 (계산된) 값을 돌려주거나 "
":exc:`AttributeError` 예외를 일으켜야 합니다. 이 메서드에서 무한 재귀(infinite recursion)가 "
"발생하는 것을 막기 위해, 구현은 언제나 필요한 어트리뷰트에 접근하기 위해 같은 이름의 베이스 클래스의 메서드를 호출해야 합니다. "
"예를 들어, ``object.__getattribute__(self, name)``."

#: ../Doc/reference/datamodel.rst:1521
msgid ""
"This method may still be bypassed when looking up special methods as the "
"result of implicit invocation via language syntax or built-in functions. "
"See :ref:`special-lookup`."
msgstr ""
"언어 문법이나 내장 함수에 의한 묵시적인 호출이 결과로 특수 메서드를 참조하는 경우에는 이 메서드를 거치지 않을 수 있습니다. "
"자세한 내용은 :ref:`special-lookup` 에서 다룹니다."

#: ../Doc/reference/datamodel.rst:1528
msgid ""
"Called when an attribute assignment is attempted.  This is called instead"
" of the normal mechanism (i.e. store the value in the instance "
"dictionary). *name* is the attribute name, *value* is the value to be "
"assigned to it."
msgstr ""
"어트리뷰트 대입이 시도될 때 호출됩니다. 일반적인 메커니즘(즉 인스턴스 딕셔너리에 값을 저장하는 것) 대신에 이것이 호출됩니다. "
"*name* 은 어트리뷰트 이름이고, *value* 는 그것에 대입하려는 값입니다. "

#: ../Doc/reference/datamodel.rst:1532
msgid ""
"If :meth:`__setattr__` wants to assign to an instance attribute, it "
"should call the base class method with the same name, for example, "
"``object.__setattr__(self, name, value)``."
msgstr ""
":meth:`__setattr__` 에서 인스턴스 어트리뷰트에 대입하려고 할 때는, 같은 이름의 베이스 클래스의 메서드를 호출해야 "
"합니다. 예를 들어 ``object.__setattr__(self, name, value)``"

#: ../Doc/reference/datamodel.rst:1539
msgid ""
"Like :meth:`__setattr__` but for attribute deletion instead of "
"assignment.  This should only be implemented if ``del obj.name`` is "
"meaningful for the object."
msgstr ""
":meth:`__setattr__` 과 비슷하지만 어트리뷰트를 대입하는 대신에 삭제합니다. 이것은 ``del obj.name`` 이"
" 객체에 의미가 있는 경우에만 구현되어야 합니다."

#: ../Doc/reference/datamodel.rst:1545
msgid ""
"Called when :func:`dir` is called on the object. A sequence must be "
"returned. :func:`dir` converts the returned sequence to a list and sorts "
"it."
msgstr ""
"객체에 :func:`dir` 이 호출될 때 호출됩니다. 시퀀스를 돌려줘야 합니다. :func:`dir` 은 돌려준 시퀀스를 리스트로"
" 변환한 후 정렬합니다."

#: ../Doc/reference/datamodel.rst:1550
msgid "Customizing module attribute access"
msgstr "모듈 어트리뷰트 액세스 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:1557
msgid ""
"Special names ``__getattr__`` and ``__dir__`` can be also used to "
"customize access to module attributes. The ``__getattr__`` function at "
"the module level should accept one argument which is the name of an "
"attribute and return the computed value or raise an "
":exc:`AttributeError`. If an attribute is not found on a module object "
"through the normal lookup, i.e. :meth:`object.__getattribute__`, then "
"``__getattr__`` is searched in the module ``__dict__`` before raising an "
":exc:`AttributeError`. If found, it is called with the attribute name and"
" the result is returned."
msgstr ""
"특수한 이름 ``__getattr__`` 과 ``__dir__`` 는 모듈 어트리뷰트에 대한 접근을 사용자 정의하는 데 사용될 수도"
" 있습니다. 모듈 수준의 ``__getattr__`` 함수는 하나의 인자로 어트리뷰트의 이름을 받아서 계산된 값을 돌려주거나 "
":exc:`AttributeError` 를 발생시켜야 합니다. 일반적인 조회(즉 "
":meth:`object.__getattribute__`)를 통해 어트리뷰트가 모듈 객체에서 발견되지 않으면, "
":exc:`AttributeError` 를 일으키기 전에 모듈 ``__dict__`` 에서 ``__getattr__`` 을 "
"검색합니다. 발견되면, 어트리뷰트 이름으로 그 함수를 호출하고 결과를 돌려줍니다."

#: ../Doc/reference/datamodel.rst:1566
msgid ""
"The ``__dir__`` function should accept no arguments, and return a list of"
" strings that represents the names accessible on module. If present, this"
" function overrides the standard :func:`dir` search on a module."
msgstr ""
"``__dir__`` 함수는 인자를 받지 않고 모듈에서 접근 할 수 있는 이름을 나타내는 문자열 리스트를 돌려줘야 합니다. "
"존재하면, 이 함수는 모듈에 대한 표준 :func:`dir` 검색을 재정의합니다."

#: ../Doc/reference/datamodel.rst:1570
msgid ""
"For a more fine grained customization of the module behavior (setting "
"attributes, properties, etc.), one can set the ``__class__`` attribute of"
" a module object to a subclass of :class:`types.ModuleType`. For "
"example::"
msgstr ""
"모듈 동작(어트리뷰트 설정, 프로퍼티 등)을 보다 세밀하게 사용자 정의하려면, 모듈 객체의 ``__class__`` 어트리뷰트를 "
":class:`types.ModuleType` 의 서브 클래스로 설정할 수 있습니다. 예를 들면::"

#: ../Doc/reference/datamodel.rst:1588
msgid ""
"Defining module ``__getattr__`` and setting module ``__class__`` only "
"affect lookups made using the attribute access syntax -- directly "
"accessing the module globals (whether by code within the module, or via a"
" reference to the module's globals dictionary) is unaffected."
msgstr ""
"모듈 ``__getattr__`` 정의와 모듈 ``__class__`` 설정은 어트리뷰트 액세스 구문을 사용하는 조회에만 영향을 "
"미칩니다 -- 모듈 전역에 대한 직접적인 액세스(모듈 내의 코드에 의한 액세스이거나 모듈의 전역 딕셔너리에 대한 참조를 거치거나)는"
" 영향받지 않습니다."

#: ../Doc/reference/datamodel.rst:1593
msgid "``__class__`` module attribute is now writable."
msgstr "이제 ``__class__`` 모듈 어트리뷰트가 쓰기 가능합니다."

#: ../Doc/reference/datamodel.rst:1596
msgid "``__getattr__`` and ``__dir__`` module attributes."
msgstr "``__getattr__`` 과 ``__dir__`` 모듈 어트리뷰트."

#: ../Doc/reference/datamodel.rst:1601
msgid ":pep:`562` - Module __getattr__ and __dir__"
msgstr ":pep:`562` - 모듈 __getattr__ 과 __dir__"

#: ../Doc/reference/datamodel.rst:1602
msgid "Describes the ``__getattr__`` and ``__dir__`` functions on modules."
msgstr "모듈에 대한 ``__getattr__`` 과 ``__dir__`` 함수를 설명합니다."

#: ../Doc/reference/datamodel.rst:1608
msgid "Implementing Descriptors"
msgstr "디스크립터 구현하기"

#: ../Doc/reference/datamodel.rst:1610
msgid ""
"The following methods only apply when an instance of the class containing"
" the method (a so-called *descriptor* class) appears in an *owner* class "
"(the descriptor must be in either the owner's class dictionary or in the "
"class dictionary for one of its parents).  In the examples below, \"the "
"attribute\" refers to the attribute whose name is the key of the property"
" in the owner class' :attr:`~object.__dict__`."
msgstr ""
"다음에 오는 메서드들은 메서드를 가진 클래스(소위 *디스크립터(descriptor)* 클래스)의 인스턴스가 *소유자(owner)* "
"클래스에 등장할 때만 적용됩니다(디스크립터는 소유자 클래스의 딕셔너리나 그 부모 클래스 중 하나의 딕셔너리에 있어야 합니다). "
"아래의 예에서, \"어트리뷰트\" 는 이름이 소유자 클래스의 :attr:`~object.__dict__` 의 키로 사용되고 있는 "
"어트리뷰트를 가리킵니다."

#: ../Doc/reference/datamodel.rst:1620
msgid ""
"Called to get the attribute of the owner class (class attribute access) "
"or of an instance of that class (instance attribute access). *owner* is "
"always the owner class, while *instance* is the instance that the "
"attribute was accessed through, or ``None`` when the attribute is "
"accessed through the *owner*.  This method should return the (computed) "
"attribute value or raise an :exc:`AttributeError` exception."
msgstr ""
"소유자 클래스(클래스 어트리뷰트 액세스) 나 그 클래스의 인스턴스(인스턴스 어트리뷰트 액세스)의 어트리뷰트를 취하려고 할 때 "
"호출됩니다. *owner* 는 항상 소유자 클래스입니다. 반면에 *instance* 는 어트리뷰트 참조가 일어나고 있는 "
"인스턴스이거나, 어트리뷰트가 *owner* 를 통해 액세스 되는 경우 `None` 입니다. 이 메서드는 (계산된) 어트리뷰트 값을 "
"돌려주거나 :exc:`AttributeError` 예외를 일으켜야 합니다."

#: ../Doc/reference/datamodel.rst:1630
msgid ""
"Called to set the attribute on an instance *instance* of the owner class "
"to a new value, *value*."
msgstr "소유자 클래스의 인스턴스 *instance* 의 어트리뷰트를 새 값 *value* 로 설정할 때 호출됩니다."

#: ../Doc/reference/datamodel.rst:1636
msgid ""
"Called to delete the attribute on an instance *instance* of the owner "
"class."
msgstr "소유자 클래스의 인스턴스 *instance* 의 어트리뷰트를 삭제할 때 호출됩니다."

#: ../Doc/reference/datamodel.rst:1641
msgid ""
"Called at the time the owning class *owner* is created. The descriptor "
"has been assigned to *name*."
msgstr "소유자 클래스 *owner* 가 만들어질 때 호출됩니다. 이 디스크립터가 *name* 에 대입되었습니다."

#: ../Doc/reference/datamodel.rst:1647
msgid ""
"The attribute :attr:`__objclass__` is interpreted by the :mod:`inspect` "
"module as specifying the class where this object was defined (setting "
"this appropriately can assist in runtime introspection of dynamic class "
"attributes). For callables, it may indicate that an instance of the given"
" type (or a subclass) is expected or required as the first positional "
"argument (for example, CPython sets this attribute for unbound methods "
"that are implemented in C)."
msgstr ""
"어트리뷰트 :attr:`__objclass__` 는 :mod:`inspect` 모듈에 의해 이 객체가 정의된 클래스를 지정하는 "
"것으로 해석됩니다(이 값을 적절히 설정하면 동적인 클래스 어트리뷰트의 실행시간 인트로스펙션(introspection)을 지원할 수 "
"있습니다). 콜러블의 경우, 첫 번째 위치 인자에, 주어진 형(또는 서브 클래스)의 인스턴스가 기대되거나 요구됨을 가리킬 수 "
"있습니다(예를 들어, CPython 은 C로 구현된 연결되지 않은 메서드(unbound method)에 이 어트리뷰트를 "
"설정합니다)."

#: ../Doc/reference/datamodel.rst:1658
msgid "Invoking Descriptors"
msgstr "디스크립터 호출하기"

#: ../Doc/reference/datamodel.rst:1660
msgid ""
"In general, a descriptor is an object attribute with \"binding "
"behavior\", one whose attribute access has been overridden by methods in "
"the descriptor protocol:  :meth:`__get__`, :meth:`__set__`, and "
":meth:`__delete__`. If any of those methods are defined for an object, it"
" is said to be a descriptor."
msgstr ""
"일반적으로, 디스크립터는 \"결합한 동작(binding behavior)\"을 가진 객체 어트리뷰트입니다. 어트리뷰트 액세스가 "
"디스크립터 프로토콜(descriptor protocol)의 메서드들에 의해 재정의됩니다: :meth:`__get__`, "
":meth:`__set__`, :meth:`__delete__`. 이 메서드들 중 하나라도 정의되어 있으면, 디스크립터라고 "
"부릅니다."

#: ../Doc/reference/datamodel.rst:1665
msgid ""
"The default behavior for attribute access is to get, set, or delete the "
"attribute from an object's dictionary. For instance, ``a.x`` has a lookup"
" chain starting with ``a.__dict__['x']``, then ``type(a).__dict__['x']``,"
" and continuing through the base classes of ``type(a)`` excluding "
"metaclasses."
msgstr ""
"어트리뷰트 액세스의 기본 동작은 객체의 딕셔너리에서 어트리뷰트를 읽고, 쓰고, 삭제하는 것입니다. 예를 들어 ``a.x`` 는 "
"``a.__dict__['x']`` 에서 시작해서 ``type(a).__dict__['x']`` 를 거쳐 ``type(a)`` 의 "
"메타 클래스를 제외한 베이스 클래스들을 거쳐 가는 일련의 조회로 구성됩니다."

#: ../Doc/reference/datamodel.rst:1670
msgid ""
"However, if the looked-up value is an object defining one of the "
"descriptor methods, then Python may override the default behavior and "
"invoke the descriptor method instead.  Where this occurs in the "
"precedence chain depends on which descriptor methods were defined and how"
" they were called."
msgstr ""
"그러나, 만약 조회한 값이 디스크립터 메서드를 구현한 객체면, 파이썬은 기본 동작 대신에 디스크립터 메서드를 호출할 수 있습니다. "
"우선순위 목록의 어느 위치에서 이런 일이 일어나는지는 어떤 디스크립터 메서드가 정의되어 있고 어떤 식으로 호출되는지에 따라 "
"다릅니다."

#: ../Doc/reference/datamodel.rst:1675
msgid ""
"The starting point for descriptor invocation is a binding, ``a.x``. How "
"the arguments are assembled depends on ``a``:"
msgstr "디스크립터 호출의 시작점은 결합(binding)입니다, ``a.x``. 어떻게 인자들이 조합되는지는 ``a`` 에 따라 다릅니다:"

#: ../Doc/reference/datamodel.rst:1680
msgid "Direct Call"
msgstr "직접 호출"

#: ../Doc/reference/datamodel.rst:1679
msgid ""
"The simplest and least common call is when user code directly invokes a "
"descriptor method:    ``x.__get__(a)``."
msgstr "가장 간단하면서도 가장 덜 사용되는 호출은 사용자의 코드가 디스크립터 메서드를 직접 호출할 때입니다: ``x.__get__(a)``"

#: ../Doc/reference/datamodel.rst:1684
msgid "Instance Binding"
msgstr "인스턴스 결합"

#: ../Doc/reference/datamodel.rst:1683
msgid ""
"If binding to an object instance, ``a.x`` is transformed into the call: "
"``type(a).__dict__['x'].__get__(a, type(a))``."
msgstr ""
"객체 인스턴스에 결합하면, ``a.x`` 는 이런 호출로 변환됩니다: ``type(a).__dict__['x'].__get__(a,"
" type(a))``."

#: ../Doc/reference/datamodel.rst:1688
msgid "Class Binding"
msgstr "클래스 결합"

#: ../Doc/reference/datamodel.rst:1687
msgid ""
"If binding to a class, ``A.x`` is transformed into the call: "
"``A.__dict__['x'].__get__(None, A)``."
msgstr "클래스에 결합하면, ``A.x`` 는 이런 호출로 변환됩니다: ``A.__dict__['x'].__get__(None, A)``."

#: ../Doc/reference/datamodel.rst:1694
msgid "Super Binding"
msgstr "Super 결합"

#: ../Doc/reference/datamodel.rst:1691
msgid ""
"If ``a`` is an instance of :class:`super`, then the binding ``super(B, "
"obj).m()`` searches ``obj.__class__.__mro__`` for the base class ``A`` "
"immediately preceding ``B`` and then invokes the descriptor with the "
"call: ``A.__dict__['m'].__get__(obj, obj.__class__)``."
msgstr ""
":class:`super` 의 인스턴스에 결합하면, 결합 ``super(B, obj).m()`` 은 "
"``obj.__class__.__mro__`` 를 검색해서 ``B`` 바로 다음에 나오는 베이스 클래스 ``A`` 를 찾은 후에 "
"이렇게 디스크립터를 호출합니다: ``A.__dict__['m'].__get__(obj, obj.__class__)``."

#: ../Doc/reference/datamodel.rst:1696
msgid ""
"For instance bindings, the precedence of descriptor invocation depends on"
" the which descriptor methods are defined.  A descriptor can define any "
"combination of :meth:`__get__`, :meth:`__set__` and :meth:`__delete__`.  "
"If it does not define :meth:`__get__`, then accessing the attribute will "
"return the descriptor object itself unless there is a value in the "
"object's instance dictionary.  If the descriptor defines :meth:`__set__` "
"and/or :meth:`__delete__`, it is a data descriptor; if it defines "
"neither, it is a non-data descriptor.  Normally, data descriptors define "
"both :meth:`__get__` and :meth:`__set__`, while non-data descriptors have"
" just the :meth:`__get__` method.  Data descriptors with :meth:`__set__` "
"and :meth:`__get__` defined always override a redefinition in an instance"
" dictionary.  In contrast, non-data descriptors can be overridden by "
"instances."
msgstr ""
"인스턴스 결합의 경우, 디스크립터 호출의 우선순위는 어떤 디스크립터 메서드가 정의되어있는지에 따라 다릅니다. 디스크립터는 "
":meth:`__get__`, :meth:`__set__`, :meth:`__delete__` 를 어떤 조합으로도 정의할 수 "
"있습니다. 만약 :meth:`__get__` 를 정의하지 않는다면, 어트리뷰트 액세스는, 객체의 인스턴스 딕셔너리에 값이 있지 않은"
" 이상 디스크립터 객체 자신을 돌려줍니다. 만약 디스크립터가 :meth:`__set__` 이나 :meth:`__delete__` 중"
" 어느 하나나 둘 다 정의하면, 데이터 디스크립터(data descriptor)입니다. 둘 다 정의하지 않는다면 비데이터 디스크립터"
"(non-data descriptor)입니다. 보통, 데이터 디스크립터가 :meth:`__get__` 과 "
":meth:`__set__` 을 모두 정의하는 반면, 비데이터 디스크립터는 :meth:`__get__` 메서드만 정의합니다. "
":meth:`__set__` 과 :meth:`__get__` 이 있는 데이터 디스크립터는 인스턴스 딕셔너리에 있는 값에 우선합니다."
" 반면에 비데이터 디스크립터는 인스턴스보다 우선순위가 낮습니다."

#: ../Doc/reference/datamodel.rst:1709
msgid ""
"Python methods (including :func:`staticmethod` and :func:`classmethod`) "
"are implemented as non-data descriptors.  Accordingly, instances can "
"redefine and override methods.  This allows individual instances to "
"acquire behaviors that differ from other instances of the same class."
msgstr ""
"파이썬 메서드 (:func:`staticmethod` 와 :func:`classmethod` 를 포함해서) 는 비데이터 디스크립터로"
" 구현됩니다. 이 때문에, 인스턴스는 메서드를 새로 정의하거나 덮어쓸 수 있습니다. 이것은 개별 인스턴스가 같은 클래스의 다른 "
"인스턴스들과는 다른 동작을 얻을 수 있도록 만듭니다."

#: ../Doc/reference/datamodel.rst:1714
msgid ""
"The :func:`property` function is implemented as a data descriptor. "
"Accordingly, instances cannot override the behavior of a property."
msgstr ""
":func:`property` 함수는 데이터 디스크립터로 구현됩니다. 이 때문에, 인스턴스는 프로퍼티(property)의 동작을 "
"변경할 수 없습니다."

#: ../Doc/reference/datamodel.rst:1721
msgid "__slots__"
msgstr "__slots__"

#: ../Doc/reference/datamodel.rst:1723
msgid ""
"*__slots__* allow us to explicitly declare data members (like properties)"
" and deny the creation of *__dict__* and *__weakref__* (unless explicitly"
" declared in *__slots__* or available in a parent.)"
msgstr ""
"*__slots__* 은 (프로퍼티처럼) 데이터 멤버를 명시적으로 선언하고 (*__slots__* 에 명시적으로 선언하거나 "
"부모로부터 물려받지 않는 한) *__dict__* 와 *__weakref__* 생성을 거부할 수 있도록 합니다."

#: ../Doc/reference/datamodel.rst:1727
msgid ""
"The space saved over using *__dict__* can be significant. Attribute "
"lookup speed can be significantly improved as well."
msgstr "*__dict__* 를 사용할 때에 비교해 절약되는 공간은 상당할 수 있습니다. 어트리뷰트 조회 속도도 크게 개선할 수 있습니다."

#: ../Doc/reference/datamodel.rst:1732
msgid ""
"This class variable can be assigned a string, iterable, or sequence of "
"strings with variable names used by instances.  *__slots__* reserves "
"space for the declared variables and prevents the automatic creation of "
"*__dict__* and *__weakref__* for each instance."
msgstr ""
"이 클래스 변수에는 인스턴스에 의해 사용되는 변수들의 이름을 제공하는 문자열, 이터러블(iterable), 문자열의 시퀀스가 대입될"
" 수 있습니다. *__slots__* 은 선언된 변수들을 위한 공간을 예약하고, 간 인스턴스마다 *__dict__* 와 "
"*__weakref__* 가 만들어지는 것을 막습니다."

#: ../Doc/reference/datamodel.rst:1739
msgid "Notes on using *__slots__*"
msgstr "*__slots__* 사용에 관한 노트"

#: ../Doc/reference/datamodel.rst:1741
msgid ""
"When inheriting from a class without *__slots__*, the *__dict__* and "
"*__weakref__* attribute of the instances will always be accessible."
msgstr ""
"*__slots__* 가 없는 클래스를 계승할 때, 인스턴스의 *__dict__* 와 *__weakref__* 어트리뷰트는 항상 "
"제공됩니다."

#: ../Doc/reference/datamodel.rst:1744
msgid ""
"Without a *__dict__* variable, instances cannot be assigned new variables"
" not listed in the *__slots__* definition.  Attempts to assign to an "
"unlisted variable name raises :exc:`AttributeError`. If dynamic "
"assignment of new variables is desired, then add ``'__dict__'`` to the "
"sequence of strings in the *__slots__* declaration."
msgstr ""
"*__dict__* 변수가 없으므로 인스턴스는 *__slots__* 정의에 나열되지 않은 새 변수를 대입할 수 없습니다. 나열되지 "
"않은 변수명으로 대입하려고 하면 :exc:`AttributeError` 를 일으킵니다. 만약 동적으로 새 변수를 대입하는 것이 "
"필요하다면, *__slots__* 선언의 문자열 시퀀스에 ``'__dict__'`` 를 추가합니다."

#: ../Doc/reference/datamodel.rst:1750
msgid ""
"Without a *__weakref__* variable for each instance, classes defining "
"*__slots__* do not support weak references to its instances. If weak "
"reference support is needed, then add ``'__weakref__'`` to the sequence "
"of strings in the *__slots__* declaration."
msgstr ""
"인스턴스마다 *__weakref__* 변수가 없으므로, *__slots__* 를 정의하는 클래스는 인스턴스에 대한 약한 "
"참조(weak reference)를 지원하지 않습니다. 만약 약한 참조 지원이 필요하다면, *__slots__* 선언의 문자열 "
"시퀀스에 ``'__weakref__'`` 를 추가합니다."

#: ../Doc/reference/datamodel.rst:1755
msgid ""
"*__slots__* are implemented at the class level by creating descriptors "
"(:ref:`descriptors`) for each variable name.  As a result, class "
"attributes cannot be used to set default values for instance variables "
"defined by *__slots__*; otherwise, the class attribute would overwrite "
"the descriptor assignment."
msgstr ""
"*__slots__* 는 각 변수 이름마다 디스크립터를 만드는 방식으로 클래스 수준에서 "
"구현됩니다(:ref:`descriptors`). 결과적으로, 클래스 어트리뷰트는 *__slots__* 로 정의된 인스턴스 변수들을 "
"위한 기본값을 제공할 목적으로 사용될 수 없습니다. 클래스 어트리뷰트는 디스크립터 대입을 무효로 합니다."

#: ../Doc/reference/datamodel.rst:1761
msgid ""
"The action of a *__slots__* declaration is not limited to the class where"
" it is defined.  *__slots__* declared in parents are available in child "
"classes. However, child subclasses will get a *__dict__*  and "
"*__weakref__* unless they also define *__slots__* (which should only "
"contain names of any *additional* slots)."
msgstr ""
"*__slots__* 선언으로 인한 효과는 그것이 정의된 클래스로 한정되지 않습니다. 부모가 선언한 *__slots__* 은 자식 "
"클래스에 제공됩니다. 하지만, 자식 서브 클래스가 자신의 *__slots__* (새로 *추가되는* 변수들만 포함해야 합니다) 을 "
"정의하지 않는다면 *__dict__* 와 *__weakref__* 를 갖게 됩니다."

#: ../Doc/reference/datamodel.rst:1767
msgid ""
"If a class defines a slot also defined in a base class, the instance "
"variable defined by the base class slot is inaccessible (except by "
"retrieving its descriptor directly from the base class). This renders the"
" meaning of the program undefined.  In the future, a check may be added "
"to prevent this."
msgstr ""
"클래스가 베이스 클래스의 *__slots__* 에 정의된 이름과 같은 이름의 변수를 *__slots__* 에 선언한다면, 베이스 "
"클래스가 정의한 변수는 액세스할 수 없는 상태가 됩니다(베이스 클래스로부터 디스크립터를 직접 조회하는 경우는 예외다). 이것은 "
"프로그램을 정의되지 않은 상태로 보내게 됩니다. 미래에는, 이를 방지하기 위한 검사가 추가될 것입니다."

#: ../Doc/reference/datamodel.rst:1772
msgid ""
"Nonempty *__slots__* does not work for classes derived from \"variable-"
"length\" built-in types such as :class:`int`, :class:`bytes` and "
":class:`tuple`."
msgstr ""
":class:`int`, :class:`bytes`, :class:`tuple`\\과 같은 \"가변 길이(valiable-"
"length)\" 의 내장형들을 계승하는 클래스에서는 오직 빈 *__slots__* 만 지원됩니다."

#: ../Doc/reference/datamodel.rst:1775
msgid ""
"Any non-string iterable may be assigned to *__slots__*. Mappings may also"
" be used; however, in the future, special meaning may be assigned to the "
"values corresponding to each key."
msgstr ""
"*__slots__* 에는 문자열 이외의 이터러블을 대입할 수 있습니다. 매핑도 역시 사용할 수 있습니다. 하지만, 미래에, 각 "
"키에 대응하는 값들의 의미가 부여될 수 있습니다."

#: ../Doc/reference/datamodel.rst:1779
msgid ""
"*__class__* assignment works only if both classes have the same "
"*__slots__*."
msgstr "두 클래스가 같은 *__slots__* 을 갖는 경우만 *__class__* 대입이 동작합니다."

#: ../Doc/reference/datamodel.rst:1781
msgid ""
"Multiple inheritance with multiple slotted parent classes can be used, "
"but only one parent is allowed to have attributes created by slots (the "
"other bases must have empty slot layouts) - violations raise "
":exc:`TypeError`."
msgstr ""
"슬롯을 사용하는 여러 부모 클래스들을 다중 상속할 수 있지만, 오직 하나의 부모만 슬롯으로 만들어진 어트리뷰트를 가질 수 있습니다 "
"(다른 베이스들은 빈 슬롯을 가져야만 합니다) - 이를 어기면 :exc:`TypeError` 를 일으킵니다."

#: ../Doc/reference/datamodel.rst:1789
msgid "Customizing class creation"
msgstr "클래스 생성 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:1791
msgid ""
"Whenever a class inherits from another class, *__init_subclass__* is "
"called on that class. This way, it is possible to write classes which "
"change the behavior of subclasses. This is closely related to class "
"decorators, but where class decorators only affect the specific class "
"they're applied to, ``__init_subclass__`` solely applies to future "
"subclasses of the class defining the method."
msgstr ""
"클래스가 다른 클래스를 상속할 때, 그 클래스의 *__init_subclass__* 가 호출됩니다. 이 방법으로, 서브 클래스의 "
"동작을 변경하는 클래스를 쓰는 것이 가능합니다. 이런 용도는 클래스 데코레이터와도 밀접히 관련되어 있습니다. 하지만 클래스 "
"데코레이터는 그들을 사용하는 특정한 클래스에만 작용하지만, ``__init_subclass__`` 단독으로 그 메서드를 정의하는 "
"클래스의 미래 서브 클래스 모두에게 작용합니다."

#: ../Doc/reference/datamodel.rst:1800
msgid ""
"This method is called whenever the containing class is subclassed. *cls* "
"is then the new subclass. If defined as a normal instance method, this "
"method is implicitly converted to a class method."
msgstr ""
"이 메서드는 포함하는 클래스의 서브 클래스가 만들어질 때마다 호출됩니다. *cls* 는 새 서브 클래스입니다. 만약 일반적인 "
"인스턴스 메서드로 정의되면, 이 메서드는 묵시적으로 클래스 메서드로 변경됩니다."

#: ../Doc/reference/datamodel.rst:1804
msgid ""
"Keyword arguments which are given to a new class are passed to the "
"parent's class ``__init_subclass__``. For compatibility with other "
"classes using ``__init_subclass__``, one should take out the needed "
"keyword arguments and pass the others over to the base class, as in::"
msgstr ""
"새 클래스에 주어진 키워드 인자들은 부모 클래스의 ``__init_subclass__`` 로 전달됩니다. "
"``__init_subclass__`` 를 사용하는 다른 클래스들과의 호환성을 위해, 필요한 키워드 인자들을 꺼낸 후에 다른 것들을"
" 베이스 클래스로 전달해야 합니다. 이런 식입니다::"

#: ../Doc/reference/datamodel.rst:1818
msgid ""
"The default implementation ``object.__init_subclass__`` does nothing, but"
" raises an error if it is called with any arguments."
msgstr ""
"기본 구현 ``object.__init_subclass__`` 는 아무 일도 하지 않지만, 인자가 포함되어 호출되면 예외를 "
"발생시킵니다."

#: ../Doc/reference/datamodel.rst:1823
msgid ""
"The metaclass hint ``metaclass`` is consumed by the rest of the type "
"machinery, and is never passed to ``__init_subclass__`` implementations. "
"The actual metaclass (rather than the explicit hint) can be accessed as "
"``type(cls)``."
msgstr ""
"메타 클래스 힌트 ``metaclass`` 는 나머지 형 절차에 의해 소비되고, ``__init_subclass__`` 로 전달되지"
" 않습니다. 실제 메타 클래스 (명시적인 힌트 대신에) 는 ``type(cls)`` 로 액세스할 수 있습니다."

#: ../Doc/reference/datamodel.rst:1834
msgid "Metaclasses"
msgstr "메타 클래스"

#: ../Doc/reference/datamodel.rst:1841
msgid ""
"By default, classes are constructed using :func:`type`. The class body is"
" executed in a new namespace and the class name is bound locally to the "
"result of ``type(name, bases, namespace)``."
msgstr ""
"기본적으로, 클래스는 :func:`type` 을 사용해서 만들어집니다. 클래스의 바디는 새 이름 공간에서 실행되고, 클래스 이름은 "
"``type(name, bases, namespace)`` 의 결과에 지역적으로 연결됩니다."

#: ../Doc/reference/datamodel.rst:1845
msgid ""
"The class creation process can be customized by passing the ``metaclass``"
" keyword argument in the class definition line, or by inheriting from an "
"existing class that included such an argument. In the following example, "
"both ``MyClass`` and ``MySubclass`` are instances of ``Meta``::"
msgstr ""
"클래스를 만드는 과정은 클래스 정의 줄에 ``metaclass`` 키워드 인자를 전달하거나, 그런 인자를 포함한 이미 존재하는 "
"클래스를 계승함으로써 커스터마이즈될 수 있습니다. 다음 예에서, ``MyClass`` 와 ``MySubclass`` 는 모두 "
"``Meta`` 의 인스턴스입니다."

#: ../Doc/reference/datamodel.rst:1859
msgid ""
"Any other keyword arguments that are specified in the class definition "
"are passed through to all metaclass operations described below."
msgstr "클래스 정의에서 지정된 다른 키워드 인자들은 아래에서 설명되는 모든 메타 클래스 연산들로 전달됩니다."

#: ../Doc/reference/datamodel.rst:1862
msgid "When a class definition is executed, the following steps occur:"
msgstr "클래스 정의가 실행될 때, 다음과 같은 단계가 수행됩니다.:"

#: ../Doc/reference/datamodel.rst:1864
msgid "MRO entries are resolved;"
msgstr "MRO 항목이 결정됩니다;"

#: ../Doc/reference/datamodel.rst:1865
msgid "the appropriate metaclass is determined;"
msgstr "적절한 메타 클래스가 결정됩니다;"

#: ../Doc/reference/datamodel.rst:1866
msgid "the class namespace is prepared;"
msgstr "클래스 이름 공간이 준비됩니다;"

#: ../Doc/reference/datamodel.rst:1867
msgid "the class body is executed;"
msgstr "클래스 바디가 실행됩니다;"

#: ../Doc/reference/datamodel.rst:1868
msgid "the class object is created."
msgstr "클래스 객체가 만들어집니다."

#: ../Doc/reference/datamodel.rst:1872
msgid "Resolving MRO entries"
msgstr "MRO 항목 결정하기"

#: ../Doc/reference/datamodel.rst:1874
msgid ""
"If a base that appears in class definition is not an instance of "
":class:`type`, then an ``__mro_entries__`` method is searched on it. If "
"found, it is called with the original bases tuple. This method must "
"return a tuple of classes that will be used instead of this base. The "
"tuple may be empty, in such case the original base is ignored."
msgstr ""
"클래스 정의에 나타나는 베이스 클래스가 :class:`type` 의 인스턴스가 아닌 경우, 거기에서 "
"``__mro_entries__`` 메서드를 검색합니다. 발견되면, 원래의 베이스 튜플로 호출됩니다. 이 메서드는 이 베이스 대신에"
" 사용될 클래스의 튜플을 돌려줘야 합니다. 튜플은 비어있을 수 있습니다. 이 경우 원래 베이스는 무시됩니다."

#: ../Doc/reference/datamodel.rst:1882 ../Doc/reference/datamodel.rst:2070
msgid ":pep:`560` - Core support for typing module and generic types"
msgstr ":pep:`560` - typing 모듈과 제네릭 형에 대한 코어 지원"

#: ../Doc/reference/datamodel.rst:1886
msgid "Determining the appropriate metaclass"
msgstr "적절한 메타 클래스 선택하기"

#: ../Doc/reference/datamodel.rst:1890
msgid "The appropriate metaclass for a class definition is determined as follows:"
msgstr "클래스 정의의 적절한 메타 클래스는 다음과 같이 결정됩니다:"

#: ../Doc/reference/datamodel.rst:1892
msgid ""
"if no bases and no explicit metaclass are given, then :func:`type` is "
"used;"
msgstr "베이스와 명시적인 메타 클래스를 주지 않는 경우 :func:`type` 이 사용됩니다;"

#: ../Doc/reference/datamodel.rst:1893
msgid ""
"if an explicit metaclass is given and it is *not* an instance of "
":func:`type`, then it is used directly as the metaclass;"
msgstr "명시적인 메타 클래스가 지정되고, 그것이 :func:`type` 의 인스턴스가 *아니면*, 그것을 메타 클래스로 사용합니다;"

#: ../Doc/reference/datamodel.rst:1895
msgid ""
"if an instance of :func:`type` is given as the explicit metaclass, or "
"bases are defined, then the most derived metaclass is used."
msgstr ""
":func:`type` 의 인스턴스가 명시적인 메타 클래스로 주어지거나, 베이스가 정의되었으면, 가장 많이 파생된 메타 클래스가 "
"사용됩니다."

#: ../Doc/reference/datamodel.rst:1898
msgid ""
"The most derived metaclass is selected from the explicitly specified "
"metaclass (if any) and the metaclasses (i.e. ``type(cls)``) of all "
"specified base classes. The most derived metaclass is one which is a "
"subtype of *all* of these candidate metaclasses. If none of the candidate"
" metaclasses meets that criterion, then the class definition will fail "
"with ``TypeError``."
msgstr ""
"가장 많이 파생된 메타 클래스는 명시적으로 지정된 메타 클래스(있다면)와 지정된 모든 베이스 클래스들의 메타 클래스들(즉, "
"``type(cls)``) 중에서 선택됩니다. 가장 많이 파생된 메타 클래스는 이들 *모두* 의 서브 타입(subtype)입니다. "
"만약 어느 것도 이 조건을 만족하지 못한다면, 클래스 정의는 ``TypeError`` 를 발생시키며 실패합니다."

#: ../Doc/reference/datamodel.rst:1908
msgid "Preparing the class namespace"
msgstr "클래스 이름 공간 준비하기"

#: ../Doc/reference/datamodel.rst:1913
msgid ""
"Once the appropriate metaclass has been identified, then the class "
"namespace is prepared. If the metaclass has a ``__prepare__`` attribute, "
"it is called as ``namespace = metaclass.__prepare__(name, bases, "
"**kwds)`` (where the additional keyword arguments, if any, come from the "
"class definition)."
msgstr ""
"일단 적절한 메타 클래스가 식별되면, 클래스 이름 공간이 준비됩니다. 만약 메타 클래스가 ``__prepare__`` 어트리뷰트를 "
"가지면, ``namespace = metaclass.__prepare__(name, bases, **kwds)`` 같은 식으로 "
"호출됩니다(추가적인 키워드 인자가 있다면 클래스 정의에서 온 것입니다)."

#: ../Doc/reference/datamodel.rst:1918
msgid ""
"If the metaclass has no ``__prepare__`` attribute, then the class "
"namespace is initialised as an empty ordered mapping."
msgstr ""
"만약 메타 클래스에 ``__prepare__`` 어트리뷰트가 없다면, 클래스 이름 공간은 빈 순서 있는 매핑(ordered "
"mapping) 으로 초기화됩니다."

#: ../Doc/reference/datamodel.rst:1923
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - 파이썬 3000 에서의 메타 클래스"

#: ../Doc/reference/datamodel.rst:1924
msgid "Introduced the ``__prepare__`` namespace hook"
msgstr "``__prepare__`` 이름 공간 훅을 도입했습니다"

#: ../Doc/reference/datamodel.rst:1928
msgid "Executing the class body"
msgstr "클래스 바디 실행하기"

#: ../Doc/reference/datamodel.rst:1933
msgid ""
"The class body is executed (approximately) as ``exec(body, globals(), "
"namespace)``. The key difference from a normal call to :func:`exec` is "
"that lexical scoping allows the class body (including any methods) to "
"reference names from the current and outer scopes when the class "
"definition occurs inside a function."
msgstr ""
"클래스 바디는 (대략) ``exec(body, globals(), namespace)`` 과같이 실행됩니다. 일반적인 "
":func:`exec` 호출과 주된 차이점은 클래스 정의가 함수 내부에서 이루어질 때 어휘 스코핑(lexical scoping) 이"
" 클래스 바디(모든 메서드들을 포함해서)로 하여금 현재와 외부 스코프에 있는 이름들을 참조하도록 허락한다는 것입니다."

#: ../Doc/reference/datamodel.rst:1939
msgid ""
"However, even when the class definition occurs inside the function, "
"methods defined inside the class still cannot see names defined at the "
"class scope. Class variables must be accessed through the first parameter"
" of instance or class methods, or through the implicit lexically scoped "
"``__class__`` reference described in the next section."
msgstr ""
"하지만, 클래스 정의가 함수 내부에서 이루어질 때조차도, 클래스 내부에서 정의된 메서드들은 클래스 스코프에서 정의된 이름들을 볼 수"
" 없습니다. 클래스 변수는 인스턴스나 클래스 메서드의 첫 번째 매개변수를 통해 액세스하거나 다음 섹션에서 설명하는 묵시적으로 어휘 "
"스코핑된 ``__class__`` 참조를 통해야 합니다."

#: ../Doc/reference/datamodel.rst:1948
msgid "Creating the class object"
msgstr "클래스 객체 만들기"

#: ../Doc/reference/datamodel.rst:1955
msgid ""
"Once the class namespace has been populated by executing the class body, "
"the class object is created by calling ``metaclass(name, bases, "
"namespace, **kwds)`` (the additional keywords passed here are the same as"
" those passed to ``__prepare__``)."
msgstr ""
"일단 클래스 이름 공간이 클래스 바디를 실행함으로써 채워지면, 클래스 객체가 ``metaclass(name, bases, "
"namespace, **kwds)`` 을 통해 만들어집니다(여기에서 전달되는 추가적인 키워드 인자들은 ``__prepare__`` "
"에 전달된 것들과 같습니다)."

#: ../Doc/reference/datamodel.rst:1960
msgid ""
"This class object is the one that will be referenced by the zero-argument"
" form of :func:`super`. ``__class__`` is an implicit closure reference "
"created by the compiler if any methods in a class body refer to either "
"``__class__`` or ``super``. This allows the zero argument form of "
":func:`super` to correctly identify the class being defined based on "
"lexical scoping, while the class or instance that was used to make the "
"current call is identified based on the first argument passed to the "
"method."
msgstr ""
"이 클래스 객체는 :func:`super` 에 인자를 주지 않는 경우 참조되는 것입니다. ``__class__`` 는 클래스 바디의"
" 메서드들 중 어느 하나라도 ``__class__`` 나 ``super`` 를 참조할 경우 컴파일러에 의해 만들어지는 묵시적인 "
"클로저(closure) 참조입니다. 이것은 인자 없는 형태의 :func:`super` 가 어휘 스코핑 기반으로 현재 정의되고 있는 "
"클래스를 올바르게 찾을 수 있도록 합니다. 반면에 현재의 호출에 사용된 클래스나 인스턴스는 메서드로 전달된 첫 번째 인자에 기초해서"
" 식별됩니다."

#: ../Doc/reference/datamodel.rst:1970
msgid ""
"In CPython 3.6 and later, the ``__class__`` cell is passed to the "
"metaclass as a ``__classcell__`` entry in the class namespace. If "
"present, this must be propagated up to the ``type.__new__`` call in order"
" for the class to be initialised correctly. Failing to do so will result "
"in a :exc:`DeprecationWarning` in Python 3.6, and a :exc:`RuntimeError` "
"in Python 3.8."
msgstr ""
"CPython 3.6 이상에서, ``__class__`` 셀(cell)은 클래스 이름 공간의 ``__classcell__`` "
"엔트리로 메타 클래스에 전달됩니다. 만약 존재한다면, 이것은 클래스가 올바르게 초기화되기 위해 ``type.__new__`` "
"호출까지 거슬러서 전파되어야 합니다. 이렇게 하지 못하면 파이썬 3.6 에서는 "
":exc:`DeprecationWarning`\\으로, 파이썬 3.8 에서는 :exc:`RuntimeError`\\로 이어질 "
"것입니다."

#: ../Doc/reference/datamodel.rst:1977
msgid ""
"When using the default metaclass :class:`type`, or any metaclass that "
"ultimately calls ``type.__new__``, the following additional customisation"
" steps are invoked after creating the class object:"
msgstr ""
"기본 메타 클래스 :class:`type` 을 사용할 때나 다른 메타 클래스가 결국 ``type.__new__`` 를 호출할 때, "
"클래스 객체를 만든 후에, 다음과 같은 추가의 커스터마이제이션 단계가 실행됩니다:"

#: ../Doc/reference/datamodel.rst:1981
msgid ""
"first, ``type.__new__`` collects all of the descriptors in the class "
"namespace that define a :meth:`~object.__set_name__` method;"
msgstr ""
"첫째로, ``type.__new__`` 는 :meth:`~object.__set_name__` 을 정의하는 클래스 이름 공간의 모든"
" 디스크립터들을 수집합니다;"

#: ../Doc/reference/datamodel.rst:1983
msgid ""
"second, all of these ``__set_name__`` methods are called with the class "
"being defined and the assigned name of that particular descriptor;"
msgstr ""
"둘째로, 이렇게 수집된 모든 ``__set_name__`` 을 호출하는데, 정의되고 있는 클래스와 디스크립터에 주어진 이름을 인자로"
" 전달합니다;"

#: ../Doc/reference/datamodel.rst:1985
msgid ""
"finally, the :meth:`~object.__init_subclass__` hook is called on the "
"immediate parent of the new class in its method resolution order."
msgstr ""
"마지막으로, 메서드 결정 순서에 따라 가장 가까운 부모에 대해 :meth:`~object.__init_subclass__` 훅이 "
"호출됩니다."

#: ../Doc/reference/datamodel.rst:1988
msgid ""
"After the class object is created, it is passed to the class decorators "
"included in the class definition (if any) and the resulting object is "
"bound in the local namespace as the defined class."
msgstr ""
"클래스 객체가 만들어진 후에, 클래스 정의에 포함된 클래스 데코레이터들에게 (있다면) 클래스를 전달하고, 그 결과를 클래스가 "
"정의되는 지역 이름 공간에 연결합니다."

#: ../Doc/reference/datamodel.rst:1992
msgid ""
"When a new class is created by ``type.__new__``, the object provided as "
"the namespace parameter is copied to a new ordered mapping and the "
"original object is discarded. The new copy is wrapped in a read-only "
"proxy, which becomes the :attr:`~object.__dict__` attribute of the class "
"object."
msgstr ""
"``type.__new__`` 로 새 클래스가 만들어질 때, 이름 공간 매개변수로 제공되는 객체는 새로 만든 순서 있는 매핑으로 "
"복사되고, 원래의 객체는 버립니다. 새 사본은 읽기 전용 프락시(read-only proxy)로 둘러싸이는데, 이것이 클래스 객체의"
" :attr:`~object.__dict__` 어트리뷰트가 됩니다."

#: ../Doc/reference/datamodel.rst:1999
msgid ":pep:`3135` - New super"
msgstr ":pep:`3135` - 새 super"

#: ../Doc/reference/datamodel.rst:2000
msgid "Describes the implicit ``__class__`` closure reference"
msgstr "묵시적인 \\__class__ 클로저 참조를 설명합니다"

#: ../Doc/reference/datamodel.rst:2004
msgid "Uses for metaclasses"
msgstr "메타 클래스의 용도"

#: ../Doc/reference/datamodel.rst:2006
msgid ""
"The potential uses for metaclasses are boundless. Some ideas that have "
"been explored include enum, logging, interface checking, automatic "
"delegation, automatic property creation, proxies, frameworks, and "
"automatic resource locking/synchronization."
msgstr ""
"메타 클래스의 잠재적인 용도에는 한계가 없습니다. 탐색 된 몇 가지 아이디어들에는 enum, 로깅, 인터페이스 검사, 자동화된 "
"위임(automatic delegation), 자동화된 프로퍼티(properety) 생성, 프락시(proxy), "
"프레임웍(framework), 자동화된 자원 로킹/동기화(automatic resource "
"locking/synchronization) 등이 있습니다."

#: ../Doc/reference/datamodel.rst:2013
msgid "Customizing instance and subclass checks"
msgstr "인스턴스 및 서브 클래스 검사 커스터마이제이션"

#: ../Doc/reference/datamodel.rst:2015
msgid ""
"The following methods are used to override the default behavior of the "
":func:`isinstance` and :func:`issubclass` built-in functions."
msgstr ""
"다음 메서드들은 :func:`isinstance` 와 :func:`issubclass` 내장 함수들의 기본 동작을 재정의하는 데 "
"사용됩니다."

#: ../Doc/reference/datamodel.rst:2018
msgid ""
"In particular, the metaclass :class:`abc.ABCMeta` implements these "
"methods in order to allow the addition of Abstract Base Classes (ABCs) as"
" \"virtual base classes\" to any class or type (including built-in "
"types), including other ABCs."
msgstr ""
"특히, 메타 클래스 :class:`abc.ABCMeta` 는 추상 베이스 클래스(Abstract Base Class, ABC)를 "
"다른 ABC를 포함한 임의의 클래스나 형(내장형을 포함합니다)에 \"가상 베이스 클래스(virtual base class)\"로 "
"추가할 수 있게 하려고 이 메서드들을 구현합니다."

#: ../Doc/reference/datamodel.rst:2025
msgid ""
"Return true if *instance* should be considered a (direct or indirect) "
"instance of *class*. If defined, called to implement "
"``isinstance(instance, class)``."
msgstr ""
"*instance* 가 (직접적이거나 간접적으로) *class* 의 인스턴스로 취급될 수 있으면 참을 돌려줍니다. 만약 정의되면, "
"``isinstance(instance, class)`` 를 구현하기 위해 호출됩니다."

#: ../Doc/reference/datamodel.rst:2032
msgid ""
"Return true if *subclass* should be considered a (direct or indirect) "
"subclass of *class*.  If defined, called to implement "
"``issubclass(subclass, class)``."
msgstr ""
"*subclass* 가 (직접적이거나 간접적으로) *class* 의 서브 클래스로 취급될 수 있으면 참을 돌려줍니다. 만약 "
"정의되면, ``issubclass(subclass, class)`` 를 구현하기 위해 호출됩니다."

#: ../Doc/reference/datamodel.rst:2037
msgid ""
"Note that these methods are looked up on the type (metaclass) of a class."
"  They cannot be defined as class methods in the actual class.  This is "
"consistent with the lookup of special methods that are called on "
"instances, only in this case the instance is itself a class."
msgstr ""
"이 메서드들은 클래스의 형(메타 클래스)에서 조회된다는 것에 주의해야 합니다. 실제 클래스에서 클래스 메서드로 정의될 수 없습니다."
" 이것은 인스턴스에 대해 호출되는 특수 메서드들의 조회와 일관성 있습니다. 이 경우 인스턴스는 클래스 자체다."

#: ../Doc/reference/datamodel.rst:2048
msgid ":pep:`3119` - Introducing Abstract Base Classes"
msgstr ":pep:`3119` - 추상 베이스 클래스의 도입"

#: ../Doc/reference/datamodel.rst:2045
msgid ""
"Includes the specification for customizing :func:`isinstance` and "
":func:`issubclass` behavior through :meth:`~class.__instancecheck__` and "
":meth:`~class.__subclasscheck__`, with motivation for this functionality "
"in the context of adding Abstract Base Classes (see the :mod:`abc` "
"module) to the language."
msgstr ""
":meth:`~class.__instancecheck__` 와 :meth:`~class.__subclasscheck__` 를 통해 "
":func:`isinstance` 와 :func:`issubclass` 의 동작을 커스터마이징하는 데 필요한 규약을 포함하는데, 이"
" 기능의 동기는 언어에 추상 베이스 클래스 (:mod:`abc` 모듈을 보십시오)를 추가하고자 하는 데 있습니다."

#: ../Doc/reference/datamodel.rst:2053
msgid "Emulating generic types"
msgstr "제네릭 형 흉내 내기"

#: ../Doc/reference/datamodel.rst:2055
msgid ""
"One can implement the generic class syntax as specified by :pep:`484` "
"(for example ``List[int]``) by defining a special method:"
msgstr ""
"특수 메서드를 정의함으로써 :pep:`484`\\에서 지정된 제네릭 클래스 문법(예를 들면 ``List[int]``)을 구현할 수 "
"있습니다:"

#: ../Doc/reference/datamodel.rst:2060
msgid ""
"Return an object representing the specialization of a generic class by "
"type arguments found in *key*."
msgstr "*key* 에 있는 형 인자에 의한 제네릭 클래스의 특수화를 나타내는 객체를 돌려줍니다."

#: ../Doc/reference/datamodel.rst:2063
msgid ""
"This method is looked up on the class object itself, and when defined in "
"the class body, this method is implicitly a class method.  Note, this "
"mechanism is primarily reserved for use with static type hints, other "
"usage is discouraged."
msgstr ""
"이 메서드는 클래스 개체 자체에서 조회되며, 클래스 바디에 정의된 경우, 이 메서드는 묵시적으로 클래스 메서드입니다. 이 메커니즘은"
" 주로 정적 형 힌트와 함께 사용하기 위해 예약되어 있습니다. 다른 용도는 권장하지 않습니다."

#: ../Doc/reference/datamodel.rst:2076
msgid "Emulating callable objects"
msgstr "콜러블 객체 흉내 내기"

#: ../Doc/reference/datamodel.rst:2083
msgid ""
"Called when the instance is \"called\" as a function; if this method is "
"defined, ``x(arg1, arg2, ...)`` is a shorthand for ``x.__call__(arg1, "
"arg2, ...)``."
msgstr ""
"인스턴스가 함수처럼 \"호출될\" 때 호출됩니다; 이 메서드가 정의되면, ``x(arg1, arg2, ...)`` 는 "
"``x.__call__(arg1, arg2, ...)`` 의 줄인 표현입니다."

#: ../Doc/reference/datamodel.rst:2090
msgid "Emulating container types"
msgstr "컨테이너형 흉내 내기"

#: ../Doc/reference/datamodel.rst:2092
msgid ""
"The following methods can be defined to implement container objects.  "
"Containers usually are sequences (such as lists or tuples) or mappings "
"(like dictionaries), but can represent other containers as well.  The "
"first set of methods is used either to emulate a sequence or to emulate a"
" mapping; the difference is that for a sequence, the allowable keys "
"should be the integers *k* for which ``0 <= k < N`` where *N* is the "
"length of the sequence, or slice objects, which define a range of items."
"  It is also recommended that mappings provide the methods :meth:`keys`, "
":meth:`values`, :meth:`items`, :meth:`get`, :meth:`clear`, "
":meth:`setdefault`, :meth:`pop`, :meth:`popitem`, :meth:`!copy`, and "
":meth:`update` behaving similar to those for Python's standard dictionary"
" objects.  The :mod:`collections.abc` module provides a "
":class:`~collections.abc.MutableMapping` abstract base class to help "
"create those methods from a base set of :meth:`__getitem__`, "
":meth:`__setitem__`, :meth:`__delitem__`, and :meth:`keys`. Mutable "
"sequences should provide methods :meth:`append`, :meth:`count`, "
":meth:`index`, :meth:`extend`, :meth:`insert`, :meth:`pop`, "
":meth:`remove`, :meth:`reverse` and :meth:`sort`, like Python standard "
"list objects.  Finally, sequence types should implement addition (meaning"
" concatenation) and multiplication (meaning repetition) by defining the "
"methods :meth:`__add__`, :meth:`__radd__`, :meth:`__iadd__`, "
":meth:`__mul__`, :meth:`__rmul__` and :meth:`__imul__` described below; "
"they should not define other numerical operators.  It is recommended that"
" both mappings and sequences implement the :meth:`__contains__` method to"
" allow efficient use of the ``in`` operator; for mappings, ``in`` should "
"search the mapping's keys; for sequences, it should search through the "
"values.  It is further recommended that both mappings and sequences "
"implement the :meth:`__iter__` method to allow efficient iteration "
"through the container; for mappings, :meth:`__iter__` should be the same "
"as :meth:`keys`; for sequences, it should iterate through the values."
msgstr ""
"컨테이너 객체를 구현하기 위해 다음과 같은 메서드들을 정의할 수 있습니다. 컨테이너는 보통 시퀀스(리스트와 튜플 같은)나 "
"매핑(딕셔너리 같은)이지만, 다른 컨테이너들 역시 표현할 수 있습니다. 첫 번째 메서드 집합은 시퀀스나 매핑을 흉내 내는 데 "
"사용됩니다; 차이점은, 시퀀스의 경우 허락되는 키는 *N* 이 시퀀스의 길이일 때 ``0 <= k < N`` 를 만족하는 정수 "
"*k* 와 항목들의 범위를 정의하는 슬라이스 객체만 허락된다는 것입니다. 파이썬의 표준 딕셔너리 객체와 비슷하게 동작하도록, 매핑에"
" 메서드 :meth:`keys`, :meth:`values`, :meth:`items`, :meth:`get`, "
":meth:`clear`, :meth:`setdefault`, :meth:`pop`, :meth:`popitem`, "
":meth:`!copy`, :meth:`update` 를 제공하는 것이 좋습니다. :mod:`collections.abc` 모듈은 "
":class:`~collections.abc.MutableMapping` 추상 베이스 클래스를 제공하는데, 기본 집합 "
":meth:`__getitem__`, :meth:`__setitem__`, :meth:`__delitem__`, "
":meth:`keys` 로 부터 이들 메서드들을 만드는 데 도움을 줍니다. 파이썬의 표준 리스트 객체처럼, 가변 시퀀스는 메서드 "
":meth:`append`, :meth:`count`, :meth:`index`, :meth:`extend`, "
":meth:`insert`, :meth:`pop`, :meth:`remove`, :meth:`reverse`, "
":meth:`sort` 를 제공해야 합니다. 마지막으로 시퀀스 형은 아래에서 설명하는 메서드 :meth:`__add__`, "
":meth:`__radd__`, :meth:`__iadd__`, :meth:`__mul__`, :meth:`__rmul__`, "
":meth:`__imul__` 를 정의해서 더하기(이어붙이기를 뜻합니다)와 곱하기(반복을 뜻합니다)를 구현해야 합니다. 다른 숫자 "
"연산자들은 정의하지 말아야 합니다. ``in`` 연산자의 효과적인 사용을 허락하기 위해, 매핑과 시퀀스 모두 "
":meth:`__contains__` 메서드를 구현하도록 권장합니다. 매핑의 경우, ``in`` 은 매핑의 키를 검색해야 합니다; "
"시퀀스의 경우, 값들을 검색해야 합니다. 컨테이너의 효율적인 이터레이션을 허락하기 위해, 매핑과 시퀀스 모두 "
":meth:`__iter__` 메서드를 구현하는 것 또한 권장합니다; 매핑의 경우, :meth:`__iter__` 는 "
":meth:`keys` 와 같아야 합니다; 시퀀스의 경우, 값들을 이터레이트해야 합니다."

#: ../Doc/reference/datamodel.rst:2127
msgid ""
"Called to implement the built-in function :func:`len`.  Should return the"
" length of the object, an integer ``>=`` 0.  Also, an object that doesn't"
" define a :meth:`__bool__` method and whose :meth:`__len__` method "
"returns zero is considered to be false in a Boolean context."
msgstr ""
"내장함수 :func:`len` 를 구현하기 위해 호출됩니다. 객체의 길이를 돌려줘야 하는데, ``>=`` 0인 정수입니다. 또한 "
":meth:`__bool__` 메서드를 정의하지 않은 객체의 :meth:`__len__` 이 0을 돌려주면 논리 문맥에서 거짓으로 "
"취급됩니다."

#: ../Doc/reference/datamodel.rst:2134
msgid ""
"In CPython, the length is required to be at most :attr:`sys.maxsize`. If "
"the length is larger than :attr:`!sys.maxsize` some features (such as "
":func:`len`) may raise :exc:`OverflowError`.  To prevent raising "
":exc:`!OverflowError` by truth value testing, an object must define a "
":meth:`__bool__` method."
msgstr ""
"CPython 에서, 길이는 최대 :attr:`sys.maxsize` 일 것이 요구됩니다. 만약 길이가 "
":attr:`!sys.maxsize` 보다 크면, 어떤 기능들 (:func:`len` 과 같은)은 "
":exc:`OverflowError` 를 일으킬 수 있습니다. 참 거짓 검사에서 :exc:`!OverflowError` 가 일어나는"
" 것을 막기 위해, 객체는 :meth:`__bool__` 를 정의해야 합니다."

#: ../Doc/reference/datamodel.rst:2143
msgid ""
"Called to implement :func:`operator.length_hint`. Should return an "
"estimated length for the object (which may be greater or less than the "
"actual length). The length must be an integer ``>=`` 0. This method is "
"purely an optimization and is never required for correctness."
msgstr ""
":func:`operator.length_hint` 를 구현하기 위해 호출됩니다. 객체의 추정된 길이를 돌려줘야 합니다(실제 "
"길이보다 크거나 작을 수 있습니다). 길이는 ``>=`` 0인 정수여야 합니다. 이 메서드는 순수하게 최적화를 위한 것이고 결코 "
"올바름이 요구되지는 않습니다."

#: ../Doc/reference/datamodel.rst:2155
msgid ""
"Slicing is done exclusively with the following three methods.  A call "
"like ::"
msgstr "슬라이싱은 전적으로 다음에 나오는 세 메서드들에의해 수행됩니다 ::"

#: ../Doc/reference/datamodel.rst:2159
msgid "is translated to ::"
msgstr "과 같은 호출은 ::"

#: ../Doc/reference/datamodel.rst:2163
msgid "and so forth.  Missing slice items are always filled in with ``None``."
msgstr "로 번역되고, 다른 형태도 마찬가지입니다. 빠진 슬라이스 항목은 항상 ``None`` 으로 채워집니다."

#: ../Doc/reference/datamodel.rst:2168
msgid ""
"Called to implement evaluation of ``self[key]``. For sequence types, the "
"accepted keys should be integers and slice objects.  Note that the "
"special interpretation of negative indexes (if the class wishes to "
"emulate a sequence type) is up to the :meth:`__getitem__` method. If "
"*key* is of an inappropriate type, :exc:`TypeError` may be raised; if of "
"a value outside the set of indexes for the sequence (after any special "
"interpretation of negative values), :exc:`IndexError` should be raised. "
"For mapping types, if *key* is missing (not in the container), "
":exc:`KeyError` should be raised."
msgstr ""
"``self[key]`` 의 값을 구하기 위해 호출됩니다. 시퀀스형의 경우, 정수와 슬라이스 객체만 키로 허용됩니다. 음수 "
"인덱스(만약 클래스가 시퀀스 형을 흉내 내길 원한다면)의 특별한 해석은 :meth:`__getitem__` 메서드에 달려있음에 "
"주의해야 합니다. 만약 *key* 가 적절하지 않은 형인 경우, :exc:`TypeError` 가 발생할 수 있습니다; 만약 "
"시퀀스의 인덱스 범위를 벗어나면(음수에 대한 특별한 해석 후에), :exc:`IndexError` 를 일으켜야 합니다. 매핑 형의 "
"경우, *key* 가 (컨테이너에) 없으면, :exc:`KeyError` 를 일으켜야 합니다."

#: ../Doc/reference/datamodel.rst:2179
msgid ""
":keyword:`for` loops expect that an :exc:`IndexError` will be raised for "
"illegal indexes to allow proper detection of the end of the sequence."
msgstr ""
":keyword:`for` 루프는 시퀀스의 끝을 올바로 감지하기 위해, 잘못된 인덱스에 대해 :exc:`IndexError` 가 "
"일어날 것으로 기대하고 있습니다."

#: ../Doc/reference/datamodel.rst:2185
msgid ""
"Called to implement assignment to ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the"
" objects support changes to the values for keys, or if new keys can be "
"added, or for sequences if elements can be replaced.  The same exceptions"
" should be raised for improper *key* values as for the "
":meth:`__getitem__` method."
msgstr ""
"``self[key]`` 로의 대입을 구현하기 위해 호출됩니다. :meth:`__getitem__` 과 같은 주의가 필요합니다. "
"매핑의 경우에는, 객체가 키에 대해 값의 변경이나 새 키의 추가를 허락할 경우, 시퀀스의 경우는 항목이 교체될 수 있을 때만 "
"구현되어야 합니다. 잘못된 *key* 값의 경우는 :meth:`__getitem__` 에서와 같은 예외를 일으켜야 합니다."

#: ../Doc/reference/datamodel.rst:2194
msgid ""
"Called to implement deletion of ``self[key]``.  Same note as for "
":meth:`__getitem__`.  This should only be implemented for mappings if the"
" objects support removal of keys, or for sequences if elements can be "
"removed from the sequence.  The same exceptions should be raised for "
"improper *key* values as for the :meth:`__getitem__` method."
msgstr ""
"``self[key]`` 의 삭제를 구현하기 위해 호출됩니다. :meth:`__getitem__` 과 같은 주의가 필요합니다. "
"매핑의 경우에는, 객체가 키의 삭제를 허락할 경우, 시퀀스의 경우는 항목이 시퀀스로부터 제거될 수 있을 때만 구현되어야 합니다. "
"잘못된 *key* 값의 경우는 :meth:`__getitem__` 에서와 같은 예외를 일으켜야 합니다."

#: ../Doc/reference/datamodel.rst:2203
msgid ""
"Called by :class:`dict`\\ .\\ :meth:`__getitem__` to implement "
"``self[key]`` for dict subclasses when key is not in the dictionary."
msgstr ""
":class:`dict`\\ .\\ :meth:`__getitem__` 이 dict 서브 클래스에서 키가 딕셔너리에 없으면 "
"``self[key]`` 를 구현하기 위해 호출합니다."

#: ../Doc/reference/datamodel.rst:2209
msgid ""
"This method is called when an iterator is required for a container. This "
"method should return a new iterator object that can iterate over all the "
"objects in the container.  For mappings, it should iterate over the keys "
"of the container."
msgstr ""
"컨테이너의 이터레이터가 필요할 때 이 메서드가 호출됩니다. 이 메서드는 컨테이너에 포함된 모든 객체를 이터레이트할 수 있는 "
"이터레이터 객체를 돌려줘야 합니다. 매핑의 경우, 컨테이너의 키를 이터레이트해야 합니다."

#: ../Doc/reference/datamodel.rst:2213
msgid ""
"Iterator objects also need to implement this method; they are required to"
" return themselves.  For more information on iterator objects, see "
":ref:`typeiter`."
msgstr ""
"이터레이터 객체 역시 이 메서드를 구현할 필요가 있습니다; 자기 자신을 돌려줘야 합니다. 이터레이터 객체에 대한 추가의 정보는 "
":ref:`typeiter` 에 있습니다."

#: ../Doc/reference/datamodel.rst:2219
msgid ""
"Called (if present) by the :func:`reversed` built-in to implement reverse"
" iteration.  It should return a new iterator object that iterates over "
"all the objects in the container in reverse order."
msgstr ""
":func:`reversed` 내장 함수가 역 이터레이션(reverse iteration)을 구현하기 위해 (있다면) 호출합니다. "
"컨테이너에 있는 객체들을 역 순으로 탐색하는 새 이터레이터 객체를 돌려줘야 합니다."

#: ../Doc/reference/datamodel.rst:2223
msgid ""
"If the :meth:`__reversed__` method is not provided, the :func:`reversed` "
"built-in will fall back to using the sequence protocol (:meth:`__len__` "
"and :meth:`__getitem__`).  Objects that support the sequence protocol "
"should only provide :meth:`__reversed__` if they can provide an "
"implementation that is more efficient than the one provided by "
":func:`reversed`."
msgstr ""
":meth:`__reversed__` 메서드가 제공되지 않으면, :func:`reversed` 내장함수는 시퀀스 "
"프로토콜(:meth:`__len__` 과 :meth:`__getitem__`)을 대안으로 사용합니다. 시퀀스 프로토콜을 지원하는 "
"객체들은 :func:`reversed` 가 제공하는 것보다 더 효율적인 구현을 제공할 수 있을 때만 "
":meth:`__reversed__` 를 제공해야 합니다."

#: ../Doc/reference/datamodel.rst:2230
msgid ""
"The membership test operators (:keyword:`in` and :keyword:`not in`) are "
"normally implemented as an iteration through a sequence.  However, "
"container objects can supply the following special method with a more "
"efficient implementation, which also does not require the object be a "
"sequence."
msgstr ""
"멤버십 검사 연산자들(:keyword:`in` 과 :keyword:`not in`) 은 보통 시퀀스에 대한 이터레이션으로 "
"구현됩니다. 하지만, 컨테이너 객체는 더 효율적인 구현을 다음과 같은 특수 메서드를 통해 제공할 수 있습니다. 이 경우 객체는 "
"시퀀스일 필요도 없습니다."

#: ../Doc/reference/datamodel.rst:2237
msgid ""
"Called to implement membership test operators.  Should return true if "
"*item* is in *self*, false otherwise.  For mapping objects, this should "
"consider the keys of the mapping rather than the values or the key-item "
"pairs."
msgstr ""
"멤버십 검사 연산자를 구현하기 위해 호출됩니다. *item* 이 *self* 에 있으면 참을, 그렇지 않으면 거짓을 돌려줘야 "
"합니다. 매핑 객체의 경우, 키-값 쌍이 아니라 매핑의 키가 고려되어야 합니다."

#: ../Doc/reference/datamodel.rst:2241
msgid ""
"For objects that don't define :meth:`__contains__`, the membership test "
"first tries iteration via :meth:`__iter__`, then the old sequence "
"iteration protocol via :meth:`__getitem__`, see :ref:`this section in the"
" language reference <membership-test-details>`."
msgstr ""
":meth:`__contains__` 를 정의하지 않는 객체의 경우, 멤버십 검사는 먼저 :meth:`__iter__` 를 통한 "
"이터레이션을 시도한 후, :meth:`__getitem__` 을 통한 낡은 시퀀스 이터레이션 프로토콜을 시도합니다. :ref"
":`membership-test-details` 섹션을 참고하십시오."

#: ../Doc/reference/datamodel.rst:2250
msgid "Emulating numeric types"
msgstr "숫자 형 흉내 내기"

#: ../Doc/reference/datamodel.rst:2252
msgid ""
"The following methods can be defined to emulate numeric objects. Methods "
"corresponding to operations that are not supported by the particular kind"
" of number implemented (e.g., bitwise operations for non-integral "
"numbers) should be left undefined."
msgstr ""
"숫자 형을 흉내 내기 위해 다음과 같은 메서드들을 정의할 수 있습니다. 구현되는 특별한 종류의 숫자에 의해 지원되지 않는 "
"연산들(예를 들어, 정수가 아닌 숫자들에 대한 비트 연산들)에 대응하는 메서드들을 정의되지 않은 채로 남겨두어야 합니다."

#: ../Doc/reference/datamodel.rst:2278
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``).  For instance,"
" to evaluate the expression ``x + y``, where *x* is an instance of a "
"class that has an :meth:`__add__` method, ``x.__add__(y)`` is called.  "
"The :meth:`__divmod__` method should be the equivalent to using "
":meth:`__floordiv__` and :meth:`__mod__`; it should not be related to "
":meth:`__truediv__`.  Note that :meth:`__pow__` should be defined to "
"accept an optional third argument if the ternary version of the built-in "
":func:`pow` function is to be supported."
msgstr ""
"이 메서드들은 이항 산술 연산들(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, "
":func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, "
"``|``)을 구현하기 위해 호출됩니다. 예를 들어, *x* 가 :meth:`__add__` 메서드를 가진 클래스의 인스턴스일 때,"
" 표현식 ``x + y`` 의 값을 구하기 위해, ``x.__add__(y)`` 가 호출됩니다. :meth:`__divmod__` "
"메서드는 :meth:`__floordiv__` 와 :meth:`__mod__` 를 사용하는 것과 동등해야 합니다; "
":meth:`__truediv__` 와 연관되지 않아야 합니다; 내장 :func:`pow` 함수의 삼 항 버전이 지원되기 위해서는,"
" :meth:`__pow__` 메서드가 생략할 수 있는 세 번째 인자를 받도록 정의되어야 함에 주의해야 합니다."

#: ../Doc/reference/datamodel.rst:2289
msgid ""
"If one of those methods does not support the operation with the supplied "
"arguments, it should return ``NotImplemented``."
msgstr "만약 이 메서드들 중 하나가 제공된 인자에 대해 연산을 지원하지 않으면, ``NotImplemented`` 를 돌려줘야 합니다."

#: ../Doc/reference/datamodel.rst:2312
msgid ""
"These methods are called to implement the binary arithmetic operations "
"(``+``, ``-``, ``*``, ``@``, ``/``, ``//``, ``%``, :func:`divmod`, "
":func:`pow`, ``**``, ``<<``, ``>>``, ``&``, ``^``, ``|``) with reflected "
"(swapped) operands.  These functions are only called if the left operand "
"does not support the corresponding operation [#]_ and the operands are of"
" different types. [#]_ For instance, to evaluate the expression ``x - "
"y``, where *y* is an instance of a class that has an :meth:`__rsub__` "
"method, ``y.__rsub__(x)`` is called if ``x.__sub__(y)`` returns "
"*NotImplemented*."
msgstr ""
"이 메서드들은 뒤집힌 피연산자들에 대해 이항 산술 연산들(``+``, ``-``, ``*``, ``@``, ``/``, "
"``//``, ``%``, :func:`divmod`, :func:`pow`, ``**``, ``<<``, ``>>``, "
"``&``, ``^``, ``|``)을 구현하기 위해 호출됩니다. 이 함수들은 왼쪽의 피연산자가 해당 연산을 지원하지 않고 "
"[#]_, 피연산자들이 서로 다른 형일 때만 호출됩니다. [#]_ 예를 들어, 표현식 ``x - y`` 의 값을 구하려고 할 때, "
"*y* 가 :meth:`__rsub__` 를 갖는 클래스의 인스턴스이고, ``x.__sub__(y)`` 가 "
"*NotImplemented* 를 돌려주면 ``y.__rsub__(x)`` 가 호출됩니다."

#: ../Doc/reference/datamodel.rst:2323
msgid ""
"Note that ternary :func:`pow` will not try calling :meth:`__rpow__` (the "
"coercion rules would become too complicated)."
msgstr ""
"삼 항 :func:`pow` 는 :meth:`__rpow__` 를 호출하려고 시도하지 않음에 주의해야 합니다 (그렇게 하려면 코어션"
" 규칙이 너무 복잡해집니다)."

#: ../Doc/reference/datamodel.rst:2328
msgid ""
"If the right operand's type is a subclass of the left operand's type and "
"that subclass provides the reflected method for the operation, this "
"method will be called before the left operand's non-reflected method.  "
"This behavior allows subclasses to override their ancestors' operations."
msgstr ""
"만약 오른쪽 피연산자의 형이 왼쪽 피연산자의 형의 서브 클래스이고, 그 서브 클래스가 연산의 뒤집힌 메서드들 제공하면, 이 메서드가"
" 왼쪽 연산자의 뒤집히지 않은 메서드보다 먼저 호출됩니다. 이 동작은 서브 클래스가 조상들의 연산을 재정의할 수 있도록 합니다."

#: ../Doc/reference/datamodel.rst:2348
msgid ""
"These methods are called to implement the augmented arithmetic "
"assignments (``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``, "
"``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``).  These methods should"
" attempt to do the operation in-place (modifying *self*) and return the "
"result (which could be, but does not have to be, *self*).  If a specific "
"method is not defined, the augmented assignment falls back to the normal "
"methods.  For instance, if *x* is an instance of a class with an "
":meth:`__iadd__` method, ``x += y`` is equivalent to ``x = "
"x.__iadd__(y)`` . Otherwise, ``x.__add__(y)`` and ``y.__radd__(x)`` are "
"considered, as with the evaluation of ``x + y``. In certain situations, "
"augmented assignment can result in unexpected errors (see :ref:`faq-"
"augmented-assignment-tuple-error`), but this behavior is in fact part of "
"the data model."
msgstr ""
"이 메서드들은 증분 산술 대입(``+=``, ``-=``, ``*=``, ``@=``, ``/=``, ``//=``, ``%=``,"
" ``**=``, ``<<=``, ``>>=``, ``&=``, ``^=``, ``|=``)을 구현하기 위해 호출됩니다. 이 "
"메서드는 연산을 제자리에서(*self* 를 수정해서) 하도록 시도해야 하고, 결과(반드시 그래야 하는 것은 아니지만 *self* 일"
" 수 있습니다)를 돌려줘야 합니다. 만약 특정 메서드가 정의되지 않으면, 중분 대입은 일반적인 메서드들을 대신 사용합니다. 예를 "
"들어, *x* 가 :meth:`__iadd__` 메서드를 갖는 클래스의 인스턴스면, ``x += y`` 는 ``x = "
"x.__iadd__(y)`` 와 동등합니다. 그렇지 않으면, ``x + y`` 의 값을 구할 때처럼, ``x.__add__(y)``"
" 와 ``y.__radd__(x)`` 가 고려됩니다. 어떤 상황에서, 증분 대입은 예상치 못한 에러로 이어질 수 있습니다. "
"(:ref:`faq-augmented-assignment-tuple-error` 를 보십시오). 하지만 이 동작은 사실 데이터 "
"모델의 일부입니다."

#: ../Doc/reference/datamodel.rst:2369
msgid ""
"Called to implement the unary arithmetic operations (``-``, ``+``, "
":func:`abs` and ``~``)."
msgstr "일 항 산술 연산(``-``, ``+``, :func:`abs`, ``~``)을 구현하기 위해 호출됩니다."

#: ../Doc/reference/datamodel.rst:2382
msgid ""
"Called to implement the built-in functions :func:`complex`, :func:`int` "
"and :func:`float`.  Should return a value of the appropriate type."
msgstr ""
"내장 함수 :func:`complex`, :func:`int`, :func:`float`\\를 구현하기 위해 호출됩니다. 적절한 "
"형의 값을 돌려줘야 합니다."

#: ../Doc/reference/datamodel.rst:2389
msgid ""
"Called to implement :func:`operator.index`, and whenever Python needs to "
"losslessly convert the numeric object to an integer object (such as in "
"slicing, or in the built-in :func:`bin`, :func:`hex` and :func:`oct` "
"functions). Presence of this method indicates that the numeric object is "
"an integer type.  Must return an integer."
msgstr ""
":func:`operator.index` 를 구현하기 위해 호출되고, 파이썬이 숫자 객체를 정수 객체로 손실 없이 변환해야 할 "
"때(슬라이싱이나 내장 :func:`bin`, :func:`hex`, :func:`oct` 함수들에서와같이)마다 호출됩니다. 이 "
"메서드의 존재는 숫자 객체가 정수 형임을 가리킵니다. 반드시 정수를 돌려줘야 합니다."

#: ../Doc/reference/datamodel.rst:2397
msgid ""
"In order to have a coherent integer type class, when :meth:`__index__` is"
" defined :meth:`__int__` should also be defined, and both should return "
"the same value."
msgstr ""
"일관성 있는 정수형 클래스를 가지려고, :meth:`__index__` 가 정의될 때는 :meth:`__int__` 역시 정의되어야"
" 하고, 둘 다 같은 값을 돌려줘야 합니다."

#: ../Doc/reference/datamodel.rst:2409
msgid ""
"Called to implement the built-in function :func:`round` and :mod:`math` "
"functions :func:`~math.trunc`, :func:`~math.floor` and "
":func:`~math.ceil`. Unless *ndigits* is passed to :meth:`!__round__` all "
"these methods should return the value of the object truncated to an "
":class:`~numbers.Integral` (typically an :class:`int`)."
msgstr ""
"내장 함수 :func:`round`\\와 :mod:`math` 함수 :func:`~math.trunc`, "
":func:`~math.floor`, :func:`~math.ceil` 을 구현하기 위해 호출됩니다. *ndigits* 가 "
":meth:`!__round__` 로 전달되지 않는 한, 이 메서드들은 모두 :class:`~numbers.Integral` (보통"
" :class:`int`) 로 잘린 객체의 값을 돌려줘야 합니다."

#: ../Doc/reference/datamodel.rst:2415
msgid ""
"If :meth:`__int__` is not defined then the built-in function :func:`int` "
"falls back to :meth:`__trunc__`."
msgstr ""
":meth:`__int__` 가 정의되어 있지 않으면, 내장 함수 :func:`int` 는 :meth:`__trunc__` 를 "
"사용합니다."

#: ../Doc/reference/datamodel.rst:2422
msgid "With Statement Context Managers"
msgstr "with 문 컨텍스트 관리자"

#: ../Doc/reference/datamodel.rst:2424
msgid ""
"A :dfn:`context manager` is an object that defines the runtime context to"
" be established when executing a :keyword:`with` statement. The context "
"manager handles the entry into, and the exit from, the desired runtime "
"context for the execution of the block of code.  Context managers are "
"normally invoked using the :keyword:`!with` statement (described in "
"section :ref:`with`), but can also be used by directly invoking their "
"methods."
msgstr ""
":dfn:`컨텍스트 관리자 (context manager)` 는 :keyword:`with` 문을 실행할 때 자리 잡는 실행 "
"컨텍스트(context)를 정의하는 객체입니다. 코드 블록의 실행을 위해, 컨텍스트 관리자는 원하는 실행시간 컨텍스트로의 진입과 "
"탈출을 처리합니다. 컨텍스트 관리자는 보통 :keyword:`!with` 문(:ref:`with` 섹션에서 설명합니다)으로 "
"시작되지만, 그들의 메서드를 호출해서 직접 사용할 수도 있습니다."

#: ../Doc/reference/datamodel.rst:2435
msgid ""
"Typical uses of context managers include saving and restoring various "
"kinds of global state, locking and unlocking resources, closing opened "
"files, etc."
msgstr ""
"컨텍스트 관리자의 전형적인 용도에는 다양한 종류의 전역 상태(global state)를 보관하고 복구하는 것, 자원을 "
"로킹(locking)하고 언로킹(unlocking)하는 것, 열린 파일을 닫는 것 등이 있습니다."

#: ../Doc/reference/datamodel.rst:2438
msgid "For more information on context managers, see :ref:`typecontextmanager`."
msgstr "컨텍스트 관리자에 대한 더 자세한 정보는 :ref:`typecontextmanager` 에 나옵니다."

#: ../Doc/reference/datamodel.rst:2443
msgid ""
"Enter the runtime context related to this object. The :keyword:`with` "
"statement will bind this method's return value to the target(s) specified"
" in the :keyword:`!as` clause of the statement, if any."
msgstr ""
"이 객체와 연관된 실행시간 컨텍스트에 진입합니다. :keyword:`with` 문은 :keyword:`!as` 절로 지정된 대상이 "
"있다면, 이 메서드의 반환 값을 연결합니다."

#: ../Doc/reference/datamodel.rst:2450
msgid ""
"Exit the runtime context related to this object. The parameters describe "
"the exception that caused the context to be exited. If the context was "
"exited without an exception, all three arguments will be :const:`None`."
msgstr ""
"이 객체와 연관된 실행시간 컨텍스트를 종료합니다. 매개변수들은 컨텍스트에서 벗어나게 만든 예외를 기술합니다. 만약 컨텍스트가 예외 "
"없이 종료한다면, 세 인자 모두 :const:`None` 이 됩니다."

#: ../Doc/reference/datamodel.rst:2454
msgid ""
"If an exception is supplied, and the method wishes to suppress the "
"exception (i.e., prevent it from being propagated), it should return a "
"true value. Otherwise, the exception will be processed normally upon exit"
" from this method."
msgstr ""
"만약 예외가 제공되고, 메서드가 예외를 중지시키고 싶으면 (즉 확산하는 것을 막으려면) 참(true)을 돌려줘야 합니다. 그렇지 "
"않으면 예외는 이 메서드가 종료한 후에 계속 진행됩니다."

#: ../Doc/reference/datamodel.rst:2458
msgid ""
"Note that :meth:`__exit__` methods should not reraise the passed-in "
"exception; this is the caller's responsibility."
msgstr ""
":meth:`__exit__` 메서드가 전달된 예외를 다시 일으키지(reraise) 않도록 주의해야 합니다; 이것은 "
"호출자(caller)의 책임입니다."

#: ../Doc/reference/datamodel.rst:2465
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 문"

#: ../Doc/reference/datamodel.rst:2465
msgid ""
"The specification, background, and examples for the Python "
":keyword:`with` statement."
msgstr "파이썬 :keyword:`with` 문에 대한 규격, 배경, 예."

#: ../Doc/reference/datamodel.rst:2472
msgid "Special method lookup"
msgstr "특수 메서드 조회"

#: ../Doc/reference/datamodel.rst:2474
msgid ""
"For custom classes, implicit invocations of special methods are only "
"guaranteed to work correctly if defined on an object's type, not in the "
"object's instance dictionary.  That behaviour is the reason why the "
"following code raises an exception::"
msgstr ""
"사용자 정의 클래스의 경우, 묵시적인 특수 메서드의 호출은 객체의 인스턴스 딕셔너리가 아닌 객체의 형에 정의되어 있을 때만 올바르게"
" 동작함이 보장됩니다. 이런 동작은 다음과 같은 코드가 예외를 일으키는 원인입니다:"

#: ../Doc/reference/datamodel.rst:2489
msgid ""
"The rationale behind this behaviour lies with a number of special methods"
" such as :meth:`__hash__` and :meth:`__repr__` that are implemented by "
"all objects, including type objects. If the implicit lookup of these "
"methods used the conventional lookup process, they would fail when "
"invoked on the type object itself::"
msgstr ""
"이런 동작의 배경에 깔린 논리는, 모든 객체(형 객체를 포함해서)에 의해 구현되는 :meth:`__hash__` 나 "
":meth:`__repr__` 과 같은 많은 특수 메서드들과 관련이 있습니다. 만약 이 메서드들에 대한 묵시적인 조회가 일반적인 "
"조회 프로세스를 거친다면, 형 객체 자체에 대해 호출되었을 때 실패하게 됩니다:"

#: ../Doc/reference/datamodel.rst:2502
msgid ""
"Incorrectly attempting to invoke an unbound method of a class in this way"
" is sometimes referred to as 'metaclass confusion', and is avoided by "
"bypassing the instance when looking up special methods::"
msgstr ""
"클래스의 연결되지 않은 메서드를 호출하려는 이런 식의 잘못된 시도는 종종 '메타 클래스 혼란(metaclass confusion)'"
" 이라고 불리고, 특수 메서드를 조회할 때 인스턴스를 우회하는 방법으로 피할 수 있습니다."

#: ../Doc/reference/datamodel.rst:2511
msgid ""
"In addition to bypassing any instance attributes in the interest of "
"correctness, implicit special method lookup generally also bypasses the "
":meth:`__getattribute__` method even of the object's metaclass::"
msgstr ""
"올바름을 추구하기 위해 인스턴스 어트리뷰트들을 우회하는 것에 더해, 묵시적인 특수 메서드 조회는 객체의 메타 클래스의 "
":meth:`__getattribute__` 메서드 조차도 우회합니다::"

#: ../Doc/reference/datamodel.rst:2537
msgid ""
"Bypassing the :meth:`__getattribute__` machinery in this fashion provides"
" significant scope for speed optimisations within the interpreter, at the"
" cost of some flexibility in the handling of special methods (the special"
" method *must* be set on the class object itself in order to be "
"consistently invoked by the interpreter)."
msgstr ""
"이런 식으로 :meth:`__getattribute__` 절차를 우회하는 것은 특수 메서드 처리의 유연함을 일부 포기하는 대신(특수"
" 메서드가 인터프리터에 의해 일관성 있게 호출되기 위해서는 *반드시* 클래스 객체에 설정되어야 합니다), 인터프리터 내부에서의 속도"
" 최적화를 위한 상당한 기회를 제공합니다."

#: ../Doc/reference/datamodel.rst:2548
msgid "Coroutines"
msgstr "코루틴(Coroutines)"

#: ../Doc/reference/datamodel.rst:2552
msgid "Awaitable Objects"
msgstr "어웨이터블 객체(Awaitable Objects)"

#: ../Doc/reference/datamodel.rst:2554
msgid ""
"An :term:`awaitable` object generally implements an :meth:`__await__` "
"method. :term:`Coroutine` objects returned from :keyword:`async def` "
"functions are awaitable."
msgstr ""
":term:`어웨이터블 <awaitable>` 객체는 일반적으로 :meth:`__await__` 메서드를 구현합니다. "
":keyword:`async def` 함수가 돌려주는 :term:`코루틴 <Coroutine>` 객체는 어웨이터블입니다."

#: ../Doc/reference/datamodel.rst:2560
msgid ""
"The :term:`generator iterator` objects returned from generators decorated"
" with :func:`types.coroutine` or :func:`asyncio.coroutine` are also "
"awaitable, but they do not implement :meth:`__await__`."
msgstr ""
":func:`types.coroutine` 이나 :func:`asyncio.coroutine` 로 데코레이션된 제너레이터가 돌려주는"
" :term:`제너레이터 이터레이터 <generator iterator>` 객체 또한 어웨이터블이지만 "
":meth:`__await__` 를 구현하지 않습니다."

#: ../Doc/reference/datamodel.rst:2566
msgid ""
"Must return an :term:`iterator`.  Should be used to implement "
":term:`awaitable` objects.  For instance, :class:`asyncio.Future` "
"implements this method to be compatible with the :keyword:`await` "
"expression."
msgstr ""
":term:`이터레이터 <iterator>` 를 돌려줘야 합니다. :term:`어웨이터블 <awaitable>` 객체를 구현하기 "
"위해 사용되어야 합니다. 예를 들어, :class:`asyncio.Future` 는 :keyword:`await` 표현식과 호환되기"
" 위해 이 메서드를 구현합니다."

#: ../Doc/reference/datamodel.rst:2572
msgid ":pep:`492` for additional information about awaitable objects."
msgstr ":pep:`492` 가 어웨이터블 객체에 대한 더 자세한 정보를 포함하고 있습니다."

#: ../Doc/reference/datamodel.rst:2578
msgid "Coroutine Objects"
msgstr "코루틴 객체(Coroutine Objects)"

#: ../Doc/reference/datamodel.rst:2580
msgid ""
":term:`Coroutine` objects are :term:`awaitable` objects. A coroutine's "
"execution can be controlled by calling :meth:`__await__` and iterating "
"over the result.  When the coroutine has finished executing and returns, "
"the iterator raises :exc:`StopIteration`, and the exception's "
":attr:`~StopIteration.value` attribute holds the return value.  If the "
"coroutine raises an exception, it is propagated by the iterator.  "
"Coroutines should not directly raise unhandled :exc:`StopIteration` "
"exceptions."
msgstr ""
":term:`코루틴 <Coroutine>` 객체는 :term:`어웨이터블 <awaitable>` 객체입니다. 코루틴의 실행은 "
":meth:`__await__` 를 호출하고 그 결과를 이터레이트하는 방법으로 제어될 수 있습니다. 코루틴이 실행을 완료하고 복귀할"
" 때, 이터레이터는 :exc:`StopIteration` 을 일으키고, 예외의 :attr:`~StopIteration.value` "
"어트리뷰트가 반환 값을 갖고 있습니다. 만약 코루틴이 예외를 일으키면, 이터레이터에 의해 퍼집니다. 코루틴이 직접 잡히지 않은 "
":exc:`StopIteration` 예외를 일으키지는 말아야 합니다."

#: ../Doc/reference/datamodel.rst:2588
msgid ""
"Coroutines also have the methods listed below, which are analogous to "
"those of generators (see :ref:`generator-methods`).  However, unlike "
"generators, coroutines do not directly support iteration."
msgstr ""
"코루틴은 다음에 나열하는 메서드들 또한 갖고 있는데, 제너레이터(:ref:`generator-methods` 를 보십시오)의 것들과"
" 닮았습니다. 하지만, 제너레이터와는 달리, 코루틴은 이터레이션을 직접 지원하지는 않습니다."

#: ../Doc/reference/datamodel.rst:2592
msgid "It is a :exc:`RuntimeError` to await on a coroutine more than once."
msgstr "코루틴을 두 번 await 하면 :exc:`RuntimeError` 를 일으킵니다."

#: ../Doc/reference/datamodel.rst:2598
msgid ""
"Starts or resumes execution of the coroutine.  If *value* is ``None``, "
"this is equivalent to advancing the iterator returned by "
":meth:`__await__`.  If *value* is not ``None``, this method delegates to "
"the :meth:`~generator.send` method of the iterator that caused the "
"coroutine to suspend.  The result (return value, :exc:`StopIteration`, or"
" other exception) is the same as when iterating over the "
":meth:`__await__` return value, described above."
msgstr ""
"코루틴의 실행을 시작하거나 재개합니다. *value* 가 ``None`` 이면, :meth:`__await__` 가 돌려준 "
"이터레이터를 전진시키는 것과 같습니다. *value* 가 ``None`` 이 아니면, 이 메서드는 코루틴이 일시 중지되도록 한 "
"이터레이터의 :meth:`~generator.send` 메서드로 위임합니다. 결과(반환 값, :exc:`StopIteration` "
"이나 다른 예외)는 위에서 설명한 :meth:`__await__` 의 반환 값을 이터레이트할 때와 같습니다."

#: ../Doc/reference/datamodel.rst:2608
msgid ""
"Raises the specified exception in the coroutine.  This method delegates "
"to the :meth:`~generator.throw` method of the iterator that caused the "
"coroutine to suspend, if it has such a method.  Otherwise, the exception "
"is raised at the suspension point.  The result (return value, "
":exc:`StopIteration`, or other exception) is the same as when iterating "
"over the :meth:`__await__` return value, described above.  If the "
"exception is not caught in the coroutine, it propagates back to the "
"caller."
msgstr ""
"코루틴에서 지정한 예외가 발생하도록 합니다. 이 메서드는 코루틴이 일시 중지되도록 한 이터레이터의 "
":meth:`~generator.throw` 메서드로 위임합니다(그런 메서드를 가지는 경우). 그렇지 않으면, 일시 중지지점에서 "
"예외가 발생합니다. 결과(반환 값, :exc:`StopIteration` 이나 다른 예외)는 위에서 설명한 "
":meth:`__await__` 의 반환 값을 이터레이트할 때와 같습니다. 만약 예외가 코루틴에서 잡히지 않는다면 호출자에게 되돌아"
" 전파됩니다."

#: ../Doc/reference/datamodel.rst:2619
msgid ""
"Causes the coroutine to clean itself up and exit.  If the coroutine is "
"suspended, this method first delegates to the :meth:`~generator.close` "
"method of the iterator that caused the coroutine to suspend, if it has "
"such a method.  Then it raises :exc:`GeneratorExit` at the suspension "
"point, causing the coroutine to immediately clean itself up. Finally, the"
" coroutine is marked as having finished executing, even if it was never "
"started."
msgstr ""
"코루틴이 자신을 정리하고 종료하도록 만듭니다. 만약 코루틴이 일시 중지 중이면, 이 메서드는 먼저 코루틴이 일시 중지되도록 한 "
"이터레이터의 :meth:`~generator.close` 메서드로 위임합니다(그런 메서드를 가지는 경우). 그런 다음 일시 "
"중지지점에서 :exc:`GeneratorExit` 를 발생시키는데, 코루틴이 즉시 자신을 정리하도록 만듭니다. 마지막으로 코루틴에 "
"실행을 종료했다고 표시하는데, 아직 시작하지조차 않았을 때도 그렇다."

#: ../Doc/reference/datamodel.rst:2627
msgid ""
"Coroutine objects are automatically closed using the above process when "
"they are about to be destroyed."
msgstr "코루틴 객체가 파괴될 때는 위의 프로세스에 따라 자동으로 닫힙니다(closed)."

#: ../Doc/reference/datamodel.rst:2633
msgid "Asynchronous Iterators"
msgstr "비동기 이터레이터(Asynchronous Iterators)"

#: ../Doc/reference/datamodel.rst:2635
msgid ""
"An *asynchronous iterator* can call asynchronous code in its "
"``__anext__`` method."
msgstr "*비동기 이터레이터* 는 자신의 ``__anext__`` 메서드에서 비동기 코드를 호출할 수 있습니다."

#: ../Doc/reference/datamodel.rst:2638
msgid "Asynchronous iterators can be used in an :keyword:`async for` statement."
msgstr "비동기 이터레이터는 :keyword:`async for` 문에서 사용될 수 있습니다."

#: ../Doc/reference/datamodel.rst:2642
msgid "Must return an *asynchronous iterator* object."
msgstr "*비동기 이터레이터* 객체를 돌려줘야 합니다."

#: ../Doc/reference/datamodel.rst:2646
msgid ""
"Must return an *awaitable* resulting in a next value of the iterator.  "
"Should raise a :exc:`StopAsyncIteration` error when the iteration is "
"over."
msgstr ""
"이터레이터의 다음 값을 주는 *어웨이터블* 을 돌려줘야 합니다. 이터레이션이 끝나면 :exc:`StopAsyncIteration` "
"에러를 일으켜야 합니다."

#: ../Doc/reference/datamodel.rst:2649
msgid "An example of an asynchronous iterable object::"
msgstr "비동기 이터러블 객체의 예::"

#: ../Doc/reference/datamodel.rst:2666
msgid ""
"Prior to Python 3.7, ``__aiter__`` could return an *awaitable* that would"
" resolve to an :term:`asynchronous iterator <asynchronous iterator>`."
msgstr ""
"파이썬 3.7 이전에, ``__aiter__`` 는 :term:`비동기 이터레이터 <asynchronous iterator>` 로 "
"결정될 *어웨이터블* 을 반환 할 수 있었습니다."

#: ../Doc/reference/datamodel.rst:2671
msgid ""
"Starting with Python 3.7, ``__aiter__`` must return an asynchronous "
"iterator object.  Returning anything else will result in a "
":exc:`TypeError` error."
msgstr ""
"파이썬 3.7부터, ``__aiter__`` 는 반드시 비동기 이터레이터 객체를 돌려줘야 합니다. 다른 것을 돌려주면 "
":exc:`TypeError` 에러가 발생합니다."

#: ../Doc/reference/datamodel.rst:2679
msgid "Asynchronous Context Managers"
msgstr "비동기 컨텍스트 관리자"

#: ../Doc/reference/datamodel.rst:2681
msgid ""
"An *asynchronous context manager* is a *context manager* that is able to "
"suspend execution in its ``__aenter__`` and ``__aexit__`` methods."
msgstr ""
"*비동기 컨텍스트 관리자(asynchronous context manager)* 는 ``__aenter__`` 와 "
"``__aexit__`` 메서드에서 실행을 일시 중지할 수 있는 *컨텍스트 관리자* 입니다."

#: ../Doc/reference/datamodel.rst:2684
msgid ""
"Asynchronous context managers can be used in an :keyword:`async with` "
"statement."
msgstr "비동기 컨텍스트 관리자는 :keyword:`async with` 문에서 사용될 수 있습니다."

#: ../Doc/reference/datamodel.rst:2688
msgid ""
"This method is semantically similar to the :meth:`__enter__`, with only "
"difference that it must return an *awaitable*."
msgstr ""
"이 메서드는 :meth:`__enter__` 메서드와 의미상으로 유사한데, 유일한 차이점은 *어웨이터블* 을 돌려줘야 한다는 "
"것입니다."

#: ../Doc/reference/datamodel.rst:2693
msgid ""
"This method is semantically similar to the :meth:`__exit__`, with only "
"difference that it must return an *awaitable*."
msgstr "이 메서드는 :meth:`__exit__` 메서드와 의미상으로 유사한데, 유일한 차이점은 *어웨이터블* 을 돌려줘야 한다는 것입니다."

#: ../Doc/reference/datamodel.rst:2696
msgid "An example of an asynchronous context manager class::"
msgstr "비동기 컨텍스트 관리자 클래스의 예::"

#: ../Doc/reference/datamodel.rst:2709
msgid "Footnotes"
msgstr "각주"

#: ../Doc/reference/datamodel.rst:2710
msgid ""
"It *is* possible in some cases to change an object's type, under certain "
"controlled conditions. It generally isn't a good idea though, since it "
"can lead to some very strange behaviour if it is handled incorrectly."
msgstr ""
"어떤 제한된 조건으로, 어떤 경우에 객체의 형을 변경하는 것이 *가능합니다*. 하지만 잘못 다뤄지면 아주 괴상한 결과로 이어질 수 "
"있으므로 일반적으로 좋은 생각이 아닙니다."

#: ../Doc/reference/datamodel.rst:2714
msgid ""
"The :meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, and "
":meth:`__contains__` methods have special handling for this; others will "
"still raise a :exc:`TypeError`, but may do so by relying on the behavior "
"that ``None`` is not callable."
msgstr ""
":meth:`__hash__`, :meth:`__iter__`, :meth:`__reversed__`, "
":meth:`__contains__` 메서드들이 이런 경우에 대한 특별한 처리를 포함하고 있습니다; 다른 것들도 여전히 "
":exc:`TypeError` 을 일으키지만, 단지 ``None`` 이 콜러블이 아니므로 그런 것뿐입니다."

#: ../Doc/reference/datamodel.rst:2719
msgid ""
"\"Does not support\" here means that the class has no such method, or the"
" method returns ``NotImplemented``.  Do not set the method to ``None`` if"
" you want to force fallback to the right operand's reflected method—that "
"will instead have the opposite effect of explicitly *blocking* such "
"fallback."
msgstr ""
"여기서 \"지원하지 않는다\" 는 클래스가 그런 메서드를 갖지 않거나, 메서드가 ``NotImplemented`` 를 돌려줌을 "
"뜻합니다. 오른쪽 피연산자의 뒤집힌 메서드를 사용하는 대안이 시도되도록 하려면 메서드를 ``None`` 으로 설정하지 말아야 합니다"
" - 그렇게 하는 것은 그런 대안을 명시적으로 *금지하는* 반대 효과를 줍니다."

#: ../Doc/reference/datamodel.rst:2725
msgid ""
"For operands of the same type, it is assumed that if the non-reflected "
"method (such as :meth:`__add__`) fails the operation is not supported, "
"which is why the reflected method is not called."
msgstr ""
"피연산자들이 같은 형이면, 뒤집히지 않은 메서드(:meth:`__add__` 같은)가 실패하면 그 연산이 지원되지 않는 것으로 "
"간주합니다. 이것이 뒤집힌 메서드가 호출되지 않는 이유입니다."

