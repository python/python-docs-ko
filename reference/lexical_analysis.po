# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 11:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "구문 분석"

#: ../Doc/reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream "
"of *tokens*, generated by the *lexical analyzer*.  This chapter describes"
" how the lexical analyzer breaks a file into tokens."
msgstr ""
"파이썬 프로그램은 *파서(parser)* 에 의해 읽힙니다. 파서의 입력은 *구문 분석기(lexical analyzer)* 가 "
"만들어내는 *토큰(token)* 들의 스트림입니다. 이 장에서는 구문 분석기가 어떻게 파일을 토큰들로 분해하는지 설명합니다."

#: ../Doc/reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a "
"source file can be given by an encoding declaration and defaults to "
"UTF-8, see :pep:`3120` for details.  If the source file cannot be "
"decoded, a :exc:`SyntaxError` is raised."
msgstr ""
"파이썬은 프로그램 텍스트를 유니코드 코드값으로 읽습니다; 소스 파일의 인코딩은 인코딩 선언을 통해 지정될 수 있고, 기본값은 "
"UTF-8입니다. 자세한 내용은 :pep:`3120` 에 나옵니다. 소스 파일을 디코딩할 수 없을 때는 "
":exc:`SyntaxError` 가 발생합니다."

#: ../Doc/reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "줄 구조(Line structure)"

#: ../Doc/reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "파이썬 프로그램은 여러 개의 *논리적인 줄(logical lines)* 들로 나뉩니다."

#: ../Doc/reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "논리적인 줄"

#: ../Doc/reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  "
"Statements cannot cross logical line boundaries except where NEWLINE is "
"allowed by the syntax (e.g., between statements in compound statements). "
"A logical line is constructed from one or more *physical lines* by "
"following the explicit or implicit *line joining* rules."
msgstr ""
"논리적인 줄의 끝은 NEWLINE 토큰으로 표현됩니다. 문법이 허락하지 않는 이상 (예를 들어 복합문에서 문장들 사이) 문장은 "
"논리적인 줄 간의 경계를 가로지를 수 없습니다. 논리적인 줄은 명시적이거나 묵시적인 *줄 결합(line joining)* 규칙에 따라 "
"하나 이상의 *물리적인 줄(physical lines)* 들로 구성됩니다."

#: ../Doc/reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "물리적인 줄"

#: ../Doc/reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files and strings, any of the standard platform line"
" termination sequences can be used - the Unix form using ASCII LF "
"(linefeed), the Windows form using the ASCII sequence CR LF (return "
"followed by linefeed), or the old Macintosh form using the ASCII CR "
"(return) character.  All of these forms can be used equally, regardless "
"of platform. The end of input also serves as an implicit terminator for "
"the final physical line."
msgstr ""
"물리적인 줄은 줄의 끝을 나타내는 시퀀스로 끝나는 문자들의 시퀀스입니다. 소스 파일과 문자열에는 플랫폼들의 표준 줄 종료 시퀀스들이 모두"
" 사용될 수 있습니다 - ASCII LF (개행문자)를 사용하는 유닉스 형, ASCII 시퀀스 CR LF(캐리지 리턴 다음에 오는 개행 "
"문자)를 사용하는 윈도우 형, ASCII CR(캐리지 리턴)을 사용하는 예전의 매킨토시 형. 이 형태들은 플랫폼의 종류와 관계없이 "
"동등하게 사용할 수 있습니다. 입력의 끝은 마지막 물리적인 줄의 묵시적 종결자 역할을 합니다."

#: ../Doc/reference/lexical_analysis.rst:57
msgid ""
"When embedding Python, source code strings should be passed to Python "
"APIs using the standard C conventions for newline characters (the ``\\n``"
" character, representing ASCII LF, is the line terminator)."
msgstr ""
"파이썬을 내장할 때는, 소스 코드 문자열은 반드시 줄 종료 문자에 표준 C 관행(ASCII LF를 표현하는 ``\\n`` 문자로 "
"줄이 종료됩니다)을 적용해서 파이썬 API로 전달되어야 합니다."

#: ../Doc/reference/lexical_analysis.rst:65
msgid "Comments"
msgstr "주석"

#: ../Doc/reference/lexical_analysis.rst:69
msgid ""
"A comment starts with a hash character (``#``) that is not part of a "
"string literal, and ends at the end of the physical line.  A comment "
"signifies the end of the logical line unless the implicit line joining "
"rules are invoked. Comments are ignored by the syntax; they are not "
"tokens."
msgstr ""
"주석은 문자열 리터럴에 포함되지 않는 해시 문자(``#``)로 시작하고 물리적인 줄의 끝에서 끝납니다. 묵시적인 줄 결합 규칙이 "
"유효하지 않은 이상, 주석은 논리적인 줄을 종료시킵니다. 주석은 문법이 무시합니다; 토큰으로 만들어지지 않습니다."

#: ../Doc/reference/lexical_analysis.rst:78
msgid "Encoding declarations"
msgstr "인코딩 선언"

#: ../Doc/reference/lexical_analysis.rst:82
msgid ""
"If a comment in the first or second line of the Python script matches the"
" regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is "
"processed as an encoding declaration; the first group of this expression "
"names the encoding of the source code file. The encoding declaration must"
" appear on a line of its own. If it is the second line, the first line "
"must also be a comment-only line. The recommended forms of an encoding "
"expression are ::"
msgstr ""
"파이썬 스크립트의 첫 번 째나 두 번째 줄에 있는 주석이 정규식 ``coding[=:]\\s*([-\\w.]+)`` 과 매치되면, "
"이 주석은 인코딩 선언으로 처리됩니다. 이 정규식의 첫 번째 그룹은 소스 코드 파일의 인코딩 이름을 지정합니다. 인코딩 선언은 줄 "
"전체에 홀로 나와야 합니다. 만약 두 번째 줄이라면, 첫 번째 줄 역시 주석만 있어야 합니다. 인코딩 선언의 권장 형태는 두 개입니다. "
"하나는 ::"

#: ../Doc/reference/lexical_analysis.rst:91
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "인데 GNU Emacs에서도 인식됩니다. 다른 하나는 ::"

#: ../Doc/reference/lexical_analysis.rst:95
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "인데 Bram Moolenaar 의 VIM에서 인식됩니다."

#: ../Doc/reference/lexical_analysis.rst:97
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"인코딩 선언이 발견되지 않으면 기본 인코딩은 UTF-8입니다. 여기에 더해, 파일의 처음이 UTF-8 BOM "
"(``b'\\xef\\xbb\\xbf'``)이면 파일 인코딩이 UTF-8으로 선언된 것으로 봅니다. (이 방식은 마이크로소프트의 "
":program:`notepad` 에서 지원됩니다.)"

#: ../Doc/reference/lexical_analysis.rst:102
msgid ""
"If an encoding is declared, the encoding name must be recognized by "
"Python. The encoding is used for all lexical analysis, including string "
"literals, comments and identifiers."
msgstr ""
"인코딩이 선언되면, 인코딩 이름은 파이썬이 인식할 수 있어야 합니다. 인코딩은 문자열 리터럴, 주석, 식별자를 포함한 모든 구문 "
"분석에서 모두 사용됩니다."

#: ../Doc/reference/lexical_analysis.rst:112
msgid "Explicit line joining"
msgstr "명시적인 줄 결합"

#: ../Doc/reference/lexical_analysis.rst:116
msgid ""
"Two or more physical lines may be joined into logical lines using "
"backslash characters (``\\``), as follows: when a physical line ends in a"
" backslash that is not part of a string literal or comment, it is joined "
"with the following forming a single logical line, deleting the backslash "
"and the following end-of-line character.  For example::"
msgstr ""
"둘 이상의 물리적인 줄은 역 슬래시 문자(``\\``)를 사용해서 논리적인 줄로 결합할 수 있습니다: 물리적인 줄이 문자열 리터럴이나 "
"주석의 일부가 아닌 역 슬래시 문자로 끝나면, 역 슬래시와 뒤따르는 개행 문자가 제거된 채로, 현재 만들어지고 있는 논리적인 줄에 "
"합쳐집니다. 예를 들어::"

#: ../Doc/reference/lexical_analysis.rst:127
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does "
"not continue a comment.  A backslash does not continue a token except for"
" string literals (i.e., tokens other than string literals cannot be split"
" across physical lines using a backslash).  A backslash is illegal "
"elsewhere on a line outside a string literal."
msgstr ""
"역 슬래시로 끝나는 줄은 주석이 포함될 수 없습니다. 역 슬래시는 주석을 결합하지 못합니다. 역 슬래시는 문자열 리터럴을 제외한 어떤 "
"토큰도 결합하지 못합니다 (즉, 문자열 리터럴 이외의 어떤 토큰도 역 슬래시를 사용해서 두 줄에 나누어 기록할 수 없습니다.). 문자열 "
"리터럴 밖에 있는 역 슬래시가 앞에서 언급한 장소 이외의 곳에 등장하는 것은 문법에 어긋납니다."

#: ../Doc/reference/lexical_analysis.rst:137
msgid "Implicit line joining"
msgstr "묵시적인 줄 결합"

#: ../Doc/reference/lexical_analysis.rst:139
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"괄호(``()``), 꺾쇠괄호(``[]``), 중괄호(``{}``)가 사용되는 표현은 역 슬래시 없이도 여러 개의 물리적인 줄로 "
"나눌 수 있습니다. 예를 들어::"

#: ../Doc/reference/lexical_analysis.rst:147
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are "
"allowed. There is no NEWLINE token between implicit continuation lines.  "
"Implicitly continued lines can also occur within triple-quoted strings "
"(see below); in that case they cannot carry comments."
msgstr ""
"묵시적으로 이어지는 줄들은 주석을 포함할 수 있습니다. 이어지는 줄들의 들여쓰기는 중요하지 않습니다. 중간에 빈 줄이 들어가도 됩니다. "
"묵시적으로 줄 결합하는 줄 들 간에는 NEWLINE 토큰이 만들어지지 않습니다. 묵시적으로 이어지는 줄들은 삼중 따옴표 된 "
"문자열들에서도 등장할 수 있는데 (아래를 보라), 이 경우는 주석이 포함될 수 없습니다."

#: ../Doc/reference/lexical_analysis.rst:157
msgid "Blank lines"
msgstr "빈 줄"

#: ../Doc/reference/lexical_analysis.rst:161
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. "
"one containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"스페이스, 탭, 폼 피드(formfeed) 와 주석만으로 구성된 논리적인 줄은 무시됩니다. (즉 NEWLINE 토큰이 만들어지지 "
"않습니다.) 대화형으로 문장이 입력되는 도중에는 빈 줄의 처리가 REPL 구현에 따라 달라질 수 있습니다. 표준 대화형 인터프리터에서는,"
" 완전히 빈 줄(즉 공백이나 주석조차 없는 것)은 다중 행 문장을 종료시킵니다."

#: ../Doc/reference/lexical_analysis.rst:172
msgid "Indentation"
msgstr "들여쓰기"

#: ../Doc/reference/lexical_analysis.rst:176
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line "
"is used to compute the indentation level of the line, which in turn is "
"used to determine the grouping of statements."
msgstr ""
"논리적인 줄의 제일 앞에 오는 공백(스페이스와 탭)은 줄의 들여쓰기 수준을 계산하는 데 사용되고, 이는 다시 문장들의 묶음을 "
"결정하는 데 사용되게 됩니다."

#: ../Doc/reference/lexical_analysis.rst:180
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that "
"the total number of characters up to and including the replacement is a "
"multiple of eight (this is intended to be the same rule as used by Unix)."
"  The total number of spaces preceding the first non-blank character then"
" determines the line's indentation.  Indentation cannot be split over "
"multiple physical lines using backslashes; the whitespace up to the first"
" backslash determines the indentation."
msgstr ""
"탭은 (왼쪽에서 오른쪽으로) 1~8개의 스페이스로 변환되는데, 치환된 후의 총 스페이스 문자 수가 8의 배수가 되도록 맞춥니다. "
"(유닉스에서 사용되는 규칙에 맞추려는 것입니다.) 첫 번째 비 공백 문자 앞에 나오는 공백의 총수가 줄의 들여쓰기를 결정합니다. "
"들여쓰기는 역 슬래시를 사용해서 여러 개의 물리적인 줄로 나눠질 수 없습니다; 첫 번째 역 슬래시 이전의 공백이 들여쓰기를 결정합니다."

#: ../Doc/reference/lexical_analysis.rst:188
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in"
" spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"소스 파일이 탭과 스페이스를 섞어 쓰는 경우, 탭이 몇 개의 스페이스에 해당하는지에 따라 다르게 해석될 수 있으면 "
":exc:`TabError` 를 일으킵니다."

#: ../Doc/reference/lexical_analysis.rst:192
msgid ""
"**Cross-platform compatibility note:** because of the nature of text "
"editors on non-UNIX platforms, it is unwise to use a mixture of spaces "
"and tabs for the indentation in a single source file.  It should also be "
"noted that different platforms may explicitly limit the maximum "
"indentation level."
msgstr ""
"**크로스-플랫폼 호환성 유의 사항:** UNIX 이외의 플랫폼에서 편집기들이 동작하는 방식 때문에, 하나의 파일 내에서 들여쓰기를"
" 위해 탭과 스페이스를 섞어 쓰는 것은 현명한 선택이 아닙니다. 다른 플랫폼들에서는 최대 들여쓰기 수준에 제한이 있을 수도 있다는 "
"점도 주의해야 합니다."

#: ../Doc/reference/lexical_analysis.rst:197
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect "
"(for instance, they may reset the space count to zero)."
msgstr ""
"폼 피드 문자는 줄의 처음에 나올 수 있습니다; 앞서 설명한 들여쓰기 수준 계산에서는 무시됩니다. 페이지 넘김 문자 앞에 공백이나 탭이 "
"있는 경우는 정의되지 않은 효과를 줄 수 있습니다 (가령, 스페이스 수가 0으로 초기화될 수 있습니다)."

#: ../Doc/reference/lexical_analysis.rst:204
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT "
"and DEDENT tokens, using a stack, as follows."
msgstr ""
"연속된 줄의 들여쓰기 수준은, 스택을 사용해서, 다음과 같은 방법으로 INDENT와 DEDENT 토큰을 만드는 데 사용됩니다."

#: ../Doc/reference/lexical_analysis.rst:207
msgid ""
"Before the first line of the file is read, a single zero is pushed on the"
" stack; this will never be popped off again.  The numbers pushed on the "
"stack will always be strictly increasing from bottom to top.  At the "
"beginning of each logical line, the line's indentation level is compared "
"to the top of the stack. If it is equal, nothing happens. If it is "
"larger, it is pushed on the stack, and one INDENT token is generated.  If"
" it is smaller, it *must* be one of the numbers occurring on the stack; "
"all numbers on the stack that are larger are popped off, and for each "
"number popped off a DEDENT token is generated.  At the end of the file, a"
" DEDENT token is generated for each number remaining on the stack that is"
" larger than zero."
msgstr ""
"파일의 첫 줄을 읽기 전에 0하나를 스택에 넣습니다(push); 이 값은 다시 꺼내는(pop) 일이 없습니다. 스택에 넣는 값은 항상 "
"스택의 아래에서 위로 올라갈 때 단조 증가합니다. 각 논리적인 줄의 처음에서 줄의 들여쓰기 수준이 스택의 가장 위에 있는 값과 "
"비교됩니다. 같다면 아무런 일도 일어나지 않습니다. 더 크다면 그 값을 스택에 넣고 하나의 INDENT 토큰을 만듭니다. 더 작다면 이 "
"값은 스택에 있는 값 중 하나여야만 합니다. 이 값보다 큰 모든 스택의 값들을 꺼내고(pop), 꺼낸 횟수만큼의 DEDENT 토큰을 "
"만듭니다. 파일의 끝에서, 스택에 남아있는 0보다 큰 값의 개수만큼 DEDENT 토큰을 만듭니다."

#: ../Doc/reference/lexical_analysis.rst:218
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr "여기에 (혼란스럽다 할지라도) 올바르게 들여쓰기 된 파이썬 코드 조각이 있습니다::"

#: ../Doc/reference/lexical_analysis.rst:233
msgid "The following example shows various indentation errors::"
msgstr "다음 예는 여러 가지 들여쓰기 에러를 보여줍니다::"

#: ../Doc/reference/lexical_analysis.rst:243
msgid ""
"(Actually, the first three errors are detected by the parser; only the "
"last error is found by the lexical analyzer --- the indentation of "
"``return r`` does not match a level popped off the stack.)"
msgstr ""
"(사실, 처음 세 개의 에러는 파서가 감지합니다. 단지 마지막 에러만 구문 분석기가 감지합니다. --- ``return r`` 의 "
"들여쓰기가 스택에 있는 값과 일치하지 않습니다.)"

#: ../Doc/reference/lexical_analysis.rst:251
msgid "Whitespace between tokens"
msgstr "토큰 사이의 공백"

#: ../Doc/reference/lexical_analysis.rst:253
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably"
" to separate tokens.  Whitespace is needed between two tokens only if "
"their concatenation could otherwise be interpreted as a different token "
"(e.g., ab is one token, but a b is two tokens)."
msgstr ""
"논리적인 줄의 처음과 문자열 리터럴을 제외하고, 공백 문자인 스페이스, 탭, 폼 피드는 토큰을 분리하기 위해 섞어 쓸 수 있습니다. 두"
" 토큰을 붙여 쓸 때 다른 토큰으로 해석될 수 있는 경우만 토큰 사이에 공백이 필요합니다. (예를 들어, ab 는 하나의 토큰이지만,"
" a b 는 두 개의 토큰입니다.)"

#: ../Doc/reference/lexical_analysis.rst:263
msgid "Other tokens"
msgstr "다른 토큰들"

#: ../Doc/reference/lexical_analysis.rst:265
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and "
"*delimiters*. Whitespace characters (other than line terminators, "
"discussed earlier) are not tokens, but serve to delimit tokens. Where "
"ambiguity exists, a token comprises the longest possible string that "
"forms a legal token, when read from left to right."
msgstr ""
"NEWLINE, INDENT, DEDENT 와는 별도로, 다음과 같은 유형의 토큰들이 존재합니다: *식별자(identifier)*, "
"*키워드(keyword)*, *리터럴(literal)*, *연산자(operator)*, *구분자(delimiter)*. (앞에서 "
"살펴본 줄 종료 이외의) 공백 문자들은 토큰이 아니지만, 토큰을 분리하는 역할을 담당합니다. 모호할 경우, 왼쪽에서 오른쪽으로 읽을 "
"때, 하나의 토큰은 올바르고 가능한 한 최대 길이의 문자열로 구성되는 것을 선호합니다."

#: ../Doc/reference/lexical_analysis.rst:275
msgid "Identifiers and keywords"
msgstr "식별자와 키워드"

#: ../Doc/reference/lexical_analysis.rst:279
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr "식별자 (*이름(name)* 이라고도 합니다) 은 다음과 같은 구문 정의로 기술됩니다."

#: ../Doc/reference/lexical_analysis.rst:282
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard "
"annex UAX-31, with elaboration and changes as defined below; see also "
":pep:`3131` for further details."
msgstr ""
"파이썬에서 식별자의 문법은 유니코드 표준 부속서 UAX-31 에 기반을 두는데, 여기에 덧붙이거나 바꾼 내용은 아래에서 정의합니다. "
"좀 더 상세한 내용은 :pep:`3131` 에서 찾을 수 있습니다."

#: ../Doc/reference/lexical_analysis.rst:286
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the "
"first character, the digits ``0`` through ``9``."
msgstr ""
"ASCII 범위 (U+0001..U+007F) 내에서, 올바른 식별자 문자는 파이썬 2.x 와 같습니다: ``A`` 에서 ``Z`` "
"범위의 대문자와 소문자, 밑줄 ``_``, 첫 문자를 제외하고, 숫자 ``0`` 에서 ``9``. "

#: ../Doc/reference/lexical_analysis.rst:291
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the "
":mod:`unicodedata` module."
msgstr ""
"파이썬 3.0은 ASCII 범위 밖의 문자들을 도입합니다 (:pep:`3131` 참조). 이 문자들의 경우, "
":mod:`unicodedata` 모듈에 포함된 버전의 유니코드 문자 데이터베이스에 따라 분류됩니다."

#: ../Doc/reference/lexical_analysis.rst:295
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "식별자는 길이에 제한이 없고, 케이스(case)는 구분됩니다."

#: ../Doc/reference/lexical_analysis.rst:304
msgid "The Unicode category codes mentioned above stand for:"
msgstr "위에서 언급한 유니코드 카테고리 코드들의 의미는 이렇습니다:"

#: ../Doc/reference/lexical_analysis.rst:306
msgid "*Lu* - uppercase letters"
msgstr "*Lu* - uppercase letters"

#: ../Doc/reference/lexical_analysis.rst:307
msgid "*Ll* - lowercase letters"
msgstr "*Ll* - lowercase letters"

#: ../Doc/reference/lexical_analysis.rst:308
msgid "*Lt* - titlecase letters"
msgstr "*Lt* - titlecase letters"

#: ../Doc/reference/lexical_analysis.rst:309
msgid "*Lm* - modifier letters"
msgstr "*Lm* - modifier letters"

#: ../Doc/reference/lexical_analysis.rst:310
msgid "*Lo* - other letters"
msgstr "*Lo* - other letters"

#: ../Doc/reference/lexical_analysis.rst:311
msgid "*Nl* - letter numbers"
msgstr "*Nl* - letter numbers"

#: ../Doc/reference/lexical_analysis.rst:312
msgid "*Mn* - nonspacing marks"
msgstr "*Mn* - nonspacing marks"

#: ../Doc/reference/lexical_analysis.rst:313
msgid "*Mc* - spacing combining marks"
msgstr "*Mc* - spacing combining marks"

#: ../Doc/reference/lexical_analysis.rst:314
msgid "*Nd* - decimal numbers"
msgstr "*Nd* - decimal numbers"

#: ../Doc/reference/lexical_analysis.rst:315
msgid "*Pc* - connector punctuations"
msgstr "*Pc* - connector punctuations"

#: ../Doc/reference/lexical_analysis.rst:316
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt "
"<http://www.unicode.org/Public/11.0.0/ucd/PropList.txt>`_ to support "
"backwards compatibility"
msgstr ""
"*Other_ID_Start* - 하위 호환성 지원을 위해 `PropList.txt "
"<http://www.unicode.org/Public/11.0.0/ucd/PropList.txt>`_ 에서 명시적으로 나열된 "
"문자들"

#: ../Doc/reference/lexical_analysis.rst:319
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - 마찬가지"

#: ../Doc/reference/lexical_analysis.rst:321
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr "모든 식별자는 파서에 의해 NFKC 정규화 형식으로 변환되고, 식별자의 비교는 NFKC 에 기반을 둡니다."

#: ../Doc/reference/lexical_analysis.rst:324
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at https://www.dcl.hpi.uni-"
"potsdam.de/home/loewis/table-3131.html."
msgstr ""
"유니코드 4.1의 올바른 식별자 문자들의 비규범적인 목록을 HTML 파일로 정리한 문서를 https://www.dcl.hpi"
".uni-potsdam.de/home/loewis/table-3131.html 에서 열람할 수 있습니다."

#: ../Doc/reference/lexical_analysis.rst:332
msgid "Keywords"
msgstr "키워드"

#: ../Doc/reference/lexical_analysis.rst:338
msgid ""
"The following identifiers are used as reserved words, or *keywords* of "
"the language, and cannot be used as ordinary identifiers.  They must be "
"spelled exactly as written here:"
msgstr ""
"다음 식별자들은 예약어, 또는 언어의 키워드, 로 사용되고, 일반적인 식별자로 사용될 수 없습니다. 여기 쓰여 있는 것과 정확히 같게 "
"사용되어야 합니다:"

#: ../Doc/reference/lexical_analysis.rst:355
msgid "Reserved classes of identifiers"
msgstr "식별자의 예약 영역"

#: ../Doc/reference/lexical_analysis.rst:357
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings."
"  These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr ""
"(키워드와는 별개로) 어떤 부류의 식별자들은 특별한 의미가 있습니다. 이 부류의 식별자들은 시작과 끝의 밑줄 문자 패턴으로 구분됩니다:"

#: ../Doc/reference/lexical_analysis.rst:371
msgid "``_*``"
msgstr "``_*``"

#: ../Doc/reference/lexical_analysis.rst:362
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` "
"is used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""
"``from module import *`` 에 의해 임포트되지 않습니다. 특별한 식별자 ``_`` 는 대화형 인터프리터에서 마지막에"
" 실행한 결과의 값을 저장하는 용도로 사용됩니다; :mod:`builtins` 모듈에 저장됩니다. 대화형 모드가 아닐 경우 ``_`` "
"는 특별한 의미가 없고, 정의되지도 않습니다. :ref:`import` 섹션을 보세요."

#: ../Doc/reference/lexical_analysis.rst:369
msgid ""
"The name ``_`` is often used in conjunction with internationalization; "
"refer to the documentation for the :mod:`gettext` module for more "
"information on this convention."
msgstr ""
"이름 ``_`` 은 종종 국제화(internationalization)와 관련되어 사용됩니다. 이 관례에 관해서는 "
":mod:`gettext` 모듈의 문서를 참조하십시오."

#: ../Doc/reference/lexical_analysis.rst:379
msgid "``__*__``"
msgstr "``__*__``"

#: ../Doc/reference/lexical_analysis.rst:374
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names "
"are discussed in the :ref:`specialnames` section and elsewhere.  More "
"will likely be defined in future versions of Python.  *Any* use of "
"``__*__`` names, in any context, that does not follow explicitly "
"documented use, is subject to breakage without warning."
msgstr ""
"시스템 정의 이름. 이 이름들은 인터프리터와 그 구현(표준 라이브러리를 포함합니다)이 정의합니다. 현재 정의된 시스템 이름은 "
":ref:`specialnames` 섹션과 그 외의 곳에서 논의됩니다. 파이썬의 미래 버전에서는 더 많은 것들이 정의될 가능성이 "
"큽니다. 어떤 문맥에서건, 명시적으로 문서로 만들어진 사용법을 벗어나는 ``__*__`` 이름의 *모든* 사용은, 경고 없이 손상될 "
"수 있습니다."

#: ../Doc/reference/lexical_analysis.rst:386
msgid "``__*``"
msgstr "``__*``"

#: ../Doc/reference/lexical_analysis.rst:382
msgid ""
"Class-private names.  Names in this category, when used within the "
"context of a class definition, are re-written to use a mangled form to "
"help avoid name clashes between \"private\" attributes of base and "
"derived classes. See section :ref:`atom-identifiers`."
msgstr ""
"클래스-비공개 이름. 이 부류의 이름들을 클래스 정의 문맥에서 사용하면 뒤섞인 형태로 변형됩니다. 부모 클래스와 자식 클래스의 "
"\"비공개(private)\" 어트리뷰트 간의 이름 충돌을 피하기 위함입니다. :ref:`atom-identifiers` 섹션을 "
"보세요."

#: ../Doc/reference/lexical_analysis.rst:391
msgid "Literals"
msgstr "리터럴"

#: ../Doc/reference/lexical_analysis.rst:395
msgid "Literals are notations for constant values of some built-in types."
msgstr "리터럴(literal)은 몇몇 내장형들의 상숫값을 위한 표기법입니다."

#: ../Doc/reference/lexical_analysis.rst:401
msgid "String and Bytes literals"
msgstr "문자열과 바이트열 리터럴"

#: ../Doc/reference/lexical_analysis.rst:405
msgid "String literals are described by the following lexical definitions:"
msgstr "문자열 리터럴은 다음과 같은 구문 정의로 기술됩니다:"

#: ../Doc/reference/lexical_analysis.rst:430
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or "
":token:`bytesprefix` and the rest of the literal. The source character "
"set is defined by the encoding declaration; it is UTF-8 if no encoding "
"declaration is given in the source file; see section :ref:`encodings`."
msgstr ""
"이 생성 규칙이 보여주지 못하는 한 가지 문법적 제약은 :token:`stringprefix` 나 "
":token:`bytesprefix` 와 리터럴의 나머지 부분 사이에 공백이 허락되지 않는다는 것입니다. 소스 문자 집합은 인코딩 "
"선언으로 정의됩니다; 소스 파일에 인코딩 선언이 없으면 UTF-8입니다. :ref:`encodings` 섹션을 보세요."

#: ../Doc/reference/lexical_analysis.rst:438
msgid ""
"In plain English: Both types of literals can be enclosed in matching "
"single quotes (``'``) or double quotes (``\"``).  They can also be "
"enclosed in matching groups of three single or double quotes (these are "
"generally referred to as *triple-quoted strings*).  The backslash "
"(``\\``) character is used to escape characters that otherwise have a "
"special meaning, such as newline, backslash itself, or the quote "
"character."
msgstr ""
"쉬운 말로 하자면, 두 가지 리터럴은 한 쌍의 작은따옴표(``'``) 나 큰따옴표(``\"``)로 둘러싸일 수 있습니다. 또한, 둘 다"
" 한 쌍의 삼중 작은따옴표나 큰따옴표로 둘러싸일 수도 있습니다 (이것들은 보통 *삼중 따옴표 된 문자열* 이라고 불립니다). 역 "
"슬래시(``\\``) 문자는 홀로 쓰이면 특별한 의미가 있는 문자들을 이스케이핑할 때 사용되는데, 개행문자, 역 슬래시 자신, "
"따옴표 문자가 그것입니다."

#: ../Doc/reference/lexical_analysis.rst:445
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce "
"an instance of the :class:`bytes` type instead of the :class:`str` type."
"  They may only contain ASCII characters; bytes with a numeric value of "
"128 or greater must be expressed with escapes."
msgstr ""
"바이트열(bytes) 리터럴은 항상 ``'b'`` 나 ``'B'`` 를 앞에 붙입니다; :class:`str` 형의 인스턴스 대신 "
":class:`bytes` 형의 인스턴스를 만듭니다. 오직 ASCII 문자들만 포함할 수 있습니다. 코드값이 128보다 크거나 같은 "
"값들은 반드시 이스케이핑으로 표현되어야 합니다."

#: ../Doc/reference/lexical_analysis.rst:450
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially."
" Given that Python 2.x's raw unicode literals behave differently than "
"Python 3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"문자열과 바이트열 리터럴 모두 선택적으로 ``'r'`` 이나 ``'R'`` 문자를 앞에 붙일 수 있습니다. 이런 문자열을 날 "
"문자열(:dfn:`raw strings`) 이라고 하는데, 역 슬래시를 평범한 문자로 취급합니다. 결과적으로, 문자열 리터럴에서, 날"
" 문자열에 있는 ``'\\U'`` 와 ``'\\u'`` 이스케이프는 특별하게 처리되지 않습니다. 파이썬 2.x의 날 유니코드 리터럴이"
" 파이썬 3.x와 다르게 동작합니다는 것을 고려해서, ``'ur'`` 문법은 지원되지 않습니다."

#: ../Doc/reference/lexical_analysis.rst:457
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr "날 바이트열 리터럴의 ``'br'`` 와 같은 의미가 있는 ``'rb'`` 접두어가 추가되었습니다."

#: ../Doc/reference/lexical_analysis.rst:461
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to"
" simplify the maintenance of dual Python 2.x and 3.x codebases. See "
":pep:`414` for more information."
msgstr ""
"파이썬 2.x 와 3.x 에서 동시에 지원하는 코드들의 유지보수를 단순화하기 위해 예전에 사용되던 유니코드 리터럴 "
"(``u'value'``)이 다시 도입되었습니다. 자세한 정보는 :pep:`414` 에 나옵니다."

#: ../Doc/reference/lexical_analysis.rst:466
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a "
":dfn:`formatted string literal`; see :ref:`f-strings`.  The ``'f'`` may "
"be combined with ``'r'``, but not with ``'b'`` or ``'u'``, therefore raw "
"formatted strings are possible, but formatted bytes literals are not."
msgstr ""
"``'f'`` 나 ``'F'`` 를 접두어로 갖는 문자열 리터럴은 포맷 문자열 리터럴(:dfn:`formatted string "
"literal`)입니다; :ref:`f-strings` 을 보세요. ``'f'`` 는 ``'r'`` 과 결합할 수 있습니다, 하지만, "
"``'b'`` 나 ``'u'`` 와는 결합할 수 없습니다. 따라서 날 포맷 문자열은 가능하지만, 포맷 바이트열 리터럴은 불가능합니다."

#: ../Doc/reference/lexical_analysis.rst:471
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and"
" are retained), except that three unescaped quotes in a row terminate the"
" literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"삼중 따옴표 된 리터럴에서, 세 개의 이스케이핑 되지 않은 개행 문자와 따옴표가 허락됩니다 (그리고 유지됩니다). 예외는 한 줄에 세 "
"개의 이스케이핑 되지 않은 따옴표가 나오는 것인데, 리터럴을 종료시킵니다. (\"따옴표\"는 리터럴을 시작하는데 사용한 문자입니다. 즉,"
" ``'`` 나 ``\"``)"

#: ../Doc/reference/lexical_analysis.rst:477
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in "
"string and bytes literals are interpreted according to rules similar to "
"those used by Standard C.  The recognized escape sequences are:"
msgstr ""
"``'r'`` 나 ``'R'`` 접두어가 붙지 않은 이상, 문자열과 바이트열 리터럴에 포함된 이스케이프 시퀀스는 표준 C에서 사용된"
" 것과 비슷한 규칙으로 해석됩니다. 인식되는 이스케이프 시퀀스는 이렇습니다:"

#: ../Doc/reference/lexical_analysis.rst:482
#: ../Doc/reference/lexical_analysis.rst:515
msgid "Escape Sequence"
msgstr "이스케이프 시퀀스"

#: ../Doc/reference/lexical_analysis.rst:482
#: ../Doc/reference/lexical_analysis.rst:515
msgid "Meaning"
msgstr "의미"

#: ../Doc/reference/lexical_analysis.rst:482
#: ../Doc/reference/lexical_analysis.rst:515
msgid "Notes"
msgstr "유의 사항"

#: ../Doc/reference/lexical_analysis.rst:484
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../Doc/reference/lexical_analysis.rst:484
msgid "Backslash and newline ignored"
msgstr "역 슬래시와 개행 문자가 무시됩니다"

#: ../Doc/reference/lexical_analysis.rst:486
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../Doc/reference/lexical_analysis.rst:486
msgid "Backslash (``\\``)"
msgstr "역 슬래시 (``\\``)"

#: ../Doc/reference/lexical_analysis.rst:488
msgid "``\\'``"
msgstr "``\\'``"

#: ../Doc/reference/lexical_analysis.rst:488
msgid "Single quote (``'``)"
msgstr "작은따옴표 (``'``)"

#: ../Doc/reference/lexical_analysis.rst:490
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../Doc/reference/lexical_analysis.rst:490
msgid "Double quote (``\"``)"
msgstr "큰따옴표 (``\"``)"

#: ../Doc/reference/lexical_analysis.rst:492
msgid "``\\a``"
msgstr "``\\a``"

#: ../Doc/reference/lexical_analysis.rst:492
msgid "ASCII Bell (BEL)"
msgstr "ASCII 벨 (BEL)"

#: ../Doc/reference/lexical_analysis.rst:494
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/reference/lexical_analysis.rst:494
msgid "ASCII Backspace (BS)"
msgstr "ASCII 백스페이스 (BS)"

#: ../Doc/reference/lexical_analysis.rst:496
msgid "``\\f``"
msgstr "``\\f``"

#: ../Doc/reference/lexical_analysis.rst:496
msgid "ASCII Formfeed (FF)"
msgstr "ASCII 폼 피드 (FF)"

#: ../Doc/reference/lexical_analysis.rst:498
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/reference/lexical_analysis.rst:498
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 라인 피드 (LF)"

#: ../Doc/reference/lexical_analysis.rst:500
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/reference/lexical_analysis.rst:500
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 캐리지 리턴 (CR)"

#: ../Doc/reference/lexical_analysis.rst:502
msgid "``\\t``"
msgstr "``\\t``"

#: ../Doc/reference/lexical_analysis.rst:502
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 가로 탭 (TAB)"

#: ../Doc/reference/lexical_analysis.rst:504
msgid "``\\v``"
msgstr "``\\v``"

#: ../Doc/reference/lexical_analysis.rst:504
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII 세로 탭 (VT)"

#: ../Doc/reference/lexical_analysis.rst:506
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../Doc/reference/lexical_analysis.rst:506
msgid "Character with octal value *ooo*"
msgstr "8진수 *ooo* 로 지정된 문자"

#: ../Doc/reference/lexical_analysis.rst:506
msgid "(1,3)"
msgstr "(1,3)"

#: ../Doc/reference/lexical_analysis.rst:509
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../Doc/reference/lexical_analysis.rst:509
msgid "Character with hex value *hh*"
msgstr "16진수 *hh* 로 지정된 문자"

#: ../Doc/reference/lexical_analysis.rst:509
msgid "(2,3)"
msgstr "(2,3)"

#: ../Doc/reference/lexical_analysis.rst:512
msgid "Escape sequences only recognized in string literals are:"
msgstr "문자열 리터럴에서만 인식되는 이스케이프 시퀀스는:"

#: ../Doc/reference/lexical_analysis.rst:517
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../Doc/reference/lexical_analysis.rst:517
msgid "Character named *name* in the Unicode database"
msgstr "유니코드 데이터베이스에서 *name* 이라고 이름 붙여진 문자"

#: ../Doc/reference/lexical_analysis.rst:517
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/reference/lexical_analysis.rst:520
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../Doc/reference/lexical_analysis.rst:520
msgid "Character with 16-bit hex value *xxxx*"
msgstr "16-bit 16진수 *xxxx* 로 지정된 문자"

#: ../Doc/reference/lexical_analysis.rst:520
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/reference/lexical_analysis.rst:523
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../Doc/reference/lexical_analysis.rst:523
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "32-bit 16진수 *xxxxxxxx* 로 지정된 문자"

#: ../Doc/reference/lexical_analysis.rst:523
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/reference/lexical_analysis.rst:527
msgid "Notes:"
msgstr "유의 사항:"

#: ../Doc/reference/lexical_analysis.rst:530
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "표준 C와 마찬가지로, 최대 세 개의 8진수가 허용됩니다."

#: ../Doc/reference/lexical_analysis.rst:533
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "표준 C와는 달리, 정확히 두 개의 16진수가 제공되어야 합니다."

#: ../Doc/reference/lexical_analysis.rst:536
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with "
"the given value. In a string literal, these escapes denote a Unicode "
"character with the given value."
msgstr ""
"바이트열 리터럴에서, 16진수와 8진수 이스케이프는 지정된 값의 바이트를 표현합니다. 문자열 리터럴에서는, 이 이스케이프는 지정된 "
"값의 유니코드 문자를 표현합니다."

#: ../Doc/reference/lexical_analysis.rst:541
msgid "Support for name aliases [#]_ has been added."
msgstr "별칭 [#]_ 지원이 추가되었습니다"

#: ../Doc/reference/lexical_analysis.rst:545
msgid "Exactly four hex digits are required."
msgstr "정확히 4개의 16진수를 필요로 합니다."

#: ../Doc/reference/lexical_analysis.rst:548
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits "
"are required."
msgstr "이 방법으로 모든 유니코드를 인코딩할 수 있습니다. 정확히 8개의 16진수가 필요합니다."

#: ../Doc/reference/lexical_analysis.rst:554
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the "
"string unchanged, i.e., *the backslash is left in the result*.  (This "
"behavior is useful when debugging: if an escape sequence is mistyped, the"
" resulting output is more easily recognized as broken.)  It is also "
"important to note that the escape sequences only recognized in string "
"literals fall into the category of unrecognized escapes for bytes "
"literals."
msgstr ""
"표준 C와는 달리, 인식되지 않는 모든 이스케이프 시퀀스는 문자열에 변경되지 않은 상태로 남게 됩니다. 즉, *역 슬래시가 결과에 "
"남게 됩니다*. (이 동작은 디버깅할 때 쓸모가 있습니다. 이스케이프 시퀀스가 잘못 입력되었을 때, 최종 결과에서 잘못된 부분을 쉽게 "
"인지할 수 있습니다.) 문자열 리터럴에서만 인식되는 이스케이프 시퀀스가, 바이트열 리터럴에서는 인식되지 않는 부류임에 주목하십시오."

#: ../Doc/reference/lexical_analysis.rst:561
msgid ""
"Unrecognized escape sequences produce a DeprecationWarning.  In some "
"future version of Python they will be a SyntaxError."
msgstr ""
"인식되지 않는 이스케이프 시퀀스는 DeprecationWarning 을 만듭니다. 언젠가 파이썬의 미래 버전에서는 "
"SyntaxError 로 취급될 것입니다."

#: ../Doc/reference/lexical_analysis.rst:565
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double "
"quote; ``r\"\\\"`` is not a valid string literal (even a raw string "
"cannot end in an odd number of backslashes).  Specifically, *a raw "
"literal cannot end in a single backslash* (since the backslash would "
"escape the following quote character).  Note also that a single backslash"
" followed by a newline is interpreted as those two characters as part of "
"the literal, *not* as a line continuation."
msgstr ""
"날 리터럴에서 조차, 따옴표는 역 슬래시로 이스케이프 됩니다. 하지만 역 슬래시가 결과에 남게 됩니다; 예를 들어, "
"``r\"\\\"\"`` 는 올바른 문자열 리터럴인데, 두 개의 문자가 들어있습니다: 역 슬래시와 큰따옴표; ``r\"\\\"`` 는 "
"올바른 문자열 리터럴이 아닙니다 (날 문자열조차 홀수개의 역 슬래시로 끝날 수 없습니다.). 좀 더 명확하게 말하자면, 날 리터럴은 "
"하나의 역 슬래시로 끝날 수 없습니다(역 슬래시가 뒤에 오는 따옴표를 이스케이프 시키기 때문입니다). 역 슬래시와 바로 뒤에 오는 "
"개행문자는 줄 결합이 *아니라* 리터럴에 포함되는 두 개의 문자로 인식됨에 주의해야 합니다."

#: ../Doc/reference/lexical_analysis.rst:578
msgid "String literal concatenation"
msgstr "문자열 리터럴 이어붙이기"

#: ../Doc/reference/lexical_analysis.rst:580
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their "
"meaning is the same as their concatenation.  Thus, ``\"hello\" 'world'`` "
"is equivalent to ``\"helloworld\"``.  This feature can be used to reduce "
"the number of backslashes needed, to split long strings conveniently "
"across long lines, or even to add comments to parts of strings, for "
"example::"
msgstr ""
"여러 개의 문자열이나 바이트열 리터럴을 (공백으로 분리해서) 여러 개 인접해서 나열하는 것이 허락되고, 그 의미는 이어붙인 것과 "
"같습니다. 각 리터럴이 서로 다른 따옴표를 사용해도 됩니다. 그래서, ``\"hello\" 'world'`` 는 "
"``\"helloworld\"`` 와 동등합니다. 이 기능은 긴 문자열을 편의상 여러 줄로 나눌 때 필요한 역 슬래시를 줄여줍니다. 각"
" 문자열 단위마다 주석을 붙이는 것도 가능합니다. 예를 들어::"

#: ../Doc/reference/lexical_analysis.rst:591
msgid ""
"Note that this feature is defined at the syntactical level, but "
"implemented at compile time.  The '+' operator must be used to "
"concatenate string expressions at run time.  Also note that literal "
"concatenation can use different quoting styles for each component (even "
"mixing raw strings and triple quoted strings), and formatted string "
"literals may be concatenated with plain string literals."
msgstr ""
"이 기능이 문법 수준에서 정의되고는 있지만, 컴파일 시점에 구현됨에 주의해야 합니다. 실행 시간에 문자열 표현을 이어붙이기 위해서는 "
"'+' 연산자를 사용해야 합니다. 리터럴 이어붙이기가 요소별로 다른 따옴표를 사용할 수 있고 (날 문자열과 삼중 따옴표 문자열을 "
"이어붙이는 것조차 가능합니다), 포맷 문자열 리터럴을 보통 문자열 리터럴과 이어붙일 수 있음에 유의해야 합니다."

#: ../Doc/reference/lexical_analysis.rst:607
msgid "Formatted string literals"
msgstr "포맷 문자열 리터럴"

#: ../Doc/reference/lexical_analysis.rst:611
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces "
"``{}``. While other string literals always have a constant value, "
"formatted strings are really expressions evaluated at run time."
msgstr ""
"포맷 문자열 리터럴(:dfn:`formatted string literal`) 또는 :dfn:`f-문자열 (f-string)` 은 "
"``'f'`` 나 ``'F'`` 를 앞에 붙인 문자열 리터럴입니다. 이 문자열은 치환 필드를 포함할 수 있는데, 중괄호 ``{}`` "
"로 구분되는 표현식입니다. 다른 문자열 리터럴이 항상 상숫값을 갖지만, 포맷 문자열 리터럴은 실행시간에 계산되는 표현식입니다."

#: ../Doc/reference/lexical_analysis.rst:617
msgid ""
"Escape sequences are decoded like in ordinary string literals (except "
"when a literal is also marked as a raw string).  After decoding, the "
"grammar for the contents of the string is:"
msgstr ""
"이스케이프 시퀀스는 일반 문자열 리터럴처럼 디코딩됩니다 (동시에 날 문자열인 경우는 예외입니다). 디코딩 후에 문자열의 내용은 다음과 "
"같은 문법을 따릅니다:"

#: ../Doc/reference/lexical_analysis.rst:631
msgid ""
"The parts of the string outside curly braces are treated literally, "
"except that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced "
"with the corresponding single curly brace.  A single opening curly "
"bracket ``'{'`` marks a replacement field, which starts with a Python "
"expression.  After the expression, there may be a conversion field, "
"introduced by an exclamation point ``'!'``.  A format specifier may also "
"be appended, introduced by a colon ``':'``.  A replacement field ends "
"with a closing curly bracket ``'}'``."
msgstr ""
"중괄호 바깥 부분은 일반 리터럴처럼 취급되는데, 이중 중괄호 ``'{{'`` 나 ``'}}'`` 가 대응하는 단일 중괄호로 "
"치환된다는 점만 예외입니다. 하나의 여는 중괄호 ``'{'`` 는 치환 필드를 시작시키는데, 파이썬 표현식이 뒤따릅니다. 표현식 뒤로는 "
"변환(conversion) 필드가 올 수 있는데, 느낌표 ``'!'`` 로 시작합니다. 포맷 지정자(format specifier)도"
" 덧붙일 수 있는데, 콜론 ``':'`` 으로 시작합니다. 치환 필드는 닫는 중괄호 ``'}'`` 로 끝납니다."

#: ../Doc/reference/lexical_analysis.rst:640
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and a :keyword:`lambda` expression must be "
"surrounded by explicit parentheses.  Replacement expressions can contain "
"line breaks (e.g. in triple-quoted strings), but they cannot contain "
"comments.  Each expression is evaluated in the context where the "
"formatted string literal appears, in order from left to right."
msgstr ""
"포맷 문자열 리터럴의 표현식은 괄호로 둘러싸인 일반적인 파이썬 표현식으로 취급되는데, 몇 가지 예외가 있습니다. 빈 표현식은 허락되지 "
"않고, :keyword:`lambda` 표현식은 명시적인 괄호로 둘러싸야 합니다. 치환 표현식은 개행문자를 포함할 수 있으나 (예를 "
"들어, 삼중 따옴표 된 문자열) 주석은 포함할 수 없습니다. 각 표현식은 포맷 문자열 리터럴이 등장한 지점의 문맥에서 왼쪽에서 "
"오른쪽으로 계산됩니다."

#: ../Doc/reference/lexical_analysis.rst:648
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on "
"the result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls "
":func:`ascii`."
msgstr ""
"변환(conversion)이 지정되면, 표현식의 결과가 포매팅 전에 변환됩니다. 변환 ``'!s'`` 는 결과에 :func:`str`"
" 을 호출하고, ``'!r'`` 은 :func:`repr` 을 호출하고, ``'!a'`` 은 :func:`ascii` 를 호출합니다."

#: ../Doc/reference/lexical_analysis.rst:652
msgid ""
"The result is then formatted using the :func:`format` protocol.  The "
"format specifier is passed to the :meth:`__format__` method of the "
"expression or conversion result.  An empty string is passed when the "
"format specifier is omitted.  The formatted result is then included in "
"the final value of the whole string."
msgstr ""
"결과는 :func:`format` 프로토콜로 포매팅합니다. 포맷 지정자는 표현식이나 변환 결과의 :meth:`__format__` "
"메서드 로 전달됩니다. 포맷 지정자가 생략되면 빈 문자열이 전달됩니다. 이제 포맷된 결과가 최종 문자열에 삽입됩니다."

#: ../Doc/reference/lexical_analysis.rst:658
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and :ref:`format "
"specifiers <formatspec>`, but may not include more deeply-nested "
"replacement fields. The :ref:`format specifier mini-language "
"<formatspec>` is the same as that used by the string .format() method."
msgstr ""
"최상위 포맷 지정자는 중첩된 치환 필드들을 포함할 수 있습니다. 이 중첩된 필드들은 그들 자신의 변환 필드와 :ref:`포맷 지정자 "
"<formatspec>`\\를 포함할 수 있지만, 깊이 중첩된 치환 필드들을 포함할 수는 없습니다. :ref:`포맷 지정자 간이 언어 "
"<formatspec>`\\는 문자열 .format() 메서드에서 사용되는 것과 같습니다."

#: ../Doc/reference/lexical_analysis.rst:664
msgid ""
"Formatted string literals may be concatenated, but replacement fields "
"cannot be split across literals."
msgstr "포맷 문자열 리터럴을 이어붙일 수는 있지만, 치환 필드가 여러 리터럴로 쪼개질 수는 없습니다."

#: ../Doc/reference/lexical_analysis.rst:667
msgid "Some examples of formatted string literals::"
msgstr "포맷 문자열 리터럴의 예를 들면::"

#: ../Doc/reference/lexical_analysis.rst:686
msgid ""
"A consequence of sharing the same syntax as regular string literals is "
"that characters in the replacement fields must not conflict with the "
"quoting used in the outer formatted string literal::"
msgstr ""
"일반적인 문자열 리터럴과 같은 문법을 공유하는 것으로 인한 결과는 치환 필드에 사용되는 문자들이 포맷 문자열 리터럴을 감싸는 "
"따옴표와 충돌하지 않아야 한다는 것입니다::"

#: ../Doc/reference/lexical_analysis.rst:693
msgid ""
"Backslashes are not allowed in format expressions and will raise an "
"error::"
msgstr "포맷 표현식에는 역 슬래시를 사용할 수 없고, 사용하면 에러가 발생합니다::"

#: ../Doc/reference/lexical_analysis.rst:698
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr "역 슬래시 이스케이프가 필요한 값을 포함하려면, 임시 변수를 만들면 됩니다."

#: ../Doc/reference/lexical_analysis.rst:705
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do "
"not include expressions."
msgstr "포맷 문자열 리터럴은 독스트링(docstring)으로 사용될 수 없습니다. 표현식이 전혀 없더라도 마찬가집니다."

#: ../Doc/reference/lexical_analysis.rst:716
msgid ""
"See also :pep:`498` for the proposal that added formatted string "
"literals, and :meth:`str.format`, which uses a related format string "
"mechanism."
msgstr ""
"포맷 문자열 리터럴 추가에 대한 제안은 :pep:`498` 을 참조하고, 관련된 포맷 문자열 메커니즘을 사용하는 "
":meth:`str.format` 도 살펴보는 것이 좋습니다."

#: ../Doc/reference/lexical_analysis.rst:723
msgid "Numeric literals"
msgstr "숫자 리터럴"

#: ../Doc/reference/lexical_analysis.rst:729
msgid ""
"There are three types of numeric literals: integers, floating point "
"numbers, and imaginary numbers.  There are no complex literals (complex "
"numbers can be formed by adding a real number and an imaginary number)."
msgstr ""
"숫자 리터럴에는 세 가지 종류가 있습니다: 정수, 실수, 허수. 복소수 리터럴 같은 것은 없습니다 (복소수는 실수와 허수를 더해서 "
"만들어집니다.)"

#: ../Doc/reference/lexical_analysis.rst:733
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is"
" actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"숫자 리터럴이 부호를 포함하지 않는 것에 주의해야 합니다; ``-1`` 과 같은 구문은 일 항 연산자 '``-``' 과 리터럴 "
"``1`` 로 구성된 표현식입니다."

#: ../Doc/reference/lexical_analysis.rst:741
msgid "Integer literals"
msgstr "정수 리터럴"

#: ../Doc/reference/lexical_analysis.rst:743
msgid "Integer literals are described by the following lexical definitions:"
msgstr "정수 리터럴은 다음과 같은 구문 정의로 표현됩니다:"

#: ../Doc/reference/lexical_analysis.rst:757
msgid ""
"There is no limit for the length of integer literals apart from what can "
"be stored in available memory."
msgstr "가용한 메모리에 저장될 수 있는지와는 별개로 정수 리터럴의 길이에 제한은 없습니다."

#: ../Doc/reference/lexical_analysis.rst:760
msgid ""
"Underscores are ignored for determining the numeric value of the literal."
"  They can be used to group digits for enhanced readability.  One "
"underscore can occur between digits, and after base specifiers like "
"``0x``."
msgstr ""
"밑줄은 리터럴의 숫자 값을 결정할 때 고려되지 않습니다. 가독성을 높이기 위해 숫자들을 무리 지을 때 쓸모가 있습니다. 밑줄은 숫자 "
"사이나 ``0x`` 와 같은 진수 지정자(base specifier) 다음에 나올 수 있는데, 한 번에 하나만 사용될 수 있습니다."

#: ../Doc/reference/lexical_analysis.rst:764
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. "
"This is for disambiguation with C-style octal literals, which Python used"
" before version 3.0."
msgstr ""
"0 이 아닌 10진수가 0으로 시작할 수 없음에 주의해야 합니다. 3.0 버전 이전의 파이썬에서 사용한 C 스타일의 8진수 리터럴과 "
"혼동되는 것을 막기 위함입니다."

#: ../Doc/reference/lexical_analysis.rst:768
msgid "Some examples of integer literals::"
msgstr "정수 리터럴의 예를 들면::"

#: ../Doc/reference/lexical_analysis.rst:774
#: ../Doc/reference/lexical_analysis.rst:802
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "리터럴에서 숫자들의 그룹을 표현할 목적으로 밑줄을 허락합니다."

#: ../Doc/reference/lexical_analysis.rst:781
msgid "Floating point literals"
msgstr "실수 리터럴"

#: ../Doc/reference/lexical_analysis.rst:783
msgid ""
"Floating point literals are described by the following lexical "
"definitions:"
msgstr "실수 리터럴은 다음과 같은 구문 정의로 표현됩니다:"

#: ../Doc/reference/lexical_analysis.rst:793
msgid ""
"Note that the integer and exponent parts are always interpreted using "
"radix 10. For example, ``077e010`` is legal, and denotes the same number "
"as ``77e10``. The allowed range of floating point literals is "
"implementation-dependent.  As in integer literals, underscores are "
"supported for digit grouping."
msgstr ""
"정수부와 지수부는 항상 10진법으로 해석된다는 것에 주의해야 합니다. 예를 들어, ``077e010`` 는 올바른 표현이고, "
"``77e10`` 과 같은 숫자를 표현합니다. 실수 리터럴의 허락된 범위는 구현 세부 사항입니다. 정수 리터럴에서와 마찬가지로 밑줄로 "
"숫자들의 묶음을 만드는 것도 지원됩니다."

#: ../Doc/reference/lexical_analysis.rst:798
msgid "Some examples of floating point literals::"
msgstr "실수 리터럴의 몇 가지 예를 듭니다::"

#: ../Doc/reference/lexical_analysis.rst:809
msgid "Imaginary literals"
msgstr "허수 리터럴"

#: ../Doc/reference/lexical_analysis.rst:811
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "허수 리터럴은 다음과 같은 구문 정의로 표현됩니다:"

#: ../Doc/reference/lexical_analysis.rst:816
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and "
"have the same restrictions on their range.  To create a complex number "
"with a nonzero real part, add a floating point number to it, e.g., "
"``(3+4j)``.  Some examples of imaginary literals::"
msgstr ""
"허수 리터럴은 실수부가 0.0인 복소수를 만듭니다. 복소수는 실수와 같은 범위 제약이 적용되는 한 쌍의 실수로 표현됩니다. 0이 아닌 "
"실수부를 갖는 복소수를 만들려면, 실수를 더하면 됩니다. 예를 들어, ``(3+4j)``. 허수 리터럴의 몇 가지 예를 듭니다::"

#: ../Doc/reference/lexical_analysis.rst:828
msgid "Operators"
msgstr "연산자"

#: ../Doc/reference/lexical_analysis.rst:832
msgid "The following tokens are operators:"
msgstr "다음과 같은 토큰들은 연산자입니다:"

#: ../Doc/reference/lexical_analysis.rst:845
msgid "Delimiters"
msgstr "구분자"

#: ../Doc/reference/lexical_analysis.rst:849
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "다음 토큰들은 문법에서 구분자(delimiter)로 기능합니다:"

#: ../Doc/reference/lexical_analysis.rst:858
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. "
"The second half of the list, the augmented assignment operators, serve "
"lexically as delimiters, but also perform an operation."
msgstr ""
"마침표는 실수와 허수 리터럴에서도 등장할 수 있습니다. 연속된 마침표 세 개는 생략부호 리터럴(ellipsis literal)이라는 "
"특별한 의미가 있습니다. 목록 후반의 증분 대입 연산자(augmented assignment operator)들은 구문적으로는 구분자로"
" 기능하지만, 동시에 연산을 수행합니다."

#: ../Doc/reference/lexical_analysis.rst:863
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr "다음의 인쇄되는 ASCII 문자들은 다른 토큰들 일부로서 특별한 의미가 있거나, 그렇지 않으면 구문 분석기에 유의미합니다:"

#: ../Doc/reference/lexical_analysis.rst:870
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional "
"error:"
msgstr ""
"다음의 인쇄되는 ASCII 문자들은 파이썬에서 사용되지 않습니다. 문자열 리터럴과 주석 이외의 곳에서 사용되는 것은 조건 없는 "
"에러입니다:"

#: ../Doc/reference/lexical_analysis.rst:879
msgid "Footnotes"
msgstr "각주"

#: ../Doc/reference/lexical_analysis.rst:880
msgid "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
msgstr "http://www.unicode.org/Public/11.0.0/ucd/NameAliases.txt"
