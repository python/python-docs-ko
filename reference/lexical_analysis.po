# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-23 11:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/reference/lexical_analysis.rst:6
msgid "Lexical analysis"
msgstr "구문 분석"

#: ../Doc/reference/lexical_analysis.rst:10
msgid ""
"A Python program is read by a *parser*.  Input to the parser is a stream "
"of *tokens*, generated by the *lexical analyzer*.  This chapter describes"
" how the lexical analyzer breaks a file into tokens."
msgstr ""
"파이썬 프로그램은 *파서(parser)* 에 의해 읽힌다. 파서의 입력은 *구문 분석기(lexical analyzer)* 가 "
"만들어내는 *토큰(token)* 들의 스트림이다. 이 장에서는 구문 분석기가 어떻게 파일을 토큰들로 분해하는지 설명한다."

#: ../Doc/reference/lexical_analysis.rst:14
msgid ""
"Python reads program text as Unicode code points; the encoding of a "
"source file can be given by an encoding declaration and defaults to "
"UTF-8, see :pep:`3120` for details.  If the source file cannot be "
"decoded, a :exc:`SyntaxError` is raised."
msgstr ""
"파이썬은 프로그램 텍스트를 유니코드 코드값으로 읽는다; 소스 파일의 인코딩은 인코딩 선언을 통해 지정될 수 있고, 기본값은 "
"UTF-8이다. 자세한 내용은 :pep:`3120` 에 나온다. 소스 파일을 디코딩할 수 없을 때는 "
":exc:`SyntaxError` 가 발생한다."

#: ../Doc/reference/lexical_analysis.rst:23
msgid "Line structure"
msgstr "줄 구조(Line structure)"

#: ../Doc/reference/lexical_analysis.rst:27
msgid "A Python program is divided into a number of *logical lines*."
msgstr "파이썬 프로그램은 여러 개의 *논리적인 줄(logical lines)* 들로 나뉜다."

#: ../Doc/reference/lexical_analysis.rst:33
msgid "Logical lines"
msgstr "논리적인 줄"

#: ../Doc/reference/lexical_analysis.rst:37
msgid ""
"The end of a logical line is represented by the token NEWLINE.  "
"Statements cannot cross logical line boundaries except where NEWLINE is "
"allowed by the syntax (e.g., between statements in compound statements). "
"A logical line is constructed from one or more *physical lines* by "
"following the explicit or implicit *line joining* rules."
msgstr ""
"논리적인 줄의 끝은 NEWLINE 토큰으로 표현된다. 문법이 허락하지 않는 이상 (예를 들어 복합문에서 문장들 사이) 문장은 "
"논리적인 줄 간의 경계를 가로지를 수 없다. 논리적인 줄은 명시적이거나 묵시적인 *줄 결합(line joining)* 규칙에 따라 "
"하나 이상의 *물리적인 줄(physical lines)* 들로 구성된다."

#: ../Doc/reference/lexical_analysis.rst:47
msgid "Physical lines"
msgstr "물리적인 줄"

#: ../Doc/reference/lexical_analysis.rst:49
msgid ""
"A physical line is a sequence of characters terminated by an end-of-line "
"sequence.  In source files, any of the standard platform line termination"
" sequences can be used - the Unix form using ASCII LF (linefeed), the "
"Windows form using the ASCII sequence CR LF (return followed by "
"linefeed), or the old Macintosh form using the ASCII CR (return) "
"character.  All of these forms can be used equally, regardless of "
"platform."
msgstr ""
"물리적인 줄은 줄의 끝을 나타내는 시퀀스로 끝나는 문자들의 시퀀스다. 소스 파일에는 플랫폼들의 표준 줄 종료 시퀀스들이 모두 사용될 "
"수 있다 - ASCII LF (개행문자)를 사용하는 유닉스 형, ASCII 시퀀스 CR LF(캐리지 리턴 다음에 오는 개행 문자)를"
" 사용하는 윈도우 형, ASCII CR(캐리지 리턴)을 사용하는 예전의 매킨토시 형. 이 형태들은 플랫폼의 종류와 관계없이 "
"동등하게 사용할 수 있다."

#: ../Doc/reference/lexical_analysis.rst:56
msgid ""
"When embedding Python, source code strings should be passed to Python "
"APIs using the standard C conventions for newline characters (the ``\\n``"
" character, representing ASCII LF, is the line terminator)."
msgstr ""
"파이썬을 내장할 때는, 소스 코드 문자열은 반드시 줄 종료 문자에 표준 C 관행(ASCII LF를 표현하는 ``\\n`` 문자로 "
"줄이 종료된다)을 적용해서 파이썬 API로 전달되어야 한다."

#: ../Doc/reference/lexical_analysis.rst:64
msgid "Comments"
msgstr "주석"

#: ../Doc/reference/lexical_analysis.rst:68
msgid ""
"A comment starts with a hash character (``#``) that is not part of a "
"string literal, and ends at the end of the physical line.  A comment "
"signifies the end of the logical line unless the implicit line joining "
"rules are invoked. Comments are ignored by the syntax; they are not "
"tokens."
msgstr ""
"주석은 문자열 리터럴에 포함되지 않는 해시 문자(``#``)로 시작하고 물리적인 줄의 끝에서 끝난다. 묵시적인 줄 결합 규칙이 "
"유효하지 않은 이상, 주석은 논리적인 줄을 종료시킨다. 주석은 문법이 무시한다; 토큰으로 만들어지지 않는다."

#: ../Doc/reference/lexical_analysis.rst:77
msgid "Encoding declarations"
msgstr "인코딩 선언"

#: ../Doc/reference/lexical_analysis.rst:81
msgid ""
"If a comment in the first or second line of the Python script matches the"
" regular expression ``coding[=:]\\s*([-\\w.]+)``, this comment is "
"processed as an encoding declaration; the first group of this expression "
"names the encoding of the source code file. The encoding declaration must"
" appear on a line of its own. If it is the second line, the first line "
"must also be a comment-only line. The recommended forms of an encoding "
"expression are ::"
msgstr ""
"파이썬 스크립트의 첫 번 째나 두 번째 줄에 있는 주석이 정규식 ``coding[=:]\\s*([-\\w.]+)`` 과 매치되면, "
"이 주석은 인코딩 선언으로 처리된다. 이 정규식의 첫 번째 그룹은 소스 코드 파일의 인코딩 이름을 지정한다. 인코딩 선언은 줄 전체에"
" 홀로 나와야 한다. 만약 두 번째 줄이라면, 첫 번째 줄 역시 주석만 있어야 한다. 인코딩 선언의 권장 형태는 두 개다. 하나는 "
"::"

#: ../Doc/reference/lexical_analysis.rst:90
msgid "which is recognized also by GNU Emacs, and ::"
msgstr "인데 GNU Emacs에서도 인식된다. 다른 하나는 ::"

#: ../Doc/reference/lexical_analysis.rst:94
msgid "which is recognized by Bram Moolenaar's VIM."
msgstr "인데 Bram Moolenaar 의 VIM에서 인식된다."

#: ../Doc/reference/lexical_analysis.rst:96
msgid ""
"If no encoding declaration is found, the default encoding is UTF-8.  In "
"addition, if the first bytes of the file are the UTF-8 byte-order mark "
"(``b'\\xef\\xbb\\xbf'``), the declared file encoding is UTF-8 (this is "
"supported, among others, by Microsoft's :program:`notepad`)."
msgstr ""
"인코딩 선언이 발견되지 않으면 기본 인코딩은 UTF-8이다. 여기에 더해, 파일의 처음이 UTF-8 BOM "
"(``b'\\xef\\xbb\\xbf'``)이면 파일 인코딩이 UTF-8으로 선언된 것으로 본다. (이 방식은 마이크로소프트의 "
":program:`notepad` 에서 지원된다.)"

#: ../Doc/reference/lexical_analysis.rst:101
msgid ""
"If an encoding is declared, the encoding name must be recognized by "
"Python. The encoding is used for all lexical analysis, including string "
"literals, comments and identifiers."
msgstr ""
"인코딩이 선언되면, 인코딩 이름은 파이썬이 인식할 수 있어야 한다. 인코딩은 문자열 리터럴, 주석, 식별자를 포함한 모든 "
"구문 분석에서 모두 사용된다."

#: ../Doc/reference/lexical_analysis.rst:111
msgid "Explicit line joining"
msgstr "명시적인 줄 결합"

#: ../Doc/reference/lexical_analysis.rst:115
msgid ""
"Two or more physical lines may be joined into logical lines using "
"backslash characters (``\\``), as follows: when a physical line ends in a"
" backslash that is not part of a string literal or comment, it is joined "
"with the following forming a single logical line, deleting the backslash "
"and the following end-of-line character.  For example::"
msgstr ""
"둘 이상의 물리적인 줄은 역 슬래시 문자(``\\``)를 사용해서 논리적인 줄로 결합할 수 있다: 물리적인 줄이 문자열 리터럴이나 주석의 "
"일부가 아닌 역 슬래시 문자로 끝나면, 역 슬래시와 뒤따르는 개행 문자가 제거된 채로, 현재 만들어지고 있는 논리적인 줄에 합쳐진다. "
"예를 들어::"

#: ../Doc/reference/lexical_analysis.rst:126
msgid ""
"A line ending in a backslash cannot carry a comment.  A backslash does "
"not continue a comment.  A backslash does not continue a token except for"
" string literals (i.e., tokens other than string literals cannot be split"
" across physical lines using a backslash).  A backslash is illegal "
"elsewhere on a line outside a string literal."
msgstr ""
"역 슬래시로 끝나는 줄은 주석이 포함될 수 없다. 역 슬래시는 주석을 결합하지 못한다. 역 슬래시는 문자열 리터럴을 제외한 어떤 토큰도 "
"결합하지 못한다 (즉, 문자열 리터럴 이외의 어떤 토큰도 역 슬래시를 사용해서 두 줄에 나누어 기록할 수 없다.). 문자열 리터럴 "
"밖에 있는 역 슬래시가 앞에서 언급한 장소 이외의 곳에 등장하는 것은 문법에 어긋난다."

#: ../Doc/reference/lexical_analysis.rst:136
msgid "Implicit line joining"
msgstr "묵시적인 줄 결합"

#: ../Doc/reference/lexical_analysis.rst:138
msgid ""
"Expressions in parentheses, square brackets or curly braces can be split "
"over more than one physical line without using backslashes. For example::"
msgstr ""
"괄호(``()``), 꺾쇠괄호(``[]``), 중괄호(``{}``)가 사용되는 표현은 역 슬래시 없이도 여러 개의 물리적인 줄로 나눌 "
"수 있다. 예를 들어::"

#: ../Doc/reference/lexical_analysis.rst:146
msgid ""
"Implicitly continued lines can carry comments.  The indentation of the "
"continuation lines is not important.  Blank continuation lines are "
"allowed. There is no NEWLINE token between implicit continuation lines.  "
"Implicitly continued lines can also occur within triple-quoted strings "
"(see below); in that case they cannot carry comments."
msgstr ""
"묵시적으로 이어지는 줄들은 주석을 포함할 수 있다. 이어지는 줄들의 들여쓰기는 중요하지 않다. 중간에 빈 줄이 들어가도 된다. "
"묵시적으로 줄 결합하는 줄 들 간에는 NEWLINE 토큰이 만들어지지 않는다. 묵시적으로 이어지는 줄들은 삼중 따옴표 된 "
"문자열들에서도 등장할 수 있는데 (아래를 보라), 이 경우는 주석이 포함될 수 없다."

#: ../Doc/reference/lexical_analysis.rst:156
msgid "Blank lines"
msgstr "빈 줄"

#: ../Doc/reference/lexical_analysis.rst:160
msgid ""
"A logical line that contains only spaces, tabs, formfeeds and possibly a "
"comment, is ignored (i.e., no NEWLINE token is generated).  During "
"interactive input of statements, handling of a blank line may differ "
"depending on the implementation of the read-eval-print loop.  In the "
"standard interactive interpreter, an entirely blank logical line (i.e. "
"one containing not even whitespace or a comment) terminates a multi-line "
"statement."
msgstr ""
"스페이스, 탭, 폼 피드(formfeed) 와 주석만으로 구성된 논리적인 줄은 무시된다. (즉 NEWLINE 토큰이 만들어지지 않는다.)"
" 대화형으로 문장이 입력되는 도중에는 빈 줄의 처리가 REPL 구현에 따라 달라질 수 있다. 표준 대화형 인터프리터에서는, 완전히 "
"빈 줄(즉 공백이나 주석조차 없는 것)은 다중 행 문장을 종료시킨다."

#: ../Doc/reference/lexical_analysis.rst:171
msgid "Indentation"
msgstr "들여쓰기"

#: ../Doc/reference/lexical_analysis.rst:175
msgid ""
"Leading whitespace (spaces and tabs) at the beginning of a logical line "
"is used to compute the indentation level of the line, which in turn is "
"used to determine the grouping of statements."
msgstr ""
"논리적인 줄의 제일 앞에 오는 공백(스페이스와 탭)은 줄의 들여쓰기 수준을 계산하는 데 사용되고, 이는 다시 문장들의 묶음을 결정하는 데"
" 사용되게 된다."

#: ../Doc/reference/lexical_analysis.rst:179
msgid ""
"Tabs are replaced (from left to right) by one to eight spaces such that "
"the total number of characters up to and including the replacement is a "
"multiple of eight (this is intended to be the same rule as used by Unix)."
"  The total number of spaces preceding the first non-blank character then"
" determines the line's indentation.  Indentation cannot be split over "
"multiple physical lines using backslashes; the whitespace up to the first"
" backslash determines the indentation."
msgstr ""
"탭은 (왼쪽에서 오른쪽으로) 1~8개의 스페이스로 변환되는데, 치환된 후의 총 스페이스 문자 수가 8의 배수가 되도록 "
"맞춘다. (유닉스에서 사용되는 규칙에 맞추려는 것이다.) 첫 번째 비 공백 문자 앞에 나오는 공백의 총수가 줄의 들여쓰기를 결정한다. "
"들여쓰기는 역 슬래시를 사용해서 여러 개의 물리적인 줄로 나눠질 수 없다; 첫 번째 역 슬래시 이전의 공백이 들여쓰기를 결정한다."

#: ../Doc/reference/lexical_analysis.rst:187
msgid ""
"Indentation is rejected as inconsistent if a source file mixes tabs and "
"spaces in a way that makes the meaning dependent on the worth of a tab in"
" spaces; a :exc:`TabError` is raised in that case."
msgstr ""
"소스 파일이 탭과 스페이스를 섞어 쓰는 경우, 탭이 몇 개의 스페이스에 해당하는지에 따라 다르게 해석될 수 있으면 "
":exc:`TabError` 를 일으킨다."

#: ../Doc/reference/lexical_analysis.rst:191
msgid ""
"**Cross-platform compatibility note:** because of the nature of text "
"editors on non-UNIX platforms, it is unwise to use a mixture of spaces "
"and tabs for the indentation in a single source file.  It should also be "
"noted that different platforms may explicitly limit the maximum "
"indentation level."
msgstr ""
"**크로스-플랫폼 호환성 유의 사항:** UNIX 이외의 플랫폼에서 편집기들이 동작하는 방식 때문에, 하나의 파일 내에서 들여쓰기를"
" 위해 탭과 스페이스를 섞어 쓰는 것은 현명한 선택이 아니다. 다른 플랫폼들에서는 최대 들여쓰기 수준에 제한이 있을 수도 있다는 점도"
" 주의해야 한다."

#: ../Doc/reference/lexical_analysis.rst:196
msgid ""
"A formfeed character may be present at the start of the line; it will be "
"ignored for the indentation calculations above.  Formfeed characters "
"occurring elsewhere in the leading whitespace have an undefined effect "
"(for instance, they may reset the space count to zero)."
msgstr ""
"폼 피드 문자는 줄의 처음에 나올 수 있다; 앞서 설명한 들여쓰기 수준 계산에서는 무시된다. 페이지 넘김 문자 앞에 공백이나 탭이 있는 "
"경우는 정의되지 않은 효과를 줄 수 있다 (가령, 스페이스 수가 0으로 초기화될 수 있다)."

#: ../Doc/reference/lexical_analysis.rst:203
msgid ""
"The indentation levels of consecutive lines are used to generate INDENT "
"and DEDENT tokens, using a stack, as follows."
msgstr "연속된 줄의 들여쓰기 수준은, 스택을 사용해서, 다음과 같은 방법으로 INDENT와 DEDENT 토큰을 만드는 데 사용된다."

#: ../Doc/reference/lexical_analysis.rst:206
msgid ""
"Before the first line of the file is read, a single zero is pushed on the"
" stack; this will never be popped off again.  The numbers pushed on the "
"stack will always be strictly increasing from bottom to top.  At the "
"beginning of each logical line, the line's indentation level is compared "
"to the top of the stack. If it is equal, nothing happens. If it is "
"larger, it is pushed on the stack, and one INDENT token is generated.  If"
" it is smaller, it *must* be one of the numbers occurring on the stack; "
"all numbers on the stack that are larger are popped off, and for each "
"number popped off a DEDENT token is generated.  At the end of the file, a"
" DEDENT token is generated for each number remaining on the stack that is"
" larger than zero."
msgstr ""
"파일의 첫 줄을 읽기 전에 0하나를 스택에 넣는다(push); 이 값은 다시 꺼내는(pop) 일이 없다. 스택에 넣는 값은 항상 "
"스택의 아래에서 위로 올라갈 때 단조 증가한다. 각 논리적인 줄의 처음에서 줄의 들여쓰기 수준이 스택의 가장 위에 있는 값과 비교된다."
" 같다면 아무런 일도 일어나지 않는다. 더 크다면 그 값을 스택에 넣고 하나의 INDENT 토큰을 만든다. 더 작다면 이 값은 "
"스택에 있는 값 중 하나여만 한다. 이 값보다 큰 모든 스택의 값들을 꺼내고(pop), 꺼낸 횟수만큼의 DEDENT 토큰을 만든다."
" 파일의 끝에서, 스택에 남아있는 0보다 큰 값의 개수만큼 DEDENT 토큰을 만든다."

#: ../Doc/reference/lexical_analysis.rst:217
msgid ""
"Here is an example of a correctly (though confusingly) indented piece of "
"Python code::"
msgstr "여기에 (혼란스럽다 할지라도) 올바르게 들여쓰기 된 파이썬 코드 조각이 있다::"

#: ../Doc/reference/lexical_analysis.rst:232
msgid "The following example shows various indentation errors::"
msgstr "다음 예는 여러 가지 들여쓰기 에러를 보여준다::"

#: ../Doc/reference/lexical_analysis.rst:242
msgid ""
"(Actually, the first three errors are detected by the parser; only the "
"last error is found by the lexical analyzer --- the indentation of "
"``return r`` does not match a level popped off the stack.)"
msgstr ""
"(사실, 처음 세 개의 에러는 파서가 감지한다. 단지 마지막 에러만 구문 분석기가 감지한다. --- ``return r`` 의 "
"들여쓰기가 스택에 있는 값과 일치하지 않는다.)"

#: ../Doc/reference/lexical_analysis.rst:250
msgid "Whitespace between tokens"
msgstr "토큰 사이의 공백"

#: ../Doc/reference/lexical_analysis.rst:252
msgid ""
"Except at the beginning of a logical line or in string literals, the "
"whitespace characters space, tab and formfeed can be used interchangeably"
" to separate tokens.  Whitespace is needed between two tokens only if "
"their concatenation could otherwise be interpreted as a different token "
"(e.g., ab is one token, but a b is two tokens)."
msgstr ""
"논리적인 줄의 처음과 문자열 리터럴을 제외하고, 공백 문자인 스페이스, 탭, 폼 피드는 토큰을 분리하기 위해 섞어 쓸 수 있다. 두 "
"토큰을 붙여 쓸 때 다른 토큰으로 해석될 수 있는 경우만 토큰 사이에 공백이 필요하다. (예를 들어, ab 는 하나의 토큰이지만,"
" a b 는 두 개의 토큰이다.)"

#: ../Doc/reference/lexical_analysis.rst:262
msgid "Other tokens"
msgstr "다른 토큰들"

#: ../Doc/reference/lexical_analysis.rst:264
msgid ""
"Besides NEWLINE, INDENT and DEDENT, the following categories of tokens "
"exist: *identifiers*, *keywords*, *literals*, *operators*, and "
"*delimiters*. Whitespace characters (other than line terminators, "
"discussed earlier) are not tokens, but serve to delimit tokens. Where "
"ambiguity exists, a token comprises the longest possible string that "
"forms a legal token, when read from left to right."
msgstr ""
"NEWLINE, INDENT, DEDENT 와는 별도로, 다음과 같은 유형의 토큰들이 존재한다: *식별자(identifier)*, "
"*키워드(keyword)*, *리터럴(literal)*, *연산자(operator)*, *구분자(delimiter)*. (앞에서 "
"살펴본 줄 종료 이외의) 공백 문자들은 토큰이 아니지만, 토큰을 분리하는 역할을 담당한다. 모호할 경우, 왼쪽에서 오른쪽으로 읽을 "
"때, 하나의 토큰은 올바르고 가능한 한 최대 길이의 문자열로 구성되는 것을 선호한다."

#: ../Doc/reference/lexical_analysis.rst:274
msgid "Identifiers and keywords"
msgstr "식별자와 키워드"

#: ../Doc/reference/lexical_analysis.rst:278
msgid ""
"Identifiers (also referred to as *names*) are described by the following "
"lexical definitions."
msgstr "식별자 (*이름(name)* 이라고도 한다) 은 다음과 같은 구문 정의로 기술된다."

#: ../Doc/reference/lexical_analysis.rst:281
msgid ""
"The syntax of identifiers in Python is based on the Unicode standard "
"annex UAX-31, with elaboration and changes as defined below; see also "
":pep:`3131` for further details."
msgstr ""
"파이썬에서 식별자의 문법은 유니코드 표준 부속서 UAX-31 에 기반을 두는데, 여기에 덧붙이거나 바꾼 내용은 아래에서 정의한다. 좀 더"
" 상세한 내용은 :pep:`3131` 에서 찾을 수 있다."

#: ../Doc/reference/lexical_analysis.rst:285
msgid ""
"Within the ASCII range (U+0001..U+007F), the valid characters for "
"identifiers are the same as in Python 2.x: the uppercase and lowercase "
"letters ``A`` through ``Z``, the underscore ``_`` and, except for the "
"first character, the digits ``0`` through ``9``."
msgstr ""
"ASCII 범위 (U+0001..U+007F) 내에서, 올바른 식별자 문자는 파이썬 2.x 와 같다: ``A`` 에서 ``Z``"
" 범위의 대문자와 소문자, 밑줄 ``_``, 첫 문자를 제외하고, 숫자 ``0`` 에서 ``9``. "

#: ../Doc/reference/lexical_analysis.rst:290
msgid ""
"Python 3.0 introduces additional characters from outside the ASCII range "
"(see :pep:`3131`).  For these characters, the classification uses the "
"version of the Unicode Character Database as included in the "
":mod:`unicodedata` module."
msgstr ""
"파이썬 3.0은 ASCII 범위 밖의 문자들을 도입한다 (:pep:`3131` 참조). 이 문자들의 경우, "
":mod:`unicodedata` 모듈에 포함된 버전의 유니코드 문자 데이터베이스에 따라 분류된다."

#: ../Doc/reference/lexical_analysis.rst:294
msgid "Identifiers are unlimited in length.  Case is significant."
msgstr "식별자는 길이에 제한이 없고, 케이스(case)는 구분된다."

#: ../Doc/reference/lexical_analysis.rst:303
msgid "The Unicode category codes mentioned above stand for:"
msgstr "위에서 언급한 유니코드 카테고리 코드들의 의미는 이렇다:"

#: ../Doc/reference/lexical_analysis.rst:305
msgid "*Lu* - uppercase letters"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:306
msgid "*Ll* - lowercase letters"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:307
msgid "*Lt* - titlecase letters"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:308
msgid "*Lm* - modifier letters"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:309
msgid "*Lo* - other letters"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:310
msgid "*Nl* - letter numbers"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:311
msgid "*Mn* - nonspacing marks"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:312
msgid "*Mc* - spacing combining marks"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:313
msgid "*Nd* - decimal numbers"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:314
msgid "*Pc* - connector punctuations"
msgstr ""

#: ../Doc/reference/lexical_analysis.rst:315
msgid ""
"*Other_ID_Start* - explicit list of characters in `PropList.txt "
"<http://www.unicode.org/Public/9.0.0/ucd/PropList.txt>`_ to support "
"backwards compatibility"
msgstr ""
"*Other_ID_Start* - 하위 호환성 지원을 위해 `PropList.txt "
"<http://www.unicode.org/Public/9.0.0/ucd/PropList.txt>`_ 에서 명시적으로 나열된 문자들"

#: ../Doc/reference/lexical_analysis.rst:318
msgid "*Other_ID_Continue* - likewise"
msgstr "*Other_ID_Continue* - 마찬가지"

#: ../Doc/reference/lexical_analysis.rst:320
msgid ""
"All identifiers are converted into the normal form NFKC while parsing; "
"comparison of identifiers is based on NFKC."
msgstr "모든 식별자는 파서에 의해 NFKC 정규화 형식으로 변환되고, 식별자의 비교는 NFKC 에 기반을 둔다."

#: ../Doc/reference/lexical_analysis.rst:323
msgid ""
"A non-normative HTML file listing all valid identifier characters for "
"Unicode 4.1 can be found at https://www.dcl.hpi.uni-"
"potsdam.de/home/loewis/table-3131.html."
msgstr ""
"유니코드 4.1의 올바른 식별자 문자들의 비규범적인 목록을 HTML 파일로 정리한 문서를 https://www.dcl.hpi"
".uni-potsdam.de/home/loewis/table-3131.html 에서 열람할 수 있다."

#: ../Doc/reference/lexical_analysis.rst:331
msgid "Keywords"
msgstr "키워드"

#: ../Doc/reference/lexical_analysis.rst:337
msgid ""
"The following identifiers are used as reserved words, or *keywords* of "
"the language, and cannot be used as ordinary identifiers.  They must be "
"spelled exactly as written here:"
msgstr ""
"다음 식별자들은 예약어, 또는 언어의 키워드, 로 사용되고, 일반적인 식별자로 사용될 수 없다. 여기 쓰여 있는 것과 정확히 같게 "
"사용되어야 한다:"

#: ../Doc/reference/lexical_analysis.rst:354
msgid "Reserved classes of identifiers"
msgstr "식별자의 예약 영역"

#: ../Doc/reference/lexical_analysis.rst:356
msgid ""
"Certain classes of identifiers (besides keywords) have special meanings."
"  These classes are identified by the patterns of leading and trailing "
"underscore characters:"
msgstr "(키워드와는 별개로) 어떤 부류의 식별자들은 특별한 의미가 있다. 이 부류의 식별자들은 시작과 끝의 밑줄 문자 패턴으로 구분된다:"

#: ../Doc/reference/lexical_analysis.rst:370
msgid "``_*``"
msgstr "``_*``"

#: ../Doc/reference/lexical_analysis.rst:361
msgid ""
"Not imported by ``from module import *``.  The special identifier ``_`` "
"is used in the interactive interpreter to store the result of the last "
"evaluation; it is stored in the :mod:`builtins` module.  When not in "
"interactive mode, ``_`` has no special meaning and is not defined. See "
"section :ref:`import`."
msgstr ""
"``from module import *`` 에 의해 임포트되지 않는다. 특별한 식별자 ``_`` 는 대화형 인터프리터에서 마지막에 "
"실행한 결과의 값을 저장하는 용도로 사용된다; :mod:`builtins` 모듈에 저장된다. 대화형 모드가 아닐 경우 ``_`` 는"
" 특별한 의미가 없고, 정의되지도 않는다. :ref:`import` 섹션을 보라."

#: ../Doc/reference/lexical_analysis.rst:368
msgid ""
"The name ``_`` is often used in conjunction with internationalization; "
"refer to the documentation for the :mod:`gettext` module for more "
"information on this convention."
msgstr ""
"이름 ``_`` 은 종종 국제화(internationalization)와 관련되어 사용된다. 이 관례에 관해서는 "
":mod:`gettext` 모듈의 문서를 참조하라."

#: ../Doc/reference/lexical_analysis.rst:378
msgid "``__*__``"
msgstr "``__*__``"

#: ../Doc/reference/lexical_analysis.rst:373
msgid ""
"System-defined names. These names are defined by the interpreter and its "
"implementation (including the standard library).  Current system names "
"are discussed in the :ref:`specialnames` section and elsewhere.  More "
"will likely be defined in future versions of Python.  *Any* use of "
"``__*__`` names, in any context, that does not follow explicitly "
"documented use, is subject to breakage without warning."
msgstr ""
"시스템 정의 이름. 이 이름들은 인터프리터와 그 구현 (표준 라이브러리를 포함한다)이 정의한다. 현재 정의된 시스템 이름은 "
":ref:`specialnames` 섹션과 그 외의 곳에서 논의된다. 파이썬의 미래 버전에서는 더 많은 것들이 정의될 가능성이 "
"크다. 어떤 문맥에서건, 명시적으로 문서로 만들어진 사용법을 벗어나는 ``__*__`` 이름의 *모든* 사용은, 경고 없이 손상될 수 "
"있다."

#: ../Doc/reference/lexical_analysis.rst:385
msgid "``__*``"
msgstr "``__*``"

#: ../Doc/reference/lexical_analysis.rst:381
msgid ""
"Class-private names.  Names in this category, when used within the "
"context of a class definition, are re-written to use a mangled form to "
"help avoid name clashes between \"private\" attributes of base and "
"derived classes. See section :ref:`atom-identifiers`."
msgstr ""
"클래스-비공개 이름. 이 부류의 이름들을 클래스 정의 문맥에서 사용하면 뒤섞인 형태로 변형된다. 부모 클래스와 자식 클래스의 "
"\"비공개(private)\" 어트리뷰트 간의 이름 충돌을 피하기 위함이다. :ref:`atom-identifiers` 섹션을 보라."

#: ../Doc/reference/lexical_analysis.rst:390
msgid "Literals"
msgstr "리터럴"

#: ../Doc/reference/lexical_analysis.rst:394
msgid "Literals are notations for constant values of some built-in types."
msgstr "리터럴(literal)은 몇몇 내장형들의 상숫값을 위한 표기법이다."

#: ../Doc/reference/lexical_analysis.rst:400
msgid "String and Bytes literals"
msgstr "문자열과 바이트열 리터럴"

#: ../Doc/reference/lexical_analysis.rst:404
msgid "String literals are described by the following lexical definitions:"
msgstr "문자열 리터럴은 다음과 같은 구문 정의로 기술된다:"

#: ../Doc/reference/lexical_analysis.rst:429
msgid ""
"One syntactic restriction not indicated by these productions is that "
"whitespace is not allowed between the :token:`stringprefix` or "
":token:`bytesprefix` and the rest of the literal. The source character "
"set is defined by the encoding declaration; it is UTF-8 if no encoding "
"declaration is given in the source file; see section :ref:`encodings`."
msgstr ""
"이 생성 규칙이 보여주지 못하는 한 가지 문법적 제약은 :token:`stringprefix` 나 "
":token:`bytesprefix` 와 리터럴의 나머지 부분 사이에 공백이 허락되지 않는다는 것이다. 소스 문자 집합은 인코딩 "
"선언으로 정의된다; 소스 파일에 인코딩 선언이 없으면 UTF-8이다. :ref:`encodings` 섹션을 보라."

#: ../Doc/reference/lexical_analysis.rst:437
msgid ""
"In plain English: Both types of literals can be enclosed in matching "
"single quotes (``'``) or double quotes (``\"``).  They can also be "
"enclosed in matching groups of three single or double quotes (these are "
"generally referred to as *triple-quoted strings*).  The backslash "
"(``\\``) character is used to escape characters that otherwise have a "
"special meaning, such as newline, backslash itself, or the quote "
"character."
msgstr ""
"쉬운 말로 하자면, 두 가지 리터럴은 한 쌍의 작은따옴표(``'``) 나 큰따옴표(``\"``)로 둘러싸일 수 있다. 또한, 둘 "
"다 한 쌍의 삼중 작은따옴표나 큰따옴표로 둘러싸일 수도 있다 (이것들은 보통 *삼중 따옴표 된 문자열* 이라고 불린다). "
"역 슬래시(``\\``) 문자는 홀로 쓰이면 특별한 의미가 있는 문자들을 이스케이핑할 때 사용되는데, 개행문자, 역 슬래시 자신, "
"따옴표 문자가 그것이다."

#: ../Doc/reference/lexical_analysis.rst:444
msgid ""
"Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce "
"an instance of the :class:`bytes` type instead of the :class:`str` type."
"  They may only contain ASCII characters; bytes with a numeric value of "
"128 or greater must be expressed with escapes."
msgstr ""
"바이트열(bytes) 리터럴은 항상 ``'b'`` 나 ``'B'`` 를 앞에 붙인다; :class:`str` 형의 인스턴스 대신 "
":class:`bytes` 형의 인스턴스를 만든다. 오직 ASCII 문자들만 포함할 수 있다. 코드값이 128보다 크거나 같은 "
"값들은 반드시 이스케이핑으로 표현되어야 한다."

#: ../Doc/reference/lexical_analysis.rst:449
msgid ""
"Both string and bytes literals may optionally be prefixed with a letter "
"``'r'`` or ``'R'``; such strings are called :dfn:`raw strings` and treat "
"backslashes as literal characters.  As a result, in string literals, "
"``'\\U'`` and ``'\\u'`` escapes in raw strings are not treated specially."
" Given that Python 2.x's raw unicode literals behave differently than "
"Python 3.x's the ``'ur'`` syntax is not supported."
msgstr ""
"문자열과 바이트열 리터럴 모두 선택적으로 ``'r'`` 이나 ``'R'`` 문자를 앞에 붙일 수 있다. 이런 문자열을 날 "
"문자열(:dfn:`raw strings`) 이라고 하는데, 역 슬래시를 평범한 문자로 취급한다. 결과적으로, 문자열 리터럴에서, 날 "
"문자열에 있는 ``'\\U'`` 와 ``'\\u'`` 이스케이프는 특별하게 처리되지 않는다. 파이썬 2.x의 날 유니코드 리터럴이 "
"파이썬 3.x와 다르게 동작한다는 것을 고려해서, ``'ur'`` 문법은 지원되지 않는다."

#: ../Doc/reference/lexical_analysis.rst:456
msgid ""
"The ``'rb'`` prefix of raw bytes literals has been added as a synonym of "
"``'br'``."
msgstr "날 바이트열 리터럴의 ``'br'`` 와 같은 의미가 있는 ``'rb'`` 접두어가 추가되었다."

#: ../Doc/reference/lexical_analysis.rst:460
msgid ""
"Support for the unicode legacy literal (``u'value'``) was reintroduced to"
" simplify the maintenance of dual Python 2.x and 3.x codebases. See "
":pep:`414` for more information."
msgstr ""
"파이썬 2.x 와 3.x 에서 동시에 지원하는 코드들의 유지보수를 단순화하기 위해 예전에 사용되던 유니코드 리터럴 "
"(``u'value'``)이 다시 도입되었다. 자세한 정보는 :pep:`414` 에 나온다."

#: ../Doc/reference/lexical_analysis.rst:465
msgid ""
"A string literal with ``'f'`` or ``'F'`` in its prefix is a "
":dfn:`formatted string literal`; see :ref:`f-strings`.  The ``'f'`` may "
"be combined with ``'r'``, but not with ``'b'`` or ``'u'``, therefore raw "
"formatted strings are possible, but formatted bytes literals are not."
msgstr ""
"``'f'`` 나 ``'F'`` 를 접두어로 갖는 문자열 리터럴은 포맷 문자열 리터럴(:dfn:`formatted string "
"literal`)이다; :ref:`f-strings` 을 보라. ``'f'`` 는 ``'r'`` 과 결합할 수 있다, 하지만, "
"``'b'`` 나 ``'u'`` 와는 결합할 수 없다. 따라서 날 포맷 문자열은 가능하지만, 포맷 바이트열 리터럴은 불가능하다."

#: ../Doc/reference/lexical_analysis.rst:470
msgid ""
"In triple-quoted literals, unescaped newlines and quotes are allowed (and"
" are retained), except that three unescaped quotes in a row terminate the"
" literal.  (A \"quote\" is the character used to open the literal, i.e. "
"either ``'`` or ``\"``.)"
msgstr ""
"삼중 따옴표 된 리터럴에서, 세 개의 이스케이핑 되지 않은 개행 문자와 따옴표가 허락된다 (그리고 유지된다). 예외는 한 줄에 세 개의 "
"이스케이핑 되지 않은 따옴표가 나오는 것인데, 리터럴을 종료시킨다. (\"따옴표\"는 리터럴을 시작하는데 사용한 문자다. 즉, "
"``'`` 나 ``\"``)"

#: ../Doc/reference/lexical_analysis.rst:476
msgid ""
"Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in "
"string and bytes literals are interpreted according to rules similar to "
"those used by Standard C.  The recognized escape sequences are:"
msgstr ""
"``'r'`` 나 ``'R'`` 접두어가 붙지 않은 이상, 문자열과 바이트열 리터럴에 포함된 이스케이프 시퀀스는 표준 C에서 "
"사용된 것과 비슷한 규칙으로 해석된다. 인식되는 이스케이프 시퀀스는 이렇다:"

#: ../Doc/reference/lexical_analysis.rst:481
#: ../Doc/reference/lexical_analysis.rst:514
msgid "Escape Sequence"
msgstr "이스케이프 시퀀스"

#: ../Doc/reference/lexical_analysis.rst:481
#: ../Doc/reference/lexical_analysis.rst:514
msgid "Meaning"
msgstr "의미"

#: ../Doc/reference/lexical_analysis.rst:481
#: ../Doc/reference/lexical_analysis.rst:514
msgid "Notes"
msgstr "유의 사항"

#: ../Doc/reference/lexical_analysis.rst:483
msgid "``\\newline``"
msgstr "``\\newline``"

#: ../Doc/reference/lexical_analysis.rst:483
msgid "Backslash and newline ignored"
msgstr "역 슬래시와 개행 문자가 무시된다"

#: ../Doc/reference/lexical_analysis.rst:485
msgid "``\\\\``"
msgstr "``\\\\``"

#: ../Doc/reference/lexical_analysis.rst:485
msgid "Backslash (``\\``)"
msgstr "역 슬래시 (``\\``)"

#: ../Doc/reference/lexical_analysis.rst:487
msgid "``\\'``"
msgstr "``\\'``"

#: ../Doc/reference/lexical_analysis.rst:487
msgid "Single quote (``'``)"
msgstr "작은따옴표 (``'``)"

#: ../Doc/reference/lexical_analysis.rst:489
msgid "``\\\"``"
msgstr "``\\\"``"

#: ../Doc/reference/lexical_analysis.rst:489
msgid "Double quote (``\"``)"
msgstr "큰따옴표 (``\"``)"

#: ../Doc/reference/lexical_analysis.rst:491
msgid "``\\a``"
msgstr "``\\a``"

#: ../Doc/reference/lexical_analysis.rst:491
msgid "ASCII Bell (BEL)"
msgstr "ASCII 벨 (BEL)"

#: ../Doc/reference/lexical_analysis.rst:493
msgid "``\\b``"
msgstr "``\\b``"

#: ../Doc/reference/lexical_analysis.rst:493
msgid "ASCII Backspace (BS)"
msgstr "ASCII 백스페이스 (BS)"

#: ../Doc/reference/lexical_analysis.rst:495
msgid "``\\f``"
msgstr "``\\f``"

#: ../Doc/reference/lexical_analysis.rst:495
msgid "ASCII Formfeed (FF)"
msgstr "ASCII 폼 피드 (FF)"

#: ../Doc/reference/lexical_analysis.rst:497
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/reference/lexical_analysis.rst:497
msgid "ASCII Linefeed (LF)"
msgstr "ASCII 라인 피드 (LF)"

#: ../Doc/reference/lexical_analysis.rst:499
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/reference/lexical_analysis.rst:499
msgid "ASCII Carriage Return (CR)"
msgstr "ASCII 캐리지 리턴 (CR)"

#: ../Doc/reference/lexical_analysis.rst:501
msgid "``\\t``"
msgstr "``\\t``"

#: ../Doc/reference/lexical_analysis.rst:501
msgid "ASCII Horizontal Tab (TAB)"
msgstr "ASCII 가로 탭 (TAB)"

#: ../Doc/reference/lexical_analysis.rst:503
msgid "``\\v``"
msgstr "``\\v``"

#: ../Doc/reference/lexical_analysis.rst:503
msgid "ASCII Vertical Tab (VT)"
msgstr "ASCII 세로 탭 (VT)"

#: ../Doc/reference/lexical_analysis.rst:505
msgid "``\\ooo``"
msgstr "``\\ooo``"

#: ../Doc/reference/lexical_analysis.rst:505
msgid "Character with octal value *ooo*"
msgstr "8진수 *ooo* 로 지정된 문자"

#: ../Doc/reference/lexical_analysis.rst:505
msgid "(1,3)"
msgstr "(1,3)"

#: ../Doc/reference/lexical_analysis.rst:508
msgid "``\\xhh``"
msgstr "``\\xhh``"

#: ../Doc/reference/lexical_analysis.rst:508
msgid "Character with hex value *hh*"
msgstr "16진수 *hh* 로 지정된 문자"

#: ../Doc/reference/lexical_analysis.rst:508
msgid "(2,3)"
msgstr "(2,3)"

#: ../Doc/reference/lexical_analysis.rst:511
msgid "Escape sequences only recognized in string literals are:"
msgstr "문자열 리터럴에서만 인식되는 이스케이프 시퀀스는:"

#: ../Doc/reference/lexical_analysis.rst:516
msgid "``\\N{name}``"
msgstr "``\\N{name}``"

#: ../Doc/reference/lexical_analysis.rst:516
msgid "Character named *name* in the Unicode database"
msgstr "유니코드 데이터베이스에서 *name* 이라고 이름 붙여진 문자"

#: ../Doc/reference/lexical_analysis.rst:516
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "``\\uxxxx``"
msgstr "``\\uxxxx``"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "Character with 16-bit hex value *xxxx*"
msgstr "16-bit 16진수 *xxxx* 로 지정된 문자"

#: ../Doc/reference/lexical_analysis.rst:519
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/reference/lexical_analysis.rst:522
msgid "``\\Uxxxxxxxx``"
msgstr "``\\Uxxxxxxxx``"

#: ../Doc/reference/lexical_analysis.rst:522
msgid "Character with 32-bit hex value *xxxxxxxx*"
msgstr "32-bit 16진수 *xxxxxxxx* 로 지정된 문자"

#: ../Doc/reference/lexical_analysis.rst:522
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/reference/lexical_analysis.rst:526
msgid "Notes:"
msgstr "유의 사항:"

#: ../Doc/reference/lexical_analysis.rst:529
msgid "As in Standard C, up to three octal digits are accepted."
msgstr "표준 C와 마찬가지로, 최대 세 개의 8진수가 허용된다."

#: ../Doc/reference/lexical_analysis.rst:532
msgid "Unlike in Standard C, exactly two hex digits are required."
msgstr "표준 C와는 달리, 정확히 두 개의 16진수가 제공되어야 한다."

#: ../Doc/reference/lexical_analysis.rst:535
msgid ""
"In a bytes literal, hexadecimal and octal escapes denote the byte with "
"the given value. In a string literal, these escapes denote a Unicode "
"character with the given value."
msgstr ""
"바이트열 리터럴에서, 16진수와 8진수 이스케이프는 지정된 값의 바이트를 표현한다. 문자열 리터럴에서는, 이 이스케이프는 지정된 "
"값의 유니코드 문자를 표현한다."

#: ../Doc/reference/lexical_analysis.rst:540
msgid "Support for name aliases [#]_ has been added."
msgstr "별칭 [#]_ 지원이 추가되었다"

#: ../Doc/reference/lexical_analysis.rst:544
msgid "Exactly four hex digits are required."
msgstr "정확히 4개의 16진수를 필요로 한다."

#: ../Doc/reference/lexical_analysis.rst:547
msgid ""
"Any Unicode character can be encoded this way.  Exactly eight hex digits "
"are required."
msgstr "이 방법으로 모든 유니코드를 인코딩할 수 있다. 정확히 8개의 16진수가 필요하다."

#: ../Doc/reference/lexical_analysis.rst:553
msgid ""
"Unlike Standard C, all unrecognized escape sequences are left in the "
"string unchanged, i.e., *the backslash is left in the result*.  (This "
"behavior is useful when debugging: if an escape sequence is mistyped, the"
" resulting output is more easily recognized as broken.)  It is also "
"important to note that the escape sequences only recognized in string "
"literals fall into the category of unrecognized escapes for bytes "
"literals."
msgstr ""
"표준 C와는 달리, 인식되지 않는 모든 이스케이프 시퀀스는 문자열에 변경되지 않은 상태로 남게 된다. 즉, *역 슬래시가 결과에 "
"남게 된다*. (이 동작은 디버깅할 때 쓸모가 있다. 이스케이프 시퀀스가 잘못 입력되었을 때, 최종 결과에서 잘못된 부분을 쉽게 인지할"
" 수 있다.) 문자열 리터럴에서만 인식되는 이스케이프 시퀀스가, 바이트열 리터럴에서는 인식되지 않는 부류임에 주목하라."

#: ../Doc/reference/lexical_analysis.rst:560
msgid ""
"Unrecognized escape sequences produce a DeprecationWarning.  In some "
"future version of Python they will be a SyntaxError."
msgstr ""
"인식되지 않는 이스케이프 시퀀스는 DeprecationWarning 을 만든다. 언젠가 파이썬의 미래 버전에서는 "
"SyntaxError 로 취급될 것이다."

#: ../Doc/reference/lexical_analysis.rst:564
msgid ""
"Even in a raw literal, quotes can be escaped with a backslash, but the "
"backslash remains in the result; for example, ``r\"\\\"\"`` is a valid "
"string literal consisting of two characters: a backslash and a double "
"quote; ``r\"\\\"`` is not a valid string literal (even a raw string "
"cannot end in an odd number of backslashes).  Specifically, *a raw "
"literal cannot end in a single backslash* (since the backslash would "
"escape the following quote character).  Note also that a single backslash"
" followed by a newline is interpreted as those two characters as part of "
"the literal, *not* as a line continuation."
msgstr ""
"날 리터럴에서 조차, 따옴표는 역 슬래시로 이스케이프 된다. 하지만 역 슬래시가 결과에 남게 된다; 예를 들어, ``r\"\\\"\"``"
" 는 올바른 문자열 리터럴인데, 두 개의 문자가 들어있다: 역 슬래시와 큰따옴표; ``r\"\\\"`` 는 올바른 문자열 리터럴이 "
"아니다 (날 문자열조차 홀수개의 역 슬래시로 끝날 수 없다.). 좀 더 명확하게 말하자면, 날 리터럴은 하나의 역 슬래시로 끝날 수 "
"없다(역 슬래시가 뒤에 오는 따옴표를 이스케이프 시키기 때문이다). 역 슬래시와 바로 뒤에 오는 개행문자는 줄 결합이 *아니라* 리터럴에 "
"포함되는 두 개의 문자로 인식됨에 주의해야 한다."

#: ../Doc/reference/lexical_analysis.rst:577
msgid "String literal concatenation"
msgstr "문자열 리터럴 이어붙이기"

#: ../Doc/reference/lexical_analysis.rst:579
msgid ""
"Multiple adjacent string or bytes literals (delimited by whitespace), "
"possibly using different quoting conventions, are allowed, and their "
"meaning is the same as their concatenation.  Thus, ``\"hello\" 'world'`` "
"is equivalent to ``\"helloworld\"``.  This feature can be used to reduce "
"the number of backslashes needed, to split long strings conveniently "
"across long lines, or even to add comments to parts of strings, for "
"example::"
msgstr ""
"여러 개의 문자열이나 바이트열 리터럴을 (공백으로 분리해서) 여러 개 인접해서 나열하는 것이 허락되고, 그 의미는 이어붙인 것과 "
"같다. 각 리터럴이 서로 다른 따옴표를 사용해도 된다. 그래서, ``\"hello\" 'world'`` 는 "
"``\"helloworld\"`` 와 동등하다. 이 기능은 긴 문자열을 편의상 여러 줄로 나눌 때 필요한 역 슬래시를 줄여준다. 각 "
"문자열 단위마다 주석을 붙이는 것도 가능하다. 예를 들어::"

#: ../Doc/reference/lexical_analysis.rst:590
msgid ""
"Note that this feature is defined at the syntactical level, but "
"implemented at compile time.  The '+' operator must be used to "
"concatenate string expressions at run time.  Also note that literal "
"concatenation can use different quoting styles for each component (even "
"mixing raw strings and triple quoted strings), and formatted string "
"literals may be concatenated with plain string literals."
msgstr ""
"이 기능이 문법 수준에서 정의되고는 있지만, 컴파일 시점에 구현됨에 주의해야 한다. 실행 시간에 문자열 표현을 이어붙이기 위해서는 "
"'+' 연산자를 사용해야 한다. 리터럴 이어붙이기가 요소별로 다른 따옴표를 사용할 수 있고 (날 문자열과 삼중 따옴표 문자열을 "
"이어붙이는 것조차 가능하다), 포맷 문자열 리터럴을 보통 문자열 리터럴과 이어붙일 수 있음에 유의해야 한다."

#: ../Doc/reference/lexical_analysis.rst:606
msgid "Formatted string literals"
msgstr "포맷 문자열 리터럴"

#: ../Doc/reference/lexical_analysis.rst:610
msgid ""
"A :dfn:`formatted string literal` or :dfn:`f-string` is a string literal "
"that is prefixed with ``'f'`` or ``'F'``.  These strings may contain "
"replacement fields, which are expressions delimited by curly braces "
"``{}``. While other string literals always have a constant value, "
"formatted strings are really expressions evaluated at run time."
msgstr ""
"포맷 문자열 리터럴(:dfn:`formatted string literal`) 또는 :dfn:`f-문자열 (f-string)` 은 "
"``'f'`` 나 ``'F'`` 를 앞에 붙인 문자열 리터럴이다. 이 문자열은 치환 필드를 포함할 수 있는데, 중괄호 ``{}`` "
"로 구분되는 표현식이다. 다른 문자열 리터럴이 항상 상숫값을 갖지만, 포맷 문자열 리터럴은 실행시간에 계산되는 표현식이다."

#: ../Doc/reference/lexical_analysis.rst:616
msgid ""
"Escape sequences are decoded like in ordinary string literals (except "
"when a literal is also marked as a raw string).  After decoding, the "
"grammar for the contents of the string is:"
msgstr ""
"이스케이프 시퀀스는 일반 문자열 리터럴처럼 디코딩된다 (동시에 날 문자열인 경우는 예외다). 디코딩 후에 문자열의 내용은 다음과 "
"같은 문법을 따른다:"

#: ../Doc/reference/lexical_analysis.rst:630
msgid ""
"The parts of the string outside curly braces are treated literally, "
"except that any doubled curly braces ``'{{'`` or ``'}}'`` are replaced "
"with the corresponding single curly brace.  A single opening curly "
"bracket ``'{'`` marks a replacement field, which starts with a Python "
"expression.  After the expression, there may be a conversion field, "
"introduced by an exclamation point ``'!'``.  A format specifier may also "
"be appended, introduced by a colon ``':'``.  A replacement field ends "
"with a closing curly bracket ``'}'``."
msgstr ""
"중괄호 바깥 부분은 일반 리터럴처럼 취급되는데, 이중 중괄호 ``'{{'`` 나 ``'}}'`` 가 대응하는 단일 중괄호로 "
"치환된다는 점만 예외다. 하나의 여는 중괄호 ``'{'`` 는 치환 필드를 시작시키는데, 파이썬 표현식이 뒤따른다. 표현식 뒤로는 "
"변환(conversion) 필드가 올 수 있는데, 느낌표 ``'!'`` 로 시작한다. 포맷 지정자(format specifier)도"
" 덧붙일 수 있는데, 콜론 ``':'`` 으로 시작한다. 치환 필드는 닫는 중괄호 ``'}'`` 로 끝난다."

#: ../Doc/reference/lexical_analysis.rst:639
msgid ""
"Expressions in formatted string literals are treated like regular Python "
"expressions surrounded by parentheses, with a few exceptions. An empty "
"expression is not allowed, and a :keyword:`lambda` expression must be "
"surrounded by explicit parentheses.  Replacement expressions can contain "
"line breaks (e.g. in triple-quoted strings), but they cannot contain "
"comments.  Each expression is evaluated in the context where the "
"formatted string literal appears, in order from left to right."
msgstr ""
"포맷 문자열 리터럴의 표현식은 괄호로 둘러싸인 일반적인 파이썬 표현식으로 취급되는데 몇 가지 예외가 있다. 빈 표현식은 허락되지 "
"않고, :keyword:`lambda` 표현식은 명시적인 괄호로 둘러싸야 한다. 치환 표현식은 개행문자를 포함할 수 있으나 "
"(예를 들어, 삼중 따옴표 된 문자열) 주석은 포함할 수 없다. 각 표현식은 포맷 문자열 리터럴이 등장한 지점의 문맥에서 왼쪽에서 "
"오른쪽으로 계산된다."

#: ../Doc/reference/lexical_analysis.rst:647
msgid ""
"If a conversion is specified, the result of evaluating the expression is "
"converted before formatting.  Conversion ``'!s'`` calls :func:`str` on "
"the result, ``'!r'`` calls :func:`repr`, and ``'!a'`` calls "
":func:`ascii`."
msgstr ""
"변환(conversion)이 지정되면, 표현식의 결과가 포매팅 전에 변환된다. 변환 ``'!s'`` 는 결과에 :func:`str` "
"을 호출하고, ``'!r'`` 은 :func:`repr` 을 호출하고, ``'!a'`` 은 :func:`ascii` 를 호출한다."

#: ../Doc/reference/lexical_analysis.rst:651
msgid ""
"The result is then formatted using the :func:`format` protocol.  The "
"format specifier is passed to the :meth:`__format__` method of the "
"expression or conversion result.  An empty string is passed when the "
"format specifier is omitted.  The formatted result is then included in "
"the final value of the whole string."
msgstr ""
"결과는 :func:`format` 프로토콜로 포매팅한다. 포맷 지정자는 표현식이나 변환 결과의 :meth:`__format__` "
"메서드 로 전달된다. 포맷지정자가 생략되면 빈 문자열이 전달된다. 이제 포맷된 결과가 최종 문자열에 삽입된다."

#: ../Doc/reference/lexical_analysis.rst:657
msgid ""
"Top-level format specifiers may include nested replacement fields. These "
"nested fields may include their own conversion fields and format "
"specifiers, but may not include more deeply-nested replacement fields."
msgstr ""
"최상위 포맷 지정자는 중첩된 치환 필드들을 포함할 수 있다. 이 중첩된 필드들은 그들 자신의 변환 필드와 포맷 지정자를 포함할 수 "
"있지만, 깊이 중첩된 치환 필드들을 포함할 수는 없다."

#: ../Doc/reference/lexical_analysis.rst:661
msgid ""
"Formatted string literals may be concatenated, but replacement fields "
"cannot be split across literals."
msgstr "포맷 문자열 리터럴을 이어붙일 수는 있지만, 치환 필드가 여러 리터럴로 쪼개질 수는 없다."

#: ../Doc/reference/lexical_analysis.rst:664
msgid "Some examples of formatted string literals::"
msgstr "포맷 문자열 리터럴의 예를 들면::"

#: ../Doc/reference/lexical_analysis.rst:683
msgid ""
"A consequence of sharing the same syntax as regular string literals is "
"that characters in the replacement fields must not conflict with the "
"quoting used in the outer formatted string literal::"
msgstr ""
"일반적인 문자열 리터럴과 같은 문법을 공유하는 것으로 인한 결과는 치환 필드에 사용되는 문자들이 포맷 문자열 리터럴을 감싸는 "
"따옴표와 충돌하지 않아야 한다는 것이다::"

#: ../Doc/reference/lexical_analysis.rst:690
msgid ""
"Backslashes are not allowed in format expressions and will raise an "
"error::"
msgstr "포맷 표현식에는 역 슬래시를 사용할 수 없고, 사용하면 에러가 발생한다::"

#: ../Doc/reference/lexical_analysis.rst:695
msgid ""
"To include a value in which a backslash escape is required, create a "
"temporary variable."
msgstr ""
"역 슬래시 이스케이프가 필요한 값을 포함시키려면, 임시 변수를 만들면된다."

#: ../Doc/reference/lexical_analysis.rst:702
msgid ""
"Formatted string literals cannot be used as docstrings, even if they do "
"not include expressions."
msgstr "포맷 문자열 리터럴은 독스트링(docstring)으로 사용될 수 없다. 표현식이 전혀 없더라도 마찬가지다."

#: ../Doc/reference/lexical_analysis.rst:713
msgid ""
"See also :pep:`498` for the proposal that added formatted string "
"literals, and :meth:`str.format`, which uses a related format string "
"mechanism."
msgstr ""
"포맷 문자열 리터럴 추가에 대한 제안은 :pep:`498` 을 참조하고, 관련된 포맷 문자열 메커니즘을 사용하는 "
":meth:`str.format` 도 살펴보는 것이 좋다."

#: ../Doc/reference/lexical_analysis.rst:720
msgid "Numeric literals"
msgstr "숫자 리터럴"

#: ../Doc/reference/lexical_analysis.rst:726
msgid ""
"There are three types of numeric literals: integers, floating point "
"numbers, and imaginary numbers.  There are no complex literals (complex "
"numbers can be formed by adding a real number and an imaginary number)."
msgstr ""
"숫자 리터럴에는 세 가지 종류가 있다: 정수, 실수, 허수. 복소수 리터럴 같은 것은 없다 (복소수는 실수와 허수를 더해서 "
"만들어진다.)"

#: ../Doc/reference/lexical_analysis.rst:730
msgid ""
"Note that numeric literals do not include a sign; a phrase like ``-1`` is"
" actually an expression composed of the unary operator '``-``' and the "
"literal ``1``."
msgstr ""
"숫자 리터럴이 부호를 포함하지 않는 것에 주의해야 한다; ``-1`` 과 같은 구문은 일 항 연산자 '``-``' 과 리터럴 "
"``1`` 로 구성된 표현식이다."

#: ../Doc/reference/lexical_analysis.rst:738
msgid "Integer literals"
msgstr "정수 리터럴"

#: ../Doc/reference/lexical_analysis.rst:740
msgid "Integer literals are described by the following lexical definitions:"
msgstr "정수 리터럴은 다음과 같은 구문 정의로 표현된다:"

#: ../Doc/reference/lexical_analysis.rst:754
msgid ""
"There is no limit for the length of integer literals apart from what can "
"be stored in available memory."
msgstr "가용한 메모리에 저장될 수 있는지와는 별개로 정수 리터럴의 길이에 제한은 없다."

#: ../Doc/reference/lexical_analysis.rst:757
msgid ""
"Underscores are ignored for determining the numeric value of the literal."
"  They can be used to group digits for enhanced readability.  One "
"underscore can occur between digits, and after base specifiers like "
"``0x``."
msgstr ""
"밑줄은 리터럴의 숫자 값을 결정할 때 고려되지 않는다. 가독성을 높이기 위해 숫자들을 무리 지을 때 쓸모가 있다. 밑줄은 숫자 사이나"
" ``0x`` 와 같은 진수 지정자(base specifier) 다음에 나올 수 있는데, 한 번에 하나만 사용될 수 있다."

#: ../Doc/reference/lexical_analysis.rst:761
msgid ""
"Note that leading zeros in a non-zero decimal number are not allowed. "
"This is for disambiguation with C-style octal literals, which Python used"
" before version 3.0."
msgstr ""
"0 이 아닌 10진수가 0으로 시작할 수 없음에 주의해야 한다. 3.0 버전 이전의 파이썬에서 사용한 C 스타일의 8진수 리터럴과 "
"혼동되는 것을 막기 위함이다."

#: ../Doc/reference/lexical_analysis.rst:765
msgid "Some examples of integer literals::"
msgstr "정수 리터럴의 예를 들면::"

#: ../Doc/reference/lexical_analysis.rst:771
#: ../Doc/reference/lexical_analysis.rst:799
msgid "Underscores are now allowed for grouping purposes in literals."
msgstr "리터럴에서 숫자들의 그룹을 표현할 목적으로 밑줄을 허락한다."

#: ../Doc/reference/lexical_analysis.rst:778
msgid "Floating point literals"
msgstr "실수 리터럴"

#: ../Doc/reference/lexical_analysis.rst:780
msgid ""
"Floating point literals are described by the following lexical "
"definitions:"
msgstr "실수 리터럴은 다음과 같은 구문 정의로 표현된다:"

#: ../Doc/reference/lexical_analysis.rst:790
msgid ""
"Note that the integer and exponent parts are always interpreted using "
"radix 10. For example, ``077e010`` is legal, and denotes the same number "
"as ``77e10``. The allowed range of floating point literals is "
"implementation-dependent.  As in integer literals, underscores are "
"supported for digit grouping."
msgstr ""
"정수부와 지수부는 항상 10진법으로 해석된다는 것에 주의해야 한다. 예를 들어, ``077e010`` 는 올바른 표현이고, "
"``77e10`` 과 같은 숫자를 표현한다. 실수 리터럴의 허락된 범위는 구현 세부 사항이다. 정수 리터럴에서와 마찬가지로 밑줄로 "
"숫자들의 묶음을 만드는 것도 지원된다."

#: ../Doc/reference/lexical_analysis.rst:795
msgid "Some examples of floating point literals::"
msgstr "실수 리터럴의 몇 가지 예를 든다::"

#: ../Doc/reference/lexical_analysis.rst:806
msgid "Imaginary literals"
msgstr "허수 리터럴"

#: ../Doc/reference/lexical_analysis.rst:808
msgid "Imaginary literals are described by the following lexical definitions:"
msgstr "허수 리터럴은 다음과 같은 구문 정의로 표현된다:"

#: ../Doc/reference/lexical_analysis.rst:813
msgid ""
"An imaginary literal yields a complex number with a real part of 0.0.  "
"Complex numbers are represented as a pair of floating point numbers and "
"have the same restrictions on their range.  To create a complex number "
"with a nonzero real part, add a floating point number to it, e.g., "
"``(3+4j)``.  Some examples of imaginary literals::"
msgstr ""
"허수 리터럴은 실수부가 0.0인 복소수를 만든다. 복소수는 실수와 같은 범위 제약이 적용되는 한 쌍의 실수로 표현된다. 0이 아닌"
" 실수부를 갖는 복소수를 만들려면, 실수를 더하면 된다. 예를 들어, ``(3+4j)``. 허수 리터럴의 몇 가지 예를 든다::"

#: ../Doc/reference/lexical_analysis.rst:825
msgid "Operators"
msgstr "연산자"

#: ../Doc/reference/lexical_analysis.rst:829
msgid "The following tokens are operators:"
msgstr "다음과 같은 토큰들은 연산자다:"

#: ../Doc/reference/lexical_analysis.rst:842
msgid "Delimiters"
msgstr "구분자"

#: ../Doc/reference/lexical_analysis.rst:846
msgid "The following tokens serve as delimiters in the grammar:"
msgstr "다음 토큰들은 문법에서 구분자(delimiter)로 기능한다:"

#: ../Doc/reference/lexical_analysis.rst:855
msgid ""
"The period can also occur in floating-point and imaginary literals.  A "
"sequence of three periods has a special meaning as an ellipsis literal. "
"The second half of the list, the augmented assignment operators, serve "
"lexically as delimiters, but also perform an operation."
msgstr ""
"마침표는 실수와 허수 리터럴에서도 등장할 수 있다. 연속된 마침표 세 개는 생략부호 리터럴(ellipsis literal)이라는 특별한 "
"의미가 있다. 목록 후반의 증분 대입 연산자(augmented assignment operator)들은 구문적으로는 구분자로 "
"기능하지만, 동시에 연산을 수행한다."

#: ../Doc/reference/lexical_analysis.rst:860
msgid ""
"The following printing ASCII characters have special meaning as part of "
"other tokens or are otherwise significant to the lexical analyzer:"
msgstr "다음의 인쇄되는 ASCII 문자들은 다른 토큰들 일부로서 특별한 의미를 같거나, 그 밖의 경우 구문 분석기에 유의미하다:"

#: ../Doc/reference/lexical_analysis.rst:867
msgid ""
"The following printing ASCII characters are not used in Python.  Their "
"occurrence outside string literals and comments is an unconditional "
"error:"
msgstr "다음의 인쇄되는 ASCII 문자들은 파이썬에서 사용되지 않는다. 문자열 리터럴과 주석 이외의 곳에서 사용되는 것은 조건 없는 에러다:"

#: ../Doc/reference/lexical_analysis.rst:876
msgid "Footnotes"
msgstr "각주"

#: ../Doc/reference/lexical_analysis.rst:877
msgid "http://www.unicode.org/Public/9.0.0/ucd/NameAliases.txt"
msgstr "http://www.unicode.org/Public/9.0.0/ucd/NameAliases.txt"

#~ msgid ""
#~ "As of Python 3.3 it is possible"
#~ " again to prefix string literals with"
#~ " a ``u`` prefix to simplify "
#~ "maintenance of dual 2.x and 3.x "
#~ "codebases."
#~ msgstr ""
#~ "파이썬 3.3 부터, 2.x 와 3.x 를 동시에"
#~ " 지원하는 코드들의 유지보수를 단순화하기위해, 문자열 리터럴에"
#~ " ``u`` 접두어를 붙이는 것이 다시 가능해졌다."
