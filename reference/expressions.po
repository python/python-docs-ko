# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-23 11:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/reference/expressions.rst:6
msgid "Expressions"
msgstr "표현식"

#: ../Doc/reference/expressions.rst:10
msgid ""
"This chapter explains the meaning of the elements of expressions in "
"Python."
msgstr "이 장은 파이썬에서 사용되는 표현식 요소들의 의미를 설명한다."

#: ../Doc/reference/expressions.rst:12
msgid ""
"**Syntax Notes:** In this and the following chapters, extended BNF "
"notation will be used to describe syntax, not lexical analysis.  When "
"(one alternative of) a syntax rule has the form"
msgstr ""
"**문법 유의 사항:** 여기와 이어지는 장에서는, 구문 분석이 아니라 문법을 설명하기 위해 확장 BNF 표기법을 사용한다. 문법 "
"규칙이 다음과 같은 형태를 가지고,"

#: ../Doc/reference/expressions.rst:19
msgid ""
"and no semantics are given, the semantics of this form of ``name`` are "
"the same as for ``othername``."
msgstr "뜻(semantics)을 주지 않으면, 이 형태의 ``name`` 의 뜻은 ``othername`` 과 같다."

#: ../Doc/reference/expressions.rst:26
msgid "Arithmetic conversions"
msgstr "산술 변환"

#: ../Doc/reference/expressions.rst:30
msgid ""
"When a description of an arithmetic operator below uses the phrase \"the "
"numeric arguments are converted to a common type,\" this means that the "
"operator implementation for built-in types works as follows:"
msgstr ""
"다음에 나오는 산술 연산자의 설명이 \"숫자 인자들은 공통 형으로 변환된다\"라는 구절을 사용할 때, 내장형의 연산자 구현이 "
"다음과 같이 동작한다는 뜻이다:"

#: ../Doc/reference/expressions.rst:34
msgid "If either argument is a complex number, the other is converted to complex;"
msgstr "어느 한 인자가 복소수면 다른 하나는 복소수로 변환된다;"

#: ../Doc/reference/expressions.rst:36
msgid ""
"otherwise, if either argument is a floating point number, the other is "
"converted to floating point;"
msgstr "그렇지 않고, 어느 한 인자가 실수면, 다른 하나는 실수로 변환된다;"

#: ../Doc/reference/expressions.rst:39
msgid "otherwise, both must be integers and no conversion is necessary."
msgstr "그렇지 않으면, 두 인자는 모두 정수여야 하고, 변환은 필요 없다."

#: ../Doc/reference/expressions.rst:41
msgid ""
"Some additional rules apply for certain operators (e.g., a string as a "
"left argument to the '%' operator).  Extensions must define their own "
"conversion behavior."
msgstr ""
"어떤 연산자들(예를 들어, '%' 연산자의 왼쪽 인자로 주어지는 문자열)에 대해서는 몇 가지 추가의 규칙이 적용된다. "
"확장(extension)은 그들 자신의 변환 규칙을 정의해야 한다."

#: ../Doc/reference/expressions.rst:49
msgid "Atoms"
msgstr "아톰 (Atoms)"

#: ../Doc/reference/expressions.rst:53
msgid ""
"Atoms are the most basic elements of expressions.  The simplest atoms are"
" identifiers or literals.  Forms enclosed in parentheses, brackets or "
"braces are also categorized syntactically as atoms.  The syntax for atoms"
" is:"
msgstr ""
"아톰은 표현식의 가장 기본적인 요소다. 가장 간단한 아톰은 식별자와 리터럴이다. 괄호, 꺾쇠괄호, 중괄호로 둘러싸인 형태도 "
"문법적으로 아톰으로 분류된다. 아톰의 문법은 이렇다:"

#: ../Doc/reference/expressions.rst:66
msgid "Identifiers (Names)"
msgstr "식별자 (이름)"

#: ../Doc/reference/expressions.rst:70
msgid ""
"An identifier occurring as an atom is a name.  See section "
":ref:`identifiers` for lexical definition and section :ref:`naming` for "
"documentation of naming and binding."
msgstr ""
"아톰으로 등장하는 식별자는 이름이다. 구문 분석에 대해서는 :ref:`identifiers` 섹션을, 이름과 연결에 대한 문서는 "
":ref:`naming` 섹션을 보면 된다."

#: ../Doc/reference/expressions.rst:76
msgid ""
"When the name is bound to an object, evaluation of the atom yields that "
"object. When a name is not bound, an attempt to evaluate it raises a "
":exc:`NameError` exception."
msgstr ""
"이름이 객체에 연결될 때, 아톰의 값을 구하면 객체가 나온다. 이름이 연결되지 않았을 때, 값을 구하려고 하면 "
":exc:`NameError` 예외가 일어난다."

#: ../Doc/reference/expressions.rst:84
msgid ""
"**Private name mangling:** When an identifier that textually occurs in a "
"class definition begins with two or more underscore characters and does "
"not end in two or more underscores, it is considered a :dfn:`private "
"name` of that class. Private names are transformed to a longer form "
"before code is generated for them.  The transformation inserts the class "
"name, with leading underscores removed and a single underscore inserted, "
"in front of the name.  For example, the identifier ``__spam`` occurring "
"in a class named ``Ham`` will be transformed to ``_Ham__spam``.  This "
"transformation is independent of the syntactical context in which the "
"identifier is used.  If the transformed name is extremely long (longer "
"than 255 characters), implementation defined truncation may happen. If "
"the class name consists only of underscores, no transformation is done."
msgstr ""
"**비공개 이름 뒤섞기(private name mangling):** 클래스 정의에 등장하는 식별자가 두 개나 그 이상의 밑줄로 "
"시작하고, 두 개나 그 이상의 밑줄로 끝나지 않으면, 그 클래스의 :dfn:`비공개 이름(private name)` 으로 간주한다."
" 비공개 이름은 그 들을 위한 코드가 만들어지기 전에 더 긴 형태로 변환된다. 이 변환은 그 이름의 앞에 클래스 이름을 삽입하는데,"
" 클래스 이름의 처음에 오는 모든 밑줄을 제거한 후, 하나의 밑줄을 추가한다. 예를 들어, ``Ham`` 이라는 이름의 클래스에 "
"식별자 ``__spam`` 이 등장하면, ``_Ham__spam`` 으로 변환된다. 이 변환은 식별자가 사용되는 문법적인 문맥에 "
"무관하다. 변환된 이름이 극단적으로 길면(255자보다 길면), 구현이 정의한 잘라내기가 발생할 수 있다. 클래스 이름이 밑줄로만 "
"구성되어 있으면, 변환은 일어나지 않는다."

#: ../Doc/reference/expressions.rst:100
msgid "Literals"
msgstr "리터럴 (Literals)"

#: ../Doc/reference/expressions.rst:104
msgid "Python supports string and bytes literals and various numeric literals:"
msgstr "파이썬은 문자열과 바이트열 리터럴과 여러 가지 숫자 리터럴들을 지원한다:"

#: ../Doc/reference/expressions.rst:110
msgid ""
"Evaluation of a literal yields an object of the given type (string, "
"bytes, integer, floating point number, complex number) with the given "
"value.  The value may be approximated in the case of floating point and "
"imaginary (complex) literals.  See section :ref:`literals` for details."
msgstr ""
"리터럴의 값을 구하면 주어진 형(문자열, 바이트열, 정수, 실수, 복소수)과 주어진 값을 갖는 객체가 나온다. 실수와 복소수의 "
"경우는 근삿값일 수 있다. 자세한 내용은 :ref:`literals` 섹션을 보면 된다."

#: ../Doc/reference/expressions.rst:119
msgid ""
"All literals correspond to immutable data types, and hence the object's "
"identity is less important than its value.  Multiple evaluations of "
"literals with the same value (either the same occurrence in the program "
"text or a different occurrence) may obtain the same object or a different"
" object with the same value."
msgstr ""
"모든 리터럴은 불변 데이터형에 대응하기 때문에, 객체의 아이덴티티는 값 보다 덜 중요하다. 같은 값의 리터럴에 대해 반복적으로 값을"
" 구하면 (프로그램 텍스트의 같은 장소에 있거나 다른 장소에 있을 때) 같은 객체를 얻을 수도 있고, 같은 값의 다른 객체를 얻을 "
"수도 있다."

#: ../Doc/reference/expressions.rst:129
msgid "Parenthesized forms"
msgstr "괄호 안에 넣은 형"

#: ../Doc/reference/expressions.rst:133
msgid ""
"A parenthesized form is an optional expression list enclosed in "
"parentheses:"
msgstr "괄호 안에 넣은 형은, 괄호로 둘러싸인 생략 가능한 표현식 목록이다:"

#: ../Doc/reference/expressions.rst:138
msgid ""
"A parenthesized expression list yields whatever that expression list "
"yields: if the list contains at least one comma, it yields a tuple; "
"otherwise, it yields the single expression that makes up the expression "
"list."
msgstr ""
"괄호 안에 넣은 표현식 목록은, 무엇이건 그 표현식 목록이 산출하는 것이 된다: 목록이 적어도 하나의 쉼표를 포함하면, 튜플이 "
"된다; 그렇지 않으면 표현식 목록을 구성한 단일 표현식이 된다."

#: ../Doc/reference/expressions.rst:144
msgid ""
"An empty pair of parentheses yields an empty tuple object.  Since tuples "
"are immutable, the rules for literals apply (i.e., two occurrences of the"
" empty tuple may or may not yield the same object)."
msgstr ""
"빈 괄호 쌍은 빈 튜플 객체를 만든다. 튜플은 불변이기 때문에 리터럴의 규칙이 적용된다 (즉, 두 개의 빈 튜플은 같은 객체일 수도 "
"있고 그렇지 않을 수도 있다)."

#: ../Doc/reference/expressions.rst:152
msgid ""
"Note that tuples are not formed by the parentheses, but rather by use of "
"the comma operator.  The exception is the empty tuple, for which "
"parentheses *are* required --- allowing unparenthesized \"nothing\" in "
"expressions would cause ambiguities and allow common typos to pass "
"uncaught."
msgstr ""
"튜플이 괄호에 의해 만들어지는 것이 아니라, 쉼표 연산자의 사용 때문이라는 것에 주의해야 한다. 예외는 빈 튜플인데, 괄호가 필요하다 "
"--- 표현식에서 괄호 없는 \"없음(nothing)\"을 허락하는 것은 모호함을 유발하고 자주 발생하는 오타들이 잡히지 "
"않은 채로 남게 할 것이다."

#: ../Doc/reference/expressions.rst:161
msgid "Displays for lists, sets and dictionaries"
msgstr "리스트, 집합, 딕셔너리의 디스플레이(display)"

#: ../Doc/reference/expressions.rst:163
msgid ""
"For constructing a list, a set or a dictionary Python provides special "
"syntax called \"displays\", each of them in two flavors:"
msgstr ""
"리스트, 집합, 딕셔너리를 구성하기 위해, 파이썬은 \"디스플레이(displays)\"라고 부르는 특별한 문법을 각기 두 가지 "
"스타일로 제공한다:"

#: ../Doc/reference/expressions.rst:166
msgid "either the container contents are listed explicitly, or"
msgstr "컨테이너의 내용을 명시적으로 나열하거나,"

#: ../Doc/reference/expressions.rst:168
msgid ""
"they are computed via a set of looping and filtering instructions, called"
" a :dfn:`comprehension`."
msgstr "일련의 루프와 필터링 지시들을 통해 계산되는데, :dfn:`컴프리헨션 (comprehension)` 이라고 불린다."

#: ../Doc/reference/expressions.rst:171
msgid "Common syntax elements for comprehensions are:"
msgstr "컴프리헨션의 공통 문법 요소들은 이렇다:"

#: ../Doc/reference/expressions.rst:179
msgid ""
"The comprehension consists of a single expression followed by at least "
"one :keyword:`for` clause and zero or more :keyword:`for` or "
":keyword:`if` clauses. In this case, the elements of the new container "
"are those that would be produced by considering each of the "
":keyword:`for` or :keyword:`if` clauses a block, nesting from left to "
"right, and evaluating the expression to produce an element each time the "
"innermost block is reached."
msgstr ""
"컴프리헨션은 하나의 표현식과 그 뒤를 따르는 최소한 하나의 :keyword:`for` 절과 없거나 여러 개의 "
":keyword:`for` 또는 :keyword:`if` 절로 구성된다. 이 경우, 새 컨테이너의 요소들은 각 "
":keyword:`for` 또는 :keyword:`if` 절이 왼쪽에서 오른쪽으로 중첩된 블록을 이루고, 가장 안쪽에 있는 블록에서"
" 표현식의 값을 구해서 만들어낸 것들이다."

#: ../Doc/reference/expressions.rst:186
msgid ""
"Note that the comprehension is executed in a separate scope, so names "
"assigned to in the target list don't \"leak\" into the enclosing scope."
msgstr ""
"컴프리헨션은 별도의 스코프(scope)에서 실행되기 때문에, 타깃 목록에서 대입된 이름들은 둘러싼 스코프로 \"누수(leak)\"되지"
" 않음에 주의해야 한다."

#: ../Doc/reference/expressions.rst:189
msgid ""
"Since Python 3.6, in an :keyword:`async def` function, an :keyword:`async"
" for` clause may be used to iterate over a :term:`asynchronous iterator`."
" A comprehension in an :keyword:`async def` function may consist of "
"either a :keyword:`for` or :keyword:`async for` clause following the "
"leading expression, may contain additional :keyword:`for` or "
":keyword:`async for` clauses, and may also use :keyword:`await` "
"expressions. If a comprehension contains either :keyword:`async for` "
"clauses or :keyword:`await` expressions it is called an "
":dfn:`asynchronous comprehension`.  An asynchronous comprehension may "
"suspend the execution of the coroutine function in which it appears. See "
"also :pep:`530`."
msgstr ""
"파이썬 3.6부터, :keyword:`async def` 함수에서는, :term:`비동기 이터레이터 <asynchronous "
"iterator>` 를 탐색하기 위해 :keyword:`async for` 를 사용할 수 있다. :keyword:`async "
"def` 함수에 있는 컴프리헨션은 처음에 나오는 표현식뒤에 :keyword:`for` 나 :keyword:`async for` 절이"
" 올 수 있고, 추가의 :keyword:`for` 나 :keyword:`async for` 절이 올 수 있고, "
":keyword:`await` 표현식 또한 사용할 수 있다. 컴프리헨션이 :keyword:`async for` 절이나 "
":keyword:`await` 표현식을 포함하면 :dfn:`비동기 컴프리헨션 (asynchronous comprehension)` "
"이라고 불린다. 비동기 컴프리헨션은 그것이 등장한 코루틴 함수의 실행을 일시 중지시킬 수 있다. :pep:`530` 를 "
"참고하라."

#: ../Doc/reference/expressions.rst:204
msgid "List displays"
msgstr "리스트 디스플레이"

#: ../Doc/reference/expressions.rst:212
msgid ""
"A list display is a possibly empty series of expressions enclosed in "
"square brackets:"
msgstr "리스트 디스플레이는 꺾쇠괄호(square brackets)로 둘러싸인 표현식의 나열인데 비어있을 수 있다:"

#: ../Doc/reference/expressions.rst:218
msgid ""
"A list display yields a new list object, the contents being specified by "
"either a list of expressions or a comprehension.  When a comma-separated "
"list of expressions is supplied, its elements are evaluated from left to "
"right and placed into the list object in that order.  When a "
"comprehension is supplied, the list is constructed from the elements "
"resulting from the comprehension."
msgstr ""
"리스트 디스플레이는 리스트 객체를 만드는데, 그 내용은 표현식의 목록이나 컴프리헨션으로 지정할 수 있다. 쉼표로 분리된 표현식의 "
"목록이 제공될 때, 그 요소들은 왼쪽에서 오른쪽으로 값이 구해지고, 그 순서대로 리스트 객체에 삽입된다. 컴프리헨션이 제공될 때, "
"리스트는 컴프리헨션으로 만들어지는 요소들로 구성된다."

#: ../Doc/reference/expressions.rst:228
msgid "Set displays"
msgstr "집합 디스플레이"

#: ../Doc/reference/expressions.rst:233
msgid ""
"A set display is denoted by curly braces and distinguishable from "
"dictionary displays by the lack of colons separating keys and values:"
msgstr ""
"집합 디스플레이는 중괄호(curly braces)로 표시되고, 키와 값을 분리하는 콜론(colon)이 없는 것으로 딕셔너리 "
"디스플레이와 구분될 수 있다."

#: ../Doc/reference/expressions.rst:239
msgid ""
"A set display yields a new mutable set object, the contents being "
"specified by either a sequence of expressions or a comprehension.  When a"
" comma-separated list of expressions is supplied, its elements are "
"evaluated from left to right and added to the set object.  When a "
"comprehension is supplied, the set is constructed from the elements "
"resulting from the comprehension."
msgstr ""
"집합 디스플레이는 새 가변 집합 객체를 만드는데, 그 내용은 표현식의 시퀀스나 컴프리헨션으로 지정된다. 쉼표로 분리된 표현식의 "
"목록이 제공될 때, 그 요소들은 왼쪽에서 오른쪽으로 값이 구해지고, 집합 객체에 더해진다. 컴프리헨션이 제공될 때, 집합은 "
"컴프리헨션으로 만들어지는 요소들로 구성된다."

#: ../Doc/reference/expressions.rst:245
msgid ""
"An empty set cannot be constructed with ``{}``; this literal constructs "
"an empty dictionary."
msgstr "빈 집합은 ``{}`` 으로 만들어질 수 없다; 이 리터럴은 빈 딕셔너리를 만든다."

#: ../Doc/reference/expressions.rst:252
msgid "Dictionary displays"
msgstr "딕셔너리 디스플레이"

#: ../Doc/reference/expressions.rst:258
msgid ""
"A dictionary display is a possibly empty series of key/datum pairs "
"enclosed in curly braces:"
msgstr "딕셔너리 디스플레이는 중괄호(curly braces)로 둘러싸인 키/데이터 쌍의 나열인데 비어있을 수 있다:"

#: ../Doc/reference/expressions.rst:267
msgid "A dictionary display yields a new dictionary object."
msgstr "딕셔너리 디스플레이는 새 딕셔너리 객체를 만든다."

#: ../Doc/reference/expressions.rst:269
msgid ""
"If a comma-separated sequence of key/datum pairs is given, they are "
"evaluated from left to right to define the entries of the dictionary: "
"each key object is used as a key into the dictionary to store the "
"corresponding datum.  This means that you can specify the same key "
"multiple times in the key/datum list, and the final dictionary's value "
"for that key will be the last one given."
msgstr ""
"쉼표로 분리된 키/데이터 쌍의 시퀀스가 주어질 때, 그것들은 왼쪽에서 오른쪽으로 값이 구해지고 딕셔너리의 엔트리들을 정의한다: 각"
" 키 객체는 딕셔너리에 대응하는 데이터를 저장하는 데 키로 사용된다. 이것은 키/값 목록에서 같은 키를 여러 번 지정할 수 있다는 "
"뜻인데, 그 키의 최종 딕셔너리 값은 마지막에 주어진 것이 된다."

#: ../Doc/reference/expressions.rst:277
msgid ""
"A double asterisk ``**`` denotes :dfn:`dictionary unpacking`. Its operand"
" must be a :term:`mapping`.  Each mapping item is added to the new "
"dictionary.  Later values replace values already set by earlier key/datum"
" pairs and earlier dictionary unpackings."
msgstr ""
"두 개의 애스터리스크(asterisk) ``**`` 는 :dfn:`딕셔너리 언 패킹(dictionary unpacking)` 를 "
"나타낸다. 피연산자는 :term:`매핑 <mapping>` 이어야만 한다. 각 매핑 항목은 새 딕셔너리에 추가된다. 뒤에 오는 "
"값들이 앞의 키/데이터 쌍이나 앞의 딕셔너리 언 패킹 때문에 설정된 값들을 교체한다."

#: ../Doc/reference/expressions.rst:282
msgid "Unpacking into dictionary displays, originally proposed by :pep:`448`."
msgstr ":pep:`448` 에서 처음 제안된 딕셔너리 디스플레이로의 언 패킹."

#: ../Doc/reference/expressions.rst:285
msgid ""
"A dict comprehension, in contrast to list and set comprehensions, needs "
"two expressions separated with a colon followed by the usual \"for\" and "
"\"if\" clauses. When the comprehension is run, the resulting key and "
"value elements are inserted in the new dictionary in the order they are "
"produced."
msgstr ""
"딕셔너리 컴프리헨션은, 리스트와 집합 컴프리헨션에 대비해서, 일반적인 \"for\" 와 \"if\" 절 앞에 콜론으로 분리된 두 "
"개의 표현식을 필요로 한다. 컴프리헨션이 실행될 때, 만들어지는 키와 값 요소들이 만들어지는 순서대로 딕셔너리에 삽입된다."

#: ../Doc/reference/expressions.rst:293
msgid ""
"Restrictions on the types of the key values are listed earlier in section"
" :ref:`types`.  (To summarize, the key type should be :term:`hashable`, "
"which excludes all mutable objects.)  Clashes between duplicate keys are "
"not detected; the last datum (textually rightmost in the display) stored "
"for a given key value prevails."
msgstr ""
"킷값의 형에 대한 제약은 앞의 섹션 :ref:`types` 에서 나열되었다. (요약하자면, 키 형은 :term:`해시 가능 "
"<hashable>` 해야 하는데, 모든 가변 객체들이 제외된다.) 중복된 키 간의 충돌은 감지되지 않는다; 주어진 키에 대해 "
"저장된 마지막 (구문상으로 디스플레이의 가장 오른쪽에 있는) 데이터가 우선한다."

#: ../Doc/reference/expressions.rst:303
msgid "Generator expressions"
msgstr "제너레이터 표현식 (Generator expressions)"

#: ../Doc/reference/expressions.rst:308
msgid "A generator expression is a compact generator notation in parentheses:"
msgstr "제너레이터 표현식은 괄호로 둘러싸인 간결한 제너레이터 표기법이다."

#: ../Doc/reference/expressions.rst:313
msgid ""
"A generator expression yields a new generator object.  Its syntax is the "
"same as for comprehensions, except that it is enclosed in parentheses "
"instead of brackets or curly braces."
msgstr "제너레이터 표현식은 새 제너레이터 객체를 만든다. 문법은 꺾쇠괄호나 중괄호 대신 괄호로 둘러싸인다는 점만 제외하면 컴프리헨션과 같다."

#: ../Doc/reference/expressions.rst:317
msgid ""
"Variables used in the generator expression are evaluated lazily when the "
":meth:`~generator.__next__` method is called for the generator object (in"
" the same fashion as normal generators).  However, the leftmost "
":keyword:`for` clause is immediately evaluated, so that an error produced"
" by it can be seen before any other possible error in the code that "
"handles the generator expression. Subsequent :keyword:`for` clauses "
"cannot be evaluated immediately since they may depend on the previous "
":keyword:`for` loop. For example: ``(x*y for x in range(10) for y in "
"bar(x))``."
msgstr ""
"제너레이터 표현식에 사용되는 변수들은 제너레이터 객체의 :meth:`~generator.__next__` 메서드가 호출될 때 "
"느긋하게(lazily) 값이 구해진다 (일반 제너레이터와 마찬가지다). 하지만, 가장 왼쪽의 :keyword:`for` 절은 즉시 "
"값이 구해져서, 그것으로 인해 발생하는 에러는 제너레이터 표현을 다루는 다른 어떤 코드들에서 발생하는 에러들보다 먼저 "
"발견된다. 뒤따르는 :keyword:`for` 절들은 앞의 :keyword:`for` 루프에 종속되기 때문에 즉시 값을 구할 수 "
"없다. 예를 들어: ``(x*y for x in range(10) for y in bar(x))``."

#: ../Doc/reference/expressions.rst:326
msgid ""
"The parentheses can be omitted on calls with only one argument.  See "
"section :ref:`calls` for details."
msgstr "단지 하나의 인자만 갖는 호출에서는 괄호를 생략할 수 있다. 자세한 내용은 :ref:`calls` 섹션을 보면 된다."

#: ../Doc/reference/expressions.rst:329
msgid ""
"Since Python 3.6, if the generator appears in an :keyword:`async def` "
"function, then :keyword:`async for` clauses and :keyword:`await` "
"expressions are permitted as with an asynchronous comprehension.  If a "
"generator expression contains either :keyword:`async for` clauses or "
":keyword:`await` expressions it is called an :dfn:`asynchronous generator"
" expression`. An asynchronous generator expression yields a new "
"asynchronous generator object, which is an asynchronous iterator (see "
":ref:`async-iterators`)."
msgstr ""
"파이썬 3.6부터, 제너레이터가 :keyword:`async def` 함수에서 등장하면, 비동기 컴프리헨션 처럼 "
":keyword:`async for` 절과 :keyword:`await` 표현식이 허락된다. 제너레이터 표현식이 "
":keyword:`async for` 절이나 :keyword:`await` 표현식을 포함하면 :dfn:`비동기 제너레이터 표현식 "
"(asynchronous generator expression)` 이라고 불린다. 비동기 제너레이터 표현식은 새 비동기 제너레이터 "
"객체를 만드는데 이것은 비동기 이터레이터다 (:ref:`async-iterators` 를 참고하라)."

#: ../Doc/reference/expressions.rst:341
msgid "Yield expressions"
msgstr "일드 표현식(Yield expressions)"

#: ../Doc/reference/expressions.rst:352
msgid ""
"The yield expression is used when defining a :term:`generator` function "
"or an :term:`asynchronous generator` function and thus can only be used "
"in the body of a function definition.  Using a yield expression in a "
"function's body causes that function to be a generator, and using it in "
"an :keyword:`async def` function's body causes that coroutine function to"
" be an asynchronous generator. For example::"
msgstr ""
"일드 표현식은 :term:`제너레이터 <generator>` 함수나 :term:`비동기 제너레이터 <asynchronous "
"generator>` 함수를 정의할 때 사용되고, 그래서 함수 정의의 바디에서만 사용될 수 있다. 함수의 바디에서 일드 표현식을 "
"사용하는 것은 함수를 제너레이터로 만들고, :keyword:`async def` 함수의 바디에서 사용하는 것은 그 코루틴 함수를 "
"비동기 제너레이터로 만든다. 예를 들어::"

#: ../Doc/reference/expressions.rst:365
msgid ""
"Generator functions are described below, while asynchronous generator "
"functions are described separately in section :ref:`asynchronous-"
"generator-functions`."
msgstr ""
"제너레이터 함수는 다음에서 설명한다. 반면에 비동기 제너레이터 함수는 :ref:`asynchronous-generator-"
"functions` 섹션에서 별도로 설명한다."

#: ../Doc/reference/expressions.rst:369
msgid ""
"When a generator function is called, it returns an iterator known as a "
"generator.  That generator then controls the execution of the generator "
"function. The execution starts when one of the generator's methods is "
"called.  At that time, the execution proceeds to the first yield "
"expression, where it is suspended again, returning the value of "
":token:`expression_list` to the generator's caller.  By suspended, we "
"mean that all local state is retained, including the current bindings of "
"local variables, the instruction pointer, the internal evaluation stack, "
"and the state of any exception handling.  When the execution is resumed "
"by calling one of the generator's methods, the function can proceed "
"exactly as if the yield expression were just another external call.  The "
"value of the yield expression after resuming depends on the method which "
"resumed the execution.  If :meth:`~generator.__next__` is used (typically"
" via either a :keyword:`for` or the :func:`next` builtin) then the result"
" is :const:`None`.  Otherwise, if :meth:`~generator.send` is used, then "
"the result will be the value passed in to that method."
msgstr ""
"제너레이터 함수가 호출될 때, 제너레이터로 알려진 이터레이터를 돌려준다. 그러면 그 제너레이터가 제너레이터 함수의 실행을 제어한다."
" 제너레이터의 메서드들 중 하나가 호출될 때 실행이 시작된다. 그 시점에, 실행은 첫 번째 일드 표현식까지 진행한 후, 거기에서 다시"
" 일시 중지(suspend)하고 제너레이터의 호출자에게 :token:`expression_list` 의 값을 돌려준다. 일시 "
"중지된다는 것은, 모든 지역 상태가 보존된다는 뜻인데, 지역 변수들의 현재 연결들, 명령 포인터(instruction "
"pointer), 내부 연산 스택(internal evaluation stack), 모든 예외 처리 상태가 포함된다. 제너레이터의 "
"메서드들 중 하나를 호출해서 실행이 재개될 때, 함수는 마치 일드 표현식이 단지 또 하나의 외부 호출인 것처럼 진행할 수 있다. "
"재개된 후에 일드 표현식의 값은 실행을 재개하도록 만든 메서드에 달려있다. (보통 :keyword:`for` 나 "
":func:`next` 내장을 통해) :meth:`~generator.__next__` 가 사용되었다면 결과는 "
":const:`None` 이다. 그렇지 않고, :meth:`~generator.send` 가 사용되었다면, 결과는 그 메서드로 "
"전달된 값이다."

#: ../Doc/reference/expressions.rst:388
msgid ""
"All of this makes generator functions quite similar to coroutines; they "
"yield multiple times, they have more than one entry point and their "
"execution can be suspended.  The only difference is that a generator "
"function cannot control where the execution should continue after it "
"yields; the control is always transferred to the generator's caller."
msgstr ""
"이 모든 것들은 제너레이터 함수를 코루틴과 아주 비슷하게 만든다; 여러 번 결과를 만들고, 하나 이상의 진입 지점을 갖고 있으며, "
"실행이 일시 중지될 수 있다. 유일한 차이점은 제너레이터 함수는 yield 한 후에 실행이 어디에서 계속되어야 하는지를 제어할 수 "
"없다는 점이다; 제어는 항상 제너레이터의 호출자로 전달된다."

#: ../Doc/reference/expressions.rst:394
msgid ""
"Yield expressions are allowed anywhere in a :keyword:`try` construct.  If"
" the generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), the generator-iterator's "
":meth:`~generator.close` method will be called, allowing any pending "
":keyword:`finally` clauses to execute."
msgstr ""
"일드 표현식은 :keyword:`try` 구조물의 어디에서건 허락된다. 제너레이터가 (참조 횟수가 0이 되거나 가비지 수거됨으로써)"
" 파이널라이즈(finalize)되기 전에 재개되지 않으면, 제너레이터-이터레이터의 :meth:`~generator.close` "
"메서드가 호출되어, 대기 중인 :keyword:`finally` 절이 실행되도록 허락한다."

#: ../Doc/reference/expressions.rst:400
msgid ""
"When ``yield from <expr>`` is used, it treats the supplied expression as "
"a subiterator. All values produced by that subiterator are passed "
"directly to the caller of the current generator's methods. Any values "
"passed in with :meth:`~generator.send` and any exceptions passed in with "
":meth:`~generator.throw` are passed to the underlying iterator if it has "
"the appropriate methods.  If this is not the case, then "
":meth:`~generator.send` will raise :exc:`AttributeError` or "
":exc:`TypeError`, while :meth:`~generator.throw` will just raise the "
"passed in exception immediately."
msgstr ""
"``yield from <expr>`` 이 사용될 때, 제공된 표현식을 서브 이터레이터(subiterator)로 취급한다. "
"서브 이터레이터가 만드는 모든 값은 현재 제너레이터 메서드의 호출자에게 바로 전달된다. :meth:`~generator.send` "
"로 전달된 모든 값과 :meth:`~generator.throw` 로 전달된 모든 예외는 밑에 있는(underlying) "
"이터레이터가 해당 메서드를 갖고 있다면 그곳으로 전달된다. 그렇지 않다면, :meth:`~generator.send` 는 "
":exc:`AttributeError` 나 :exc:`TypeError` 를 일으키지만, "
":meth:`~generator.throw` 는 전달된 예외를 즉시 일으킨다."

#: ../Doc/reference/expressions.rst:409
msgid ""
"When the underlying iterator is complete, the "
":attr:`~StopIteration.value` attribute of the raised :exc:`StopIteration`"
" instance becomes the value of the yield expression. It can be either set"
" explicitly when raising :exc:`StopIteration`, or automatically when the "
"sub-iterator is a generator (by returning a value from the sub-"
"generator)."
msgstr ""
"밑에 있는 이러레이터가 완료될 때, 발생하는 :exc:`StopIteration` 인스턴스의 "
":attr:`~StopIteration.value` 어트리뷰트는 일드 표현식의 값이 된다. :exc:`StopIteration` 를"
" 일으킬 때 명시적으로 설정되거나, 서브 이터레이터가 제너레이터일 경우는 자동으로 이루어진다 (서브 제너레이터가 값을 "
"돌려(return)줌으로써)."

#: ../Doc/reference/expressions.rst:415
msgid "Added ``yield from <expr>`` to delegate control flow to a subiterator."
msgstr "서브 이터레이터로 제어 흐름을 위임하는 ``yield from <expr>`` 를 추가했다."

#: ../Doc/reference/expressions.rst:418
msgid ""
"The parentheses may be omitted when the yield expression is the sole "
"expression on the right hand side of an assignment statement."
msgstr "일드 표현식이 대입문의 우변에 홀로 나온다면 괄호를 생략할 수 있다."

#: ../Doc/reference/expressions.rst:424
msgid ":pep:`255` - Simple Generators"
msgstr ":pep:`255` - 간단한 제너레이터"

#: ../Doc/reference/expressions.rst:424
msgid ""
"The proposal for adding generators and the :keyword:`yield` statement to "
"Python."
msgstr "파이썬에 제너레이터와 :keyword:`yield` 문을 추가하는 제안."

#: ../Doc/reference/expressions.rst:428
msgid ":pep:`342` - Coroutines via Enhanced Generators"
msgstr ":pep:`342` - 개선된 제너레이터를 통한 코루틴"

#: ../Doc/reference/expressions.rst:427
msgid ""
"The proposal to enhance the API and syntax of generators, making them "
"usable as simple coroutines."
msgstr "제너레이터의 API와 문법을 개선해서, 간단한 코루틴으로 사용할 수 있도록 만드는 제안."

#: ../Doc/reference/expressions.rst:431
msgid ":pep:`380` - Syntax for Delegating to a Subgenerator"
msgstr ":pep:`380` - 서브 제너레이터로 위임하는 문법"

#: ../Doc/reference/expressions.rst:431
msgid ""
"The proposal to introduce the :token:`yield_from` syntax, making "
"delegation to sub-generators easy."
msgstr ":token:`yield_from` 문법을 도입해서, 서브 제너레이터로의 위임을 쉽게 만드는 제안."

#: ../Doc/reference/expressions.rst:438
msgid "Generator-iterator methods"
msgstr "제너레이터-이터레이터 메서드"

#: ../Doc/reference/expressions.rst:440
msgid ""
"This subsection describes the methods of a generator iterator.  They can "
"be used to control the execution of a generator function."
msgstr "이 서브섹션은 제너레이터 이터레이터의 메서드들을 설명한다. 제너레이터 함수의 실행을 제어하는데 사용될 수 있다."

#: ../Doc/reference/expressions.rst:443
msgid ""
"Note that calling any of the generator methods below when the generator "
"is already executing raises a :exc:`ValueError` exception."
msgstr "제너레이터가 이미 실행 중일 때 아래에 나오는 메서드들을 호출하면 :exc:`ValueError` 예외를 일으키는 것에 주의해야 한다."

#: ../Doc/reference/expressions.rst:451
msgid ""
"Starts the execution of a generator function or resumes it at the last "
"executed yield expression.  When a generator function is resumed with a "
":meth:`~generator.__next__` method, the current yield expression always "
"evaluates to :const:`None`.  The execution then continues to the next "
"yield expression, where the generator is suspended again, and the value "
"of the :token:`expression_list` is returned to :meth:`__next__`'s caller."
"  If the generator exits without yielding another value, a "
":exc:`StopIteration` exception is raised."
msgstr ""
"제너레이터 함수의 실행을 시작하거나 마지막으로 실행된 일드 표현식에서 재개한다. 제너레이터 함수가 "
":meth:`~generator.__next__` 메서드로 재개될 때, 현재의 일드 표현식은 항상 :const:`None` 값을 "
"갖는다. 실행은 다음 일드 표현식까지 이어지는데, 그곳에서 제너레이터는 다시 일시 중지되고, "
":token:`expression_list` 의 값을 :meth:`__next__` 의 호출자에게 돌려준다. 제너레이터가 다른 값을"
" yield 하지 않고 종료되면 :exc:`StopIteration` 예외가 발생한다."

#: ../Doc/reference/expressions.rst:460
msgid ""
"This method is normally called implicitly, e.g. by a :keyword:`for` loop,"
" or by the built-in :func:`next` function."
msgstr "이 메서드는 보통 묵시적으로 호출된다, 예를 들어, :keyword:`for` 루프나 내장 :func:`next` 함수에 의해."

#: ../Doc/reference/expressions.rst:466
msgid ""
"Resumes the execution and \"sends\" a value into the generator function."
"  The *value* argument becomes the result of the current yield "
"expression.  The :meth:`send` method returns the next value yielded by "
"the generator, or raises :exc:`StopIteration` if the generator exits "
"without yielding another value.  When :meth:`send` is called to start the"
" generator, it must be called with :const:`None` as the argument, because"
" there is no yield expression that could receive the value."
msgstr ""
"실행을 재개하고 제너레이터 함수로 값을 \"보낸다(send)\". *value* 인자는 현재 일드 표현식의 값이 된다. "
":meth:`send` 메서드는 제너레이터가 yield 하는 다음 값을 돌려주거나, 제너레이터가 다른 값을 yield 하지 않고 "
"종료하면 :exc:`StopIteration` 을 일으킨다. :meth:`send` 가 제너레이터를 시작시키도록 호출될 때, 값을 "
"받을 일드 표현식이 없으므로, 인자로는 반드시 :const:`None` 을 전달해야 한다."

#: ../Doc/reference/expressions.rst:477
msgid ""
"Raises an exception of type ``type`` at the point where the generator was"
" paused, and returns the next value yielded by the generator function.  "
"If the generator exits without yielding another value, a "
":exc:`StopIteration` exception is raised.  If the generator function does"
" not catch the passed-in exception, or raises a different exception, then"
" that exception propagates to the caller."
msgstr ""
"제너레이터가 일시 정지한 지점에서 ``type`` 형의 예외를 일으키고, 제너레이터 함수가 yield 하는 다음 값을 돌려준다. "
"제너레이터가 다른 값을 yield 하지 않고 종료하면 :exc:`StopIteration` 을 일으킨다. 제너레이터가 전달된 예외를"
" 잡지 않거나, 다른 예외를 일으키면, 그 예외는 호출자로 퍼진다."

#: ../Doc/reference/expressions.rst:488
msgid ""
"Raises a :exc:`GeneratorExit` at the point where the generator function "
"was paused.  If the generator function then exits gracefully, is already "
"closed, or raises :exc:`GeneratorExit` (by not catching the exception), "
"close returns to its caller.  If the generator yields a value, a "
":exc:`RuntimeError` is raised.  If the generator raises any other "
"exception, it is propagated to the caller.  :meth:`close` does nothing if"
" the generator has already exited due to an exception or normal exit."
msgstr ""
"제너레이터가 일시 정지한 지점에서 :exc:`GeneratorExit` 를 일으킨다. 그런 다음 제너레이터 함수가 "
"우아하게(gracefully) 종료하거나, 이미 닫혔거나, (그 예외를 잡지 않음으로써) :exc:`GeneratorExit` 를 "
"일으키면 close는 호출자로 돌아간다. 제너레이터가 값을 yield 하면 :exc:`RuntimeError` 가 발생한다. "
"제너레이터가 다른 예외를 일으키면, 호출자로 퍼진다. 제너레이터가 예외나 정상 종료로 인해 이미 종료되었다면, "
":meth:`close` 는 아무런 일도 하지 않는다."

#: ../Doc/reference/expressions.rst:499
msgid "Examples"
msgstr "사용 예"

#: ../Doc/reference/expressions.rst:501
msgid ""
"Here is a simple example that demonstrates the behavior of generators and"
" generator functions::"
msgstr "여기에 제너레이터와 제너레이터 함수의 동작을 시연하는 간단한 예가 있다::"

#: ../Doc/reference/expressions.rst:528
msgid ""
"For examples using ``yield from``, see :ref:`pep-380` in \"What's New in "
"Python.\""
msgstr ""
"``yield from`` 을 사용하는 예는, \"What's New in Python.\" 에 있는 :ref:`pep-380` 을"
" 보면 된다."

#: ../Doc/reference/expressions.rst:534
msgid "Asynchronous generator functions"
msgstr "비동기 제너레이터 함수"

#: ../Doc/reference/expressions.rst:536
msgid ""
"The presence of a yield expression in a function or method defined using "
":keyword:`async def` further defines the function as a "
":term:`asynchronous generator` function."
msgstr ""
":keyword:`async def` 를 사용한 함수나 메서드에서 일드 표현식의 존재는 그 함수를 :term:`비동기 제너레이터 "
"<asynchronous generator>` 함수로 정의한다."

#: ../Doc/reference/expressions.rst:540
msgid ""
"When an asynchronous generator function is called, it returns an "
"asynchronous iterator known as an asynchronous generator object. That "
"object then controls the execution of the generator function. An "
"asynchronous generator object is typically used in an :keyword:`async "
"for` statement in a coroutine function analogously to how a generator "
"object would be used in a :keyword:`for` statement."
msgstr ""
"비동기 제너레이터 함수가 호출되면, 비동기 제너레이터 객체로 알려진 비동기 이터레이터를 돌려준다. 그런 다음 그 객체는 제너레이터 "
"함수의 실행을 제어한다. 비동기 제너레이터 객체는 보통 코루틴 함수의 :keyword:`async for` 문에서 사용되는데, "
"제너레이터 객체가 :keyword:`for` 문에서 사용되는 방식과 유사하다."

#: ../Doc/reference/expressions.rst:547
msgid ""
"Calling one of the asynchronous generator's methods returns an "
":term:`awaitable` object, and the execution starts when this object is "
"awaited on. At that time, the execution proceeds to the first yield "
"expression, where it is suspended again, returning the value of "
":token:`expression_list` to the awaiting coroutine. As with a generator, "
"suspension means that all local state is retained, including the current "
"bindings of local variables, the instruction pointer, the internal "
"evaluation stack, and the state of any exception handling.  When the "
"execution is resumed by awaiting on the next object returned by the "
"asynchronous generator's methods, the function can proceed exactly as if "
"the yield expression were just another external call. The value of the "
"yield expression after resuming depends on the method which resumed the "
"execution.  If :meth:`~agen.__anext__` is used then the result is "
":const:`None`. Otherwise, if :meth:`~agen.asend` is used, then the result"
" will be the value passed in to that method."
msgstr ""
"비동기 제너레이터의 메서드들 중 하나를 호출하면 :term:`어웨이터블 <awaitable>` 객체를 돌려주고, 이 객체를 "
"await 할 때 실행이 시작된다. 그 시점에, 실행은 첫 번째 일드 표현식까지 진행한 후, 거기에서 다시 일시 "
"중지(suspend)하고 await 중인 코루틴에게 :token:`expression_list` 의 값을 돌려준다. 제너레이터에서"
"처럼, 일시 중지된다는 것은, 모든 지역 상태가 보존된다는 뜻인데, 지역 변수들의 현재 연결들, 명령 "
"포인터(instruction pointer), 내부 연산 스택(internal evaluation stack), 모든 예외 처리 "
"상태가 포함된다. 비동기 제너레이터의 메서드가 돌려준 다음 객체를 await 해서 실행이 재개될 때, 함수는 마치 일드 표현식이 "
"단지 또 하나의 외부 호출인 것처럼 진행할 수 있다. 재개된 후에 일드 표현식의 값은 실행을 재개하도록 만든 메서드에 달려있다. "
":meth:`~agen.__anext__` 가 사용되었다면 결과는 :const:`None` 이다. 그렇지 않고, "
":meth:`~agen.asend` 가 사용되었다면, 결과는 그 메서드로 전달된 값이다."

#: ../Doc/reference/expressions.rst:563
msgid ""
"In an asynchronous generator function, yield expressions are allowed "
"anywhere in a :keyword:`try` construct. However, if an asynchronous "
"generator is not resumed before it is finalized (by reaching a zero "
"reference count or by being garbage collected), then a yield expression "
"within a :keyword:`try` construct could result in a failure to execute "
"pending :keyword:`finally` clauses.  In this case, it is the "
"responsibility of the event loop or scheduler running the asynchronous "
"generator to call the asynchronous generator-iterator's "
":meth:`~agen.aclose` method and run the resulting coroutine object, thus "
"allowing any pending :keyword:`finally` clauses to execute."
msgstr ""
"비동기 제너레이터 함수에서, 일드 표현식은 :keyword:`try` 구조물의 어디에서건 허락된다. 하지만, 비동기 제너레이터가 "
"(참조 횟수가 0이 되거나 가비지 수거됨으로써) 파이널라이즈(finalize)되기 전에 재개되지 않으면, :keyword:`try`"
" 구조물 내의 일드 표현식은 대기 중인 :keyword:`finally` 절을 실행하는 데 실패할 수 있다. 이 경우에, 비동기 "
"제너레이터-이터레이터의 :meth:`~agen.aclose` 를 호출하고, 그 결과로 오는 코루틴 객체를 실행해서, 대기 중인 "
":keyword:`finally` 절이 실행되도록 하는 책임은, 비동기 제너레이터를 실행하는 이벤트 루프(event loop)나 "
"스케쥴러(scheduler)에게 있다."

#: ../Doc/reference/expressions.rst:574
msgid ""
"To take care of finalization, an event loop should define a *finalizer* "
"function which takes an asynchronous generator-iterator and presumably "
"calls :meth:`~agen.aclose` and executes the coroutine. This  *finalizer* "
"may be registered by calling :func:`sys.set_asyncgen_hooks`. When first "
"iterated over, an asynchronous generator-iterator will store the "
"registered *finalizer* to be called upon finalization. For a reference "
"example of a *finalizer* method see the implementation of "
"``asyncio.Loop.shutdown_asyncgens`` in "
":source:`Lib/asyncio/base_events.py`."
msgstr ""
"파이널리제이션을 처리하기 위해, 이벤트 루프는 *파이널라이저(finalizer)* 함수를 정의해야 하는데 비동기 "
"제너레이터-이터레이터를 받아서 아마도 :meth:`~agen.aclose` 를 호출하고 그 코루틴을 실행한다. 이 *파이널라이저* "
"는 :func:`sys.set_asyncgen_hooks` 을 호출해서 등록할 수 있다. 처음 탐색 될 때, 비동기 "
"제너레이터-이터레이터는 파이널리제이션때 호출될 등록된 *파이널라이저* 를 저장할 것이다. *파이널라이저* 메서드의 참조할만한 예는 "
":source:`Lib/asyncio/base_events.py` 에 있는 "
"``asyncio.Loop.shutdown_asyncgens`` 구현을 보면 된다."

#: ../Doc/reference/expressions.rst:583
msgid ""
"The expression ``yield from <expr>`` is a syntax error when used in an "
"asynchronous generator function."
msgstr "표현식 ``yield from <expr>`` 를 비동기 제너레이터 함수에서 사용하는 것은 문법 에러다."

#: ../Doc/reference/expressions.rst:590
msgid "Asynchronous generator-iterator methods"
msgstr "비동기 제너레이터-이터레이터 메서드"

#: ../Doc/reference/expressions.rst:592
msgid ""
"This subsection describes the methods of an asynchronous generator "
"iterator, which are used to control the execution of a generator "
"function."
msgstr "이 서브섹션은 비동기 제너레이터 이터레이터의 메서드를 설명하는데, 제너레이터 함수의 실행을 제어하는 데 사용된다."

#: ../Doc/reference/expressions.rst:600
msgid ""
"Returns an awaitable which when run starts to execute the asynchronous "
"generator or resumes it at the last executed yield expression.  When an "
"asynchronous generator function is resumed with a :meth:`~agen.__anext__`"
" method, the current yield expression always evaluates to :const:`None` "
"in the returned awaitable, which when run will continue to the next yield"
" expression. The value of the :token:`expression_list` of the yield "
"expression is the value of the :exc:`StopIteration` exception raised by "
"the completing coroutine.  If the asynchronous generator exits without "
"yielding another value, the awaitable instead raises an "
":exc:`StopAsyncIteration` exception, signalling that the asynchronous "
"iteration has completed."
msgstr ""
"어웨이터블을 돌려주는데, 실행하면 비동기 제너레이터 함수의 실행을 시작하거나 마지막으로 실행된 일드 표현식에서 재개한다. 비동기 "
"제너레이터 함수가 :meth:`~agen.__anext__` 메서드로 재개될 때, 반환된 어웨이터블에서 현재의 일드 표현식은 항상 "
":const:`None` 값을 갖고 반환된 어웨이터블을 실행하면 다음 일드 표현식까지 이어진다. 일드 표현식의 "
":token:`expression_list` 의 값은 종료하는 코루틴이 일으킨 :exc:`StopIteration` 의 값이다. "
"비동기 제너레이터가 다른 값을 yield 하지 않고 종료되면, 비동기 탐색의 종료를 알리기 위해 어웨이터블이 대신 "
":exc:`StopAsyncIteration` 예외를 일으킨다."

#: ../Doc/reference/expressions.rst:612
msgid "This method is normally called implicitly by a :keyword:`async for` loop."
msgstr "이 메서드는 보통 :keyword:`async for` 루프에 의해 묵시적으로 호출된다."

#: ../Doc/reference/expressions.rst:617
msgid ""
"Returns an awaitable which when run resumes the execution of the "
"asynchronous generator. As with the :meth:`~generator.send()` method for "
"a generator, this \"sends\" a value into the asynchronous generator "
"function, and the *value* argument becomes the result of the current "
"yield expression. The awaitable returned by the :meth:`asend` method will"
" return the next value yielded by the generator as the value of the "
"raised :exc:`StopIteration`, or raises :exc:`StopAsyncIteration` if the "
"asynchronous generator exits without yielding another value.  When "
":meth:`asend` is called to start the asynchronous generator, it must be "
"called with :const:`None` as the argument, because there is no yield "
"expression that could receive the value."
msgstr ""
"어웨이터블을 돌려주는데, 실행하면 비동기 제너레이터의 실행을 재개한다. 제너레이터의 :meth:`~generator.send()` "
"메서드 처럼, 이것은 값을 비동기 제너레이터 함수로 \"보내(send)\"고, *value* 인자는 현재 일드 표현식의 결과가 "
"된다. :meth:`asend` 메서드가 돌려주는 어웨이터블은 제너레이터가 yield 하는 다음 값을 발생시킨 "
":exc:`StopIteration` 의 값으로 돌려주거나, 비동기 제너레이터가 다른 값을 yield 하지 않고 종료하면 "
":exc:`StopAsyncIteration` 를 일으킨다. 비동기 제너레이터를 시작시키도록 :meth:`asend` 가 호출될 "
"때, 값을 받을 일드 표현식이 없으므로 인자를 :const:`None` 으로 호출해야 한다."

#: ../Doc/reference/expressions.rst:632
msgid ""
"Returns an awaitable that raises an exception of type ``type`` at the "
"point where the asynchronous generator was paused, and returns the next "
"value yielded by the generator function as the value of the raised "
":exc:`StopIteration` exception.  If the asynchronous generator exits "
"without yielding another value, an :exc:`StopAsyncIteration` exception is"
" raised by the awaitable. If the generator function does not catch the "
"passed-in exception, or raises a different exception, then when the "
"awaitable is run that exception propagates to the caller of the "
"awaitable."
msgstr ""
"어웨이터블을 돌려주는데, 비동기 제너레이터가 일시 중지한 지점에 ``type`` 형의 예외를 일으키고, 제너레이터 함수가 yield"
" 한 다음 값을 발생하는 :exc:`StopIteration` 예외의 값으로 돌려준다. 비동기 제너레이터가 다른 값을 yield "
"하지 않고 종료하면, 어웨이터블에 의해 :exc:`StopAsyncIteration` 예외가 일어난다. 제너레이터 함수가 전달된 "
"예외를 잡지 않거나, 다른 예외를 일으키면, 어웨이터블을 실행할 때 그 예외가 어웨이터블의 호출자에게 퍼진다."

#: ../Doc/reference/expressions.rst:647
msgid ""
"Returns an awaitable that when run will throw a :exc:`GeneratorExit` into"
" the asynchronous generator function at the point where it was paused. If"
" the asynchronous generator function then exits gracefully, is already "
"closed, or raises :exc:`GeneratorExit` (by not catching the exception), "
"then the returned awaitable will raise a :exc:`StopIteration` exception. "
"Any further awaitables returned by subsequent calls to the asynchronous "
"generator will raise a :exc:`StopAsyncIteration` exception.  If the "
"asynchronous generator yields a value, a :exc:`RuntimeError` is raised by"
" the awaitable.  If the asynchronous generator raises any other "
"exception, it is propagated to the caller of the awaitable.  If the "
"asynchronous generator has already exited due to an exception or normal "
"exit, then further calls to :meth:`aclose` will return an awaitable that "
"does nothing."
msgstr ""
"어웨이터블을 돌려주는데, 실행하면, 비동기 제너레이터 함수가 일시 정지한 지점으로 :exc:`GeneratorExit` 를 "
"던진다. 만약 그 이후에 비동기 제너레이터 함수가 우아하게 (gracefully) 종료하거나, 이미 닫혔거나, (그 예외를 잡지 "
"않음으로써) :exc:`GeneratorExit` 를 일으키면, 돌려준 어웨이터블은 :exc:`StopIteration` 예외를 "
"일으킨다. 이어지는 비동기 제너레이터 호출이 돌려주는 추가의 어웨이터블들은 :exc:`StopAsyncIteration` 예외를 "
"일으킨다. 만약 비동기 제너레이터가 값을 yield 하면 어웨이터블에 의해 :exc:`RuntimeError` 가 발생한다. 만약 "
"비동기 제너레이터가 그 밖의 다른 예외를 일으키면, 어웨이터블의 호출자로 퍼진다. 만약 비동기 제너레이터가 예외나 정상 종료로 "
"이미 종료했으면, 더 이어지는 :meth:`aclose` 호출은 아무것도 하지 않는 어웨이터블을 돌려준다."

#: ../Doc/reference/expressions.rst:663
msgid "Primaries"
msgstr "프라이머리"

#: ../Doc/reference/expressions.rst:667
msgid ""
"Primaries represent the most tightly bound operations of the language. "
"Their syntax is:"
msgstr "프라이머리는 언어에서 가장 강하게 결합하는 연산들을 나타낸다. 문법은 이렇다:"

#: ../Doc/reference/expressions.rst:677
msgid "Attribute references"
msgstr "어트리뷰트 참조"

#: ../Doc/reference/expressions.rst:681
msgid "An attribute reference is a primary followed by a period and a name:"
msgstr "어트리뷰트 참조는 마침표(period)와 이름이 뒤에 붙은 프라이머리다:"

#: ../Doc/reference/expressions.rst:691
msgid ""
"The primary must evaluate to an object of a type that supports attribute "
"references, which most objects do.  This object is then asked to produce "
"the attribute whose name is the identifier.  This production can be "
"customized by overriding the :meth:`__getattr__` method.  If this "
"attribute is not available, the exception :exc:`AttributeError` is "
"raised.  Otherwise, the type and value of the object produced is "
"determined by the object.  Multiple evaluations of the same attribute "
"reference may yield different objects."
msgstr ""
"프라이머리는 값을 구했을 때 어트리뷰트 참조를 지원하는 형의 객체가 나와야 하는데, 대부분 객체가 이 상황에 해당한다. 이 객체는"
" 그 이름을 식별자로 하는 어트리뷰트를 생산하도록 요청받는다. 이 생산은 :meth:`__getattr__` 메서드를 재정의해서 "
"커스터마이즈 할 수 있다. 이 어트리뷰트가 없으면, :exc:`AttributeError` 을 일으킨다. 그렇지 않으면, 생산된 "
"객체의 형과 값은 그 객체에 의해 결정된다. 같은 어트리뷰트 참조의 값을 여러 번 구하면 각기 다른 객체가 얻어질 수 있다."

#: ../Doc/reference/expressions.rst:703
msgid "Subscriptions"
msgstr "서브스크립션(Subscriptions)"

#: ../Doc/reference/expressions.rst:716
msgid ""
"A subscription selects an item of a sequence (string, tuple or list) or "
"mapping (dictionary) object:"
msgstr "서브스크립션은 시퀀스(문자열, 튜플, 리스트)나 매핑 (딕셔너리) 객체의 항목을 선택한다:"

#: ../Doc/reference/expressions.rst:722
msgid ""
"The primary must evaluate to an object that supports subscription (lists "
"or dictionaries for example).  User-defined objects can support "
"subscription by defining a :meth:`__getitem__` method."
msgstr ""
"프라이머리는 값을 구했을 때 서브스크립션을 지원하는 객체가 나와야 한다 (예를 들어, 리스트나 딕셔너리). 사용자 정의 객체들은 "
":meth:`__getitem__` 메서드를 구현해서 서브스크립션을 지원할 수 있다."

#: ../Doc/reference/expressions.rst:726
msgid ""
"For built-in objects, there are two types of objects that support "
"subscription:"
msgstr "내장 객체들의 경우, 서브스크립션을 지원하는 두 가지 종류의 객체들이 있다:"

#: ../Doc/reference/expressions.rst:728
msgid ""
"If the primary is a mapping, the expression list must evaluate to an "
"object whose value is one of the keys of the mapping, and the "
"subscription selects the value in the mapping that corresponds to that "
"key.  (The expression list is a tuple except if it has exactly one item.)"
msgstr ""
"프라이머리가 매핑이면, 표현식 목록은 값을 구했을 때 매핑의 키 중 하나가 되어야 하고, 서브스크립션은 매핑에서 그 키에 대응하는 "
"값을 선택한다. (표현식 목록은 정확히 하나의 항목을 가지는 경우만을 제외하고는 튜플이다.)"

#: ../Doc/reference/expressions.rst:733
msgid ""
"If the primary is a sequence, the expression (list) must evaluate to an "
"integer or a slice (as discussed in the following section)."
msgstr "프라이머리가 시퀀스면, 표현식(목록)은 값을 구했을 때 정수나 슬라이스(slice) (다음 섹션에서 논의한다)가 나와야 한다."

#: ../Doc/reference/expressions.rst:736
msgid ""
"The formal syntax makes no special provision for negative indices in "
"sequences; however, built-in sequences all provide a :meth:`__getitem__` "
"method that interprets negative indices by adding the length of the "
"sequence to the index (so that ``x[-1]`` selects the last item of ``x``)."
"  The resulting value must be a nonnegative integer less than the number "
"of items in the sequence, and the subscription selects the item whose "
"index is that value (counting from zero). Since the support for negative "
"indices and slicing occurs in the object's :meth:`__getitem__` method, "
"subclasses overriding this method will need to explicitly add that "
"support."
msgstr ""
"형식 문법은 시퀀스에서 음수 인덱스에 대해 특별히 규정하지 않는다; 하지만, 내장 시퀀스들은 모두 인덱스에 시퀀스의 길이를 더하는 "
"것으로 음의 인덱스를 해석하는 :meth:`__getitem__` 메서드를 제공한다 (그래서 ``x[-1]`` 은 ``x`` 의 "
"마지막 항목을 선택한다). 결괏값은 반드시 시퀀스에 있는 항목들의 개수보다 작은 음이 아닌 정수가 되어야 하고, 서브스크립션은 "
"인덱스가 그 값이 되는 항목을 선택한다 (0에서 부 터 센다). 음의 인덱스와 슬라이싱에 대한 지원이 객체의 "
":meth:`__getitem__` 메서드에서 이루어지기 때문에, 이 메서드를 재정의하는 서브 클래스는 그 지원을 명시적으로 추가할 "
"필요가 있다."

#: ../Doc/reference/expressions.rst:750
msgid ""
"A string's items are characters.  A character is not a separate data type"
" but a string of exactly one character."
msgstr "문자열의 항목은 문자다. 문자는 별도의 데이터형이 아니고, 하나의 문자만을 가진 문자열이다."

#: ../Doc/reference/expressions.rst:757
msgid "Slicings"
msgstr "슬라이싱(Slicings)"

#: ../Doc/reference/expressions.rst:769
msgid ""
"A slicing selects a range of items in a sequence object (e.g., a string, "
"tuple or list).  Slicings may be used as expressions or as targets in "
"assignment or :keyword:`del` statements.  The syntax for a slicing:"
msgstr ""
"슬라이싱은 시퀀스 객체 (예를 들어, 문자열 튜플 리스트)에서 어떤 범위의 항목들을 선택한다. 슬라이싱은 표현식이나 대입의 "
"타깃이나 :keyword:`del` 문에 사용될 수 있다. 슬라이싱의 문법은 이렇다:"

#: ../Doc/reference/expressions.rst:782
msgid ""
"There is ambiguity in the formal syntax here: anything that looks like an"
" expression list also looks like a slice list, so any subscription can be"
" interpreted as a slicing.  Rather than further complicating the syntax, "
"this is disambiguated by defining that in this case the interpretation as"
" a subscription takes priority over the interpretation as a slicing (this"
" is the case if the slice list contains no proper slice)."
msgstr ""
"이 형식 문법에는 모호함이 있다: 표현식 목록처럼 보이는 것들은 모두 슬라이스 목록으로 보이기도 해서, 모든 서브스크립션이 "
"슬라이싱으로 해석될 수도 있다. 문법을 더 복잡하게 만드는 대신, 이 경우에 서브스크립션으로 해석하는 것이 슬라이싱으로 해석하는 "
"것에 우선한다고 정의하는 것으로 애매함을 제거한다 (이 경우는 슬라이스 목록이 고유한 슬라이스(proper slice) 를 하나도 "
"포함하지 않을 때다)."

#: ../Doc/reference/expressions.rst:794
msgid ""
"The semantics for a slicing are as follows.  The primary is indexed "
"(using the same :meth:`__getitem__` method as normal subscription) with a"
" key that is constructed from the slice list, as follows.  If the slice "
"list contains at least one comma, the key is a tuple containing the "
"conversion of the slice items; otherwise, the conversion of the lone "
"slice item is the key.  The conversion of a slice item that is an "
"expression is that expression.  The conversion of a proper slice is a "
"slice object (see section :ref:`types`) whose :attr:`~slice.start`, "
":attr:`~slice.stop` and :attr:`~slice.step` attributes are the values of "
"the expressions given as lower bound, upper bound and stride, "
"respectively, substituting ``None`` for missing expressions."
msgstr ""
"슬라이싱의 의미는 다음과 같다. 프라이머리가 (일반 서브스크립션과 같은 :meth:`__getitem__` 메서드를 사용해서) "
"다음과 같이 슬라이스 목록으로부터 만들어지는 키로 인덱싱된다. 슬라이스 목록이 적어도 하나의 쉼표를 갖는다면, 키는 슬라이스 "
"항목들의 변환을 포함하는 튜플이다; 그렇지 않으면 슬라이스 항목 하나의 변환이 키다. 표현식인 슬라이스 항목의 변환은 그 "
"표현식이다. 고유한 슬라이스(proper slice)의 변환은 슬라이스 객체 (섹션 :ref:`types` 를 보라)인데, "
":attr:`~slice.start`, :attr:`~slice.stop`, :attr:`~slice.step` 어트리뷰트가 각각 "
"``lower_bound``, ``upper_bound``, ``stride`` 로 주어진 표현식이고, 빠진 표현식들을 "
"``None`` 으로 채운다."

#: ../Doc/reference/expressions.rst:815
msgid "Calls"
msgstr "호출"

#: ../Doc/reference/expressions.rst:817
msgid ""
"A call calls a callable object (e.g., a :term:`function`) with a possibly"
" empty series of :term:`arguments <argument>`:"
msgstr ""
"호출은 콜러블 객체 (예를 들어, :term:`함수 <function>`) 를 빌 수도 있는 :term:`인자 <argument>`"
" 들의 목록으로 호출한다."

#: ../Doc/reference/expressions.rst:833
msgid ""
"An optional trailing comma may be present after the positional and "
"keyword arguments but does not affect the semantics."
msgstr "생략할 수 있는 마지막 쉼표가 위치나 키워드 인자 뒤에 나타날 수 있지만, 의미를 바꾸지 않는다."

#: ../Doc/reference/expressions.rst:839
msgid ""
"The primary must evaluate to a callable object (user-defined functions, "
"built-in functions, methods of built-in objects, class objects, methods "
"of class instances, and all objects having a :meth:`__call__` method are "
"callable).  All argument expressions are evaluated before the call is "
"attempted.  Please refer to section :ref:`function` for the syntax of "
"formal :term:`parameter` lists."
msgstr ""
"프라이머리의 값을 구하면 콜러블 객체 (사용자 정의 함수, 내장 함수, 내장 객체들의 메서드, 클래스 객체, 클래스 인스턴스의 "
"메서드, :meth:`__call__` 메서드를 갖는 모든 객체가 콜러블이다) 가 나와야 한다. 모든 인자 표현식들은 호출을 "
"시도하기 전에 값이 구해진다. 형식 :term:`파라미터 <parameter>` 목록의 문법은 :ref:`function` 섹션을 "
"참고하면 된다."

#: ../Doc/reference/expressions.rst:847
msgid ""
"If keyword arguments are present, they are first converted to positional "
"arguments, as follows.  First, a list of unfilled slots is created for "
"the formal parameters.  If there are N positional arguments, they are "
"placed in the first N slots.  Next, for each keyword argument, the "
"identifier is used to determine the corresponding slot (if the identifier"
" is the same as the first formal parameter name, the first slot is used, "
"and so on).  If the slot is already filled, a :exc:`TypeError` exception "
"is raised. Otherwise, the value of the argument is placed in the slot, "
"filling it (even if the expression is ``None``, it fills the slot).  When"
" all arguments have been processed, the slots that are still unfilled are"
" filled with the corresponding default value from the function "
"definition.  (Default values are calculated, once, when the function is "
"defined; thus, a mutable object such as a list or dictionary used as "
"default value will be shared by all calls that don't specify an argument "
"value for the corresponding slot; this should usually be avoided.)  If "
"there are any unfilled slots for which no default value is specified, a "
":exc:`TypeError` exception is raised.  Otherwise, the list of filled "
"slots is used as the argument list for the call."
msgstr ""
"키워드 인자가 있으면, 먼저 다음과 같이 위치 인자로 변환된다. 먼저 형식 파라미터들의 채워지지 않은 슬롯들의 목록이 만들어진다. N "
"개의 위치 인자들이 있다면, 처음 N 개의 슬롯에 넣는다. 그다음, 각 키워드 인자마다, 식별자가 대응하는 슬롯을 결정하는 데 "
"사용된다 (식별자가 첫 번째 형식 파라미터의 이름과 같으면, 첫 번째 슬롯은 사용되고, 이런 식으로 계속한다). 슬롯이 이미 채워졌으면, "
":exc:`TypeError` 예외를 일으킨다. 그렇지 않으면 그 인자의 값을 슬롯에 채워 넣는다 (표현식이 ``None`` 이라 "
"할지라도, 슬롯을 채우게 된다). 모든 인자가 처리되었을 때, 아직 채워지지 않은 슬롯들을 함수 정의로부터 오는 대응하는 "
"기본값들로 채운다. (기본값들은 함수가 정의될 때 한 번만 값을 구한다; 그래서, 리스트나 딕셔너리 같은 가변객체들이 기본값으로 "
"사용되면 해당 슬롯에 인자값을 지정하지 않은 모든 호출에서 공유된다; 보통 이런 상황은 피해야 할 일이다.) 만약 기본값이 지정되지"
" 않고, 아직도 비어있는 슬롯이 남아있다면, :exc:`TypeError` 예외가 발생한다. 그렇지 않으면, 채워진 슬롯의 목록이 "
"호출의 인자 목록으로 사용된다."

#: ../Doc/reference/expressions.rst:867
msgid ""
"An implementation may provide built-in functions whose positional "
"parameters do not have names, even if they are 'named' for the purpose of"
" documentation, and which therefore cannot be supplied by keyword.  In "
"CPython, this is the case for functions implemented in C that use "
":c:func:`PyArg_ParseTuple` to parse their arguments."
msgstr ""
"구현은 위치 파라미터가 이름을 갖지 않아서, 설사 문서화의 목적으로 이름이 붙여졌다 하더라도, 키워드로 공급될 수 없는 내장 함수들을"
" 제공할 수 있다. CPython 에서, 인자들을 파싱하기 위해 :c:func:`PyArg_ParseTuple` 를 사용하는 C로"
" 구현된 함수들이 이 경우다."

#: ../Doc/reference/expressions.rst:873
msgid ""
"If there are more positional arguments than there are formal parameter "
"slots, a :exc:`TypeError` exception is raised, unless a formal parameter "
"using the syntax ``*identifier`` is present; in this case, that formal "
"parameter receives a tuple containing the excess positional arguments (or"
" an empty tuple if there were no excess positional arguments)."
msgstr ""
"형식 파라미터 슬롯들보다 많은 위치 인자들이 있으면, ``*identifier`` 문법을 사용하는 형식 파라미터가 있지 않은 한, "
":exc:`TypeError` 예외를 일으킨다; 이 경우, 그 형식 파라미터는 남는 위치 인자들을 포함하는 튜플을 전달받는다 (또는"
" 남는 위치 인자들이 없으면 빈 튜플)."

#: ../Doc/reference/expressions.rst:879
msgid ""
"If any keyword argument does not correspond to a formal parameter name, a"
" :exc:`TypeError` exception is raised, unless a formal parameter using "
"the syntax ``**identifier`` is present; in this case, that formal "
"parameter receives a dictionary containing the excess keyword arguments "
"(using the keywords as keys and the argument values as corresponding "
"values), or a (new) empty dictionary if there were no excess keyword "
"arguments."
msgstr ""
"키워드 인자가 형식 파라미터 이름에 대응하지 않으면, ``**identifier`` 문법을 사용하는 형식 파라미터가 있지 않은 한,"
" :exc:`TypeError` 예외를 일으킨다; 이 경우, 그 형식 파라미터는 남는 키워드 인자들을 포함하는 딕셔너리나, 남는 "
"위치기반 인자들이 없으면 빈 (새) 딕셔너리를 전달받는다."

#: ../Doc/reference/expressions.rst:890
msgid ""
"If the syntax ``*expression`` appears in the function call, "
"``expression`` must evaluate to an :term:`iterable`.  Elements from these"
" iterables are treated as if they were additional positional arguments.  "
"For the call ``f(x1, x2, *y, x3, x4)``, if *y* evaluates to a sequence "
"*y1*, ..., *yM*, this is equivalent to a call with M+4 positional "
"arguments *x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4*."
msgstr ""
"문법 ``*expression`` 이 함수 호출에 등장하면, ``expression`` 의 값은 :term:`이터러블 "
"<iterable>` 이 되어야 한다. 이 이터러블의 요소들은, 그것들이 추가의 위치 인자들인 것처럼 취급된다. 호출 "
"``f(x1, x2, *y, x3, x4)`` 의 경우, *y* 의 값을 구할 때 시퀀스 *y1*, ..., *yM* 이 나온다면,"
" 이것은 M+4개의 위치 인자들 *x1*, *x2*, *y1*, ..., *yM*, *x3*, *x4* 로 호출하는 것과 "
"동등하다."

#: ../Doc/reference/expressions.rst:897
msgid ""
"A consequence of this is that although the ``*expression`` syntax may "
"appear *after* explicit keyword arguments, it is processed *before* the "
"keyword arguments (and any ``**expression`` arguments -- see below).  "
"So::"
msgstr ""
"이로 인한 결과는 설사 ``*expression`` 문법이 명시적인 키워드 인자 *뒤에* 나올 수는 있어도, 키워드 인자 (그리고 "
"모든 ``**expression`` 인자들 -- 아래를 보라) *전에* 처리된다는 것이다. 그래서::"

#: ../Doc/reference/expressions.rst:913
msgid ""
"It is unusual for both keyword arguments and the ``*expression`` syntax "
"to be used in the same call, so in practice this confusion does not "
"arise."
msgstr ""
"같은 호출에서 키워드 인자와 ``*expression`` 문법을 모두 사용하는 것은 일반적이지 않기 때문에, 실제로는 이런 혼란이 "
"일어나지 않는다."

#: ../Doc/reference/expressions.rst:919
msgid ""
"If the syntax ``**expression`` appears in the function call, "
"``expression`` must evaluate to a :term:`mapping`, the contents of which "
"are treated as additional keyword arguments.  If a keyword is already "
"present (as an explicit keyword argument, or from another unpacking), a "
":exc:`TypeError` exception is raised."
msgstr ""
"문법 ``**expression`` 이 함수 호출에 등장하면, ``expression`` 의 값은 :term:`매핑 "
"<mapping>` 이 되어야 한다, 그 내용이 추가의 키워드 인자인 것처럼 취급된다. 키워드가 (명시적인 키워드 인자나 다른 "
"언 패킹으로부터) 이미 존재한다면 :exc:`TypeError` 예외가 발생한다."

#: ../Doc/reference/expressions.rst:925
msgid ""
"Formal parameters using the syntax ``*identifier`` or ``**identifier`` "
"cannot be used as positional argument slots or as keyword argument names."
msgstr ""
"문법 ``*identifier`` 이나 ``**identifier`` 를 사용하는 형식 파라미터들은 위치 인자 슬롯이나 키워드 인자"
" 아름들로 사용될 수 없다."

#: ../Doc/reference/expressions.rst:928
msgid ""
"Function calls accept any number of ``*`` and ``**`` unpackings, "
"positional arguments may follow iterable unpackings (``*``), and keyword "
"arguments may follow dictionary unpackings (``**``). Originally proposed "
"by :pep:`448`."
msgstr ""
"함수 호출은 임의의 개수의 ``*`` and ``**`` 언 패킹을 받아들이고, 위치 인자들이 이터러블 언 패킹 (``*``) 뒤에 올"
" 수 있고, 키워드 인자가 딕셔너리 언 패킹 (``**``) 뒤에 올 수 있다. 최초로 :pep:`448` 에서 제안되었다."

#: ../Doc/reference/expressions.rst:934
msgid ""
"A call always returns some value, possibly ``None``, unless it raises an "
"exception.  How this value is computed depends on the type of the "
"callable object."
msgstr ""
"호출은 예외를 일으키지 않는 한, 항상 어떤 값을 돌려준다, ``None`` 일 수 있다. 이 값이 어떻게 계산되는지는 콜러블 "
"객체의 형에 달려있다."

#: ../Doc/reference/expressions.rst:938
msgid "If it is---"
msgstr "만약 그것이---"

#: ../Doc/reference/expressions.rst:951
msgid "a user-defined function:"
msgstr "사용자 정의 함수면:"

#: ../Doc/reference/expressions.rst:947
msgid ""
"The code block for the function is executed, passing it the argument "
"list.  The first thing the code block will do is bind the formal "
"parameters to the arguments; this is described in section "
":ref:`function`.  When the code block executes a :keyword:`return` "
"statement, this specifies the return value of the function call."
msgstr ""
"인자 목록을 전달해서 함수의 코드 블록이 실행된다. 코드 블록이 처음으로 하는 일은 형식 파라미터들을 인자에 결합하는 것이다; 이"
"것은 섹션 :ref:`function` 에서 설명한다. 코드 블록이 :keyword:`return` 문을 실행하면, 함수 호출의 "
"반환 값을 지정하게 된다."

#: ../Doc/reference/expressions.rst:965
msgid "a built-in function or method:"
msgstr "내장 함수나 메서드면:"

#: ../Doc/reference/expressions.rst:964
msgid ""
"The result is up to the interpreter; see :ref:`built-in-funcs` for the "
"descriptions of built-in functions and methods."
msgstr "결과는 인터프리터에 달려있다; 내장 함수와 메서드들에 대한 설명은 :ref:`built-in-funcs` 를 보면 된다."

#: ../Doc/reference/expressions.rst:972
msgid "a class object:"
msgstr "클래스 객체면:"

#: ../Doc/reference/expressions.rst:972
msgid "A new instance of that class is returned."
msgstr "그 클래스의 새 인스턴스가 반환된다."

#: ../Doc/reference/expressions.rst:982
msgid "a class instance method:"
msgstr "클래스 인스턴스 메서드면:"

#: ../Doc/reference/expressions.rst:980
msgid ""
"The corresponding user-defined function is called, with an argument list "
"that is one longer than the argument list of the call: the instance "
"becomes the first argument."
msgstr "대응하는 사용자 정의 함수가 호출되는데, 그 인스턴스가 첫 번째 인자가 되는 하나만큼 더 긴 인자 목록이 전달된다."

#: ../Doc/reference/expressions.rst:991
msgid "a class instance:"
msgstr "클래스 인스턴스면:"

#: ../Doc/reference/expressions.rst:989
msgid ""
"The class must define a :meth:`__call__` method; the effect is then the "
"same as if that method was called."
msgstr "그 클래스는 :meth:`__call__` 메서드를 정의해야 한다; 그 효과는 그 메서드가 호출되는 것과 같다."

#: ../Doc/reference/expressions.rst:996 ../Doc/reference/expressions.rst:1702
msgid "Await expression"
msgstr "어웨이트 표현식"

#: ../Doc/reference/expressions.rst:998
msgid ""
"Suspend the execution of :term:`coroutine` on an :term:`awaitable` "
"object. Can only be used inside a :term:`coroutine function`."
msgstr ""
":term:`어웨이터블 <awaitable>` 에서 :term:`코루틴 <coroutine>` 의 실행을 일시 중지한다. 오직 "
":term:`코루틴 함수 <coroutine function>` 에서만 사용할 수 있다."

#: ../Doc/reference/expressions.rst:1010
msgid "The power operator"
msgstr "거듭제곱 연산자"

#: ../Doc/reference/expressions.rst:1012
msgid ""
"The power operator binds more tightly than unary operators on its left; "
"it binds less tightly than unary operators on its right.  The syntax is:"
msgstr ""
"거듭제곱 연산자는 그것의 왼쪽에 붙는 일 항 연산자보다 더 강하게 결합한다; 그것의 오른쪽에 붙는 일 항 연산자보다는 약하게 "
"결합한다. 문법은 이렇다:"

#: ../Doc/reference/expressions.rst:1018
msgid ""
"Thus, in an unparenthesized sequence of power and unary operators, the "
"operators are evaluated from right to left (this does not constrain the "
"evaluation order for the operands): ``-1**2`` results in ``-1``."
msgstr ""
"그래서, 괄호가 없는 거듭제곱과 일 항 연산자의 시퀀스에서, 연산자는 오른쪽에서 왼쪽으로 값이 구해진다 (이것이 피연산자의 값을 "
"구하는 순서를 제약하는 것은 아니다): ``-1**2`` 은 ``-1`` 이 된다."

#: ../Doc/reference/expressions.rst:1022
msgid ""
"The power operator has the same semantics as the built-in :func:`pow` "
"function, when called with two arguments: it yields its left argument "
"raised to the power of its right argument.  The numeric arguments are "
"first converted to a common type, and the result is of that type."
msgstr ""
"거듭제곱 연산자는 내장 :func:`pow` 함수가 두 개의 인자로 호출될 때와 같은 의미가 있다: 왼쪽 인자를 오른쪽 "
"인자만큼 거듭제곱한 값을 준다. 숫자 인자는 먼저 공통 형으로 변환되고, 결과는 그 형이다."

#: ../Doc/reference/expressions.rst:1027
msgid ""
"For int operands, the result has the same type as the operands unless the"
" second argument is negative; in that case, all arguments are converted "
"to float and a float result is delivered. For example, ``10**2`` returns "
"``100``, but ``10**-2`` returns ``0.01``."
msgstr ""
"int 피연산자의 경우, 두 번째 인자가 음수가 아닌 이상 결과는 피연산자들과 같은 형을 갖는다; 두 번째 인자가 음수면, 모든 "
"인자는 float로 변환되고, float 결과가 전달된다. 예를 들어, ``10**2`` 는 ``100`` 를 돌려주지만, "
"``10**-2`` 는 ``0.01`` 를 돌려준다."

#: ../Doc/reference/expressions.rst:1032
msgid ""
"Raising ``0.0`` to a negative power results in a "
":exc:`ZeroDivisionError`. Raising a negative number to a fractional power"
" results in a :class:`complex` number. (In earlier versions it raised a "
":exc:`ValueError`.)"
msgstr ""
"``0.0`` 를 음수로 거듭제곱하면 :exc:`ZeroDivisionError` 를 일으킨다. 음수를 분수로 거듭제곱하면 "
"복소수(:class:`complex`)가 나온다. (예전 버전에서는 :exc:`ValueError` 를 일으켰다.)"

#: ../Doc/reference/expressions.rst:1040
msgid "Unary arithmetic and bitwise operations"
msgstr "일 항 산술과 비트 연산"

#: ../Doc/reference/expressions.rst:1046
msgid "All unary arithmetic and bitwise operations have the same priority:"
msgstr "모든 일 항 산술과 비트 연산자는 같은 우선순위를 갖는다."

#: ../Doc/reference/expressions.rst:1055
msgid ""
"The unary ``-`` (minus) operator yields the negation of its numeric "
"argument."
msgstr "일 항 ``-`` (마이너스) 연산자는 그 숫자 인자의 음의 값을 준다."

#: ../Doc/reference/expressions.rst:1059
msgid "The unary ``+`` (plus) operator yields its numeric argument unchanged."
msgstr "일 항 ``+`` (플러스) 연산자는 그 숫자 인자의 값을 변경 없이 준다."

#: ../Doc/reference/expressions.rst:1064
msgid ""
"The unary ``~`` (invert) operator yields the bitwise inversion of its "
"integer argument.  The bitwise inversion of ``x`` is defined as "
"``-(x+1)``.  It only applies to integral numbers."
msgstr ""
"일 항 ``~`` (인버트) 연산자는 그 정수 인자의 비트 반전된 값을 준다. ``x`` 의 비트 반전은 ``-(x+1)`` 로 "
"정의된다. 오직 정수에만 적용된다."

#: ../Doc/reference/expressions.rst:1070
msgid ""
"In all three cases, if the argument does not have the proper type, a "
":exc:`TypeError` exception is raised."
msgstr "세 가지 경우 모두, 인자가 올바른 형을 갖지 않는다면, :exc:`TypeError` 예외가 발생한다."

#: ../Doc/reference/expressions.rst:1077
msgid "Binary arithmetic operations"
msgstr "이항 산술 연산"

#: ../Doc/reference/expressions.rst:1081
msgid ""
"The binary arithmetic operations have the conventional priority levels.  "
"Note that some of these operations also apply to certain non-numeric "
"types.  Apart from the power operator, there are only two levels, one for"
" multiplicative operators and one for additive operators:"
msgstr ""
"이항 산술 연산자는 관습적인 우선순위를 갖는다. 이 연산자 중 일부는 일부 비 숫자 형에도 적용됨에 주의해야 한다. 거듭제곱 "
"연산자와는 별개로, 오직 두 가지 수준만 있는데, 하나는 곱셈형 연산자들이고, 하나는 덧셈형 연산자들이다."

#: ../Doc/reference/expressions.rst:1094
msgid ""
"The ``*`` (multiplication) operator yields the product of its arguments."
"  The arguments must either both be numbers, or one argument must be an "
"integer and the other must be a sequence. In the former case, the numbers"
" are converted to a common type and then multiplied together.  In the "
"latter case, sequence repetition is performed; a negative repetition "
"factor yields an empty sequence."
msgstr ""
"``*`` (곱셈) 연산자는 인자들의 곱을 준다. 인자들은 모두 숫자거나, 한 인자는 정수고 다른 인자는 시퀀스여야 한다. 앞의"
" 경우에, 숫자들은 공통 형으로 변환된 후 곱해진다. 후자의 경우, 시퀀스의 반복이 수행된다; 음의 반복 값은 빈 시퀀스를 만든다."

#: ../Doc/reference/expressions.rst:1102
msgid ""
"The ``@`` (at) operator is intended to be used for matrix multiplication."
"  No builtin Python types implement this operator."
msgstr "``@`` (at) 연산자는 행렬 곱셈에 사용하려는 것이다. 파이썬의 내장형들 어느 것도 이 연산자를 구현하지 않는다."

#: ../Doc/reference/expressions.rst:1111
msgid ""
"The ``/`` (division) and ``//`` (floor division) operators yield the "
"quotient of their arguments.  The numeric arguments are first converted "
"to a common type. Division of integers yields a float, while floor "
"division of integers results in an integer; the result is that of "
"mathematical division with the 'floor' function applied to the result.  "
"Division by zero raises the :exc:`ZeroDivisionError` exception."
msgstr ""
"``/`` (나눗셈)과 ``//`` (정수 나눗셈, floor division) 연산자들은 그 인자들의 몫(quotient)을 "
"준다. 숫자 인자들은 먼저 공통형으로 변환된다. 정수들의 나눗셈은 실수를 만드는 반면, 정수들의 정수 나눗셈은 정숫값을 준다; 그 "
"결과는 수학적인 나눗셈의 결과에 'floor' 함수를 적용한 것이다. 0으로 나누는 것은 "
":exc:`ZeroDivisionError` 예외를 일으킨다."

#: ../Doc/reference/expressions.rst:1120
msgid ""
"The ``%`` (modulo) operator yields the remainder from the division of the"
" first argument by the second.  The numeric arguments are first converted"
" to a common type.  A zero right argument raises the "
":exc:`ZeroDivisionError` exception.  The arguments may be floating point "
"numbers, e.g., ``3.14%0.7`` equals ``0.34`` (since ``3.14`` equals "
"``4*0.7 + 0.34``.)  The modulo operator always yields a result with the "
"same sign as its second operand (or zero); the absolute value of the "
"result is strictly smaller than the absolute value of the second operand "
"[#]_."
msgstr ""
"``%`` (모듈로, modulo) 연산자는 첫 번째 인자를 두 번째 인자로 나눈 나머지를 준다. 숫자 인자들은 먼저 공통형으로 "
"변환된다. 오른쪽 인자가 0이면 :exc:`ZeroDivisionError` 예외를 일으킨다. 인자들은 실수가 될 수 있다, 예를"
" 들어, ``3.14%0.7`` 는 ``0.34`` 와 같다 (``3.14`` 가 ``4*0.7 + 0.34`` 와 같으므로.)"
" 모듈로 연산자는 항상 두 번째 피연산자와 같은 부호를 갖는 결과를 준다 (또는 0이다); 결과의 절댓값은 두 번째 피연산자의 "
"절댓값보다 작다 [#]_."

#: ../Doc/reference/expressions.rst:1129
msgid ""
"The floor division and modulo operators are connected by the following "
"identity: ``x == (x//y)*y + (x%y)``.  Floor division and modulo are also "
"connected with the built-in function :func:`divmod`: ``divmod(x, y) == "
"(x//y, x%y)``. [#]_."
msgstr ""
"정수 나눗셈과 모듈로 연산자는 다음과 같은 항등식으로 연결되어 있다: ``x == (x//y)*y + (x%y)``. 정수 나눗셈과 "
"모듈로는 내장 함수 :func:`divmod` 와도 연결되어 있다: ``divmod(x, y) == (x//y, x%y)``. "
"[#]_."

#: ../Doc/reference/expressions.rst:1134
msgid ""
"In addition to performing the modulo operation on numbers, the ``%`` "
"operator is also overloaded by string objects to perform old-style string"
" formatting (also known as interpolation).  The syntax for string "
"formatting is described in the Python Library Reference, section :ref"
":`old-string-formatting`."
msgstr ""
"숫자들에 대해 모듈로 연산을 수행하는 것에 더해, ``%`` 연산자는 예전 스타일의 문자열 포매팅 (인터폴레이션이라고도 알려져 "
"있다)을 수행하기 위해 문자열 객체에 의해 다시 정의된다. 문자열 포매팅의 문법은 파이썬 라이브러리 레퍼런스의 섹션 :ref"
":`old-string-formatting` 에서 설명한다."

#: ../Doc/reference/expressions.rst:1139
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are not defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""
"정수 나눗셈 연산자, 모듈로 연산자, :func:`divmod` 함수는 복소수에 대해서는 정의되어 있지 않다. 대신, 적절하다면, "
":func:`abs` 함수를 사용해서 실수로 변환하라."

#: ../Doc/reference/expressions.rst:1145
msgid ""
"The ``+`` (addition) operator yields the sum of its arguments.  The "
"arguments must either both be numbers or both be sequences of the same "
"type.  In the former case, the numbers are converted to a common type and"
" then added together. In the latter case, the sequences are concatenated."
msgstr ""
"``+`` (덧셈) 연산자는 그 인자들의 합을 준다. 인자들은 둘 다 숫자거나, 둘 다 같은 형의 시퀀스여야 한다. 앞의 경우, "
"숫자들은 먼저 공통형으로 변환된 후, 함께 합쳐진다. 후자의 경우 시퀀스는 이어붙이게 된다."

#: ../Doc/reference/expressions.rst:1152
msgid ""
"The ``-`` (subtraction) operator yields the difference of its arguments."
"  The numeric arguments are first converted to a common type."
msgstr "``-`` (빼기) 연산자는 그 인자들의 차를 준다. 숫자 인자들은 먼저 공통형으로 변환된다."

#: ../Doc/reference/expressions.rst:1159
msgid "Shifting operations"
msgstr "시프트 연산"

#: ../Doc/reference/expressions.rst:1163
msgid ""
"The shifting operations have lower priority than the arithmetic "
"operations:"
msgstr "시프트 연산은 산술 연산보다 낮은 우선순위를 갖는다."

#: ../Doc/reference/expressions.rst:1168
msgid ""
"These operators accept integers as arguments.  They shift the first "
"argument to the left or right by the number of bits given by the second "
"argument."
msgstr "이 연산들은 정수들을 인자로 받아들인다. 첫 번째 인자를 두 번째 인자로 주어진 비트 수만큼 왼쪽이나 오른쪽으로 민(shift)다."

#: ../Doc/reference/expressions.rst:1173
msgid ""
"A right shift by *n* bits is defined as floor division by ``pow(2,n)``.  "
"A left shift by *n* bits is defined as multiplication with ``pow(2,n)``."
msgstr ""
"오른쪽으로 *n* 비트 시프트 하는 것은 ``pow(2,n)`` 로 정수 나눗셈하는 것으로 정의된다. 왼쪽으로 *n* 비트 시프트 하는 "
"것은 ``pow(2,n)`` 를 곱하는 것으로 정의된다."

#: ../Doc/reference/expressions.rst:1178
msgid ""
"In the current implementation, the right-hand operand is required to be "
"at most :attr:`sys.maxsize`.  If the right-hand operand is larger than "
":attr:`sys.maxsize` an :exc:`OverflowError` exception is raised."
msgstr ""
"현재 구현에서, 우측 피연산자는 최대 :attr:`sys.maxsize` 일 것이 요구된다. 우측 피연산자가 "
":attr:`sys.maxsize` 보다 크면 :exc:`OverflowError` 예외가 발생한다."

#: ../Doc/reference/expressions.rst:1185
msgid "Binary bitwise operations"
msgstr "이항 비트 연산"

#: ../Doc/reference/expressions.rst:1189
msgid "Each of the three bitwise operations has a different priority level:"
msgstr "세 개의 비트 연산은 각기 다른 우선순위를 갖는다:"

#: ../Doc/reference/expressions.rst:1198
msgid ""
"The ``&`` operator yields the bitwise AND of its arguments, which must be"
" integers."
msgstr "``&`` 연산자는 그 인자들의 비트별 AND를 주는데, 인자들은 정수여야 한다."

#: ../Doc/reference/expressions.rst:1205
msgid ""
"The ``^`` operator yields the bitwise XOR (exclusive OR) of its "
"arguments, which must be integers."
msgstr "``^`` 연산자는 그 인자들의 비트별 XOR (배타적 OR)를 주는데, 인자들은 정수여야 한다."

#: ../Doc/reference/expressions.rst:1212
msgid ""
"The ``|`` operator yields the bitwise (inclusive) OR of its arguments, "
"which must be integers."
msgstr "``|`` 연산자는 그 인자들의 비트별 (포함적, inclusive) OR를 주는데, 인자들은 정수여야 한다."

#: ../Doc/reference/expressions.rst:1219
msgid "Comparisons"
msgstr "비교"

#: ../Doc/reference/expressions.rst:1225
msgid ""
"Unlike C, all comparison operations in Python have the same priority, "
"which is lower than that of any arithmetic, shifting or bitwise "
"operation.  Also unlike C, expressions like ``a < b < c`` have the "
"interpretation that is conventional in mathematics:"
msgstr ""
"C와는 달리, 파이썬에서 모든 비교 연산은 같은 우선순위를 갖는데, 산술, 시프팅, 비트 연산들보다 낮다. 또한, C와는 달리, "
"``a < b < c`` 와 같은 표현식이 수학에서와 같은 방식으로 해석된다."

#: ../Doc/reference/expressions.rst:1235
msgid "Comparisons yield boolean values: ``True`` or ``False``."
msgstr "비교는 논리값을 준다: ``True`` 또는 ``False``"

#: ../Doc/reference/expressions.rst:1239
msgid ""
"Comparisons can be chained arbitrarily, e.g., ``x < y <= z`` is "
"equivalent to ``x < y and y <= z``, except that ``y`` is evaluated only "
"once (but in both cases ``z`` is not evaluated at all when ``x < y`` is "
"found to be false)."
msgstr ""
"비교는 자유롭게 연결될 수 있다, 예를 들어, ``x < y <= z`` 는 ``x < y and y <= z`` 와 동등한데, "
"차이점은 ``y`` 의 값을 오직 한 번만 구한다는 것이다 (하지만 두 경우 모두 ``x < y`` 가 거짓이면 ``z`` 의 값은 "
"구하지 않는다)."

#: ../Doc/reference/expressions.rst:1243
msgid ""
"Formally, if *a*, *b*, *c*, ..., *y*, *z* are expressions and *op1*, "
"*op2*, ..., *opN* are comparison operators, then ``a op1 b op2 c ... y "
"opN z`` is equivalent to ``a op1 b and b op2 c and ... y opN z``, except "
"that each expression is evaluated at most once."
msgstr ""
"형식적으로, *a*, *b*, *c*, ..., *y*, *z* 가 표현식이고, *op1*, *op2*, ..., *opN* 가 "
"비교 연산자면, ``a op1 b op2 c ... y opN z`` 는 각 표현식의 값을 최대 한 번만 구한다는 점을 제외하고는 "
"``a op1 b and b op2 c and ... y opN z`` 와 동등하다."

#: ../Doc/reference/expressions.rst:1248
msgid ""
"Note that ``a op1 b op2 c`` doesn't imply any kind of comparison between "
"*a* and *c*, so that, e.g., ``x < y > z`` is perfectly legal (though "
"perhaps not pretty)."
msgstr ""
"``a op1 b op2 c`` 가 *a* 와 *c* 간의 어떤 종류의 비교도 암시하지 않기 때문에, 예를 들어, ``x < y >"
" z`` 이 완벽하게 (아마 이쁘지는 않더라도) 올바르다는 것에 주의해야 한다."

#: ../Doc/reference/expressions.rst:1253
msgid "Value comparisons"
msgstr "값 비교"

#: ../Doc/reference/expressions.rst:1255
msgid ""
"The operators ``<``, ``>``, ``==``, ``>=``, ``<=``, and ``!=`` compare "
"the values of two objects.  The objects do not need to have the same "
"type."
msgstr ""
"연산자 ``<``, ``>``, ``==``, ``>=``, ``<=``, ``!=`` 는 두 객체의 값을 비교한다. 객체들이 "
"같은 형일 필요는 없다."

#: ../Doc/reference/expressions.rst:1258
msgid ""
"Chapter :ref:`objects` states that objects have a value (in addition to "
"type and identity).  The value of an object is a rather abstract notion "
"in Python: For example, there is no canonical access method for an "
"object's value.  Also, there is no requirement that the value of an "
"object should be constructed in a particular way, e.g. comprised of all "
"its data attributes. Comparison operators implement a particular notion "
"of what the value of an object is.  One can think of them as defining the"
" value of an object indirectly, by means of their comparison "
"implementation."
msgstr ""
":ref:`objects` 장은 객체들이 (형과 아이덴티티에 더해) 값을 갖는다고 말하고 있다. 파이썬에서 객체의 값은 좀 추상적인"
" 개념이다: 예를 들어, 객체의 값에 대한 규범적인(canonical) 액세스 방법은 없다. 또한, 객체의 값이 특별한 방식(예를 "
"들어, 모든 데이터 어트리뷰트로 구성되는 것)으로 구성되어야 한다는 요구 사항도 없다. 비교 연산자는 객체의 값이 무엇인지에 대한"
" 특정한 종류의 개념을 구현한다. 객체의 값을 비교를 통해 간접적으로 정의한다고 생각해도 좋다."

#: ../Doc/reference/expressions.rst:1267
msgid ""
"Because all types are (direct or indirect) subtypes of :class:`object`, "
"they inherit the default comparison behavior from :class:`object`.  Types"
" can customize their comparison behavior by implementing :dfn:`rich "
"comparison methods` like :meth:`__lt__`, described in "
":ref:`customization`."
msgstr ""
"모든 형은 (직접적 혹은 간접적으로) :class:`object` 의 서브 형이기 때문에, 그들은 :class:`object` 로 "
"부터 기본 비교 동작을 계승한다. 형들은 :meth:`__lt__` 와 같은 풍부한 비교 메서드(:dfn:`rich "
"comparison methods`) 를 구현해서 자신의 비교 동작을 커스터마이즈할 수 있는데, "
":ref:`customization` 에서 설명된다."

#: ../Doc/reference/expressions.rst:1273
msgid ""
"The default behavior for equality comparison (``==`` and ``!=``) is based"
" on the identity of the objects.  Hence, equality comparison of instances"
" with the same identity results in equality, and equality comparison of "
"instances with different identities results in inequality.  A motivation "
"for this default behavior is the desire that all objects should be "
"reflexive (i.e. ``x is y`` implies ``x == y``)."
msgstr ""
"동등 비교 (``==`` 와 ``!=``) 의 기본 동작은 객체의 아이덴티티에 기반을 둔다. 그래서, 같은 아이덴티티를 갖는 "
"인스턴스 간의 동등 비교는 같음을 주고, 다른 아이덴티티를 갖는 인스턴스 간의 동등 비교는 다름을 준다. 이 기본 동작의 동기는 "
"모든 객체가 반사적(reflexive) (즉, ``x is y`` 는 ``x == y`` 를 암시한다) 이도록 만들고자 하는 "
"욕구다."

#: ../Doc/reference/expressions.rst:1280
msgid ""
"A default order comparison (``<``, ``>``, ``<=``, and ``>=``) is not "
"provided; an attempt raises :exc:`TypeError`.  A motivation for this "
"default behavior is the lack of a similar invariant as for equality."
msgstr ""
"기본 대소 비교(order comparison) (``<``, ``>``, ``<=``, ``>=``) 는 제공되지 않는다; "
"시도하면 :exc:`TypeError` 를 일으킨다. 이 기본 동작의 동기는 동등함과 유사한 항등 관계가 없다는 것이다."

#: ../Doc/reference/expressions.rst:1284
msgid ""
"The behavior of the default equality comparison, that instances with "
"different identities are always unequal, may be in contrast to what types"
" will need that have a sensible definition of object value and value-"
"based equality.  Such types will need to customize their comparison "
"behavior, and in fact, a number of built-in types have done that."
msgstr ""
"다른 아이덴티티를 갖는 인스턴스들이 항상 서로 다르다는, 기본 동등 비교의 동작은, 객체의 값과 값 기반의 동등함에 대한 나름의 "
"정의를 가진 형들이 필요로 하는 것과는 크게 다를 수 있다. 그런 형들은 자신의 비교 동작을 커스터마이즈 할 필요가 있고, "
"사실 많은 내장형이 그렇게 하고 있다."

#: ../Doc/reference/expressions.rst:1290
msgid ""
"The following list describes the comparison behavior of the most "
"important built-in types."
msgstr "다음 목록은 가장 중요한 내장형들의 비교 동작을 기술한다."

#: ../Doc/reference/expressions.rst:1293
msgid ""
"Numbers of built-in numeric types (:ref:`typesnumeric`) and of the "
"standard library types :class:`fractions.Fraction` and "
":class:`decimal.Decimal` can be compared within and across their types, "
"with the restriction that complex numbers do not support order "
"comparison.  Within the limits of the types involved, they compare "
"mathematically (algorithmically) correct without loss of precision."
msgstr ""
"내장 숫자 형 ((:ref:`typesnumeric`)) 과 표준 라이브러리 형 :class:`fractions.Fraction`"
" 과 :class:`decimal.Decimal` 에 속하는 숫자들은, 복소수가 대소 비교를 지원하지 않는다는 제약 사항만 빼고는,"
" 같거나 다른 형들 간의 비교가 가능하다. 관련된 형들의 한계 안에서, 정밀도의 손실 없이 수학적으로 (알고리즘 적으로) 올바르게 "
"비교한다."

#: ../Doc/reference/expressions.rst:1300
msgid ""
"The not-a-number values :const:`float('NaN')` and :const:`Decimal('NaN')`"
" are special.  They are identical to themselves (``x is x`` is true) but "
"are not equal to themselves (``x == x`` is false).  Additionally, "
"comparing any number to a not-a-number value will return ``False``.  For "
"example, both ``3 < float('NaN')`` and ``float('NaN') < 3`` will return "
"``False``."
msgstr ""
"NaN(not-a-number) 값들 :const:`float('NaN')` 과 :const:`Decimal('NaN')` 은 "
"특별하다. 이것들은 자기 자신과 같은 객체지만 (``x is x`` 는 참이다), 자기 자신과 같지는 않다 (``x == x`` 는"
" 거짓이다.). 추가로, 어떤 숫자건 NaN 값과 비교하면 ``False`` 를 돌려준다. 예를 들어, ``3 < "
"float('NaN')`` 과 ``float('NaN') < 3`` 모두 ``False`` 를 돌려준다."

#: ../Doc/reference/expressions.rst:1307
msgid ""
"Binary sequences (instances of :class:`bytes` or :class:`bytearray`) can "
"be compared within and across their types.  They compare "
"lexicographically using the numeric values of their elements."
msgstr ""
"바이너리 시퀀스들 (:class:`bytes` 나 :class:`bytearray` 의 인스턴스들)은 형을 건너 상호 비교될 수 "
"있다. 이것들은 요소들의 숫자 값을 사용해서 사전식으로(lexicographically) 비교한다."

#: ../Doc/reference/expressions.rst:1311
msgid ""
"Strings (instances of :class:`str`) compare lexicographically using the "
"numerical Unicode code points (the result of the built-in function "
":func:`ord`) of their characters. [#]_"
msgstr ""
"문자열들 (:class:`str` 의 인스턴스들) 은 문자들의 유니코드 코드 포인트(Unicode code points) (내장 "
"함수 :func:`ord` 의 결과)를 사용해서 사전식으로 비교한다. [#]_"

#: ../Doc/reference/expressions.rst:1315
msgid "Strings and binary sequences cannot be directly compared."
msgstr "문자열과 바이너리 시퀀스는 직접 비교할 수 없다."

#: ../Doc/reference/expressions.rst:1317
msgid ""
"Sequences (instances of :class:`tuple`, :class:`list`, or :class:`range`)"
" can be compared only within each of their types, with the restriction "
"that ranges do not support order comparison.  Equality comparison across "
"these types results in inequality, and ordering comparison across these "
"types raises :exc:`TypeError`."
msgstr ""
"시퀀스들 (:class:`tuple`, :class:`list`, :class:`range` 의 인스턴스들)은 같은 형끼리 비교될"
" 수 있는데, range는 대소 비교를 지원하지 않는다. 서로 다른 형들 간의 동등 비교는 다름을 주고, 서로 다른 형들 간의 "
"대소 비교는 :exc:`TypeError` 를 일으킨다."

#: ../Doc/reference/expressions.rst:1323
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements, whereby reflexivity of the elements is enforced."
msgstr "시퀀스는 대응하는 요소 간의 비교를 사용해서 사전적으로 비교하는데, 요소들의 반사성(reflexivity)이 강제된다."

#: ../Doc/reference/expressions.rst:1326
msgid ""
"In enforcing reflexivity of elements, the comparison of collections "
"assumes that for a collection element ``x``, ``x == x`` is always true.  "
"Based on that assumption, element identity is compared first, and element"
" comparison is performed only for distinct elements.  This approach "
"yields the same result as a strict element comparison would, if the "
"compared elements are reflexive.  For non-reflexive elements, the result "
"is different than for strict element comparison, and may be surprising:  "
"The non-reflexive not-a-number values for example result in the following"
" comparison behavior when used in a list::"
msgstr ""
"요소들의 반사성을 강제한다는 것은, 컬렉션의 비교가 컬렉션 요소 ``x`` 에 대해, ``x == x`` 가 항상 참이라고 "
"가정한다는 것이다. 그 가정에 기반을 둬서, 요소들의 아이덴티티가 먼저 비교된 후에, 이것이 다를 때만 요소 간의 동등 비교가 "
"수행된다. 비교되는 요소들이 반사적일 때, 이런 접근법은 엄밀한 요소 간 비교와 같은 결과를 준다. 비 반사적인 요소의 경우, 결과가 "
"엄밀한 요소 비교와 달라질 수 있고, 놀랄 수 있다: 예를 들어, 비 반사적인 NaN이 리스트에서 사용될 때 다음과 같은 비교 동작을"
" 보인다::"

#: ../Doc/reference/expressions.rst:1344
msgid "Lexicographical comparison between built-in collections works as follows:"
msgstr "내장 컬렉션들의 사전적인 비교는 다음과 같이 이루어진다:"

#: ../Doc/reference/expressions.rst:1346
msgid ""
"For two collections to compare equal, they must be of the same type, have"
" the same length, and each pair of corresponding elements must compare "
"equal (for example, ``[1,2] == (1,2)`` is false because the type is not "
"the same)."
msgstr ""
"두 컬렉션이 같다고 비교되기 위해서는, 같은 형이고, 길이가 같고, 대응하는 요소들의 각 쌍이 같다고 비교되어야 한다 (예를 들어,"
" ``[1,2] == (1,2)`` 는 거짓인데, 형이 다르기 때문이다)."

#: ../Doc/reference/expressions.rst:1351
msgid ""
"Collections that support order comparison are ordered the same as their "
"first unequal elements (for example, ``[1,2,x] <= [1,2,y]`` has the same "
"value as ``x <= y``).  If a corresponding element does not exist, the "
"shorter collection is ordered first (for example, ``[1,2] < [1,2,3]`` is "
"true)."
msgstr ""
"대소 비교를 지원하는 컬렉션들은 첫 번째로 다른 요소들과 같은 순서를 준다 (예를 들어, ``[1,2,x] <= [1,2,y]`` 는"
" ``x <= y`` 와 같은 값이다). 대응하는 요소가 없는 경우 더 짧은 컬렉션이 작다고 비교된다 (예를 들어, ``[1,2] "
"< [1,2,3]`` 은 참이다)."

#: ../Doc/reference/expressions.rst:1357
msgid ""
"Mappings (instances of :class:`dict`) compare equal if and only if they "
"have equal `(key, value)` pairs. Equality comparison of the keys and "
"values enforces reflexivity."
msgstr ""
"매핑들 (:class:`dict` 의 인스턴스들) 은 같은 `(key, value)` 쌍들을 가질 때, 그리고 오직 이 경우만 "
"같다고 비교된다. 키와 값의 동등 비교는 반사성을 강제한다."

#: ../Doc/reference/expressions.rst:1361
msgid ""
"Order comparisons (``<``, ``>``, ``<=``, and ``>=``) raise "
":exc:`TypeError`."
msgstr "대소 비교 (``<``, ``>``, ``<=``, ``>=``) 는 :exc:`TypeError` 를 일으킨다."

#: ../Doc/reference/expressions.rst:1363
msgid ""
"Sets (instances of :class:`set` or :class:`frozenset`) can be compared "
"within and across their types."
msgstr ""
"집합들 (:class:`set` 이나 :class:`frozenset` 의 인스턴스들)은 같은 형들과 서로 다른 형들 간에 비교될"
" 수 있다."

#: ../Doc/reference/expressions.rst:1366
msgid ""
"They define order comparison operators to mean subset and superset tests."
"  Those relations do not define total orderings (for example, the two "
"sets ``{1,2}`` and ``{2,3}`` are not equal, nor subsets of one another, "
"nor supersets of one another).  Accordingly, sets are not appropriate "
"arguments for functions which depend on total ordering (for example, "
":func:`min`, :func:`max`, and :func:`sorted` produce undefined results "
"given a list of sets as inputs)."
msgstr ""
"이것들은 부분집합(subset)과 상위집합(superset)을 뜻하는 대소비교 연산자들을 정의한다. 이 관계는 전 순서(total"
" ordering)를 정의하지 않는다 (예를 들어, 두 집합 ``{1,2}`` 와 ``{2,3}`` 는 다르면서도, 하나가 다른 "
"하나의 부분집합이지도, 하나가 다른 하나의 상위집합이지도 않다). 따라서, 전 순서에 의존하는 함수의 인자로는 적합하지 않다 (예를 "
"들어, :func:`min`, :func:`max`, :func:`sorted` 에 입력으로 집합의 리스트를 제공하면 정의되지 않은"
" 결과를 준다)."

#: ../Doc/reference/expressions.rst:1374
msgid "Comparison of sets enforces reflexivity of its elements."
msgstr "집합의 비교는 그 요소들의 반사성을 강제한다."

#: ../Doc/reference/expressions.rst:1376
msgid ""
"Most other built-in types have no comparison methods implemented, so they"
" inherit the default comparison behavior."
msgstr "대부분의 다른 내장형들은 비교 메서드들을 구현하지 않기 때문에, 기본 비교 동작을 계승한다."

#: ../Doc/reference/expressions.rst:1379
msgid ""
"User-defined classes that customize their comparison behavior should "
"follow some consistency rules, if possible:"
msgstr "비교 동작을 커스터마이즈하는 사용자 정의 클래스들은 가능하다면 몇 가지 일관성 규칙을 준수해야 한다:"

#: ../Doc/reference/expressions.rst:1382
msgid ""
"Equality comparison should be reflexive. In other words, identical "
"objects should compare equal:"
msgstr "동등 비교는 반사적(reflexive)이어야 한다. 다른 말로 표현하면, 아이덴티티가 같은 객체는 같다고 비교되어야 한다:"

#: ../Doc/reference/expressions.rst:1385
msgid "``x is y`` implies ``x == y``"
msgstr "``x is y`` 면 ``x == y`` 다."

#: ../Doc/reference/expressions.rst:1387
msgid ""
"Comparison should be symmetric. In other words, the following expressions"
" should have the same result:"
msgstr "비교는 대칭적(symmetric)이어야 한다. 다른 말로 표현하면, 다음과 같은 표현식은 같은 결과를 주어야 한다:"

#: ../Doc/reference/expressions.rst:1390
msgid "``x == y`` and ``y == x``"
msgstr "``x == y`` 와 ``y == x``"

#: ../Doc/reference/expressions.rst:1392
msgid "``x != y`` and ``y != x``"
msgstr "``x != y`` 와 ``y != x``"

#: ../Doc/reference/expressions.rst:1394
msgid "``x < y`` and ``y > x``"
msgstr "``x < y`` 와 ``y > x``"

#: ../Doc/reference/expressions.rst:1396
msgid "``x <= y`` and ``y >= x``"
msgstr "``x <= y`` 와 ``y >= x``"

#: ../Doc/reference/expressions.rst:1398
msgid ""
"Comparison should be transitive. The following (non-exhaustive) examples "
"illustrate that:"
msgstr "비교는 추이적(transitive)이어야 한다. 다음 (철저하지 않은) 예들이 이것을 예증한다:"

#: ../Doc/reference/expressions.rst:1401
msgid "``x > y and y > z`` implies ``x > z``"
msgstr "``x > y and y > z`` 면 ``x > z`` 다"

#: ../Doc/reference/expressions.rst:1403
msgid "``x < y and y <= z`` implies ``x < z``"
msgstr "x < y and y <= z`` 면 ``x < z`` 다"

#: ../Doc/reference/expressions.rst:1405
msgid ""
"Inverse comparison should result in the boolean negation. In other words,"
" the following expressions should have the same result:"
msgstr "역 비교는 논리적 부정이 되어야 한다. 다른 말로 표현하면, 다음 표현식들이 같은 값을 주어야 한다:"

#: ../Doc/reference/expressions.rst:1408
msgid "``x == y`` and ``not x != y``"
msgstr "``x == y`` 와 ``not x != y``"

#: ../Doc/reference/expressions.rst:1410
msgid "``x < y`` and ``not x >= y`` (for total ordering)"
msgstr "``x < y`` 와 ``not x >= y`` (전 순서의 경우)"

#: ../Doc/reference/expressions.rst:1412
msgid "``x > y`` and ``not x <= y`` (for total ordering)"
msgstr "``x > y`` 와 ``not x <= y`` (전 순서의 경우)"

#: ../Doc/reference/expressions.rst:1414
msgid ""
"The last two expressions apply to totally ordered collections (e.g. to "
"sequences, but not to sets or mappings). See also the "
":func:`~functools.total_ordering` decorator."
msgstr ""
"마지막 두 표현식은 전 순서 컬렉션에 적용된다 (예를 들어, 시퀀스에는 적용되지만, 집합과 매핑은 그렇지 않다). "
":func:`~functools.total_ordering` 데코레이터 또한 보기 바란다."

#: ../Doc/reference/expressions.rst:1418
msgid ""
"The :func:`hash` result should be consistent with equality. Objects that "
"are equal should either have the same hash value, or be marked as "
"unhashable."
msgstr ""
":func:`hash` 결과는 동등성과 일관성을 유지해야 한다. 같은 객체들은 같은 해시값을 같거나 "
"해시 불가능으로 지정되어야 한다."

#: ../Doc/reference/expressions.rst:1422
msgid ""
"Python does not enforce these consistency rules. In fact, the "
"not-a-number values are an example for not following these rules."
msgstr "파이썬은 이 일관성 규칙들을 강제하지 않는다. 사실 NaN 값들은 이 규칙을 따르지 않는 예다."

#: ../Doc/reference/expressions.rst:1431
msgid "Membership test operations"
msgstr "멤버십 검사 연산"

#: ../Doc/reference/expressions.rst:1433
msgid ""
"The operators :keyword:`in` and :keyword:`not in` test for membership.  "
"``x in s`` evaluates to ``True`` if *x* is a member of *s*, and ``False``"
" otherwise. ``x not in s`` returns the negation of ``x in s``.  All "
"built-in sequences and set types support this as well as dictionary, for "
"which :keyword:`in` tests whether the dictionary has a given key. For "
"container types such as list, tuple, set, frozenset, dict, or "
"collections.deque, the expression ``x in y`` is equivalent to ``any(x is "
"e or x == e for e in y)``."
msgstr ""
"연산자 :keyword:`in` 과 :keyword:`not in` 은 멤버십을 검사한다. ``x in s`` 는 *x* 가 *s*"
" 의 멤버일 때 ``True`` 를, 그렇지 않을 때 ``False`` 를 준다. ``x not in s`` 은 ``x in s``"
" 의 부정을 준다. 딕셔너리 뿐만 아니라 모든 내장 시퀀스들과 집합 형들이 이것을 지원하는데, 딕셔너리의 경우는 "
":keyword:`in` 이 딕셔너리에 주어진 키가 있는지 검사한다. list, tuple, set, frozenset, dict,"
" collections.deque 와 같은 컨테이너형들의 경우, 표현식 ``x in y`` 는 ``any(x is e or x "
"== e for e in y)`` 와 동등하다."

#: ../Doc/reference/expressions.rst:1441
msgid ""
"For the string and bytes types, ``x in y`` is ``True`` if and only if *x*"
" is a substring of *y*.  An equivalent test is ``y.find(x) != -1``.  "
"Empty strings are always considered to be a substring of any other "
"string, so ``\"\" in \"abc\"`` will return ``True``."
msgstr ""
"문자열과 바이트열 형의 경우, ``x in y`` 는 *x* 가 *y* 의 서브 스트링(substring)인 경우, 그리고 오직 그 "
"경우만 ``True`` 다. 동등한 검사는 ``y.find(x) != -1`` 다. 빈 문자열은 항상 다른 문자열들의 서브 스트링으로"
" 취급되기 때문에, ``\"\" in \"abc\"`` 은 ``True`` 를 돌려준다."

#: ../Doc/reference/expressions.rst:1446
msgid ""
"For user-defined classes which define the :meth:`__contains__` method, "
"``x in y`` returns ``True`` if ``y.__contains__(x)`` returns a true "
"value, and ``False`` otherwise."
msgstr ""
":meth:`__contains__` 메서드를 정의하는 사용자 정의 클래스의 경우, ``x in y`` 는 "
"``y.__contains__(x)`` 가 참을 줄 때 ``True`` 를, 그렇지 않으면 ``False`` 를 돌려준다."

#: ../Doc/reference/expressions.rst:1450
msgid ""
"For user-defined classes which do not define :meth:`__contains__` but do "
"define :meth:`__iter__`, ``x in y`` is ``True`` if some value ``z`` with "
"``x == z`` is produced while iterating over ``y``.  If an exception is "
"raised during the iteration, it is as if :keyword:`in` raised that "
"exception."
msgstr ""
":meth:`__contains__` 를 정의하지 않지만 :meth:`__iter__` 를 정의하는 사용자 정의 클래스의 경우, "
"``x in y`` 는 ``y`` 를 탐색할 때 ``x == z`` 를 만족하는 어떤 값 ``z`` 가 만들어지면 ``True`` "
"다. 탐색하는 동안 예외가 발생하면 :keyword:`in` 이 그 예외를 일으킨 것으로 취급된다."

#: ../Doc/reference/expressions.rst:1455
msgid ""
"Lastly, the old-style iteration protocol is tried: if a class defines "
":meth:`__getitem__`, ``x in y`` is ``True`` if and only if there is a "
"non-negative integer index *i* such that ``x == y[i]``, and all lower "
"integer indices do not raise :exc:`IndexError` exception.  (If any other "
"exception is raised, it is as if :keyword:`in` raised that exception)."
msgstr ""
"마지막으로, 올드스타일(old-style) 이터레이션 프로토콜을 시도한다: 클래스가 :meth:`__getitem__` 를 "
"정의하면, ``x in y`` 는 ``x == y[i]`` 를 만족하는 음이 아닌 정수 인덱스 *i* 가 존재하고, 그보다 작은 "
"모든 정수 인덱스들에 대해 :exc:`IndexError` 예외를 일으키지 않는 경우, 그리고 오직 그 경우만 ``True`` 가 "
"된다. (그 밖의 예외가 발생하면 :keyword:`in` 이 그 예외를 일으킨 것으로 취급된다."

#: ../Doc/reference/expressions.rst:1467
msgid ""
"The operator :keyword:`not in` is defined to have the inverse true value "
"of :keyword:`in`."
msgstr "연산자 :keyword:`not in` 은 :keyword:`in` 의 논리적 부정으로 정의된다."

#: ../Doc/reference/expressions.rst:1480
msgid "Identity comparisons"
msgstr "아이덴티티 비교"

#: ../Doc/reference/expressions.rst:1482
msgid ""
"The operators :keyword:`is` and :keyword:`is not` test for object "
"identity: ``x is y`` is true if and only if *x* and *y* are the same "
"object.  Object identity is determined using the :meth:`id` function.  "
"``x is not y`` yields the inverse truth value. [#]_"
msgstr ""
"연산자 :keyword:`is` 와 :keyword:`is not` 은 객체의 아이덴티티를 검사한다: ``x is y`` 는 *x*"
" 와 *y* 가 아이덴티티가 같은 객체일 때, 그리고 오직 그 경우만 참이다. 객체의 아이덴티티는 :meth:`id` 함수를 사용해서 "
"결정된다. ``x is not y`` 은 논리적 부정 값을 준다. [#]_"

#: ../Doc/reference/expressions.rst:1494
msgid "Boolean operations"
msgstr "논리 연산(Boolean operations)"

#: ../Doc/reference/expressions.rst:1505
msgid ""
"In the context of Boolean operations, and also when expressions are used "
"by control flow statements, the following values are interpreted as "
"false: ``False``, ``None``, numeric zero of all types, and empty strings "
"and containers (including strings, tuples, lists, dictionaries, sets and "
"frozensets).  All other values are interpreted as true.  User-defined "
"objects can customize their truth value by providing a :meth:`__bool__` "
"method."
msgstr ""
"논리 연산의 문맥에서, 그리고 표현식이 제어 흐름 문(control flow statements)에서 사용될 때, 다음 값들은 "
"거짓으로 해석된다: ``False``, ``None``, 모든 형의 숫자 0, 빈 문자열과 컨테이너(문자열, 튜플, 리스트, "
"딕셔너리, 집합, 불변 집합(frozenset)들을 포함한다). 그 밖의 모든 값은 참으로 해석된다. 사용자 정의 객체들은 "
":meth:`__bool__` 메서드를 제공해서 자신의 논리값(truth value)을 커스터마이즈 할 수 있다."

#: ../Doc/reference/expressions.rst:1514
msgid ""
"The operator :keyword:`not` yields ``True`` if its argument is false, "
"``False`` otherwise."
msgstr "연산자 :keyword:`not` 은 그 인자가 거짓이면 ``True`` 를, 그렇지 않으면 ``False`` 를 준다."

#: ../Doc/reference/expressions.rst:1519
msgid ""
"The expression ``x and y`` first evaluates *x*; if *x* is false, its "
"value is returned; otherwise, *y* is evaluated and the resulting value is"
" returned."
msgstr ""
"표현식 ``x and y`` 는 먼저 *x* 의 값을 구한다; *x* 가 거짓이면 그 값을 돌려준다; 그렇지 않으면 *y* 의 값을"
" 구한 후에 그 결과를 돌려준다."

#: ../Doc/reference/expressions.rst:1524
msgid ""
"The expression ``x or y`` first evaluates *x*; if *x* is true, its value "
"is returned; otherwise, *y* is evaluated and the resulting value is "
"returned."
msgstr ""
"표현식 ``x or y`` 는 먼저 *x* 의 값을 구한다; *x* 가 참이면 그 값을 돌려준다. 그렇지 않으면 *y* 의 값을 "
"구한 후에 그 결과를 돌려준다."

#: ../Doc/reference/expressions.rst:1527
msgid ""
"(Note that neither :keyword:`and` nor :keyword:`or` restrict the value "
"and type they return to ``False`` and ``True``, but rather return the "
"last evaluated argument.  This is sometimes useful, e.g., if ``s`` is a "
"string that should be replaced by a default value if it is empty, the "
"expression ``s or 'foo'`` yields the desired value.  Because "
":keyword:`not` has to create a new value, it returns a boolean value "
"regardless of the type of its argument (for example, ``not 'foo'`` "
"produces ``False`` rather than ``''``.)"
msgstr ""
"(:keyword:`and` 와 :keyword:`or` 어느 것도 반환 값이나 그 형을 ``False`` 와 ``True`` 로 "
"제한하지 않고, 대신 마지막에 값이 구해진 인자를 돌려줌에 주의해야 한다. 이것은 때로 쓸모가 있다, 예를 들어 ``s`` 가 "
"문자열이고 비어 있으면 기본값으로 대체되어야 한다면, 표현식 ``s or 'foo'`` 는 원하는 값을 제공한다. "
":keyword:`not` 은 새 값을 만들어야 하므로, 그 인자의 형과 관계없이 논리값(boolean value)을 "
"돌려준다 (예를 들어, ``not 'foo'`` 는 ``''`` 가 아니라 ``False`` 를 만든다.))"

#: ../Doc/reference/expressions.rst:1537
msgid "Conditional expressions"
msgstr "조건 표현식(Conditional expressions)"

#: ../Doc/reference/expressions.rst:1548
msgid ""
"Conditional expressions (sometimes called a \"ternary operator\") have "
"the lowest priority of all Python operations."
msgstr ""
"조건 표현식은 (때로 \"삼 항 연산자(ternary operator)\"라고 불린다) 모든 파이썬 연산에서 가장 낮은 우선순위를"
" 갖는다."

#: ../Doc/reference/expressions.rst:1551
msgid ""
"The expression ``x if C else y`` first evaluates the condition, *C* "
"rather than *x*. If *C* is true, *x* is evaluated and its value is "
"returned; otherwise, *y* is evaluated and its value is returned."
msgstr ""
"표현식 ``x if C else y`` 은 먼저 *x* 대신에 조건 *C* 의 값을 구한다. *C* 가 참이면, *x* 의 값이 "
"구해지고 그 값을 돌려준다; 그렇지 않으면, *y* 의 값을 구한 후에 그 결과를 돌려준다."

#: ../Doc/reference/expressions.rst:1555
msgid "See :pep:`308` for more details about conditional expressions."
msgstr "조건 표현식에 대한 더 자세한 내용은 :pep:`308` 를 참고하라."

#: ../Doc/reference/expressions.rst:1562
msgid "Lambdas"
msgstr "람다(Lambdas)"

#: ../Doc/reference/expressions.rst:1573
msgid ""
"Lambda expressions (sometimes called lambda forms) are used to create "
"anonymous functions. The expression ``lambda arguments: expression`` "
"yields a function object.  The unnamed object behaves like a function "
"object defined with:"
msgstr ""
"람다 표현식은 (때로 람다 형식(lambda forms)이라고 불린다) 이름 없는 함수를 만드는 데 사용된다. 표현식 ``lambda "
"arguments: expression`` 는 함수 객체를 준다. 이 이름 없는 객체는 이렇게 정의된 함수 객체처럼 동작한다:"

#: ../Doc/reference/expressions.rst:1582
msgid ""
"See section :ref:`function` for the syntax of parameter lists.  Note that"
" functions created with lambda expressions cannot contain statements or "
"annotations."
msgstr ""
"파라미터 목록의 문법은 :ref:`function` 섹션을 보면 된다. 람다 표현식으로 만들어진 함수는 "
"문장(statements)이나 어노테이션(annotations)을 포함할 수 없음에 주의해야 한다."

#: ../Doc/reference/expressions.rst:1590
msgid "Expression lists"
msgstr "표현식 목록(Expression lists)"

#: ../Doc/reference/expressions.rst:1602
msgid ""
"Except when part of a list or set display, an expression list containing "
"at least one comma yields a tuple.  The length of the tuple is the number"
" of expressions in the list.  The expressions are evaluated from left to "
"right."
msgstr ""
"리스트나 집합 디스플레이의 일부일 때를 제외하고, 최소한 하나의 쉼표를 포함하는 표현식 목록은 튜플을 준다. 튜플의 길이는 목록에 "
"있는 표현식의 개수다. 표현식들은 왼쪽에서 오른쪽으로 값이 구해진다."

#: ../Doc/reference/expressions.rst:1611
msgid ""
"An asterisk ``*`` denotes :dfn:`iterable unpacking`.  Its operand must be"
" an :term:`iterable`.  The iterable is expanded into a sequence of items,"
" which are included in the new tuple, list, or set, at the site of the "
"unpacking."
msgstr ""
"애스터리스크(asterisk) ``*`` 는 이터러블 언 패킹(:dfn:`iterable unpacking`)을 나타낸다. "
"피연산자는 반드시 :term:`이터러블 <iterable>` 이어야 한다. 그 이터러블이 항목들의 시퀀스로 확장되어서, 언 패킹 "
"지점에서 새 튜플, 리스트, 집합에 포함된다."

#: ../Doc/reference/expressions.rst:1616
msgid "Iterable unpacking in expression lists, originally proposed by :pep:`448`."
msgstr "표현식 목록에서의 이터러블 언 패킹, :pep:`448` 에서 최초로 제안되었다."

#: ../Doc/reference/expressions.rst:1621
msgid ""
"The trailing comma is required only to create a single tuple (a.k.a. a "
"*singleton*); it is optional in all other cases.  A single expression "
"without a trailing comma doesn't create a tuple, but rather yields the "
"value of that expression. (To create an empty tuple, use an empty pair of"
" parentheses: ``()``.)"
msgstr ""
"끝에 붙는 쉼표는 단일 튜플(single tuple) (소위, *싱글톤(singleton)*) 을 만들 때만 필수다; 다른 모든 "
"경우에는 생략할 수 있다. 끝에 붙는 쉼표가 없는 단일 표현식은 튜플을 만들지 않고, 그 표현식의 값을 준다. (빈 튜플을 "
"만들려면, 빈 괄호 쌍을 사용하라: ``()``.)"

#: ../Doc/reference/expressions.rst:1631
msgid "Evaluation order"
msgstr "값을 구하는 순서"

#: ../Doc/reference/expressions.rst:1635
msgid ""
"Python evaluates expressions from left to right.  Notice that while "
"evaluating an assignment, the right-hand side is evaluated before the "
"left-hand side."
msgstr "파이썬은 왼쪽에서 오른쪽으로 표현식의 값을 구한다. 대입의 값을 구하는 동안, 우변의 값이 좌변보다 먼저 구해짐에 주목하라."

#: ../Doc/reference/expressions.rst:1638
msgid ""
"In the following lines, expressions will be evaluated in the arithmetic "
"order of their suffixes::"
msgstr "다 줄들에서, 표현식은 그들의 끝에 붙은 숫자들의 순서대로 값이 구해진다::"

#: ../Doc/reference/expressions.rst:1652
msgid "Operator precedence"
msgstr "연산자 우선순위"

#: ../Doc/reference/expressions.rst:1656
msgid ""
"The following table summarizes the operator precedence in Python, from "
"lowest precedence (least binding) to highest precedence (most binding).  "
"Operators in the same box have the same precedence.  Unless the syntax is"
" explicitly given, operators are binary.  Operators in the same box group"
" left to right (except for exponentiation, which groups from right to "
"left)."
msgstr ""
"다음 표는 파이썬 에서의 연산자 우선순위를 가장 낮은 것 (least binding)에서 가장 높은 것 (most "
"binding) 순으로 요약한다. 같은 상자에 들어있는 연산자들은 같은 우선순위를 갖는다. 문법이 명시적으로 주어지지 않는 이상,"
" 연산자들은 이항(binary)이다. 같은 상자에 있는 연산자들은 왼쪽에서 오른쪽으로 그룹 지어진다 (거듭제곱은 예외인데, 오른쪽에서"
" 왼쪽으로 그룹 지어진다)."

#: ../Doc/reference/expressions.rst:1662
msgid ""
"Note that comparisons, membership tests, and identity tests, all have the"
" same precedence and have a left-to-right chaining feature as described "
"in the :ref:`comparisons` section."
msgstr ""
"비교, 멤버십 검사, 아이덴티티 검사들은 모두 같은 우선순위를 갖고 :ref:`comparisons` 섹션에서 설명한 것처럼 "
"왼쪽에서 오른쪽으로 이어붙이기(chaining) 하는 기능을 갖는다."

#: ../Doc/reference/expressions.rst:1668
msgid "Operator"
msgstr "연산자"

#: ../Doc/reference/expressions.rst:1668
msgid "Description"
msgstr "설명"

#: ../Doc/reference/expressions.rst:1670
msgid ":keyword:`lambda`"
msgstr ":keyword:`lambda`"

#: ../Doc/reference/expressions.rst:1670
msgid "Lambda expression"
msgstr "람다 표현식"

#: ../Doc/reference/expressions.rst:1672
msgid ":keyword:`if` -- :keyword:`else`"
msgstr ":keyword:`if` -- :keyword:`else`"

#: ../Doc/reference/expressions.rst:1672
msgid "Conditional expression"
msgstr "조건 표현식"

#: ../Doc/reference/expressions.rst:1674
msgid ":keyword:`or`"
msgstr ":keyword:`or`"

#: ../Doc/reference/expressions.rst:1674
msgid "Boolean OR"
msgstr "논리 OR"

#: ../Doc/reference/expressions.rst:1676
msgid ":keyword:`and`"
msgstr ":keyword:`and`"

#: ../Doc/reference/expressions.rst:1676
msgid "Boolean AND"
msgstr "논리 AND"

#: ../Doc/reference/expressions.rst:1678
msgid ":keyword:`not` ``x``"
msgstr ":keyword:`not` ``x``"

#: ../Doc/reference/expressions.rst:1678
msgid "Boolean NOT"
msgstr "논리 NOT"

#: ../Doc/reference/expressions.rst:1680
msgid ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, "
"``<``, ``<=``, ``>``, ``>=``, ``!=``, ``==``"
msgstr ""
":keyword:`in`, :keyword:`not in`, :keyword:`is`, :keyword:`is not`, "
"``<``, ``<=``, ``>``, ``>=``, ``!=``, ``==``"

#: ../Doc/reference/expressions.rst:1680
msgid "Comparisons, including membership tests and identity tests"
msgstr "비교, 멤버십 검사와 아이덴티티 검사를 포함한다"

#: ../Doc/reference/expressions.rst:1684
msgid "``|``"
msgstr "``|``"

#: ../Doc/reference/expressions.rst:1684
msgid "Bitwise OR"
msgstr "비트 OR"

#: ../Doc/reference/expressions.rst:1686
msgid "``^``"
msgstr "``^``"

#: ../Doc/reference/expressions.rst:1686
msgid "Bitwise XOR"
msgstr "비트 XOR"

#: ../Doc/reference/expressions.rst:1688
msgid "``&``"
msgstr "``&``"

#: ../Doc/reference/expressions.rst:1688
msgid "Bitwise AND"
msgstr "비트 AND"

#: ../Doc/reference/expressions.rst:1690
msgid "``<<``, ``>>``"
msgstr "``<<``, ``>>``"

#: ../Doc/reference/expressions.rst:1690
msgid "Shifts"
msgstr "시프트"

#: ../Doc/reference/expressions.rst:1692
msgid "``+``, ``-``"
msgstr "``+``, ``-``"

#: ../Doc/reference/expressions.rst:1692
msgid "Addition and subtraction"
msgstr "덧셈과 뺄셈"

#: ../Doc/reference/expressions.rst:1694
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr "``*``, ``@``, ``/``, ``//``, ``%``"

#: ../Doc/reference/expressions.rst:1694
msgid ""
"Multiplication, matrix multiplication, division, floor division, "
"remainder [#]_"
msgstr "곱셈, 행렬 곱셈, 나눗셈, 정수 나눗셈, 나머지 [#]_"

#: ../Doc/reference/expressions.rst:1698
msgid "``+x``, ``-x``, ``~x``"
msgstr "``+x``, ``-x``, ``~x``"

#: ../Doc/reference/expressions.rst:1698
msgid "Positive, negative, bitwise NOT"
msgstr "양, 음, 비트 NOT"

#: ../Doc/reference/expressions.rst:1700
msgid "``**``"
msgstr "``**``"

#: ../Doc/reference/expressions.rst:1700
msgid "Exponentiation [#]_"
msgstr "거듭제곱 [#]_"

#: ../Doc/reference/expressions.rst:1702
msgid "``await`` ``x``"
msgstr "``await`` ``x``"

#: ../Doc/reference/expressions.rst:1704
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"

#: ../Doc/reference/expressions.rst:1704
msgid "Subscription, slicing, call, attribute reference"
msgstr "서브스크립션, 슬라이싱, 호출, 어트리뷰트 참조"

#: ../Doc/reference/expressions.rst:1707
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"``{expressions...}``"
msgstr ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"``{expressions...}``"

#: ../Doc/reference/expressions.rst:1707
msgid "Binding or tuple display, list display, dictionary display, set display"
msgstr "결합(binding) 또는 튜플 디스플레이, 리스트 디스플레이, 딕셔너리 디스플레이, 집합 디스플레이"

#: ../Doc/reference/expressions.rst:1715
msgid "Footnotes"
msgstr "각주"

#: ../Doc/reference/expressions.rst:1716
#, python-format
msgid ""
"While ``abs(x%y) < abs(y)`` is true mathematically, for floats it may not"
" be true numerically due to roundoff.  For example, and assuming a "
"platform on which a Python float is an IEEE 754 double-precision number, "
"in order that ``-1e-100 % 1e100`` have the same sign as ``1e100``, the "
"computed result is ``-1e-100 + 1e100``, which is numerically exactly "
"equal to ``1e100``.  The function :func:`math.fmod` returns a result "
"whose sign matches the sign of the first argument instead, and so returns"
" ``-1e-100`` in this case. Which approach is more appropriate depends on "
"the application."
msgstr ""
"``abs(x%y) < abs(y)`` 이 수학적으로는 참이지만, float의 경우에는 소수점 자름(roundoff) 때문에 "
"수치적으로 참이 아닐 수 있다. 예를 들어, 파이썬 float가 IEEE 754 배정도 숫자인 플랫폼을 가정할 때, "
"``-1e-100 % 1e100`` 가 ``1e100`` 와 같은 부호를 가지기 위해, 계산된 결과는 ``-1e-100 + "
"1e100`` 인데, 수치적으로는 ``1e100`` 과 정확히 같은 값이다. 함수 :func:`math.fmod` 는 부호가 첫 번째"
" 인자의 부호에 맞춰진 결과를 주기 때문에, 이 경우 ``-1e-100`` 을 돌려준다. 어떤 접근법이 더 적절한지는 응용 프로그램에 "
"달려있다."

#: ../Doc/reference/expressions.rst:1725
msgid ""
"If x is very close to an exact integer multiple of y, it's possible for "
"``x//y`` to be one larger than ``(x-x%y)//y`` due to rounding.  In such "
"cases, Python returns the latter result, in order to preserve that "
"``divmod(x,y)[0] * y + x % y`` be very close to ``x``."
msgstr ""
"x가 y의 정확한 정수배와 아주 가까우면, 라운딩(rounding) 때문에 ``x//y`` 는 ``(x-x%y)//y`` 보다 "
"1 클 수 있다. 그런 경우, ``divmod(x,y)[0] * y + x % y`` 가 ``x`` 와 아주 가깝도록 유지하기 "
"위해, 파이썬은 뒤의 결과를 돌려준다."

#: ../Doc/reference/expressions.rst:1730
msgid ""
"The Unicode standard distinguishes between :dfn:`code points` (e.g. "
"U+0041) and :dfn:`abstract characters` (e.g. \"LATIN CAPITAL LETTER A\")."
" While most abstract characters in Unicode are only represented using one"
" code point, there is a number of abstract characters that can in "
"addition be represented using a sequence of more than one code point.  "
"For example, the abstract character \"LATIN CAPITAL LETTER C WITH "
"CEDILLA\" can be represented as a single :dfn:`precomposed character` at "
"code position U+00C7, or as a sequence of a :dfn:`base character` at code"
" position U+0043 (LATIN CAPITAL LETTER C), followed by a :dfn:`combining "
"character` at code position U+0327 (COMBINING CEDILLA)."
msgstr ""
"유니코드 표준은 코드 포인트(:dfn:`code points`) (예를 들어, U+0041) 와 추상 "
"문자(:dfn:`abstract characters`) (예를 들어, \"LATIN CAPITAL LETTER A\") 를 "
"구분한다. 유니코드에 있는 대부분의 추상 문자들이 오직 하나의 코드 포인트만으로 표현되지만, 추가로 하나 이상의 코드 포인트의 "
"시퀀스로 표현될 수 있는 추상 문자들이 많이 있다. 예를 들어, 추상 문자 \"LATIN CAPITAL LETTER C WITH "
"CEDILLA\" 는 코드 위치 U+00C7 에 있는 한 개의 복합 문자(:dfn:`precomposed character`) 나 "
"코드 위치 U+0043 (LATIN CAPITAL LETTER C) 에 있는 기본 문자(:dfn:`base character`) 와"
" 뒤따르는 코드 위치 U+0327 (COMBINING CEDILLA) 에 있는 결합 문자(:dfn:`combining "
"character`) 의 시퀀스로 표현될 수 있다."

#: ../Doc/reference/expressions.rst:1741
msgid ""
"The comparison operators on strings compare at the level of Unicode code "
"points. This may be counter-intuitive to humans.  For example, "
"``\"\\u00C7\" == \"\\u0043\\u0327\"`` is ``False``, even though both "
"strings represent the same abstract character \"LATIN CAPITAL LETTER C "
"WITH CEDILLA\"."
msgstr ""
"문자열의 비교 연산자는 유니코드 코드 포인트 수준에서 비교한다. 이것은 사람에게 반 직관적일 수 있다. 예를 들어, "
"``\"\\u00C7\" == \"\\u0043\\u0327\"`` 는 거짓이다, 설사 두 문자열이 같은 추상 문자 \"LATIN "
"CAPITAL LETTER C WITH CEDILLA\"를 표현할지라도 그렇다."

#: ../Doc/reference/expressions.rst:1746
msgid ""
"To compare strings at the level of abstract characters (that is, in a way"
" intuitive to humans), use :func:`unicodedata.normalize`."
msgstr ""
"문자열을 추상 문자 수준에서 비교하려면 (즉, 사람에게 직관적인 방법으로), :func:`unicodedata.normalize` "
"를 사용하라."

#: ../Doc/reference/expressions.rst:1749
msgid ""
"Due to automatic garbage-collection, free lists, and the dynamic nature "
"of descriptors, you may notice seemingly unusual behaviour in certain "
"uses of the :keyword:`is` operator, like those involving comparisons "
"between instance methods, or constants.  Check their documentation for "
"more info."
msgstr ""
"자동 가비지-수거(automatic garbage-collection)와 자유 목록(free lists)과 "
"디스크립터(descriptor)의 동적인 성격 때문에, :keyword:`is` 연산자를 인스턴스 메서드들이나 상수들을 비교하는 "
"것과 같은 특정한 방식으로 사용할 때, 겉으로 보기에 이상한 동작을 감지할 수 있다. 더 자세한 정보는 그들의 문서를 확인하기 "
"바란다."

#: ../Doc/reference/expressions.rst:1754
msgid ""
"The ``%`` operator is also used for string formatting; the same "
"precedence applies."
msgstr "``%`` 연산자는 문자열 포매팅에도 사용된다; 같은 우선순위가 적용된다."

#: ../Doc/reference/expressions.rst:1757
msgid ""
"The power operator ``**`` binds less tightly than an arithmetic or "
"bitwise unary operator on its right, that is, ``2**-1`` is ``0.5``."
msgstr ""
"거듭제곱 연산자 ``**`` 는 오른쪽에 오는 산술이나 비트 일 항 연산자보다 약하게 결합한다, 즉, ``2**-1`` 는 "
"``0.5`` 다."

