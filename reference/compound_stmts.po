# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/reference/compound_stmts.rst:5
msgid "Compound statements"
msgstr "복합문(Compound statements)"

#: ../Doc/reference/compound_stmts.rst:9
msgid ""
"Compound statements contain (groups of) other statements; they affect or "
"control the execution of those other statements in some way.  In general,"
" compound statements span multiple lines, although in simple incarnations"
" a whole compound statement may be contained in one line."
msgstr ""
"복합문은 다른 문장들(의 그룹들)을 포함합니다; 어떤 방법으로 그 다른 문장들의 실행에 영향을 주거나 제어합니다. 간단하게 표현할 "
"때, 전체 복합문을 한 줄로 쓸 수 있기는 하지만, 일반적으로 복합문은 여러 줄에 걸칩니다."

#: ../Doc/reference/compound_stmts.rst:14
msgid ""
"The :keyword:`if`, :keyword:`while` and :keyword:`for` statements "
"implement traditional control flow constructs.  :keyword:`try` specifies "
"exception handlers and/or cleanup code for a group of statements, while "
"the :keyword:`with` statement allows the execution of initialization and "
"finalization code around a block of code.  Function and class definitions"
" are also syntactically compound statements."
msgstr ""
":keyword:`if`, :keyword:`while`, :keyword:`for` 문장은 전통적인 제어 흐름 구조를 구현합니다."
" 문장들의 그룹에 대해 :keyword:`try` 는 예외 처리기나 정리(cleanup) 코드 또는 그 둘 모두를 지정하는 반면, "
":keyword:`with` 문은 코드 블록 주변으로 초기화와 파이널리제이션 코드를 실행할 수 있도록 합니다. 함수와 클래스 정의 "
"또한 문법적으로 복합문입니다."

#: ../Doc/reference/compound_stmts.rst:25
msgid ""
"A compound statement consists of one or more 'clauses.'  A clause "
"consists of a header and a 'suite.'  The clause headers of a particular "
"compound statement are all at the same indentation level. Each clause "
"header begins with a uniquely identifying keyword and ends with a colon."
"  A suite is a group of statements controlled by a clause.  A suite can "
"be one or more semicolon-separated simple statements on the same line as "
"the header, following the header's colon, or it can be one or more "
"indented statements on subsequent lines.  Only the latter form of a suite"
" can contain nested compound statements; the following is illegal, mostly"
" because it wouldn't be clear to which :keyword:`if` clause a following "
":keyword:`else` clause would belong::"
msgstr ""
"복합문은 하나나 그 이상의 '절'로 구성됩니다. 절은 헤더와 '스위트(suite)'로 구성됩니다. 특정 복합문의 절 헤더들은 모두 "
"같은 들여쓰기 수준을 갖습니다. 각 절 헤더는 특별하게 식별되는 키워드로 시작하고 콜론으로 끝납니다. 스위트는 절에 의해 제어되는 "
"문장들의 그룹입니다. 스위트는 헤더의 콜론 뒤에서 같은 줄에 세미콜론으로 분리된 하나나 그 이상의 단순문일 수 있습니다. 또는 "
"그다음 줄에 들여쓰기 된 하나나 그 이상의 문장들일 수도 있습니다. 오직 후자의 형태만 중첩된 복합문을 포함할 수 있습니다; 다음과"
" 같은 것은 올바르지 않은데, 대체로 뒤따르는 :keyword:`else` 절이 있다면 어떤 :keyword:`if` 절에 속하는지"
" 명확하지 않기 때문입니다."

#: ../Doc/reference/compound_stmts.rst:38
msgid ""
"Also note that the semicolon binds tighter than the colon in this "
"context, so that in the following example, either all or none of the "
":func:`print` calls are executed::"
msgstr ""
"또한, 이 문맥에서 세미콜론이 콜론보다 더 강하게 결합해서, 다음과 같은 예에서, :func:`print` 호출들은 모두 실행되거나"
" 어느 하나도 실행되지 않습니다는 것에 주의해야 합니다::"

#: ../Doc/reference/compound_stmts.rst:44
msgid "Summarizing:"
msgstr "요약하면:"

#: ../Doc/reference/compound_stmts.rst:66
msgid ""
"Note that statements always end in a ``NEWLINE`` possibly followed by a "
"``DEDENT``.  Also note that optional continuation clauses always begin "
"with a keyword that cannot start a statement, thus there are no "
"ambiguities (the 'dangling :keyword:`else`' problem is solved in Python "
"by requiring nested :keyword:`if` statements to be indented)."
msgstr ""
"문장들이 항상 ``NEWLINE`` 으로 끝나고 ``DEDENT`` 가 그 뒤를 따를 수 있음에 주목해야 합니다. 또한, 생략 "
"가능한 연결 절들이 항상 문장을 시작시킬 수 없는 키워드로 시작하기 때문에, 모호함이 없다는 것도 주목하세요 (파이썬에서는 중첩된 "
":keyword:`if` 문이 들여쓰기 되는 것을 요구함으로써 '매달린(dangling) :keyword:`else`' 문제를 "
"해결합니다)."

#: ../Doc/reference/compound_stmts.rst:72
msgid ""
"The formatting of the grammar rules in the following sections places each"
" clause on a separate line for clarity."
msgstr "명확함을 위해 다음에 오는 절들에서 나오는 문법 규칙들은 각 절을 별도의 줄에 놓도록 포매팅합니다."

#: ../Doc/reference/compound_stmts.rst:81
msgid "The :keyword:`if` statement"
msgstr ":keyword:`if` 문"

#: ../Doc/reference/compound_stmts.rst:90
msgid "The :keyword:`if` statement is used for conditional execution:"
msgstr ":keyword:`if` 문은 조건부 실행에 사용됩니다:"

#: ../Doc/reference/compound_stmts.rst:97
msgid ""
"It selects exactly one of the suites by evaluating the expressions one by"
" one until one is found to be true (see section :ref:`booleans` for the "
"definition of true and false); then that suite is executed (and no other "
"part of the :keyword:`if` statement is executed or evaluated).  If all "
"expressions are false, the suite of the :keyword:`else` clause, if "
"present, is executed."
msgstr ""
"참이 되는 것을 발견할 때까지 표현식들의 값을 하나씩 차례대로 구해서 정확히 하나의 스위트를 선택합니다 (참과 거짓의 정의는 "
":ref:`booleans` 섹션을 보세요); 그런 다음 그 스위트를 실행합니다 (그리고는 :keyword:`if` 문의 다른 어떤"
" 부분도 실행되거나 값이 구해지지 않습니다). 모든 표현식들이 거짓이면 :keyword:`else` 절의 스위트가 (있다면) "
"실행됩니다."

#: ../Doc/reference/compound_stmts.rst:107
msgid "The :keyword:`while` statement"
msgstr ":keyword:`while` 문"

#: ../Doc/reference/compound_stmts.rst:115
msgid ""
"The :keyword:`while` statement is used for repeated execution as long as "
"an expression is true:"
msgstr ":keyword:`while` 문은 표현식이 참인 동안 실행을 반복하는 데 사용됩니다:"

#: ../Doc/reference/compound_stmts.rst:122
msgid ""
"This repeatedly tests the expression and, if it is true, executes the "
"first suite; if the expression is false (which may be the first time it "
"is tested) the suite of the :keyword:`else` clause, if present, is "
"executed and the loop terminates."
msgstr ""
"이것은 표현식을 반복적으로 검사하고, 참이면, 첫 번째 스위트를 실행합니다; 표현식이 거짓이면 (처음부터 거짓일 수도 있습니다) "
":keyword:`else` 절의 스위트가 (있다면) 실행되고 루프를 종료합니다."

#: ../Doc/reference/compound_stmts.rst:131
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the "
"loop without executing the :keyword:`else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest "
"of the suite and goes back to testing the expression."
msgstr ""
"첫 번째 스위트에서 실행되는 :keyword:`break` 문은 :keyword:`else` 절을 실행하지 않고 루프를 종료합니다."
" 첫 번째 스위트에서 실행되는 :keyword:`continue` 문은 스위트의 나머지 부분을 건너뛰고 표현식의 검사로 돌아갑니다."

#: ../Doc/reference/compound_stmts.rst:140
msgid "The :keyword:`for` statement"
msgstr ":keyword:`for` 문"

#: ../Doc/reference/compound_stmts.rst:153
msgid ""
"The :keyword:`for` statement is used to iterate over the elements of a "
"sequence (such as a string, tuple or list) or other iterable object:"
msgstr ""
":keyword:`for` 문은 (문자열, 튜플, 리스트 같은) 시퀀스 나 다른 이터러블 객체의 요소들을 이터레이트하는데 사용됩니다:"

#: ../Doc/reference/compound_stmts.rst:160
msgid ""
"The expression list is evaluated once; it should yield an iterable "
"object.  An iterator is created for the result of the "
"``expression_list``.  The suite is then executed once for each item "
"provided by the iterator, in the order returned by the iterator.  Each "
"item in turn is assigned to the target list using the standard rules for "
"assignments (see :ref:`assignment`), and then the suite is executed.  "
"When the items are exhausted (which is immediately when the sequence is "
"empty or an iterator raises a :exc:`StopIteration` exception), the suite "
"in the :keyword:`else` clause, if present, is executed, and the loop "
"terminates."
msgstr ""
"표현식 목록은 한 번만 값이 구해집니다; 이터러블 객체가 나와야 합니다. ``expression_list`` 의 결과로 이터레이터가"
" 만들어집니다. 그런 다음 이터레이터가 제공하는 항목마다, 이터레이터가 돌려주는 순서대로, 스위트가 한 번씩 실행됩니다. 순환마다 "
"각 항목이 대입의 표준 규칙 (:ref:`assignment` 을 보세요) 으로 타깃 목록에 대입된 다음, 스위트가 실행됩니다. "
"항목들이 소진되었을 때 (이터레이터가 :exc:`StopIteration` 예외를 일으킬 때나 빈 시퀀스인 경우는 즉시 "
"발생합니다), the :keyword:`else` 절의 스위트가 (있다면) 실행되고 루프를 종료합니다."

#: ../Doc/reference/compound_stmts.rst:173
msgid ""
"A :keyword:`break` statement executed in the first suite terminates the "
"loop without executing the :keyword:`else` clause's suite.  A "
":keyword:`continue` statement executed in the first suite skips the rest "
"of the suite and continues with the next item, or with the "
":keyword:`else` clause if there is no next item."
msgstr ""
"첫 번째 스위트에서 실행되는 :keyword:`break` 문은 :keyword:`else` 절을 실행하지 않고 루프를 종료합니다."
" 첫 번째 스위트에서 실행되는 :keyword:`continue` 문은 스위트의 나머지 부분을 건너뛰고 다음 항목으로 넘어가거나, "
"다음 항목이 없으면 :keyword:`else` 절로 갑니다."

#: ../Doc/reference/compound_stmts.rst:179
msgid ""
"The for-loop makes assignments to the variables(s) in the target list. "
"This overwrites all previous assignments to those variables including "
"those made in the suite of the for-loop::"
msgstr ""
"for-루프는 타깃 목록의 변수들에 대입합니다. for-루프의 스위트에서 이루어진 것들도 포함해서, 그 변수에 앞서 대입된 값들을 "
"모두 덮어씁니다::"

#: ../Doc/reference/compound_stmts.rst:193
msgid ""
"Names in the target list are not deleted when the loop is finished, but "
"if the sequence is empty, they will not have been assigned to at all by "
"the loop.  Hint: the built-in function :func:`range` returns an iterator "
"of integers suitable to emulate the effect of Pascal's ``for i := a to b "
"do``; e.g., ``list(range(3))`` returns the list ``[0, 1, 2]``."
msgstr ""
"타깃 목록의 이름들은 루프가 종료될 때 삭제되지 않지만, 시퀀스가 비어있다면, 루프에 의해 전혀 대입이 일어나지 않을 수도 "
"있습니다. 힌트: 내장 함수 :func:`range` 는 파스칼의 ``for i := a to b do`` 의 효과를 흉내 내는데 "
"적합한 정수의 이터레이터를 돌려줍니다; 예를 들어, ``list(range(3))`` 는 리스트 ``[0, 1, 2]`` 를 "
"돌려줍니다."

#: ../Doc/reference/compound_stmts.rst:205
msgid ""
"There is a subtlety when the sequence is being modified by the loop (this"
" can only occur for mutable sequences, e.g. lists).  An internal counter "
"is used to keep track of which item is used next, and this is incremented"
" on each iteration.  When this counter has reached the length of the "
"sequence the loop terminates.  This means that if the suite deletes the "
"current (or a previous) item from the sequence, the next item will be "
"skipped (since it gets the index of the current item which has already "
"been treated).  Likewise, if the suite inserts an item in the sequence "
"before the current item, the current item will be treated again the next "
"time through the loop. This can lead to nasty bugs that can be avoided by"
" making a temporary copy using a slice of the whole sequence, e.g., ::"
msgstr ""
"시퀀스가 루프에 의해 수정될 때는 미묘한 점이 있습니다 (이것은 오직 가변 시퀀스에서만 일어납니다, 가령 리스트). 다음에 어떤 "
"항목이 사용될지를 추적하는 내부 카운터가 사용되고, 각 이터레이션마다 증가합니다. 이 카운터가 시퀀스의 길이에 도달하면 루프가 "
"종료됩니다. 이것은 만약 스위트가 시퀀스에서 현재 (또는 그 이전의) 항목을 삭제하면, 다음 항목을 건너뛰게 된다는 뜻입니다 (다음"
" 항목이 이미 다뤄진 현재 항목의 인덱스를 갖게 되기 때문입니다). 마찬가지로, 스위트가 현재 항목 앞으로 시퀀스에 항목을 "
"삽입하면, 현재 항목은 루프의 다음 순환에서 현재 항목이 한 번 더 다뤄지게 됩니다. 이것은 고약한 버그로 이어질 수 있는데, 전체"
" 시퀀스의 슬라이스로 임시 사본을 만듦으로써 피할 수 있습니다, 예를 들어 ::"

#: ../Doc/reference/compound_stmts.rst:226
msgid "The :keyword:`try` statement"
msgstr ":keyword:`try` 문"

#: ../Doc/reference/compound_stmts.rst:234
msgid ""
"The :keyword:`try` statement specifies exception handlers and/or cleanup "
"code for a group of statements:"
msgstr ""
":keyword:`try` 문은 문장 그룹에 대한 예외 처리기나 정리(cleanup) 코드 또는 그 둘 모두를 지정하는 데 "
"사용됩니다."

#: ../Doc/reference/compound_stmts.rst:247
msgid ""
"The :keyword:`except` clause(s) specify one or more exception handlers. "
"When no exception occurs in the :keyword:`try` clause, no exception "
"handler is executed. When an exception occurs in the :keyword:`try` "
"suite, a search for an exception handler is started.  This search "
"inspects the except clauses in turn until one is found that matches the "
"exception.  An expression-less except clause, if present, must be last; "
"it matches any exception.  For an except clause with an expression, that "
"expression is evaluated, and the clause matches the exception if the "
"resulting object is \"compatible\" with the exception.  An object is "
"compatible with an exception if it is the class or a base class of the "
"exception object or a tuple containing an item compatible with the "
"exception."
msgstr ""
":keyword:`except` 절(들)은 하나나 그 이상의 예외 처리기를 지정합니다. :keyword:`try` 절에서 예외가 "
"발생하지 않으면 아무런 예외 처리기도 실행되지 않습니다. :keyword:`try` 스위트에서 예외가 발생할 때, 예외 처리기 "
"검색이 시작됩니다. 이 검색은 그 예외에 매치되는 것을 발견할 때까지 except 절을 차례대로 들여다봅니다. 표현식이 없는 "
"except 절이 있다면 가장 마지막에 와야 합니다; 모든 예외와 매치됩니다. 표현식이 있는 except 절의 경우, 표현식의 값을"
" 구하고, 결과 객체가 예외와 \"호환\" 되면 그 절이 예외에 매치됩니다. 객체는 예외 객체의 클래스나 베이스 클래스일 때, 또는"
" 예외와 호환되는 항목을 포함한 튜플일 때 예외와 호환됩니다."

#: ../Doc/reference/compound_stmts.rst:258
msgid ""
"If no except clause matches the exception, the search for an exception "
"handler continues in the surrounding code and on the invocation stack.  "
"[#]_"
msgstr "except 절 중 어느 것도 예외와 매치되지 않으면, 예외 처리기 검색은 둘러싼 코드와 호출 스택에서 계속됩니다. [#]_"

#: ../Doc/reference/compound_stmts.rst:261
msgid ""
"If the evaluation of an expression in the header of an except clause "
"raises an exception, the original search for a handler is canceled and a "
"search starts for the new exception in the surrounding code and on the "
"call stack (it is treated as if the entire :keyword:`try` statement "
"raised the exception)."
msgstr ""
"만약 except 절의 헤더에 있는 표현식의 값을 구할 때 예외가 발생하면, 원래의 처리기 검색은 취소되고 둘러싼 코드와 호출 "
"스택에서 새 예외에 대해 검사가 시작됩니다 (:keyword:`try` 문 전체가 예외를 일으킨 것으로 취급됩니다)."

#: ../Doc/reference/compound_stmts.rst:266
msgid ""
"When a matching except clause is found, the exception is assigned to the "
"target specified after the :keyword:`as` keyword in that except clause, "
"if present, and the except clause's suite is executed.  All except "
"clauses must have an executable block.  When the end of this block is "
"reached, execution continues normally after the entire try statement.  "
"(This means that if two nested handlers exist for the same exception, and"
" the exception occurs in the try clause of the inner handler, the outer "
"handler will not handle the exception.)"
msgstr ""
"매치되는 except 절이 발견되면, 예외는 그 except 절에 있는 :keyword:`as` 키워드 (가 있다면) 뒤에 지정된 "
"타깃에 대입되고, except 절의 스위트가 실행됩니다. 모든 except 절은 실행 가능한 블록을 가져야 합니다. 블록의 끝에 "
"도달하면, try 문 전체의 뒤에서 일반적인 실행이 계속됩니다. (이것은 같은 예외에 대해 두 개의 중첩된 처리기가 있고, 예외가 "
"안쪽 처리기의 try 절에서 발생했다면, 바깥 처리기는 예외를 처리하지 않게 된다는 뜻이 됩니다.)"

#: ../Doc/reference/compound_stmts.rst:274
msgid ""
"When an exception has been assigned using ``as target``, it is cleared at"
" the end of the except clause.  This is as if ::"
msgstr "예외가 ``as target`` 을 사용해서 대입될 때, except 절 끝에서 삭제됩니다. 이것은 마치 ::"

#: ../Doc/reference/compound_stmts.rst:280
msgid "was translated to ::"
msgstr "가 이렇게 변환되는 것과 같습니다 ::"

#: ../Doc/reference/compound_stmts.rst:288
msgid ""
"This means the exception must be assigned to a different name to be able "
"to refer to it after the except clause.  Exceptions are cleared because "
"with the traceback attached to them, they form a reference cycle with the"
" stack frame, keeping all locals in that frame alive until the next "
"garbage collection occurs."
msgstr ""
"이것은 except 절 후에 참조하려면 예외를 다른 이름에 대입해야 한다는 뜻입니다. 예외를 제거하는 이유는, 그것에 첨부된 "
"트레이스백으로 인해, 스택 프레임과 참조 순환을 형성해서 다음 가비지 수거가 일어나기 전까지 그 프레임의 모든 지역 변수들을 "
"잡아두기 때문입니다."

#: ../Doc/reference/compound_stmts.rst:297
msgid ""
"Before an except clause's suite is executed, details about the exception "
"are stored in the :mod:`sys` module and can be accessed via "
":func:`sys.exc_info`. :func:`sys.exc_info` returns a 3-tuple consisting "
"of the exception class, the exception instance and a traceback object "
"(see section :ref:`types`) identifying the point in the program where the"
" exception occurred.  :func:`sys.exc_info` values are restored to their "
"previous values (before the call) when returning from a function that "
"handled an exception."
msgstr ""
"except 절의 스위트가 실행되기 전에, 예외의 상세 내용이 :mod:`sys` 모듈에 저장되는데, "
":func:`sys.exc_info` 를 통해 액세스할 수 있습니다. :func:`sys.exc_info` 는 예외 클래스, 예외 "
"인스턴스, 예외가 프로그램의 어디에서 발생했는지를 알려주는 트레이스백 객체 (:ref:`types` 를 보세요) 로 이루어진 "
"3-튜플을 돌려줍니다. :func:`sys.exc_info` 값들은 예외를 처리한 함수로부터 복귀할 때 이전 값으로 복구됩니다."

#: ../Doc/reference/compound_stmts.rst:311
msgid ""
"The optional :keyword:`else` clause is executed if and when control flows"
" off the end of the :keyword:`try` clause. [#]_ Exceptions in the "
":keyword:`else` clause are not handled by the preceding :keyword:`except`"
" clauses."
msgstr ""
"생략 가능한 :keyword:`else` 절은 제어 흐름이 :keyword:`try` 절의 끝으로 빠져나갈 때 실행됩니다. [#]_"
" :keyword:`else` 절에서 발생하는 예외는 앞에 나오는 :keyword:`except` 절에서 처리되지 않습니다."

#: ../Doc/reference/compound_stmts.rst:317
msgid ""
"If :keyword:`finally` is present, it specifies a 'cleanup' handler.  The "
":keyword:`try` clause is executed, including any :keyword:`except` and "
":keyword:`else` clauses.  If an exception occurs in any of the clauses "
"and is not handled, the exception is temporarily saved. The "
":keyword:`finally` clause is executed.  If there is a saved exception it "
"is re-raised at the end of the :keyword:`finally` clause.  If the "
":keyword:`finally` clause raises another exception, the saved exception "
"is set as the context of the new exception. If the :keyword:`finally` "
"clause executes a :keyword:`return` or :keyword:`break` statement, the "
"saved exception is discarded::"
msgstr ""
":keyword:`finally` 가 있으면, '정리(cleanup)' 처리기를 지정합니다. :keyword:`except` 와 "
":keyword:`else` 절을 포함해서, 먼저 :keyword:`try` 절이 실행됩니다. 이 절들의 어디에서건 예외가 "
"일어나면, 예외는 임시 저장됩니다. :keyword:`finally` 절이 실행됩니다. 만약 저장된 예외가 있으면, "
":keyword:`finally` 절의 끝에서 다시 발생시킨다. :keyword:`finally` 절이 다른 예외를 일으키면, "
"저장된 예외는 새 예외의 컨텍스트(context) 로 설정됩니다. :keyword:`finally` 절이 "
":keyword:`return` 이나 :keyword:`break` 문을 실행하면, 저장된 예외는 버립니다."

#: ../Doc/reference/compound_stmts.rst:336
msgid ""
"The exception information is not available to the program during "
"execution of the :keyword:`finally` clause."
msgstr ":keyword:`finally` 절을 실행하는 동안 예외 정보는 프로그램에 제공되지 않습니다."

#: ../Doc/reference/compound_stmts.rst:344
msgid ""
"When a :keyword:`return`, :keyword:`break` or :keyword:`continue` "
"statement is executed in the :keyword:`try` suite of a "
":keyword:`try`...\\ :keyword:`finally` statement, the :keyword:`finally` "
"clause is also executed 'on the way out.' A :keyword:`continue` statement"
" is illegal in the :keyword:`finally` clause. (The reason is a problem "
"with the current implementation --- this restriction may be lifted in the"
" future)."
msgstr ""
":keyword:`try`...\\ :keyword:`finally` 문의 :keyword:`try` 스위트에서 "
":keyword:`return`, :keyword:`break`, :keyword:`continue` 문이 실행될 때, "
":keyword:`finally` 절도 '나가는 길에' 실행됩니다. :keyword:`finally` 절에서는 "
":keyword:`continue` 문을 사용할 수 없다. (그 이유는 현재 구현에 있는 문제 때문입니다 --- 이 제약은 미래에 "
"제거될 수 있습니다)."

#: ../Doc/reference/compound_stmts.rst:351
msgid ""
"The return value of a function is determined by the last "
":keyword:`return` statement executed.  Since the :keyword:`finally` "
"clause always executes, a :keyword:`return` statement executed in the "
":keyword:`finally` clause will always be the last one executed::"
msgstr ""
"함수의 반환 값은 마지막에 실행된 :keyword:`return` 문으로 결정됩니다. :keyword:`finally` 절이 항상 "
"실행되기 때문에, :keyword:`finally` 절에서 실행되는 :keyword:`return` 문이 항상 마지막에 실행되는 "
"것이 됩니다::"

#: ../Doc/reference/compound_stmts.rst:365
msgid ""
"Additional information on exceptions can be found in section "
":ref:`exceptions`, and information on using the :keyword:`raise` "
"statement to generate exceptions may be found in section :ref:`raise`."
msgstr ""
"예외에 관한 추가의 정보는 :ref:`exceptions` 섹션에서 찾을 수 있고, 예외를 일으키기 위해 "
":keyword:`raise` 문을 사용하는 것에 관한 정보는 :ref:`raise` 섹션에서 찾을 수 있습니다."

#: ../Doc/reference/compound_stmts.rst:374
msgid "The :keyword:`with` statement"
msgstr ":keyword:`with` 문"

#: ../Doc/reference/compound_stmts.rst:380
msgid ""
"The :keyword:`with` statement is used to wrap the execution of a block "
"with methods defined by a context manager (see section :ref:`context-"
"managers`). This allows common :keyword:`try`...\\ :keyword:`except`...\\"
" :keyword:`finally` usage patterns to be encapsulated for convenient "
"reuse."
msgstr ""
":keyword:`with` 문은 블록의 실행을 컨텍스트 관리자 (:ref:`context-managers` 섹션을 보세요) 가 "
"정의한 메서드들로 감싸는 데 사용됩니다. 이것은 흔한 :keyword:`try`...\\ :keyword:`except`...\\ "
":keyword:`finally` 사용 패턴을 편리하게 재사용할 수 있도록 캡슐화할 수 있도록 합니다."

#: ../Doc/reference/compound_stmts.rst:389
msgid ""
"The execution of the :keyword:`with` statement with one \"item\" proceeds"
" as follows:"
msgstr "하나의 \"item\" 을 사용하는 :keyword:`with` 문의 실행은 다음과 같이 진행됩니다:"

#: ../Doc/reference/compound_stmts.rst:391
msgid ""
"The context expression (the expression given in the :token:`with_item`) "
"is evaluated to obtain a context manager."
msgstr ""
"컨텍스트 관리자를 얻기 위해 컨텍스트 표현식 (:token:`with_item` 에 주어진 expression) 의 값을 구합니다."

#: ../Doc/reference/compound_stmts.rst:394
msgid "The context manager's :meth:`__exit__` is loaded for later use."
msgstr "나중에 사용하기 위해 컨텍스트 관리자의 :meth:`__exit__` 가 로드됩니다."

#: ../Doc/reference/compound_stmts.rst:396
msgid "The context manager's :meth:`__enter__` method is invoked."
msgstr "컨텍스트 관리자의 :meth:`__enter__` 메서드를 호출합니다."

#: ../Doc/reference/compound_stmts.rst:398
msgid ""
"If a target was included in the :keyword:`with` statement, the return "
"value from :meth:`__enter__` is assigned to it."
msgstr ":keyword:`with` 문에 타깃이 포함되었으면, 그것에 :meth:`__enter__` 의 반환 값을 대입합니다."

#: ../Doc/reference/compound_stmts.rst:403
msgid ""
"The :keyword:`with` statement guarantees that if the :meth:`__enter__` "
"method returns without an error, then :meth:`__exit__` will always be "
"called. Thus, if an error occurs during the assignment to the target "
"list, it will be treated the same as an error occurring within the suite "
"would be. See step 6 below."
msgstr ""
":keyword:`with` 문은 :meth:`__enter__` 메서드가 에러 없이 돌아왔을 때, :meth:`__exit__` "
"가 항상 호출됨을 보장합니다. 그래서, 타깃에 대입하는 동안 에러가 발생하면, 스위트 안에서 에러가 발생한 것과 같이 취급됩니다. "
"아래의 6단계를 보세요."

#: ../Doc/reference/compound_stmts.rst:409
msgid "The suite is executed."
msgstr "스위트가 실행됩니다."

#: ../Doc/reference/compound_stmts.rst:411
msgid ""
"The context manager's :meth:`__exit__` method is invoked.  If an "
"exception caused the suite to be exited, its type, value, and traceback "
"are passed as arguments to :meth:`__exit__`. Otherwise, three "
":const:`None` arguments are supplied."
msgstr ""
"컨텍스트 관리자의 :meth:`__exit__` 메서드를 호출합니다. 예외가 스위트를 종료되도록 만들었다면, 그것의 형, 값, "
"트레이스백이 :meth:`__exit__` 의 인자로 전달됩니다. 그렇지 않으면 세 개의 :const:`None` 이 인자로 "
"공급됩니다."

#: ../Doc/reference/compound_stmts.rst:416
msgid ""
"If the suite was exited due to an exception, and the return value from "
"the :meth:`__exit__` method was false, the exception is reraised.  If the"
" return value was true, the exception is suppressed, and execution "
"continues with the statement following the :keyword:`with` statement."
msgstr ""
"스위트가 예외 때문에 종료되었고, :meth:`__exit__` 메서드의 반환 값이 거짓이면, 그 예외를 다시 일으킨다. 반환 값이"
" 참이면, 예외를 억누르고, :keyword:`with` 문 뒤에 오는 문장으로 실행을 계속합니다. "

#: ../Doc/reference/compound_stmts.rst:421
msgid ""
"If the suite was exited for any reason other than an exception, the "
"return value from :meth:`__exit__` is ignored, and execution proceeds at "
"the normal location for the kind of exit that was taken."
msgstr ""
"스위트가 예외 이외의 이유로 종료되면, :meth:`__exit__` 의 반환 값은 무시되고, 해당 종료의 종류에 맞는 위치에서 "
"실행을 계속합니다."

#: ../Doc/reference/compound_stmts.rst:425
msgid ""
"With more than one item, the context managers are processed as if "
"multiple :keyword:`with` statements were nested::"
msgstr "하나 보다 많은 항목을 주면, 컨텍스트 관리자는 :keyword:`with` 문이 중첩된 것처럼 진행합니다::"

#: ../Doc/reference/compound_stmts.rst:431
#: ../Doc/reference/compound_stmts.rst:636
msgid "is equivalent to ::"
msgstr "는 다음과 동등합니다 ::"

#: ../Doc/reference/compound_stmts.rst:437
msgid "Support for multiple context expressions."
msgstr "다중 컨텍스트 표현식의 지원"

#: ../Doc/reference/compound_stmts.rst:443
msgid ":pep:`343` - The \"with\" statement"
msgstr ":pep:`343` - \"with\" 문"

#: ../Doc/reference/compound_stmts.rst:443
msgid ""
"The specification, background, and examples for the Python "
":keyword:`with` statement."
msgstr "파이썬 :keyword:`with` 문의 규격, 배경, 예."

#: ../Doc/reference/compound_stmts.rst:454
msgid "Function definitions"
msgstr "함수 정의"

#: ../Doc/reference/compound_stmts.rst:466
msgid ""
"A function definition defines a user-defined function object (see section"
" :ref:`types`):"
msgstr "함수 정의는 사용자 정의 함수 객체 (:ref:`types` 섹션을 보세요) 를 정의합니다:"

#: ../Doc/reference/compound_stmts.rst:484
msgid ""
"A function definition is an executable statement.  Its execution binds "
"the function name in the current local namespace to a function object (a "
"wrapper around the executable code for the function).  This function "
"object contains a reference to the current global namespace as the global"
" namespace to be used when the function is called."
msgstr ""
"함수 정의는 실행할 수 있는 문장입니다. 실행하면 현재 지역 이름 공간의 함수 이름을 함수 객체 (함수의 실행 가능한 코드를 둘러싼"
" 래퍼(wrapper)). 이 함수 객체는 현재의 이름 공간에 대한 참조를 포함하는데, 함수가 호출될 때 전역 이름 공간으로 "
"사용됩니다."

#: ../Doc/reference/compound_stmts.rst:490
msgid ""
"The function definition does not execute the function body; this gets "
"executed only when the function is called. [#]_"
msgstr "함수 정의는 함수의 바디를 실행하지 않습니다. 함수가 호출될 때 실행됩니다. [#]_"

#: ../Doc/reference/compound_stmts.rst:496
msgid ""
"A function definition may be wrapped by one or more :term:`decorator` "
"expressions. Decorator expressions are evaluated when the function is "
"defined, in the scope that contains the function definition.  The result "
"must be a callable, which is invoked with the function object as the only"
" argument. The returned value is bound to the function name instead of "
"the function object.  Multiple decorators are applied in nested fashion. "
"For example, the following code ::"
msgstr ""
"함수 정의는 하나나 그 이상의 :term:`데코레이터 <decorator>` 표현식으로 감싸질 수 있습니다. 데코레이터 표현식은 "
"함수가 정의될 때, 함수 정의를 포함하는 스코프에서 값을 구합니다. 그 결과는 콜러블이어야 하는데, 함수 객체만을 인자로 사용해서 "
"호출됩니다. 반환 값이 함수 객체 대신 함수의 이름에 연결됩니다. 여러 개의 데코레이터는 중첩되는 방식으로 적용됩니다. 예를 들어,"
" 다음과 같은 코드 ::"

#: ../Doc/reference/compound_stmts.rst:507
#: ../Doc/reference/compound_stmts.rst:663
msgid "is roughly equivalent to ::"
msgstr "는 대략 다음과 동등합니다 ::"

#: ../Doc/reference/compound_stmts.rst:512
msgid ""
"except that the original function is not temporarily bound to the name "
"``func``."
msgstr "원래의 함수가 임시로 이름 ``func`` 에 연결되지 않는다는 점만 다릅니다."

#: ../Doc/reference/compound_stmts.rst:518
msgid ""
"When one or more :term:`parameters <parameter>` have the form *parameter*"
" ``=`` *expression*, the function is said to have \"default parameter "
"values.\"  For a parameter with a default value, the corresponding "
":term:`argument` may be omitted from a call, in which case the "
"parameter's default value is substituted.  If a parameter has a default "
"value, all following parameters up until the \"``*``\" must also have a "
"default value --- this is a syntactic restriction that is not expressed "
"by the grammar."
msgstr ""
"하나나 그 이상의 :term:`매개변수 <parameter>` 들이 *parameter* ``=`` *expression* 형태를 "
"가질 때, 함수가 \"기본 매개변수 값\"을 갖는다고 말합니다. 기본값이 있는 매개변수의 경우, 호출할 때 대응하는 "
":term:`인자 <argument>` 를 생략할 수 있고, 그럴 때 매개변수의 기본값이 적용됩니다. 만약 매개변수가 기본값을 "
"가지면, \"``*``\" 까지 그 뒤를 따르는 모든 매개변수도 기본값을 가져야 합니다 --- 이것은 문법 규칙에서 표현되지 않는 "
"문법적 제약입니다."

#: ../Doc/reference/compound_stmts.rst:526
msgid ""
"**Default parameter values are evaluated from left to right when the "
"function definition is executed.** This means that the expression is "
"evaluated once, when the function is defined, and that the same \"pre-"
"computed\" value is used for each call.  This is especially important to "
"understand when a default parameter is a mutable object, such as a list "
"or a dictionary: if the function modifies the object (e.g. by appending "
"an item to a list), the default value is in effect modified.  This is "
"generally not what was intended.  A way around this is to use ``None`` as"
" the default, and explicitly test for it in the body of the function, "
"e.g.::"
msgstr ""
"**함수 정의가 실행될 때, 기본 매개변수 값은 왼쪽에서 오른쪽으로 값이 구해집니다.** 이것은 표현식이 함수가 정의될 때 한 번 "
"값이 구해지고, 호출마다 같은 \"미리 계산된\" 값이 사용된다는 것을 뜻합니다. 이것을 이해하는 것은 특히 기본값이 리스트나 "
"딕셔너리와 같은 가변 객체일 때 중요합니다: 만약 함수가 그 객체를 수정하면 (가령, 리스트에 항목을 추가합니다), 그 결과 "
"기본값이 수정됩니다. 이것은 일반적으로 의도하고 있는 것이 아니다. 이 문제를 회피하는 방법은 기본값으로 ``None`` 을 "
"사용하고, 함수 바디에서 명시적으로 검사하는 것입니다, 예를 들어::"

#: ../Doc/reference/compound_stmts.rst:546
msgid ""
"Function call semantics are described in more detail in section "
":ref:`calls`. A function call always assigns values to all parameters "
"mentioned in the parameter list, either from position arguments, from "
"keyword arguments, or from default values.  If the form "
"\"``*identifier``\" is present, it is initialized to a tuple receiving "
"any excess positional parameters, defaulting to the empty tuple. If the "
"form \"``**identifier``\" is present, it is initialized to a new ordered "
"mapping receiving any excess keyword arguments, defaulting to a new empty"
" mapping of the same type.  Parameters after \"``*``\" or "
"\"``*identifier``\" are keyword-only parameters and may only be passed "
"used keyword arguments."
msgstr ""
"함수 호출의 의미는 섹션 :ref:`calls` 에서 더 자세히 설명됩니다. 함수 호출은 항상 매개변수 목록에서 언급하는 모든 "
"매개변수에 값을 대입하는데, 위치 인자들에서 올 수도, 키워드 인자들에서 올 수도, 기본값에서 올 수도 있습니다. "
"\"``*identifier``\" 형태가 존재하면, 남는 위치 매개변수들을 받는 튜플로 초기화됩니다. 기본값은 빈 튜플입니다. "
"\"``**identifier``\" 형태가 존재하면, 남는 키워드 인자들을 받는 순서 있는 매핑으로 초기화됩니다. 기본값은 빈 "
"매핑입니다. \"``*``\" 나 \"``*identifier``\" 뒤에 오는 매개변수들은 키워드 전용 매개변수들이고, 키워드 "
"인자로만 전달될 수 있습니다."

#: ../Doc/reference/compound_stmts.rst:559
msgid ""
"Parameters may have annotations of the form \"``: expression``\" "
"following the parameter name.  Any parameter may have an annotation even "
"those of the form ``*identifier`` or ``**identifier``.  Functions may "
"have \"return\" annotation of the form \"``-> expression``\" after the "
"parameter list.  These annotations can be any valid Python expression.  "
"The presence of annotations does not change the semantics of a function."
"  The annotation values are available as values of a dictionary keyed by "
"the parameters' names in the :attr:`__annotations__` attribute of the "
"function object.  If the ``annotations`` import from :mod:`__future__` is"
" used, annotations are preserved as strings at runtime which enables "
"postponed evaluation.  Otherwise, they are evaluated when the function "
"definition is executed.  In this case annotations may be evaluated in a "
"different order than they appear in the source code."
msgstr ""
"매개변수들은 매개변수 이름 뒤에 오는 \"``: expression``\" 형태의 어노테이션을 가질 수 있습니다. 모든 매개변수는 "
"어노테이션을 가질 수 있는데, ``*identifier`` 나 ``**identifier`` 형태조차 그렇습니다. 함수는 매개변수 "
"목록 뒤에 오는 \"``-> expression``\" 형태의 반환(\"return\") 어노테이션을 가질 수 있습니다. 이 "
"어노테이션들은 올바른 파이썬 표현식이면 어떤 것이건 될 수 있습니다. 어노테이션의 존재는 함수의 의미를 바꾸지 않습니다. 어노테이션"
" 값들은 함수 객체의 :attr:`__annotations__` 어트리뷰트에서 매개변수의 이름을 키로 하는 딕셔너리의 값으로 "
"제공됩니다. :mod:`__future__` 에서 ``annotations`` 을 임포트하면, 지연된 평가가 활성화되어 어노테이션은"
" 실행시간에 문자열로 보존됩니다. 그렇지 않으면 함수 정의가 실행될 때 평가됩니다. 이 경우 어노테이션은 소스 코드에 나오는 순서와"
" 다른 순서로 평가될 수 있습니다."

#: ../Doc/reference/compound_stmts.rst:574
msgid ""
"It is also possible to create anonymous functions (functions not bound to"
" a name), for immediate use in expressions.  This uses lambda "
"expressions, described in section :ref:`lambda`.  Note that the lambda "
"expression is merely a shorthand for a simplified function definition; a "
"function defined in a \":keyword:`def`\" statement can be passed around "
"or assigned to another name just like a function defined by a lambda "
"expression.  The \":keyword:`def`\" form is actually more powerful since "
"it allows the execution of multiple statements and annotations."
msgstr ""
"표현식에서 즉시 사용하기 위해, 이름 없는 함수(이름에 연결되지 않은 함수)를 만드는 것도 가능합니다. 이것은 람다 표현식을 "
"사용하는데, :ref:`lambda` 섹션에서 설명합니다. 람다 표현식은 단순화된 함수 정의를 위한 줄임 표현에 지나지 않는다는 "
"것에 주의하세요; \":keyword:`def`\" 문장에서 정의된 함수는 람다 표현식으로 정의된 함수처럼 전달되거나 다른 이름에 "
"대입될 수 있습니다. 여러 개의 문장을 실행하는 것과 어노테이션을 허락하기 때문에, \":keyword:`def`\" 형태가 사실 "
"더 강력합니다."

#: ../Doc/reference/compound_stmts.rst:582
msgid ""
"**Programmer's note:** Functions are first-class objects.  A \"``def``\" "
"statement executed inside a function definition defines a local function "
"that can be returned or passed around.  Free variables used in the nested"
" function can access the local variables of the function containing the "
"def.  See section :ref:`naming` for details."
msgstr ""
"**프로그래머 유의 사항:** 함수는 퍼스트 클래스(first-class) 객체다. 함수 정의 안에서 실행되는 \"``def``\""
" 문은 돌려주거나 전달할 수 있는 지역 함수를 정의합니다. 중첩된 함수에서 사용되는 자유 변수들은 그 def 를 포함하는 함수의 "
"지역 변수들을 액세스할 수 있습니다. 더 자세한 내용은 :ref:`naming` 섹션을 보세요."

#: ../Doc/reference/compound_stmts.rst:591
msgid ":pep:`3107` - Function Annotations"
msgstr ":pep:`3107` - 함수 어노테이션"

#: ../Doc/reference/compound_stmts.rst:591
msgid "The original specification for function annotations."
msgstr "함수 어노테이션의 최초 규격."

#: ../Doc/reference/compound_stmts.rst:594
msgid ":pep:`484` - Type Hints"
msgstr ":pep:`484` - 형 힌트"

#: ../Doc/reference/compound_stmts.rst:594
msgid "Definition of a standard meaning for annotations: type hints."
msgstr "어노테이션에 대한 표준 의미 정의: 형 힌트."

#: ../Doc/reference/compound_stmts.rst:598
msgid ":pep:`526` - Syntax for Variable Annotations"
msgstr ":pep:`526` - 변수 어노테이션 문법"

#: ../Doc/reference/compound_stmts.rst:597
msgid ""
"Ability to type hint variable declarations, including class variables and"
" instance variables"
msgstr "클래스 변수 및 인스턴스 변수를 포함하는 변수 선언에 형 힌트를 줄 수 있는 기능"

#: ../Doc/reference/compound_stmts.rst:601
msgid ":pep:`563` - Postponed Evaluation of Annotations"
msgstr ":pep:`563` - 어노테이션의 지연된 평가"

#: ../Doc/reference/compound_stmts.rst:601
msgid ""
"Support for forward references within annotations by preserving "
"annotations in a string form at runtime instead of eager evaluation."
msgstr "즉시 평가하는 대신 실행시간에 어노테이션을 문자열 형식으로 보존하여 어노테이션 내에서의 전방 참조를 지원합니다."

#: ../Doc/reference/compound_stmts.rst:608
msgid "Class definitions"
msgstr "클래스 정의"

#: ../Doc/reference/compound_stmts.rst:620
msgid "A class definition defines a class object (see section :ref:`types`):"
msgstr "클래스 정의는 클래스 객체(:ref:`types` 섹션을 보세요)를 정의합니다:"

#: ../Doc/reference/compound_stmts.rst:627
msgid ""
"A class definition is an executable statement.  The inheritance list "
"usually gives a list of base classes (see :ref:`metaclasses` for more "
"advanced uses), so each item in the list should evaluate to a class "
"object which allows subclassing.  Classes without an inheritance list "
"inherit, by default, from the base class :class:`object`; hence, ::"
msgstr ""
"클래스 정의는 실행 가능한 문장입니다. 계승(inheritance) 목록은 보통 베이스 클래스들의 목록을 제공하는데 (더 고급 "
"사용에 대해서는 :ref:`metaclasses` 를 보세요), 목록의 각 항목은 값을 구할 때 서브클래싱을 허락하는 클래스 객체가"
" 되어야 합니다. 계승 목록이 없는 클래스는, 기본적으로, 베이스 클래스 :class:`object` 를 계승합니다; 그래서 ::"

#: ../Doc/reference/compound_stmts.rst:641
msgid ""
"The class's suite is then executed in a new execution frame (see "
":ref:`naming`), using a newly created local namespace and the original "
"global namespace. (Usually, the suite contains mostly function "
"definitions.)  When the class's suite finishes execution, its execution "
"frame is discarded but its local namespace is saved. [#]_ A class object "
"is then created using the inheritance list for the base classes and the "
"saved local namespace for the attribute dictionary.  The class name is "
"bound to this class object in the original local namespace."
msgstr ""
"클래스의 스위트는 새로 만들어진 지역 이름 공간과 원래의 전역 이름 공간을 사용하는 새 실행 프레임 (:ref:`naming` 을 "
"보세요)에서 실행됩니다. (보통, 스위트는 대부분 함수 정의들을 포함합니다.) 클래스의 스위트가 실행을 마치면, 실행 프레임은 "
"파기하지만, 그것의 지역 이름 공간은 보존합니다. [#]_ 그런 다음, 계승 목록을 베이스 클래스들로, 보존된 지역 이름 공간을 "
"어트리뷰트 딕셔너리로 사용해서 새 클래스 객체를 만듭니다. 클래스의 이름은 원래의 지역 이름 공간에서 이 클래스 객체와 연결됩니다."

#: ../Doc/reference/compound_stmts.rst:650
msgid ""
"The order in which attributes are defined in the class body is preserved "
"in the new class's ``__dict__``.  Note that this is reliable only right "
"after the class is created and only for classes that were defined using "
"the definition syntax."
msgstr ""
"클래스 바디에서 어트리뷰트가 정의되는 순서는, 새 클래스의 ``__dict__`` 에 보존됩니다. 이것은 클래스가 만들어진 직후에,"
" 정의 문법을 사용해서 정의되는 클래스들에서만 신뢰할 수 있다는 것에 주의해야 합니다."

#: ../Doc/reference/compound_stmts.rst:655
msgid ""
"Class creation can be customized heavily using :ref:`metaclasses "
"<metaclasses>`."
msgstr "클래스 생성은 :ref:`메타 클래스 <metaclasses>` 를 사용해서 심하게 커스터마이즈할 수 있습니다."

#: ../Doc/reference/compound_stmts.rst:657
msgid "Classes can also be decorated: just like when decorating functions, ::"
msgstr "클래스 역시 함수를 데코레이팅할 때처럼 테코레이트할 수 있습니다, ::"

#: ../Doc/reference/compound_stmts.rst:668
msgid ""
"The evaluation rules for the decorator expressions are the same as for "
"function decorators.  The result is then bound to the class name."
msgstr "데코레이터 표현식의 값을 구하는 규칙은 함수 데코레이터와 같습니다. 그런 다음 그 결과가 클래스 이름에 연결됩니다."

#: ../Doc/reference/compound_stmts.rst:671
msgid ""
"**Programmer's note:** Variables defined in the class definition are "
"class attributes; they are shared by instances.  Instance attributes can "
"be set in a method with ``self.name = value``.  Both class and instance "
"attributes are accessible through the notation \"``self.name``\", and an "
"instance attribute hides a class attribute with the same name when "
"accessed in this way.  Class attributes can be used as defaults for "
"instance attributes, but using mutable values there can lead to "
"unexpected results.  :ref:`Descriptors <descriptors>` can be used to "
"create instance variables with different implementation details."
msgstr ""
"**프로그래머 유의 사항:** 클래스 정의에서 정의되는 변수들은 클래스 어트리뷰트입니다; 이것들은 인스턴스 간에 공유됩니다. "
"인스턴스 어트리뷰트는 메서드에서 ``self.name = value`` 로 설정될 수 있습니다. 클래스와 인스턴스 어트리뷰트 모두 "
"\"``self.name``\" 표기법으로 액세스할 수 있고, 이런 식으로 액세스할 때 인스턴스 어트리뷰트는 같은 이름의 클래스 "
"어트리뷰트를 가립니다. 클래스 어트리뷰트는 인스턴스 어트리뷰트의 기본값으로 사용될 수 있지만, 가변 값을 사용하는 것은 예상하지 "
"않은 결과를 줄 수 있습니다. :ref:`디스크립터 <descriptors>` 를 다른 구현 상세를 갖는 인스턴스 변수를 만드는데 "
"사용할 수 있습니다."

#: ../Doc/reference/compound_stmts.rst:686
msgid ":pep:`3115` - Metaclasses in Python 3000"
msgstr ":pep:`3115` - 파이썬 3000의 메타 클래스"

#: ../Doc/reference/compound_stmts.rst:684
msgid ""
"The proposal that changed the declaration of metaclasses to the current "
"syntax, and the semantics for how classes with metaclasses are "
"constructed."
msgstr "메타 클래스 선언을 현재 문법으로 변경하고, 메타 클래스가 있는 클래스를 구성하는 방법의 의미를 변경하는 제안."

#: ../Doc/reference/compound_stmts.rst:689
msgid ":pep:`3129` - Class Decorators"
msgstr ":pep:`3129` - 클래스 데코레이터"

#: ../Doc/reference/compound_stmts.rst:689
msgid ""
"The proposal that added class decorators.  Function and method decorators"
" were introduced in :pep:`318`."
msgstr "클래스 데코레이터를 추가하는 제안. 함수와 메서드 데코레이터는 :pep:`318`\\에서 도입되었습니다."

#: ../Doc/reference/compound_stmts.rst:696
msgid "Coroutines"
msgstr "코루틴"

#: ../Doc/reference/compound_stmts.rst:704
msgid "Coroutine function definition"
msgstr "코루틴 함수 정의"

#: ../Doc/reference/compound_stmts.rst:714
msgid ""
"Execution of Python coroutines can be suspended and resumed at many "
"points (see :term:`coroutine`).  In the body of a coroutine, any "
"``await`` and ``async`` identifiers become reserved keywords; "
":keyword:`await` expressions, :keyword:`async for` and :keyword:`async "
"with` can only be used in coroutine bodies."
msgstr ""
"파이썬 코루틴의 실행은 여러 지점에서 일시 중지되거나 재개될 수 있습니다 (:term:`코루틴 <coroutine>` 을 "
"보세요.). 코루틴의 바디에서, ``await`` 와 ``async`` 식별자는 예약 키워드가 됩니다; "
"어웨이트(:keyword:`await`) 표현식, :keyword:`async for`, :keyword:`async with` 는"
" 코루틴 바디에서만 사용할 수 있습니다."

#: ../Doc/reference/compound_stmts.rst:720
msgid ""
"Functions defined with ``async def`` syntax are always coroutine "
"functions, even if they do not contain ``await`` or ``async`` keywords."
msgstr ""
"``async def`` 문법으로 정의된 함수는 항상 코루틴 함수인데, ``await`` 나 ``async`` 키워드를 포함하지 "
"않는 경우도 그렇습니다."

#: ../Doc/reference/compound_stmts.rst:723
msgid ""
"It is a :exc:`SyntaxError` to use ``yield from`` expressions in ``async "
"def`` coroutines."
msgstr ""
"``async def`` 코루틴에서 ``yield from`` 표현식을 사용하는 것은 :exc:`SyntaxError` 입니다."

#: ../Doc/reference/compound_stmts.rst:726
msgid "An example of a coroutine function::"
msgstr "코루틴 함수의 예::"

#: ../Doc/reference/compound_stmts.rst:737
msgid "The :keyword:`async for` statement"
msgstr ":keyword:`async for` 문"

#: ../Doc/reference/compound_stmts.rst:742
msgid ""
"An :term:`asynchronous iterable` is able to call asynchronous code in its"
" *iter* implementation, and :term:`asynchronous iterator` can call "
"asynchronous code in its *next* method."
msgstr ""
":term:`비동기 이터러블 <asynchronous iterable>` 은 *iter* 구현에서 비동기 코드를 호출할 수 있고, "
":term:`비동기 이터레이터 <asynchronous iterator>` 는 *next* 메서드에서 비동기 코드를 호출할 수 "
"있습니다."

#: ../Doc/reference/compound_stmts.rst:746
msgid ""
"The ``async for`` statement allows convenient iteration over asynchronous"
" iterators."
msgstr "``async for`` 문은 비동기 이터레이터에 대한 편리한 이터레이션을 허락합니다."

#: ../Doc/reference/compound_stmts.rst:749
#: ../Doc/reference/compound_stmts.rst:789
msgid "The following code::"
msgstr "다음과 같은 코드는::"

#: ../Doc/reference/compound_stmts.rst:756
#: ../Doc/reference/compound_stmts.rst:794
msgid "Is semantically equivalent to::"
msgstr "의미상으로 다음과 동등합니다::"

#: ../Doc/reference/compound_stmts.rst:771
msgid "See also :meth:`__aiter__` and :meth:`__anext__` for details."
msgstr "더 자세한 내용은 :meth:`__aiter__` 를 :meth:`__anext__` 보면 됩니다."

#: ../Doc/reference/compound_stmts.rst:773
msgid ""
"It is a :exc:`SyntaxError` to use an ``async for`` statement outside of a"
" coroutine."
msgstr "코루틴 밖에서 ``async for`` 문을 사용하는 것은 :exc:`SyntaxError` 입니다."

#: ../Doc/reference/compound_stmts.rst:781
msgid "The :keyword:`async with` statement"
msgstr ":keyword:`async with` 문"

#: ../Doc/reference/compound_stmts.rst:786
msgid ""
"An :term:`asynchronous context manager` is a :term:`context manager` that"
" is able to suspend execution in its *enter* and *exit* methods."
msgstr ""
":term:`비동기 컨텍스트 관리자 <asynchronous context manager>` 는 *enter* 와 *exit* "
"메서드에서 실행을 일시 중지할 수 있는 :term:`컨텍스트 관리자 <context manager>` 입니다."

#: ../Doc/reference/compound_stmts.rst:809
msgid "See also :meth:`__aenter__` and :meth:`__aexit__` for details."
msgstr "더 자세한 내용은 :meth:`__aenter__` 와 :meth:`__aexit__` 를 보면 됩니다."

#: ../Doc/reference/compound_stmts.rst:811
msgid ""
"It is a :exc:`SyntaxError` to use an ``async with`` statement outside of "
"a coroutine."
msgstr "코루틴 밖에서 ``async with`` 문을 사용하는 것은 :exc:`SyntaxError` 입니다."

#: ../Doc/reference/compound_stmts.rst:817
msgid ":pep:`492` - Coroutines with async and await syntax"
msgstr ":pep:`492` - async 와 await 문법을 사용하는 코루틴"

#: ../Doc/reference/compound_stmts.rst:817
msgid ""
"The proposal that made coroutines a proper standalone concept in Python, "
"and added supporting syntax."
msgstr "코루틴을 파이썬에서 적절한 독립적인 개념으로 만들고, 문법 지원을 추가한 제안."

#: ../Doc/reference/compound_stmts.rst:822
msgid "Footnotes"
msgstr "각주"

#: ../Doc/reference/compound_stmts.rst:823
msgid ""
"The exception is propagated to the invocation stack unless there is a "
":keyword:`finally` clause which happens to raise another exception. That "
"new exception causes the old one to be lost."
msgstr ""
"다른 예외를 일으키는 :keyword:`finally` 절이 있지 않은 한 예외는 호출 스택으로 퍼집니다. 그 새 예외는 예전의 "
"것을 잃어버리게 만듭니다."

#: ../Doc/reference/compound_stmts.rst:827
msgid ""
"Currently, control \"flows off the end\" except in the case of an "
"exception or the execution of a :keyword:`return`, :keyword:`continue`, "
"or :keyword:`break` statement."
msgstr ""
"현재, 예외나, :keyword:`return`, :keyword:`continue`, :keyword:`break` 문의 실행을 "
"제외하고는 \"제어 흐름이 try 절의 끝으로 빠져나갑니다\"."

#: ../Doc/reference/compound_stmts.rst:831
msgid ""
"A string literal appearing as the first statement in the function body is"
" transformed into the function's ``__doc__`` attribute and therefore the "
"function's :term:`docstring`."
msgstr ""
"함수 바디의 첫 번째 문장으로 등장하는 문자열 리터럴은 함수의 ``__doc__`` 어트리뷰트로 변환되어 함수의 "
":term:`독스트링 <docstring>` 이 됩니다."

#: ../Doc/reference/compound_stmts.rst:835
msgid ""
"A string literal appearing as the first statement in the class body is "
"transformed into the namespace's ``__doc__`` item and therefore the "
"class's :term:`docstring`."
msgstr ""
"클래스 바디의 첫 번째 문장으로 등장하는 문자열 리터럴은 그 이름 공간의 ``__doc__`` 항목으로 변환되어 클래스의 "
":term:`독스트링 <docstring>` 이 됩니다."
