# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/reference/executionmodel.rst:6
msgid "Execution model"
msgstr "실행 모델"

#: ../Doc/reference/executionmodel.rst:15
msgid "Structure of a program"
msgstr "프로그램의 구조"

#: ../Doc/reference/executionmodel.rst:19
msgid ""
"A Python program is constructed from code blocks. A :dfn:`block` is a "
"piece of Python program text that is executed as a unit. The following "
"are blocks: a module, a function body, and a class definition. Each "
"command typed interactively is a block.  A script file (a file given as "
"standard input to the interpreter or specified as a command line argument"
" to the interpreter) is a code block.  A script command (a command "
"specified on the interpreter command line with the '**-c**' option) is a "
"code block.  The string argument passed to the built-in functions "
":func:`eval` and :func:`exec` is a code block."
msgstr ""
"파이썬 프로그램은 코드 블록으로 만들어진다. :dfn:`블록 (block)` 은 한 단위로 실행되는 한 "
"조각의 파이썬 프로그램 텍스트다. 다음과 같은 것들이 블록이다: 모듈, 함수 바디, 클래스 정의. "
"대화형으로 입력되는 각 명령은 블록이다. 스크립트 파일(표준 입력을 통해 인터프리터로 제공되는 "
"파일이나 인터프리터에 명령행 인자로 지정된 파일)은 코드 블록이다. 스크립트 명령('**-c**' "
"옵션으로 인터프리터 명령행에 지정된 명령)은 코드 블록이다. 내장함수 :func:`eval` 과 "
":func:`exec` 로 전달되는 문자열 인자도 코드 블록이다."

#: ../Doc/reference/executionmodel.rst:31
msgid ""
"A code block is executed in an :dfn:`execution frame`.  A frame contains "
"some administrative information (used for debugging) and determines where"
" and how execution continues after the code block's execution has "
"completed."
msgstr ""
"코드 블록은 :dfn:`실행 프레임 (execution frame)` 에서 실행된다. 프레임은 몇몇 관리를 "
"위한 정보(디버깅에 사용된다)를 포함하고, 코드 블록의 실행이 끝난 후에 어디서 어떻게 실행을 "
"계속할 것인지를 결정한다."

#: ../Doc/reference/executionmodel.rst:38
msgid "Naming and binding"
msgstr "이름과 연결(binding)"

#: ../Doc/reference/executionmodel.rst:47
msgid "Binding of names"
msgstr "이름의 연결"

#: ../Doc/reference/executionmodel.rst:53
msgid ""
":dfn:`Names` refer to objects.  Names are introduced by name binding "
"operations."
msgstr ""
":dfn:`이름 (Names)` 은 객체를 가리킨다. 이름은 이름 연결 연산 때문에 만들어진다."

#: ../Doc/reference/executionmodel.rst:57
msgid ""
"The following constructs bind names: formal parameters to functions, "
":keyword:`import` statements, class and function definitions (these bind "
"the class or function name in the defining block), and targets that are "
"identifiers if occurring in an assignment, :keyword:`for` loop header, or"
" after :keyword:`as` in a :keyword:`with` statement or :keyword:`except` "
"clause. The :keyword:`import` statement of the form ``from ... import *``"
" binds all names defined in the imported module, except those beginning "
"with an underscore.  This form may only be used at the module level."
msgstr ""
"다음과 같은 것들이 이름을 연결한다: 함수로 전달되는 형식 파라미터, :keyword:`import` 문, "
"클래스와 함수 정의(이것들은 클래스나 함수 이름을 정의하고 있는 블록에 연결한다), 그리고 다음과 "
"같은 것들에 등장하는 식별자 대상들: 대입, :keyword:`for` 루프 헤더, :keyword:`with` "
"문이나 :keyword:`except` 절의 :keyword:`as` 뒤. ``from ... import *`` 형태의 "
":keyword:`import` 문은 임포트되는 모듈에 정의된 모든 이름을 연결한다, 밑줄로 시작하는 "
"이름들은 예외다. 이 형태는 모듈 수준에서만 사용될 수 있다."

#: ../Doc/reference/executionmodel.rst:67
msgid ""
"A target occurring in a :keyword:`del` statement is also considered bound"
" for this purpose (though the actual semantics are to unbind the name)."
msgstr ""
":keyword:`del` 문에 나오는 대상 역시 이 목적에서 연결된 것으로 간주한다(실제 의미가 이름을 "
"연결 해제하는 것이기는 해도)."

#: ../Doc/reference/executionmodel.rst:70
msgid ""
"Each assignment or import statement occurs within a block defined by a "
"class or function definition or at the module level (the top-level code "
"block)."
msgstr ""
"각 대입이나 임포트 문은 클래스나 함수 정의 때문에 정의되는 블록 내에 등장할 수 있고, 모듈 "
"수준(최상위 코드 블록)에서 등장할 수도 있다."

#: ../Doc/reference/executionmodel.rst:75
msgid ""
"If a name is bound in a block, it is a local variable of that block, "
"unless declared as :keyword:`nonlocal` or :keyword:`global`.  If a name "
"is bound at the module level, it is a global variable.  (The variables of"
" the module code block are local and global.)  If a variable is used in a"
" code block but not defined there, it is a :dfn:`free variable`."
msgstr ""
"만약 이름이 블록 내에서 연결되면, :keyword:`nonlocal` 이나 :keyword:`global` 로 "
"선언되지 않는 이상, 그 블록의 지역 변수다. 만약 이름이 모듈 수준에서 연결되면, 전역 변수다. "
"(모듈 코드 블록의 변수들 지역이면서 전역이다.) 만약 변수가 코드 블록에서 사용되지만, 거기에서 "
"정의되지 않았으면 :dfn:`자유 변수 (free variable)` 다."

#: ../Doc/reference/executionmodel.rst:81
msgid ""
"Each occurrence of a name in the program text refers to the "
":dfn:`binding` of that name established by the following name resolution "
"rules."
msgstr ""
"프로그램 텍스트에 등장하는 각각의 이름들은 다음에 나오는 이름 검색(name resolution) 규칙에 "
"따라 확정되는 이름의 :dfn:`연결 (binding)` 을 가리킨다."

#: ../Doc/reference/executionmodel.rst:87
msgid "Resolution of names"
msgstr "이름의 검색(resolution)"

#: ../Doc/reference/executionmodel.rst:91
msgid ""
"A :dfn:`scope` defines the visibility of a name within a block.  If a "
"local variable is defined in a block, its scope includes that block.  If "
"the definition occurs in a function block, the scope extends to any "
"blocks contained within the defining one, unless a contained block "
"introduces a different binding for the name."
msgstr ""
":dfn:`스코프 (scope)` 는 블록 내에서 이름의 가시성(visibility)을 정의한다. 지역 변수가 "
"블록에서 정의되면, 그것의 스코프는 그 블록을 포함한다. 만약 정의가 함수 블록에서 이루어지면, "
"포함된 블록이 그 이름에 대해 다른 결합을 만들지 않는 이상, 스코프는 정의하고 있는 것 안에 포함된 "
"모든 블록으로 확대된다."

#: ../Doc/reference/executionmodel.rst:99
msgid ""
"When a name is used in a code block, it is resolved using the nearest "
"enclosing scope.  The set of all such scopes visible to a code block is "
"called the block's :dfn:`environment`."
msgstr ""
"이름이 코드 블록 내에서 사용될 때, 가장 가깝게 둘러싸고 있는 스코프에 있는 것으로 검색된다. 코드 "
"블록이 볼 수 있는 모든 스코프의 집합을 블록의 :dfn:`환경 (environment)` 이라고 부른다."

#: ../Doc/reference/executionmodel.rst:107
msgid ""
"When a name is not found at all, a :exc:`NameError` exception is raised. "
"If the current scope is a function scope, and the name refers to a local "
"variable that has not yet been bound to a value at the point where the "
"name is used, an :exc:`UnboundLocalError` exception is raised. "
":exc:`UnboundLocalError` is a subclass of :exc:`NameError`."
msgstr ""
"이름이 어디에서도 발견되지 않으면 :exc:`NameError` 예외가 발생한다. 만약 현재 스코프가 함수 "
"스코프이고, 그 이름이 사용되는 시점에 아직 연결되지 않은 지역 변수면 "
":exc:`UnboundLocalError` 예외가 발생한다. :exc:`UnboundLocalError` 는 "
":exc:`NameError` 의 서브 클래스다."

#: ../Doc/reference/executionmodel.rst:113
msgid ""
"If a name binding operation occurs anywhere within a code block, all uses"
" of the name within the block are treated as references to the current "
"block.  This can lead to errors when a name is used within a block before"
" it is bound.  This rule is subtle.  Python lacks declarations and allows"
" name binding operations to occur anywhere within a code block.  The "
"local variables of a code block can be determined by scanning the entire "
"text of the block for name binding operations."
msgstr ""
"만약 이름 연결 연산이 코드 블록 내의 어디에서 건 일어난다면, 그 블록 내에서 그 이름의 모든 "
"사용은 현재 블록을 가리키는 것으로 취급된다. 이것은 연결되기 전에 블록에서 사용될 때 에러로 "
"이어질 수 있다. 이 규칙은 미묘하다. 파이썬에는 선언(declaration)이 없고, 이름 연결 연산이 "
"코드 블록 내의 어디에서나 일어날 수 있도록 허락한다. 코드 블록의 지역 변수는 블록의 텍스트 "
"전체에서 이름 연결 연산을 찾아야 결정될 수 있다."

#: ../Doc/reference/executionmodel.rst:120
msgid ""
"If the :keyword:`global` statement occurs within a block, all uses of the"
" name specified in the statement refer to the binding of that name in the"
" top-level namespace.  Names are resolved in the top-level namespace by "
"searching the global namespace, i.e. the namespace of the module "
"containing the code block, and the builtins namespace, the namespace of "
"the module :mod:`builtins`.  The global namespace is searched first.  If "
"the name is not found there, the builtins namespace is searched.  The "
":keyword:`global` statement must precede all uses of the name."
msgstr ""
"만약 :keyword:`global` 문이 블록 내에서 나오면, 문장에서 지정한 이름의 모든 사용은 최상위 "
"이름 공간(top-level namespace)에 연결된 것을 가리키게 된다. 최상위 이름 공간에서 이름을 "
"검색한다는 것은, 전역 이름 공간, 즉 코드 블록을 포함하는 모듈의 이름 공간, 과 내장 이름 공간, 모듈 "
":mod:`builtins` 의 이름 공간, 을 검색한다는 뜻이다. 전역 이름 공간이 먼저 검색된다. 거기에서 "
"이름이 발견되지 않으면, 내장 이름 공간을 검색한다. :keyword:`global` 문은 그 이름을 "
"사용하기 전에 나와야 한다."

#: ../Doc/reference/executionmodel.rst:129
msgid ""
"The :keyword:`global` statement has the same scope as a name binding "
"operation in the same block.  If the nearest enclosing scope for a free "
"variable contains a global statement, the free variable is treated as a "
"global."
msgstr ""
":keyword:`global` 문은 같은 블록의 이름 연결 연산과 같은 스코프를 갖는다. 자유 변수의 "
"경우 가장 가까이서 둘러싸는 스코프가 global 문을 포함한다면, 그 자유 변수는 전역으로 취급된다."

#: ../Doc/reference/executionmodel.rst:135
msgid ""
"The :keyword:`nonlocal` statement causes corresponding names to refer to "
"previously bound variables in the nearest enclosing function scope. "
":exc:`SyntaxError` is raised at compile time if the given name does not "
"exist in any enclosing function scope."
msgstr ""
":keyword:`nonlocal` 문은 대응하는 이름이 가장 가까이서 둘러싸는 함수 스코프에서 이미 연결된 "
"이름을 가리키도록 만든다. 만약 주어진 이름이 둘러싸는 함수 스코프 어디에도 없다면 컴파일 시점에 "
":exc:`SyntaxError` 를 일으킨다."

#: ../Doc/reference/executionmodel.rst:142
msgid ""
"The namespace for a module is automatically created the first time a "
"module is imported.  The main module for a script is always called "
":mod:`__main__`."
msgstr ""
"모듈의 이름 공간은 모듈이 처음 임포트될 때 자동으로 만들어진다. 스크립트의 메인 모듈은 항상 "
":mod:`__main__` 이라고 불린다."

#: ../Doc/reference/executionmodel.rst:145
msgid ""
"Class definition blocks and arguments to :func:`exec` and :func:`eval` "
"are special in the context of name resolution. A class definition is an "
"executable statement that may use and define names. These references "
"follow the normal rules for name resolution with an exception that "
"unbound local variables are looked up in the global namespace. The "
"namespace of the class definition becomes the attribute dictionary of the"
" class. The scope of names defined in a class block is limited to the "
"class block; it does not extend to the code blocks of methods -- this "
"includes comprehensions and generator expressions since they are "
"implemented using a function scope.  This means that the following will "
"fail::"
msgstr ""
"클래스 정의 블록과 :func:`exec` 와 :func:`eval` 로 전달되는 인자는 특별한 이름 검색 "
"문맥을 갖는다. 클래스 정의는 이름을 사용하고 정의할 수 있는 실행 가능한 문장이다. 이 참조들은 "
"연결되지 않은 지역 변수를 전역 이름 공간에서 찾는다는 점을 제외하고는 이름 검색의 일반적인 규칙을 "
"따른다. 클래스 정의의 이름 공간은 클래스의 어트리뷰트 딕셔너리가 된다. 클래스 블록에서 정의된 "
"이름들의 스코프는 클래스 블록으로 제한된다; 메서드들의 코드 블록으로 확대되지 않는다 -- 이것은 "
"컴프리헨션과 제너레이터 표현을 포함하는데 이것들이 함수 스코프를 사용해서 구현되기 때문이다. 이"
"것은 다음과 같은 것이 실패한다는 뜻이다::"

#: ../Doc/reference/executionmodel.rst:163
msgid "Builtins and restricted execution"
msgstr "builtins 와 제한된 실행"

#: ../Doc/reference/executionmodel.rst:169
msgid ""
"Users should not touch ``__builtins__``; it is strictly an implementation"
" detail.  Users wanting to override values in the builtins namespace "
"should :keyword:`import` the :mod:`builtins` module and modify its "
"attributes appropriately."
msgstr ""
"사용자는 ``__builtins__`` 를 건드리지 말아야 한다; 이것은 구현 세부사항이다. 내장 "
"이름 공간의 값을 변경하고 싶은 사용자는 :mod:`builtins` 모듈을 :keyword:`import` 하고 "
"그것의 어트리뷰트를 적절하게 수정해야 한다."

#: ../Doc/reference/executionmodel.rst:174
msgid ""
"The builtins namespace associated with the execution of a code block is "
"actually found by looking up the name ``__builtins__`` in its global "
"namespace; this should be a dictionary or a module (in the latter case "
"the module's dictionary is used).  By default, when in the "
":mod:`__main__` module, ``__builtins__`` is the built-in module "
":mod:`builtins`; when in any other module, ``__builtins__`` is an alias "
"for the dictionary of the :mod:`builtins` module itself."
msgstr ""
"코드 블록의 실행과 연관된 내장 이름 공간은, 사실 전역 이름 공간의 이름 ``__builtins__`` 를 "
"조회함으로써 발견된다. 이것은 딕셔너리나 모듈이어야 한다(후자의 경우 모듈의 딕셔너리가 "
"사용된다). 기본적으로, :mod:`__main__` 모듈에 있을 때는 ``__builtins__`` 가 내장 모듈 "
":mod:`builtins` 이고, 다른 모듈에 있을 때는 ``__builtins__`` 는 :mod:`builtins` "
"모듈의 딕셔너리에 대한 별칭이다."

#: ../Doc/reference/executionmodel.rst:186
msgid "Interaction with dynamic features"
msgstr "동적 기능과의 상호작용"

#: ../Doc/reference/executionmodel.rst:188
msgid ""
"Name resolution of free variables occurs at runtime, not at compile time."
" This means that the following code will print 42::"
msgstr ""
"자유 변수에 대해 이름 검색은 컴파일 시점이 아니라 실행 시점에 이루어진다. 이것은 다음과 같은 "
"코드가 42를 출력한다는 것을 뜻한다:"

#: ../Doc/reference/executionmodel.rst:199
msgid ""
"The :func:`eval` and :func:`exec` functions do not have access to the "
"full environment for resolving names.  Names may be resolved in the local"
" and global namespaces of the caller.  Free variables are not resolved in"
" the nearest enclosing namespace, but in the global namespace.  [#]_ The "
":func:`exec` and :func:`eval` functions have optional arguments to "
"override the global and local namespace.  If only one namespace is "
"specified, it is used for both."
msgstr ""
":func:`eval` 과 :func:`exec` 함수는 이름 검색을 위한 완전한 환경에 대한 접근권이 없다. "
"이름은 호출자의 지역과 전역 이름 공간에서 검색될 수 있다. 자유 변수는 가장 가까이 둘러싼 "
"이름 공간이 아니라 전역 이름 공간에서 검색된다. [#]_ :func:`exec` 과 :func:`eval` "
"함수에는 전역과 지역 이름 공간을 재정의할 수 있는 생략 가능한 인자가 있다. 만약 단지 한 "
"이름 공간만 주어지면, 그것이 두 가지 모두로 사용된다."

#: ../Doc/reference/executionmodel.rst:210
msgid "Exceptions"
msgstr "예외"

#: ../Doc/reference/executionmodel.rst:221
msgid ""
"Exceptions are a means of breaking out of the normal flow of control of a"
" code block in order to handle errors or other exceptional conditions.  "
"An exception is *raised* at the point where the error is detected; it may"
" be *handled* by the surrounding code block or by any code block that "
"directly or indirectly invoked the code block where the error occurred."
msgstr ""
"예외는 에러나 예외적인 조건을 처리하기 위해 코드 블록의 일반적인 제어 흐름을 깨는 수단이다. "
"에러가 감지된 지점에서 예외를 *일으킨다(raised)*; 둘러싼 코드 블록이나 직접적 혹은 간접적으로 "
"에러가 발생한 코드 블록을 호출한 어떤 코드 블록에서건 예외는 처리될 수 있다."

#: ../Doc/reference/executionmodel.rst:227
msgid ""
"The Python interpreter raises an exception when it detects a run-time "
"error (such as division by zero).  A Python program can also explicitly "
"raise an exception with the :keyword:`raise` statement. Exception "
"handlers are specified with the :keyword:`try` ... :keyword:`except` "
"statement.  The :keyword:`finally` clause of such a statement can be used"
" to specify cleanup code which does not handle the exception, but is "
"executed whether an exception occurred or not in the preceding code."
msgstr ""
"파이썬 인터프리터는 실행 시간 에러(0으로 나누는 것 같은)를 감지할 때 예외를 일으킨다. 파이썬 "
"프로그램은 :keyword:`raise` 문을 사용해서 명시적으로 예외를 일으킬 수 있다. 예외 처리기는 "
":keyword:`try` ... :keyword:`except` 문으로 지정된다. 그런 문장에서 "
":keyword:`finally` 구는 정리(cleanup) 코드를 지정하는 데 사용되는데, 예외를 처리하는 "
"것이 아니라 앞선 코드에서 예외가 발생하건 그렇지 않건 실행된다. "

#: ../Doc/reference/executionmodel.rst:237
msgid ""
"Python uses the \"termination\" model of error handling: an exception "
"handler can find out what happened and continue execution at an outer "
"level, but it cannot repair the cause of the error and retry the failing "
"operation (except by re-entering the offending piece of code from the "
"top)."
msgstr ""
"파이썬은 에러 처리에 \"종결 (termination)\" 모델을 사용한다; 예외 처리기가 뭐가 발생했는지 "
"발견할 수 있고, 바깥 단계에서 실행을 계속할 수는 있지만, 에러의 원인을 제거한 후에 실패한 "
"연산을 재시도할 수는 없다(문제의 코드 조각을 처음부터 다시 시작시키는 것은 예외다)."

#: ../Doc/reference/executionmodel.rst:244
msgid ""
"When an exception is not handled at all, the interpreter terminates "
"execution of the program, or returns to its interactive main loop.  In "
"either case, it prints a stack backtrace, except when the exception is "
":exc:`SystemExit`."
msgstr ""
"예외가 어디서도 처리되지 않을 때, 인터프리터는 프로그램의 실행을 종료하거나, 대화형 메인 루프로 "
"돌아간다. 두 경우 모두, 예외가 :exc:`SystemExit` 인 경우를 제외하고, 스택 트레이스를 "
"인쇄한다."

#: ../Doc/reference/executionmodel.rst:248
msgid ""
"Exceptions are identified by class instances.  The :keyword:`except` "
"clause is selected depending on the class of the instance: it must "
"reference the class of the instance or a base class thereof.  The "
"instance can be received by the handler and can carry additional "
"information about the exceptional condition."
msgstr ""
"예외는 클래스 인스턴스로 구분된다. :keyword:`except` 절은 인스턴스의 클래스에 따라 "
"선택된다: 인스턴스의 클래스나 그것의 베이스 클래스를 가리켜야 한다. 인스턴스는 핸들러가 수신할 "
"수 있고 예외적인 조건에 대한 추가적인 정보를 포함할 수 있다."

#: ../Doc/reference/executionmodel.rst:255
msgid ""
"Exception messages are not part of the Python API.  Their contents may "
"change from one version of Python to the next without warning and should "
"not be relied on by code which will run under multiple versions of the "
"interpreter."
msgstr ""
"예외 메시지는 파이썬 API 일부가 아니다. 그 내용은 파이썬의 버전이 바뀔 때 경고 없이 변경될 "
"수 있고, 코드는 여러 버전의 인터프리터에서 실행될 수 있는 코드는 이것에 의존하지 말아야 한다."

#: ../Doc/reference/executionmodel.rst:259
msgid ""
"See also the description of the :keyword:`try` statement in section "
":ref:`try` and :keyword:`raise` statement in section :ref:`raise`."
msgstr ""
"섹션 :ref:`try` 에서 :keyword:`try` 문, :ref:`raise` 에서 :keyword:`raise` "
"문에 대한 설명이 제공된다."

#: ../Doc/reference/executionmodel.rst:264
msgid "Footnotes"
msgstr "각주"

#: ../Doc/reference/executionmodel.rst:265
msgid ""
"This limitation occurs because the code that is executed by these "
"operations is not available at the time the module is compiled."
msgstr ""
"이 한계는 이 연산들 때문에 실행되는 코드가 모듈이 컴파일되는 시점에는 존재하지 않았기 때문이다."

