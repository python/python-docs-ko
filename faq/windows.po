# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-25 10:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Kang-min Kim <kokomong0831@naver.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/faq/windows.rst:9
msgid "Python on Windows FAQ"
msgstr "윈도우 파이썬 FAQ"

#: ../Doc/faq/windows.rst:12
msgid "Contents"
msgstr "목차"

#: ../Doc/faq/windows.rst:20
msgid "How do I run a Python program under Windows?"
msgstr "윈도우에서 파이썬 프로그램을 실행하려면 어떻게 해야 합니까?"

#: ../Doc/faq/windows.rst:22
msgid ""
"This is not necessarily a straightforward question. If you are already "
"familiar with running programs from the Windows command line then "
"everything will seem obvious; otherwise, you might need a little more "
"guidance."
msgstr ""
"이 질문은 명확한 질문이 아닙니다. 이미 윈도우 명령 줄에서 프로그램을 실행하는 것에 익숙 하다면 이 모든 것이 분명할 것입니다. "
"그렇지 않으면, 좀 더 지침이 필요할 수 있습니다."

#: ../Doc/faq/windows.rst:26
msgid ""
"Unless you use some sort of integrated development environment, you will "
"end up *typing* Windows commands into what is variously referred to as a "
"\"DOS window\" or \"Command prompt window\".  Usually you can create such"
" a window from your search bar by searching for ``cmd``.  You should be "
"able to recognize when you have started such a window because you will "
"see a Windows \"command prompt\", which usually looks like this:"
msgstr ""
"당신이 어떤 통합 개발 한경을 쓰지 않는 이상, 결국 \"DOS 창\" 또는 \"명령 프롬프트 창\"이라 불리는 것에 윈도우 "
"명령어를 *입력* 할 것 입니다. 보통 윈도우 검색 창에서 ``cmd`` 를 입력하여 이 창을 띄울 수 있습니다. 일반적으로 다음과"
" 같은 윈도우의 \"명령 프롬프트\"가 표시되기 때문에 이러한 창이 언제 시작했는지 인지할 수 있어야 합니다:"

#: ../Doc/faq/windows.rst:37
msgid ""
"The letter may be different, and there might be other things after it, so"
" you might just as easily see something like:"
msgstr "아마 글자가 다르고, 그 뒤에 다른 것들이 있을 수 있습니다. 그러므로 다음과 같은 것을 쉽게 볼 수 있습니다:"

#: ../Doc/faq/windows.rst:44
msgid ""
"depending on how your computer has been set up and what else you have "
"recently done with it.  Once you have started such a window, you are well"
" on the way to running Python programs."
msgstr "컴퓨터 설정 방법과 최근에 끝낸 그 밖의 것에 의존적입니다. 일단 이런 창을 시작했다면, 파이썬 프로그램 실행할 준비가 되었습니다."

#: ../Doc/faq/windows.rst:48
msgid ""
"You need to realize that your Python scripts have to be processed by "
"another program called the Python *interpreter*.  The interpreter reads "
"your script, compiles it into bytecodes, and then executes the bytecodes "
"to run your program. So, how do you arrange for the interpreter to handle"
" your Python?"
msgstr ""
"파이썬 스크립트는 파이썬 *인터프리터* 라는 다른 프로그램에서 관리할 필요가 있다는 것을 알고 있어야 합니다. 인터프리터는 "
"스크립트를 읽고, 바이트 코드로 컴파일하고, 바이트 코드를 실행하여 프로그램을 구동합니다. 그렇다면, 인터프리터를 통해 파이썬을 "
"관리하려면 어떻게 준비해야 하겠습니까?"

#: ../Doc/faq/windows.rst:53
msgid ""
"First, you need to make sure that your command window recognises the word"
" \"py\" as an instruction to start the interpreter.  If you have opened a"
" command window, you should try entering the command ``py`` and hitting "
"return:"
msgstr ""
"먼저, 명령 창이 \"py\"라는 단어를 해석기를 시작하는 지시로 인식하는지 확인해야합니다. 명령 창을 열고 있으면, 명령 "
"``py`` 를 입력하고 return 키를 눌러야 합니다:"

#: ../Doc/faq/windows.rst:62
msgid "You should then see something like:"
msgstr "다음과 같이 표시됩니다:"

#: ../Doc/faq/windows.rst:70
msgid ""
"You have started the interpreter in \"interactive mode\". That means you "
"can enter Python statements or expressions interactively and have them "
"executed or evaluated while you wait.  This is one of Python's strongest "
"features.  Check it by entering a few expressions of your choice and "
"seeing the results:"
msgstr ""
"인터프리터를 \"대화형 모드\"로 시작했습니다. 즉, 파이썬 문장이나 표현식을 대화식으로 입력하여 대기하는 중에 실행 혹은 평가시킬"
" 수 있습니다. 이것은 파이썬의 가장 강력한 기능 중 하나입니다. 선택한 몇 가지 수식을 입력하여 확인하고 그 결과를 확인하십시오:"

#: ../Doc/faq/windows.rst:82
msgid ""
"Many people use the interactive mode as a convenient yet highly "
"programmable calculator.  When you want to end your interactive Python "
"session, call the :func:`exit` function or hold the :kbd:`Ctrl` key down "
"while you enter a :kbd:`Z`, then hit the \":kbd:`Enter`\" key to get back"
" to your Windows command prompt."
msgstr ""
"많은 사람이 대화형 모드를 편리하면서도 프로그래밍이 가능한 계산기로 사용합니다. 대화형 파이썬 세션을 종료하려면, "
":func:`exit` 함수를 호출하거나 :kbd:`Z` 를 입력하면서 :kbd:`Ctrl` 키를 누르고 "
"나서\":kbd:`Enter`\" 키를 눌러 윈도우 명령 프롬프트로 돌아갑니다."

#: ../Doc/faq/windows.rst:88
msgid ""
"You may also find that you have a Start-menu entry such as "
":menuselection:`Start --> Programs --> Python 3.x --> Python (command "
"line)` that results in you seeing the ``>>>`` prompt in a new window.  If"
" so, the window will disappear after you call the :func:`exit` function "
"or enter the :kbd:`Ctrl-Z` character; Windows is running a single "
"\"python\" command in the window, and closes it when you terminate the "
"interpreter."
msgstr ""
"또한, :menuselection:`시작 --> 프로그램 --> Python 3.x --> Python(명령 줄)` 메뉴 선택과 "
"같은 시작 메뉴 항목을 찾아볼 수 있으며, 그 결과 새 창에서 ``>>>`` 프롬프트를 볼 수 있습니다. 이 경우, "
":func:`exit` 함수를 호출하거나 :kbd:`Ctrl-Z` 를 입력하면 창이 사라집니다. 윈도우에서 단일 \"python\""
" 명령을 실행하는 중이고, 인터프리터를 종료하면 창을 닫습니다."

#: ../Doc/faq/windows.rst:95
msgid ""
"Now that we know the ``py`` command is recognized, you can give your "
"Python script to it. You'll have to give either an absolute or a relative"
" path to the Python script. Let's say your Python script is located in "
"your desktop and is named ``hello.py``, and your command prompt is nicely"
" opened in your home directory so you're seeing something similar to::"
msgstr ""
"이제 ``py`` 명령이 인식되었으므로, 당신은 당신의 파이썬 스크립트를 줄 수 있습니다. 파이썬 스크립트에 절대 경로나 상대 "
"경로를 지정해야 할 것입니다. 당신의 파이썬 스크립트가 ``hello.py`` 라는 이름으로 당신의 데스크톱에 위치한다고 하면, "
"명령 프롬프트가 홈 디렉토리에 잘 열려있으므로 다음과 같이 내용이 표시됩니다::"

#: ../Doc/faq/windows.rst:104
msgid ""
"So now you'll ask the ``py`` command to give your script to Python by "
"typing ``py`` followed by your script path::"
msgstr "그래서 이제 스크립트 경로 뒤에 ``py`` 를 입력하여 파이썬 스크립트를 제공하기 위해 ``py`` 명령을 요청할 것입니다::"

#: ../Doc/faq/windows.rst:112
msgid "How do I make Python scripts executable?"
msgstr "파이썬 스크립트 실행 파일을 만드려면 어떻게 해야 합니까?"

#: ../Doc/faq/windows.rst:114
#, qt-format
msgid ""
"On Windows, the standard Python installer already associates the .py "
"extension with a file type (Python.File) and gives that file type an open"
" command that runs the interpreter (``D:\\Program "
"Files\\Python\\python.exe \"%1\" %*``).  This is enough to make scripts "
"executable from the command prompt as 'foo.py'.  If you'd rather be able "
"to execute the script by simple typing 'foo' with no extension you need "
"to add .py to the PATHEXT environment variable."
msgstr ""
"윈도우에서 표준 파이썬 설치관리자는 이미 .py 확장을 파일 유형(Python.File)과 연결했고, (``D:\\Program "
"Files\\Python\\python.exe \"%1\" %*``) 인터프리터를 실행하는 열린 명령의 파일 유형을 제공합니다. "
"이것은 명령 프롬프트에서 'foo.py' 과 같은 스크립트 실행파일을 만들기에 충분합니다. 확장자명 없이 'foo' 를 입력하여 "
"스크립트를 실행하려면 PATHEXT 환경 변수에 .py를 추가해야 합니다."

#: ../Doc/faq/windows.rst:122
msgid "Why does Python sometimes take so long to start?"
msgstr "왜 때때로 파이썬은 시작하는 데 시간이 오래 걸립니까?"

#: ../Doc/faq/windows.rst:124
msgid ""
"Usually Python starts very quickly on Windows, but occasionally there are"
" bug reports that Python suddenly begins to take a long time to start up."
"  This is made even more puzzling because Python will work fine on other "
"Windows systems which appear to be configured identically."
msgstr ""
"일반적으로 파이썬은 윈도우에서 매우 빠르게 시작되지만, 때때로 파이썬을 시작하는 데 갑자기 오랜 시간이 걸린다는 버그 보고서가 "
"있습니다. 이러한 것은 파이썬이 동일하게 구성된 것으로 보이는 다른 윈도우 시스템에서 잘 작동하기 때문에 더욱 더 곤혹스럽게 "
"만듭니다."

#: ../Doc/faq/windows.rst:129
msgid ""
"The problem may be caused by a misconfiguration of virus checking "
"software on the problem machine.  Some virus scanners have been known to "
"introduce startup overhead of two orders of magnitude when the scanner is"
" configured to monitor all reads from the filesystem.  Try checking the "
"configuration of virus scanning software on your systems to ensure that "
"they are indeed configured identically. McAfee, when configured to scan "
"all file system read activity, is a particular offender."
msgstr ""
"이 문제는 해당 컴퓨터의 바이러스 검사 소프트웨어의 잘못된 설정으로 발생하는 것일 수 있습니다. 일부 바이러스 스캐너는 파일 "
"시스템으로부터 읽은 모든 것을 모니터링하도록 스캐너를 구성할 때 두 가지 크기의 시동 오버헤드를 도입하는 것으로 알려져 있습니다. "
"시스템에서 바이러스 검사 소프트웨어의 구성을 확인하여 실제로 동일하게 구성되었는지 확인하십시오. McAfee는 모든 파일 시스템 "
"읽기 작업을 검색하도록 구성된 경우에 특정 위반자입니다."

#: ../Doc/faq/windows.rst:139
msgid "How do I make an executable from a Python script?"
msgstr "파이썬 스크립트에서 실행 파일을 만드는 방법은 무엇입니까?"

#: ../Doc/faq/windows.rst:141
msgid ""
"See `cx_Freeze <https://anthony-tuininga.github.io/cx_Freeze/>`_ for a "
"distutils extension that allows you to create console and GUI executables"
" from Python code. `py2exe <http://www.py2exe.org/>`_, the most popular "
"extension for building Python 2.x-based executables, does not yet support"
" Python 3 but a version that does is in development."
msgstr ""
"파이썬 코드에서 콘솔 및 GUI 실행 파일을 만들 수 있는 distutils 확장을 위해 `cx_Freeze <https"
"://anthony-tuininga.github.io/cx_Freeze/>`_ 를 참고하시면 됩니다. Python 2.x 기반 실행"
" 파일을 만드는 데 가장 인기 있는 확장자인 `py2exe <http://www.py2exe.org/>`_ 는 아직 Python "
"3을 지원하지 않고, 개발 중인 버전입니다."

#: ../Doc/faq/windows.rst:149
msgid "Is a ``*.pyd`` file the same as a DLL?"
msgstr "``*.pyd`` 파일은 DLL과 동일합니까?"

#: ../Doc/faq/windows.rst:151
msgid ""
"Yes, .pyd files are dll's, but there are a few differences.  If you have "
"a DLL named ``foo.pyd``, then it must have a function ``PyInit_foo()``.  "
"You can then write Python \"import foo\", and Python will search for "
"foo.pyd (as well as foo.py, foo.pyc) and if it finds it, will attempt to "
"call ``PyInit_foo()`` to initialize it.  You do not link your .exe with "
"foo.lib, as that would cause Windows to require the DLL to be present."
msgstr ""
"예, .pyd 파일은 dll 이지만, 몇 가지 차이점이 있습니다. 만약 당신이 ``foo.pyd`` 라는 이름의 DLL을 가지고 "
"있다면, ``PyInit_foo()`` 함수를 반드시 가지고 있어야 합니다. 당신은 파이썬 \"import foo\"를 쓸 수 "
"있으며, 파이썬은 (foo.py, foo.pyc 뿐만 아니라) foo.pyd 를 검색할 것이고, 이를 발견하면 초기화하기 위해 "
"``PyInit_foo()`` 호출을 시도할 것입니다. 윈도우에서 DLL 의 존재를 요구하기 때문에 .exe를 foo.lib와 "
"연결하면 안 됩니다."

#: ../Doc/faq/windows.rst:158
msgid ""
"Note that the search path for foo.pyd is PYTHONPATH, not the same as the "
"path that Windows uses to search for foo.dll.  Also, foo.pyd need not be "
"present to run your program, whereas if you linked your program with a "
"dll, the dll is required.  Of course, foo.pyd is required if you want to "
"say ``import foo``.  In a DLL, linkage is declared in the source code "
"with ``__declspec(dllexport)``. In a .pyd, linkage is defined in a list "
"of available functions."
msgstr ""
"foo.pyd에 대한 검색 경로는 윈도우에서 foo.dll을 검색하는 데 사용하는 경로가 아닌 PYTHONPATH임을 유의하십시오."
" 또한, 프로그램을 실행하기 위해 foo.pyd가 있을 필요는 없지만, 프로그램을 dll과 연결한 경우에는 dll이 필요합니다. "
"물론, ``import foo`` 를 하기 위해서는 foo.pyd가 필요합니다. DLL에서 링키지는 소스 코드에서 "
"``__declspec(dllexport)`` 로 선언됩니다. .pyd에서 링키지는 사용 가능한 함수 목록에 정의됩니다."

#: ../Doc/faq/windows.rst:167
msgid "How can I embed Python into a Windows application?"
msgstr "윈도우 응용프로그램에 파이썬을 포함하려면 어떻게 해야 합니까?"

#: ../Doc/faq/windows.rst:169
msgid ""
"Embedding the Python interpreter in a Windows app can be summarized as "
"follows:"
msgstr "윈도우 앱에서 파이썬 인터프리터를 포함하려면 다음과 같이 요약할 수 있습니다:"

#: ../Doc/faq/windows.rst:171
msgid ""
"Do _not_ build Python into your .exe file directly.  On Windows, Python "
"must be a DLL to handle importing modules that are themselves DLL's.  "
"(This is the first key undocumented fact.)  Instead, link to "
":file:`python{NN}.dll`; it is typically installed in "
"``C:\\Windows\\System``.  *NN* is the Python version, a number such as "
"\"33\" for Python 3.3."
msgstr ""
".exe 파일에 직접 파이썬을 빌드하면 안 됩니다. 윈도우에서 파이썬은 DLL 자체인 모듈 가져오기를 처리하기 위한 DLL이어야 "
"합니다. (이것이 문서화되지 않은 첫 번째 사실입니다) 대신에, :file:`python{NN}.dll` 에 연결하면 됩니다. "
"일반적으로 ``C:\\Windows\\System`` 에 설치됩니다. *NN*\\은 파이썬 버전이고, Python 3.3의 경우 "
"\"33\"과 같은 숫자입니다."

#: ../Doc/faq/windows.rst:177
msgid ""
"You can link to Python in two different ways.  Load-time linking means "
"linking against :file:`python{NN}.lib`, while run-time linking means "
"linking against :file:`python{NN}.dll`.  (General note: "
":file:`python{NN}.lib` is the so-called \"import lib\" corresponding to "
":file:`python{NN}.dll`.  It merely defines symbols for the linker.)"
msgstr ""
"두 가지 방법으로 파이썬에 연결할 수 있습니다. 로드 타임 링크는 :file:`python{NN}.lib` 에 대한 링크를 "
"의미하고, 런타임 링크는 :file:`python{NN}.dll` 에 대한 링크를 의미합니다. (일반 참고: "
":file:`python{NN}.lib` 는 :file:`python{NN}.dll` 에 해당하는 소위 \"import "
"lib\"입니다. 오직 링커의 기호만 정의합니다)"

#: ../Doc/faq/windows.rst:183
msgid ""
"Run-time linking greatly simplifies link options; everything happens at "
"run time.  Your code must load :file:`python{NN}.dll` using the Windows "
"``LoadLibraryEx()`` routine.  The code must also use access routines and "
"data in :file:`python{NN}.dll` (that is, Python's C API's) using pointers"
" obtained by the Windows ``GetProcAddress()`` routine.  Macros can make "
"using these pointers transparent to any C code that calls routines in "
"Python's C API."
msgstr ""
"런타임 연결은 링크 옵션을 크게 단순화합니다. 모든 것은 런타임 중에 발생합니다. 당신의 코드는 윈도우 "
"``LoadLibraryEx()`` 루틴을 사용하여 :file:`python{NN}.dll` 을 로드해야 합니다. 그 코드는 윈도우"
" ``GetProcAddress()`` 루틴에서 얻은 포인터를 사용하여 :file:`python{NN}.dll` (파이썬의 C "
"API)의 엑세스 루틴 및 데이터를 사용해야 합니다. 매크로는 이러한 포인터를 파이썬 C API에서 루틴을 호출하는 모든 C 코드에"
" 투명하게 사용할 수 있습니다."

#: ../Doc/faq/windows.rst:190
msgid ""
"Borland note: convert :file:`python{NN}.lib` to OMF format using "
"Coff2Omf.exe first."
msgstr ""
"Borland 참고 : 먼저 Coff2Omf.exe를 사용하여 :file:`python{NN}.lib` 를 OMF 형식으로 "
"변환합니다."

#: ../Doc/faq/windows.rst:195
msgid ""
"If you use SWIG, it is easy to create a Python \"extension module\" that "
"will make the app's data and methods available to Python.  SWIG will "
"handle just about all the grungy details for you.  The result is C code "
"that you link *into* your .exe file (!)  You do _not_ have to create a "
"DLL file, and this also simplifies linking."
msgstr ""
"SWIG를 사용할 경우, 파이썬 \"확장 모듈\"을 생성하여 앱의 데이터와 방법을 파이썬에서 사용할 수 있게 합니다. SWIG는 "
"당신을 위해 모든 성가신 세부사항들을 처리할 것입니다. 그 결과로 .exe 파일(!)에 연결하는 C 코드가 생성되며 DLL 파일을 "
"생성해야 하며, 이를 통해 연결도 간단해집니다."

#: ../Doc/faq/windows.rst:201
msgid ""
"SWIG will create an init function (a C function) whose name depends on "
"the name of the extension module.  For example, if the name of the module"
" is leo, the init function will be called initleo().  If you use SWIG "
"shadow classes, as you should, the init function will be called "
"initleoc().  This initializes a mostly hidden helper class used by the "
"shadow class."
msgstr ""
"SWIG는 확장 모듈의 이름에 따라 이름이 달라지는 초기화 함수(C 함수)를 생성합니다. 예를 들어, 모듈의 이름이 leo인 경우,"
" 초기화 함수를 initleo()로 합니다. SWIG 섀도 클래스를 사용하면 initleoc()로 합니다. 이것은 섀도 클래스가 "
"사용하는 대부분 숨겨진 조력자 클래스를 초기화합니다."

#: ../Doc/faq/windows.rst:207
msgid ""
"The reason you can link the C code in step 2 into your .exe file is that "
"calling the initialization function is equivalent to importing the module"
" into Python! (This is the second key undocumented fact.)"
msgstr ""
"2단계에서 C 코드를 .exe 파일에 연결할 수 있는 이유는 초기화 함수를 호출하는 것이 모듈을 파이썬으로 가져오는 것과 동일하기 "
"때문입니다! (이것이 문서화되지 않은 두 번째 사실입니다)"

#: ../Doc/faq/windows.rst:211
msgid ""
"In short, you can use the following code to initialize the Python "
"interpreter with your extension module."
msgstr "간단히 말해서, 당신은 당신의 확장 모듈로 파이썬 인터프리터를 초기화하기 위해 다음 코드를 사용할 수 있습니다."

#: ../Doc/faq/windows.rst:222
msgid ""
"There are two problems with Python's C API which will become apparent if "
"you use a compiler other than MSVC, the compiler used to build "
"pythonNN.dll."
msgstr ""
"파이썬의 C API에는 두 가지 문제가 있는데, 이것은 당신이 PythonNN.dll을 만드는 데 사용되는 컴파일러인 MSVC "
"이외의 컴파일러를 사용하면 명백해집니다."

#: ../Doc/faq/windows.rst:225
msgid ""
"Problem 1: The so-called \"Very High Level\" functions that take FILE * "
"arguments will not work in a multi-compiler environment because each "
"compiler's notion of a struct FILE will be different.  From an "
"implementation standpoint these are very _low_ level functions."
msgstr ""
"문제 1: FILE * 인수를 취하는 소위 \"Very High Level\" 함수는 각 컴파일러의 구조체 FILE 개념이 다르기 "
"때문에 멀티 컴파일러 환경에서는 작동하지 않습니다. 구현 관점에서 볼 때 이들은 매우 _낮은_ 수준의 함수입니다."

#: ../Doc/faq/windows.rst:230
msgid ""
"Problem 2: SWIG generates the following code when generating wrappers to "
"void functions:"
msgstr "문제 2: 함수를 무효화하기 위해 래퍼를 생성할 때 SWIG는 다음과 같은 코드를 생성합니다:"

#: ../Doc/faq/windows.rst:239
msgid ""
"Alas, Py_None is a macro that expands to a reference to a complex data "
"structure called _Py_NoneStruct inside pythonNN.dll.  Again, this code "
"will fail in a mult-compiler environment.  Replace such code by:"
msgstr ""
"아아, Py_None은 pythonNN.dll 내부의 _Py_NoneStruct라는 복잡한 데이터 구조에 대한 참조로 확장되는 "
"매크로입니다. 다시 말하자면, 이 코드는 멀티 컴파일러 환경에서 실패할 것입니다. 다음과 같은 코드로 바꾸십시오:"

#: ../Doc/faq/windows.rst:247
msgid ""
"It may be possible to use SWIG's ``%typemap`` command to make the change "
"automatically, though I have not been able to get this to work (I'm a "
"complete SWIG newbie)."
msgstr ""
"저는 이것을 작동시키지는 못했지만, SWIG의 ``%typemap`` 명령을 사용하여 자동으로 변경하는 것이 가능할지도 "
"모릅니다(저는 완전 SWIG 초보자입니다)."

#: ../Doc/faq/windows.rst:251
msgid ""
"Using a Python shell script to put up a Python interpreter window from "
"inside your Windows app is not a good idea; the resulting window will be "
"independent of your app's windowing system.  Rather, you (or the "
"wxPythonWindow class) should create a \"native\" interpreter window.  It "
"is easy to connect that window to the Python interpreter.  You can "
"redirect Python's i/o to _any_ object that supports read and write, so "
"all you need is a Python object (defined in your extension module) that "
"contains read() and write() methods."
msgstr ""
"윈도우 앱 내부에서 파이썬 셸 스크립트를 사용하여 파이썬 인터프리터 창을 설치하는 것은 좋은 생각이 아닙니다. 결과 창은 앱의 창 "
"시스템과는 독립적일 것입니다. 오히려, 당신(또는 wxPythonWindow 클래스)은 \"native\" 인터프리터 창을 만들어야"
" 합니다. 이 창은 파이썬 인터프리터와 연결하기 쉽습니다. 당신은 파이썬의 i/o를 읽기 및 쓰기를 지원하는 _any_ 개체로 "
"리디렉션할 수 있으므로 read() 와 write() 메서드를 포함하는 파이썬 개체(확장 모듈에 정의됨)만 있으면 됩니다."

#: ../Doc/faq/windows.rst:260
msgid "How do I keep editors from inserting tabs into my Python source?"
msgstr "편집자가 내 파이썬 소스에 탭을 삽입하지 않도록 하려면 어떻게 해야 합니까?"

#: ../Doc/faq/windows.rst:262
msgid ""
"The FAQ does not recommend using tabs, and the Python style guide, "
":pep:`8`, recommends 4 spaces for distributed Python code; this is also "
"the Emacs python-mode default."
msgstr ""
"FAQ는 탭을 사용하는 것을 권장하지 않으며, 파이썬 스타일 안내서( :pep:`8` )는 분산된 파이썬 코드에 대해 4개의 공간을"
" 권장합니다. 이 또한 Emacs python-mode default입니다."

#: ../Doc/faq/windows.rst:266
msgid ""
"Under any editor, mixing tabs and spaces is a bad idea.  MSVC is no "
"different in this respect, and is easily configured to use spaces: Take "
":menuselection:`Tools --> Options --> Tabs`, and for file type "
"\"Default\" set \"Tab size\" and \"Indent size\" to 4, and select the "
"\"Insert spaces\" radio button."
msgstr ""
"편집기에서 탭과 공백을 혼합하는 것은 좋은 생각이 아닙니다. 이 점에서 MSVC는 다르지 않으며 공백을 사용하기 쉽게 구성됩니다: "
"다음 행동을 따라해보십시오 :menuselection:`Tools --> Options --> Tabs`, 그리고 파일 유형은 "
"\"\"Default\"로 하고 \"Tab size\"와 \"Indent size\"는 4로 설정하고, \"Insert "
"spaces\"를 라디오 버튼으로 선택합니다."

#: ../Doc/faq/windows.rst:271
msgid ""
"Python raises :exc:`IndentationError` or :exc:`TabError` if mixed tabs "
"and spaces are causing problems in leading whitespace. You may also run "
"the :mod:`tabnanny` module to check a directory tree in batch mode."
msgstr ""
"만일 혼합된 탭과 공백으로 인해 선행 백스페이스에 문제가 발생하는 경우, 파이썬이 :exc:`IndentationError` 나 "
":exc:`TabError` 를 발생시킵니다. 또한, :mod:`tabnanny` 모듈을 실행하여 배치 모드에서 디렉토리 트리를 "
"확인할 수도 있습니다."

#: ../Doc/faq/windows.rst:278
msgid "How do I check for a keypress without blocking?"
msgstr "블로킹 없이 키 입력을 확인하려면 어떻게 해야 합니까?"

#: ../Doc/faq/windows.rst:280
msgid ""
"Use the msvcrt module.  This is a standard Windows-specific extension "
"module. It defines a function ``kbhit()`` which checks whether a keyboard"
" hit is present, and ``getch()`` which gets one character without echoing"
" it."
msgstr ""
"msvcrt 모듈을 사용합니다. 이것은 표준 윈도우-특정 확장 모듈입니다. 이것은 키보드 히트가 존재하는지를 확인하는 "
"``kbhit()`` 와 에코 없이 문자를 얻는 ``getch()`` 를 정의합니다."

#~ msgid ""
#~ "Unless you use some sort of "
#~ "integrated development environment, you will"
#~ " end up *typing* Windows commands "
#~ "into what is variously referred to "
#~ "as a \"DOS window\" or \"Command "
#~ "prompt window\".  Usually you can create"
#~ " such a window from your Start "
#~ "menu; under Windows 7 the menu "
#~ "selection is :menuselection:`Start --> "
#~ "Programs --> Accessories --> Command "
#~ "Prompt`.  You should be able to "
#~ "recognize when you have started such "
#~ "a window because you will see a"
#~ " Windows \"command prompt\", which usually"
#~ " looks like this::"
#~ msgstr ""

#~ msgid ""
#~ "The letter may be different, and "
#~ "there might be other things after "
#~ "it, so you might just as easily"
#~ " see something like::"
#~ msgstr ""

#~ msgid ""
#~ "First, you need to make sure that"
#~ " your command window recognises the "
#~ "word \"python\" as an instruction to "
#~ "start the interpreter.  If you have "
#~ "opened a command window, you should "
#~ "try entering the command ``python`` and"
#~ " hitting return.::"
#~ msgstr ""

#~ msgid "You should then see something like::"
#~ msgstr ""

#~ msgid ""
#~ "You have started the interpreter in "
#~ "\"interactive mode\". That means you can"
#~ " enter Python statements or expressions "
#~ "interactively and have them executed or"
#~ " evaluated while you wait.  This is"
#~ " one of Python's strongest features.  "
#~ "Check it by entering a few "
#~ "expressions of your choice and seeing"
#~ " the results::"
#~ msgstr ""

#~ msgid ""
#~ "Prior to Python 2.7 and 3.2, to"
#~ " terminate a process, you can use "
#~ ":mod:`ctypes`::"
#~ msgstr ""

#~ msgid ""
#~ "See http://cx-freeze.sourceforge.net/ for a"
#~ " distutils extension that allows you "
#~ "to create console and GUI executables"
#~ " from Python code. `py2exe "
#~ "<http://www.py2exe.org/>`_, the most popular "
#~ "extension for building Python 2.x-based "
#~ "executables, does not yet support Python"
#~ " 3 but a version that does is"
#~ " in development."
#~ msgstr ""

#~ msgid ""
#~ "This series of screencasts aims to "
#~ "get you up and running with Python"
#~ " on Windows XP.  The knowledge is "
#~ "distilled into 1.5 hours and will "
#~ "get you up and running with the"
#~ " right Python distribution, coding in "
#~ "your choice of IDE, and debugging "
#~ "and writing solid code with unit-"
#~ "tests."
#~ msgstr ""

#~ msgid ""
#~ "Python is not added to the DOS "
#~ "path by default.  This screencast will"
#~ " walk you through the steps to "
#~ "add the correct entry to the "
#~ "`System Path`, allowing Python to be "
#~ "executed from the command-line by "
#~ "all users."
#~ msgstr ""

#~ msgid ""
#~ "Unless you use some sort of "
#~ "integrated development environment, you will"
#~ " end up *typing* Windows commands "
#~ "into what is variously referred to "
#~ "as a \"DOS window\" or \"Command "
#~ "prompt window\".  Usually you can create"
#~ " such a window from your Start "
#~ "menu; under Windows 7 the menu "
#~ "selection is :menuselection:`Start --> "
#~ "Programs --> Accessories --> Command "
#~ "Prompt`.  You should be able to "
#~ "recognize when you have started such "
#~ "a window because you will see a"
#~ " Windows \"command prompt\", which usually"
#~ " looks like this:"
#~ msgstr ""

#~ msgid ""
#~ "First, you need to make sure that"
#~ " your command window recognises the "
#~ "word \"python\" as an instruction to "
#~ "start the interpreter.  If you have "
#~ "opened a command window, you should "
#~ "try entering the command ``python`` and"
#~ " hitting return:"
#~ msgstr ""

#~ msgid ""
#~ "Many people use the interactive mode "
#~ "as a convenient yet highly programmable"
#~ " calculator.  When you want to end"
#~ " your interactive Python session, hold "
#~ "the :kbd:`Ctrl` key down while you "
#~ "enter a :kbd:`Z`, then hit the "
#~ "\":kbd:`Enter`\" key to get back to "
#~ "your Windows command prompt."
#~ msgstr ""

#~ msgid ""
#~ "You may also find that you have"
#~ " a Start-menu entry such as "
#~ ":menuselection:`Start --> Programs --> Python"
#~ " 3.3 --> Python (command line)` that"
#~ " results in you seeing the ``>>>``"
#~ " prompt in a new window.  If "
#~ "so, the window will disappear after "
#~ "you enter the :kbd:`Ctrl-Z` character; "
#~ "Windows is running a single \"python\""
#~ " command in the window, and closes"
#~ " it when you terminate the "
#~ "interpreter."
#~ msgstr ""

#~ msgid ""
#~ "If the ``python`` command, instead of"
#~ " displaying the interpreter prompt ``>>>``,"
#~ " gives you a message like::"
#~ msgstr ""

#~ msgid "or::"
#~ msgstr ""

#~ msgid ""
#~ "then you need to make sure that"
#~ " your computer knows where to find"
#~ " the Python interpreter.  To do this"
#~ " you will have to modify a "
#~ "setting called PATH, which is a "
#~ "list of directories where Windows will"
#~ " look for programs."
#~ msgstr ""

#~ msgid ""
#~ "You should arrange for Python's "
#~ "installation directory to be added to"
#~ " the PATH of every command window "
#~ "as it starts.  If you installed "
#~ "Python fairly recently then the command"
#~ " ::"
#~ msgstr ""

#~ msgid ""
#~ "will probably tell you where it is"
#~ " installed; the usual location is "
#~ "something like ``C:\\Python33``.  Otherwise "
#~ "you will be reduced to a search"
#~ " of your whole disk ... use "
#~ ":menuselection:`Tools --> Find` or hit "
#~ "the :guilabel:`Search` button and look "
#~ "for \"python.exe\".  Supposing you discover"
#~ " that Python is installed in the "
#~ "``C:\\Python33`` directory (the default at "
#~ "the time of writing), you should "
#~ "make sure that entering the command "
#~ "::"
#~ msgstr ""

#~ msgid ""
#~ "starts up the interpreter as above "
#~ "(and don't forget you'll need a "
#~ "\":kbd:`Ctrl-Z`\" and an \":kbd:`Enter`\" to"
#~ " get out of it). Once you have"
#~ " verified the directory, you can add"
#~ " it to the system path to make"
#~ " it easier to start Python by "
#~ "just running the ``python`` command. "
#~ "This is currently an option in the"
#~ " installer as of CPython 3.3."
#~ msgstr ""

#~ msgid ""
#~ "More information about environment variables"
#~ " can be found on the :ref:`Using "
#~ "Python on Windows <setting-envvars>` "
#~ "page."
#~ msgstr ""

#~ msgid "How do I emulate os.kill() in Windows?"
#~ msgstr ""

#~ msgid ""
#~ "Prior to Python 2.7 and 3.2, to"
#~ " terminate a process, you can use "
#~ ":mod:`ctypes`:"
#~ msgstr ""

#~ msgid ""
#~ "In 2.7 and 3.2, :func:`os.kill` is "
#~ "implemented similar to the above "
#~ "function, with the additional feature of"
#~ " being able to send :kbd:`Ctrl+C` and"
#~ " :kbd:`Ctrl+Break` to console subprocesses "
#~ "which are designed to handle those "
#~ "signals. See :func:`os.kill` for further "
#~ "details."
#~ msgstr ""

#~ msgid "How do I extract the downloaded documentation on Windows?"
#~ msgstr ""

#~ msgid ""
#~ "Sometimes, when you download the "
#~ "documentation package to a Windows "
#~ "machine using a web browser, the "
#~ "file extension of the saved file "
#~ "ends up being .EXE. This is a "
#~ "mistake; the extension should be .TGZ."
#~ msgstr ""

#~ msgid ""
#~ "Simply rename the downloaded file to "
#~ "have the .TGZ extension, and WinZip "
#~ "will be able to handle it.  (If"
#~ " your copy of WinZip doesn't, get "
#~ "a newer one from https://www.winzip.com.)"
#~ msgstr ""

