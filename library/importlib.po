# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-10-08 03:37+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:2
msgid ":mod:`!importlib` --- The implementation of :keyword:`!import`"
msgstr ":mod:`!importlib` --- :keyword:`!import`\\의 구현"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:12
msgid "**Source code:** :source:`Lib/importlib/__init__.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/__init__.py`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:17
msgid "Introduction"
msgstr "소개"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:19
msgid ""
"The purpose of the :mod:`importlib` package is two-fold. One is to "
"provide the implementation of the :keyword:`import` statement (and thus, "
"by extension, the :func:`__import__` function) in Python source code. "
"This provides an implementation of :keyword:`!import` which is portable "
"to any Python interpreter. This also provides an implementation which is "
"easier to comprehend than one implemented in a programming language other"
" than Python."
msgstr ""
":mod:`importlib` 패키지의 목적은 두 가지입니다. 하나는 파이썬 소스 코드에서 :keyword:`import` "
"문(그리고, 확장하면 :func:`__import__` 함수)의 구현을 제공하는 것입니다. 이것은 모든 파이썬 인터프리터에 이식할 "
"수 있는 :keyword:`!import`\\의 구현을 제공합니다. 또한 파이썬 이외의 프로그래밍 언어로 구현된 것보다 이해하기 "
"쉬운 구현을 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:26
msgid ""
"Two, the components to implement :keyword:`import` are exposed in this "
"package, making it easier for users to create their own custom objects "
"(known generically as an :term:`importer`) to participate in the import "
"process."
msgstr ""
"둘째, :keyword:`import`\\를 구현하는 구성 요소가 이 패키지에서 노출되어, 사용자가 임포트 프로세스에 참여하기 위해"
" 자신의 사용자 지정 객체(일반적으로 :term:`임포터 <importer>`\\라고 합니다)를 쉽게 만들 수 있도록 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:33
msgid ":ref:`import`"
msgstr ":ref:`import`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:33
msgid "The language reference for the :keyword:`import` statement."
msgstr ":keyword:`import` 문의 언어 레퍼런스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:38
msgid "`Packages specification <https://www.python.org/doc/essays/packages/>`__"
msgstr "`패키지 명세 <https://www.python.org/doc/essays/packages/>`__"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:36
msgid ""
"Original specification of packages. Some semantics have changed since the"
" writing of this document (e.g. redirecting based on ``None`` in "
":data:`sys.modules`)."
msgstr ""
"패키지의 원래 명세. 이 문서를 작성한 이후로 일부 의미가 변경되었습니다 (예를 들어 :data:`sys.modules`\\의 "
"``None``\\을 기반으로 하는 리디렉션)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:41
msgid "The :func:`.__import__` function"
msgstr ":func:`.__import__` 함수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:41
msgid "The :keyword:`import` statement is syntactic sugar for this function."
msgstr ":keyword:`import` 문은 이 함수의 편의 문법입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:44
msgid ":pep:`235`"
msgstr ":pep:`235`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:44
msgid "Import on Case-Insensitive Platforms"
msgstr "대소 문자를 구분하지 않는 플랫폼에서의 임포트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:47
msgid ":pep:`263`"
msgstr ":pep:`263`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:47
msgid "Defining Python Source Code Encodings"
msgstr "파이썬 소스 코드 인코딩 정의"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:50
msgid ":pep:`302`"
msgstr ":pep:`302`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:50
msgid "New Import Hooks"
msgstr "새로운 임포트 훅"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:53
msgid ":pep:`328`"
msgstr ":pep:`328`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:53
msgid "Imports: Multi-Line and Absolute/Relative"
msgstr "임포트: 다중 줄과 절대/상대"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:56
msgid ":pep:`366`"
msgstr ":pep:`366`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:56
msgid "Main module explicit relative imports"
msgstr "메인 모듈 명시적 상대 임포트"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:59
msgid ":pep:`420`"
msgstr ":pep:`420`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:59
msgid "Implicit namespace packages"
msgstr "묵시적 이름 공간 패키지"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:62
msgid ":pep:`451`"
msgstr ":pep:`451`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:62
msgid "A ModuleSpec Type for the Import System"
msgstr "임포트 시스템을 위한 ModuleSpec 형"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:65
msgid ":pep:`488`"
msgstr ":pep:`488`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:65
msgid "Elimination of PYO files"
msgstr "PYO 파일 제거"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:68
msgid ":pep:`489`"
msgstr ":pep:`489`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:68
msgid "Multi-phase extension module initialization"
msgstr "다단계 확장 모듈 초기화"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:71
msgid ":pep:`552`"
msgstr ":pep:`552`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:71
msgid "Deterministic pycs"
msgstr "결정론적 pyc"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:74
msgid ":pep:`3120`"
msgstr ":pep:`3120`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:74
msgid "Using UTF-8 as the Default Source Encoding"
msgstr "UTF-8을 기본 소스 인코딩으로 사용하기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:76
msgid ":pep:`3147`"
msgstr ":pep:`3147`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:77
msgid "PYC Repository Directories"
msgstr "PYC 저장소 디렉터리"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:81
msgid "Functions"
msgstr "함수"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:85
msgid "An implementation of the built-in :func:`__import__` function."
msgstr "내장 :func:`__import__` 함수의 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:88
msgid ""
"Programmatic importing of modules should use :func:`import_module` "
"instead of this function."
msgstr "프로그래밍 방식으로 모듈을 임포트 하려면 이 함수 대신 :func:`import_module`\\을 사용해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:93
msgid ""
"Import a module. The *name* argument specifies what module to import in "
"absolute or relative terms (e.g. either ``pkg.mod`` or ``..mod``). If the"
" name is specified in relative terms, then the *package* argument must be"
" set to the name of the package which is to act as the anchor for "
"resolving the package name (e.g. ``import_module('..mod', 'pkg.subpkg')``"
" will import ``pkg.mod``)."
msgstr ""
"모듈을 임포트 합니다. *name* 인자는 절대나 상대적인 항으로 임포트 할 모듈을 지정합니다 (예를 들어 "
"``pkg.mod``\\나 ``..mod``). 이름이 상대적인 항으로 지정되면, *package* 인자는 패키지 이름을 결정하기 "
"위한 앵커 역할을 하는 패키지 이름으로 설정해야 합니다 (예를 들어 ``import_module('..mod', "
"'pkg.subpkg')``\\는 ``pkg.mod``\\를 임포트 합니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:101
msgid ""
"The :func:`import_module` function acts as a simplifying wrapper around "
":func:`importlib.__import__`. This means all semantics of the function "
"are derived from :func:`importlib.__import__`. The most important "
"difference between these two functions is that :func:`import_module` "
"returns the specified package or module (e.g. ``pkg.mod``), while "
":func:`__import__` returns the top-level package or module (e.g. "
"``pkg``)."
msgstr ""
":func:`import_module` 함수는 :func:`importlib.__import__` 주위를 감싸는 단순화 래퍼 역할을"
" 합니다. 이는 함수의 모든 의미가 :func:`importlib.__import__`\\에서 파생됨을 뜻합니다. 이 두 함수의 "
"가장 중요한 차이점은 :func:`import_module`\\이 지정된 패키지나 모듈(예를 들어 ``pkg.mod``)을 반환하는"
" 반면, :func:`__import__`\\는 최상위 패키지나 모듈(예를 들어 ``pkg``)을 반환한다는 것입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:108
msgid ""
"If you are dynamically importing a module that was created since the "
"interpreter began execution (e.g., created a Python source file), you may"
" need to call :func:`invalidate_caches` in order for the new module to be"
" noticed by the import system."
msgstr ""
"인터프리터가 실행을 시작한 이후 만들어진 모듈(예를 들어, 파이썬 소스 파일을 만들면)을 동적으로 임포트 하는 경우, 임포트 "
"시스템에서 새 모듈을 알 수 있도록 :func:`invalidate_caches`\\를 호출해야 할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:113
msgid "Parent packages are automatically imported."
msgstr "부모 패키지는 자동으로 임포트 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:118
msgid ""
"Find the loader for a module, optionally within the specified *path*. If "
"the module is in :attr:`sys.modules`, then "
"``sys.modules[name].__loader__`` is returned (unless the loader would be "
"``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is "
"returned if no loader is found."
msgstr ""
"선택적으로 지정된 *path* 내에서, 모듈의 로더를 찾습니다. 모듈이 :attr:`sys.modules`\\에 있으면, "
"``sys.modules[name].__loader__``\\가 반환됩니다 (로더가 ``None``\\이 되거나 설정되지 않지 않은"
" 한, 그런 경우 :exc:`ValueError`\\가 발생합니다). 그렇지 않으면 :attr:`sys.meta_path`\\를 "
"사용한 검색이 수행됩니다. 로더가 발견되지 않으면 ``None``\\이 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:124
msgid ""
"A dotted name does not have its parents implicitly imported as that "
"requires loading them and that may not be desired. To properly import a "
"submodule you will need to import all parent packages of the submodule "
"and use the correct argument to *path*."
msgstr ""
"점으로 구분된 이름은 부모를 묵시적으로 임포트 되게 하지 않습니다, 그렇게 하려면 로드가 필요하고 이것이 바람직하지 않을 수 있기 "
"때문입니다. 서브 모듈을 올바르게 임포트 하려면 서브 모듈의 모든 부모 패키지를 임포트 하고 *path*\\에 올바른 인자를 "
"사용해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:131
msgid ""
"If ``__loader__`` is not set, raise :exc:`ValueError`, just like when the"
" attribute is set to ``None``."
msgstr ""
"``__loader__``\\가 설정되지 않으면, 어트리뷰트가 ``None``\\으로 설정되었을 때와 마찬가지로 "
":exc:`ValueError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:135
msgid "Use :func:`importlib.util.find_spec` instead."
msgstr "대신 :func:`importlib.util.find_spec`\\을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:140
msgid ""
"Invalidate the internal caches of finders stored at "
":data:`sys.meta_path`. If a finder implements ``invalidate_caches()`` "
"then it will be called to perform the invalidation.  This function should"
" be called if any modules are created/installed while your program is "
"running to guarantee all finders will notice the new module's existence."
msgstr ""
":data:`sys.meta_path`\\에 저장된 파인더의 내부 캐시를 무효로 합니다. 파인더가 "
"``invalidate_caches()``\\를 구현하면 무효화를 수행하기 위해 호출됩니다. 모든 파인더가 새로운 모듈의 존재를 알"
" 수 있도록 프로그램이 실행되는 동안 모듈이 만들어진/설치된 경우 이 함수를 호출해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:150
msgid ""
"Reload a previously imported *module*.  The argument must be a module "
"object, so it must have been successfully imported before.  This is "
"useful if you have edited the module source file using an external editor"
" and want to try out the new version without leaving the Python "
"interpreter.  The return value is the module object (which can be "
"different if re-importing causes a different object to be placed in "
":data:`sys.modules`)."
msgstr ""
"이전에 임포트 한 *module*\\을 다시 로드합니다. 인자는 모듈 객체여야 해서, 이전에 성공적으로 임포트 됐어야 합니다. 외부"
" 편집기를 사용하여 모듈 소스 파일을 편집했고 파이썬 인터프리터를 떠나지 않고 새 버전을 시험해보고 싶을 때 유용합니다. 반환 값은"
" 모듈 객체입니다 (재 임포트로 인해 다른 객체가 :data:`sys.modules`\\에 배치되면 다를 수 있습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:157
msgid "When :func:`reload` is executed:"
msgstr ":func:`reload`\\가 실행될 때:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:159
msgid ""
"Python module's code is recompiled and the module-level code re-executed,"
" defining a new set of objects which are bound to names in the module's "
"dictionary by reusing the :term:`loader` which originally loaded the "
"module.  The ``init`` function of extension modules is not called a "
"second time."
msgstr ""
"파이썬 모듈의 코드가 다시 컴파일되고 모듈 수준 코드가 다시 실행되어, 원래 모듈을 로드한 :term:`로더 <loader>`\\를"
" 재사용하여 모듈 딕셔너리에 있는 이름에 연결되는 새로운 객체 집합을 정의합니다. 확장 모듈의 ``init`` 함수는 두 번째에는 "
"호출되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:165
msgid ""
"As with all other objects in Python the old objects are only reclaimed "
"after their reference counts drop to zero."
msgstr "파이썬의 다른 모든 객체와 마찬가지로 이전 객체는 참조 횟수가 0으로 떨어진 후에만 자원이 회수됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:168
msgid ""
"The names in the module namespace are updated to point to any new or "
"changed objects."
msgstr "모듈 이름 공간의 이름은 새로운 객체나 변경된 객체를 가리키도록 갱신됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:171
msgid ""
"Other references to the old objects (such as names external to the "
"module) are not rebound to refer to the new objects and must be updated "
"in each namespace where they occur if that is desired."
msgstr ""
"이전 객체에 대한 다른 참조(가령 모듈 외부의 이름)는 새 객체를 참조하기 위해 다시 연결되지 않으며 필요하다면 그들이 등장하는 각"
" 이름 공간에서 갱신되어야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:175
msgid "There are a number of other caveats:"
msgstr "다른 여러 가지 경고가 있습니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:177
msgid ""
"When a module is reloaded, its dictionary (containing the module's global"
" variables) is retained.  Redefinitions of names will override the old "
"definitions, so this is generally not a problem.  If the new version of a"
" module does not define a name that was defined by the old version, the "
"old definition remains.  This feature can be used to the module's "
"advantage if it maintains a global table or cache of objects --- with a "
":keyword:`try` statement it can test for the table's presence and skip "
"its initialization if desired::"
msgstr ""
"모듈을 다시 로드할 때, 그것의 (모듈의 전역 변수를 포함하는) 딕셔너리가 유지됩니다. 이름을 재정의하면 이전 정의를 대체해서, "
"일반적으로 문제가 되지 않습니다. 새 버전의 모듈이 이전 버전이 정의한 이름을 정의하지 않으면, 이전 정의가 그대로 남습니다. 이 "
"기능은 객체의 전역 테이블이나 캐시를 유지한다면 모듈의 이점으로 사용될 수 있습니다 --- :keyword:`try` 문으로 "
"테이블의 존재를 검사하고 필요하다면 초기화를 건너뛸 수 있습니다::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:191
msgid ""
"It is generally not very useful to reload built-in or dynamically loaded "
"modules.  Reloading :mod:`sys`, :mod:`__main__`, :mod:`builtins` and "
"other key modules is not recommended.  In many cases extension modules "
"are not designed to be initialized more than once, and may fail in "
"arbitrary ways when reloaded."
msgstr ""
"일반적으로 내장이나 동적으로 로드된 모듈을 다시 로드하는 것은 그리 유용하지 않습니다. :mod:`sys`, "
":mod:`__main__`, :mod:`builtins` 및 기타 주요 모듈을 다시 로드하지 않는 것이 좋습니다. 많은 경우 확장"
" 모듈은 두 번 이상 초기화되도록 설계되지 않았으며, 다시 로드할 때 임의의 방식으로 실패할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:197
msgid ""
"If a module imports objects from another module using :keyword:`from` ..."
" :keyword:`import` ..., calling :func:`reload` for the other module does "
"not redefine the objects imported from it --- one way around this is to "
"re-execute the :keyword:`!from` statement, another is to use "
":keyword:`!import` and qualified names (*module.name*) instead."
msgstr ""
"모듈이 :keyword:`from` ... :keyword:`import` ...를 사용하여 다른 모듈에서 객체를 임포트 하면, "
"다른 모듈에 대해 :func:`reload`\\를 호출해도 그것에서 임포트 한 객체를 재정의하지 않습니다 --- 이것을 피하는 한 "
"가지 방법은 :keyword:`!from` 문을 다시 실행하는 것입니다, 다른 방법은 대신 :keyword:`!import`\\와 "
"정규화된 이름(*module.name*)을 사용하는 것입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:203
msgid ""
"If a module instantiates instances of a class, reloading the module that "
"defines the class does not affect the method definitions of the instances"
" --- they continue to use the old class definition.  The same is true for"
" derived classes."
msgstr ""
"모듈이 클래스의 인스턴스를 인스턴스 화하면, 클래스를 정의하는 모듈을 다시 로드해도 인스턴스의 메서드 정의에는 영향을 미치지 "
"않습니다 --- 이전 클래스 정의를 계속 사용합니다. 파생 클래스의 경우도 마찬가지입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:209
msgid ""
":exc:`ModuleNotFoundError` is raised when the module being reloaded lacks"
" a :class:`ModuleSpec`."
msgstr "다시 로드되는 모듈에 :class:`ModuleSpec`\\이 없으면 :exc:`ModuleNotFoundError` 가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:215
msgid ":mod:`importlib.abc` -- Abstract base classes related to import"
msgstr ":mod:`importlib.abc` -- import와 관련된 추상 베이스 클래스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:220
msgid "**Source code:** :source:`Lib/importlib/abc.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/abc.py`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:225
msgid ""
"The :mod:`importlib.abc` module contains all of the core abstract base "
"classes used by :keyword:`import`. Some subclasses of the core abstract "
"base classes are also provided to help in implementing the core ABCs."
msgstr ""
":mod:`importlib.abc` 모듈에는 :keyword:`import`\\에서 사용하는 모든 핵심 추상 베이스 클래스가 "
"포함되어 있습니다. 핵심 ABC 구현에 도움이 되도록 핵심 추상 베이스 클래스의 일부 서브 클래스도 제공됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:229
msgid "ABC hierarchy::"
msgstr "ABC 계층::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:245
msgid "An abstract base class representing a :term:`finder`."
msgstr ":term:`파인더 <finder>`\\를 나타내는 추상 베이스 클래스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:247
msgid "Use :class:`MetaPathFinder` or :class:`PathEntryFinder` instead."
msgstr "대신 :class:`MetaPathFinder`\\나 :class:`PathEntryFinder`\\를 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:252
msgid ""
"An abstract method for finding a :term:`loader` for the specified module."
"  Originally specified in :pep:`302`, this method was meant for use in "
":data:`sys.meta_path` and in the path-based import subsystem."
msgstr ""
"지정된 모듈의 :term:`로더 <loader>`\\를 찾는 추상 메서드. 원래 :pep:`302`\\에 지정된, 이 메서드는 "
":data:`sys.meta_path`\\와 경로 기반 임포트 서브 시스템에서 사용하기 위한 것입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:256
msgid ""
"Returns ``None`` when called instead of raising "
":exc:`NotImplementedError`."
msgstr "호출하면 :exc:`NotImplementedError`\\를 발생시키는 대신 ``None``\\을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:263
msgid ""
"An abstract base class representing a :term:`meta path finder`. For "
"compatibility, this is a subclass of :class:`Finder`."
msgstr ""
":term:`메타 경로 파인더 <meta path finder>`\\를 나타내는 추상 베이스 클래스. 호환성을 위해, "
":class:`Finder`\\의 서브 클래스입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:270
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  If this is a top-level import, *path* will be "
"``None``.  Otherwise, this is a search for a subpackage or module and "
"*path* will be the value of :attr:`__path__` from the parent package. If "
"a spec cannot be found, ``None`` is returned. When passed in, ``target`` "
"is a module object that the finder may use to make a more educated guess "
"about what spec to return. :func:`importlib.util.spec_from_loader` may be"
" useful for implementing concrete ``MetaPathFinders``."
msgstr ""
"지정된 모듈의 :term:`스펙 <module spec>`\\을 찾는 추상 메서드. 최상위 임포트 인 경우, *path*\\는 "
"``None``\\입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈의 검색이 되고, *path*\\는 부모 패키지의 "
":attr:`__path__` 값입니다. 스펙을 찾을 수 없으면, ``None``\\이 반환됩니다. 전달될 때, "
"``target``\\은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. "
":func:`importlib.util.spec_from_loader`\\는 구상 ``MetaPathFinders``\\를 구현하는"
" 데 유용할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:284
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"If this is a top-level import, *path* will be ``None``. Otherwise, this "
"is a search for a subpackage or module and *path* will be the value of "
":attr:`__path__` from the parent package. If a loader cannot be found, "
"``None`` is returned."
msgstr ""
"지정된 모듈에 대한 :term:`로더 <loader>`\\를 찾기 위한 레거시 메서드. 최상위 임포트 인 경우, *path*\\는 "
"``None``\\입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈의 검색이 되고, *path*\\는 부모 패키지의 "
":attr:`__path__` 값입니다. 로더를 찾을 수 없으면, ``None``\\이 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:290
msgid ""
"If :meth:`find_spec` is defined, backwards-compatible functionality is "
"provided."
msgstr ":meth:`find_spec`\\이 정의되면, 이전 버전과 호환되는 기능이 제공됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:293
msgid ""
"Returns ``None`` when called instead of raising "
":exc:`NotImplementedError`. Can use :meth:`find_spec` to provide "
"functionality."
msgstr ""
"호출하면 :exc:`NotImplementedError`\\를 발생시키는 대신 ``None``\\을 반환합니다. "
":meth:`find_spec`\\을 사용하여 기능을 제공할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:298
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:352
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:360
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1119
msgid "Use :meth:`find_spec` instead."
msgstr "대신 :meth:`find_spec`\\을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:303
msgid ""
"An optional method which, when called, should invalidate any internal "
"cache used by the finder. Used by :func:`importlib.invalidate_caches` "
"when invalidating the caches of all finders on :data:`sys.meta_path`."
msgstr ""
"호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적 메서드. :data:`sys.meta_path`\\에서 모든 "
"파인더의 캐시를 무효로 할 때 :func:`importlib.invalidate_caches`\\에서 사용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:307
msgid "Returns ``None`` when called instead of ``NotImplemented``."
msgstr "호출될 때 ``NotImplemented`` 대신 ``None``\\을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:313
msgid ""
"An abstract base class representing a :term:`path entry finder`.  Though "
"it bears some similarities to :class:`MetaPathFinder`, "
"``PathEntryFinder`` is meant for use only within the path-based import "
"subsystem provided by :class:`PathFinder`. This ABC is a subclass of "
":class:`Finder` for compatibility reasons only."
msgstr ""
":term:`경로 엔트리 파인더 <path entry finder>`\\를 나타내는 추상 베이스 클래스. "
":class:`MetaPathFinder`\\와 일부 유사하지만, ``PathEntryFinder``\\는 "
":class:`PathFinder`\\가 제공하는 경로 기반 임포트 서브 시스템 내에서만 사용하려는 것입니다. 이 ABC는 호환성을"
" 위해서만 :class:`Finder`\\의 서브 클래스입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:323
msgid ""
"An abstract method for finding a :term:`spec <module spec>` for the "
"specified module.  The finder will search for the module only within the "
":term:`path entry` to which it is assigned.  If a spec cannot be found, "
"``None`` is returned.  When passed in, ``target`` is a module object that"
" the finder may use to make a more educated guess about what spec to "
"return. :func:`importlib.util.spec_from_loader` may be useful for "
"implementing concrete ``PathEntryFinders``."
msgstr ""
"지정된 모듈의 :term:`스펙 <module spec>`\\을 찾는 추상 메서드. 파인더는 할당된 :term:`경로 엔트리 "
"<path entry>` 내에서만 모듈을 검색합니다. 스펙을 찾을 수 없으면, ``None``\\이 반환됩니다. 전달될 때, "
"``target``\\은 파인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다. "
":func:`importlib.util.spec_from_loader`\\는 구상 ``PathEntryFinders``\\를 "
"구현하는 데 유용할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:335
msgid ""
"A legacy method for finding a :term:`loader` for the specified module.  "
"Returns a 2-tuple of ``(loader, portion)`` where ``portion`` is a "
"sequence of file system locations contributing to part of a namespace "
"package. The loader may be ``None`` while specifying ``portion`` to "
"signify the contribution of the file system locations to a namespace "
"package. An empty list can be used for ``portion`` to signify the loader "
"is not part of a namespace package. If ``loader`` is ``None`` and "
"``portion`` is the empty list then no loader or location for a namespace "
"package were found (i.e. failure to find anything for the module)."
msgstr ""
"지정된 모듈에 대한 :term:`로더 <loader>`\\를 찾기 위한 레거시 메서드. ``(loader, portion)``\\의"
" 2-튜플을 반환하는데, ``portion``\\은 이름 공간 패키지의 일부에 기여하는 파일 시스템 위치의 시퀀스입니다. 파일 "
"시스템 위치가 이름 공간 패키지에 기여함을 나타내도록 ``portion``\\을 지정하는 동안 로더는 ``None``\\일 수 "
"있습니다. 로더가 이름 공간 패키지의 일부가 아님을 표시하기 위해 ``portion``\\에 빈 리스트를 사용할 수 있습니다. "
"``loader``\\가 ``None``\\이고 ``portion``\\이 빈 리스트이면 이름 공간 패키지의 로더나 위치가 발견되지"
" 않은 것입니다 (즉 모듈에 대해 아무것도 찾지 못했습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:345
msgid ""
"If :meth:`find_spec` is defined then backwards-compatible functionality "
"is provided."
msgstr ":meth:`find_spec`\\이 정의되면 이전 버전과 호환되는 기능이 제공됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:348
msgid ""
"Returns ``(None, [])`` instead of raising :exc:`NotImplementedError`. "
"Uses :meth:`find_spec` when available to provide functionality."
msgstr ""
":exc:`NotImplementedError`\\를 발생시키는 대신 ``(None, [])``\\를 반환합니다. 가능하다면 기능을"
" 제공하기 위해 :meth:`find_spec`\\을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:357
msgid ""
"A concrete implementation of :meth:`Finder.find_module` which is "
"equivalent to ``self.find_loader(fullname)[0]``."
msgstr ""
"``self.find_loader(fullname)[0]``\\과 동등한 :meth:`Finder.find_module`\\의 구상"
" 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:365
msgid ""
"An optional method which, when called, should invalidate any internal "
"cache used by the finder. Used by :meth:`PathFinder.invalidate_caches` "
"when invalidating the caches of all cached finders."
msgstr ""
"호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적 메서드. 모든 캐시 된 파인더의 캐시를 무효화 할 때 "
":meth:`PathFinder.invalidate_caches`\\에서 사용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:372
msgid ""
"An abstract base class for a :term:`loader`. See :pep:`302` for the exact"
" definition for a loader."
msgstr ":term:`로더 <loader>`\\의 추상 베이스 클래스. 로더에 대한 정확한 정의는 :pep:`302`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:375
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:856
msgid ""
"Loaders that wish to support resource reading should implement a "
"``get_resource_reader(fullname)`` method as specified by "
":class:`importlib.abc.ResourceReader`."
msgstr ""
"리소스 읽기를 지원하려는 로더는 :class:`importlib.abc.ResourceReader`\\에 지정된 대로 "
"``get_resource_reader(fullname)`` 메서드를 구현해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:379
msgid "Introduced the optional ``get_resource_reader()`` method."
msgstr "선택적 ``get_resource_reader()`` 메서드를 도입했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:384
msgid ""
"A method that returns the module object to use when importing a module.  "
"This method may return ``None``, indicating that default module creation "
"semantics should take place."
msgstr ""
"모듈을 임포트 할 때 사용할 모듈 객체를 반환하는 메서드. 이 메서드는 ``None``\\을 반환해서 기본 모듈 생성 시맨틱이 "
"적용되어야 함을 나타낼 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:390
msgid ""
"Starting in Python 3.6, this method will not be optional when "
":meth:`exec_module` is defined."
msgstr "파이썬 3.6부터는, :meth:`exec_module`\\이 정의될 때 이 메서드는 선택 사항이 아닙니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:396
msgid ""
"An abstract method that executes the module in its own namespace when a "
"module is imported or reloaded.  The module should already be initialized"
" when ``exec_module()`` is called. When this method exists, "
":meth:`~importlib.abc.Loader.create_module` must be defined."
msgstr ""
"모듈을 임포트 하거나 다시 로드할 때 자체 이름 공간에서 모듈을 실행하는 추상 메서드. ``exec_module()``\\이 호출될"
" 때 모듈이 이미 초기화되어 있어야 합니다. 이 메서드가 존재하면, "
":meth:`~importlib.abc.Loader.create_module`\\을 정의해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:403
msgid ":meth:`~importlib.abc.Loader.create_module` must also be defined."
msgstr ":meth:`~importlib.abc.Loader.create_module`\\도 정의해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:408
msgid ""
"A legacy method for loading a module. If the module cannot be loaded, "
":exc:`ImportError` is raised, otherwise the loaded module is returned."
msgstr ""
"모듈을 로드하는 레거시 메서드. 모듈을 로드할 수 없으면, :exc:`ImportError`\\가 발생하고, 그렇지 않으면 로드된 "
"모듈이 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:412
msgid ""
"If the requested module already exists in :data:`sys.modules`, that "
"module should be used and reloaded. Otherwise the loader should create a "
"new module and insert it into :data:`sys.modules` before any loading "
"begins, to prevent recursion from the import. If the loader inserted a "
"module and the load fails, it must be removed by the loader from "
":data:`sys.modules`; modules already in :data:`sys.modules` before the "
"loader began execution should be left alone (see "
":func:`importlib.util.module_for_loader`)."
msgstr ""
"요청된 모듈이 :data:`sys.modules`\\에 이미 존재하면, 해당 모듈이 사용되고 다시 로드되어야 합니다. 그렇지 않으면"
" 로더는 임포트에서 재귀를 방지하기 위해 로드를 시작하기 전에 새 모듈을 만들어 :data:`sys.modules`\\에 삽입해야 "
"합니다. 로더가 모듈을 삽입했는데 로드에 실패하면, 로더가 :data:`sys.modules`\\에서 모듈을 제거해야 합니다; "
"로더가 실행을 시작하기 전에 이미 :data:`sys.modules`\\에 있었던 모듈은 그대로 두어야 합니다 "
"(:func:`importlib.util.module_for_loader`\\를 참조하십시오)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:421
msgid ""
"The loader should set several attributes on the module. (Note that some "
"of these attributes can change when a module is reloaded):"
msgstr "로더는 모듈에서 여러 어트리뷰트를 설정해야 합니다. (이러한 어트리뷰트 중 일부는 모듈을 다시 로드할 때 변경될 수 있습니다):"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:426
msgid ":attr:`__name__`"
msgstr ":attr:`__name__`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:426
msgid "The name of the module."
msgstr "모듈의 이름"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:430
msgid ":attr:`__file__`"
msgstr ":attr:`__file__`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:429
msgid ""
"The path to where the module data is stored (not set for built-in "
"modules)."
msgstr "모듈 데이터가 저장되는 경로입니다 (내장 모듈에는 설정되지 않습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:434
msgid ":attr:`__cached__`"
msgstr ":attr:`__cached__`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:433
msgid ""
"The path to where a compiled version of the module is/should be stored "
"(not set when the attribute would be inappropriate)."
msgstr "모듈의 컴파일 된 버전이 저장되는/저장되어야 하는 경로 (어트리뷰트가 부적절하면 설정되지 않습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:438
msgid ":attr:`__path__`"
msgstr ":attr:`__path__`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:437
msgid ""
"A list of strings specifying the search path within a package. This "
"attribute is not set on modules."
msgstr "패키지 내에서 검색 경로를 지정하는 문자열 리스트. 이 어트리뷰트는 모듈에는 설정되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:444
msgid ":attr:`__package__`"
msgstr ":attr:`__package__`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:441
msgid ""
"The parent package for the module/package. If the module is top-level "
"then it has a value of the empty string. The "
":func:`importlib.util.module_for_loader` decorator can handle the details"
" for :attr:`__package__`."
msgstr ""
"모듈/패키지의 부모 패키지. 모듈이 최상위 수준이면 빈 문자열 값을 갖습니다. "
":func:`importlib.util.module_for_loader` 데코레이터는 :attr:`__package__`\\의 세부"
" 사항을 처리할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:449
msgid ":attr:`__loader__`"
msgstr ":attr:`__loader__`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:447
msgid ""
"The loader used to load the module. The "
":func:`importlib.util.module_for_loader` decorator can handle the details"
" for :attr:`__package__`."
msgstr ""
"모듈을 로드하는 데 사용되는 로더. :func:`importlib.util.module_for_loader` 데코레이터는 "
":attr:`__package__`\\의 세부 사항을 처리 할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:451
msgid ""
"When :meth:`exec_module` is available then backwards-compatible "
"functionality is provided."
msgstr ":meth:`exec_module`\\을 사용할 수 있으면 이전 버전과 호환되는 기능이 제공됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:454
msgid ""
"Raise :exc:`ImportError` when called instead of "
":exc:`NotImplementedError`. Functionality provided when "
":meth:`exec_module` is available."
msgstr ""
"호출될 때 :exc:`NotImplementedError` 대신 :exc:`ImportError`\\를 발생시킵니다. "
":meth:`exec_module`\\을 사용할 수 있을 때 제공되는 기능."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:459
msgid ""
"The recommended API for loading a module is :meth:`exec_module` (and "
":meth:`create_module`).  Loaders should implement it instead of "
"load_module().  The import machinery takes care of all the other "
"responsibilities of load_module() when exec_module() is implemented."
msgstr ""
"모듈 로드에 권장되는 API는 :meth:`exec_module`\\(및 :meth:`create_module`)입니다. 로더는 "
"load_module() 대신 이것을 구현해야 합니다. 임포트 절차는 exec_module()이 구현될 때 "
"load_module()의 다른 모든 책임을 처리합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:468
msgid ""
"A legacy method which when implemented calculates and returns the given "
"module's repr, as a string. The module type's default repr() will use the"
" result of this method as appropriate."
msgstr ""
"구현될 때 지정된 모듈의 repr을 문자열로 계산하고 반환하는 레거시 메서드. 모듈 형의 기본 repr()은 이 메서드의 결과를 "
"적절하게 사용합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:474
msgid "Made optional instead of an abstractmethod."
msgstr "abstractmethod 대신에 선택 사항으로 만들어졌습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:477
msgid "The import machinery now takes care of this automatically."
msgstr "임포트 절차는 이제 이것을 자동으로 처리합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:483
msgid "*Superseded by TraversableReader*"
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:485
msgid "An :term:`abstract base class` to provide the ability to read *resources*."
msgstr ""
"*리소스(resources)*\\를 읽을 수 있는 기능을 제공하는 :term:`추상 베이스 클래스 <abstract base "
"class>`."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:488
msgid ""
"From the perspective of this ABC, a *resource* is a binary artifact that "
"is shipped within a package. Typically this is something like a data file"
" that lives next to the ``__init__.py`` file of the package. The purpose "
"of this class is to help abstract out the accessing of such data files so"
" that it does not matter if the package and its data file(s) are stored "
"in a e.g. zip file versus on the file system."
msgstr ""
"이 ABC의 관점에서, *리소스(resource)*\\는 패키지 내에 제공되는 바이너리 아티팩트(artifact)입니다. 일반적으로"
" 이것은 패키지의 ``__init__.py`` 파일 옆에 있는 데이터 파일 같은 것입니다. 이 클래스의 목적은 이러한 데이터 파일에"
" 대한 액세스를 추상화하여 패키지와 해당 데이터 파일이 예를 들어 zip 파일에 있는지 파일 시스템에 저장되어 있는지가 중요하지 "
"않도록 만드는 것입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:496
msgid ""
"For any of methods of this class, a *resource* argument is expected to be"
" a :term:`path-like object` which represents conceptually just a file "
"name. This means that no subdirectory paths should be included in the "
"*resource* argument. This is because the location of the package the "
"reader is for, acts as the \"directory\". Hence the metaphor for "
"directories and file names is packages and resources, respectively. This "
"is also why instances of this class are expected to directly correlate to"
" a specific package (instead of potentially representing multiple "
"packages or a module)."
msgstr ""
"이 클래스의 모든 메서드에서, *resource* 인자는 개념적으로 단지 파일 이름을 나타내는 :term:`경로류 객체 <path-"
"like object>`\\가 될 것으로 기대됩니다. 이는 *resource* 인자에 서브 디렉터리 경로가 포함되지 않아야 함을 "
"의미합니다. 판독기(reader)가 읽으려는 패키지의 위치가 \"디렉터리\"의 역할을 하기 때문입니다. 따라서 디렉터리와 파일 "
"이름에 대한 은유는 각각 패키지와 리소스입니다. 이것은 또한 이 클래스의 인스턴스가 (잠재적으로 여러 패키지나 모듈을 나타내는 "
"대신) 특정 패키지와 직접적으로 연관될 것으로 기대되는 이유입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:507
msgid ""
"Loaders that wish to support resource reading are expected to provide a "
"method called ``get_resource_reader(fullname)`` which returns an object "
"implementing this ABC's interface. If the module specified by fullname is"
" not a package, this method should return :const:`None`. An object "
"compatible with this ABC should only be returned when the specified "
"module is a package."
msgstr ""
"리소스 읽기를 지원하려는 로더는 이 ABC의 인터페이스를 구현하는 객체를 반환하는 "
"``get_resource_reader(fullname)``\\이라는 메서드를 제공해야 합니다. fullname으로 지정된 모듈이 "
"패키지가 아니면, 이 메서드는 :const:`None`\\을 반환해야 합니다. 이 ABC와 호환되는 객체는 지정된 모듈이 패키지일 "
"때만 반환해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:518
msgid ""
"Returns an opened, :term:`file-like object` for binary reading of the "
"*resource*."
msgstr "*resource*\\의 바이너리 읽기를 위해 열린 :term:`파일류 객체 <file-like object>`\\를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:521
msgid "If the resource cannot be found, :exc:`FileNotFoundError` is raised."
msgstr "리소스를 찾을 수 없으면, :exc:`FileNotFoundError` 가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:526
msgid "Returns the file system path to the *resource*."
msgstr "*resource*\\에 대한 파일 시스템 경로를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:528
msgid ""
"If the resource does not concretely exist on the file system, raise "
":exc:`FileNotFoundError`."
msgstr "리소스가 파일 시스템에 구체적으로 존재하지 않으면, :exc:`FileNotFoundError` 가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:533
msgid ""
"Returns ``True`` if the named *name* is considered a resource. "
":exc:`FileNotFoundError` is raised if *name* does not exist."
msgstr ""
"명명된 *name*\\을 리소스로 간주하면 ``True``\\를 반환합니다. *name*\\이 없으면, "
":exc:`FileNotFoundError` 가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:538
msgid ""
"Returns an :term:`iterable` of strings over the contents of the package. "
"Do note that it is not required that all names returned by the iterator "
"be actual resources, e.g. it is acceptable to return names for which "
":meth:`is_resource` would be false."
msgstr ""
"패키지 내용에 대한 문자열의 :term:`이터러블 <iterable>`\\을 반환합니다. 이터레이터가 반환한 모든 이름이 실제 "
"리소스일 필요는 없음에 유의하십시오, 예를 들어 :meth:`is_resource`\\가 거짓인 이름을 반환하는 것이 허용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:544
msgid ""
"Allowing non-resource names to be returned is to allow for situations "
"where how a package and its resources are stored are known a priori and "
"the non-resource names would be useful. For instance, returning "
"subdirectory names is allowed so that when it is known that the package "
"and resources are stored on the file system then those subdirectory names"
" can be used directly."
msgstr ""
"리소스가 아닌 이름이 반환되도록 하는 것은 패키지와 그것의 리소스가 저장되는 방법이 사전에 알려졌고 리소스가 아닌 이름이 유용한 "
"상황을 허용하기 위함입니다. 예를 들어, 패키지와 리소스가 파일 시스템에 저장되어있는 것으로 알려졌을 때 해당 서브 디렉터리 이름을"
" 직접 사용할 수 있도록 서브 디렉터리 이름 반환이 허용됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:552
msgid "The abstract method returns an iterable of no items."
msgstr "추상 메서드는 항목이 없는 이터러블을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:557
msgid ""
"An abstract base class for a :term:`loader` which implements the optional"
" :pep:`302` protocol for loading arbitrary resources from the storage "
"back-end."
msgstr ""
"스토리지 백 엔드에서 임의의 리소스를 로드하기 위한 선택적 :pep:`302` 프로토콜을 구현하는 :term:`로더 "
"<loader>`\\의 추상 베이스 클래스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:561
msgid ""
"This ABC is deprecated in favour of supporting resource loading through "
":class:`importlib.abc.ResourceReader`."
msgstr ""
"이 ABC는 폐지되었고 :class:`importlib.abc.ResourceReader`\\를 통한 리소스 로드 지원으로 "
"대체되었습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:567
msgid ""
"An abstract method to return the bytes for the data located at *path*. "
"Loaders that have a file-like storage back-end that allows storing "
"arbitrary data can implement this abstract method to give direct access "
"to the data stored. :exc:`OSError` is to be raised if the *path* cannot "
"be found. The *path* is expected to be constructed using a module's "
":attr:`__file__` attribute or an item from a package's :attr:`__path__`."
msgstr ""
"*path*\\에 있는 데이터를 바이트열로 반환하는 추상 메서드. 임의의 데이터를 저장할 수 있는 파일류 스토리지 백 엔드가 있는 "
"로더는 이 추상 메서드를 구현하여 저장된 데이터에 직접 액세스하도록 할 수 있습니다. *path*\\를 찾을 수 없으면 "
":exc:`OSError`\\가 발생합니다. *path*\\는 모듈의 :attr:`__file__` 어트리뷰트나 패키지의 "
":attr:`__path__`\\에서 온 항목을 사용하여 구성될 것으로 기대됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:575
msgid "Raises :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` 대신 :exc:`OSError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:581
msgid ""
"An abstract base class for a :term:`loader` which implements the optional"
" :pep:`302` protocol for loaders that inspect modules."
msgstr ""
"모듈을 검사(inspect)하는 로더를 위한 선택적 :pep:`302` 프로토콜을 구현하는 :term:`로더 <loader>`\\의"
" 추상 베이스 클래스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:586
msgid ""
"Return the code object for a module, or ``None`` if the module does not "
"have a code object (as would be the case, for example, for a built-in "
"module).  Raise an :exc:`ImportError` if loader cannot find the requested"
" module."
msgstr ""
"모듈에 대한 코드 객체나, 모듈에 코드 객체가 없으면 (예를 들어, 내장 모듈이 이런 경우입니다) ``None``\\을 반환합니다."
" 로더가 요청한 모듈을 찾을 수 없으면 :exc:`ImportError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:592
msgid ""
"While the method has a default implementation, it is suggested that it be"
" overridden if possible for performance."
msgstr "이 메서드에는 기본 구현이 있지만, 가능하다면 성능을 위해 재정의하는 것이 좋습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:598
msgid "No longer abstract and a concrete implementation is provided."
msgstr "더는 추상적이지 않고 구상 구현이 제공됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:603
msgid ""
"An abstract method to return the source of a module. It is returned as a "
"text string using :term:`universal newlines`, translating all recognized "
"line separators into ``'\\n'`` characters.  Returns ``None`` if no source"
" is available (e.g. a built-in module). Raises :exc:`ImportError` if the "
"loader cannot find the module specified."
msgstr ""
"모듈의 소스를 반환하는 추상 메서드. 인식된 모든 줄 구분자를 ``'\\n'`` 문자로 변환하는 :term:`유니버설 줄 넘김 "
"<universal newlines>`\\을 사용하여 텍스트 문자열로 반환됩니다. 사용 가능한 소스가 없으면 (예를 들어, 내장 "
"모듈) ``None``\\을 반환합니다. 로더가 지정된 모듈을 찾을 수 없으면 :exc:`ImportError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:609
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:618
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:668
msgid "Raises :exc:`ImportError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` 대신 :exc:`ImportError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:614
msgid ""
"An abstract method to return a true value if the module is a package, a "
"false value otherwise. :exc:`ImportError` is raised if the :term:`loader`"
" cannot find the module."
msgstr ""
"모듈이 패키지이면 참값을 반환하고, 그렇지 않으면 거짓 값을 반환하는 추상 메서드. :term:`로더 <loader>`\\가 모듈을"
" 찾을 수 없으면 :exc:`ImportError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:623
msgid "Create a code object from Python source."
msgstr "파이썬 소스에서 코드 객체를 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:625
msgid ""
"The *data* argument can be whatever the :func:`compile` function supports"
" (i.e. string or bytes). The *path* argument should be the \"path\" to "
"where the source code originated from, which can be an abstract concept "
"(e.g. location in a zip file)."
msgstr ""
"*data* 인자는 :func:`compile` 함수가 지원하는 것은 무엇이든 될 수 있습니다 (즉 문자열이나 바이트열). "
"*path* 인자는 소스 코드가 온 곳의 \"경로\"여야 하며, 추상 개념(예를 들어 zip 파일에서의 위치)일 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:630
msgid ""
"With the subsequent code object one can execute it in a module by running"
" ``exec(code, module.__dict__)``."
msgstr ""
"후속 코드 객체를 사용하면 ``exec(code, module.__dict__)``\\를 실행하여 그 코드를 모듈에서 실행할 수 "
"있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:635
msgid "Made the method static."
msgstr "메서드를 정적(static)으로 만들었습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:640
msgid "Implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module`\\의 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:646
msgid "Implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module`\\의 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:648
msgid "use :meth:`exec_module` instead."
msgstr "대신 :meth:`exec_module`\\을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:654
msgid ""
"An abstract base class which inherits from :class:`InspectLoader` that, "
"when implemented, helps a module to be executed as a script. The ABC "
"represents an optional :pep:`302` protocol."
msgstr ""
"구현될 때, 모듈이 스크립트로 실행되도록 돕는 :class:`InspectLoader`\\에서 상속되는 추상 베이스 클래스. "
"ABC는 선택적 :pep:`302` 프로토콜을 표현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:660
msgid ""
"An abstract method that is to return the value of :attr:`__file__` for "
"the specified module. If no path is available, :exc:`ImportError` is "
"raised."
msgstr ""
"지정된 모듈의 :attr:`__file__` 값을 반환하는 추상 메서드. 사용 가능한 경로가 없으면 "
":exc:`ImportError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:664
msgid ""
"If source code is available, then the method should return the path to "
"the source file, regardless of whether a bytecode was used to load the "
"module."
msgstr "소스 코드를 사용할 수 있으면, 메서드는 모듈을 로드하는 데 바이트 코드를 사용했는지와 관계없이 소스 파일의 경로를 반환해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:674
msgid ""
"An abstract base class which inherits from :class:`ResourceLoader` and "
":class:`ExecutionLoader`, providing concrete implementations of "
":meth:`ResourceLoader.get_data` and :meth:`ExecutionLoader.get_filename`."
msgstr ""
":class:`ResourceLoader`\\와 :class:`ExecutionLoader`\\를 상속하고 "
":meth:`ResourceLoader.get_data`\\와 "
":meth:`ExecutionLoader.get_filename`\\의 구상 구현을 제공하는 추상 베이스 클래스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:678
msgid ""
"The *fullname* argument is a fully resolved name of the module the loader"
" is to handle. The *path* argument is the path to the file for the "
"module."
msgstr ""
"*fullname* 인자는 로더가 처리해야 하는 모듈의 완전히 결정된(resolved) 이름입니다. *path* 인자는 모듈의 파일"
" 경로입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:685
msgid "The name of the module the loader can handle."
msgstr "로더가 처리할 수 있는 모듈의 이름."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:689
msgid "Path to the file of the module."
msgstr "모듈 파일의 경로."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:693
msgid "Calls super's ``load_module()``."
msgstr "super의 ``load_module()``\\을 호출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:695
msgid "Use :meth:`Loader.exec_module` instead."
msgstr "대신 :meth:`Loader.exec_module`\\을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:700
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1318
msgid "Returns :attr:`path`."
msgstr ":attr:`path`\\를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:704
msgid "Reads *path* as a binary file and returns the bytes from it."
msgstr "*path*\\를 바이너리 파일로 읽고 그것의 바이트열을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:709
msgid ""
"An abstract base class for implementing source (and optionally bytecode) "
"file loading. The class inherits from both :class:`ResourceLoader` and "
":class:`ExecutionLoader`, requiring the implementation of:"
msgstr ""
"소스 (및 선택적으로 바이트 코드) 파일 로드를 구현하기 위한 추상 베이스 클래스. 이 클래스는 "
":class:`ResourceLoader`\\와 :class:`ExecutionLoader`\\를 모두 상속하며, 다음을 구현해야 "
"합니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:713
msgid ":meth:`ResourceLoader.get_data`"
msgstr ":meth:`ResourceLoader.get_data`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:716
msgid ":meth:`ExecutionLoader.get_filename`"
msgstr ":meth:`ExecutionLoader.get_filename`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:715
msgid ""
"Should only return the path to the source file; sourceless loading is not"
" supported."
msgstr "소스 파일의 경로만 반환해야 합니다; 소스 없는 로딩은 지원되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:718
msgid ""
"The abstract methods defined by this class are to add optional bytecode "
"file support. Not implementing these optional methods (or causing them to"
" raise :exc:`NotImplementedError`) causes the loader to only work with "
"source code. Implementing the methods allows the loader to work with "
"source *and* bytecode files; it does not allow for *sourceless* loading "
"where only bytecode is provided.  Bytecode files are an optimization to "
"speed up loading by removing the parsing step of Python's compiler, and "
"so no bytecode-specific API is exposed."
msgstr ""
"이 클래스에 의해 정의된 추상 메서드는 선택적 바이트 코드 파일 지원을 추가하는 것입니다. 이러한 선택적 메서드를 구현하지 않으면 "
"(또는 그들이 :exc:`NotImplementedError`\\를 발생시키도록 하면) 로더가 소스 코드에 대해서만 작동하도록 "
"만듭니다. 메서드를 구현하면 로더가 소스\\*와* 바이트 코드 파일 모두에 대해 작동하게 할 수 있습니다; 바이트 코드만 제공되는 "
"*소스 없는* 로드는 허용하지 않습니다. 바이트 코드 파일은 파이썬 컴파일러의 구문 분석 단계를 제거하여 로딩 속도를 높이기 위한 "
"최적화라서, 바이트 코드 전용 API는 노출되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:729
msgid ""
"Optional abstract method which returns a :class:`dict` containing "
"metadata about the specified path.  Supported dictionary keys are:"
msgstr ""
"지정된 경로에 대한 메타 데이터를 포함하는 :class:`dict`\\를 반환하는 선택적 추상 메서드. 지원되는 딕셔너리 키는 "
"다음과 같습니다:"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:732
msgid ""
"``'mtime'`` (mandatory): an integer or floating-point number representing"
" the modification time of the source code;"
msgstr "``'mtime'`` (필수): 소스 코드의 수정 시간을 나타내는 정수나 부동 소수점 숫자;"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:734
msgid "``'size'`` (optional): the size in bytes of the source code."
msgstr "``'size'`` (선택): 바이트 단위의 소스 코드의 크기."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:736
msgid ""
"Any other keys in the dictionary are ignored, to allow for future "
"extensions. If the path cannot be handled, :exc:`OSError` is raised."
msgstr "향후 확장을 위해, 딕셔너리의 다른 키는 무시됩니다. 경로를 처리할 수 없으면, :exc:`OSError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:741
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:754
msgid "Raise :exc:`OSError` instead of :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError` 대신 :exc:`OSError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:746
msgid ""
"Optional abstract method which returns the modification time for the "
"specified path."
msgstr "지정된 경로의 수정 시간을 반환하는 선택적 추상 메서드."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:749
msgid ""
"This method is deprecated in favour of :meth:`path_stats`.  You don't "
"have to implement it, but it is still available for compatibility "
"purposes. Raise :exc:`OSError` if the path cannot be handled."
msgstr ""
"이 메서드는 폐지되었고 :meth:`path_stats`\\로 대체되었습니다. 구현할 필요는 없지만, 호환성을 위해 여전히 "
"제공됩니다. 경로를 처리할 수 없으면 :exc:`OSError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:759
msgid ""
"Optional abstract method which writes the specified bytes to a file path."
" Any intermediate directories which do not exist are to be created "
"automatically."
msgstr "지정된 바이트열을 파일 경로에 쓰는 선택적 추상 메서드. 존재하지 않는 중간 디렉터리는 자동으로 만들어집니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:763
msgid ""
"When writing to the path fails because the path is read-only "
"(:attr:`errno.EACCES`/:exc:`PermissionError`), do not propagate the "
"exception."
msgstr ""
"경로가 읽기 전용(:attr:`errno.EACCES`/:exc:`PermissionError`)이라서 경로에 쓰지 못할 때 예외를"
" 전파하지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:767
msgid "No longer raises :exc:`NotImplementedError` when called."
msgstr "호출할 때 더는 :exc:`NotImplementedError`\\를 발생시키지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:772
msgid "Concrete implementation of :meth:`InspectLoader.get_code`."
msgstr ":meth:`InspectLoader.get_code`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:776
msgid "Concrete implementation of :meth:`Loader.exec_module`."
msgstr ":meth:`Loader.exec_module`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:782
msgid "Concrete implementation of :meth:`Loader.load_module`."
msgstr ":meth:`Loader.load_module`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:784
msgid "Use :meth:`exec_module` instead."
msgstr "대신 :meth:`exec_module`\\을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:789
msgid "Concrete implementation of :meth:`InspectLoader.get_source`."
msgstr ":meth:`InspectLoader.get_source`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:793
msgid ""
"Concrete implementation of :meth:`InspectLoader.is_package`. A module is "
"determined to be a package if its file path (as provided by "
":meth:`ExecutionLoader.get_filename`) is a file named ``__init__`` when "
"the file extension is removed **and** the module name itself does not end"
" in ``__init__``."
msgstr ""
":meth:`InspectLoader.is_package`\\의 구상 구현. "
"(:meth:`ExecutionLoader.get_filename`\\에서 제공되는) 파일 경로가 파일 확장자를 제거했을 때 "
"``__init__``\\라는 이름의 파일이고 *동시에* 모듈 이름 자체가 ``__init__``\\로 끝나지 않으면 모듈은 "
"패키지로 결정됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:802
msgid ""
"An object with a subset of pathlib.Path methods suitable for traversing "
"directories and opening files."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:810
msgid ""
"An abstract base class for resource readers capable of serving the "
"``files`` interface. Subclasses ResourceReader and provides concrete "
"implementations of the ResourceReader's abstract methods. Therefore, any "
"loader supplying TraversableReader also supplies ResourceReader."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:820
msgid ":mod:`importlib.resources` -- Resources"
msgstr ":mod:`importlib.resources` -- 리소스"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:825
msgid "**Source code:** :source:`Lib/importlib/resources.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/resources.py`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:831
msgid ""
"This module leverages Python's import system to provide access to "
"*resources* within *packages*.  If you can import a package, you can "
"access resources within that package.  Resources can be opened or read, "
"in either binary or text mode."
msgstr ""
"이 모듈은 파이썬의 임포트 시스템을 활용하여 *패키지(packages)* 안에 있는 *리소스(resources)*\\에 대한 "
"액세스를 제공합니다. 패키지를 임포트 할 수 있으면, 해당 패키지 내의 리소스에 액세스 할 수 있습니다. 바이너리나 텍스트 모드로 "
"리소스를 열거나 읽을 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:836
msgid ""
"Resources are roughly akin to files inside directories, though it's "
"important to keep in mind that this is just a metaphor.  Resources and "
"packages **do not** have to exist as physical files and directories on "
"the file system."
msgstr ""
"리소스는 디렉터리 내의 파일과 거의 비슷하지만, 이것은 단지 은유라는 점을 명심해야 합니다. 리소스와 패키지가 파일 시스템에 실제 "
"파일과 디렉터리로 존재할 필요는 **없습니다**."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:842
msgid ""
"This module provides functionality similar to `pkg_resources "
"<https://setuptools.readthedocs.io/en/latest/pkg_resources.html>`_ `Basic"
" Resource Access "
"<http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-"
"resource-access>`_ without the performance overhead of that package.  "
"This makes reading resources included in packages easier, with more "
"stable and consistent semantics."
msgstr ""
"이 모듈은 `pkg_resources "
"<https://setuptools.readthedocs.io/en/latest/pkg_resources.html>`_ `Basic"
" Resource Access "
"<http://setuptools.readthedocs.io/en/latest/pkg_resources.html#basic-"
"resource-access>`_\\와 유사한 기능을 제공합니다만, 이 패키지의 성능 오버헤드가 없습니다. 이는 더 안정적이고 "
"일관된 의미론으로, 패키지에 포함된 리소스를 더 쉽게 읽을 수 있도록 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:850
msgid ""
"The standalone backport of this module provides more information on "
"`using importlib.resources <http://importlib-"
"resources.readthedocs.io/en/latest/using.html>`_ and `migrating from "
"pkg_resources to importlib.resources <http://importlib-"
"resources.readthedocs.io/en/latest/migration.html>`_."
msgstr ""
"이 모듈의 독립형 역 이식은 `using importlib.resources <http://importlib-"
"resources.readthedocs.io/en/latest/using.html>`_\\와 `migrating from "
"pkg_resources to importlib.resources <http://importlib-"
"resources.readthedocs.io/en/latest/migration.html>`_\\에서 자세한 정보를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:860
msgid "The following types are defined."
msgstr "다음과 같은 형이 정의됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:864
msgid ""
"The ``Package`` type is defined as ``Union[str, ModuleType]``.  This "
"means that where the function describes accepting a ``Package``, you can "
"pass in either a string or a module.  Module objects must have a "
"resolvable ``__spec__.submodule_search_locations`` that is not ``None``."
msgstr ""
"``Package`` 형은 ``Union[str, ModuleType]``\\으로 정의됩니다. 이는 함수가 "
"``Package``\\를 받아들인다고 설명하는 위치에 문자열이나 모듈을 전달할 수 있음을 의미합니다. 모듈 객체는 "
"``None``\\이 아닌 해석할 수 있는 ``__spec__.submodule_search_locations``\\를 가져야 "
"합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:871
msgid ""
"This type describes the resource names passed into the various functions "
"in this package.  This is defined as ``Union[str, os.PathLike]``."
msgstr ""
"이 형은 이 패키지의 다양한 함수에 전달된 리소스 이름을 기술합니다. 이것은 ``Union[str, "
"os.PathLike]``\\으로 정의됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:875
msgid "The following functions are available."
msgstr "다음과 같은 함수를 사용할 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:880
msgid ""
"Returns an :class:`importlib.resources.abc.Traversable` object "
"representing the resource container for the package (think directory) and"
" its resources (think files). A Traversable may contain other containers "
"(think subdirectories)."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:885
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:970
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements."
msgstr "*package*\\는 ``Package`` 요구 사항을 준수하는 이름이나 모듈 객체입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:892
msgid "Open for binary reading the *resource* within *package*."
msgstr "*package* 내에서 *resource*\\를 바이너리 읽기로 엽니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:894
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open"
" within *package*; it may not contain path separators and it may not have"
" sub-resources (i.e. it cannot be a directory).  This function returns a "
"``typing.BinaryIO`` instance, a binary I/O stream open for reading."
msgstr ""
"*package*\\는 ``Package`` 요구 사항을 준수하는 이름이나 모듈 객체입니다. *resource*\\는 "
"*package* 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, "
"디렉터리가 될 수 없습니다). 이 함수는 읽기 위해 열린 바이너리 I/O 스트림인 ``typing.BinaryIO`` 인스턴스를 "
"반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:903
msgid ""
"Open for text reading the *resource* within *package*.  By default, the "
"resource is opened for reading as UTF-8."
msgstr "*package* 내에서 *resource*\\를 텍스트 읽기로 엽니다. 기본적으로, 리소스는 UTF-8로 읽도록 열립니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:906
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open"
" within *package*; it may not contain path separators and it may not have"
" sub-resources (i.e. it cannot be a directory).  *encoding* and *errors* "
"have the same meaning as with built-in :func:`open`."
msgstr ""
"*package*\\는 ``Package`` 요구 사항을 준수하는 이름이나 모듈 객체입니다. *resource*\\는 "
"*package* 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, "
"디렉터리가 될 수 없습니다). *encoding*\\과 *errors*\\는 내장 :func:`open`\\과 같은 의미입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:912
msgid ""
"This function returns a ``typing.TextIO`` instance, a text I/O stream "
"open for reading."
msgstr "이 함수는 읽기 위해 열린 텍스트 I/O 스트림인 ``typing.TextIO`` 인스턴스를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:918
msgid ""
"Read and return the contents of the *resource* within *package* as "
"``bytes``."
msgstr "*package* 내에서 *resource*\\의 내용을 읽고 ``bytes``\\로 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:921
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open"
" within *package*; it may not contain path separators and it may not have"
" sub-resources (i.e. it cannot be a directory).  This function returns "
"the contents of the resource as :class:`bytes`."
msgstr ""
"*package*\\는 ``Package`` 요구 사항을 준수하는 이름이나 모듈 객체입니다. *resource*\\는 "
"*package* 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, "
"디렉터리가 될 수 없습니다). 이 함수는 리소스의 내용을 :class:`bytes`\\로 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:930
msgid ""
"Read and return the contents of *resource* within *package* as a ``str``."
" By default, the contents are read as strict UTF-8."
msgstr ""
"*package* 내에서 *resource*\\의 내용을 읽고 ``str``\\로 반환합니다. 기본적으로, 내용은 "
"엄격한(strict) UTF-8로 읽습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:933
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open"
" within *package*; it may not contain path separators and it may not have"
" sub-resources (i.e. it cannot be a directory).  *encoding* and *errors* "
"have the same meaning as with built-in :func:`open`.  This function "
"returns the contents of the resource as :class:`str`."
msgstr ""
"*package*\\는 ``Package`` 요구 사항을 준수하는 이름이나 모듈 객체입니다. *resource*\\는 "
"*package* 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, "
"디렉터리가 될 수 없습니다). *encoding*\\과 *errors*\\는 내장 :func:`open`\\과 같은 의미입니다. 이"
" 함수는 리소스의 내용을 :class:`str`\\로 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:943
msgid ""
"Return the path to the *resource* as an actual file system path.  This "
"function returns a context manager for use in a :keyword:`with` "
"statement. The context manager provides a :class:`pathlib.Path` object."
msgstr ""
"*resource*\\에 대한 경로를 실제 파일 시스템 경로로 반환합니다. 이 함수는 :keyword:`with` 문에서 사용할 "
"컨텍스트 관리자를 반환합니다. 컨텍스트 관리자는 :class:`pathlib.Path` 객체를 제공합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:947
msgid ""
"Exiting the context manager cleans up any temporary file created when the"
" resource needs to be extracted from e.g. a zip file."
msgstr "컨텍스트 관리자를 종료하면 리소스를 예를 들어 zip 파일에서 추출해야 할 때 만들어진 임시 파일이 정리됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:950
msgid ""
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements.  *resource* is the name of the resource to open"
" within *package*; it may not contain path separators and it may not have"
" sub-resources (i.e. it cannot be a directory)."
msgstr ""
"*package*\\는 ``Package`` 요구 사항을 준수하는 이름이나 모듈 객체입니다. *resource*\\는 "
"*package* 내에서 열 리소스의 이름입니다; 경로 구분 기호를 포함하지 않아야 하고 서브 리소스를 가질 수도 없습니다 (즉, "
"디렉터리가 될 수 없습니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:958
msgid ""
"Return ``True`` if there is a resource named *name* in the package, "
"otherwise ``False``.  Remember that directories are *not* resources! "
"*package* is either a name or a module object which conforms to the "
"``Package`` requirements."
msgstr ""
"패키지에 *name*\\이라는 리소스가 있으면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다. 디렉터리는 "
"리소스가 *아니라는* 것을 기억하십시오! *package*\\는 ``Package`` 요구 사항을 준수하는 이름이나 모듈 "
"객체입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:966
msgid ""
"Return an iterable over the named items within the package.  The iterable"
" returns :class:`str` resources (e.g. files) and non-resources (e.g. "
"directories).  The iterable does not recurse into subdirectories."
msgstr ""
"패키지 내에서 이름이 있는 항목에 대한 이터러블을 반환합니다. 이터러블은 :class:`str` 리소스(예를 들어 파일)와 리소스가"
" 아닌 것(예를 들어 디렉터리)을 반환합니다. 이터러블은 서브 디렉터리로 재귀하지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:975
msgid ":mod:`importlib.machinery` -- Importers and path hooks"
msgstr ":mod:`importlib.machinery` -- 임포터와 경로 훅"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:980
msgid "**Source code:** :source:`Lib/importlib/machinery.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/machinery.py`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:984
msgid ""
"This module contains the various objects that help :keyword:`import` find"
" and load modules."
msgstr "이 모듈에는 :keyword:`import`\\가 모듈을 찾고 로드하는 데 도움이 되는 다양한 객체가 포함되어 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:989
msgid ""
"A list of strings representing the recognized file suffixes for source "
"modules."
msgstr "소스 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:996
msgid ""
"A list of strings representing the file suffixes for non-optimized "
"bytecode modules."
msgstr "최적화되지 않은 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1001
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1011
msgid "Use :attr:`BYTECODE_SUFFIXES` instead."
msgstr "대신 :attr:`BYTECODE_SUFFIXES`\\를 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1006
msgid ""
"A list of strings representing the file suffixes for optimized bytecode "
"modules."
msgstr "최적화된 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1016
msgid ""
"A list of strings representing the recognized file suffixes for bytecode "
"modules (including the leading dot)."
msgstr "바이트 코드 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트 (앞의 점을 포함합니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1021
msgid "The value is no longer dependent on ``__debug__``."
msgstr "이 값은 더는 ``__debug__``\\에 의존하지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1026
msgid ""
"A list of strings representing the recognized file suffixes for extension"
" modules."
msgstr "확장 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1033
msgid ""
"Returns a combined list of strings representing all file suffixes for "
"modules recognized by the standard import machinery. This is a helper for"
" code which simply needs to know if a filesystem path potentially refers "
"to a module without needing any details on the kind of module (for "
"example, :func:`inspect.getmodulename`)."
msgstr ""
"표준 임포트 절차가 인식하는 모듈의 모든 파일 접미사를 나타내는 문자열의 결합한 리스트를 반환합니다. 이것은 모듈 종류에 대한 세부"
" 정보 없이 파일 시스템 경로가 잠재적으로 모듈을 참조하는지를 알아야 하는 코드(예를 들어, "
":func:`inspect.getmodulename`)를 위한 도우미입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1044
msgid ""
"An :term:`importer` for built-in modules. All known built-in modules are "
"listed in :data:`sys.builtin_module_names`. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"내장 모듈용 :term:`임포터 <importer>`. 알려진 모든 내장 모듈은 "
":data:`sys.builtin_module_names`\\에 나열되어 있습니다. 이 클래스는 "
":class:`importlib.abc.MetaPathFinder`\\와 "
":class:`importlib.abc.InspectLoader` ABC를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1049
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1063
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1076
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1091
msgid ""
"Only class methods are defined by this class to alleviate the need for "
"instantiation."
msgstr "이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정의합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1052
msgid ""
"As part of :pep:`489`, the builtin importer now implements "
":meth:`Loader.create_module` and :meth:`Loader.exec_module`"
msgstr ""
":pep:`489`\\의 일부로, 내장 임포터는 이제 :meth:`Loader.create_module`\\과 "
":meth:`Loader.exec_module`\\을 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1059
msgid ""
"An :term:`importer` for frozen modules. This class implements the "
":class:`importlib.abc.MetaPathFinder` and "
":class:`importlib.abc.InspectLoader` ABCs."
msgstr ""
"프로즌(frozen) 모듈용 :term:`임포터 <importer>`. 이 클래스는 "
":class:`importlib.abc.MetaPathFinder`\\와 "
":class:`importlib.abc.InspectLoader` ABC를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1066
msgid ""
"Gained :meth:`~Loader.create_module` and :meth:`~Loader.exec_module` "
"methods."
msgstr ":meth:`Loader.create_module`\\과 :meth:`Loader.exec_module` 메서드를 얻었습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1073
msgid ""
":term:`Finder <finder>` for modules declared in the Windows registry.  "
"This class implements the :class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
"윈도우 레지스트리에 선언된 모듈용 :term:`파인더 <finder>`. 이 클래스는 "
":class:`importlib.abc.MetaPathFinder` ABC를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1081
msgid ""
"Use :mod:`site` configuration instead. Future versions of Python may not "
"enable this finder by default."
msgstr "대신 :mod:`site` 구성을 사용하십시오. 이후 버전의 파이썬은 기본적으로 이 파인더를 활성화하지 않을 수 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1088
msgid ""
"A :term:`Finder <finder>` for :data:`sys.path` and package ``__path__`` "
"attributes. This class implements the "
":class:`importlib.abc.MetaPathFinder` ABC."
msgstr ""
":data:`sys.path`\\와 패키지 ``__path__`` 어트리뷰트용 :term:`파인더 <finder>`. 이 클래스는 "
":class:`importlib.abc.MetaPathFinder` ABC를 구현합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1096
msgid ""
"Class method that attempts to find a :term:`spec <module spec>` for the "
"module specified by *fullname* on :data:`sys.path` or, if defined, on "
"*path*. For each path entry that is searched, "
":data:`sys.path_importer_cache` is checked. If a non-false object is "
"found then it is used as the :term:`path entry finder` to look for the "
"module being searched for. If no entry is found in "
":data:`sys.path_importer_cache`, then :data:`sys.path_hooks` is searched "
"for a finder for the path entry and, if found, is stored in "
":data:`sys.path_importer_cache` along with being queried about the "
"module. If no finder is ever found then ``None`` is both stored in the "
"cache and returned."
msgstr ""
":data:`sys.path` 또는, 정의되었다면, *path*\\에서 *fullname*\\에 의해 지정된 모듈에 대한 "
":term:`스펙 <module spec>`\\을 찾으려고 시도하는 클래스 메서드. 검색된 각 경로 엔트리에 대해, "
":data:`sys.path_importer_cache`\\가 확인됩니다. 거짓이 아닌 객체를 찾으면 검색 중인 모듈을 찾기 위한 "
":term:`경로 엔트리 파인더 <path entry finder>`\\로 사용됩니다. "
":data:`sys.path_importer_cache`\\에 엔트리가 없으면, :data:`sys.path_hooks`\\에서 "
"경로 엔트리를 위한 파인더를 검색하고, 발견되면, 모듈에 대해 조회되는 것과 동시에 "
":data:`sys.path_importer_cache`\\에 저장됩니다. 파인더가 아예 발견되지 않으면 ``None``\\이 "
"캐시에 저장되고 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1110
msgid ""
"If the current working directory -- represented by an empty string -- is "
"no longer valid then ``None`` is returned but no value is cached in "
":data:`sys.path_importer_cache`."
msgstr ""
"현재 작업 디렉터리 -- 빈 문자열로 표현됩니다 -- 가 더는 유효하지 않으면 ``None``\\이 반환되지만 "
":data:`sys.path_importer_cache`\\에 값이 캐시 되지는 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1117
msgid "A legacy wrapper around :meth:`find_spec`."
msgstr ":meth:`find_spec`\\을 감싸는 레거시 래퍼."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1124
msgid ""
"Calls :meth:`importlib.abc.PathEntryFinder.invalidate_caches` on all "
"finders stored in :data:`sys.path_importer_cache` that define the method."
" Otherwise entries in :data:`sys.path_importer_cache` set to ``None`` are"
" deleted."
msgstr ""
"메서드를 정의하는 :data:`sys.path_importer_cache`\\에 저장된 모든 파인더에 대해 "
":meth:`importlib.abc.PathEntryFinder.invalidate_caches`\\를 호출합니다. "
":data:`sys.path_importer_cache`\\에 ``None``\\으로 설정된 엔트리가 삭제됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1129
msgid "Entries of ``None`` in :data:`sys.path_importer_cache` are deleted."
msgstr ":data:`sys.path_importer_cache`\\에서 ``None``\\의 엔트리가 삭제됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1132
msgid ""
"Calls objects in :data:`sys.path_hooks` with the current working "
"directory for ``''`` (i.e. the empty string)."
msgstr "``''``\\(즉 빈 문자열)에 대해서는 현재 작업 디렉터리로 :data:`sys.path_hooks`\\의 객체를 호출합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1139
msgid ""
"A concrete implementation of :class:`importlib.abc.PathEntryFinder` which"
" caches results from the file system."
msgstr "파일 시스템에서의 결과를 캐시 하는 :class:`importlib.abc.PathEntryFinder` 의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1142
msgid ""
"The *path* argument is the directory for which the finder is in charge of"
" searching."
msgstr "*path* 인자는 파인더가 검색을 담당하는 디렉터리입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1145
msgid ""
"The *loader_details* argument is a variable number of 2-item tuples each "
"containing a loader and a sequence of file suffixes the loader "
"recognizes. The loaders are expected to be callables which accept two "
"arguments of the module's name and the path to the file found."
msgstr ""
"*loader_details* 인자는 각각 로더와 로더가 인식하는 파일 접미사의 시퀀스를 포함하는 가변 개수의 2개 항목 "
"튜플입니다. 로더는 모듈 이름과 찾은 파일의 경로로 구성되는 두 인자를 받아들이는 콜러블일 것으로 기대됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1150
msgid ""
"The finder will cache the directory contents as necessary, making stat "
"calls for each module search to verify the cache is not outdated. Because"
" cache staleness relies upon the granularity of the operating system's "
"state information of the file system, there is a potential race condition"
" of searching for a module, creating a new file, and then searching for "
"the module the new file represents. If the operations happen fast enough "
"to fit within the granularity of stat calls, then the module search will "
"fail. To prevent this from happening, when you create a module "
"dynamically, make sure to call :func:`importlib.invalidate_caches`."
msgstr ""
"파인더는 필요에 따라 디렉터리 내용을 캐시 하여, 각 모듈 검색에서 stat 호출을 수행하여 캐시가 시효가 지나지 않았는지 "
"확인합니다. 캐시 만료는 파일 시스템의 운영 체제 상태 정보의 세분성에 의존하기 때문에, 모듈 검색, 새 파일 생성 및 새 파일이 "
"나타내는 모듈 검색의 잠재적 경쟁 조건이 있습니다. stat 호출의 세분성 이하로 연산이 아주 빠르게 수행되면, 모듈 검색이 "
"실패합니다. 이를 방지하려면, 모듈을 동적으로 만들 때, :func:`importlib.invalidate_caches`\\를 "
"호출해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1164
msgid "The path the finder will search in."
msgstr "파인더가 검색할 경로."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1168
msgid "Attempt to find the spec to handle *fullname* within :attr:`path`."
msgstr ":attr:`path` 내에서 *fullname*\\을 처리할 스펙을 찾으려고 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1174
msgid "Attempt to find the loader to handle *fullname* within :attr:`path`."
msgstr ":attr:`path` 내에서 *fullname*\\을 처리할 로더를 찾으려고 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1178
msgid "Clear out the internal cache."
msgstr "내부 캐시를 지웁니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1182
msgid ""
"A class method which returns a closure for use on :attr:`sys.path_hooks`."
" An instance of :class:`FileFinder` is returned by the closure using the "
"path argument given to the closure directly and *loader_details* "
"indirectly."
msgstr ""
":attr:`sys.path_hooks`\\에 사용할 클로저를 반환하는 클래스 메서드. :class:`FileFinder`\\의 "
"인스턴스는 클로저에 직접 제공된 경로 인자와 *loader_details*\\를 간접적으로 사용하여 클로저에 의해 반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1187
msgid ""
"If the argument to the closure is not an existing directory, "
":exc:`ImportError` is raised."
msgstr "클로저에 대한 인자가 기존 디렉터리가 아니면, :exc:`ImportError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1193
msgid ""
"A concrete implementation of :class:`importlib.abc.SourceLoader` by "
"subclassing :class:`importlib.abc.FileLoader` and providing some concrete"
" implementations of other methods."
msgstr ""
":class:`importlib.abc.FileLoader`\\를 서브 클래싱하고 다른 메서드의 구상 구현을 제공하는 "
":class:`importlib.abc.SourceLoader`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1201
msgid "The name of the module that this loader will handle."
msgstr "이 로더가 처리할 모듈의 이름."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1205
msgid "The path to the source file."
msgstr "소스 파일의 경로."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1209
msgid "Return ``True`` if :attr:`path` appears to be for a package."
msgstr ":attr:`path`\\가 패키지에 대한 것으로 드러나면 ``True``\\를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1213
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.path_stats`."
msgstr ":meth:`importlib.abc.SourceLoader.path_stats`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1217
msgid "Concrete implementation of :meth:`importlib.abc.SourceLoader.set_data`."
msgstr ":meth:`importlib.abc.SourceLoader.set_data`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1221
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1264
msgid ""
"Concrete implementation of :meth:`importlib.abc.Loader.load_module` where"
" specifying the name of the module to load is optional."
msgstr "로드할 모듈 이름을 지정하는 것이 선택적인 :meth:`importlib.abc.Loader.load_module`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1226
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1269
msgid "Use :meth:`importlib.abc.Loader.exec_module` instead."
msgstr "대신 :meth:`importlib.abc.Loader.exec_module`\\을 사용하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1231
msgid ""
"A concrete implementation of :class:`importlib.abc.FileLoader` which can "
"import bytecode files (i.e. no source code files exist)."
msgstr ""
"바이트 코드 파일을 (즉, 소스 코드 파일 없이) 임포트 할 수 있는 "
":class:`importlib.abc.FileLoader`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1234
msgid ""
"Please note that direct use of bytecode files (and thus not source code "
"files) inhibits your modules from being usable by all Python "
"implementations or new versions of Python which change the bytecode "
"format."
msgstr ""
"바이트 코드 파일(그래서 소스 코드 파일이 아닌)을 직접 사용하면 모든 파이썬 구현이나 바이트 코드 형식을 변경하는 새 버전의 "
"파이썬에서 모듈을 사용할 수 없게 됨에 유의하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1243
msgid "The name of the module the loader will handle."
msgstr "로더가 처리할 모듈의 이름."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1247
msgid "The path to the bytecode file."
msgstr "바이트 코드 파일의 경로."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1251
msgid "Determines if the module is a package based on :attr:`path`."
msgstr ":attr:`path`\\를 기반으로 모듈이 패키지인지 판단합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1255
msgid "Returns the code object for :attr:`name` created from :attr:`path`."
msgstr ":attr:`path`\\에서 만들어진 :attr:`name`\\의 코드 객체를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1259
msgid ""
"Returns ``None`` as bytecode files have no source when this loader is "
"used."
msgstr "이 로더가 사용될 때는 바이트 코드 파일에 소스가 없어서 ``None``\\을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1274
msgid ""
"A concrete implementation of :class:`importlib.abc.ExecutionLoader` for "
"extension modules."
msgstr "확장 모듈을 위한 :class:`importlib.abc.ExecutionLoader`\\의 구상 구현."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1277
msgid ""
"The *fullname* argument specifies the name of the module the loader is to"
" support. The *path* argument is the path to the extension module's file."
msgstr "*fullname* 인자는 로더가 지원할 모듈의 이름을 지정합니다. *path* 인자는 확장 모듈 파일의 경로입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1284
msgid "Name of the module the loader supports."
msgstr "로더가 지원하는 모듈의 이름."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1288
msgid "Path to the extension module."
msgstr "확장 모듈의 경로."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1292
msgid ""
"Creates the module object from the given specification in accordance with"
" :pep:`489`."
msgstr ":pep:`489`\\에 따라 지정된 명세에서 모듈 객체를 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1299
msgid "Initializes the given module object in accordance with :pep:`489`."
msgstr ":pep:`489`\\에 따라 주어진 모듈 객체를 초기화합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1305
msgid ""
"Returns ``True`` if the file path points to a package's ``__init__`` "
"module based on :attr:`EXTENSION_SUFFIXES`."
msgstr ""
":attr:`EXTENSION_SUFFIXES`\\에 기반해서 파일 경로가 패키지의 ``__init__`` 모듈을 가리키면 "
"``True``\\를 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1310
msgid "Returns ``None`` as extension modules lack a code object."
msgstr "확장 모듈에는 코드 객체가 없어서 ``None``\\을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1314
msgid "Returns ``None`` as extension modules do not have source code."
msgstr "확장 모듈에는 소스 코드가 없어서 ``None``\\을 반환합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1325
msgid ""
"A specification for a module's import-system-related state.  This is "
"typically exposed as the module's ``__spec__`` attribute.  In the "
"descriptions below, the names in parentheses give the corresponding "
"attribute available directly on the module object. E.g. "
"``module.__spec__.origin == module.__file__``.  Note however that while "
"the *values* are usually equivalent, they can differ since there is no "
"synchronization between the two objects.  Thus it is possible to update "
"the module's ``__path__`` at runtime, and this will not be automatically "
"reflected in ``__spec__.submodule_search_locations``."
msgstr ""
"모듈의 임포트 시스템 관련 상태에 대한 명세. 이것은 일반적으로 모듈의 ``__spec__`` 어트리뷰트로 노출됩니다. 아래 "
"설명에서, 괄호 안의 이름은 모듈 객체에서 직접 사용 가능한 해당 어트리뷰트를 제공합니다. 예를 들어: "
"``module.__spec__.origin == module.__file__``. 그러나 *values*\\는 일반적으로 "
"동등하지만, 두 객체 간에 동기화가 없기 때문에 다를 수 있음에 유의하십시오. 따라서 실행 시간에 모듈의 "
"``__path__``\\를 갱신할 수 있으며, 이는 ``__spec__.submodule_search_locations``\\에 "
"자동으로 반영되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1339
msgid "(``__name__``)"
msgstr "(``__name__``)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1341
msgid "A string for the fully-qualified name of the module."
msgstr "정규화된 모듈 이름의 문자열."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1345
msgid "(``__loader__``)"
msgstr "(``__loader__``)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1347
msgid ""
"The loader to use for loading.  For namespace packages this should be set"
" to ``None``."
msgstr "로딩에 사용할 로더. 이름 공간 패키지의 경우 ``None``\\으로 설정해야 합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1352
msgid "(``__file__``)"
msgstr "(``__file__``)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1354
msgid ""
"Name of the place from which the module is loaded, e.g. \"builtin\" for "
"built-in modules and the filename for modules loaded from source. "
"Normally \"origin\" should be set, but it may be ``None`` (the default) "
"which indicates it is unspecified (e.g. for namespace packages)."
msgstr ""
"모듈이 로드된 장소의 이름, 예를 들어, 내장 모듈의 경우 \"builtin\"이고 소스에서 로드한 모듈의 경우 파일명. 일반적으로"
" \"origin\"을 설정해야 하지만, 지정되지 않았음을 나타내는 ``None``\\(기본값)일 수 있습니다 (예를 들어 이름 "
"공간 패키지)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1361
msgid "(``__path__``)"
msgstr "(``__path__``)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1363
msgid ""
"List of strings for where to find submodules, if a package (``None`` "
"otherwise)."
msgstr "패키지이면, 서브 모듈을 찾을 수 있는 문자열 리스트 (그렇지 않으면 ``None``)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1368
msgid ""
"Container of extra module-specific data for use during loading (or "
"``None``)."
msgstr "로드 중 사용하기 위한 추가 모듈 특정 데이터의 컨테이너 (또는 ``None``)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1373
msgid "(``__cached__``)"
msgstr "(``__cached__``)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1375
msgid "String for where the compiled module should be stored (or ``None``)."
msgstr "컴파일된 모듈을 저장해야 하는 장소의 문자열 (또는 ``None``)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1379
msgid "(``__package__``)"
msgstr "(``__package__``)"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1381
msgid ""
"(Read-only) Fully-qualified name of the package to which the module "
"belongs as a submodule (or ``None``)."
msgstr "(읽기 전용) 모듈이 서브 모듈로 속하는 패키지의 정규화된 이름 (또는 ``None``)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1386
msgid ""
"Boolean indicating whether or not the module's \"origin\" attribute "
"refers to a loadable location."
msgstr "모듈의 \"origin\" 어트리뷰트가 로드 가능한 위치를 나타내는지를 나타내는 불리언."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1390
msgid ":mod:`importlib.util` -- Utility code for importers"
msgstr ":mod:`importlib.util` -- 임포터를 위한 유틸리티 코드"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1396
msgid "**Source code:** :source:`Lib/importlib/util.py`"
msgstr "**소스 코드:** :source:`Lib/importlib/util.py`"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1400
msgid ""
"This module contains the various objects that help in the construction of"
" an :term:`importer`."
msgstr "이 모듈에는 :term:`임포터 <importer>` 구성에 도움이 되는 다양한 객체가 포함되어 있습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1405
msgid ""
"The bytes which represent the bytecode version number. If you need help "
"with loading/writing bytecode then consider "
":class:`importlib.abc.SourceLoader`."
msgstr ""
"바이트 코드 버전 번호를 나타내는 바이트열. 바이트 코드의 로드/쓰기에 도움이 필요하면 "
":class:`importlib.abc.SourceLoader`\\를 고려하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1412
msgid ""
"Return the :pep:`3147`/:pep:`488` path to the byte-compiled file "
"associated with the source *path*.  For example, if *path* is "
"``/foo/bar/baz.py`` the return value would be "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` for Python 3.2. The "
"``cpython-32`` string comes from the current magic tag (see "
":func:`get_tag`; if :attr:`sys.implementation.cache_tag` is not defined "
"then :exc:`NotImplementedError` will be raised)."
msgstr ""
"소스 *path*\\와 연관된 바이트 컴파일된 파일의 :pep:`3147`/:pep:`488` 경로를 반환합니다. 예를 들어, "
"*path*\\가 ``/foo/bar/baz.py``\\이면 반환값은 파이썬 3.2의 경우 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``\\입니다. ``cpython-32`` 문자열은 현재 "
"매직 태그에서 온 것입니다 (:func:`get_tag`\\를 참조하십시오; "
":attr:`sys.implementation.cache_tag`\\가 정의되지 않으면 "
":exc:`NotImplementedError` 가 발생합니다)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1419
msgid ""
"The *optimization* parameter is used to specify the optimization level of"
" the bytecode file. An empty string represents no optimization, so "
"``/foo/bar/baz.py`` with an *optimization* of ``''`` will result in a "
"bytecode path of ``/foo/bar/__pycache__/baz.cpython-32.pyc``. ``None`` "
"causes the interpreter's optimization level to be used. Any other value's"
" string representation is used, so ``/foo/bar/baz.py`` with an "
"*optimization* of ``2`` will lead to the bytecode path of "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``. The string "
"representation of *optimization* can only be alphanumeric, else "
":exc:`ValueError` is raised."
msgstr ""
"*optimization* 매개 변수는 바이트 코드 파일의 최적화 수준을 지정하는 데 사용됩니다. 빈 문자열은 최적화하지 않음을 "
"나타내므로, *optimization*\\이 ``''`` 인 ``/foo/bar/baz.py``\\는 바이트 코드 경로가 "
"``/foo/bar/__pycache__/baz.cpython-32.pyc``\\가 됩니다. ``None``\\은 인터프리터의 "
"최적화 수준이 사용되도록 합니다. 다른 값의 문자열 표현은 사용되므로, *optimization*\\이 ``2``\\인 "
"``/foo/bar/baz.py``\\는 바이트 코드 경로가 "
"``/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc``\\가 됩니다. "
"*optimization*\\의 문자열 표현은 영숫자만 가능하며, 그렇지 않으면 :exc:`ValueError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1429
msgid ""
"The *debug_override* parameter is deprecated and can be used to override "
"the system's value for ``__debug__``. A ``True`` value is the equivalent "
"of setting *optimization* to the empty string. A ``False`` value is the "
"same as setting *optimization* to ``1``. If both *debug_override* an "
"*optimization* are not ``None`` then :exc:`TypeError` is raised."
msgstr ""
"*debug_override* 매개 변수는 폐지되었고 ``__debug__``\\의 시스템값을 대체하는 데 사용할 수 있습니다. "
"``True`` 값은 *optimization*\\을 빈 문자열로 설정하는 것과 등등합니다. ``False`` 값은 "
"*optimization*\\을 ``1``\\로 설정하는 것과 같습니다. *debug_override*\\와 "
"*optimization*\\이 모두 ``None``\\이 아니면 :exc:`TypeError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1437
msgid ""
"The *optimization* parameter was added and the *debug_override* parameter"
" was deprecated."
msgstr "*optimization* 매개 변수가 추가되었고 *debug_override* 매개 변수는 폐지되었습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1441
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1457
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1606
msgid "Accepts a :term:`path-like object`."
msgstr ":term:`경로류 객체 <path-like object>`\\를 받아들입니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1447
msgid ""
"Given the *path* to a :pep:`3147` file name, return the associated source"
" code file path.  For example, if *path* is "
"``/foo/bar/__pycache__/baz.cpython-32.pyc`` the returned path would be "
"``/foo/bar/baz.py``.  *path* need not exist, however if it does not "
"conform to :pep:`3147` or :pep:`488` format, a :exc:`ValueError` is "
"raised. If :attr:`sys.implementation.cache_tag` is not defined, "
":exc:`NotImplementedError` is raised."
msgstr ""
"*path*\\에 :pep:`3147` 파일 이름이 주어지면, 연관된 소스 코드 파일 경로를 반환합니다. 예를 들어, "
"*path*\\가 ``/foo/bar/__pycache__/baz.cpython-32.pyc``\\이면 반환된 경로는 "
"``/foo/bar/baz.py``\\입니다. *path*\\는 존재할 필요는 없지만, :pep:`3147`\\이나 "
":pep:`488` 형식을 준수하지 않으면, :exc:`ValueError`\\가 발생합니다. "
":attr:`sys.implementation.cache_tag`\\가 정의되지 않으면, "
":exc:`NotImplementedError` 가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1462
msgid ""
"Decode the given bytes representing source code and return it as a string"
" with universal newlines (as required by "
":meth:`importlib.abc.InspectLoader.get_source`)."
msgstr ""
"소스 코드를 나타내는 주어진 바이트열을 디코딩하고 유니버설 줄 넘김이 적용된 문자열로 반환합니다 "
"(:meth:`importlib.abc.InspectLoader.get_source`\\에 필요한 대로)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1470
msgid "Resolve a relative module name to an absolute one."
msgstr "상대 모듈 이름을 절대 이름으로 결정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1472
msgid ""
"If  **name** has no leading dots, then **name** is simply returned. This "
"allows for usage such as ``importlib.util.resolve_name('sys', "
"__package__)`` without doing a check to see if the **package** argument "
"is needed."
msgstr ""
"**name** 선두에 점이 없으면, **name**\\이 단순히 반환됩니다. 이를 통해 **package** 인자가 필요한지 "
"확인하지 않고 ``importlib.util.resolve_name('sys', __package__)``\\와 같은 사용이 "
"가능합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1477
#, fuzzy
msgid ""
":exc:`ImportError` is raised if **name** is a relative module name but "
"**package** is a false value (e.g. ``None`` or the empty string). "
":exc:`ImportError` is also raised a relative name would escape its "
"containing package (e.g. requesting ``..bacon`` from within the ``spam`` "
"package)."
msgstr ""
"**name**\\이 상대 모듈 이름이지만 package가 거짓 값(예를 들어 ``None``\\이나 빈 문자열)이면 "
":exc:`ValueError`\\가 발생합니다. :exc:`ValueError`\\는 또한 상대 이름이 그것을 포함하는 패키지를 "
"벗어날 것 같으면 발생합니다 (예를 들어 ``spam`` 패키지 내에서 ``..bacon``\\을 요청하는 것)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1484
msgid ""
"To improve consistency with import statements, raise :exc:`ImportError` "
"instead of :exc:`ValueError` for invalid relative import attempts."
msgstr ""

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1491
msgid ""
"Find the :term:`spec <module spec>` for a module, optionally relative to "
"the specified **package** name. If the module is in :attr:`sys.modules`, "
"then ``sys.modules[name].__spec__`` is returned (unless the spec would be"
" ``None`` or is not set, in which case :exc:`ValueError` is raised). "
"Otherwise a search using :attr:`sys.meta_path` is done. ``None`` is "
"returned if no spec is found."
msgstr ""
"선택적으로 지정된 **package** 이름에 상대적으로, 모듈의 :term:`스펙 <module spec>`\\을 찾습니다. "
"모듈이 :attr:`sys.modules`\\에 있으면, ``sys.modules[name].__spec__``\\이 반환됩니다 "
"(스펙이 ``None``\\이 되거나 설정되지 않지 않은 한, 그럴 경우는 :exc:`ValueError`\\가 발생합니다). "
"그렇지 않으면 :attr:`sys.meta_path`\\를 사용한 검색이 수행됩니다. 스펙을 찾지 못하면 ``None``\\이 "
"반환됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1498
msgid ""
"If **name** is for a submodule (contains a dot), the parent module is "
"automatically imported."
msgstr "**name**\\이 서브 모듈에 관한 것이면 (점을 포함하면), 부모 모듈은 자동으로 임포트 됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1501
msgid "**name** and **package** work the same as for :func:`import_module`."
msgstr "**name**\\과 **package**\\는 :func:`import_module`\\과 같게 작동합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1505
msgid ""
"Raises :exc:`ModuleNotFoundError` instead of :exc:`AttributeError` if "
"**package** is in fact not a package (i.e. lacks a :attr:`__path__` "
"attribute)."
msgstr ""
"**package**\\가 실제로 패키지가 아니면 (즉 :attr:`__path__` 어트리뷰트가 없으면) "
":exc:`AttributeError` 대신 :exc:`ModuleNotFoundError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1512
msgid ""
"Create a new module based on **spec** and "
":meth:`spec.loader.create_module <importlib.abc.Loader.create_module>`."
msgstr ""
"**spec**\\과 :meth:`spec.loader.create_module "
"<importlib.abc.Loader.create_module>`\\을 기반으로 새 모듈을 만듭니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1515
msgid ""
"If :meth:`spec.loader.create_module <importlib.abc.Loader.create_module>`"
" does not return ``None``, then any pre-existing attributes will not be "
"reset. Also, no :exc:`AttributeError` will be raised if triggered while "
"accessing **spec** or setting an attribute on the module."
msgstr ""
":meth:`spec.loader.create_module <importlib.abc.Loader.create_module>`\\이"
" ``None``\\을 반환하지 않으면, 어떤 기존 어트리뷰트도 재설정되지 않습니다. 또한 **spec**\\에 액세스하거나 "
"모듈에서 어트리뷰트를 설정하는 동안 트리거 되면 :exc:`AttributeError`\\가 발생하지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1520
msgid ""
"This function is preferred over using :class:`types.ModuleType` to create"
" a new module as **spec** is used to set as many import-controlled "
"attributes on the module as possible."
msgstr ""
"**spec**\\은 모듈에서 가능한 많은 임포트 제어 어트리뷰트를 설정하는 데 사용되므로 새 모듈을 작성하는 데 "
":class:`types.ModuleType`\\을 사용하는 것보다 이 함수가 선호됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1528
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to "
"handle selecting the proper module object to load with. The decorated "
"method is expected to have a call signature taking two positional "
"arguments (e.g. ``load_module(self, module)``) for which the second "
"argument will be the module **object** to be used by the loader. Note "
"that the decorator will not work on static methods because of the "
"assumption of two arguments."
msgstr ""
"로드할 적절한 모듈 객체 선택을 처리하기 위한 :meth:`importlib.abc.Loader.load_module` 용 "
":term:`데코레이터 <decorator>`. 데코레이팅 된 메서드에는 두 개의 위치 인자를 취하는 호출 서명을 가질 것으로 "
"기대됩니다 (예를 들어 ``load_module(self, module)``), 두 번째 인자는 로더가 사용할 모듈 "
"**객체**\\입니다. 데코레이터는 두 개의 인자를 가정하기 때문에 정적 메서드에서 작동하지 않음에 유의하십시오."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1537
msgid ""
"The decorated method will take in the **name** of the module to be loaded"
" as expected for a :term:`loader`. If the module is not found in "
":data:`sys.modules` then a new one is constructed. Regardless of where "
"the module came from, :attr:`__loader__` set to **self** and "
":attr:`__package__` is set based on what "
":meth:`importlib.abc.InspectLoader.is_package` returns (if available). "
"These attributes are set unconditionally to support reloading."
msgstr ""
"데코레이팅 된 메서드는 :term:`로더 <loader>`\\에 대해 로드될 모듈 **이름**\\을 취합니다. "
":data:`sys.modules`\\에 모듈이 없으면 새로운 모듈이 구성됩니다. 모듈의 출처와 관계없이, "
":attr:`__loader__`\\는 **self**\\로 설정되고 :attr:`__package__`\\는 "
":meth:`importlib.abc.InspectLoader.is_package`\\가 반환하는 것에 따라 설정됩니다 (사용 "
"가능하다면). 이러한 어트리뷰트는 재로드를 지원하도록 무조건 설정됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1545
msgid ""
"If an exception is raised by the decorated method and a module was added "
"to :data:`sys.modules`, then the module will be removed to prevent a "
"partially initialized module from being in left in :data:`sys.modules`. "
"If the module was already in :data:`sys.modules` then it is left alone."
msgstr ""
"데코레이트 된 메서드가 예외를 발생시키고 :data:`sys.modules`\\에 모듈이 추가되었으면, 부분적으로 초기화된 모듈이 "
":data:`sys.modules`\\에 남아 있지 않도록 모듈이 제거됩니다. 모듈이 이미 :data:`sys.modules`\\에"
" 있었다면 모듈은 그대로 유지됩니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1550
msgid ""
":attr:`__loader__` and :attr:`__package__` are automatically set (when "
"possible)."
msgstr ":attr:`__loader__`\\와 :attr:`__package__`\\는 자동으로 설정됩니다 (가능하면)."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1554
msgid ""
"Set :attr:`__name__`, :attr:`__loader__` :attr:`__package__` "
"unconditionally to support reloading."
msgstr ""
"재로드를 지원하기 위해 :attr:`__name__`, :attr:`__loader__` :attr:`__package__`\\를 "
"무조건 설정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1558
msgid ""
"The import machinery now directly performs all the functionality provided"
" by this function."
msgstr "임포트 절차는 이제 이 함수가 제공하는 모든 기능을 직접 수행합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1564
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set "
"the :attr:`__loader__` attribute on the returned module. If the attribute"
" is already set the decorator does nothing. It is assumed that the first "
"positional argument to the wrapped method (i.e. ``self``) is what "
":attr:`__loader__` should be set to."
msgstr ""
"반환된 모듈에서 :attr:`__loader__` 어트리뷰트를 설정하기 위한 "
":meth:`importlib.abc.Loader.load_module` 용 :term:`데코레이터 <decorator>`. "
"어트리뷰트가 이미 설정되어 있으면 데코레이터는 아무것도 하지 않습니다. 래핑 된 메서드에 대한 첫 번째 위치 인자(즉, "
"``self``)가 :attr:`__loader__`\\가 설정되어야 하는 것으로 가정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1571
msgid "Set ``__loader__`` if set to ``None``, as if the attribute does not exist."
msgstr "어트리뷰트가 존재하지 않는 것처럼, ``None``\\으로 설정되었으면 ``__loader__``\\를 설정합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1575
#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1584
msgid "The import machinery takes care of this automatically."
msgstr "임포트 절차는 이것을 자동으로 처리합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1580
msgid ""
"A :term:`decorator` for :meth:`importlib.abc.Loader.load_module` to set "
"the :attr:`__package__` attribute on the returned module. If "
":attr:`__package__` is set and has a value other than ``None`` it will "
"not be changed."
msgstr ""
"반환된 모듈에서 :attr:`__package__` 어트리뷰트를 설정하기 위한 "
":meth:`importlib.abc.Loader.load_module` 용 :term:`데코레이터 <decorator>`. "
":attr:`__package__`\\가 설정되었고 ``None`` 이외의 값을 가지면 변경되지 않습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1589
msgid ""
"A factory function for creating a :class:`ModuleSpec` instance based on a"
" loader.  The parameters have the same meaning as they do for ModuleSpec."
"  The function uses available :term:`loader` APIs, such as "
":meth:`InspectLoader.is_package`, to fill in any missing information on "
"the spec."
msgstr ""
"로더(loader)를 기반으로 :class:`ModuleSpec` 인스턴스를 만들기 위한 팩토리 함수. 매개 변수는 "
"ModuleSpec에서와 같은 의미입니다. 이 함수는 :meth:`InspectLoader.is_package`\\와 같은 사용 "
"가능한 :term:`로더 <loader>` API를 사용하여 스펙에 빠진 정보를 채웁니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1599
msgid ""
"A factory function for creating a :class:`ModuleSpec` instance based on "
"the path to a file.  Missing information will be filled in on the spec by"
" making use of loader APIs and by the implication that the module will be"
" file-based."
msgstr ""
"파일 경로를 기반으로 :class:`ModuleSpec` 인스턴스를 만드는 팩토리 함수. 로더 API를 사용하고 모듈이 파일 기반일"
" 것이라는 것이 뜻하는 것으로 누락된 정보가 스펙에 채워집니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1611
msgid ""
"Return the hash of *source_bytes* as bytes. A hash-based ``.pyc`` file "
"embeds the :func:`source_hash` of the corresponding source file's "
"contents in its header."
msgstr ""
"*source_bytes*\\의 해시를 바이트열로 반환합니다. 해시 기반 ``.pyc`` 파일은 해당 소스 파일 내용의 "
":func:`source_hash`\\를 헤더에 포함합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1619
msgid ""
"A class which postpones the execution of the loader of a module until the"
" module has an attribute accessed."
msgstr "모듈이 어트리뷰트에 액세스할 때까지 모듈 로더의 실행을 연기하는 클래스."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1622
msgid ""
"This class **only** works with loaders that define "
":meth:`~importlib.abc.Loader.exec_module` as control over what module "
"type is used for the module is required. For those same reasons, the "
"loader's :meth:`~importlib.abc.Loader.create_module` method must return "
"``None`` or a type for which its ``__class__`` attribute can be mutated "
"along with not using :term:`slots <__slots__>`. Finally, modules which "
"substitute the object placed into :attr:`sys.modules` will not work as "
"there is no way to properly replace the module references throughout the "
"interpreter safely; :exc:`ValueError` is raised if such a substitution is"
" detected."
msgstr ""
"이 클래스는 필요한 모듈 형에 대한 제어로 :meth:`~importlib.abc.Loader.exec_module`\\을 정의하는"
" 로더\\**에서만** 작동합니다. 같은 이유로, 로더의 "
":meth:`~importlib.abc.Loader.create_module` 메서드는 ``None``\\을 반환하거나, "
":term:`슬롯 <__slots__>`\\을 사용하지 않고 ``__class__`` 어트리뷰트가 변경될 수 있는 형을 반환해야 "
"합니다. 마지막으로, :attr:`sys.modules`\\에 배치된 객체를 치환하는 모듈은 인터프리터 전체에서 모듈 참조를 "
"안전하게 대체할 방법이 없어서 작동하지 않습니다; 이러한 치환이 감지되면 :exc:`ValueError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1633
msgid ""
"For projects where startup time is critical, this class allows for "
"potentially minimizing the cost of loading a module if it is never used. "
"For projects where startup time is not essential then use of this class "
"is **heavily** discouraged due to error messages created during loading "
"being postponed and thus occurring out of context."
msgstr ""
"시작 시간이 중요한 프로젝트의 경우, 이 클래스를 사용하면 사용하지 않을 모듈을 로드하는 데 드는 비용을 최소화할 수 있습니다. "
"시작 시간이 핵심이 아닌 프로젝트의 경우 로딩이 지연되는 동안 만들어진, 따라서 문맥을 벗어난 에러 메시지 때문에, 이 클래스를 "
"사용하지 말 것을 **강하게** 권고합니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1641
msgid ""
"Began calling :meth:`~importlib.abc.Loader.create_module`, removing the "
"compatibility warning for :class:`importlib.machinery.BuiltinImporter` "
"and :class:`importlib.machinery.ExtensionFileLoader`."
msgstr ""
":class:`importlib.machinery.BuiltinImporter`\\와 "
":class:`importlib.machinery.ExtensionFileLoader` 에 대한 호환성 경고를 제거하고, "
":meth:`~importlib.abc.Loader.create_module`\\을 호출하기 시작했습니다."

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1648
msgid ""
"A static method which returns a callable that creates a lazy loader. This"
" is meant to be used in situations where the loader is passed by class "
"instead of by instance. ::"
msgstr ""
"지연된 로더(lazy loader)를 만드는 콜러블을 반환하는 정적 메서드. 이것은 로더가 인스턴스가 아닌 클래스로 전달되는 "
"상황에서 사용하려는 것입니다. ::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1661
msgid "Examples"
msgstr "예"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1664
msgid "Importing programmatically"
msgstr "프로그래밍 방식으로 임포트 하기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1666
msgid ""
"To programmatically import a module, use :func:`importlib.import_module`."
" ::"
msgstr "프로그래밍 방식으로 모듈을 임포트 하려면, :func:`importlib.import_module`\\을 사용하십시오. ::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1675
msgid "Checking if a module can be imported"
msgstr "모듈을 임포트 할 수 있는지 확인하기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1677
msgid ""
"If you need to find out if a module can be imported without actually "
"doing the import, then you should use :func:`importlib.util.find_spec`. "
"::"
msgstr ""
"실제로 임포트를 수행하지 않고 모듈을 임포트 할 수 있는지 확인해야 하면, "
":func:`importlib.util.find_spec`\\을 사용해야 합니다. ::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1700
msgid "Importing a source file directly"
msgstr "소스 파일을 직접 임포트 하기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1702
msgid ""
"To import a Python source file directly, use the following recipe (Python"
" 3.5 and newer only)::"
msgstr "파이썬 소스 파일을 직접 임포트 하려면, 다음 조리법을 사용하십시오 (파이썬 3.5 이상)::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1721
msgid "Setting up an importer"
msgstr "임포터 설정하기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1723
msgid ""
"For deep customizations of import, you typically want to implement an "
":term:`importer`. This means managing both the :term:`finder` and "
":term:`loader` side of things. For finders there are two flavours to "
"choose from depending on your needs: a :term:`meta path finder` or a "
":term:`path entry finder`. The former is what you would put on "
":attr:`sys.meta_path` while the latter is what you create using a "
":term:`path entry hook` on :attr:`sys.path_hooks` which works with "
":attr:`sys.path` entries to potentially create a finder. This example "
"will show you how to register your own importers so that import will use "
"them (for creating an importer for yourself, read the documentation for "
"the appropriate classes defined within this package)::"
msgstr ""
"임포트의 심층 사용자 정의를 위해서는, 일반적으로 :term:`임포터 <importer>`\\를 구현하려고 합니다. 이는 "
":term:`파인더 <finder>`\\와 :term:`로더 <loader>` 측면을 모두 관리한다는 의미입니다. 파인더에는 필요에"
" 따라 두 가지 종류가 있습니다: :term:`메타 경로 파인더 <meta path finder>`\\나 :term:`경로 엔트리 "
"파인더 <path entry finder>`. 전자는 :attr:`sys.meta_path`\\에 배치하는 것이고 후자는 "
":attr:`sys.path_hooks`\\에서 :term:`경로 엔트리 훅 <path entry hook>`\\을 사용하여 만드는"
" 것으로 :attr:`sys.path` 항목과 함께 작동하여 파인더를 만듭니다. 이 예제는 임포트가 임포터를 사용할 수 있도록 "
"임포터를 등록하는 방법을 보여줍니다 (임포터를 직접 만들려면, 이 패키지에 정의된 적절한 클래스의 설명서를 읽으십시오)::"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1755
msgid "Approximating :func:`importlib.import_module`"
msgstr ":func:`importlib.import_module` 근사하기"

#: /Users/flowdas/works/docs/python-docs-ko/src/Doc/library/importlib.rst:1757
msgid ""
"Import itself is implemented in Python code, making it possible to expose"
" most of the import machinery through importlib. The following helps "
"illustrate the various APIs that importlib exposes by providing an "
"approximate implementation of :func:`importlib.import_module` (Python 3.4"
" and newer for the importlib usage, Python 3.6 and newer for other parts "
"of the code). ::"
msgstr ""
"임포트 자체는 파이썬 코드로 구현되므로, importlib를 통해 대부분의 임포트 절차를 노출할 수 있습니다. 다음은 "
":func:`importlib.import_module`\\의 근사적인(approximate) 구현을 제공하여 importlib가 "
"노출하는 다양한 API를 설명하는 데 도움을 줍니다 (importlib 사용법에 대해서는 파이썬 3.4 이상, 코드의 다른 부분에 "
"대해서는 파이썬 3.6 이상). ::"

