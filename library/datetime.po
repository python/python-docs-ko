# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-15 15:23+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/datetime.rst:2
msgid ":mod:`datetime` --- Basic date and time types"
msgstr ":mod:`datetime` --- 기본 날짜와 시간 형"

#: ../Doc/library/datetime.rst:11
msgid "**Source code:** :source:`Lib/datetime.py`"
msgstr "**소스 코드:** :source:`Lib/datetime.py`"

#: ../Doc/library/datetime.rst:17
msgid ""
"The :mod:`datetime` module supplies classes for manipulating dates and "
"times in both simple and complex ways.  While date and time arithmetic is"
" supported, the focus of the implementation is on efficient attribute "
"extraction for output formatting and manipulation. For related "
"functionality, see also the :mod:`time` and :mod:`calendar` modules."
msgstr ""
":mod:`datetime` 모듈은 날짜와 시간을 간단하거나 복잡한 방법으로 조작하는 클래스를 제공합니다. 날짜와 시간 산술이 "
"지원되지만, 구현의 초점은 출력 포매팅과 조작을 위한 효율적인 어트리뷰트 추출입니다. 관련 기능에 대해서는, "
":mod:`time`\\과 :mod:`calendar` 모듈도 참조하십시오."

#: ../Doc/library/datetime.rst:23
msgid "There are two kinds of date and time objects: \"naive\" and \"aware\"."
msgstr "날짜와 시간 객체에는 두 가지 종류가 있습니다: \"나이브(naive)\"와 \"어웨어(aware)\"."

#: ../Doc/library/datetime.rst:25
msgid ""
"An aware object has sufficient knowledge of applicable algorithmic and "
"political time adjustments, such as time zone and daylight saving time "
"information, to locate itself relative to other aware objects.  An aware "
"object is used to represent a specific moment in time that is not open to"
" interpretation [#]_."
msgstr ""
"어웨어 객체는 다른 어웨어 객체와의 상대적인 위치를 파악하기 위한, 시간대와 일광 절약 시간 정보와 같은 적용 가능한 알고리즘과 "
"정치적 시간 조정에 대한 충분한 지식을 갖추고 있습니다. 어웨어 객체는 자의적으로 해석할 여지 없는 특정 시간을 나타내기 위해 "
"사용됩니다 [#]_."

#: ../Doc/library/datetime.rst:31
msgid ""
"A naive object does not contain enough information to unambiguously "
"locate itself relative to other date/time objects.  Whether a naive "
"object represents Coordinated Universal Time (UTC), local time, or time "
"in some other timezone is purely up to the program, just like it is up to"
" the program whether a particular number represents metres, miles, or "
"mass.  Naive objects are easy to understand and to work with, at the cost"
" of ignoring some aspects of reality."
msgstr ""
"나이브 객체는 모호하지 않게 자신과 다른 날짜/시간 객체의 상대적인 위치를 파악할 수 있는 충분한 정보를 포함하지 않습니다. 나이브"
" 객체가 UTC(Coordinated Universal Time), 지역 시간 또는 다른 시간대의 시간 중 어느 것을 나타내는지는 "
"순전히 프로그램에 달려있습니다. 특정 숫자가 미터, 마일 또는 질량 중 어는 것을 나타내는지가 프로그램에 달린 것과 마찬가지입니다."
" 나이브 객체는 이해하기 쉽고 작업하기 쉽지만, 현실의 일부 측면을 무시하는 대가를 치릅니다."

#: ../Doc/library/datetime.rst:38
msgid ""
"For applications requiring aware objects, :class:`.datetime` and "
":class:`.time` objects have an optional time zone information attribute, "
":attr:`!tzinfo`, that can be set to an instance of a subclass of the "
"abstract :class:`tzinfo` class. These :class:`tzinfo` objects capture "
"information about the offset from UTC time, the time zone name, and "
"whether Daylight Saving Time is in effect.  Note that only one concrete "
":class:`tzinfo` class, the :class:`timezone` class, is supplied by the "
":mod:`datetime` module.  The :class:`timezone` class can represent simple"
" timezones with fixed offset from UTC, such as UTC itself or North "
"American EST and EDT timezones.  Supporting timezones at deeper levels of"
" detail is up to the application.  The rules for time adjustment across "
"the world are more political than rational, change frequently, and there "
"is no standard suitable for every application aside from UTC."
msgstr ""
"어웨어 객체가 필요한 응용 프로그램을 위해, :class:`.datetime` 과 :class:`.time` 객체에는 추상 "
":class:`tzinfo` 클래스의 서브 클래스 인스턴스로 설정할 수 있는 선택적 시간대 정보 어트리뷰트인 "
":attr:`!tzinfo`\\가 있습니다. 이러한 :class:`tzinfo` 객체는 UTC 시간으로부터의 오프셋, 시간대 이름 "
"및 일광 절약 시간이 적용되는지에 대한 정보를 보관합니다. :mod:`datetime` 모듈에서는 오직 하나의 구상 "
":class:`tzinfo` 클래스, :class:`timezone` 클래스만 제공됨에 유의하십시오. "
":class:`timezone` 클래스는 UTC 자체나 북미 EST와 EDT 시간대와 같은 UTC로부터 고정 오프셋을 갖는 간단한 "
"시간대를 나타낼 수 있습니다. 더욱 세부적인 수준의 시간대 지원은 응용 프로그램에 달려 있습니다. 전 세계의 시간 조정에 대한 "
"규칙은 합리적이라기보다 정치적이고, 자주 변경되며, UTC 이외에 모든 응용 프로그램에 적합한 표준은 없습니다."

#: ../Doc/library/datetime.rst:51
msgid "The :mod:`datetime` module exports the following constants:"
msgstr ":mod:`datetime` 모듈은 다음 상수를 내보냅니다:"

#: ../Doc/library/datetime.rst:55
msgid ""
"The smallest year number allowed in a :class:`date` or :class:`.datetime`"
" object. :const:`MINYEAR` is ``1``."
msgstr ""
":class:`date`\\나 :class:`.datetime` 객체에서 허용되는 가장 작은 연도 번호. "
":const:`MINYEAR`\\는 ``1``\\입니다."

#: ../Doc/library/datetime.rst:61
msgid ""
"The largest year number allowed in a :class:`date` or :class:`.datetime` "
"object. :const:`MAXYEAR` is ``9999``."
msgstr ""
":class:`date`\\나 :class:`.datetime` 객체에서 허용되는 가장 큰 연도 번호. "
":const:`MAXYEAR`\\는 ``9999``\\입니다."

#: ../Doc/library/datetime.rst:68
msgid "Module :mod:`calendar`"
msgstr "모듈 :mod:`calendar`"

#: ../Doc/library/datetime.rst:68
msgid "General calendar related functions."
msgstr "일반 달력 관련 함수들."

#: ../Doc/library/datetime.rst:70
msgid "Module :mod:`time`"
msgstr "모듈 :mod:`time`"

#: ../Doc/library/datetime.rst:71
msgid "Time access and conversions."
msgstr "시간 액세스와 변환."

#: ../Doc/library/datetime.rst:75
msgid "Available Types"
msgstr "사용 가능한 형"

#: ../Doc/library/datetime.rst:80
msgid ""
"An idealized naive date, assuming the current Gregorian calendar always "
"was, and always will be, in effect. Attributes: :attr:`year`, "
":attr:`month`, and :attr:`day`."
msgstr ""
"현재의 그레고리력이 언제나 적용되어왔고, 앞으로도 그럴 것이라는 가정하에 이상적인 나이브 날짜. 어트리뷰트: "
":attr:`year`, :attr:`month` 및 :attr:`day`."

#: ../Doc/library/datetime.rst:88
msgid ""
"An idealized time, independent of any particular day, assuming that every"
" day has exactly 24\\*60\\*60 seconds (there is no notion of \"leap "
"seconds\" here). Attributes: :attr:`hour`, :attr:`minute`, "
":attr:`second`, :attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"특정 날짜와 관계없이, 하루가 정확히 24\\*60\\*60초를 갖는다는 가정하에 이상적인 시간 (여기에는 \"윤초\"라는 개념이 "
"없습니다). 어트리뷰트: :attr:`hour`, :attr:`minute`, :attr:`second`, "
":attr:`microsecond` 및 :attr:`.tzinfo`."

#: ../Doc/library/datetime.rst:97
msgid ""
"A combination of a date and a time. Attributes: :attr:`year`, "
":attr:`month`, :attr:`day`, :attr:`hour`, :attr:`minute`, :attr:`second`,"
" :attr:`microsecond`, and :attr:`.tzinfo`."
msgstr ""
"날짜와 시간의 조합. 어트리뷰트: :attr:`year`, :attr:`month`, :attr:`day`, "
":attr:`hour`, :attr:`minute`, :attr:`second`, :attr:`microsecond` 및 "
":attr:`.tzinfo`."

#: ../Doc/library/datetime.rst:105
msgid ""
"A duration expressing the difference between two :class:`date`, "
":class:`.time`, or :class:`.datetime` instances to microsecond "
"resolution."
msgstr ""
"두 :class:`date`, :class:`.time` 또는 :class:`.datetime` 인스턴스 간의 차이를 마이크로초 "
"해상도로 나타내는 기간."

#: ../Doc/library/datetime.rst:112
msgid ""
"An abstract base class for time zone information objects.  These are used"
" by the :class:`.datetime` and :class:`.time` classes to provide a "
"customizable notion of time adjustment (for example, to account for time "
"zone and/or daylight saving time)."
msgstr ""
"시간대 정보 객체의 추상 베이스 클래스. 이것들은 :class:`.datetime`\\와 :class:`.time` 클래스에서 "
"사용자 정의할 수 있는 시간 조정 개념(예를 들어, 시간대와/나 일광 절약 시간을 다루는 것)을 제공하기 위해 사용됩니다."

#: ../Doc/library/datetime.rst:120
msgid ""
"A class that implements the :class:`tzinfo` abstract base class as a "
"fixed offset from the UTC."
msgstr ":class:`tzinfo` 추상 베이스 클래스를 구현하는 클래스로, UTC로부터의 고정 오프셋을 나타냅니다."

#: ../Doc/library/datetime.rst:126
msgid "Objects of these types are immutable."
msgstr "이러한 형의 객체는 불변입니다."

#: ../Doc/library/datetime.rst:128
msgid "Objects of the :class:`date` type are always naive."
msgstr ":class:`date` 형의 객체는 항상 나이브합니다."

#: ../Doc/library/datetime.rst:130
msgid ""
"An object of type :class:`.time` or :class:`.datetime` may be naive or "
"aware. A :class:`.datetime` object *d* is aware if ``d.tzinfo`` is not "
"``None`` and ``d.tzinfo.utcoffset(d)`` does not return ``None``.  If "
"``d.tzinfo`` is ``None``, or if ``d.tzinfo`` is not ``None`` but "
"``d.tzinfo.utcoffset(d)`` returns ``None``, *d* is naive.  A "
":class:`.time` object *t* is aware if ``t.tzinfo`` is not ``None`` and "
"``t.tzinfo.utcoffset(None)`` does not return ``None``.  Otherwise, *t* is"
" naive."
msgstr ""
":class:`.time`\\나 :class:`.datetime` 형의 객체는 나이브하거나 어웨어할 수 있습니다. "
":class:`.datetime` 객체 *d*\\는 ``d.tzinfo``\\가 ``None``\\이 아니고, "
"``d.tzinfo.utcoffset(d)``\\가 ``None``\\을 반환하지 않으면 어웨어합니다. ``d.tzinfo``\\가"
" ``None``\\이거나, ``d.tzinfo``\\는 ``None``\\이 아니지만 "
"``d.tzinfo.utcoffset(d)``\\가 ``None``\\을 반환하면 *d*\\는 나이브합니다. "
":class:`.time` 객체 *t*\\는 ``t.tzinfo``가 ``None``\\이 아니고 "
"``t.tzinfo.utcoffset(None)``\\이 ``None``\\을 반환하지 않으면 어웨어합니다. 그렇지 않으면, "
"*t*\\는 나이브합니다."

#: ../Doc/library/datetime.rst:138
msgid ""
"The distinction between naive and aware doesn't apply to "
":class:`timedelta` objects."
msgstr "나이브와 어웨어 간의 차이점은 :class:`timedelta` 객체에는 적용되지 않습니다."

#: ../Doc/library/datetime.rst:141
msgid "Subclass relationships::"
msgstr "서브 클래스 관계::"

#: ../Doc/library/datetime.rst:155
msgid ":class:`timedelta` Objects"
msgstr ":class:`timedelta` 객체"

#: ../Doc/library/datetime.rst:157
msgid ""
"A :class:`timedelta` object represents a duration, the difference between"
" two dates or times."
msgstr ":class:`timedelta` 객체는 두 날짜나 시간의 차이인 기간을 나타냅니다."

#: ../Doc/library/datetime.rst:162
msgid ""
"All arguments are optional and default to ``0``.  Arguments may be "
"integers or floats, and may be positive or negative."
msgstr "모든 인자는 선택적이며 기본값은 ``0``\\입니다. 인자는 정수나 부동 소수점 수일 수 있으며, 양수나 음수일 수 있습니다."

#: ../Doc/library/datetime.rst:165
msgid ""
"Only *days*, *seconds* and *microseconds* are stored internally.  "
"Arguments are converted to those units:"
msgstr "*days*, *seconds* 및 *microseconds* 만 내부적으로 저장됩니다. 인자는 이 단위로 변환됩니다:"

#: ../Doc/library/datetime.rst:168
msgid "A millisecond is converted to 1000 microseconds."
msgstr "밀리 초는 1000마이크로초로 변환됩니다."

#: ../Doc/library/datetime.rst:169
msgid "A minute is converted to 60 seconds."
msgstr "분은 60초로 변환됩니다."

#: ../Doc/library/datetime.rst:170
msgid "An hour is converted to 3600 seconds."
msgstr "시간은 3600초로 변환됩니다."

#: ../Doc/library/datetime.rst:171
msgid "A week is converted to 7 days."
msgstr "주는 7일로 변환됩니다."

#: ../Doc/library/datetime.rst:173
msgid ""
"and days, seconds and microseconds are then normalized so that the "
"representation is unique, with"
msgstr "그런 다음 days, seconds 및 microseconds를 다음처럼 정규화하여 표현이 고유하도록 만듭니다"

#: ../Doc/library/datetime.rst:176
msgid "``0 <= microseconds < 1000000``"
msgstr "``0 <= microseconds < 1000000``"

#: ../Doc/library/datetime.rst:177
msgid "``0 <= seconds < 3600*24`` (the number of seconds in one day)"
msgstr "``0 <= seconds < 3600*24`` (하루 내의 초 수)"

#: ../Doc/library/datetime.rst:178
msgid "``-999999999 <= days <= 999999999``"
msgstr "``-999999999 <= days <= 999999999``"

#: ../Doc/library/datetime.rst:180
msgid ""
"If any argument is a float and there are fractional microseconds, the "
"fractional microseconds left over from all arguments are combined and "
"their sum is rounded to the nearest microsecond using round-half-to-even "
"tiebreaker.  If no argument is a float, the conversion and normalization "
"processes are exact (no information is lost)."
msgstr ""
"인자가 float이고 부분 마이크로초가 있으면, 모든 인자의 남은 부분 마이크로초가 합쳐지고, 그 합은 동률일 때 짝수로 반올림하는"
" 방식으로 가장 가까운 마이크로초로 반올림됩니다. float 인자가 없으면, 변환과 정규화 프로세스는 정확합니다 (정보가 손실되지 "
"않습니다)."

#: ../Doc/library/datetime.rst:187
msgid ""
"If the normalized value of days lies outside the indicated range, "
":exc:`OverflowError` is raised."
msgstr "정규화된 days 값이 표시된 범위를 벗어나면, :exc:`OverflowError`\\가 발생합니다."

#: ../Doc/library/datetime.rst:190
msgid ""
"Note that normalization of negative values may be surprising at first. "
"For example,"
msgstr "음수 값의 정규화는 처음 보면 놀라울 수 있습니다. 예를 들어,"

#: ../Doc/library/datetime.rst:199
msgid "Class attributes are:"
msgstr "클래스 어트리뷰트는 다음과 같습니다:"

#: ../Doc/library/datetime.rst:203
msgid "The most negative :class:`timedelta` object, ``timedelta(-999999999)``."
msgstr "가장 음수인 :class:`timedelta` 객체, ``timedelta(-999999999)``."

#: ../Doc/library/datetime.rst:208
msgid ""
"The most positive :class:`timedelta` object, ``timedelta(days=999999999, "
"hours=23, minutes=59, seconds=59, microseconds=999999)``."
msgstr ""
"가장 양수인 :class:`timedelta` 객체, ``timedelta(days=999999999, hours=23, "
"minutes=59, seconds=59, microseconds=999999)``."

#: ../Doc/library/datetime.rst:214
msgid ""
"The smallest possible difference between non-equal :class:`timedelta` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"같지 않은 :class:`timedelta` 객체 간의 가능한 가장 작은 차이, "
"``timedelta(microseconds=1)``."

#: ../Doc/library/datetime.rst:217
msgid ""
"Note that, because of normalization, ``timedelta.max`` > "
"``-timedelta.min``. ``-timedelta.max`` is not representable as a "
":class:`timedelta` object."
msgstr ""
"정규화로 인해, ``timedelta.max`` > ``-timedelta.min``\\입니다. "
"``-timedelta.max``\\는 :class:`timedelta` 객체로 표현할 수 없습니다."

#: ../Doc/library/datetime.rst:220 ../Doc/library/datetime.rst:480
#: ../Doc/library/datetime.rst:888 ../Doc/library/datetime.rst:1457
msgid "Instance attributes (read-only):"
msgstr "인스턴스 어트리뷰트 (읽기 전용):"

#: ../Doc/library/datetime.rst:223
msgid "Attribute"
msgstr "어트리뷰트"

#: ../Doc/library/datetime.rst:223
msgid "Value"
msgstr "값"

#: ../Doc/library/datetime.rst:225
msgid "``days``"
msgstr "``days``"

#: ../Doc/library/datetime.rst:225
msgid "Between -999999999 and 999999999 inclusive"
msgstr "-999999999와 999999999 사이, 경계 포함"

#: ../Doc/library/datetime.rst:227
msgid "``seconds``"
msgstr "``seconds``"

#: ../Doc/library/datetime.rst:227
msgid "Between 0 and 86399 inclusive"
msgstr "0과 86399 사이, 경계 포함"

#: ../Doc/library/datetime.rst:229
msgid "``microseconds``"
msgstr "``microseconds``"

#: ../Doc/library/datetime.rst:229
msgid "Between 0 and 999999 inclusive"
msgstr "0과 999999 사이, 경계 포함"

#: ../Doc/library/datetime.rst:232 ../Doc/library/datetime.rst:497
#: ../Doc/library/datetime.rst:941 ../Doc/library/datetime.rst:1496
msgid "Supported operations:"
msgstr "지원되는 연산:"

#: ../Doc/library/datetime.rst:237 ../Doc/library/datetime.rst:500
#: ../Doc/library/datetime.rst:944
msgid "Operation"
msgstr "연산"

#: ../Doc/library/datetime.rst:237 ../Doc/library/datetime.rst:500
#: ../Doc/library/datetime.rst:944
msgid "Result"
msgstr "결과"

#: ../Doc/library/datetime.rst:239
msgid "``t1 = t2 + t3``"
msgstr "``t1 = t2 + t3``"

#: ../Doc/library/datetime.rst:239
msgid ""
"Sum of *t2* and *t3*. Afterwards *t1*-*t2* == *t3* and *t1*-*t3* == *t2* "
"are true. (1)"
msgstr "*t2*\\와 *t3*\\의 합. 이후에는 *t1*-*t2* == *t3* 과 *t1*-*t3* == *t2*\\가 참입니다. (1)"

#: ../Doc/library/datetime.rst:242
msgid "``t1 = t2 - t3``"
msgstr "``t1 = t2 - t3``"

#: ../Doc/library/datetime.rst:242
msgid ""
"Difference of *t2* and *t3*. Afterwards *t1* == *t2* - *t3* and *t2* == "
"*t1* + *t3* are true. (1)(6)"
msgstr ""
"*t2*\\와 *t3*\\의 차이. 이후에는 *t1* == *t2* - *t3* 과 *t2* == *t1* + *t3*\\가 "
"참입니다. (1)(6)"

#: ../Doc/library/datetime.rst:246
msgid "``t1 = t2 * i or t1 = i * t2``"
msgstr "``t1 = t2 * i 또는 t1 = i * t2``"

#: ../Doc/library/datetime.rst:246
msgid ""
"Delta multiplied by an integer. Afterwards *t1* // i == *t2* is true, "
"provided ``i != 0``."
msgstr "델타에 정수를 곱합니다. 이후에는 ``i != 0``\\일 때, *t1* // i == *t2*\\가 참입니다."

#: ../Doc/library/datetime.rst:250
msgid "In general, *t1* \\* i == *t1* \\* (i-1) + *t1* is true. (1)"
msgstr "일반적으로, *t1* \\* i == *t1* \\* (i-1) + *t1*\\은 참입니다. (1)"

#: ../Doc/library/datetime.rst:253
msgid "``t1 = t2 * f or t1 = f * t2``"
msgstr "``t1 = t2 * f 또는 t1 = f * t2``"

#: ../Doc/library/datetime.rst:253
msgid ""
"Delta multiplied by a float. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr ""
"델타에 float를 곱합니다. 결과는 동률일 때 짝수로 반올림하는 방식으로 timedelta.resolution의 가장 가까운 "
"배수로 자리 올림 됩니다."

#: ../Doc/library/datetime.rst:257
msgid "``f = t2 / t3``"
msgstr "``f = t2 / t3``"

#: ../Doc/library/datetime.rst:257
msgid ""
"Division (3) of overall duration *t2* by interval unit *t3*. Returns a "
":class:`float` object."
msgstr "전체 기간 *t2*\\를 구간 단위 *t3*\\으로 나누기 (3). :class:`float` 객체를 반환합니다."

#: ../Doc/library/datetime.rst:261
msgid "``t1 = t2 / f or t1 = t2 / i``"
msgstr "``t1 = t2 / f 또는 t1 = t2 / i``"

#: ../Doc/library/datetime.rst:261
msgid ""
"Delta divided by a float or an int. The result is rounded to the nearest "
"multiple of timedelta.resolution using round-half-to-even."
msgstr ""
"델타를 float나 int로 나눈 값. 결과는 동률일 때 짝수로 반올림하는 방식으로 timedelta.resolution의 가장 "
"가까운 배수로 자리 올림 됩니다."

#: ../Doc/library/datetime.rst:265
msgid "``t1 = t2 // i`` or ``t1 = t2 // t3``"
msgstr "``t1 = t2 // i`` 또는 ``t1 = t2 // t3``"

#: ../Doc/library/datetime.rst:265
msgid ""
"The floor is computed and the remainder (if any) is thrown away.  In the "
"second case, an integer is returned. (3)"
msgstr "floor가 계산되고 나머지(있다면)를 버립니다. 두 번째 경우에는, 정수가 반환됩니다. (3)"

#: ../Doc/library/datetime.rst:269
msgid "``t1 = t2 % t3``"
msgstr "``t1 = t2 % t3``"

#: ../Doc/library/datetime.rst:269
msgid "The remainder is computed as a :class:`timedelta` object. (3)"
msgstr "나머지가 :class:`timedelta` 객체로 계산됩니다. (3)"

#: ../Doc/library/datetime.rst:272
msgid "``q, r = divmod(t1, t2)``"
msgstr "``q, r = divmod(t1, t2)``"

#: ../Doc/library/datetime.rst:272
msgid ""
"Computes the quotient and the remainder: ``q = t1 // t2`` (3) and ``r = "
"t1 % t2``. q is an integer and r is a :class:`timedelta` object."
msgstr ""
"몫과 나머지를 계산합니다: ``q = t1 // t2`` (3) 과 ``r = t1 % t2``. q는 정수고 r은 "
":class:`timedelta` 객체입니다."

#: ../Doc/library/datetime.rst:277
msgid "``+t1``"
msgstr "``+t1``"

#: ../Doc/library/datetime.rst:277
msgid "Returns a :class:`timedelta` object with the same value. (2)"
msgstr "같은 값을 갖는 :class:`timedelta` 객체를 반환합니다. (2)"

#: ../Doc/library/datetime.rst:280
msgid "``-t1``"
msgstr "``-t1``"

#: ../Doc/library/datetime.rst:280
msgid ""
"equivalent to :class:`timedelta`\\ (-*t1.days*, -*t1.seconds*, "
"-*t1.microseconds*), and to *t1*\\* -1. (1)(4)"
msgstr ""
":class:`timedelta`\\ (-*t1.days*, -*t1.seconds*, -*t1.microseconds*) 와 "
"*t1*\\* -1과 동등합니다. (1)(4)"

#: ../Doc/library/datetime.rst:285
msgid "``abs(t)``"
msgstr "``abs(t)``"

#: ../Doc/library/datetime.rst:285
msgid ""
"equivalent to +\\ *t* when ``t.days >= 0``, and to -*t* when ``t.days < "
"0``. (2)"
msgstr "``t.days >= 0`` 일 때 +\\ *t* 와 ``t.days < 0`` 일 때 -*t*\\와 동등합니다. (2)"

#: ../Doc/library/datetime.rst:288
msgid "``str(t)``"
msgstr "``str(t)``"

#: ../Doc/library/datetime.rst:288
msgid ""
"Returns a string in the form ``[D day[s], ][H]H:MM:SS[.UUUUUU]``, where D"
" is negative for negative ``t``. (5)"
msgstr ""
"``[D day[s], ][H]H:MM:SS[.UUUUUU]`` 형식의 문자열을 반환합니다. 여기서 D는 음의 ``t``\\일 때 "
"음수입니다. (5)"

#: ../Doc/library/datetime.rst:292
msgid "``repr(t)``"
msgstr "``repr(t)``"

#: ../Doc/library/datetime.rst:292
msgid ""
"Returns a string representation of the :class:`timedelta` object as a "
"constructor call with canonical attribute values."
msgstr "규범적 어트리뷰트 값을 가진 생성자 호출로 표현한 :class:`timedelta` 객체의 문자열 표현을 반환합니다."

#: ../Doc/library/datetime.rst:298 ../Doc/library/datetime.rst:514
#: ../Doc/library/datetime.rst:2190
msgid "Notes:"
msgstr "노트:"

#: ../Doc/library/datetime.rst:301
msgid "This is exact, but may overflow."
msgstr "이것은 정확하지만, 오버플로 할 수 있습니다."

#: ../Doc/library/datetime.rst:304
msgid "This is exact, and cannot overflow."
msgstr "이것은 정확하고, 오버플로 할 수 없습니다."

#: ../Doc/library/datetime.rst:307
msgid "Division by 0 raises :exc:`ZeroDivisionError`."
msgstr "0으로 나누면 :exc:`ZeroDivisionError`\\가 발생합니다."

#: ../Doc/library/datetime.rst:310
msgid "-*timedelta.max* is not representable as a :class:`timedelta` object."
msgstr "-*timedelta.max*\\는 :class:`timedelta` 객체로 표현할 수 없습니다."

#: ../Doc/library/datetime.rst:313
msgid ""
"String representations of :class:`timedelta` objects are normalized "
"similarly to their internal representation.  This leads to somewhat "
"unusual results for negative timedeltas.  For example:"
msgstr ""
":class:`timedelta` 객체의 문자열 표현은 내부 표현과 유사하게 정규화됩니다. 이것은 음의 timedelta가 다소 "
"이상하게 표현되는 결과로 이어집니다. 예를 들어:"

#: ../Doc/library/datetime.rst:323
msgid ""
"The expression ``t2 - t3`` will always be equal to the expression ``t2 + "
"(-t3)`` except when t3 is equal to ``timedelta.max``; in that case the "
"former will produce a result while the latter will overflow."
msgstr ""
"``t2 - t3`` 표현식은 항상 ``t2 + (-t3)`` 표현식과 같아지는데, t3이 ``timedelta.max``\\일 "
"때만 예외입니다; 이때는 앞에 있는 것은 결과를 만들지만, 뒤에 있는 것은 오버플로를 일으킵니다."

#: ../Doc/library/datetime.rst:327
msgid ""
"In addition to the operations listed above :class:`timedelta` objects "
"support certain additions and subtractions with :class:`date` and "
":class:`.datetime` objects (see below)."
msgstr ""
"위에 나열된 연산 외에도 :class:`timedelta` 객체는 :class:`date`\\와 :class:`.datetime` "
"객체와의 어떤 합과 차를 지원합니다 (아래를 참조하세요)."

#: ../Doc/library/datetime.rst:331
msgid ""
"Floor division and true division of a :class:`timedelta` object by "
"another :class:`timedelta` object are now supported, as are remainder "
"operations and the :func:`divmod` function.  True division and "
"multiplication of a :class:`timedelta` object by a :class:`float` object "
"are now supported."
msgstr ""
"나머지 연산과 :func:`divmod` 함수와 마찬가지로, :class:`timedelta` 객체를 다른 "
":class:`timedelta` 객체로 정수 나누기(floor division)와 실수 나누기(true division)가 이제 "
"지원됩니다. :class:`timedelta` 객체를 :class:`float` 객체로 실수 나누기와 곱셈도 이제 이제 지원됩니다."

#: ../Doc/library/datetime.rst:338
msgid ""
"Comparisons of :class:`timedelta` objects are supported with the "
":class:`timedelta` object representing the smaller duration considered to"
" be the smaller timedelta. In order to stop mixed-type comparisons from "
"falling back to the default comparison by object address, when a "
":class:`timedelta` object is compared to an object of a different type, "
":exc:`TypeError` is raised unless the comparison is ``==`` or ``!=``.  "
"The latter cases return :const:`False` or :const:`True`, respectively."
msgstr ""
":class:`timedelta` 객체의 비교가 지원되는데, 더 짧은 기간을 나타내는 :class:`timedelta` 객체를 더 "
"작은 것으로 간주합니다. 혼합형 비교가 객체 주소 기반의 기본 비교로 떨어지는 것을 막기 위해, :class:`timedelta` "
"객체가 다른 형의 객체와 비교될 때, 비교가 ``==`` 이나 ``!=``\\가 아니면 :exc:`TypeError`\\가 "
"발생합니다. 두 상황에 해당하면 각각 :const:`False` 나 :const:`True`\\를 반환합니다."

#: ../Doc/library/datetime.rst:346
msgid ""
":class:`timedelta` objects are :term:`hashable` (usable as dictionary "
"keys), support efficient pickling, and in Boolean contexts, a "
":class:`timedelta` object is considered to be true if and only if it "
"isn't equal to ``timedelta(0)``."
msgstr ""
":class:`timedelta` 객체는 :term:`해시 가능 <hashable>`\\(딕셔너리 키로 사용 가능)하고, 효율적인 "
"피클링을 지원하며, 불리언 문맥에서 :class:`timedelta` 객체는 ``timedelta(0)``\\와 같지 않을 때만 "
"참으로 간주합니다."

#: ../Doc/library/datetime.rst:350 ../Doc/library/datetime.rst:544
#: ../Doc/library/datetime.rst:1018 ../Doc/library/datetime.rst:1546
msgid "Instance methods:"
msgstr "인스턴스 메서드:"

#: ../Doc/library/datetime.rst:354
msgid ""
"Return the total number of seconds contained in the duration. Equivalent "
"to ``td / timedelta(seconds=1)``. For interval units other than seconds, "
"use the division form directly (e.g. ``td / timedelta(microseconds=1)``)."
msgstr ""
"기간에 포함된 총 시간을 초(seconds)로 반환합니다. ``td / timedelta(seconds=1)``\\와 동등합니다. "
"초 이외의 구간 단위에는, 나누기 형식을 직접 사용하십시오 (예를 들어, ``td / "
"timedelta(microseconds=1)``)."

#: ../Doc/library/datetime.rst:358
msgid ""
"Note that for very large time intervals (greater than 270 years on most "
"platforms) this method will lose microsecond accuracy."
msgstr "매우 큰 시간 구간에서는 (대부분 플랫폼에서 270년 이상), 이 메서드는 마이크로초의 정확도를 잃게 됩니다."

#: ../Doc/library/datetime.rst:364
msgid "Example usage:"
msgstr "사용 예:"

#: ../Doc/library/datetime.rst:390
msgid ":class:`date` Objects"
msgstr ":class:`date` 객체"

#: ../Doc/library/datetime.rst:392
msgid ""
"A :class:`date` object represents a date (year, month and day) in an "
"idealized calendar, the current Gregorian calendar indefinitely extended "
"in both directions.  January 1 of year 1 is called day number 1, January "
"2 of year 1 is called day number 2, and so on.  This matches the "
"definition of the \"proleptic Gregorian\" calendar in Dershowitz and "
"Reingold's book Calendrical Calculations, where it's the base calendar "
"for all computations.  See the book for algorithms for converting between"
" proleptic Gregorian ordinals and many other calendar systems."
msgstr ""
":class:`date` 객체는 현재의 그레고리력을 무한히 양방향으로 확장한, 이상적인 달력에서의 날짜(년, 월, 일)를 "
"나타냅니다. 1년 1월 1일을 날 번호 1, 1년 1월 2일을 날 번호 2라고 부릅니다. 이것은 Dershowitz와 "
"Reingold의 책 Calendrical Calculations에 나오는 \"역산 그레고리(proleptic "
"Gregorian)\" 달력의 정의와 일치합니다. 이 달력은 모든 계산의 기본 달력입니다. 역산 그레고리력 서수(ordinal)와 "
"다른 많은 달력 시스템 사이의 변환을 위한 알고리즘에 관해서는 이 책을 참조하십시오."

#: ../Doc/library/datetime.rst:404
msgid ""
"All arguments are required.  Arguments may be integers, in the following "
"ranges:"
msgstr "모든 인자가 필수입니다. 인자는 다음 범위에 있는 정수일 수 있습니다:"

#: ../Doc/library/datetime.rst:407
msgid "``MINYEAR <= year <= MAXYEAR``"
msgstr "``MINYEAR <= year <= MAXYEAR``"

#: ../Doc/library/datetime.rst:408
msgid "``1 <= month <= 12``"
msgstr "``1 <= month <= 12``"

#: ../Doc/library/datetime.rst:409
msgid "``1 <= day <= number of days in the given month and year``"
msgstr "``1 <= day <= 주어진 month와 year에서의 날 수``"

#: ../Doc/library/datetime.rst:411 ../Doc/library/datetime.rst:722
msgid "If an argument outside those ranges is given, :exc:`ValueError` is raised."
msgstr "이 범위를 벗어나는 인자가 주어지면, :exc:`ValueError`\\가 발생합니다."

#: ../Doc/library/datetime.rst:414 ../Doc/library/datetime.rst:727
msgid "Other constructors, all class methods:"
msgstr "다른 생성자, 모든 클래스 메서드:"

#: ../Doc/library/datetime.rst:418
msgid ""
"Return the current local date.  This is equivalent to "
"``date.fromtimestamp(time.time())``."
msgstr "현재 지역 날짜를 반환합니다. 이것은 ``date.fromtimestamp(time.time())``\\와 동등합니다."

#: ../Doc/library/datetime.rst:424
msgid ""
"Return the local date corresponding to the POSIX timestamp, such as is "
"returned by :func:`time.time`.  This may raise :exc:`OverflowError`, if "
"the timestamp is out of the range of values supported by the platform C "
":c:func:`localtime` function, and :exc:`OSError` on :c:func:`localtime` "
"failure. It's common for this to be restricted to years from 1970 through"
" 2038.  Note that on non-POSIX systems that include leap seconds in their"
" notion of a timestamp, leap seconds are ignored by "
":meth:`fromtimestamp`."
msgstr ""
":func:`time.time`\\에 의해 반환된 것과 같은 POSIX 타임스탬프에 해당하는 지역 날짜를 반환합니다. 타임스탬프가 "
"플랫폼 C :c:func:`localtime` 함수에서 지원하는 값 범위를 벗어나면 :exc:`OverflowError`\\가 "
"발생하고, :c:func:`localtime` 실패 시 :exc:`OSError`\\가 발생합니다. 이것이 1970년에서 "
"2038년으로 제한되는 것이 일반적입니다. 타임스탬프라는 개념에 윤초를 포함하는 POSIX가 아닌 시스템에서는, 윤초가 "
":meth:`fromtimestamp`\\에서 무시됨에 유의하십시오."

#: ../Doc/library/datetime.rst:432
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp "
"is out of the range of values supported by the platform C "
":c:func:`localtime` function. Raise :exc:`OSError` instead of "
":exc:`ValueError` on :c:func:`localtime` failure."
msgstr ""
"timestamp가 플랫폼 C :c:func:`localtime` 함수에서 지원하는 값 범위를 벗어나면 "
":exc:`ValueError` 대신 :exc:`OverflowError`\\를 발생시킵니다. :c:func:`localtime` "
"실패 시 :exc:`ValueError` 대신 :exc:`OSError`\\를 발생시킵니다."

#: ../Doc/library/datetime.rst:441
msgid ""
"Return the date corresponding to the proleptic Gregorian ordinal, where "
"January 1 of year 1 has ordinal 1.  :exc:`ValueError` is raised unless "
"``1 <= ordinal <= date.max.toordinal()``. For any date *d*, "
"``date.fromordinal(d.toordinal()) == d``."
msgstr ""
"역산 그레고리력 서수에 해당하는 date를 반환합니다. 1년 1월 1일이 서수 1입니다. ``1 <= ordinal <= "
"date.max.toordinal()``\\이 아니면 :exc:`ValueError`\\가 발생합니다. 모든 date *d*\\에 "
"대해, ``date.fromordinal(d.toordinal()) == d``\\입니다."

#: ../Doc/library/datetime.rst:449
msgid ""
"Return a :class:`date` corresponding to a *date_string* in the format "
"emitted by :meth:`date.isoformat`. Specifically, this function supports "
"strings in the format(s) ``YYYY-MM-DD``."
msgstr ""
":meth:`date.isoformat`\\로 만든 형식의 *date_string*\\에 해당하는 :class:`date`\\를 "
"반환합니다. 구체적으로, 이 함수는 ``YYYY-MM-DD`` 형식의 문자열을 지원합니다."

#: ../Doc/library/datetime.rst:455
msgid ""
"This does not support parsing arbitrary ISO 8601 strings - it is only "
"intended as the inverse operation of :meth:`date.isoformat`."
msgstr ""
"이것은 임의의 ISO 8601 문자열을 구문 분석하는 것을 지원하지 않습니다 - 이것은 "
":meth:`date.isoformat`\\의 역연산이고자 할 뿐입니다."

#: ../Doc/library/datetime.rst:462 ../Doc/library/datetime.rst:868
#: ../Doc/library/datetime.rst:1437 ../Doc/library/datetime.rst:2007
msgid "Class attributes:"
msgstr "클래스 어트리뷰트:"

#: ../Doc/library/datetime.rst:466
msgid "The earliest representable date, ``date(MINYEAR, 1, 1)``."
msgstr "표현 가능한 가장 이른 date, ``date(MINYEAR, 1, 1)``."

#: ../Doc/library/datetime.rst:471
msgid "The latest representable date, ``date(MAXYEAR, 12, 31)``."
msgstr "표현 가능한 가장 늦은 date, ``date(MAXYEAR, 12, 31)``."

#: ../Doc/library/datetime.rst:476
msgid ""
"The smallest possible difference between non-equal date objects, "
"``timedelta(days=1)``."
msgstr "같지 않은 date 객체 간의 가능한 가장 작은 차이, ``timedelta(days=1)``."

#: ../Doc/library/datetime.rst:484 ../Doc/library/datetime.rst:892
msgid "Between :const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ":const:`MINYEAR`\\와 :const:`MAXYEAR` 사이, 경계 포함."

#: ../Doc/library/datetime.rst:489 ../Doc/library/datetime.rst:897
msgid "Between 1 and 12 inclusive."
msgstr "1과 12 사이, 경계 포함."

#: ../Doc/library/datetime.rst:494 ../Doc/library/datetime.rst:902
msgid "Between 1 and the number of days in the given month of the given year."
msgstr "1과 주어진 year의 주어진 month의 날 수 사이."

#: ../Doc/library/datetime.rst:502
msgid "``date2 = date1 + timedelta``"
msgstr "``date2 = date1 + timedelta``"

#: ../Doc/library/datetime.rst:502
msgid "*date2* is ``timedelta.days`` days removed from *date1*.  (1)"
msgstr "*date2*\\는 *date1*\\에서 ``timedelta.days`` 일 이동한 날짜입니다. (1)"

#: ../Doc/library/datetime.rst:505
msgid "``date2 = date1 - timedelta``"
msgstr "``date2 = date1 - timedelta``"

#: ../Doc/library/datetime.rst:505
msgid "Computes *date2* such that ``date2 + timedelta == date1``. (2)"
msgstr "``date2 + timedelta == date1``\\가 성립하는 *date2*\\를 계산합니다. (2)"

#: ../Doc/library/datetime.rst:508
msgid "``timedelta = date1 - date2``"
msgstr "``timedelta = date1 - date2``"

#: ../Doc/library/datetime.rst:508 ../Doc/library/datetime.rst:950
msgid "\\(3)"
msgstr "\\(3)"

#: ../Doc/library/datetime.rst:510
msgid "``date1 < date2``"
msgstr "``date1 < date2``"

#: ../Doc/library/datetime.rst:510
msgid ""
"*date1* is considered less than *date2* when *date1* precedes *date2* in "
"time. (4)"
msgstr "*date1*\\이 *date2*\\에 앞서면 *date1*\\는 *date2*\\보다 작은 것으로 간주합니다. (4)"

#: ../Doc/library/datetime.rst:517
msgid ""
"*date2* is moved forward in time if ``timedelta.days > 0``, or backward "
"if ``timedelta.days < 0``.  Afterward ``date2 - date1 == "
"timedelta.days``. ``timedelta.seconds`` and ``timedelta.microseconds`` "
"are ignored. :exc:`OverflowError` is raised if ``date2.year`` would be "
"smaller than :const:`MINYEAR` or larger than :const:`MAXYEAR`."
msgstr ""
"*date2*\\는 ``timedelta.days > 0``\\이면 미래로, ``timedelta.days < 0``\\이면 과거로"
" 이동합니다. 결국 ``date2 - date1 == timedelta.days``\\이 됩니다. "
"``timedelta.seconds``\\와 ``timedelta.microseconds``\\는 무시됩니다. "
"``date2.year``\\가 :const:`MINYEAR`\\보다 작거나 :const:`MAXYEAR`\\보다 크게 되려고 하면"
" :exc:`OverflowError`\\가 발생합니다."

#: ../Doc/library/datetime.rst:524
msgid "``timedelta.seconds`` and ``timedelta.microseconds`` are ignored."
msgstr "``timedelta.seconds``\\와 ``timedelta.microseconds``\\는 무시됩니다."

#: ../Doc/library/datetime.rst:527
msgid ""
"This is exact, and cannot overflow.  timedelta.seconds and "
"timedelta.microseconds are 0, and date2 + timedelta == date1 after."
msgstr ""
"이것은 정확하고, 오버플로 할 수 없습니다. timedelta.seconds와 timedelta.microseconds는 0이고, "
"이후에 date2 + timedelta == date1가 됩니다."

#: ../Doc/library/datetime.rst:531
msgid ""
"In other words, ``date1 < date2`` if and only if ``date1.toordinal() < "
"date2.toordinal()``. Date comparison raises :exc:`TypeError` if the other"
" comparand isn't also a :class:`date` object. However, ``NotImplemented``"
" is returned instead if the other comparand has a :meth:`timetuple` "
"attribute.  This hook gives other kinds of date objects a chance at "
"implementing mixed-type comparison. If not, when a :class:`date` object "
"is compared to an object of a different type, :exc:`TypeError` is raised "
"unless the comparison is ``==`` or ``!=``.  The latter cases return "
":const:`False` or :const:`True`, respectively."
msgstr ""
"즉, 오직 ``date1.toordinal() < date2.toordinal()``\\일 때만 ``date1 < "
"date2``\\입니다. 비교 대상이 :class:`date` 객체가 아니면 날짜 비교는 :exc:`TypeError`\\를 "
"발생시킵니다. 그러나, 비교 대상에 :meth:`timetuple` 어트리뷰트가 있으면, 대신 "
"``NotImplemented``\\가 반환됩니다. 이 훅은 다른 형의 날짜 객체가 혼합형 비교를 구현할 기회를 제공합니다. 그렇지"
" 않으면, :class:`date` 객체가 다른 형의 객체와 비교될 때, 비교가 ``==``\\나 ``!=``\\가 아니면 "
":exc:`TypeError`\\가 발생합니다. 두 상황에 해당하면 각각 :const:`False` 나 "
":const:`True`\\를 반환합니다"

#: ../Doc/library/datetime.rst:541
msgid ""
"Dates can be used as dictionary keys. In Boolean contexts, all "
":class:`date` objects are considered to be true."
msgstr "날짜는 딕셔너리 키로 사용할 수 있습니다. 불리언 문맥에서, 모든 :class:`date` 객체는 참으로 간주합니다."

#: ../Doc/library/datetime.rst:548
msgid ""
"Return a date with the same value, except for those parameters given new "
"values by whichever keyword arguments are specified.  For example, if ``d"
" == date(2002, 12, 31)``, then ``d.replace(day=26) == date(2002, 12, "
"26)``."
msgstr ""
"키워드 인자로 새로운 값이 주어진 매개 변수들을 제외하고, 같은 값을 가진 date를 반환합니다. 예를 들어, ``d == "
"date(2002, 12, 31)``\\이면, ``d.replace(day=26) == date(2002, 12, "
"26)``\\입니다."

#: ../Doc/library/datetime.rst:555
msgid ""
"Return a :class:`time.struct_time` such as returned by "
":func:`time.localtime`. The hours, minutes and seconds are 0, and the DST"
" flag is -1. ``d.timetuple()`` is equivalent to "
"``time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, "
"-1))``, where ``yday = d.toordinal() - date(d.year, 1, 1).toordinal() + "
"1`` is the day number within the current year starting with ``1`` for "
"January 1st."
msgstr ""
":func:`time.localtime`\\이 반환하는 것과 같은 :class:`time.struct_time`\\을 반환합니다. "
"시, 분 및 초는 0이고, DST 플래그는 -1입니다. ``d.timetuple()``\\은 "
"``time.struct_time((d.year, d.month, d.day, 0, 0, 0, d.weekday(), yday, "
"-1))``\\와 동등합니다. 여기서 ``yday = d.toordinal() - date(d.year, 1, "
"1).toordinal() + 1``\\는 1월 1일에 ``1``\\로 시작하는 현재 연도의 날짜 번호입니다."

#: ../Doc/library/datetime.rst:565
msgid ""
"Return the proleptic Gregorian ordinal of the date, where January 1 of "
"year 1 has ordinal 1.  For any :class:`date` object *d*, "
"``date.fromordinal(d.toordinal()) == d``."
msgstr ""
"역산 그레고리력 서수를 돌려줍니다. 1년 1월 1일의 서수는 1입니다. 임의의 :class:`date` 객체 *d*\\에 대해 "
"``date.fromordinal(d.toordinal()) == d``\\입니다."

#: ../Doc/library/datetime.rst:572
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is"
" 6. For example, ``date(2002, 12, 4).weekday() == 2``, a Wednesday. See "
"also :meth:`isoweekday`."
msgstr ""
"정수로 요일을 반환합니다. 월요일은 0이고 일요일은 6입니다. 예를 들어, ``date(2002, 12, 4).weekday() "
"== 2``, 수요일. :meth:`isoweekday`\\도 참조하십시오."

#: ../Doc/library/datetime.rst:579
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is"
" 7. For example, ``date(2002, 12, 4).isoweekday() == 3``, a Wednesday. "
"See also :meth:`weekday`, :meth:`isocalendar`."
msgstr ""
"정수로 요일을 반환합니다. 월요일은 1이고 일요일은 7입니다. 예를 들어, ``date(2002, 12, "
"4).isoweekday() == 3``, 수요일. :meth:`weekday`, :meth:`isocalendar`\\도 "
"참조하십시오."

#: ../Doc/library/datetime.rst:586
msgid "Return a 3-tuple, (ISO year, ISO week number, ISO weekday)."
msgstr "3-튜플 (ISO 연도, ISO 주 번호, ISO 요일)을 반환합니다."

#: ../Doc/library/datetime.rst:588
msgid ""
"The ISO calendar is a widely used variant of the Gregorian calendar. See "
"https://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm for a "
"good explanation."
msgstr ""
"ISO 달력은 그레고리력의 널리 사용되는 변형입니다. "
"https://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm 에 잘 "
"설명되어 있습니다."

#: ../Doc/library/datetime.rst:592
msgid ""
"The ISO year consists of 52 or 53 full weeks, and where a week starts on "
"a Monday and ends on a Sunday.  The first week of an ISO year is the "
"first (Gregorian) calendar week of a year containing a Thursday. This is "
"called week number 1, and the ISO year of that Thursday is the same as "
"its Gregorian year."
msgstr ""
"ISO 연도는 52나 53개의 완전한 주로 구성되고, 주는 월요일에 시작하여 일요일에 끝납니다. ISO 연도의 첫 번째 주는 그 "
"해의 (그레고리) 달력에서 목요일이 들어있는 첫 번째 주입니다. 이것을 주 번호 1이라고 하며, 그 목요일의 ISO 연도는 그레고리"
" 연도와 같습니다."

#: ../Doc/library/datetime.rst:597
msgid ""
"For example, 2004 begins on a Thursday, so the first week of ISO year "
"2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan 2004, so "
"that ``date(2003, 12, 29).isocalendar() == (2004, 1, 1)`` and "
"``date(2004, 1, 4).isocalendar() == (2004, 1, 7)``."
msgstr ""
"예를 들어, 2004년은 목요일에 시작되므로, ISO 연도 2004의 첫 주는 월요일, 2003년 12월 29일에 시작하고, "
"일요일, 2004년 1월 4일에 끝납니다. 그래서 ``date(2003, 12, 29).isocalendar() == (2004, "
"1, 1)``\\이고 ``date(2004, 1, 4).isocalendar() == (2004, 1, 7)``\\입니다."

#: ../Doc/library/datetime.rst:605
msgid ""
"Return a string representing the date in ISO 8601 format, 'YYYY-MM-DD'.  "
"For example, ``date(2002, 12, 4).isoformat() == '2002-12-04'``."
msgstr ""
"ISO 8601 형식으로 날짜를 나타내는 문자열을 반환합니다, 'YYYY-MM-DD'. 예를 들어, ``date(2002, 12, "
"4).isoformat() == '2002-12-04'``."

#: ../Doc/library/datetime.rst:611
msgid "For a date *d*, ``str(d)`` is equivalent to ``d.isoformat()``."
msgstr "날짜 *d*\\에 대해, ``str(d)``\\는 ``d.isoformat()``\\와 동등합니다."

#: ../Doc/library/datetime.rst:616
msgid ""
"Return a string representing the date, for example ``date(2002, 12, "
"4).ctime() == 'Wed Dec 4 00:00:00 2002'``. ``d.ctime()`` is equivalent to"
" ``time.ctime(time.mktime(d.timetuple()))`` on platforms where the native"
" C :c:func:`ctime` function (which :func:`time.ctime` invokes, but which "
":meth:`date.ctime` does not invoke) conforms to the C standard."
msgstr ""
"날짜를 나타내는 문자열을 반환합니다, 예를 들어 ``date(2002, 12, 4).ctime() == 'Wed Dec 4 "
"00:00:00 2002'``. ``d.ctime()``\\은 네이티브 C :c:func:`ctime` "
"함수(:func:`time.ctime`\\은 호출하지만 :meth:`date.ctime`\\은 호출하지 않습니다)가 C 표준을 "
"준수하는 플랫폼에서 ``time.ctime(time.mktime(d.timetuple()))``\\와 동등합니다."

#: ../Doc/library/datetime.rst:625
msgid ""
"Return a string representing the date, controlled by an explicit format "
"string. Format codes referring to hours, minutes or seconds will see 0 "
"values. For a complete list of formatting directives, see :ref:`strftime-"
"strptime-behavior`."
msgstr ""
"명시적인 포맷 문자열로 제어되는, 날짜를 나타내는 문자열을 반환합니다. 시, 분 또는 초를 나타내는 포맷 코드는 0 값을 보게 "
"됩니다. 포매팅 지시자의 전체 목록은, :ref:`strftime-strptime-behavior`\\를 참조하십시오."

#: ../Doc/library/datetime.rst:633
msgid ""
"Same as :meth:`.date.strftime`. This makes it possible to specify a "
"format string for a :class:`.date` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`. For a complete "
"list of formatting directives, see :ref:`strftime-strptime-behavior`."
msgstr ""
":meth:`.date.strftime`\\과 같습니다. 이것이 :ref:`포맷 문자열 리터럴 <f-strings>`\\과 "
":meth:`str.format`\\을 사용할 때 :class:`.date` 객체를 위한 포맷 문자열을 지정할 수 있도록 합니다. "
"포매팅 지시자의 전체 목록은 :ref:`strftime-strptime-behavior`\\를 참조하십시오."

#: ../Doc/library/datetime.rst:640
msgid "Example of counting days to an event::"
msgstr "이벤트까지 남은 날 수 계산 예::"

#: ../Doc/library/datetime.rst:658
msgid "Example of working with :class:`date`:"
msgstr ":class:`date`\\로 작업하는 예:"

#: ../Doc/library/datetime.rst:697
msgid ":class:`.datetime` Objects"
msgstr ":class:`.datetime` 객체"

#: ../Doc/library/datetime.rst:699
msgid ""
"A :class:`.datetime` object is a single object containing all the "
"information from a :class:`date` object and a :class:`.time` object.  "
"Like a :class:`date` object, :class:`.datetime` assumes the current "
"Gregorian calendar extended in both directions; like a time object, "
":class:`.datetime` assumes there are exactly 3600\\*24 seconds in every "
"day."
msgstr ""
":class:`.datetime` 객체는 :class:`date` 객체와 :class:`.time` 객체의 모든 정보를 포함하는 "
"단일 객체입니다. :class:`date` 객체와 마찬가지로, :class:`.datetime`\\은 현재의 그레고리력을 양방향으로"
" 확장한다고 가정합니다; time 객체와 마찬가지로, :class:`.datetime`\\은 하루가 정확히 3600\\*24초인 "
"것으로 가정합니다."

#: ../Doc/library/datetime.rst:705
msgid "Constructor:"
msgstr "생성자:"

#: ../Doc/library/datetime.rst:709
msgid ""
"The year, month and day arguments are required.  *tzinfo* may be "
"``None``, or an instance of a :class:`tzinfo` subclass.  The remaining "
"arguments may be integers, in the following ranges:"
msgstr ""
"year, month, day 인자는 필수입니다. *tzinfo*\\는 ``None``\\이거나 :class:`tzinfo` 서브 "
"클래스의 인스턴스일 수 있습니다. 나머지 인자는 다음 범위의 정수일 수 있습니다:"

#: ../Doc/library/datetime.rst:713
msgid "``MINYEAR <= year <= MAXYEAR``,"
msgstr "``MINYEAR <= year <= MAXYEAR``,"

#: ../Doc/library/datetime.rst:714
msgid "``1 <= month <= 12``,"
msgstr "``1 <= month <= 12``,"

#: ../Doc/library/datetime.rst:715
msgid "``1 <= day <= number of days in the given month and year``,"
msgstr "``1 <= day <= 주어진 month와 year에서의 날 수``,"

#: ../Doc/library/datetime.rst:716 ../Doc/library/datetime.rst:1428
msgid "``0 <= hour < 24``,"
msgstr "``0 <= hour < 24``,"

#: ../Doc/library/datetime.rst:717 ../Doc/library/datetime.rst:1429
msgid "``0 <= minute < 60``,"
msgstr "``0 <= minute < 60``,"

#: ../Doc/library/datetime.rst:718 ../Doc/library/datetime.rst:1430
msgid "``0 <= second < 60``,"
msgstr "``0 <= second < 60``,"

#: ../Doc/library/datetime.rst:719 ../Doc/library/datetime.rst:1431
msgid "``0 <= microsecond < 1000000``,"
msgstr "``0 <= microsecond < 1000000``,"

#: ../Doc/library/datetime.rst:720 ../Doc/library/datetime.rst:1432
msgid "``fold in [0, 1]``."
msgstr "``fold in [0, 1]``."

#: ../Doc/library/datetime.rst:724 ../Doc/library/datetime.rst:1052
#: ../Doc/library/datetime.rst:1556
msgid "Added the ``fold`` argument."
msgstr "``fold`` 인자가 추가되었습니다."

#: ../Doc/library/datetime.rst:731
msgid ""
"Return the current local datetime, with :attr:`.tzinfo` ``None``. This is"
" equivalent to ``datetime.fromtimestamp(time.time())``. See also "
":meth:`now`, :meth:`fromtimestamp`."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\인 현재 지역 datetime을 반환합니다. 이것은 "
"``datetime.fromtimestamp(time.time())``\\과 동등합니다. :meth:`now`, "
":meth:`fromtimestamp`\\를 참조하십시오."

#: ../Doc/library/datetime.rst:738
msgid ""
"Return the current local date and time.  If optional argument *tz* is "
"``None`` or not specified, this is like :meth:`today`, but, if possible, "
"supplies more precision than can be gotten from going through a "
":func:`time.time` timestamp (for example, this may be possible on "
"platforms supplying the C :c:func:`gettimeofday` function)."
msgstr ""
"현재의 지역 날짜와 시간을 반환합니다. 선택적 인자 *tz*\\가 ``None``\\이거나 지정되지 않으면, "
":meth:`today`\\와 유사합니다. 하지만, 가능하면 :func:`time.time` 타임스탬프를 통해 얻을 수 있는 것보다"
" 더 높은 정밀도를 제공합니다 (예를 들어, C :c:func:`gettimeofday` 함수를 제공하는 플랫폼에서 가능합니다)."

#: ../Doc/library/datetime.rst:744
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the current date and time are converted to *tz*’s time "
"zone.  In this case the result is equivalent to "
"``tz.fromutc(datetime.utcnow().replace(tzinfo=tz))``. See also "
":meth:`today`, :meth:`utcnow`."
msgstr ""
"*tz*\\가 ``None``\\이 아니면, :class:`tzinfo` 서브 클래스의 인스턴스여야 하며, 현재 날짜와 시간이 "
"*tz*\\의 시간대로 변환됩니다. 이때 결과는 "
"``tz.fromutc(datetime.utcnow().replace(tzinfo=tz))``\\와 동등합니다. "
":meth:`today`, :meth:`utcnow`\\도 참조하십시오."

#: ../Doc/library/datetime.rst:752
msgid ""
"Return the current UTC date and time, with :attr:`.tzinfo` ``None``. This"
" is like :meth:`now`, but returns the current UTC date and time, as a "
"naive :class:`.datetime` object.  An aware current UTC datetime can be "
"obtained by calling ``datetime.now(timezone.utc)``.  See also "
":meth:`now`."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\인 현재 UTC 날짜와 시간을 반환합니다. 이것은 :meth:`now`\\와 "
"비슷하지만, 현재의 UTC 날짜와 시간을 나이브 :class:`.datetime` 객체로 반환합니다. 현재 어웨어 UTC "
"datetime은 ``datetime.now(timezone.utc)``\\를 호출하여 얻을 수 있습니다. "
":meth:`now`\\도 참조하십시오."

#: ../Doc/library/datetime.rst:759
msgid ""
"Return the local date and time corresponding to the POSIX timestamp, such"
" as is returned by :func:`time.time`. If optional argument *tz* is "
"``None`` or not specified, the timestamp is converted to the platform's "
"local date and time, and the returned :class:`.datetime` object is naive."
msgstr ""
":func:`time.time`\\가 반환하는 것과 같은, POSIX timestamp에 해당하는 지역 날짜와 시간을 반환합니다. "
"선택적 인자 *tz*\\가 ``None``\\이거나 지정되지 않으면 timestamp는 플랫폼의 지역 날짜와 시간으로 변환되며, "
"반환된 :class:`.datetime` 객체는 나이브합니다."

#: ../Doc/library/datetime.rst:764
msgid ""
"If *tz* is not ``None``, it must be an instance of a :class:`tzinfo` "
"subclass, and the timestamp is converted to *tz*’s time zone.  In this "
"case the result is equivalent to "
"``tz.fromutc(datetime.utcfromtimestamp(timestamp).replace(tzinfo=tz))``."
msgstr ""
"*tz*\\가 ``None``\\이 아니면, :class:`tzinfo` 서브 클래스의 인스턴스여야 하며, timestamp는 "
"*tz*\\의 시간대로 변환됩니다. 이때 결과는 "
"``tz.fromutc(datetime.utcfromtimestamp(timestamp).replace(tzinfo=tz))``\\와"
" 동등합니다."

#: ../Doc/library/datetime.rst:769
msgid ""
":meth:`fromtimestamp` may raise :exc:`OverflowError`, if the timestamp is"
" out of the range of values supported by the platform C "
":c:func:`localtime` or :c:func:`gmtime` functions, and :exc:`OSError` on "
":c:func:`localtime` or :c:func:`gmtime` failure. It's common for this to "
"be restricted to years in 1970 through 2038. Note that on non-POSIX "
"systems that include leap seconds in their notion of a timestamp, leap "
"seconds are ignored by :meth:`fromtimestamp`, and then it's possible to "
"have two timestamps differing by a second that yield identical "
":class:`.datetime` objects. See also :meth:`utcfromtimestamp`."
msgstr ""
"timestamp가 플랫폼 C :c:func:`localtime`\\이나 :c:func:`gmtime` 함수에서 지원하는 값 범위를"
" 벗어나면 :meth:`fromtimestamp`\\가 :exc:`OverflowError`\\를 발생시킬 수 있고, "
":c:func:`localtime`\\이나 :c:func:`gmtime`\\이 실패하면 :exc:`OSError`\\를 발생시킬 수"
" 있습니다. 1970년에서 2038년까지로 제한되는 것이 일반적입니다. 타임스탬프에 윤초 개념을 포함하는 비 POSIX 시스템에서,"
" :meth:`fromtimestamp`\\는 윤초를 무시하므로, 1초 차이가 나는 두 개의 타임스탬프가 같은 "
":class:`.datetime` 객체를 산출할 수 있습니다. :meth:`utcfromtimestamp`\\도 참조하십시오."

#: ../Doc/library/datetime.rst:779
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp "
"is out of the range of values supported by the platform C "
":c:func:`localtime` or :c:func:`gmtime` functions. Raise :exc:`OSError` "
"instead of :exc:`ValueError` on :c:func:`localtime` or :c:func:`gmtime` "
"failure."
msgstr ""
"timestamp가 플랫폼 C :c:func:`localtime`\\이나 :c:func:`gmtime` 함수에서 지원하는 값 범위를"
" 벗어나면 :exc:`ValueError` 대신 :exc:`OverflowError`\\를 발생시킵니다. "
":c:func:`localtime`\\이나 :c:func:`gmtime`\\가 실패하면 :exc:`ValueError` 대신 "
":exc:`OSError`\\를 발생시킵니다."

#: ../Doc/library/datetime.rst:786
msgid ":meth:`fromtimestamp` may return instances with :attr:`.fold` set to 1."
msgstr ":meth:`fromtimestamp`\\는 :attr:`.fold`\\가 1로 설정된 인스턴스를 반환할 수 있습니다."

#: ../Doc/library/datetime.rst:791
msgid ""
"Return the UTC :class:`.datetime` corresponding to the POSIX timestamp, "
"with :attr:`.tzinfo` ``None``. This may raise :exc:`OverflowError`, if "
"the timestamp is out of the range of values supported by the platform C "
":c:func:`gmtime` function, and :exc:`OSError` on :c:func:`gmtime` "
"failure. It's common for this to be restricted to years in 1970 through "
"2038."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\인 POSIX timestamp에 해당하는 UTC "
":class:`.datetime`\\을 반환합니다. timestamp가 플랫폼 C :c:func:`gmtime` 함수에서 지원하는 "
"값 범위를 벗어나면 :exc:`OverflowError`\\가 발생하고, :c:func:`gmtime`\\가 실패하면 "
":exc:`OSError`\\가 발생합니다. 1970년에서 2038년까지로 제한되는 것이 일반적입니다."

#: ../Doc/library/datetime.rst:797
msgid "To get an aware :class:`.datetime` object, call :meth:`fromtimestamp`::"
msgstr "어웨어 :class:`.datetime` 객체를 얻으려며, :meth:`fromtimestamp`\\를 호출하십시오::"

#: ../Doc/library/datetime.rst:801
msgid ""
"On the POSIX compliant platforms, it is equivalent to the following "
"expression::"
msgstr "POSIX 호환 플랫폼에서, 다음 표현식과 동등합니다::"

#: ../Doc/library/datetime.rst:806
msgid ""
"except the latter formula always supports the full years range: between "
":const:`MINYEAR` and :const:`MAXYEAR` inclusive."
msgstr ""
"단, 후자의 식은 항상 전체 연도 범위를 지원합니다: :const:`MINYEAR`\\와 :const:`MAXYEAR` 사이, 경계"
" 포함."

#: ../Doc/library/datetime.rst:809
msgid ""
"Raise :exc:`OverflowError` instead of :exc:`ValueError` if the timestamp "
"is out of the range of values supported by the platform C "
":c:func:`gmtime` function. Raise :exc:`OSError` instead of "
":exc:`ValueError` on :c:func:`gmtime` failure."
msgstr ""
"timestamp가 플랫폼 C :c:func:`gmtime` 함수에서 지원하는 값 범위를 벗어나면 :exc:`ValueError` "
"대신 :exc:`OverflowError`\\를 발생시킵니다. :c:func:`gmtime`\\이 실패하면 "
":exc:`ValueError` 대신 :exc:`OSError`\\를 발생시킵니다."

#: ../Doc/library/datetime.rst:818
msgid ""
"Return the :class:`.datetime` corresponding to the proleptic Gregorian "
"ordinal, where January 1 of year 1 has ordinal 1. :exc:`ValueError` is "
"raised unless ``1 <= ordinal <= datetime.max.toordinal()``.  The hour, "
"minute, second and microsecond of the result are all 0, and "
":attr:`.tzinfo` is ``None``."
msgstr ""
"역산 그레고리력 서수(ordinal)에 해당하는 :class:`.datetime`\\을 반환합니다. 1년 1월 1일이 서수 "
"1입니다. ``1 <= ordinal <= datetime.max.toordinal()``\\이 아니면 "
":exc:`ValueError`\\가 발생합니다. 결과의 hour, minute, second 및 microsecond는 모두 "
"0이고, :attr:`.tzinfo`\\는 ``None``\\입니다."

#: ../Doc/library/datetime.rst:826
msgid ""
"Return a new :class:`.datetime` object whose date components are equal to"
" the given :class:`date` object's, and whose time components are equal to"
" the given :class:`.time` object's.  If the *tzinfo* argument is "
"provided, its value is used to set the :attr:`.tzinfo` attribute of the "
"result, otherwise the :attr:`~.time.tzinfo` attribute of the *time* "
"argument is used."
msgstr ""
"지정된 :class:`date` 객체와 같은 날짜 구성 요소와 지정된 :class:`.time` 객체와 같은 시간 구성 요소를 갖는"
" 새 :class:`.datetime` 객체를 반환합니다. *tzinfo* 인자가 제공되면, 그 값은 결과의 "
":attr:`.tzinfo` 어트리뷰트를 설정하는 데 사용되며, 그렇지 않으면 *time* 인자의 "
":attr:`~.time.tzinfo` 어트리뷰트가 사용됩니다."

#: ../Doc/library/datetime.rst:833
msgid ""
"For any :class:`.datetime` object *d*, ``d == datetime.combine(d.date(), "
"d.time(), d.tzinfo)``.  If date is a :class:`.datetime` object, its time "
"components and :attr:`.tzinfo` attributes are ignored."
msgstr ""
"모든 :class:`.datetime` 객체 *d*\\에 대해, ``d == datetime.combine(d.date(), "
"d.time(), d.tzinfo)``\\가 성립합니다. date가 :class:`.datetime` 객체면, 그것의 시간 구성 "
"요소와 :attr:`.tzinfo` 어트리뷰트가 무시됩니다."

#: ../Doc/library/datetime.rst:838
msgid "Added the *tzinfo* argument."
msgstr "*tzinfo* 인자가 추가되었습니다."

#: ../Doc/library/datetime.rst:844
msgid ""
"Return a :class:`datetime` corresponding to a *date_string* in one of the"
" formats emitted by :meth:`date.isoformat` and "
":meth:`datetime.isoformat`. Specifically, this function supports strings "
"in the format(s) ``YYYY-MM-"
"DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]``, where ``*`` can "
"match any single character."
msgstr ""
":meth:`date.isoformat`\\과 :meth:`datetime.isoformat`\\이 출력하는 형식 중 하나인 "
"*date_string*\\에 해당하는 :class:`datetime`\\을 반환합니다. 구체적으로, 이 함수는 ``YYYY-MM-"
"DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]`` 형식의 문자열을 지원합니다. 여기서 "
"``*``\\는 임의의 단일 문자와 일치 할 수 있습니다."

#: ../Doc/library/datetime.rst:852
msgid ""
"This does not support parsing arbitrary ISO 8601 strings - it is only "
"intended as the inverse operation of :meth:`datetime.isoformat`."
msgstr ""
"이것은 임의의 ISO 8601 문자열을 구문 분석하는 것을 지원하지 않습니다 - 이것은 "
":meth:`datetime.isoformat`\\의 역연산이고자 할 뿐입니다."

#: ../Doc/library/datetime.rst:859
msgid ""
"Return a :class:`.datetime` corresponding to *date_string*, parsed "
"according to *format*.  This is equivalent to "
"``datetime(*(time.strptime(date_string, format)[0:6]))``. "
":exc:`ValueError` is raised if the date_string and format can't be parsed"
" by :func:`time.strptime` or if it returns a value which isn't a time "
"tuple. For a complete list of formatting directives, see :ref:`strftime-"
"strptime-behavior`."
msgstr ""
"*format*\\에 따라 구문 분석된, *date_string*\\에 해당하는 :class:`.datetime`\\를 반환합니다."
" 이것은 ``datetime(*(time.strptime(date_string, format)[0:6]))``\\과 동등합니다. "
"date_string과 format을 :func:`time.strptime`\\로 구문 분석할 수 없거나, 시간 튜플이 아닌 값을 "
"반환하면 :exc:`ValueError`\\가 발생합니다. 포매팅 지시자의 전체 목록은 :ref:`strftime-strptime-"
"behavior`\\을 참조하십시오."

#: ../Doc/library/datetime.rst:872
msgid ""
"The earliest representable :class:`.datetime`, ``datetime(MINYEAR, 1, 1, "
"tzinfo=None)``."
msgstr "표현 가능한 가장 이른 :class:`.datetime`, ``datetime(MINYEAR, 1, 1, tzinfo=None)``."

#: ../Doc/library/datetime.rst:878
msgid ""
"The latest representable :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, "
"23, 59, 59, 999999, tzinfo=None)``."
msgstr ""
"표현 가능한 가장 늦은 :class:`.datetime`, ``datetime(MAXYEAR, 12, 31, 23, 59, 59, "
"999999, tzinfo=None)``."

#: ../Doc/library/datetime.rst:884
msgid ""
"The smallest possible difference between non-equal :class:`.datetime` "
"objects, ``timedelta(microseconds=1)``."
msgstr ""
"같지 않은 :class:`.datetime` 객체 간의 가능한 가장 작은 차이, "
"``timedelta(microseconds=1)``."

#: ../Doc/library/datetime.rst:907 ../Doc/library/datetime.rst:1461
msgid "In ``range(24)``."
msgstr "범위 ``range(24)``."

#: ../Doc/library/datetime.rst:912 ../Doc/library/datetime.rst:917
#: ../Doc/library/datetime.rst:1466 ../Doc/library/datetime.rst:1471
msgid "In ``range(60)``."
msgstr "범위 ``range(60)``."

#: ../Doc/library/datetime.rst:922 ../Doc/library/datetime.rst:1476
msgid "In ``range(1000000)``."
msgstr "범위 ``range(1000000)``."

#: ../Doc/library/datetime.rst:927
msgid ""
"The object passed as the *tzinfo* argument to the :class:`.datetime` "
"constructor, or ``None`` if none was passed."
msgstr ":class:`.datetime` 생성자에 *tzinfo* 인자로 전달된 객체이거나, 전달되지 않았으면 ``None``\\입니다."

#: ../Doc/library/datetime.rst:933 ../Doc/library/datetime.rst:1487
msgid ""
"In ``[0, 1]``.  Used to disambiguate wall times during a repeated "
"interval.  (A repeated interval occurs when clocks are rolled back at the"
" end of daylight saving time or when the UTC offset for the current zone "
"is decreased for political reasons.) The value 0 (1) represents the "
"earlier (later) of the two moments with the same wall time "
"representation."
msgstr ""
"``[0, 1]`` 범위입니다. 반복되는 구간 동안 벽 시간(wall time)의 모호함을 제거하는 데 사용됩니다. 반복되는 구간은"
" 일광 절약 시간이 끝날 때나 현재 지역의 UTC 오프셋이 정치적인 이유로 줄어들어 시계를 되돌릴 때 발생합니다. 값 0 (1)은 "
"같은 벽 시간을 나타내는 두 순간 중 이전 (이후)을 나타냅니다."

#: ../Doc/library/datetime.rst:946
msgid "``datetime2 = datetime1 + timedelta``"
msgstr "``datetime2 = datetime1 + timedelta``"

#: ../Doc/library/datetime.rst:946 ../Doc/library/datetime.rst:2065
#: ../Doc/library/datetime.rst:2070 ../Doc/library/datetime.rst:2082
#: ../Doc/library/datetime.rst:2087 ../Doc/library/datetime.rst:2147
#: ../Doc/library/datetime.rst:2152 ../Doc/library/datetime.rst:2156
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/library/datetime.rst:948
msgid "``datetime2 = datetime1 - timedelta``"
msgstr "``datetime2 = datetime1 - timedelta``"

#: ../Doc/library/datetime.rst:948 ../Doc/library/datetime.rst:2098
msgid "\\(2)"
msgstr "\\(2)"

#: ../Doc/library/datetime.rst:950
msgid "``timedelta = datetime1 - datetime2``"
msgstr "``timedelta = datetime1 - datetime2``"

#: ../Doc/library/datetime.rst:952
msgid "``datetime1 < datetime2``"
msgstr "``datetime1 < datetime2``"

#: ../Doc/library/datetime.rst:952
msgid "Compares :class:`.datetime` to :class:`.datetime`. (4)"
msgstr ":class:`.datetime`\\과 :class:`.datetime`\\을 비교합니다. (4)"

#: ../Doc/library/datetime.rst:957
msgid ""
"datetime2 is a duration of timedelta removed from datetime1, moving "
"forward in time if ``timedelta.days`` > 0, or backward if "
"``timedelta.days`` < 0.  The result has the same "
":attr:`~.datetime.tzinfo` attribute as the input datetime, and datetime2 "
"- datetime1 == timedelta after. :exc:`OverflowError` is raised if "
"datetime2.year would be smaller than :const:`MINYEAR` or larger than "
":const:`MAXYEAR`. Note that no time zone adjustments are done even if the"
" input is an aware object."
msgstr ""
"datetime2는 datetime1에서 timedelta 기간만큼 이동한 시간이며, ``timedelta.days`` > 0이면 "
"미래로, ``timedelta.days`` < 0이면 과거로 이동합니다. 결과는 입력 datetime과 같은 "
":attr:`~.datetime.tzinfo` 어트리뷰트를 가지고, 이후에 datetime2 - datetime1 == "
"timedelta 입니다. datetime2.year가 :const:`MINYEAR`\\보다 작거나 "
":const:`MAXYEAR`\\보다 커지려고 하면 :exc:`OverflowError`\\가 발생합니다. 입력이 어웨어 객체일 "
"때도 시간대 조정이 수행되지 않음에 유의하십시오."

#: ../Doc/library/datetime.rst:966
msgid ""
"Computes the datetime2 such that datetime2 + timedelta == datetime1. As "
"for addition, the result has the same :attr:`~.datetime.tzinfo` attribute"
" as the input datetime, and no time zone adjustments are done even if the"
" input is aware."
msgstr ""
"datetime2 + timedelta == datetime1를 만족하는 datetime2를 계산합니다. 덧셈과 마찬가지로, 결과는"
" 입력 datetime과 같은 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지며 입력이 어웨어일 때도 시간대 조정이"
" 수행되지 않습니다."

#: ../Doc/library/datetime.rst:971
msgid ""
"Subtraction of a :class:`.datetime` from a :class:`.datetime` is defined "
"only if both operands are naive, or if both are aware.  If one is aware "
"and the other is naive, :exc:`TypeError` is raised."
msgstr ""
":class:`.datetime`\\에서 :class:`.datetime`\\을 빼는 것은 두 피연산자 모두 나이브하거나, 모두 "
"어웨어할 때만 정의됩니다. 하나가 어웨어이고 다른 하나가 나이브면, :exc:`TypeError`\\가 발생합니다."

#: ../Doc/library/datetime.rst:975
msgid ""
"If both are naive, or both are aware and have the same "
":attr:`~.datetime.tzinfo` attribute, the :attr:`~.datetime.tzinfo` "
"attributes are ignored, and the result is a :class:`timedelta` object *t*"
" such that ``datetime2 + t == datetime1``.  No time zone adjustments are "
"done in this case."
msgstr ""
"둘 다 나이브하거나 둘 다 어웨어하고 같은 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, "
":attr:`~.datetime.tzinfo` 어트리뷰트는 무시되고 결과는 ``datetime2 + t == "
"datetime1``\\가 되도록 하는 :class:`timedelta` 객체 *t*\\입니다. 이때 시간대 조정이 수행되지 "
"않습니다."

#: ../Doc/library/datetime.rst:980
msgid ""
"If both are aware and have different :attr:`~.datetime.tzinfo` "
"attributes, ``a-b`` acts as if *a* and *b* were first converted to naive "
"UTC datetimes first.  The result is ``(a.replace(tzinfo=None) - "
"a.utcoffset()) - (b.replace(tzinfo=None) - b.utcoffset())`` except that "
"the implementation never overflows."
msgstr ""
"둘 다 어웨어하고 :attr:`~.datetime.tzinfo` 어트리뷰트가 다르면, ``a-b``\\는 *a* 와 *b*\\가 "
"먼저 나이브 UTC datetime으로 먼저 변환된 것처럼 작동합니다. 구현이 절대 오버플로 하지 않는다는 것을 제외하면 결과는 "
"``(a.replace(tzinfo=None) - a.utcoffset()) - (b.replace(tzinfo=None) - "
"b.utcoffset())``\\입니다."

#: ../Doc/library/datetime.rst:986
msgid ""
"*datetime1* is considered less than *datetime2* when *datetime1* precedes"
" *datetime2* in time."
msgstr ""
"*datetime1*\\이 *datetime2*\\에 앞서면 *datetime1*\\는 *datetime2*\\보다 작은 것으로 "
"간주합니다."

#: ../Doc/library/datetime.rst:989
msgid ""
"If one comparand is naive and the other is aware, :exc:`TypeError` is "
"raised if an order comparison is attempted.  For equality comparisons, "
"naive instances are never equal to aware instances."
msgstr ""
"하나의 비교 피연산자가 나이브하고 다른 하나는 어웨어하면, 순서 비교가 시도될 때 :exc:`TypeError`\\가 발생합니다. "
"동등(equality) 비교에서는, 나이브 인스턴스는 절대 어웨어 인스턴스와 같지 않습니다."

#: ../Doc/library/datetime.rst:993
msgid ""
"If both comparands are aware, and have the same :attr:`~.datetime.tzinfo`"
" attribute, the common :attr:`~.datetime.tzinfo` attribute is ignored and"
" the base datetimes are compared.  If both comparands are aware and have "
"different :attr:`~.datetime.tzinfo` attributes, the comparands are first "
"adjusted by subtracting their UTC offsets (obtained from "
"``self.utcoffset()``)."
msgstr ""
"비교 피연산자가 모두 어웨어하고, 같은 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, 공통 "
":attr:`~.datetime.tzinfo` 어트리뷰트가 무시되고 기본 datetime이 비교됩니다. 두 비교 피연산자가 모두 "
"어웨어하고 다른 :attr:`~.datetime.tzinfo` 어트리뷰트를 가지면, 비교 피연산자들은 먼저 그들의 UTC 오프셋 "
"(``self.utcoffset()``\\에서 얻습니다)을 뺀 값으로 조정됩니다."

#: ../Doc/library/datetime.rst:999
msgid ""
"Equality comparisons between naive and aware :class:`.datetime` instances"
" don't raise :exc:`TypeError`."
msgstr "나이브와 어웨어 :class:`.datetime` 인스턴스 간의 동등 비교는 :exc:`TypeError`\\를 발생시키지 않습니다."

#: ../Doc/library/datetime.rst:1005
msgid ""
"In order to stop comparison from falling back to the default scheme of "
"comparing object addresses, datetime comparison normally raises "
":exc:`TypeError` if the other comparand isn't also a :class:`.datetime` "
"object.  However, ``NotImplemented`` is returned instead if the other "
"comparand has a :meth:`timetuple` attribute.  This hook gives other kinds"
" of date objects a chance at implementing mixed-type comparison.  If not,"
" when a :class:`.datetime` object is compared to an object of a different"
" type, :exc:`TypeError` is raised unless the comparison is ``==`` or "
"``!=``.  The latter cases return :const:`False` or :const:`True`, "
"respectively."
msgstr ""
"비교가 객체 주소 기반의 기본 비교 체계로 떨어지는 것을 막기 위해, datetime 비교는 다른 비교 피연산자가 "
":class:`.datetime` 객체가 아니면 일반적으로 :exc:`TypeError`\\를 발생시킵니다. 그러나, 다른 비교 "
"피연산자에 :meth:`timetuple` 어트리뷰트가 있으면 ``NotImplemented``\\가 대신 반환됩니다. 이 훅은 "
"다른 형의 날짜 객체에 혼합형 비교를 구현할 기회를 제공합니다. 그렇지 않으면, :class:`.datetime` 객체가 다른 형의"
" 객체와 비교될 때, 비교가 ``==`` 나 ``!=``\\가 아니면 :exc:`TypeError`\\가 발생합니다. 두 상황에 "
"해당하면 각각 :const:`False` 나 :const:`True`\\를 반환합니다."

#: ../Doc/library/datetime.rst:1015
msgid ""
":class:`.datetime` objects can be used as dictionary keys. In Boolean "
"contexts, all :class:`.datetime` objects are considered to be true."
msgstr ""
":class:`.datetime` 객체는 딕셔너리 키로 사용할 수 있습니다. 불리언 문맥에서, 모든 "
":class:`.datetime` 객체는 참으로 간주합니다."

#: ../Doc/library/datetime.rst:1022
msgid "Return :class:`date` object with same year, month and day."
msgstr "같은 year, month, day의 :class:`date` 객체를 반환합니다."

#: ../Doc/library/datetime.rst:1027
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond "
"and fold. :attr:`.tzinfo` is ``None``.  See also method :meth:`timetz`."
msgstr ""
"같은 hour, minute, second, microsecond 및 fold의 :class:`.time` 객체를 반환합니다. "
":attr:`.tzinfo`\\는 ``None``\\입니다. 메서드 :meth:`timetz`\\도 참조하십시오."

#: ../Doc/library/datetime.rst:1030 ../Doc/library/datetime.rst:1039
msgid "The fold value is copied to the returned :class:`.time` object."
msgstr "fold 값은 반환된 :class:`.time` 객체에 복사됩니다."

#: ../Doc/library/datetime.rst:1036
msgid ""
"Return :class:`.time` object with same hour, minute, second, microsecond,"
" fold, and tzinfo attributes.  See also method :meth:`time`."
msgstr ""
"같은 hour, minute, second, microsecond, fold 및 tzinfo 어트리뷰트의 :class:`.time`"
" 객체를 반환합니다. 메서드 :meth:`time`\\도 참조하십시오."

#: ../Doc/library/datetime.rst:1047
msgid ""
"Return a datetime with the same attributes, except for those attributes "
"given new values by whichever keyword arguments are specified.  Note that"
" ``tzinfo=None`` can be specified to create a naive datetime from an "
"aware datetime with no conversion of date and time data."
msgstr ""
"키워드 인자로 새로운 값이 주어진 어트리뷰트를 제외하고, 같은 어트리뷰트를 가진 datetime을 반환합니다. "
"``tzinfo=None``\\을 지정하면 날짜와 시간 데이터의 변환 없이 어웨어 datetime에서 나이브 datetime을 만들"
" 수 있습니다."

#: ../Doc/library/datetime.rst:1058
msgid ""
"Return a :class:`.datetime` object with new :attr:`.tzinfo` attribute "
"*tz*, adjusting the date and time data so the result is the same UTC time"
" as *self*, but in *tz*'s local time."
msgstr ""
"새로운 :attr:`.tzinfo` 어트리뷰트 *tz*\\를 갖는 :class:`.datetime` 객체를 반환하는데, 결과가 "
"*self*\\와 같은 UTC 시간이지만 *tz*\\의 지역 시간이 되도록 날짜와 시간 데이터를 조정합니다."

#: ../Doc/library/datetime.rst:1062
msgid ""
"If provided, *tz* must be an instance of a :class:`tzinfo` subclass, and "
"its :meth:`utcoffset` and :meth:`dst` methods must not return ``None``.  "
"If *self* is naive, it is presumed to represent time in the system "
"timezone."
msgstr ""
"제공된다면 *tz*\\는 :class:`tzinfo` 서브 클래스의 인스턴스여야 하며, :meth:`utcoffset`\\과 "
":meth:`dst` 메서드는 ``None``\\을 반환하지 않아야 합니다. *self*\\가 나이브하면, 시스템 시간대의 시간을 "
"나타내는 것으로 가정합니다."

#: ../Doc/library/datetime.rst:1066
msgid ""
"If called without arguments (or with ``tz=None``) the system local "
"timezone is assumed for the target timezone.  The ``.tzinfo`` attribute "
"of the converted datetime instance will be set to an instance of "
":class:`timezone` with the zone name and offset obtained from the OS."
msgstr ""
"인자 없이 (또는 ``tz=None``\\으로) 호출되면 대상 시간대는 시스템 시간대로 간주합니다. 변환된 datetime "
"인스턴스의 ``.tzinfo`` 어트리뷰트는 OS에서 얻은 시간대 이름과 오프셋을 사용하는 :class:`timezone`\\의 "
"인스턴스로 설정됩니다."

#: ../Doc/library/datetime.rst:1071
msgid ""
"If ``self.tzinfo`` is *tz*, ``self.astimezone(tz)`` is equal to *self*:  "
"no adjustment of date or time data is performed. Else the result is local"
" time in the timezone *tz*, representing the same UTC time as *self*:  "
"after ``astz = dt.astimezone(tz)``, ``astz - astz.utcoffset()`` will have"
" the same date and time data as ``dt - dt.utcoffset()``."
msgstr ""
"``self.tzinfo``\\가 *tz*\\면, ``self.astimezone(tz)``\\는 *self*\\와 같습니다: "
"날짜나 시간 데이터 조정이 수행되지 않습니다. 그렇지 않으면 결과는 *self*\\와 같은 UTC 시간을 나타내는 *tz* 시간대의"
" 지역 시간입니다: ``astz = dt.astimezone(tz)`` 후에, ``astz - "
"astz.utcoffset()``\\는 ``dt - dt.utcoffset()``\\과 같은 날짜와 시간 데이터를 갖습니다."

#: ../Doc/library/datetime.rst:1077
msgid ""
"If you merely want to attach a time zone object *tz* to a datetime *dt* "
"without adjustment of date and time data, use ``dt.replace(tzinfo=tz)``."
"  If you merely want to remove the time zone object from an aware "
"datetime *dt* without conversion of date and time data, use "
"``dt.replace(tzinfo=None)``."
msgstr ""
"날짜와 시간 데이터를 조정하지 않고 시간대 객체 *tz*\\를 datetime *dt*\\에 연결하기만 하려면, "
"``dt.replace(tzinfo=tz)``\\를 사용하십시오. 날짜와 시간 데이터를 변환하지 않고 어웨어 datetime "
"*dt*\\에서 시간대 객체를 제거하려면, ``dt.replace(tzinfo=None)``\\를 사용하십시오."

#: ../Doc/library/datetime.rst:1082
msgid ""
"Note that the default :meth:`tzinfo.fromutc` method can be overridden in "
"a :class:`tzinfo` subclass to affect the result returned by "
":meth:`astimezone`. Ignoring error cases, :meth:`astimezone` acts like::"
msgstr ""
"기본 :meth:`tzinfo.fromutc` 메서드는 :meth:`astimezone`\\에 의해 반환된 결과에 영향을 주도록 "
":class:`tzinfo` 서브 클래스에서 재정의할 수 있습니다. 에러가 발생하는 경우를 무시하고, "
":meth:`astimezone`\\는 다음과 같이 작동합니다::"

#: ../Doc/library/datetime.rst:1094
msgid "*tz* now can be omitted."
msgstr "이제 *tz*\\를 생략할 수 있습니다."

#: ../Doc/library/datetime.rst:1097
msgid ""
"The :meth:`astimezone` method can now be called on naive instances that "
"are presumed to represent system local time."
msgstr ""
"이제 :meth:`astimezone` 메서드는 이제 나이브 인스턴스에서 호출될 수 있는데, 시스템 지역 시간을 나타내는 것으로 "
"간주합니다."

#: ../Doc/library/datetime.rst:1104
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.utcoffset(self)``, and raises an exception if the latter "
"doesn't return ``None`` or a :class:`timedelta` object with magnitude "
"less than one day."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.utcoffset(self)``\\를 반환하고, 후자가 ``None`` 이나 하루 미만의 크기를 가진 "
":class:`timedelta` 객체를 반환하지 않으면 예외를 발생시킵니다."

#: ../Doc/library/datetime.rst:1108 ../Doc/library/datetime.rst:1628
#: ../Doc/library/datetime.rst:1728 ../Doc/library/datetime.rst:1969
#: ../Doc/library/datetime.rst:1980 ../Doc/library/datetime.rst:2246
msgid "The UTC offset is not restricted to a whole number of minutes."
msgstr "UTC 오프셋은 분 단위로 제한되지 않습니다."

#: ../Doc/library/datetime.rst:1114
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.dst(self)``, and raises an exception if the latter doesn't "
"return ``None`` or a :class:`timedelta` object with magnitude less than "
"one day."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.dst(self)``\\를 반환하고, 후자가 ``None`` 이나 하루 미만의 크기를 가진 "
":class:`timedelta` 객체를 반환하지 않으면 예외를 발생시킵니다."

#: ../Doc/library/datetime.rst:1118 ../Doc/library/datetime.rst:1638
#: ../Doc/library/datetime.rst:1780
msgid "The DST offset is not restricted to a whole number of minutes."
msgstr "DST 오프셋은 분 단위로 제한되지 않습니다."

#: ../Doc/library/datetime.rst:1124
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.tzname(self)``, raises an exception if the latter doesn't "
"return ``None`` or a string object,"
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.tzname(self)``\\를 반환하고, 후자가 ``None``\\이나 문자열 객체를 반환하지 않으면 "
"예외를 발생시킵니다."

#: ../Doc/library/datetime.rst:1131
msgid ""
"Return a :class:`time.struct_time` such as returned by "
":func:`time.localtime`. ``d.timetuple()`` is equivalent to "
"``time.struct_time((d.year, d.month, d.day, d.hour, d.minute, d.second, "
"d.weekday(), yday, dst))``, where ``yday = d.toordinal() - date(d.year, "
"1, 1).toordinal() + 1`` is the day number within the current year "
"starting with ``1`` for January 1st. The :attr:`tm_isdst` flag of the "
"result is set according to the :meth:`dst` method: :attr:`.tzinfo` is "
"``None`` or :meth:`dst` returns ``None``, :attr:`tm_isdst` is set to "
"``-1``; else if :meth:`dst` returns a non-zero value, :attr:`tm_isdst` is"
" set to ``1``; else :attr:`tm_isdst` is set to ``0``."
msgstr ""
":func:`time.localtime`\\이 반환하는 것과 같은 :class:`time.struct_time`\\을 반환합니다. "
"``d.timetuple()``\\는 ``time.struct_time((d.year, d.month, d.day, d.hour, "
"d.minute, d.second, d.weekday(), yday, dst))``\\와 동등합니다. 여기서 ``yday = "
"d.toordinal() - date(d.year, 1, 1).toordinal() + 1``\\는 1월 1일에 ``1``\\로 "
"시작하는 현재 연도의 날짜 번호입니다. 결과의 :attr:`tm_isdst` 플래그는 :meth:`dst` 메서드에 따라 "
"설정됩니다: :attr:`.tzinfo`\\가 ``None``\\이거나 :meth:`dst`\\가 ``None``\\을 반환하면, "
":attr:`tm_isdst`\\는 ``-1``\\로 설정됩니다; 그렇지 않고 :meth:`dst`\\가 0이 아닌 값을 반환하면,"
" :attr:`tm_isdst`\\는 ``1``\\로 설정됩니다; 그렇지 않으면 :attr:`tm_isdst`\\는 "
"``0``\\으로 설정됩니다."

#: ../Doc/library/datetime.rst:1144
msgid ""
"If :class:`.datetime` instance *d* is naive, this is the same as "
"``d.timetuple()`` except that :attr:`tm_isdst` is forced to 0 regardless "
"of what ``d.dst()`` returns.  DST is never in effect for a UTC time."
msgstr ""
":class:`.datetime` 인스턴스 *d*\\가 나이브하면, 이것은 ``d.dst()``\\가 무엇을 반환하는지와 관계없이 "
":attr:`tm_isdst`\\가 강제로 0이 된다는 점만 제외하면, ``d.timetuple()``\\와 같습니다. DST는 "
"UTC 시간에는 적용되지 않습니다."

#: ../Doc/library/datetime.rst:1148
msgid ""
"If *d* is aware, *d* is normalized to UTC time, by subtracting "
"``d.utcoffset()``, and a :class:`time.struct_time` for the normalized "
"time is returned.  :attr:`tm_isdst` is forced to 0. Note that an "
":exc:`OverflowError` may be raised if *d*.year was ``MINYEAR`` or "
"``MAXYEAR`` and UTC adjustment spills over a year boundary."
msgstr ""
"*d*\\가 어웨어하면, *d*\\는 ``d.utcoffset()``\\를 빼서 UTC 시간으로 정규화되고, 정규화된 시간의 "
":class:`time.struct_time`\\가 반환됩니다. :attr:`tm_isdst`\\는 강제로 0이 됩니다. "
"*d*.year가 ``MINYEAR``\\나 ``MAXYEAR``\\이고 UTC 조정이 연도 경계를 넘어가면 "
":exc:`OverflowError`\\가 발생할 수 있습니다."

#: ../Doc/library/datetime.rst:1158
msgid ""
"Return the proleptic Gregorian ordinal of the date.  The same as "
"``self.date().toordinal()``."
msgstr "날짜의 역산 그레고리력 서수를 반환합니다. ``self.date().toordinal()``\\과 같습니다."

#: ../Doc/library/datetime.rst:1163
msgid ""
"Return POSIX timestamp corresponding to the :class:`.datetime` instance."
"  The return value is a :class:`float` similar to that returned by "
":func:`time.time`."
msgstr ""
":class:`.datetime` 인스턴스에 해당하는 POSIX 타임스탬프를 반환합니다. 반환 값은 "
":func:`time.time`\\이 반환하는 것과 비슷한 :class:`float`\\입니다."

#: ../Doc/library/datetime.rst:1167
msgid ""
"Naive :class:`.datetime` instances are assumed to represent local time "
"and this method relies on the platform C :c:func:`mktime` function to "
"perform the conversion.  Since :class:`.datetime` supports wider range of"
" values than :c:func:`mktime` on many platforms, this method may raise "
":exc:`OverflowError` for times far in the past or far in the future."
msgstr ""
"나이브 :class:`.datetime` 인스턴스는 지역 시간을 나타내는 것으로 간주하며 이 메서드는 변환을 수행하기 위해 플랫폼 "
"C :c:func:`mktime` 함수에 의존합니다. :class:`.datetime`\\는 많은 플랫폼에서 "
":c:func:`mktime`\\보다 더 넓은 범위의 값을 지원하기 때문에, 이 메서드는 먼 과거나 먼 미래의 시간에 대해 "
":exc:`OverflowError`\\를 발생시킬 수 있습니다."

#: ../Doc/library/datetime.rst:1174
msgid "For aware :class:`.datetime` instances, the return value is computed as::"
msgstr "어웨어 :class:`.datetime` 인스턴스의 경우, 반환 값은 다음과 같이 계산됩니다::"

#: ../Doc/library/datetime.rst:1181
msgid ""
"The :meth:`timestamp` method uses the :attr:`.fold` attribute to "
"disambiguate the times during a repeated interval."
msgstr ":meth:`timestamp` 메서드는 :attr:`.fold` 어트리뷰트를 사용하여 반복되는 구간의 시간을 구분합니다."

#: ../Doc/library/datetime.rst:1187
msgid ""
"There is no method to obtain the POSIX timestamp directly from a naive "
":class:`.datetime` instance representing UTC time.  If your application "
"uses this convention and your system timezone is not set to UTC, you can "
"obtain the POSIX timestamp by supplying ``tzinfo=timezone.utc``::"
msgstr ""
"UTC 시간을 나타내는 나이브 :class:`.datetime` 인스턴스에서 직접 POSIX 타임스탬프를 얻는 메서드는 없습니다. "
"응용 프로그램에서 이 관례를 사용하고 시스템 시간대가 UTC로 설정되어 있지 않으면, "
"``tzinfo=timezone.utc``\\를 제공하여 POSIX 타임스탬프를 얻을 수 있습니다::"

#: ../Doc/library/datetime.rst:1195
msgid "or by calculating the timestamp directly::"
msgstr "또는 직접 타임스탬프를 계산할 수 있습니다::"

#: ../Doc/library/datetime.rst:1201
msgid ""
"Return the day of the week as an integer, where Monday is 0 and Sunday is"
" 6. The same as ``self.date().weekday()``. See also :meth:`isoweekday`."
msgstr ""
"정수로 요일을 반환합니다. 월요일은 0이고 일요일은 6입니다. ``self.date().weekday()``\\와 같습니다. "
":meth:`isoweekday`\\도 참조하십시오."

#: ../Doc/library/datetime.rst:1207
msgid ""
"Return the day of the week as an integer, where Monday is 1 and Sunday is"
" 7. The same as ``self.date().isoweekday()``. See also :meth:`weekday`, "
":meth:`isocalendar`."
msgstr ""
"정수로 요일을 반환합니다. 월요일은 1이고 일요일은 7입니다. ``self.date().isoweekday()``\\와 같습니다. "
":meth:`weekday`, :meth:`isocalendar`\\도 참조하십시오."

#: ../Doc/library/datetime.rst:1214
msgid ""
"Return a 3-tuple, (ISO year, ISO week number, ISO weekday).  The same as "
"``self.date().isocalendar()``."
msgstr ""
"3-튜플 (ISO 연도, ISO 주 번호, ISO 요일) 을 반환합니다. ``self.date().isocalendar()``\\와"
" 같습니다."

#: ../Doc/library/datetime.rst:1220
msgid ""
"Return a string representing the date and time in ISO 8601 format, YYYY-"
"MM-DDTHH:MM:SS.ffffff or, if :attr:`microsecond` is 0, YYYY-MM-"
"DDTHH:MM:SS"
msgstr ""
"ISO 8601 형식으로 날짜와 시간을 나타내는 문자열을 반환합니다, YYYY-MM-DDTHH:MM:SS.ffffff, 또는 "
":attr:`microsecond`\\가 0이면, YYYY-MM-DDTHH:MM:SS"

#: ../Doc/library/datetime.rst:1224
msgid ""
"If :meth:`utcoffset` does not return ``None``, a string is appended, "
"giving the UTC offset: YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or,"
" if :attr:`microsecond` is 0 YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]."
msgstr ""
":meth:`utcoffset`\\이 ``None``\\을 반환하지 않으면, UTC 오프셋을 제공하는 문자열을 덧붙입니다: "
"YYYY-MM-DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]], 또는 :attr:`microsecond`\\가"
" 0이면, YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]]."

#: ../Doc/library/datetime.rst:1229
msgid ""
"The optional argument *sep* (default ``'T'``) is a one-character "
"separator, placed between the date and time portions of the result.  For "
"example,"
msgstr "선택적 인자 *sep*\\(기본값 ``'T'``)은 한 문자 구분자로, 결과의 날짜와 시간 부분 사이에 배치됩니다. 예를 들어,"

#: ../Doc/library/datetime.rst:1239 ../Doc/library/datetime.rst:1567
msgid ""
"The optional argument *timespec* specifies the number of additional "
"components of the time to include (the default is ``'auto'``). It can be "
"one of the following:"
msgstr ""
"선택적 인자 *timespec*\\은 포함할 시간의 추가 구성 요소 수를 지정합니다 (기본값은 ``'auto'``\\입니다). 다음"
" 중 하나일 수 있습니다:"

#: ../Doc/library/datetime.rst:1243 ../Doc/library/datetime.rst:1571
msgid ""
"``'auto'``: Same as ``'seconds'`` if :attr:`microsecond` is 0, same as "
"``'microseconds'`` otherwise."
msgstr ""
"``'auto'``: :attr:`microsecond`\\가 0이면 ``'seconds'``\\와 같고, 그렇지 않으면 "
"``'microseconds'``\\와 같습니다."

#: ../Doc/library/datetime.rst:1245 ../Doc/library/datetime.rst:1573
msgid "``'hours'``: Include the :attr:`hour` in the two-digit HH format."
msgstr "``'hours'``: :attr:`hour`\\를 두 자리 숫자 HH 형식으로 포함합니다."

#: ../Doc/library/datetime.rst:1246 ../Doc/library/datetime.rst:1574
msgid "``'minutes'``: Include :attr:`hour` and :attr:`minute` in HH:MM format."
msgstr "``'minutes'``: :attr:`hour`\\와 :attr:`minute`\\를 HH:MM 형식으로 포함합니다."

#: ../Doc/library/datetime.rst:1247 ../Doc/library/datetime.rst:1575
msgid ""
"``'seconds'``: Include :attr:`hour`, :attr:`minute`, and :attr:`second` "
"in HH:MM:SS format."
msgstr ""
"``'seconds'``: :attr:`hour`, :attr:`minute` 및 :attr:`second`\\를 HH:MM:SS "
"형식으로 포함합니다."

#: ../Doc/library/datetime.rst:1249 ../Doc/library/datetime.rst:1577
msgid ""
"``'milliseconds'``: Include full time, but truncate fractional second "
"part to milliseconds. HH:MM:SS.sss format."
msgstr "``'milliseconds'``: 전체 시간을 포함하지만, 초 미만은 밀리초 단위로 자릅니다. HH:MM:SS.sss 형식입니다."

#: ../Doc/library/datetime.rst:1251 ../Doc/library/datetime.rst:1579
msgid "``'microseconds'``: Include full time in HH:MM:SS.ffffff format."
msgstr "``'microseconds'``: 전체 시간을 HH:MM:SS.ffffff 형식으로 포함합니다."

#: ../Doc/library/datetime.rst:1255 ../Doc/library/datetime.rst:1583
msgid "Excluded time components are truncated, not rounded."
msgstr "제외된 시간 구성 요소는 반올림되지 않고 잘립니다."

#: ../Doc/library/datetime.rst:1257 ../Doc/library/datetime.rst:1585
msgid ":exc:`ValueError` will be raised on an invalid *timespec* argument."
msgstr "잘못된 *timespec* 인자는 :exc:`ValueError`\\를 발생시킵니다."

#: ../Doc/library/datetime.rst:1267 ../Doc/library/datetime.rst:1597
msgid "Added the *timespec* argument."
msgstr "*timespec* 인자가 추가되었습니다."

#: ../Doc/library/datetime.rst:1273
msgid ""
"For a :class:`.datetime` instance *d*, ``str(d)`` is equivalent to "
"``d.isoformat(' ')``."
msgstr ""
":class:`.datetime` 인스턴스 *d*\\에 대해, ``str(d)``\\는 ``d.isoformat(' ')``\\과 "
"동등합니다."

#: ../Doc/library/datetime.rst:1279
msgid ""
"Return a string representing the date and time, for example "
"``datetime(2002, 12, 4, 20, 30, 40).ctime() == 'Wed Dec  4 20:30:40 "
"2002'``. ``d.ctime()`` is equivalent to "
"``time.ctime(time.mktime(d.timetuple()))`` on platforms where the native "
"C :c:func:`ctime` function (which :func:`time.ctime` invokes, but which "
":meth:`datetime.ctime` does not invoke) conforms to the C standard."
msgstr ""
"날짜와 시간을 나타내는 문자열을 반환합니다, 예를 들어 ``datetime(2002, 12, 4, 20, 30, "
"40).ctime() == 'Wed Dec  4 20:30:40 2002'``. ``d.ctime()``\\은 네이티브 C "
":c:func:`ctime` 함수(:func:`time.ctime`\\이 호출하지만, :meth:`datetime.ctime`\\은"
" 호출하지 않습니다)가 C 표준을 준수하는 플랫폼에서 "
"``time.ctime(time.mktime(d.timetuple()))``\\과 동등합니다."

#: ../Doc/library/datetime.rst:1288
msgid ""
"Return a string representing the date and time, controlled by an explicit"
" format string.  For a complete list of formatting directives, see :ref"
":`strftime-strptime-behavior`."
msgstr ""
"명시적인 포맷 문자열에 의해 제어되는 날짜와 시간을 나타내는 문자열을 반환합니다. 포매팅 지시자의 전체 목록은 :ref"
":`strftime-strptime-behavior`\\을 참조하십시오."

#: ../Doc/library/datetime.rst:1295
msgid ""
"Same as :meth:`.datetime.strftime`.  This makes it possible to specify a "
"format string for a :class:`.datetime` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`.  For a complete "
"list of formatting directives, see :ref:`strftime-strptime-behavior`."
msgstr ""
":meth:`.datetime.strftime`\\과 같습니다. 이것이 :ref:`포맷 문자열 리터럴 <f-strings>`\\과 "
":meth:`str.format`\\을 사용할 때 :class:`.datetime` 객체를 위한 포맷 문자열을 지정할 수 있도록 "
"합니다. 포매팅 지시자의 전체 목록은 :ref:`strftime-strptime-behavior`\\을 참조하십시오."

#: ../Doc/library/datetime.rst:1302
msgid "Examples of working with datetime objects:"
msgstr "datetime 객체로 작업하는 예제:"

#: ../Doc/library/datetime.rst:1349
msgid "Using datetime with tzinfo:"
msgstr "tzinfo와 함께 datetime 사용하기:"

#: ../Doc/library/datetime.rst:1417
msgid ":class:`.time` Objects"
msgstr ":class:`.time` 객체"

#: ../Doc/library/datetime.rst:1419
msgid ""
"A time object represents a (local) time of day, independent of any "
"particular day, and subject to adjustment via a :class:`tzinfo` object."
msgstr "time 객체는 특정 날짜와 관계없는 (지역) 시간을 나타내며, :class:`tzinfo` 객체를 통해 조정할 수 있습니다."

#: ../Doc/library/datetime.rst:1424
msgid ""
"All arguments are optional.  *tzinfo* may be ``None``, or an instance of "
"a :class:`tzinfo` subclass.  The remaining arguments may be integers, in "
"the following ranges:"
msgstr ""
"모든 인자는 선택적입니다. *tzinfo*\\는 ``None``, 또는 :class:`tzinfo` 서브 클래스의 인스턴스일 수 "
"있습니다. 나머지 인자는 다음 범위의 정수일 수 있습니다:"

#: ../Doc/library/datetime.rst:1434
msgid ""
"If an argument outside those ranges is given, :exc:`ValueError` is "
"raised.  All default to ``0`` except *tzinfo*, which defaults to "
":const:`None`."
msgstr ""
"이 범위를 벗어나는 인자가 주어지면, :exc:`ValueError`\\가 발생합니다. *tzinfo*\\의 기본값은 "
":const:`None`\\이고, 그 외의 모든 기본값은 ``0``\\입니다."

#: ../Doc/library/datetime.rst:1442
msgid "The earliest representable :class:`.time`, ``time(0, 0, 0, 0)``."
msgstr "표현 가능한 가장 이른 :class:`.time`, ``time(0, 0, 0, 0)``."

#: ../Doc/library/datetime.rst:1447
msgid "The latest representable :class:`.time`, ``time(23, 59, 59, 999999)``."
msgstr "표현 가능한 가장 늦은 :class:`.time`, ``time(23, 59, 59, 999999)``."

#: ../Doc/library/datetime.rst:1452
msgid ""
"The smallest possible difference between non-equal :class:`.time` "
"objects, ``timedelta(microseconds=1)``, although note that arithmetic on "
":class:`.time` objects is not supported."
msgstr ""
"같지 않은 :class:`.time` 객체 간의 가능한 가장 작은 차이, ``timedelta(microseconds=1)``, "
"하지만 :class:`.time` 객체에 대한 산술은 지원되지 않습니다."

#: ../Doc/library/datetime.rst:1481
msgid ""
"The object passed as the tzinfo argument to the :class:`.time` "
"constructor, or ``None`` if none was passed."
msgstr ":class:`.time` 생성자에 *tzinfo* 인자로 전달된 객체이거나, 전달되지 않았으면 ``None``\\입니다."

#: ../Doc/library/datetime.rst:1498
msgid ""
"comparison of :class:`.time` to :class:`.time`, where *a* is considered "
"less than *b* when *a* precedes *b* in time.  If one comparand is naive "
"and the other is aware, :exc:`TypeError` is raised if an order comparison"
" is attempted. For equality comparisons, naive instances are never equal "
"to aware instances."
msgstr ""
":class:`.time`\\과 :class:`.time`\\의 비교, 이때 *a*\\가 *b*\\에 앞서면 *a*\\가 "
"*b*\\보다 작은 것으로 간주합니다. 하나의 비교 피연산자가 나이브하고 다른 하나는 어웨어하면, 순서 비교가 시도될 때 "
":exc:`TypeError`\\가 발생합니다. 동등(equality) 비교에서는, 나이브 인스턴스는 절대 어웨어 인스턴스와 같지 "
"않습니다."

#: ../Doc/library/datetime.rst:1503
msgid ""
"If both comparands are aware, and have the same :attr:`~time.tzinfo` "
"attribute, the common :attr:`~time.tzinfo` attribute is ignored and the "
"base times are compared.  If both comparands are aware and have different"
" :attr:`~time.tzinfo` attributes, the comparands are first adjusted by "
"subtracting their UTC offsets (obtained from ``self.utcoffset()``). In "
"order to stop mixed-type comparisons from falling back to the default "
"comparison by object address, when a :class:`.time` object is compared to"
" an object of a different type, :exc:`TypeError` is raised unless the "
"comparison is ``==`` or ``!=``.  The latter cases return :const:`False` "
"or :const:`True`, respectively."
msgstr ""
"비교 피연산자가 모두 어웨어하고, 같은 :attr:`~time.tzinfo` 어트리뷰트를 가지면, 공통 "
":attr:`~time.tzinfo` 어트리뷰트가 무시되고 기본 time이 비교됩니다. 두 비교 피연산자가 모두 어웨어하고 다른 "
":attr:`~time.tzinfo` 어트리뷰트를 가지면, 비교 피연산자들은 먼저 그들의 UTC 오프셋 "
"(``self.utcoffset()``\\에서 얻습니다)을 뺀 값으로 조정됩니다. 혼합형 비교가 객체 주소 기반의 기본 비교로 "
"떨어지는 것을 막기 위해, :class:`.time` 객체가 다른 형의 객체와 비교될 때, 비교가 ``==`` 이나 "
"``!=``\\가 아니면 :exc:`TypeError`\\가 발생합니다. 두 상황에 해당하면 각각 :const:`False` 나 "
":const:`True`\\를 반환합니다."

#: ../Doc/library/datetime.rst:1513
msgid ""
"Equality comparisons between naive and aware :class:`~datetime.time` "
"instances don't raise :exc:`TypeError`."
msgstr ""
"나이브와 어웨어 :class:`~datetime.time` 인스턴스 간의 동등 비교는 :exc:`TypeError`\\를 발생시키지"
" 않습니다."

#: ../Doc/library/datetime.rst:1517
msgid "hash, use as dict key"
msgstr "hash, 딕셔너리 키로 사용"

#: ../Doc/library/datetime.rst:1519
msgid "efficient pickling"
msgstr "효율적인 피클링"

#: ../Doc/library/datetime.rst:1521
msgid ""
"In boolean contexts, a :class:`.time` object is always considered to be "
"true."
msgstr "불리언 문맥에서, :class:`.time` 객체는 항상 참으로 간주합니다."

#: ../Doc/library/datetime.rst:1523
msgid ""
"Before Python 3.5, a :class:`.time` object was considered to be false if "
"it represented midnight in UTC.  This behavior was considered obscure and"
" error-prone and has been removed in Python 3.5.  See :issue:`13936` for "
"full details."
msgstr ""
"파이썬 3.5 이전에, :class:`.time` 객체는 UTC 자정을 나타낼 때 거짓으로 간주했습니다. 이 동작은 애매하고 에러가"
" 발생하기 쉬운 것으로 간주하여 파이썬 3.5에서 제거되었습니다. 자세한 내용은 :issue:`13936`\\를 참조하십시오."

#: ../Doc/library/datetime.rst:1530
msgid "Other constructor:"
msgstr "기타 생성자:"

#: ../Doc/library/datetime.rst:1534
msgid ""
"Return a :class:`time` corresponding to a *time_string* in one of the "
"formats emitted by :meth:`time.isoformat`. Specifically, this function "
"supports strings in the format(s) "
"``HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]``."
msgstr ""
":meth:`time.isoformat`\\이 출력하는 형식 중 하나인 *time_string*\\에 해당하는 "
":class:`time`\\을 반환합니다. 구체적으로, 이 함수는 "
"``HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]`` 형식의 문자열을 지원합니다."

#: ../Doc/library/datetime.rst:1540
msgid ""
"This does not support parsing arbitrary ISO 8601 strings - it is only "
"intended as the inverse operation of :meth:`time.isoformat`."
msgstr ""
"이것은 임의의 ISO 8601 문자열을 구문 분석하는 것을 지원하지 않습니다 - 이것은 "
":meth:`time.isoformat`\\의 역연산이고자 할 뿐입니다."

#: ../Doc/library/datetime.rst:1551
msgid ""
"Return a :class:`.time` with the same value, except for those attributes "
"given new values by whichever keyword arguments are specified.  Note that"
" ``tzinfo=None`` can be specified to create a naive :class:`.time` from "
"an aware :class:`.time`, without conversion of the time data."
msgstr ""
"키워드 인자로 새로운 값이 주어진 어트리뷰트를 제외하고, 같은 값을 가진 :class:`.time`\\을 반환합니다. "
"``tzinfo=None``\\을 지정하면 시간 데이터의 변환 없이 어웨어 :class:`.time`\\에서 나이브 "
":class:`.time`\\을 만들 수 있습니다."

#: ../Doc/library/datetime.rst:1562
msgid ""
"Return a string representing the time in ISO 8601 format, HH:MM:SS.ffffff"
" or, if :attr:`microsecond` is 0, HH:MM:SS If :meth:`utcoffset` does not "
"return ``None``, a string is appended, giving the UTC offset: "
"HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or, if self.microsecond is 0, "
"HH:MM:SS+HH:MM[:SS[.ffffff]]."
msgstr ""
"ISO 8601 형식으로 시간을 나타내는 문자열을 반환합니다, HH:MM:SS.ffffff, 또는 "
":attr:`microsecond`\\가 0이면, HH:MM:SS :meth:`utcoffset`\\이 ``None``\\을 "
"반환하지 않으면, UTC 오프셋을 제공하는 문자열을 덧붙입니다: HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]], "
"또는 self.microsecond가 0이면, HH:MM:SS+HH:MM[:SS[.ffffff]]."

#: ../Doc/library/datetime.rst:1603
msgid "For a time *t*, ``str(t)`` is equivalent to ``t.isoformat()``."
msgstr "time *t*\\에 대해, ``str(t)``\\는 ``t.isoformat()``\\과 동등합니다."

#: ../Doc/library/datetime.rst:1608
msgid ""
"Return a string representing the time, controlled by an explicit format "
"string.  For a complete list of formatting directives, see :ref"
":`strftime-strptime-behavior`."
msgstr ""
"명시적인 포맷 문자열로 제어되는, 시간을 나타내는 문자열을 반환합니다. 포매팅 지시자의 전체 목록은, :ref:`strftime-"
"strptime-behavior`\\을 참조하십시오."

#: ../Doc/library/datetime.rst:1615
msgid ""
"Same as :meth:`.time.strftime`. This makes it possible to specify a "
"format string for a :class:`.time` object in :ref:`formatted string "
"literals <f-strings>` and when using :meth:`str.format`.  For a complete "
"list of formatting directives, see :ref:`strftime-strptime-behavior`."
msgstr ""
":meth:`.time.strftime`\\과 같습니다. 이것이 :ref:`포맷 문자열 리터럴 <f-strings>`\\과 "
":meth:`str.format`\\을 사용할 때 :class:`.time` 객체를 위한 포맷 문자열을 지정할 수 있도록 합니다. "
"포매팅 지시자의 전체 목록은 :ref:`strftime-strptime-behavior`\\을 참조하십시오."

#: ../Doc/library/datetime.rst:1624
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.utcoffset(None)``, and raises an exception if the latter "
"doesn't return ``None`` or a :class:`timedelta` object with magnitude "
"less than one day."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.utcoffset(None)``\\를 반환하고, 후자가 ``None`` 이나 하루 미만의 크기를 가진 "
":class:`timedelta` 객체를 반환하지 않으면 예외를 발생시킵니다."

#: ../Doc/library/datetime.rst:1634
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.dst(None)``, and raises an exception if the latter doesn't "
"return ``None``, or a :class:`timedelta` object with magnitude less than "
"one day."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.dst(None)``\\를 반환하고, 후자가 ``None`` 이나 하루 미만의 크기를 가진 "
":class:`timedelta` 객체를 반환하지 않으면 예외를 발생시킵니다."

#: ../Doc/library/datetime.rst:1643
msgid ""
"If :attr:`.tzinfo` is ``None``, returns ``None``, else returns "
"``self.tzinfo.tzname(None)``, or raises an exception if the latter "
"doesn't return ``None`` or a string object."
msgstr ""
":attr:`.tzinfo`\\가 ``None``\\이면, ``None``\\을 반환하고, 그렇지 않으면 "
"``self.tzinfo.tzname(None)``\\를 반환하고, 후자가 ``None``\\이나 문자열 객체를 반환하지 않으면 "
"예외를 발생시킵니다."

#: ../Doc/library/datetime.rst:1647
msgid "Example:"
msgstr "예제:"

#: ../Doc/library/datetime.rst:1678
msgid ":class:`tzinfo` Objects"
msgstr ":class:`tzinfo` 객체"

#: ../Doc/library/datetime.rst:1682
msgid ""
"This is an abstract base class, meaning that this class should not be "
"instantiated directly.  You need to derive a concrete subclass, and (at "
"least) supply implementations of the standard :class:`tzinfo` methods "
"needed by the :class:`.datetime` methods you use.  The :mod:`datetime` "
"module supplies a simple concrete subclass of :class:`tzinfo`, "
":class:`timezone`, which can represent timezones with fixed offset from "
"UTC such as UTC itself or North American EST and EDT."
msgstr ""
"이것은 추상 베이스 클래스입니다. 즉, 이 클래스를 직접 인스턴스로 만들면 안 됩니다. 여러분은 구상(concrete) 서브 "
"클래스를 파생시킬 필요가 있고, (적어도) 여러분이 사용하는 :class:`.datetime` 메서드에 필요한 표준 "
":class:`tzinfo` 메서드의 구현을 제공해야 합니다. :mod:`datetime` 모듈은 간단한 "
":class:`tzinfo`\\의 구상 서브 클래스 :class:`timezone`\\를 제공하는데, UTC 자체나 북미 EST, "
"EDT와 같은 UTC로부터의 고정 오프셋을 갖는 시간대를 나타낼 수 있습니다."

#: ../Doc/library/datetime.rst:1690
msgid ""
"An instance of (a concrete subclass of) :class:`tzinfo` can be passed to "
"the constructors for :class:`.datetime` and :class:`.time` objects. The "
"latter objects view their attributes as being in local time, and the "
":class:`tzinfo` object supports methods revealing offset of local time "
"from UTC, the name of the time zone, and DST offset, all relative to a "
"date or time object passed to them."
msgstr ""
":class:`tzinfo`\\의 (구상 서브 클래스의) 인스턴스는 :class:`.datetime`\\과 "
":class:`.time` 객체의 생성자에 전달될 수 있습니다. 이 객체들은 자신의 어트리뷰트를 지역 시간으로 간주하며, "
":class:`tzinfo` 객체는 지역 시간의 UTC로부터의 오프셋, 시간대 이름 및 DST 오프셋을 모두 전달된 날짜나 시간 "
"객체에 상대적으로 얻는 메서드들을 지원합니다."

#: ../Doc/library/datetime.rst:1696
msgid ""
"Special requirement for pickling:  A :class:`tzinfo` subclass must have "
"an :meth:`__init__` method that can be called with no arguments, else it "
"can be pickled but possibly not unpickled again.  This is a technical "
"requirement that may be relaxed in the future."
msgstr ""
"피클링을 위한 특별한 요구 사항: :class:`tzinfo` 서브 클래스는 인자 없이 호출할 수 있는 "
":meth:`__init__` 메서드를 가져야 합니다. 그렇지 않으면 피클 될 수는 있지만, 다시 역 피클 될 수는 없습니다. "
"이것은 기술적 요구사항으로, 미래에 완화될 수 있습니다."

#: ../Doc/library/datetime.rst:1701
msgid ""
"A concrete subclass of :class:`tzinfo` may need to implement the "
"following methods.  Exactly which methods are needed depends on the uses "
"made of aware :mod:`datetime` objects.  If in doubt, simply implement all"
" of them."
msgstr ""
":class:`tzinfo`\\의 구상 서브 클래스는 다음 메서드를 구현해야 할 수도 있습니다. 정확히 어떤 메서드가 필요한지는 "
"어웨어 :mod:`datetime` 객체를 사용하는 방법에 따라 다릅니다. 확실하지 않으면, 그냥 모두 구현하십시오."

#: ../Doc/library/datetime.rst:1708
msgid ""
"Return offset of local time from UTC, as a :class:`timedelta` object that"
" is positive east of UTC.  If local time is west of UTC, this should be "
"negative.  Note that this is intended to be the total offset from UTC; "
"for example, if a :class:`tzinfo` object represents both time zone and "
"DST adjustments, :meth:`utcoffset` should return their sum.  If the UTC "
"offset isn't known, return ``None``.  Else the value returned must be a "
":class:`timedelta` object strictly between ``-timedelta(hours=24)`` and "
"``timedelta(hours=24)`` (the magnitude of the offset must be less than "
"one day).  Most implementations of :meth:`utcoffset` will probably look "
"like one of these two::"
msgstr ""
"지역 시간의 UTC로부터의 오프셋을 UTC의 동쪽에 있을 때 양의 값을 갖는 :class:`timedelta` 객체로 반환합니다. "
"지역 시간이 UTC의 서쪽이면 이 값은 음수여야 합니다. 이 값은 UTC로부터의 총 오프셋입니다: 예를 들어, "
":class:`tzinfo` 객체가 시간대와 DST 조정을 모두 나타내면, :meth:`utcoffset`\\은 그들의 합계를 "
"반환해야 합니다. UTC 오프셋을 알 수 없으면, ``None``\\을 반환합니다. 그렇지 않으면 반환되는 값은 반드시 "
"``-timedelta(hours=24)``\\와 ``timedelta(hours=24)`` 사이의 "
":class:`timedelta` 객체여야 합니다 (오프셋의 크기는 하루 미만이어야 합니다). :meth:`utcoffset`\\의"
" 대부분 구현은 아마도 이 두 가지 중 하나일 것입니다::"

#: ../Doc/library/datetime.rst:1722
msgid ""
"If :meth:`utcoffset` does not return ``None``, :meth:`dst` should not "
"return ``None`` either."
msgstr ""
":meth:`utcoffset`\\이 ``None``\\을 반환하지 않으면, :meth:`dst`\\도 ``None``\\을 "
"반환하지 않아야 합니다."

#: ../Doc/library/datetime.rst:1725
msgid ""
"The default implementation of :meth:`utcoffset` raises "
":exc:`NotImplementedError`."
msgstr ":meth:`utcoffset`\\의 기본 구현은 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/datetime.rst:1734
msgid ""
"Return the daylight saving time (DST) adjustment, as a :class:`timedelta`"
" object or ``None`` if DST information isn't known.  Return "
"``timedelta(0)`` if DST is not in effect. If DST is in effect, return the"
" offset as a :class:`timedelta` object (see :meth:`utcoffset` for "
"details). Note that DST offset, if applicable, has already been added to "
"the UTC offset returned by :meth:`utcoffset`, so there's no need to "
"consult :meth:`dst` unless you're interested in obtaining DST info "
"separately.  For example, :meth:`datetime.timetuple` calls its "
":attr:`~.datetime.tzinfo` attribute's :meth:`dst` method to determine how"
" the :attr:`tm_isdst` flag should be set, and :meth:`tzinfo.fromutc` "
"calls :meth:`dst` to account for DST changes when crossing time zones."
msgstr ""
"일광 절약 시간 (DST) 조정을 :class:`timedelta` 객체로, 또는 DST 정보를 모르면 ``None``\\을 "
"반환합니다. DST가 적용되고 있지 않으면, ``timedelta(0)``\\를 반환합니다. DST가 적용 중이면, 오프셋을 "
":class:`timedelta` 객체로 반환합니다 (자세한 내용은 :meth:`utcoffset`\\을 참조하십시오). 해당하면,"
" DST 오프셋이 :meth:`utcoffset`\\에서 반환된 UTC 오프셋에 이미 추가되어 있으므로, 따로 DST 정보를 얻는 "
"데 관심이 없다면 :meth:`dst`\\를 확인할 필요가 없습니다. 예를 들어, "
":meth:`datetime.timetuple`\\은 :attr:`~.datetime.tzinfo` 어트리뷰트의 "
":meth:`dst` 메서드를 호출하여 :attr:`tm_isdst` 플래그를 어떻게 설정할지를 결정하고, "
":meth:`tzinfo.fromutc`\\는 시간대를 가로지를 때 DST 변경을 고려하기 위해 :meth:`dst`\\를 "
"호출합니다."

#: ../Doc/library/datetime.rst:1746
msgid ""
"An instance *tz* of a :class:`tzinfo` subclass that models both standard "
"and daylight times must be consistent in this sense:"
msgstr ""
"표준과 일광 절약 시간을 모두 모형화하는 :class:`tzinfo` 서브 클래스의 인스턴스 *tz*\\는 다음과 같은 의미에서 "
"일관되어야 합니다:"

#: ../Doc/library/datetime.rst:1749
msgid "``tz.utcoffset(dt) - tz.dst(dt)``"
msgstr "``tz.utcoffset(dt) - tz.dst(dt)``"

#: ../Doc/library/datetime.rst:1751
msgid ""
"must return the same result for every :class:`.datetime` *dt* with "
"``dt.tzinfo == tz``  For sane :class:`tzinfo` subclasses, this expression"
" yields the time zone's \"standard offset\", which should not depend on "
"the date or the time, but only on geographic location.  The "
"implementation of :meth:`datetime.astimezone` relies on this, but cannot "
"detect violations; it's the programmer's responsibility to ensure it.  If"
" a :class:`tzinfo` subclass cannot guarantee this, it may be able to "
"override the default implementation of :meth:`tzinfo.fromutc` to work "
"correctly with :meth:`astimezone` regardless."
msgstr ""
"는 ``dt.tzinfo == tz``\\인 모든 :class:`.datetime` *dt*\\에 대해 같은 결과를 반환해야 "
"합니다. 정상적인 :class:`tzinfo` 서브 클래스에서, 이 표현식은 시간대의 \"표준 오프셋\"을 산출하는데, 이것은 "
"날짜나 시간에 의존하지 않고, 지리적 위치에만 의존해야 합니다. :meth:`datetime.astimezone` 구현은 이 "
"일관성에 의존하지만, 위반을 감지할 수는 없습니다; 이를 보장하는 것은 프로그래머의 책임입니다. :class:`tzinfo` 서브 "
"클래스가 이를 보장 할 수 없으면, :meth:`astimezone`\\와 상관없이 올바르게 작동하도록 "
":meth:`tzinfo.fromutc`\\의 기본 구현을 재정의할 수 있습니다."

#: ../Doc/library/datetime.rst:1760
msgid ""
"Most implementations of :meth:`dst` will probably look like one of these "
"two::"
msgstr ":meth:`dst`\\의 대부분 구현은 아마도 이 두 가지 중 하나일 것입니다::"

#: ../Doc/library/datetime.rst:1766
msgid "or ::"
msgstr "또는 ::"

#: ../Doc/library/datetime.rst:1778
msgid ""
"The default implementation of :meth:`dst` raises "
":exc:`NotImplementedError`."
msgstr ":meth:`dst`\\의 기본 구현은 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/datetime.rst:1786
msgid ""
"Return the time zone name corresponding to the :class:`.datetime` object "
"*dt*, as a string. Nothing about string names is defined by the "
":mod:`datetime` module, and there's no requirement that it mean anything "
"in particular.  For example, \"GMT\", \"UTC\", \"-500\", \"-5:00\", "
"\"EDT\", \"US/Eastern\", \"America/New York\" are all valid replies.  "
"Return ``None`` if a string name isn't known.  Note that this is a method"
" rather than a fixed string primarily because some :class:`tzinfo` "
"subclasses will wish to return different names depending on the specific "
"value of *dt* passed, especially if the :class:`tzinfo` class is "
"accounting for daylight time."
msgstr ""
":class:`.datetime` 객체 *dt*\\에 해당하는 시간대 이름을 문자열로 반환합니다. 문자열 이름에 관한 어떤 것도 "
":mod:`datetime` 모듈에 의해 정의되지 않으며, 특별히 어떤 것을 의미해야 한다는 요구 사항이 없습니다. 예를 들어, "
"\"GMT\", \"UTC\", \"-500\", \"-5:00\", \"EDT\", \"US/Eastern\", "
"\"America/New York\"은 모두 유효한 응답입니다. 문자열 이름을 모르면 ``None``\\을 반환합니다. 이것은 "
"고정된 문자열이기보다 메서드인데, 주로 어떤 :class:`tzinfo` 서브 클래스가 전달된 *dt*\\의 특정 값에 따라 다른 "
"이름을 반환하기를 원하기 때문입니다. 특히 :class:`tzinfo` 클래스가 일광 절약 시간을 고려할 때 그렇습니다."

#: ../Doc/library/datetime.rst:1796
msgid ""
"The default implementation of :meth:`tzname` raises "
":exc:`NotImplementedError`."
msgstr ":meth:`tzname`\\의 기본 구현은 :exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/datetime.rst:1799
msgid ""
"These methods are called by a :class:`.datetime` or :class:`.time` "
"object, in response to their methods of the same names.  A "
":class:`.datetime` object passes itself as the argument, and a "
":class:`.time` object passes ``None`` as the argument.  A :class:`tzinfo`"
" subclass's methods should therefore be prepared to accept a *dt* "
"argument of ``None``, or of class :class:`.datetime`."
msgstr ""
"이 메서드들은 :class:`.datetime`\\나 :class:`.time` 객체에서 같은 이름의 메서드에 대한 응답으로 "
"호출됩니다. :class:`.datetime` 객체는 자신을 인자로 전달하고, :class:`.time` 객체는 인자로 "
"``None``\\을 전달합니다. 따라서 :class:`tzinfo` 서브 클래스의 메서드는 ``None``\\이나 "
":class:`.datetime` 클래스의 *dt* 인자를 받아들일 준비가 되어 있어야 합니다."

#: ../Doc/library/datetime.rst:1805
msgid ""
"When ``None`` is passed, it's up to the class designer to decide the best"
" response.  For example, returning ``None`` is appropriate if the class "
"wishes to say that time objects don't participate in the :class:`tzinfo` "
"protocols.  It may be more useful for ``utcoffset(None)`` to return the "
"standard UTC offset, as there is no other convention for discovering the "
"standard offset."
msgstr ""
"``None``\\이 전달되면, 최선의 응답을 결정하는 것은 클래스 설계자에게 달려있습니다. 예를 들어, 클래스가 "
":class:`tzinfo` 프로토콜에 time 객체가 참여하지 않는다고 말하고 싶다면 ``None``\\을 반환하는 것이 "
"적절합니다. 표준 오프셋을 발견하는 다른 규칙이 없으므로, ``utcoffset(None)``\\이 표준 UTC 오프셋을 반환하는 "
"것이 더 유용할 수 있습니다."

#: ../Doc/library/datetime.rst:1811
msgid ""
"When a :class:`.datetime` object is passed in response to a "
":class:`.datetime` method, ``dt.tzinfo`` is the same object as *self*.  "
":class:`tzinfo` methods can rely on this, unless user code calls "
":class:`tzinfo` methods directly.  The intent is that the :class:`tzinfo`"
" methods interpret *dt* as being in local time, and not need worry about "
"objects in other timezones."
msgstr ""
":class:`.datetime` 메서드에 대한 응답으로 :class:`.datetime` 객체가 전달되면, "
"``dt.tzinfo``\\는 *self*\\와 같은 객체입니다. 사용자 코드가 :class:`tzinfo` 메서드를 직접 호출하지"
" 않는 한, :class:`tzinfo` 메서드는 이것에 의존할 수 있습니다. :class:`tzinfo` 메서드가 *dt*\\를 "
"지역 시간으로 해석하고, 다른 시간대의 객체를 걱정할 필요가 없도록 하려는 의도입니다."

#: ../Doc/library/datetime.rst:1817
msgid ""
"There is one more :class:`tzinfo` method that a subclass may wish to "
"override:"
msgstr "서브 클래스가 재정의할 수 있는 :class:`tzinfo` 메서드가 하나 더 있습니다:"

#: ../Doc/library/datetime.rst:1822
msgid ""
"This is called from the default :class:`datetime.astimezone()` "
"implementation.  When called from that, ``dt.tzinfo`` is *self*, and "
"*dt*'s date and time data are to be viewed as expressing a UTC time.  The"
" purpose of :meth:`fromutc` is to adjust the date and time data, "
"returning an equivalent datetime in *self*'s local time."
msgstr ""
"이것은 기본 :class:`datetime.astimezone()` 구현에서 호출됩니다. 거기에서 호출되면, "
"``dt.tzinfo``\\는 *self*\\이고, *dt*\\의 날짜와 시간 데이터는 UTC 시간으로 표시된 것으로 봅니다. "
":meth:`fromutc`\\의 목적은 날짜와 시간 데이터를 조정하여, *self*\\의 지역 시간으로 동등한 datetime을 "
"반환하는 것입니다."

#: ../Doc/library/datetime.rst:1828
msgid ""
"Most :class:`tzinfo` subclasses should be able to inherit the default "
":meth:`fromutc` implementation without problems.  It's strong enough to "
"handle fixed-offset time zones, and time zones accounting for both "
"standard and daylight time, and the latter even if the DST transition "
"times differ in different years.  An example of a time zone the default "
":meth:`fromutc` implementation may not handle correctly in all cases is "
"one where the standard offset (from UTC) depends on the specific date and"
" time passed, which can happen for political reasons. The default "
"implementations of :meth:`astimezone` and :meth:`fromutc` may not produce"
" the result you want if the result is one of the hours straddling the "
"moment the standard offset changes."
msgstr ""
"대부분 :class:`tzinfo` 서브 클래스는 문제없이 기본 :meth:`fromutc` 구현을 상속할 수 있어야 합니다. 고정"
" 오프셋 시간대와 표준과 일광 절약 시간을 모두 고려하는 시간대를, 해마다 DST 전환 시간이 다를 때도 일광 절약 시간을 처리할 "
"수 있을 만큼 강력합니다. 기본 :meth:`fromutc` 구현이 모든 경우에 올바르게 처리하지 못할 수 있는 시간대의 예는 "
"(정치적 이유로 인해 발생할 수 있는) 특정 날짜와 시간에 따라 (UTC로부터의) 표준 오프셋이 달라지는 것입니다. 결과가 표준 "
"오프셋이 변경되는 순간에 걸치는 시간 중 하나일 때, :meth:`astimezone`\\과 :meth:`fromutc`\\의 기본"
" 구현은 여러분이 원하는 결과를 생성하지 못할 수 있습니다."

#: ../Doc/library/datetime.rst:1839
msgid ""
"Skipping code for error cases, the default :meth:`fromutc` implementation"
" acts like::"
msgstr "에러가 발생하는 경우를 위한 코드를 생략하면, 기본 :meth:`fromutc` 구현은 다음과 같이 동작합니다::"

#: ../Doc/library/datetime.rst:1857
msgid ""
"In the following :download:`tzinfo_examples.py "
"<../includes/tzinfo_examples.py>` file there are some examples of "
":class:`tzinfo` classes:"
msgstr ""
"다음 :download:`tzinfo_examples.py <../includes/tzinfo_examples.py>` 파일에는 "
":class:`tzinfo` 클래스의 몇 가지 예가 나와 있습니다:"

#: ../Doc/library/datetime.rst:1863
msgid ""
"Note that there are unavoidable subtleties twice per year in a "
":class:`tzinfo` subclass accounting for both standard and daylight time, "
"at the DST transition points.  For concreteness, consider US Eastern (UTC"
" -0500), where EDT begins the minute after 1:59 (EST) on the second "
"Sunday in March, and ends the minute after 1:59 (EDT) on the first Sunday"
" in November::"
msgstr ""
"DST 전환점에서 표준 시간과 일광 절약 시간을 모두 고려하는 :class:`tzinfo` 서브 클래스에는 일 년에 두 번 불가피한"
" 미묘함이 있음에 유의하십시오. 구체적으로, 3월 두 번째 일요일의 1:59 (EST) 다음 분에 시작하고, 11월 첫 번째 일요일"
" 1:59 (EDT) 다음 분에 끝나는 미국 Eastern(UTC -0500)을 고려하십시오::"

#: ../Doc/library/datetime.rst:1877
msgid ""
"When DST starts (the \"start\" line), the local wall clock leaps from "
"1:59 to 3:00.  A wall time of the form 2:MM doesn't really make sense on "
"that day, so ``astimezone(Eastern)`` won't deliver a result with ``hour "
"== 2`` on the day DST begins.  For example, at the Spring forward "
"transition of 2016, we get"
msgstr ""
"DST가 시작할 때 (\"start\" 줄), 지역 벽시계는 1:59에서 3:00로 도약합니다. 그날에는 2:MM 형식의 벽 시간은"
" 실질적인 의미가 없으므로, ``astimezone(Eastern)``\\은 DST가 시작하는 날에 ``hour == 2``\\인 "
"결과를 전달하지 않습니다. 예를 들어, 2016년 봄의 전진 전환(forward transition)에서, 다음과 같은 결과를 "
"얻습니다"

#: ../Doc/library/datetime.rst:1896
msgid ""
"When DST ends (the \"end\" line), there's a potentially worse problem: "
"there's an hour that can't be spelled unambiguously in local wall time: "
"the last hour of daylight time.  In Eastern, that's times of the form "
"5:MM UTC on the day daylight time ends.  The local wall clock leaps from "
"1:59 (daylight time) back to 1:00 (standard time) again. Local times of "
"the form 1:MM are ambiguous. :meth:`astimezone` mimics the local clock's "
"behavior by mapping two adjacent UTC hours into the same local hour then."
"  In the Eastern example, UTC times of the form 5:MM and 6:MM both map to"
" 1:MM when converted to Eastern, but earlier times have the "
":attr:`~datetime.fold` attribute set to 0 and the later times have it set"
" to 1. For example, at the Fall back transition of 2016, we get"
msgstr ""
"DST가 끝날 때 (\"end\" 줄), 잠재적으로 더 나쁜 문제가 있습니다: 지역 시간으로 명확하게 말할 수 없는 시(hour)가"
" 있습니다: 일광 절약 시간의 마지막 한 시간. Eastern에서, 이것은 일광 절약 시간제가 끝나는 날의 5:MM UTC 형식의 "
"시간입니다. 지역 벽시계는 1:59(일광 절약 시간)에서 다시 1:00(표준 시간)으로 도약합니다. 1:MM 형식의 지역 시간은 "
"모호합니다. :meth:`astimezone`\\은 두 개의 인접한 UTC 시(hour)를 같은 지역 시(hour)로 매핑하여 지역"
" 시계 동작을 모방합니다. Eastern 예제에서, 5:MM과 6:MM 형식의 UTC 시간은 모두 Eastern으로 변환될 때 "
"1:MM으로 매핑되지만, 이전 시간은 :attr:`~datetime.fold` 어트리뷰트가 0으로 설정되고 이후 시간은 1로 "
"설정됩니다. 예를 들어, 2016년 가을의 역 전환( back transition)에서, 다음과 같은 결과를 얻습니다"

#: ../Doc/library/datetime.rst:1918
msgid ""
"Note that the :class:`datetime` instances that differ only by the value "
"of the :attr:`~datetime.fold` attribute are considered equal in "
"comparisons."
msgstr ""
":attr:`~datetime.fold` 어트리뷰트의 값만 다른 :class:`datetime` 인스턴스는 비교에서 같다고 간주하는"
" 것에 유의하십시오."

#: ../Doc/library/datetime.rst:1921
msgid ""
"Applications that can't bear wall-time ambiguities should explicitly "
"check the value of the :attr:`~datetime.fold` attribute or avoid using "
"hybrid :class:`tzinfo` subclasses; there are no ambiguities when using "
":class:`timezone`, or any other fixed-offset :class:`tzinfo` subclass "
"(such as a class representing only EST (fixed offset -5 hours), or only "
"EDT (fixed offset -4 hours))."
msgstr ""
"벽 시간 모호성을 견딜 수 없는 응용 프로그램은 명시적으로 :attr:`~datetime.fold` 어트리뷰트 값을 확인하거나 "
"하이브리드 :class:`tzinfo` 서브 클래스를 사용하지 않아야 합니다; :class:`timezone`\\이나 기타 고정 "
"오프셋 :class:`tzinfo` 서브 클래스(가령 오직 EST(고정 오프셋 -5시간)와  EDT(고정 오프셋 -4시간) 중 어느"
" 한 가지만 나타내는 클래스)를 사용할 때는 모호함이 없습니다."

#: ../Doc/library/datetime.rst:1934
msgid "`dateutil.tz <https://dateutil.readthedocs.io/en/stable/tz.html>`_"
msgstr "`dateutil.tz <https://dateutil.readthedocs.io/en/stable/tz.html>`_"

#: ../Doc/library/datetime.rst:1930
msgid ""
"The standard library has :class:`timezone` class for handling arbitrary "
"fixed offsets from UTC and :attr:`timezone.utc` as UTC timezone instance."
msgstr ""
"표준 라이브러리에는 UTC로부터의 임의의 고정 오프셋을 처리하기 위한 :class:`timezone` 클래스와 UTC "
"timezone 인스턴스로 :attr:`timezone.utc`\\가 있습니다."

#: ../Doc/library/datetime.rst:1933
msgid ""
"*dateutil.tz* library brings the *IANA timezone database* (also known as "
"the Olson database) to Python and its usage is recommended."
msgstr ""
"*dateutil.tz* 라이브러리는 *IANA 시간대 데이터베이스* (Olson 데이터베이스라고도 합니다)를 파이썬으로 "
"가져옵니다. 사용을 권장합니다."

#: ../Doc/library/datetime.rst:1940
msgid "`IANA timezone database <https://www.iana.org/time-zones>`_"
msgstr "`IANA timezone database <https://www.iana.org/time-zones>`_"

#: ../Doc/library/datetime.rst:1937
msgid ""
"The Time Zone Database (often called tz, tzdata or zoneinfo) contains "
"code and data that represent the history of local time for many "
"representative locations around the globe. It is updated periodically to "
"reflect changes made by political bodies to time zone boundaries, UTC "
"offsets, and daylight-saving rules."
msgstr ""
"시간대 데이터베이스 (종종 tz, tzdata 또는 zoneinfo라고 합니다)에는 전 세계 여러 지역에서 지역 시간의 히스토리를 "
"표현하는 코드와 데이터가 포함되어 있습니다. 정치 단체가 변경 한 시간대 경계, UTC 오프셋 및 일광 절약 시간 규칙을 반영하기 "
"위해 주기적으로 갱신됩니다."

#: ../Doc/library/datetime.rst:1947
msgid ":class:`timezone` Objects"
msgstr ":class:`timezone` 객체"

#: ../Doc/library/datetime.rst:1949
msgid ""
"The :class:`timezone` class is a subclass of :class:`tzinfo`, each "
"instance of which represents a timezone defined by a fixed offset from "
"UTC.  Note that objects of this class cannot be used to represent "
"timezone information in the locations where different offsets are used in"
" different days of the year or where historical changes have been made to"
" civil time."
msgstr ""
":class:`timezone` 클래스는 :class:`tzinfo`\\의 서브 클래스이며, 각 인스턴스는 UTC로부터의 고정 "
"오프셋으로 정의된 시간대를 나타냅니다. 이 클래스의 객체는 일 년 중 어떤 날에는 다른 오프셋이 사용되거나 민간 시간이 역사적으로 "
"변해온 지역의 시간대 정보를 나타내는데 사용할 수 없음에 유의하십시오."

#: ../Doc/library/datetime.rst:1959
msgid ""
"The *offset* argument must be specified as a :class:`timedelta` object "
"representing the difference between the local time and UTC.  It must be "
"strictly between ``-timedelta(hours=24)`` and ``timedelta(hours=24)``, "
"otherwise :exc:`ValueError` is raised."
msgstr ""
"*offset* 인자는 지역 시간과 UTC 간의 차이를 나타내는 :class:`timedelta` 객체로 지정해야 합니다. "
"엄격히(경계를 포함하지 않는) ``-timedelta(hours=24)``\\와 ``timedelta(hours=24)`` 사이여야"
" 합니다. 그렇지 않으면 :exc:`ValueError`\\가 발생합니다."

#: ../Doc/library/datetime.rst:1964
msgid ""
"The *name* argument is optional.  If specified it must be a string that "
"will be used as the value returned by the :meth:`datetime.tzname` method."
msgstr ""
"*name* 인자는 선택적입니다. 지정되면 :meth:`datetime.tzname` 메서드가 반환하는 값으로 사용될 문자열이어야 "
"합니다."

#: ../Doc/library/datetime.rst:1975
msgid ""
"Return the fixed value specified when the :class:`timezone` instance is "
"constructed.  The *dt* argument is ignored.  The return value is a "
":class:`timedelta` instance equal to the difference between the local "
"time and UTC."
msgstr ""
":class:`timezone` 인스턴스가 구축될 때 지정된 고정값을 반환합니다. *dt* 인자는 무시됩니다. 반환 값은 지역 "
"시간과 UTC 간의 차이와 같은 :class:`timedelta` 인스턴스입니다."

#: ../Doc/library/datetime.rst:1985
msgid ""
"Return the fixed value specified when the :class:`timezone` instance is "
"constructed.  If *name* is not provided in the constructor, the name "
"returned by ``tzname(dt)`` is generated from the value of the ``offset`` "
"as follows.  If *offset* is ``timedelta(0)``, the name is \"UTC\", "
"otherwise it is a string 'UTC±HH:MM', where ± is the sign of ``offset``, "
"HH and MM are two digits of ``offset.hours`` and ``offset.minutes`` "
"respectively."
msgstr ""
":class:`timezone` 인스턴스가 구축될 때 지정된 고정값을 반환합니다. *name*\\을 생성자에 제공하지 않았으면, "
"``tzname(dt)``\\에 의해 반환되는 이름은 다음과 같이 ``offset`` 값으로부터 생성됩니다. *offset*\\이 "
"``timedelta(0)``\\이면, 이름은 \"UTC\"이고, 그렇지 않으면 문자열 'UTC±HH:MM'입니다. 여기서 ±는 "
"``offset``\\의 부호이고, HH와 MM은 각각 ``offset.hours``\\와 ``offset.minutes``\\의 "
"두 자리 숫자입니다."

#: ../Doc/library/datetime.rst:1993
msgid ""
"Name generated from ``offset=timedelta(0)`` is now plain 'UTC', not "
"'UTC+00:00'."
msgstr "``offset=timedelta(0)``\\에서 생성된 이름은 이제 'UTC+00:00'이 아니라 단순한 'UTC'입니다."

#: ../Doc/library/datetime.rst:2000
msgid "Always returns ``None``."
msgstr "항상 ``None``\\을 반환합니다."

#: ../Doc/library/datetime.rst:2004
msgid ""
"Return ``dt + offset``.  The *dt* argument must be an aware "
":class:`.datetime` instance, with ``tzinfo`` set to ``self``."
msgstr ""
"``dt + offset``\\을 반환합니다. *dt* 인자는 ``tzinfo``\\가 ``self``\\로 설정된 어웨어 "
":class:`.datetime` 인스턴스여야 합니다."

#: ../Doc/library/datetime.rst:2011
msgid "The UTC timezone, ``timezone(timedelta(0))``."
msgstr "UTC 시간대, ``timezone(timedelta(0))``."

#: ../Doc/library/datetime.rst:2020
msgid ":meth:`strftime` and :meth:`strptime` Behavior"
msgstr ":meth:`strftime`\\와 :meth:`strptime` 동작"

#: ../Doc/library/datetime.rst:2022
msgid ""
":class:`date`, :class:`.datetime`, and :class:`.time` objects all support"
" a ``strftime(format)`` method, to create a string representing the time "
"under the control of an explicit format string.  Broadly speaking, "
"``d.strftime(fmt)`` acts like the :mod:`time` module's "
"``time.strftime(fmt, d.timetuple())`` although not all objects support a "
":meth:`timetuple` method."
msgstr ""
":class:`date`, :class:`.datetime` 및 :class:`.time` 객체는 모두 "
"``strftime(format)`` 메서드를 지원하여, 명시적 포맷 문자열로 제어된 시간을 나타내는 문자열을 만듭니다. 대체로 "
"말하자면, 모든 객체가 :meth:`timetuple` 메서드를 지원하는 것은 아니지만, ``d.strftime(fmt)``\\는 "
":mod:`time` 모듈의 ``time.strftime(fmt, d.timetuple())``\\처럼 작동합니다."

#: ../Doc/library/datetime.rst:2028
msgid ""
"Conversely, the :meth:`datetime.strptime` class method creates a "
":class:`.datetime` object from a string representing a date and time and "
"a corresponding format string. ``datetime.strptime(date_string, format)``"
" is equivalent to ``datetime(*(time.strptime(date_string, "
"format)[0:6]))``, except when the format includes sub-second components "
"or timezone offset information, which are supported in "
"``datetime.strptime`` but are discarded by ``time.strptime``."
msgstr ""
"반대로, :meth:`datetime.strptime` 클래스 메서드는 날짜와 시간을 나타내는 문자열과 해당 포맷 문자열로 "
":class:`.datetime` 객체를 만듭니다. ``datetime.strptime(date_string, "
"format)``\\은 format에 초 미만의 성분이나 시간대 오프셋 정보가 포함된 경우를 제외하고는 "
"``datetime(*(time.strptime(date_string, format)[0:6]))``\\과 동등합니다. 이것들은 "
"``datetime.strptime``\\에서는 지원되지만 ``time.strptime``\\에서는 버려집니다."

#: ../Doc/library/datetime.rst:2035
msgid ""
"For :class:`.time` objects, the format codes for year, month, and day "
"should not be used, as time objects have no such values.  If they're used"
" anyway, ``1900`` is substituted for the year, and ``1`` for the month "
"and day."
msgstr ""
":class:`.time` 객체의 경우, time 객체에 해당 값이 없으므로, 연(year), 월(month) 및 일(day)의 "
"포맷 코드는 사용하지 않아야 합니다. 어쨌든 사용되면, ``1900``\\이 해당 연도로, ``1``\\이 해당 월과 일로 "
"대체됩니다."

#: ../Doc/library/datetime.rst:2039
msgid ""
"For :class:`date` objects, the format codes for hours, minutes, seconds, "
"and microseconds should not be used, as :class:`date` objects have no "
"such values.  If they're used anyway, ``0`` is substituted for them."
msgstr ""
":class:`date` 객체의 경우, :class:`date` 객체에 해당 값이 없으므로, 시(hour), 분(minute), "
"초(second) 및 마이크로초(microsecond)의 포맷 코드는 사용하지 않아야 합니다. 어쨌든 사용되면, ``0``\\으로 "
"대체됩니다."

#: ../Doc/library/datetime.rst:2043
msgid ""
"For the :meth:`datetime.strptime` class method, the default value is "
"``1900-01-01T00:00:00.000``: any components not specified in the format "
"string will be pulled from the default value. [#]_"
msgstr ""

#: ../Doc/library/datetime.rst:2046
msgid ""
"The full set of format codes supported varies across platforms, because "
"Python calls the platform C library's :func:`strftime` function, and "
"platform variations are common.  To see the full set of format codes "
"supported on your platform, consult the :manpage:`strftime(3)` "
"documentation."
msgstr ""
"파이썬이 플랫폼 C 라이브러리의 :func:`strftime` 함수를 호출하고, 플랫폼 변형이 일반적이기 때문에, 지원되는 전체 "
"포맷 코드 집합은 플랫폼에 따라 다릅니다. 여러분의 플랫폼에서 지원되는 모든 포맷 코드를 보려면, "
":manpage:`strftime(3)` 설명서를 참조하십시오."

#: ../Doc/library/datetime.rst:2051
msgid ""
"For the same reason, handling of format strings containing Unicode code "
"points that can't be represented in the charset of the current locale is "
"also platform-dependent. On some platforms such code points are preserved"
" intact in the output, while on others ``strftime`` may raise "
":exc:`UnicodeError` or return an empty string instead."
msgstr ""
"같은 이유로, 현재 로케일의 문자 집합으로는 표현할 수 없는 유니코드 코드 포인트를 포함하는 포맷 문자열의 처리도 플랫폼에 따라 "
"다릅니다. 일부 플랫폼에서는 이러한 코드 포인트가 그대로 출력에 보존되지만, 다른 곳에서는 ``strftime``\\이 "
":exc:`UnicodeError`\\를 발생시키거나 대신 빈 문자열을 반환할 수 있습니다."

#: ../Doc/library/datetime.rst:2057
msgid ""
"The following is a list of all the format codes that the C standard (1989"
" version) requires, and these work on all platforms with a standard C "
"implementation.  Note that the 1999 version of the C standard added "
"additional format codes."
msgstr ""
"다음은 C 표준(1989 버전)이 요구하는 모든 포맷 코드 목록이며, 표준 C 구현이 있는 모든 플랫폼에서 작동합니다. C 표준의 "
"1999 버전에는 추가 형식 코드가 추가되었음에 유의하십시오."

#: ../Doc/library/datetime.rst:2063 ../Doc/library/datetime.rst:2170
msgid "Directive"
msgstr "지시자"

#: ../Doc/library/datetime.rst:2063 ../Doc/library/datetime.rst:2170
msgid "Meaning"
msgstr "의미"

#: ../Doc/library/datetime.rst:2063 ../Doc/library/datetime.rst:2170
msgid "Example"
msgstr "예"

#: ../Doc/library/datetime.rst:2063 ../Doc/library/datetime.rst:2170
msgid "Notes"
msgstr "노트"

#: ../Doc/library/datetime.rst:2065
msgid "``%a``"
msgstr "``%a``"

#: ../Doc/library/datetime.rst:2065
msgid "Weekday as locale's abbreviated name."
msgstr "요일을 로케일의 축약된 이름으로."

#: ../Doc/library/datetime.rst
msgid "Sun, Mon, ..., Sat (en_US);"
msgstr "Sun, Mon, ..., Sat (en_US);"

#: ../Doc/library/datetime.rst
msgid "So, Mo, ..., Sa (de_DE)"
msgstr "So, Mo, ..., Sa (de_DE)"

#: ../Doc/library/datetime.rst:2070
msgid "``%A``"
msgstr "``%A``"

#: ../Doc/library/datetime.rst:2070
msgid "Weekday as locale's full name."
msgstr "요일을 로케일의 전체 이름으로."

#: ../Doc/library/datetime.rst
msgid "Sunday, Monday, ..., Saturday (en_US);"
msgstr "Sunday, Monday, ..., Saturday (en_US);"

#: ../Doc/library/datetime.rst
msgid "Sonntag, Montag, ..., Samstag (de_DE)"
msgstr "Sonntag, Montag, ..., Samstag (de_DE)"

#: ../Doc/library/datetime.rst:2075
msgid "``%w``"
msgstr "``%w``"

#: ../Doc/library/datetime.rst:2075
msgid "Weekday as a decimal number, where 0 is Sunday and 6 is Saturday."
msgstr "요일을 10진수로, 0은 일요일이고 6은 토요일입니다."

#: ../Doc/library/datetime.rst:2075
msgid "0, 1, ..., 6"
msgstr "0, 1, ..., 6"

#: ../Doc/library/datetime.rst:2079
#, python-format
msgid "``%d``"
msgstr "``%d``"

#: ../Doc/library/datetime.rst:2079
msgid "Day of the month as a zero-padded decimal number."
msgstr "월중 일(day of the month)을 0으로 채워진 10진수로."

#: ../Doc/library/datetime.rst:2079
msgid "01, 02, ..., 31"
msgstr "01, 02, ..., 31"

#: ../Doc/library/datetime.rst:2079 ../Doc/library/datetime.rst:2092
#: ../Doc/library/datetime.rst:2095 ../Doc/library/datetime.rst:2101
#: ../Doc/library/datetime.rst:2104 ../Doc/library/datetime.rst:2110
#: ../Doc/library/datetime.rst:2128
#, fuzzy
msgid "\\(9)"
msgstr "\\(8)"

#: ../Doc/library/datetime.rst:2082
msgid "``%b``"
msgstr "``%b``"

#: ../Doc/library/datetime.rst:2082
msgid "Month as locale's abbreviated name."
msgstr "월을 로케일의 축약된 이름으로."

#: ../Doc/library/datetime.rst
msgid "Jan, Feb, ..., Dec (en_US);"
msgstr "Jan, Feb, ..., Dec (en_US);"

#: ../Doc/library/datetime.rst
msgid "Jan, Feb, ..., Dez (de_DE)"
msgstr "Jan, Feb, ..., Dez (de_DE)"

#: ../Doc/library/datetime.rst:2087
msgid "``%B``"
msgstr "``%B``"

#: ../Doc/library/datetime.rst:2087
msgid "Month as locale's full name."
msgstr "월을 로케일의 전체 이름으로."

#: ../Doc/library/datetime.rst
msgid "January, February, ..., December (en_US);"
msgstr "January, February, ..., December (en_US);"

#: ../Doc/library/datetime.rst
msgid "Januar, Februar, ..., Dezember (de_DE)"
msgstr "Januar, Februar, ..., Dezember (de_DE)"

#: ../Doc/library/datetime.rst:2092
msgid "``%m``"
msgstr "``%m``"

#: ../Doc/library/datetime.rst:2092
msgid "Month as a zero-padded decimal number."
msgstr "월을 0으로 채워진 10진수로."

#: ../Doc/library/datetime.rst:2092 ../Doc/library/datetime.rst:2104
msgid "01, 02, ..., 12"
msgstr "01, 02, ..., 12"

#: ../Doc/library/datetime.rst:2095
msgid "``%y``"
msgstr "``%y``"

#: ../Doc/library/datetime.rst:2095
msgid "Year without century as a zero-padded decimal number."
msgstr "세기가 없는 해(year)를 0으로 채워진 10진수로."

#: ../Doc/library/datetime.rst:2095
msgid "00, 01, ..., 99"
msgstr "00, 01, ..., 99"

#: ../Doc/library/datetime.rst:2098
msgid "``%Y``"
msgstr "``%Y``"

#: ../Doc/library/datetime.rst:2098
msgid "Year with century as a decimal number."
msgstr "세기가 있는 해(year)를 10진수로."

#: ../Doc/library/datetime.rst:2098 ../Doc/library/datetime.rst:2172
msgid "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"
msgstr "0001, 0002, ..., 2013, 2014, ..., 9998, 9999"

#: ../Doc/library/datetime.rst:2101
msgid "``%H``"
msgstr "``%H``"

#: ../Doc/library/datetime.rst:2101
msgid "Hour (24-hour clock) as a zero-padded decimal number."
msgstr "시(24시간제)를 0으로 채워진 십진수로."

#: ../Doc/library/datetime.rst:2101
msgid "00, 01, ..., 23"
msgstr "00, 01, ..., 23"

#: ../Doc/library/datetime.rst:2104
msgid "``%I``"
msgstr "``%I``"

#: ../Doc/library/datetime.rst:2104
msgid "Hour (12-hour clock) as a zero-padded decimal number."
msgstr "시(12시간제)를 0으로 채워진 십진수로."

#: ../Doc/library/datetime.rst:2107
msgid "``%p``"
msgstr "``%p``"

#: ../Doc/library/datetime.rst:2107
msgid "Locale's equivalent of either AM or PM."
msgstr "로케일의 오전이나 오후에 해당하는 것."

#: ../Doc/library/datetime.rst
msgid "AM, PM (en_US);"
msgstr "AM, PM (en_US);"

#: ../Doc/library/datetime.rst
msgid "am, pm (de_DE)"
msgstr "am, pm (de_DE)"

#: ../Doc/library/datetime.rst:2107
msgid "\\(1), \\(3)"
msgstr "\\(1), \\(3)"

#: ../Doc/library/datetime.rst:2110
msgid "``%M``"
msgstr "``%M``"

#: ../Doc/library/datetime.rst:2110
msgid "Minute as a zero-padded decimal number."
msgstr "분을 0으로 채워진 십진수로."

#: ../Doc/library/datetime.rst:2110 ../Doc/library/datetime.rst:2113
msgid "00, 01, ..., 59"
msgstr "00, 01, ..., 59"

#: ../Doc/library/datetime.rst:2113
msgid "``%S``"
msgstr "``%S``"

#: ../Doc/library/datetime.rst:2113
msgid "Second as a zero-padded decimal number."
msgstr "초를 0으로 채워진 10진수로."

#: ../Doc/library/datetime.rst:2113
#, fuzzy
msgid "\\(4), \\(9)"
msgstr "\\(1), \\(3)"

#: ../Doc/library/datetime.rst:2116
#, python-format
msgid "``%f``"
msgstr "``%f``"

#: ../Doc/library/datetime.rst:2116
msgid "Microsecond as a decimal number, zero-padded on the left."
msgstr "마이크로초를 왼쪽에 0으로 채워진 십진수로."

#: ../Doc/library/datetime.rst:2116
msgid "000000, 000001, ..., 999999"
msgstr "000000, 000001, ..., 999999"

#: ../Doc/library/datetime.rst:2116
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/library/datetime.rst:2120 ../Doc/library/datetime.rst:2244
msgid "``%z``"
msgstr "``%z``"

#: ../Doc/library/datetime.rst:2120
msgid ""
"UTC offset in the form ±HHMM[SS[.ffffff]] (empty string if the object is "
"naive)."
msgstr "±HHMM[SS[.ffffff]] 형태의 UTC 오프셋 (객체가 나이브하면 빈 문자열)."

#: ../Doc/library/datetime.rst:2120
msgid "(empty), +0000, -0400, +1030, +063415, -030712.345216"
msgstr "(비어 있음), +0000, -0400, +1030, +063415, -030712.345216"

#: ../Doc/library/datetime.rst:2120
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/library/datetime.rst:2125 ../Doc/library/datetime.rst:2259
msgid "``%Z``"
msgstr "``%Z``"

#: ../Doc/library/datetime.rst:2125
msgid "Time zone name (empty string if the object is naive)."
msgstr "시간대 이름 (객체가 나이브하면 빈 문자열)."

#: ../Doc/library/datetime.rst:2125
msgid "(empty), UTC, EST, CST"
msgstr "(비어 있음), UTC, EST, CST"

#: ../Doc/library/datetime.rst:2128
msgid "``%j``"
msgstr "``%j``"

#: ../Doc/library/datetime.rst:2128
msgid "Day of the year as a zero-padded decimal number."
msgstr "연중 일(day of the year)을 0으로 채워진 십진수로."

#: ../Doc/library/datetime.rst:2128
msgid "001, 002, ..., 366"
msgstr "001, 002, ..., 366"

#: ../Doc/library/datetime.rst:2131
msgid "``%U``"
msgstr "``%U``"

#: ../Doc/library/datetime.rst:2131
msgid ""
"Week number of the year (Sunday as the first day of the week) as a zero "
"padded decimal number. All days in a new year preceding the first Sunday "
"are considered to be in week 0."
msgstr "연중 주 번호(일요일이 주의 시작)를 0으로 채워진 10진수로. 첫 번째 일요일에 선행하는 새해의 모든 날은 주 0으로 간주합니다."

#: ../Doc/library/datetime.rst:2131 ../Doc/library/datetime.rst:2139
msgid "00, 01, ..., 53"
msgstr "00, 01, ..., 53"

#: ../Doc/library/datetime.rst:2131 ../Doc/library/datetime.rst:2139
#, fuzzy
msgid "\\(7), \\(9)"
msgstr "\\(1), \\(3)"

#: ../Doc/library/datetime.rst:2139
msgid "``%W``"
msgstr "``%W``"

#: ../Doc/library/datetime.rst:2139
msgid ""
"Week number of the year (Monday as the first day of the week) as a "
"decimal number. All days in a new year preceding the first Monday are "
"considered to be in week 0."
msgstr "연중 주 번호(월요일이 주의 시작)를 십진수로. 첫 번째 월요일에 선행하는 새해의 모든 말은 주 0으로 간주합니다."

#: ../Doc/library/datetime.rst:2147
#, python-format
msgid "``%c``"
msgstr "``%c``"

#: ../Doc/library/datetime.rst:2147
msgid "Locale's appropriate date and time representation."
msgstr "로케일의 적절한 날짜와 시간 표현."

#: ../Doc/library/datetime.rst
msgid "Tue Aug 16 21:30:00 1988 (en_US);"
msgstr "Tue Aug 16 21:30:00 1988 (en_US);"

#: ../Doc/library/datetime.rst
msgid "Di 16 Aug 21:30:00 1988 (de_DE)"
msgstr "Di 16 Aug 21:30:00 1988 (de_DE)"

#: ../Doc/library/datetime.rst:2152
#, python-format
msgid "``%x``"
msgstr "``%x``"

#: ../Doc/library/datetime.rst:2152
msgid "Locale's appropriate date representation."
msgstr "로케일의 적절한 날짜 표현."

#: ../Doc/library/datetime.rst
msgid "08/16/88 (None);"
msgstr "08/16/88 (None);"

#: ../Doc/library/datetime.rst
msgid "08/16/1988 (en_US);"
msgstr "08/16/1988 (en_US);"

#: ../Doc/library/datetime.rst
msgid "16.08.1988 (de_DE)"
msgstr "16.08.1988 (de_DE)"

#: ../Doc/library/datetime.rst:2156
#, python-format
msgid "``%X``"
msgstr "``%X``"

#: ../Doc/library/datetime.rst:2156
msgid "Locale's appropriate time representation."
msgstr "로케일의 적절한 시간 표현."

#: ../Doc/library/datetime.rst
msgid "21:30:00 (en_US);"
msgstr "21:30:00 (en_US);"

#: ../Doc/library/datetime.rst
msgid "21:30:00 (de_DE)"
msgstr "21:30:00 (de_DE)"

#: ../Doc/library/datetime.rst:2159
#, python-format
msgid "``%%``"
msgstr "``%%``"

#: ../Doc/library/datetime.rst:2159
msgid "A literal ``'%'`` character."
msgstr "리터럴 ``'%'`` 문자."

#: ../Doc/library/datetime.rst:2159
msgid "%"
msgstr "%"

#: ../Doc/library/datetime.rst:2162
msgid ""
"Several additional directives not required by the C89 standard are "
"included for convenience. These parameters all correspond to ISO 8601 "
"date values. These may not be available on all platforms when used with "
"the :meth:`strftime` method. The ISO 8601 year and ISO 8601 week "
"directives are not interchangeable with the year and week number "
"directives above. Calling :meth:`strptime` with incomplete or ambiguous "
"ISO 8601 directives will raise a :exc:`ValueError`."
msgstr ""
"C89 표준에서 요구하지 않는 몇 가지 추가 지시자가 편의상 포함되어 있습니다. 이 파라미터들은 모두 ISO 8601 날짜 값에 "
"해당합니다. :meth:`strftime` 메서드와 함께 사용될 때 모든 플랫폼에서 사용할 수 있는 것은 아닙니다. ISO 8601"
" 연도와 ISO 8601 주 지시자는 위의 연도 및 주 번호 지시자와 교환할 수 없습니다. 불완전하거나 모호한 ISO 8601 "
"지시자로 :meth:`strptime`\\을 호출하면 :exc:`ValueError`\\가 발생합니다."

#: ../Doc/library/datetime.rst:2172
#, python-format
msgid "``%G``"
msgstr "``%G``"

#: ../Doc/library/datetime.rst:2172
msgid ""
"ISO 8601 year with century representing the year that contains the "
"greater part of the ISO week (``%V``)."
msgstr "ISO 주(``%V``)의 더 큰 부분을 포함하는 연도를 나타내는 세기가 있는 ISO 8601 연도."

#: ../Doc/library/datetime.rst:2172
msgid "\\(8)"
msgstr "\\(8)"

#: ../Doc/library/datetime.rst:2177
#, python-format
msgid "``%u``"
msgstr "``%u``"

#: ../Doc/library/datetime.rst:2177
msgid "ISO 8601 weekday as a decimal number where 1 is Monday."
msgstr "ISO 8601 요일을 10진수로, 1은 월요일입니다."

#: ../Doc/library/datetime.rst:2177
msgid "1, 2, ..., 7"
msgstr "1, 2, ..., 7"

#: ../Doc/library/datetime.rst:2180
msgid "``%V``"
msgstr "``%V``"

#: ../Doc/library/datetime.rst:2180
msgid ""
"ISO 8601 week as a decimal number with Monday as the first day of the "
"week. Week 01 is the week containing Jan 4."
msgstr "ISO 8601 주를 월요일을 주의 시작으로 하는 십진수로. 주 01은 1월 4일을 포함하는 주입니다."

#: ../Doc/library/datetime.rst:2180
msgid "01, 02, ..., 53"
msgstr "01, 02, ..., 53"

#: ../Doc/library/datetime.rst:2180
#, fuzzy
msgid "\\(8), \\(9)"
msgstr "\\(1), \\(3)"

#: ../Doc/library/datetime.rst:2187
#, python-format
msgid "``%G``, ``%u`` and ``%V`` were added."
msgstr "``%G``, ``%u`` 및 ``%V``\\가 추가되었습니다."

#: ../Doc/library/datetime.rst:2193
msgid ""
"Because the format depends on the current locale, care should be taken "
"when making assumptions about the output value. Field orderings will vary"
" (for example, \"month/day/year\" versus \"day/month/year\"), and the "
"output may contain Unicode characters encoded using the locale's default "
"encoding (for example, if the current locale is ``ja_JP``, the default "
"encoding could be any one of ``eucJP``, ``SJIS``, or ``utf-8``; use "
":meth:`locale.getlocale` to determine the current locale's encoding)."
msgstr ""
"포맷이 현재 로케일에 따라 다르므로, 출력값에 대해 가정을 할 때 주의해야 합니다. 필드 순서가 달라지며 (예를 들어, "
"\"월/일/년\" 과 \"일/월/년\"), 출력에는 로케일의 기본 인코딩을 사용하여 인코딩된 유니코드 문자가 포함될 수 있습니다 "
"(예를 들어, 현재 로케일이 ``ja_JP``\\이면, 기본 인코딩은 ``eucJP``, ``SJIS`` 또는 ``utf-8`` 중"
" 하나일 수 있습니다; 현재 로케일의 인코딩을 결정하려면 :meth:`locale.getlocale`\\를 사용하십시오)."

#: ../Doc/library/datetime.rst:2202
msgid ""
"The :meth:`strptime` method can parse years in the full [1, 9999] range, "
"but years < 1000 must be zero-filled to 4-digit width."
msgstr ""
":meth:`strptime` 메서드는 전체 [1, 9999] 범위에서 연도를 구문 분석할 수 있지만, 1000보다 작은 연도는 "
"4자리 너비가 되도록 0으로 채워야 합니다."

#: ../Doc/library/datetime.rst:2205
msgid ""
"In previous versions, :meth:`strftime` method was restricted to years >= "
"1900."
msgstr "이전 버전에서 :meth:`strftime` 메서드는 1900년 이상으로 제한되었습니다."

#: ../Doc/library/datetime.rst:2209
msgid "In version 3.2, :meth:`strftime` method was restricted to years >= 1000."
msgstr "버전 3.2에서, :meth:`strftime` 메서드는 연도를 1000 이상으로 제한했습니다."

#: ../Doc/library/datetime.rst:2214
msgid ""
"When used with the :meth:`strptime` method, the ``%p`` directive only "
"affects the output hour field if the ``%I`` directive is used to parse "
"the hour."
msgstr ""
":meth:`strptime` 메서드와 함께 사용할 때, ``%p`` 지시자는 시간을 구문 분석하는 데 ``%I`` 지시문을 사용할"
" 때만 출력 시간 필드에 영향을 줍니다."

#: ../Doc/library/datetime.rst:2218
msgid ""
"Unlike the :mod:`time` module, the :mod:`datetime` module does not "
"support leap seconds."
msgstr ":mod:`time` 모듈과 달리, :mod:`datetime` 모듈은 윤초를 지원하지 않습니다."

#: ../Doc/library/datetime.rst:2222
#, python-format
msgid ""
"When used with the :meth:`strptime` method, the ``%f`` directive accepts "
"from one to six digits and zero pads on the right.  ``%f`` is an "
"extension to the set of format characters in the C standard (but "
"implemented separately in datetime objects, and therefore always "
"available)."
msgstr ""
":meth:`strptime` 메서드와 함께 사용할 때, ``%f`` 지시자는 하나에서 여섯 자리 숫자와 오른쪽의 0-채움을 "
"받아들입니다. ``%f``\\는 C 표준의 포맷 문자 집합에 대한 확장입니다 (하지만 datetime 객체에서 별도로 구현되므로 "
"항상 사용할 수 있습니다)."

#: ../Doc/library/datetime.rst:2229
msgid ""
"For a naive object, the ``%z`` and ``%Z`` format codes are replaced by "
"empty strings."
msgstr "나이브 객체의 경우, ``%z`` 와 ``%Z`` 포맷 코드는 빈 문자열로 치환됩니다."

#: ../Doc/library/datetime.rst:2232
msgid "For an aware object:"
msgstr "어웨어 객체의 경우:"

#: ../Doc/library/datetime.rst:2235
msgid ""
":meth:`utcoffset` is transformed into a string of the form "
"±HHMM[SS[.ffffff]], where HH is a 2-digit string giving the number of UTC"
" offset hours, MM is a 2-digit string giving the number of UTC offset "
"minutes, SS is a 2-digit string giving the number of UTC offset seconds "
"and ffffff is a 6-digit string giving the number of UTC offset "
"microseconds.  The ffffff part is omitted when the offset is a whole "
"number of seconds and both the ffffff and the SS part is omitted when the"
" offset is a whole number of minutes.  For example, if :meth:`utcoffset` "
"returns ``timedelta(hours=-3, minutes=-30)``, ``%z`` is replaced with the"
" string ``'-0330'``."
msgstr ""
":meth:`utcoffset`\\이 ±HHMM[SS[.ffffff]] 형식의 문자열로 변환됩니다. 여기서 HH는 UTC 오프셋 "
"시간(hour)의 수를 나타내는 두 자리 숫자 문자열이고, MM은 UTC 오프셋 분의 수를 나타내는 두 자리 숫자 문자열이며, "
"SS는 UTC 오프셋 초의 수를 나타내는 두 자리 숫자 문자열이며, ffffff는 UTC 오프셋 마이크로초의 수를 나타내는 6자리 "
"숫자 문자열입니다. 오프셋이 딱 떨어지는 초면 ffffff 부분은 생략되며, offset이 딱 떨어지는 분이면 ffffff와 SS "
"부분이 모두 생략됩니다. 예를 들어, :meth:`utcoffset`\\이 ``timedelta(hours=-3, "
"minutes=-30)``\\를 반환하면, ``%z``\\는 ``'-0330'`` 문자열로 치환됩니다."

#: ../Doc/library/datetime.rst:2249
msgid ""
"When the ``%z`` directive is provided to the  :meth:`strptime` method, "
"the UTC offsets can have a colon as a separator between hours, minutes "
"and seconds. For example, ``'+01:00:00'`` will be parsed as an offset of "
"one hour. In addition, providing ``'Z'`` is identical to ``'+00:00'``."
msgstr ""
"``%z`` 지시자가 :meth:`strptime` 메서드에 제공될 때, UTC 오프셋에는 콜론이 시, 분 및 초 사이의 구분 "
"기호로 사용될 수 있습니다. 예를 들어, ``'+01:00:00'``\\는 1시간의 오프셋으로 구문 분석됩니다. 또한, "
"``'Z'``\\를 제공하는 것은 ``'+00:00'``\\과 같습니다."

#: ../Doc/library/datetime.rst:2257
msgid ""
"If :meth:`tzname` returns ``None``, ``%Z`` is replaced by an empty "
"string.  Otherwise ``%Z`` is replaced by the returned value, which must "
"be a string."
msgstr ""
":meth:`tzname`\\이 ``None``\\을 반환하면, ``%Z``\\는 빈 문자열로 치환됩니다. 그렇지 않으면 "
"``%Z``\\는 문자열이어야 하는 반환 값으로 치환됩니다."

#: ../Doc/library/datetime.rst:2261
msgid ""
"When the ``%z`` directive is provided to the :meth:`strptime` method, an "
"aware :class:`.datetime` object will be produced.  The ``tzinfo`` of the "
"result will be set to a :class:`timezone` instance."
msgstr ""
"``%z`` 지시자가 :meth:`strptime` 메서드에 제공될 때, 어웨어 :class:`.datetime` 객체가 "
"생성됩니다. 결과의 ``tzinfo``\\는 :class:`timezone` 인스턴스로 설정됩니다."

#: ../Doc/library/datetime.rst:2267
msgid ""
"When used with the :meth:`strptime` method, ``%U`` and ``%W`` are only "
"used in calculations when the day of the week and the calendar year "
"(``%Y``) are specified."
msgstr ""
":meth:`strptime` 메서드와 함께 사용될 때, ``%U`` 와 ``%W``\\는 요일과 달력 연도(``%Y``)가 "
"지정되었을 때만 계산에 사용됩니다."

#: ../Doc/library/datetime.rst:2272
#, python-format
msgid ""
"Similar to ``%U`` and ``%W``, ``%V`` is only used in calculations when "
"the day of the week and the ISO year (``%G``) are specified in a "
":meth:`strptime` format string. Also note that ``%G`` and ``%Y`` are not "
"interchangeable."
msgstr ""
"``%U`` 와 ``%W``\\와 비슷하게, ``%V``\\는 요일과 ISO 연도(``%G``)가 :meth:`strptime` "
"포맷 문자열에 지정되었을 때만 계산에 사용됩니다. 또한 ``%G``\\와 ``%Y``\\를 상호 교환할 수 없음에 유의하십시오."

#: ../Doc/library/datetime.rst:2278
#, python-format
msgid ""
"When used with the :meth:`strptime` method, the leading zero is optional "
"for  formats ``%d``, ``%m``, ``%H``, ``%I``, ``%M``, ``%S``, ``%J``, "
"``%U``, ``%W``, and ``%V``. Format ``%y`` does require a leading zero."
msgstr ""

#: ../Doc/library/datetime.rst:2283
msgid "Footnotes"
msgstr "각주"

#: ../Doc/library/datetime.rst:2284
msgid "If, that is, we ignore the effects of Relativity"
msgstr "즉, 상대론적 효과를 무시한다면"

#: ../Doc/library/datetime.rst:2285
#, python-format
msgid ""
"Passing ``datetime.strptime('Feb 29', '%b %d')`` will fail since ``1900``"
" is not a leap year."
msgstr ""

#~ msgid "\\(4)"
#~ msgstr "\\(4)"

#~ msgid "\\(7)"
#~ msgstr "\\(7)"

