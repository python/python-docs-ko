# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-15 07:19+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/wsgiref.rst:2
msgid ":mod:`wsgiref` --- WSGI Utilities and Reference Implementation"
msgstr ":mod:`wsgiref` --- WSGI 유틸리티와 참조 구현"

#: ../Doc/library/wsgiref.rst:12
msgid ""
"The Web Server Gateway Interface (WSGI) is a standard interface between "
"web server software and web applications written in Python. Having a "
"standard interface makes it easy to use an application that supports WSGI"
" with a number of different web servers."
msgstr ""
"WSGI(Web Server Gateway Interface)는 웹 서버 소프트웨어와 파이썬으로 작성된 웹 응용 프로그램 간의 표준"
" 인터페이스입니다. 표준 인터페이스는 여러 웹 서버에서 WSGI를 지원하는 응용 프로그램을 쉽게 사용할 수 있도록 합니다."

#: ../Doc/library/wsgiref.rst:17
msgid ""
"Only authors of web servers and programming frameworks need to know every"
" detail and corner case of the WSGI design.  You don't need to understand"
" every detail of WSGI just to install a WSGI application or to write a "
"web application using an existing framework."
msgstr ""
"웹 서버와 프로그래밍 프레임워크의 작성자만 WSGI 설계의 모든 세부 사항과 코너 케이스를 알 필요가 있습니다. 단지 WSGI 응용"
" 프로그램을 설치하거나 기존 프레임워크를 사용하여 웹 응용 프로그램을 작성하기 위해, WSGI의 모든 세부 사항을 이해할 필요는 "
"없습니다."

#: ../Doc/library/wsgiref.rst:22
msgid ""
":mod:`wsgiref` is a reference implementation of the WSGI specification "
"that can be used to add WSGI support to a web server or framework.  It "
"provides utilities for manipulating WSGI environment variables and "
"response headers, base classes for implementing WSGI servers, a demo HTTP"
" server that serves WSGI applications, and a validation tool that checks "
"WSGI servers and applications for conformance to the WSGI specification "
"(:pep:`3333`)."
msgstr ""
":mod:`wsgiref`\\는 웹 서버나 프레임워크에 WSGI 지원을 추가하는 데 사용할 수 있는, WSGI 명세의 참조 "
"구현입니다. WSGI 환경 변수와 응답 헤더를 조작하는 유틸리티, WSGI 서버 구현을 위한 베이스 클래스, WSGI 응용 "
"프로그램을 서비스하는 데모 HTTP 서버 및 WSGI 서버와 응용 프로그램이 WSGI 명세(:pep:`3333`)에 부합하는지 "
"확인하는 유효성 검사 도구를 제공합니다."

#: ../Doc/library/wsgiref.rst:29
msgid ""
"See `wsgi.readthedocs.io <https://wsgi.readthedocs.io/>`_ for more "
"information about WSGI, and links to tutorials and other resources."
msgstr ""
"WSGI에 대한 더 자세한 정보 및 자습서와 기타 자원에 대한 링크는 `wsgi.readthedocs.io "
"<https://wsgi.readthedocs.io/>`_\\를 참조하십시오."

#: ../Doc/library/wsgiref.rst:36
msgid ":mod:`wsgiref.util` -- WSGI environment utilities"
msgstr ":mod:`wsgiref.util` -- WSGI 환경 유틸리티"

#: ../Doc/library/wsgiref.rst:42
msgid ""
"This module provides a variety of utility functions for working with WSGI"
" environments.  A WSGI environment is a dictionary containing HTTP "
"request variables as described in :pep:`3333`.  All of the functions "
"taking an *environ* parameter expect a WSGI-compliant dictionary to be "
"supplied; please see :pep:`3333` for a detailed specification."
msgstr ""
"이 모듈은 WSGI 환경으로 작업하기 위한 다양한 유틸리티 함수를 제공합니다. WSGI 환경은 :pep:`3333`\\에서 설명한 "
"대로 HTTP 요청 변수를 포함하는 딕셔너리입니다. *environ* 매개 변수를 취하는 모든 함수는 WSGI 호환 딕셔너리가 "
"제공될 것으로 기대합니다; 자세한 명세는 :pep:`3333`\\를 참조하십시오."

#: ../Doc/library/wsgiref.rst:51
msgid ""
"Return a guess for whether ``wsgi.url_scheme`` should be \"http\" or "
"\"https\", by checking for a ``HTTPS`` environment variable in the "
"*environ* dictionary.  The return value is a string."
msgstr ""
"*environ* 딕셔너리에서 ``HTTPS`` 환경 변수를 검사하여 ``wsgi.url_scheme``\\이 \"http\"와 "
"\"https\" 중 어느 것인지 추측합니다. 반환 값은 문자열입니다."

#: ../Doc/library/wsgiref.rst:55
#, fuzzy
msgid ""
"This function is useful when creating a gateway that wraps CGI or a CGI-"
"like protocol such as FastCGI.  Typically, servers providing such "
"protocols will include a ``HTTPS`` variable with a value of \"1\", "
"\"yes\", or \"on\" when a request is received via SSL.  So, this function"
" returns \"https\" if such a value is found, and \"http\" otherwise."
msgstr ""
"이 함수는 CGI 나 FastCGI와 같은 CGI와 유사한 프로토콜을 감싸는 게이트웨이를 만들 때 유용합니다. 일반적으로, 이러한 "
"프로토콜을 제공하는 서버는 SSL을 통해 요청이 수신될 때 \"1\", \"yes\" 또는 \"on\" 값을 갖는 ``HTTPS``"
" 변수를 포함합니다. 따라서, 이 함수는 그런 값을 발견하면 \"https\"를 반환하고, 그렇지 않으면 \"http\"를 "
"반환합니다."

#: ../Doc/library/wsgiref.rst:64
msgid ""
"Return the full request URI, optionally including the query string, using"
" the algorithm found in the \"URL Reconstruction\" section of "
":pep:`3333`.  If *include_query* is false, the query string is not "
"included in the resulting URI."
msgstr ""
":pep:`3333`\\의 \"URL 재구성\" 절에 있는 알고리즘을 사용하여 전체 요청 URI를 반환합니다. 선택적으로 질의 "
"문자열(query string)을 포함합니다. *include_query*\\가 거짓이면 질의 문자열은 결과 URI에 포함되지 "
"않습니다."

#: ../Doc/library/wsgiref.rst:71
msgid ""
"Similar to :func:`request_uri`, except that the ``PATH_INFO`` and "
"``QUERY_STRING`` variables are ignored.  The result is the base URI of "
"the application object addressed by the request."
msgstr ""
"``PATH_INFO`` 와 ``QUERY_STRING`` 변수가 무시된다는 점을 제외하면 :func:`request_uri`\\와"
" 유사합니다. 결과는 요청이 가리키는 응용 프로그램 객체의 기본 URI입니다."

#: ../Doc/library/wsgiref.rst:78
msgid ""
"Shift a single name from ``PATH_INFO`` to ``SCRIPT_NAME`` and return the "
"name. The *environ* dictionary is *modified* in-place; use a copy if you "
"need to keep the original ``PATH_INFO`` or ``SCRIPT_NAME`` intact."
msgstr ""
"단일 이름을 ``PATH_INFO``\\에서 ``SCRIPT_NAME``\\로 이동하고 이름을 반환합니다. *environ* "
"딕셔너리는 그 자리에서 *수정*\\됩니다; 원본 ``PATH_INFO`` 나 ``SCRIPT_NAME``\\를 그대로 유지해야 하면"
" 사본을 사용하십시오."

#: ../Doc/library/wsgiref.rst:82
msgid ""
"If there are no remaining path segments in ``PATH_INFO``, ``None`` is "
"returned."
msgstr "``PATH_INFO``\\에 남아있는 경로 세그먼트가 없으면, ``None``\\이 반환됩니다."

#: ../Doc/library/wsgiref.rst:84
msgid ""
"Typically, this routine is used to process each portion of a request URI "
"path, for example to treat the path as a series of dictionary keys. This "
"routine modifies the passed-in environment to make it suitable for "
"invoking another WSGI application that is located at the target URI. For "
"example, if there is a WSGI application at ``/foo``, and the request URI "
"path is ``/foo/bar/baz``, and the WSGI application at ``/foo`` calls "
":func:`shift_path_info`, it will receive the string \"bar\", and the "
"environment will be updated to be suitable for passing to a WSGI "
"application at ``/foo/bar``.  That is, ``SCRIPT_NAME`` will change from "
"``/foo`` to ``/foo/bar``, and ``PATH_INFO`` will change from ``/bar/baz``"
" to ``/baz``."
msgstr ""
"일반적으로, 이 루틴은 요청 URI 경로의 각 부분을 처리하는 데 사용됩니다, 예를 들어 경로를 일련의 딕셔너리 키로 취급합니다. "
"이 루틴은 전달된 환경을 수정하여 대상 URI에 있는 다른 WSGI 응용 프로그램을 호출하는 데 적합하게 만듭니다. 예를 들어, "
"``/foo``\\에 WSGI 응용 프로그램이 있고, 요청 URI 경로가 ``/foo/bar/baz``\\이고, "
"``/foo``\\의 WSGI 응용 프로그램이 :func:`shift_path_info`\\를 호출하면 \"bar\" 문자열을 "
"수신하고 전달할 환경이 ``/foo/bar``\\에 있는 WSGI 응용 프로그램에 전달하기 적합하도록 갱신됩니다. 즉, "
"``SCRIPT_NAME``\\는 ``/foo``\\에서 ``/foo/bar``\\로 변경되고, ``PATH_INFO``\\는 "
"``/bar/baz``\\에서 ``/baz``\\로 변경됩니다."

#: ../Doc/library/wsgiref.rst:95
msgid ""
"When ``PATH_INFO`` is just a \"/\", this routine returns an empty string "
"and appends a trailing slash to ``SCRIPT_NAME``, even though empty path "
"segments are normally ignored, and ``SCRIPT_NAME`` doesn't normally end "
"in a slash.  This is intentional behavior, to ensure that an application "
"can tell the difference between URIs ending in ``/x`` from ones ending in"
" ``/x/`` when using this routine to do object traversal."
msgstr ""
"``PATH_INFO``\\가 단지 \"/\"일 때, 이 루틴은 빈 문자열을 반환하고 ``SCRIPT_NAME``\\에 후행 "
"슬래시를 추가합니다; 빈 경로 세그먼트는 일반적으로 무시되고, ``SCRIPT_NAME``\\는 일반적으로 슬래시로 끝나지 않음에도"
" 그렇게 합니다. 의도적인 동작입니다. 이 루틴을 사용하여 객체를 탐색할 때, 응용 프로그램이 ``/x``\\로 끝나는 URI와 "
"``/x/``\\로 끝나는 URI의 차이를 구별할 수 있도록 하기 위함입니다."

#: ../Doc/library/wsgiref.rst:105
msgid "Update *environ* with trivial defaults for testing purposes."
msgstr "테스트 목적으로 *environ*\\를 뻔한 기본값으로 갱신합니다."

#: ../Doc/library/wsgiref.rst:107
msgid ""
"This routine adds various parameters required for WSGI, including "
"``HTTP_HOST``, ``SERVER_NAME``, ``SERVER_PORT``, ``REQUEST_METHOD``, "
"``SCRIPT_NAME``, ``PATH_INFO``, and all of the :pep:`3333`\\ -defined "
"``wsgi.*`` variables.  It only supplies default values, and does not "
"replace any existing settings for these variables."
msgstr ""
"이 루틴은 ``HTTP_HOST``, ``SERVER_NAME``, ``SERVER_PORT``, "
"``REQUEST_METHOD``, ``SCRIPT_NAME``, ``PATH_INFO`` 및 모든 :pep:`3333`\\에서 "
"정의된 ``wsgi.*`` 변수를 포함하여 WSGI에 필요한 다양한 매개 변수를 추가합니다. 기본값만 제공하며, 이 변수들에 대한 "
"기존 설정을 대체하지 않습니다."

#: ../Doc/library/wsgiref.rst:113
msgid ""
"This routine is intended to make it easier for unit tests of WSGI servers"
" and applications to set up dummy environments.  It should NOT be used by"
" actual WSGI servers or applications, since the data is fake!"
msgstr ""
"이 루틴은 WSGI 서버와 응용 프로그램의 단위 테스트가 더미 환경을 쉽게 설정하도록 하기 위한 것입니다. 데이터가 가짜이므로, "
"실제 WSGI 서버나 응용 프로그램에서 사용해서는 안 됩니다!"

#: ../Doc/library/wsgiref.rst:117 ../Doc/library/wsgiref.rst:164
#: ../Doc/library/wsgiref.rst:286 ../Doc/library/wsgiref.rst:418
msgid "Example usage::"
msgstr "사용 예::"

#: ../Doc/library/wsgiref.rst:141
msgid ""
"In addition to the environment functions above, the :mod:`wsgiref.util` "
"module also provides these miscellaneous utilities:"
msgstr "위의 환경 함수 외에도, :mod:`wsgiref.util` 모듈은 다음과 같은 기타 유틸리티를 제공합니다:"

#: ../Doc/library/wsgiref.rst:147
msgid ""
"Return true if 'header_name' is an HTTP/1.1 \"Hop-by-Hop\" header, as "
"defined by :rfc:`2616`."
msgstr ""
"'header_name'이 :rfc:`2616`\\가 정의하고 있는 HTTP/1.1 \"Hop-by-Hop\" 헤더면 참을 "
"반환합니다."

#: ../Doc/library/wsgiref.rst:153
msgid ""
"A wrapper to convert a file-like object to an :term:`iterator`.  The "
"resulting objects support both :meth:`__getitem__` and :meth:`__iter__` "
"iteration styles, for compatibility with Python 2.1 and Jython. As the "
"object is iterated over, the optional *blksize* parameter will be "
"repeatedly passed to the *filelike* object's :meth:`read` method to "
"obtain bytestrings to yield.  When :meth:`read` returns an empty "
"bytestring, iteration is ended and is not resumable."
msgstr ""
"파일류 객체를 :term:`이터레이터 <iterator>`\\로 변환하는 래퍼. 결과 객체는 파이썬 2.1과 Jython과의 "
"호환성을 위해, :meth:`__getitem__` 과 :meth:`__iter__` 이터레이션 스타일을 모두 지원합니다. 객체가 "
"이터레이트될 때, 선택적인 *blksize* 매개 변수는 산출할 바이트열을 얻기 위해 *filelike* 객체의 "
":meth:`read` 메서드에 반복적으로 전달됩니다. :meth:`read`\\가 빈 바이트열을 반환하면 이터레이션이 종료되고 "
"다시 시작할 수 없습니다."

#: ../Doc/library/wsgiref.rst:160
msgid ""
"If *filelike* has a :meth:`close` method, the returned object will also "
"have a :meth:`close` method, and it will invoke the *filelike* object's "
":meth:`close` method when called."
msgstr ""
"*filelike*\\에 :meth:`close` 메서드가 있으면, 반환된 객체에도 :meth:`close` 메서드가 있고, 호출될"
" 때 *filelike* 객체의 :meth:`close` 메서드를 호출합니다."

#: ../Doc/library/wsgiref.rst:176
msgid "Support for :meth:`sequence protocol <__getitem__>` is deprecated."
msgstr ""

#: ../Doc/library/wsgiref.rst:181
msgid ":mod:`wsgiref.headers` -- WSGI response header tools"
msgstr ":mod:`wsgiref.headers` -- WSGI 응답 헤더 도구"

#: ../Doc/library/wsgiref.rst:187
msgid ""
"This module provides a single class, :class:`Headers`, for convenient "
"manipulation of WSGI response headers using a mapping-like interface."
msgstr ""
"이 모듈은 매핑류 인터페이스를 사용하여 WSGI 응답 헤더를 편리하게 조작할 수 있는 클래스 :class:`Headers` 하나를 "
"제공합니다."

#: ../Doc/library/wsgiref.rst:193
msgid ""
"Create a mapping-like object wrapping *headers*, which must be a list of "
"header name/value tuples as described in :pep:`3333`. The default value "
"of *headers* is an empty list."
msgstr ""
":pep:`3333`\\에 설명된 것처럼 헤더 이름/값 튜플의 리스트이어야 하는 *headers*\\를 감싸는 매핑류 객체를 "
"만듭니다. *headers*\\의 기본값은 빈 리스트입니다."

#: ../Doc/library/wsgiref.rst:197
msgid ""
":class:`Headers` objects support typical mapping operations including "
":meth:`__getitem__`, :meth:`get`, :meth:`__setitem__`, "
":meth:`setdefault`, :meth:`__delitem__` and :meth:`__contains__`.  For "
"each of these methods, the key is the header name (treated case-"
"insensitively), and the value is the first value associated with that "
"header name.  Setting a header deletes any existing values for that "
"header, then adds a new value at the end of the wrapped header list.  "
"Headers' existing order is generally maintained, with new headers added "
"to the end of the wrapped list."
msgstr ""
":class:`Headers` 객체는 :meth:`__getitem__`, :meth:`get`, "
":meth:`__setitem__`, :meth:`setdefault`, :meth:`__delitem__` 및 "
":meth:`__contains__`\\를 포함한 일반적인 매핑 연산을 지원합니다. 이러한 각 메서드에 대해, 키는 헤더 이름(대소"
" 문자를 구분하지 않습니다)이며, 값은 해당 헤더 이름과 연관된 첫 번째 값입니다. 헤더를 설정하면 해당 헤더의 기존 값이 삭제된 "
"다음, 감싸진 헤러 리스트의 끝에 새 값이 추가됩니다. 헤더의 기존 순서는 일반적으로 유지되며, 감싸진 리스트의 끝에 새 헤더가 "
"추가됩니다."

#: ../Doc/library/wsgiref.rst:206
msgid ""
"Unlike a dictionary, :class:`Headers` objects do not raise an error when "
"you try to get or delete a key that isn't in the wrapped header list. "
"Getting a nonexistent header just returns ``None``, and deleting a "
"nonexistent header does nothing."
msgstr ""
"딕셔너리와 달리, :class:`Headers` 객체는 감싸진 헤더 리스트에 없는 키를 가져오거나 삭제하려고 하면 에러를 발생시키지"
" 않습니다. 존재하지 않는 헤더를 가져오려고 하면 ``None``\\을 반환하고, 존재하지 않는 헤더를 삭제하면 아무것도 하지 "
"않습니다."

#: ../Doc/library/wsgiref.rst:211
msgid ""
":class:`Headers` objects also support :meth:`keys`, :meth:`values`, and "
":meth:`items` methods.  The lists returned by :meth:`keys` and "
":meth:`items` can include the same key more than once if there is a "
"multi-valued header.  The ``len()`` of a :class:`Headers` object is the "
"same as the length of its :meth:`items`, which is the same as the length "
"of the wrapped header list.  In fact, the :meth:`items` method just "
"returns a copy of the wrapped header list."
msgstr ""
":class:`Headers` 객체는 :meth:`keys`, :meth:`values` 및 :meth:`items` 메서드도 "
"지원합니다. :meth:`keys` 와 :meth:`items`\\에 의해 반환된 리스트에는 다중-값 헤더가 있으면 같은 키가 두 "
"번 이상 포함될 수 있습니다. :class:`Headers` 객체의 ``len()``\\는 :meth:`items`\\의 길이와 "
"같고, 이는 감싸진 헤더 리스트의 길이와 같습니다. 실제로, :meth:`items` 메서드는 단지 감싸진 헤더 리스트의 복사본을 "
"반환합니다."

#: ../Doc/library/wsgiref.rst:218
msgid ""
"Calling ``bytes()`` on a :class:`Headers` object returns a formatted "
"bytestring suitable for transmission as HTTP response headers.  Each "
"header is placed on a line with its value, separated by a colon and a "
"space. Each line is terminated by a carriage return and line feed, and "
"the bytestring is terminated with a blank line."
msgstr ""
":class:`Headers` 객체에서 ``bytes()``\\를 호출하면 HTTP 응답 헤더로 전송하기에 적합한 포맷된 바이트열이"
" 반환됩니다. 각 헤더는 콜론과 공백으로 구분된 값과 함께 줄에 들어갑니다. 각 줄은 캐리지 리턴과 줄넘김으로 끝나며, 바이트열은 "
"빈 줄로 끝납니다."

#: ../Doc/library/wsgiref.rst:224
msgid ""
"In addition to their mapping interface and formatting features, "
":class:`Headers` objects also have the following methods for querying and"
" adding multi-valued headers, and for adding headers with MIME "
"parameters:"
msgstr ""
":class:`Headers` 객체는 매핑 인터페이스와 포매팅 기능 외에도, 다중-값 헤더를 조회하거나 추가하고, MIME "
"파라미터가 있는 헤더를 추가하기 위해 다음과 같은 메서드를 제공합니다:"

#: ../Doc/library/wsgiref.rst:231
msgid "Return a list of all the values for the named header."
msgstr "주어진 이름의 헤더에 대한 모든 값의 리스트를 반환합니다."

#: ../Doc/library/wsgiref.rst:233
msgid ""
"The returned list will be sorted in the order they appeared in the "
"original header list or were added to this instance, and may contain "
"duplicates.  Any fields deleted and re-inserted are always appended to "
"the header list.  If no fields exist with the given name, returns an "
"empty list."
msgstr ""
"반환된 리스트는 원래 헤더 리스트에 나타나거나 이 인스턴스에 추가된 순서대로 정렬되고, 중복을 포함할 수 있습니다. 삭제되고 다시 "
"삽입된 필드는 항상 헤더 리스트의 끝에 추가됩니다. 주어진 이름의 필드가 존재하지 않으면, 빈 리스트를 반환합니다."

#: ../Doc/library/wsgiref.rst:241
msgid ""
"Add a (possibly multi-valued) header, with optional MIME parameters "
"specified via keyword arguments."
msgstr "키워드 인자로 지정되는 선택적 MIME 파라미터와 함께 헤더를 추가합니다 (다중-값 가능)."

#: ../Doc/library/wsgiref.rst:244
msgid ""
"*name* is the header field to add.  Keyword arguments can be used to set "
"MIME parameters for the header field.  Each parameter must be a string or"
" ``None``. Underscores in parameter names are converted to dashes, since "
"dashes are illegal in Python identifiers, but many MIME parameter names "
"include dashes.  If the parameter value is a string, it is added to the "
"header value parameters in the form ``name=\"value\"``. If it is "
"``None``, only the parameter name is added. (This is used for MIME "
"parameters without a value.)  Example usage::"
msgstr ""
"*name*\\은 추가할 헤더 필드입니다. 키워드 인자는 헤더 필드에 대한 MIME 파라미터를 설정하는 데 사용될 수 있습니다. 각"
" 파라미터는 문자열이나 ``None`` 이어야 합니다. 파라미터 이름의 밑줄은 대시로 변환됩니다; 파이썬 식별자에서는 대시가 "
"유효하지 않지만 많은 MIME 파라미터 이름에는 대시가 포함되기 때문입니다. 파라미터값이 문자열이면 "
"``name=\"value\"`` 형식으로 헤더 값 파라미터에 추가됩니다. ``None``\\이면 파라미터 이름 만 추가됩니다. "
"(이것은 값이 없는 MIME 파라미터에 사용됩니다.) 사용 예::"

#: ../Doc/library/wsgiref.rst:254
msgid "The above will add a header that looks like this::"
msgstr "위의 코드는 다음과 같은 헤더를 추가합니다::"

#: ../Doc/library/wsgiref.rst:259
msgid "*headers* parameter is optional."
msgstr "*headers* 매개 변수는 선택적입니다."

#: ../Doc/library/wsgiref.rst:264
msgid ":mod:`wsgiref.simple_server` -- a simple WSGI HTTP server"
msgstr ":mod:`wsgiref.simple_server` -- 간단한 WSGI HTTP 서버"

#: ../Doc/library/wsgiref.rst:270
msgid ""
"This module implements a simple HTTP server (based on :mod:`http.server`)"
" that serves WSGI applications.  Each server instance serves a single "
"WSGI application on a given host and port.  If you want to serve multiple"
" applications on a single host and port, you should create a WSGI "
"application that parses ``PATH_INFO`` to select which application to "
"invoke for each request.  (E.g., using the :func:`shift_path_info` "
"function from :mod:`wsgiref.util`.)"
msgstr ""
"이 모듈은 WSGI 응용 프로그램을 서빙하는 간단한 HTTP 서버(:mod:`http.server` 기반)를 구현합니다. 각 서버 "
"인스턴스는 주어진 호스트와 포트에서 단일 WSGI 응용 프로그램을 서빙합니다. 단일 호스트와 포트에서 여러 응용 프로그램을 "
"서빙하려면, ``PATH_INFO``\\를 구문 분석하여 각 요청에 대해 호출할 응용 프로그램을 선택하는 WSGI 응용 프로그램을 "
"만들어야 합니다. (예를 들어, :mod:`wsgiref.util`\\의 :func:`shift_path_info` 함수를 "
"사용해서.)"

#: ../Doc/library/wsgiref.rst:281
msgid ""
"Create a new WSGI server listening on *host* and *port*, accepting "
"connections for *app*.  The return value is an instance of the supplied "
"*server_class*, and will process requests using the specified "
"*handler_class*.  *app* must be a WSGI application object, as defined by "
":pep:`3333`."
msgstr ""
"*host* 와 *port*\\에서 수신을 기다리고, *app*\\에 대한 연결을 수락하는 새 WSGI 서버를 만듭니다. 반환 값은"
" 제공된 *server_class*\\의 인스턴스이며, 지정된 *handler_class*\\를 사용하여 요청을 처리합니다. "
"*app*\\는 :pep:`3333`\\에 정의된 WSGI 응용 프로그램 객체여야 합니다."

#: ../Doc/library/wsgiref.rst:302
msgid ""
"This function is a small but complete WSGI application that returns a "
"text page containing the message \"Hello world!\" and a list of the "
"key/value pairs provided in the *environ* parameter.  It's useful for "
"verifying that a WSGI server (such as :mod:`wsgiref.simple_server`) is "
"able to run a simple WSGI application correctly."
msgstr ""
"이 함수는 작지만 완벽한 WSGI 응용 프로그램인데, \"Hello world!\" 메시지와 *environ* 매개 변수에 제공된 "
"키/값 쌍 목록이 포함된 텍스트 페이지를 반환합니다. WSGI 서버(가령 :mod:`wsgiref.simple_server`)가 "
"간단한 WSGI 응용 프로그램을 올바르게 실행할 수 있는지 확인하는 데 유용합니다."

#: ../Doc/library/wsgiref.rst:311
msgid ""
"Create a :class:`WSGIServer` instance.  *server_address* should be a "
"``(host,port)`` tuple, and *RequestHandlerClass* should be the subclass "
"of :class:`http.server.BaseHTTPRequestHandler` that will be used to "
"process requests."
msgstr ""
":class:`WSGIServer` 인스턴스를 만듭니다. *server_address*\\는 ``(host,port)`` 튜플이어야"
" 하며, *RequestHandlerClass*\\는 "
":class:`http.server.BaseHTTPRequestHandler`\\의 서브 클래스여야 하는데, 요청을 처리하는 데 "
"사용됩니다."

#: ../Doc/library/wsgiref.rst:316
msgid ""
"You do not normally need to call this constructor, as the "
":func:`make_server` function can handle all the details for you."
msgstr ":func:`make_server` 함수가 모든 세부 사항을 처리할 수 있으므로, 일반적으로 이 생성자를 호출할 필요가 없습니다."

#: ../Doc/library/wsgiref.rst:319
msgid ""
":class:`WSGIServer` is a subclass of :class:`http.server.HTTPServer`, so "
"all of its methods (such as :meth:`serve_forever` and "
":meth:`handle_request`) are available. :class:`WSGIServer` also provides "
"these WSGI-specific methods:"
msgstr ""
":class:`WSGIServer`\\는 :class:`http.server.HTTPServer`\\의 서브 클래스이므로, 모든 "
"메서드(가령 :meth:`serve_forever`\\와 :meth:`handle_request`)를 사용할 수 있습니다. "
":class:`WSGIServer`\\는 또한 다음과 같은 WSGI 전용 메서드를 제공합니다:"

#: ../Doc/library/wsgiref.rst:326
msgid ""
"Sets the callable *application* as the WSGI application that will receive"
" requests."
msgstr "콜러블 *application*\\을 요청을 수신하는 WSGI 응용 프로그램으로 설정합니다."

#: ../Doc/library/wsgiref.rst:332
msgid "Returns the currently-set application callable."
msgstr "현재 설정되어있는 응용 프로그램 콜러블을 반환합니다."

#: ../Doc/library/wsgiref.rst:334
msgid ""
"Normally, however, you do not need to use these additional methods, as "
":meth:`set_app` is normally called by :func:`make_server`, and the "
":meth:`get_app` exists mainly for the benefit of request handler "
"instances."
msgstr ""
"그러나 일반적으로, 이러한 추가 메서드를 사용할 필요가 없는데, :meth:`set_app`\\는 일반적으로 "
":func:`make_server`\\에서 호출되고, :meth:`get_app`\\은 주로 요청 처리기 인스턴스의 필요를 위해 "
"존재하기 때문입니다"

#: ../Doc/library/wsgiref.rst:341
msgid ""
"Create an HTTP handler for the given *request* (i.e. a socket), "
"*client_address* (a ``(host,port)`` tuple), and *server* "
"(:class:`WSGIServer` instance)."
msgstr ""
"지정된 *request* (즉, 소켓), *client_address* (``(host,port)`` 튜플) 및 *server* "
"(:class:`WSGIServer` 인스턴스)를 위한 HTTP 처리기를 만듭니다."

#: ../Doc/library/wsgiref.rst:344
msgid ""
"You do not need to create instances of this class directly; they are "
"automatically created as needed by :class:`WSGIServer` objects.  You can,"
" however, subclass this class and supply it as a *handler_class* to the "
":func:`make_server` function.  Some possibly relevant methods for "
"overriding in subclasses:"
msgstr ""
"이 클래스의 인스턴스를 직접 만들 필요는 없습니다; :class:`WSGIServer` 객체가 필요에 따라 자동으로 만듭니다. "
"그러나, 이 클래스를 서브 클래싱하여 *handler_class*\\로 :func:`make_server` 함수에 제공할 수 "
"있습니다. 서브 클래스에서 재정의하는데 적합한 메서드들은 다음과 같습니다:"

#: ../Doc/library/wsgiref.rst:353
msgid ""
"Returns a dictionary containing the WSGI environment for a request.  The "
"default implementation copies the contents of the :class:`WSGIServer` "
"object's :attr:`base_environ` dictionary attribute and then adds various "
"headers derived from the HTTP request.  Each call to this method should "
"return a new dictionary containing all of the relevant CGI environment "
"variables as specified in :pep:`3333`."
msgstr ""
"요청에 대한 WSGI 환경을 포함하는 딕셔너리를 반환합니다. 기본 구현은 :class:`WSGIServer` 객체의 "
":attr:`base_environ` 딕셔너리 어트리뷰트의 내용을 복사한 다음, HTTP 요청으로부터 온 다양한 헤더를 추가합니다."
" 이 메서드를 호출할 때마다 :pep:`3333`\\에 지정된 CGI 환경 변수를 모두 포함하는 새 딕셔너리를 반환해야 합니다."

#: ../Doc/library/wsgiref.rst:363
msgid ""
"Return the object that should be used as the ``wsgi.errors`` stream. The "
"default implementation just returns ``sys.stderr``."
msgstr ""
"``wsgi.errors`` 스트림으로 사용해야 하는 객체를 반환합니다. 기본 구현은 단지 ``sys.stderr``\\를 "
"반환합니다."

#: ../Doc/library/wsgiref.rst:369
msgid ""
"Process the HTTP request.  The default implementation creates a handler "
"instance using a :mod:`wsgiref.handlers` class to implement the actual "
"WSGI application interface."
msgstr ""
"HTTP 요청을 처리합니다. 기본 구현은 :mod:`wsgiref.handlers` 클래스를 사용하여 실제 WSGI 응용 프로그램 "
"인터페이스를 구현하는 처리기 인스턴스를 만듭니다."

#: ../Doc/library/wsgiref.rst:375
msgid ":mod:`wsgiref.validate` --- WSGI conformance checker"
msgstr ":mod:`wsgiref.validate` --- WSGI 적합성 검사기"

#: ../Doc/library/wsgiref.rst:381
msgid ""
"When creating new WSGI application objects, frameworks, servers, or "
"middleware, it can be useful to validate the new code's conformance using"
" :mod:`wsgiref.validate`.  This module provides a function that creates "
"WSGI application objects that validate communications between a WSGI "
"server or gateway and a WSGI application object, to check both sides for "
"protocol conformance."
msgstr ""
"새로운 WSGI 응용 프로그램 객체, 프레임워크, 서버 또는 미들웨어를 만들 때, :mod:`wsgiref.validate`\\를 "
"사용하여 새 코드의 적합성을 확인하는 것이 유용할 수 있습니다. 이 모듈은 WSGI 서버나 게이트웨이와 WSGI 응용 프로그램 객체"
" 사이의 통신을 검증하는 WSGI 응용 프로그램 객체를 만드는 함수를 제공하여, 양측의 프로토콜 준수 여부를 검사할 수 있도록 "
"합니다."

#: ../Doc/library/wsgiref.rst:388
#, python-format
msgid ""
"Note that this utility does not guarantee complete :pep:`3333` "
"compliance; an absence of errors from this module does not necessarily "
"mean that errors do not exist.  However, if this module does produce an "
"error, then it is virtually certain that either the server or application"
" is not 100% compliant."
msgstr ""
"이 유틸리티는 완전한 :pep:`3333` 적합성을 보장하지는 않습니다; 이 모듈에서 에러가 없다고 해서 에러가 존재하지 않는다는 "
"것을 의미하지는 않습니다. 그러나, 이 모듈에서 오류가 발생하면, 서버나 응용 프로그램이 100% 적합하지 않다는 것은 사실상 "
"확실합니다."

#: ../Doc/library/wsgiref.rst:393
msgid ""
"This module is based on the :mod:`paste.lint` module from Ian Bicking's "
"\"Python Paste\" library."
msgstr "이 모듈은 Ian Bicking의 \"Python Paste\" 라이브러리의 :mod:`paste.lint` 모듈을 기반으로 합니다."

#: ../Doc/library/wsgiref.rst:399
msgid ""
"Wrap *application* and return a new WSGI application object.  The "
"returned application will forward all requests to the original "
"*application*, and will check that both the *application* and the server "
"invoking it are conforming to the WSGI specification and to :rfc:`2616`."
msgstr ""
"*application* 감싸고 새 WSGI 응용 프로그램 객체를 반환합니다. 반환된 응용 프로그램은 모든 요청을 원래 "
"*application*\\으로 전달하고, *application*\\과 이를 호출하는 서버가 모두 WSGI 명세와 "
":rfc:`2616`\\를 준수하는지 확인합니다."

#: ../Doc/library/wsgiref.rst:404
msgid ""
"Any detected nonconformance results in an :exc:`AssertionError` being "
"raised; note, however, that how these errors are handled is server-"
"dependent.  For example, :mod:`wsgiref.simple_server` and other servers "
"based on :mod:`wsgiref.handlers` (that don't override the error handling "
"methods to do something else) will simply output a message that an error "
"has occurred, and dump the traceback to ``sys.stderr`` or some other "
"error stream."
msgstr ""
"탐지된 모든 부적합 결과는 :exc:`AssertionError`\\를 일으킵니다; 그러나 이러한 에러를 처리하는 방법은 서버에 "
"따라 다릅니다. 예를 들어, :mod:`wsgiref.simple_server`\\와 "
":mod:`wsgiref.handlers`\\를 기반으로 하는 다른 (에러 처리 메서드를 재정의해서 다른 작업을 수행하지 않는) "
"서버는 단순히 에러가 발생했다는 메시지를 출력하고 ``sys.stderr`` 나 기타 에러 스트림으로 트레이스백을 덤프합니다."

#: ../Doc/library/wsgiref.rst:411
msgid ""
"This wrapper may also generate output using the :mod:`warnings` module to"
" indicate behaviors that are questionable but which may not actually be "
"prohibited by :pep:`3333`.  Unless they are suppressed using Python "
"command-line options or the :mod:`warnings` API, any such warnings will "
"be written to ``sys.stderr`` (*not* ``wsgi.errors``, unless they happen "
"to be the same object)."
msgstr ""
"이 래퍼는 의심스럽기는 하지만 :pep:`3333`\\에서 실제로 금지되지 않을 수도 있는 동작을 나타내도록 "
":mod:`warnings` 모듈을 사용하여 출력을 생성할 수도 있습니다. 파이썬 명령 줄 옵션이나 :mod:`warnings` "
"API를 사용해서 억제되지 않는 한, 그러한 경고는 ``sys.stderr``\\(같은 객체가 아니라면 "
"``wsgi.errors``\\가 *아닙니다*)에 기록됩니다."

#: ../Doc/library/wsgiref.rst:443
msgid ":mod:`wsgiref.handlers` -- server/gateway base classes"
msgstr ":mod:`wsgiref.handlers` -- 서버/게이트웨이 베이스 클래스"

#: ../Doc/library/wsgiref.rst:449
msgid ""
"This module provides base handler classes for implementing WSGI servers "
"and gateways.  These base classes handle most of the work of "
"communicating with a WSGI application, as long as they are given a CGI-"
"like environment, along with input, output, and error streams."
msgstr ""
"이 모듈은 WSGI 서버와 게이트웨이를 구현하기 위한 베이스 처리기 클래스를 제공합니다. 이러한 베이스 클래스는 입력, 출력 및 "
"에러 스트림과 함께 CGI와 유사한 환경이 제공되는 한, WSGI 응용 프로그램과 통신하는 대부분 작업을 처리합니다."

#: ../Doc/library/wsgiref.rst:457
msgid ""
"CGI-based invocation via ``sys.stdin``, ``sys.stdout``, ``sys.stderr`` "
"and ``os.environ``.  This is useful when you have a WSGI application and "
"want to run it as a CGI script.  Simply invoke ``CGIHandler().run(app)``,"
" where ``app`` is the WSGI application object you wish to invoke."
msgstr ""
"``sys.stdin``, ``sys.stdout``, ``sys.stderr`` 및 ``os.environ``\\를 통한 CGI "
"기반 호출. 이것은 WSGI 응용 프로그램이 있고 CGI 스크립트로 실행하려고 할 때 유용합니다. "
"``CGIHandler().run(app)``\\을 호출하기만 하면 됩니다. 여기서 ``app``\\은 호출할 WSGI 응용 "
"프로그램 객체입니다."

#: ../Doc/library/wsgiref.rst:462
msgid ""
"This class is a subclass of :class:`BaseCGIHandler` that sets "
"``wsgi.run_once`` to true, ``wsgi.multithread`` to false, and "
"``wsgi.multiprocess`` to true, and always uses :mod:`sys` and :mod:`os` "
"to obtain the necessary CGI streams and environment."
msgstr ""
"이 클래스는 ``wsgi.run_once``\\를 참으로, ``wsgi.multithread``\\를 거짓으로, "
"``wsgi.multiprocess``\\를 참으로 설정하고, 필요한 CGI 스트림과 환경을 얻기 위해 항상 "
":mod:`sys`\\와 :mod:`os`\\를 사용하는 :class:`BaseCGIHandler`\\의 서브 클래스입니다."

#: ../Doc/library/wsgiref.rst:470
msgid ""
"A specialized alternative to :class:`CGIHandler`, for use when deploying "
"on Microsoft's IIS web server, without having set the config "
"allowPathInfo option (IIS>=7) or metabase allowPathInfoForScriptMappings "
"(IIS<7)."
msgstr ""
"config allowPathInfo 옵션 (IIS>=7) 나 metabase "
"allowPathInfoForScriptMappings (IIS<7)를 설정하지 않고도, Microsoft IIS 웹 서버에 배포할"
" 때 사용할 수 있는 :class:`CGIHandler`\\의 특수한 대안."

#: ../Doc/library/wsgiref.rst:474
msgid ""
"By default, IIS gives a ``PATH_INFO`` that duplicates the ``SCRIPT_NAME``"
" at the front, causing problems for WSGI applications that wish to "
"implement routing. This handler strips any such duplicated path."
msgstr ""
"기본적으로, IIS는 앞에 ``SCRIPT_NAME``\\이 중복된 ``PATH_INFO``\\를 제공하므로, 라우팅을 구현하려는 "
"WSGI 응용 프로그램에 문제가 발생합니다. 이 처리기는 중복된 경로를 제거합니다."

#: ../Doc/library/wsgiref.rst:478
msgid ""
"IIS can be configured to pass the correct ``PATH_INFO``, but this causes "
"another bug where ``PATH_TRANSLATED`` is wrong. Luckily this variable is "
"rarely used and is not guaranteed by WSGI. On IIS<7, though, the setting "
"can only be made on a vhost level, affecting all other script mappings, "
"many of which break when exposed to the ``PATH_TRANSLATED`` bug. For this"
" reason IIS<7 is almost never deployed with the fix. (Even IIS7 rarely "
"uses it because there is still no UI for it.)"
msgstr ""
"IIS가 올바른 ``PATH_INFO``\\를 전달하도록 구성할 수 있지만, ``PATH_TRANSLATED``\\가 잘못되는 다른"
" 버그가 발생합니다. 다행히도 이 변수는 거의 사용되지 않으며 WSGI에서 보장하지 않습니다. 그러나 IIS<7에서는 설정이 가상 "
"호스트 수준에서만 이루어지므로, 다른 모든 스크립트 매핑에 영향을 미치며, 그중 많은 것들이 ``PATH_TRANSLATED`` "
"버그에 노출되면 망가집니다. 이러한 이유로 IIS<7은 거의 수정해서 배포되지 않습니다. (아직도 UI가 없어서 IIS7 조차도 "
"거의 사용하지 않습니다.)"

#: ../Doc/library/wsgiref.rst:486
msgid ""
"There is no way for CGI code to tell whether the option was set, so a "
"separate handler class is provided.  It is used in the same way as "
":class:`CGIHandler`, i.e., by calling ``IISCGIHandler().run(app)``, where"
" ``app`` is the WSGI application object you wish to invoke."
msgstr ""
"CGI 코드가 옵션이 설정되었는지를 알 수 있는 방법이 없으므로, 별도의 처리기 클래스가 제공됩니다. "
":class:`CGIHandler`\\와 같은 방식으로 사용됩니다. 즉, ``IISCGIHandler().run(app)``\\을 "
"호출합니다. 여기서 ``app``\\은 호출할 WSGI 응용 프로그램 객체입니다."

#: ../Doc/library/wsgiref.rst:496
msgid ""
"Similar to :class:`CGIHandler`, but instead of using the :mod:`sys` and "
":mod:`os` modules, the CGI environment and I/O streams are specified "
"explicitly. The *multithread* and *multiprocess* values are used to set "
"the ``wsgi.multithread`` and ``wsgi.multiprocess`` flags for any "
"applications run by the handler instance."
msgstr ""
":class:`CGIHandler`\\와 유사하지만, :mod:`sys` 와 :mod:`os` 모듈을 사용하는 대신, CGI 환경과"
" I/O 스트림이 명시적으로 지정됩니다. *multithread* 와 *multiprocess* 값은 처리기 인스턴스가 실행하는 "
"모든 응용 프로그램에 대한 ``wsgi.multithread`` 와 ``wsgi.multiprocess`` 플래그를 설정하는 데 "
"사용됩니다."

#: ../Doc/library/wsgiref.rst:502
msgid ""
"This class is a subclass of :class:`SimpleHandler` intended for use with "
"software other than HTTP \"origin servers\".  If you are writing a "
"gateway protocol implementation (such as CGI, FastCGI, SCGI, etc.) that "
"uses a ``Status:`` header to send an HTTP status, you probably want to "
"subclass this instead of :class:`SimpleHandler`."
msgstr ""
"이 클래스는 HTTP \"오리진 서버\" 이외의 소프트웨어에서 사용하기 위한 :class:`SimpleHandler`\\의 서브 "
"클래스입니다. HTTP 상태를 보내기 위해 ``Status:`` 헤더를 사용하는 게이트웨이 프로토콜 구현(가령 CGI, "
"FastCGI, SCGI 등)을 작성하는 경우 :class:`SimpleHandler` 대신 이것을 서브클래싱하고 싶을 겁니다."

#: ../Doc/library/wsgiref.rst:511
msgid ""
"Similar to :class:`BaseCGIHandler`, but designed for use with HTTP origin"
" servers.  If you are writing an HTTP server implementation, you will "
"probably want to subclass this instead of :class:`BaseCGIHandler`."
msgstr ""
":class:`BaseCGIHandler`\\와 유사하지만, HTTP 오리진 서버에 사용하도록 설계되었습니다. HTTP 서버 구현을"
" 작성하는 경우 :class:`BaseCGIHandler` 대신 이것을 서브 클래싱하고 싶을 겁니다."

#: ../Doc/library/wsgiref.rst:515
msgid ""
"This class is a subclass of :class:`BaseHandler`.  It overrides the "
":meth:`__init__`, :meth:`get_stdin`, :meth:`get_stderr`, "
":meth:`add_cgi_vars`, :meth:`_write`, and :meth:`_flush` methods to "
"support explicitly setting the environment and streams via the "
"constructor.  The supplied environment and streams are stored in the "
":attr:`stdin`, :attr:`stdout`, :attr:`stderr`, and :attr:`environ` "
"attributes."
msgstr ""
"이 클래스는 :class:`BaseHandler`\\의 서브 클래스입니다. :meth:`__init__`, "
":meth:`get_stdin`, :meth:`get_stderr`, :meth:`add_cgi_vars`, "
":meth:`_write` 및 :meth:`_flush` 메서드를 재정의하여 명시적으로 환경과 스트림을 생성자를 통해 설정하는 것을"
" 지원합니다. 제공된 환경과 스트림은 :attr:`stdin`, :attr:`stdout`, :attr:`stderr` 및 "
":attr:`environ` 어트리뷰트에 저장됩니다."

#: ../Doc/library/wsgiref.rst:522
msgid ""
"The :meth:`~io.BufferedIOBase.write` method of *stdout* should write each"
" chunk in full, like :class:`io.BufferedIOBase`."
msgstr ""
"*stdout*\\의 :meth:`~io.BufferedIOBase.write` 메서드는 "
":class:`io.BufferedIOBase`\\처럼 각 덩어리 전체를 기록해야 합니다."

#: ../Doc/library/wsgiref.rst:528
msgid ""
"This is an abstract base class for running WSGI applications.  Each "
"instance will handle a single HTTP request, although in principle you "
"could create a subclass that was reusable for multiple requests."
msgstr ""
"이것은 WSGI 응용 프로그램을 실행하기 위한 추상 베이스 클래스입니다. 원칙적으로 여러 요청에 대해 재사용할 수 있는 서브 "
"클래스를 만들 수 있지만, 각 인스턴스는 단일 HTTP 요청을 처리합니다."

#: ../Doc/library/wsgiref.rst:532
msgid ""
":class:`BaseHandler` instances have only one method intended for external"
" use:"
msgstr ":class:`BaseHandler` 인스턴스에는 외부 사용을 위한 하나의 메서드 만 있습니다:"

#: ../Doc/library/wsgiref.rst:537
msgid "Run the specified WSGI application, *app*."
msgstr "지정된 WSGI 응용 프로그램인 *app*\\을 실행합니다."

#: ../Doc/library/wsgiref.rst:539
msgid ""
"All of the other :class:`BaseHandler` methods are invoked by this method "
"in the process of running the application, and thus exist primarily to "
"allow customizing the process."
msgstr ""
"다른 모든 :class:`BaseHandler` 메서드는 응용 프로그램을 실행하는 과정에서 이 메서드에 의해 호출되므로, 주로 "
"과정을 사용자 정의하기 위해 존재합니다."

#: ../Doc/library/wsgiref.rst:543
msgid "The following methods MUST be overridden in a subclass:"
msgstr "다음 메서드는 서브 클래스에서 반드시 재정의되어야 합니다:"

#: ../Doc/library/wsgiref.rst:548
msgid ""
"Buffer the bytes *data* for transmission to the client.  It's okay if "
"this method actually transmits the data; :class:`BaseHandler` just "
"separates write and flush operations for greater efficiency when the "
"underlying system actually has such a distinction."
msgstr ""
"클라이언트로의 전송을 위해 바이트열 *data*\\를 버퍼링합니다. 이 메서드가 실제로 데이터를 전송해도 상관없습니다; "
":class:`BaseHandler`\\는 쓰기와 플러시 연산을 분리하여 하부 시스템에 실제로 이러한 구분이 있을 때 효율성을 "
"높입니다."

#: ../Doc/library/wsgiref.rst:556
msgid ""
"Force buffered data to be transmitted to the client.  It's okay if this "
"method is a no-op (i.e., if :meth:`_write` actually sends the data)."
msgstr ""
"버퍼링 된 데이터를 클라이언트로 전송하도록 강제합니다. 이 메서드가 아무 일도 하지 않아도 상관없습니다 (즉, "
":meth:`_write`\\가 실제로 데이터를 보낸다면)."

#: ../Doc/library/wsgiref.rst:562
msgid ""
"Return an input stream object suitable for use as the ``wsgi.input`` of "
"the request currently being processed."
msgstr "현재 처리 중인 요청의 ``wsgi.input``\\으로 사용하기에 적합한 입력 스트림 객체를 반환합니다."

#: ../Doc/library/wsgiref.rst:568
msgid ""
"Return an output stream object suitable for use as the ``wsgi.errors`` of"
" the request currently being processed."
msgstr "현재 처리 중인 요청의 ``wsgi.errors``\\로 사용하기에 적합한 출력 스트림 객체를 반환합니다."

#: ../Doc/library/wsgiref.rst:574
msgid ""
"Insert CGI variables for the current request into the :attr:`environ` "
"attribute."
msgstr "현재 요청에 대한 CGI 변수를 :attr:`environ` 어트리뷰트에 삽입합니다."

#: ../Doc/library/wsgiref.rst:576
msgid ""
"Here are some other methods and attributes you may wish to override. This"
" list is only a summary, however, and does not include every method that "
"can be overridden.  You should consult the docstrings and source code for"
" additional information before attempting to create a customized "
":class:`BaseHandler` subclass."
msgstr ""
"재정의하고 싶을 수 있는 다른 메서드와 어트리뷰트는 다음과 같습니다. 그러나, 이 목록은 요약에 지나지 않고, 재정의할 수 있는 "
"모든 메서드가 포함되어 있지 않습니다. 사용자 정의된 :class:`BaseHandler` 서브 클래스를 작성하기 전에 독스트링과 "
"소스 코드를 참조하여 추가 정보를 얻어야 합니다."

#: ../Doc/library/wsgiref.rst:582
msgid "Attributes and methods for customizing the WSGI environment:"
msgstr "WSGI 환경을 사용자 정의하기 위한 어트리뷰트와 메서드:"

#: ../Doc/library/wsgiref.rst:587
msgid ""
"The value to be used for the ``wsgi.multithread`` environment variable.  "
"It defaults to true in :class:`BaseHandler`, but may have a different "
"default (or be set by the constructor) in the other subclasses."
msgstr ""
"``wsgi.multithread`` 환경 변수에 사용될 값. :class:`BaseHandler`\\에서는 기본값이 참이지만, "
"다른 서브 클래스는 다른 기본값을 가질 수 있습니다 (또는 생성자에 의해 설정될 수 있습니다)."

#: ../Doc/library/wsgiref.rst:594
msgid ""
"The value to be used for the ``wsgi.multiprocess`` environment variable."
"  It defaults to true in :class:`BaseHandler`, but may have a different "
"default (or be set by the constructor) in the other subclasses."
msgstr ""
"``wsgi.multiprocess`` 환경 변수에 사용될 값. :class:`BaseHandler`\\에서는 기본값이 참이지만, "
"다른 서브 클래스는 다른 기본값을 가질 수 있습니다 (또는 생성자에 의해 설정될 수 있습니다)."

#: ../Doc/library/wsgiref.rst:601
msgid ""
"The value to be used for the ``wsgi.run_once`` environment variable.  It "
"defaults to false in :class:`BaseHandler`, but :class:`CGIHandler` sets "
"it to true by default."
msgstr ""
"``wsgi.run_once`` 환경 변수에 사용될 값. :class:`BaseHandler`\\에서는 기본값이 거짓이지만, "
":class:`CGIHandler`\\는 기본적으로 참으로 설정합니다."

#: ../Doc/library/wsgiref.rst:608
msgid ""
"The default environment variables to be included in every request's WSGI "
"environment.  By default, this is a copy of ``os.environ`` at the time "
"that :mod:`wsgiref.handlers` was imported, but subclasses can either "
"create their own at the class or instance level.  Note that the "
"dictionary should be considered read-only, since the default value is "
"shared between multiple classes and instances."
msgstr ""
"모든 요청의 WSGI 환경에 포함될 기본 환경 변수. 기본적으로, :mod:`wsgiref.handlers`\\를 임포트 한 시점의"
" ``os.environ`` 사본이지만, 서브 클래스는 클래스나 인스턴스 수준에서 자체적으로 만들 수 있습니다. 기본값이 여러 "
"클래스와 인스턴스 간에 공유되므로, 딕셔너리는 읽기 전용으로 간주해야 합니다."

#: ../Doc/library/wsgiref.rst:618
msgid ""
"If the :attr:`origin_server` attribute is set, this attribute's value is "
"used to set the default ``SERVER_SOFTWARE`` WSGI environment variable, "
"and also to set a default ``Server:`` header in HTTP responses.  It is "
"ignored for handlers (such as :class:`BaseCGIHandler` and "
":class:`CGIHandler`) that are not HTTP origin servers."
msgstr ""
":attr:`origin_server` 어트리뷰트가 설정된 경우, 이 어트리뷰트의 값은 기본 ``SERVER_SOFTWARE`` "
"WSGI 환경 변수를 설정하는 데 사용되고, HTTP 응답의 기본 ``Server:`` 헤더를 설정하는 데도 사용됩니다. HTTP "
"오리진 서버가 아닌 처리기(가령 :class:`BaseCGIHandler` 와 :class:`CGIHandler`)에서는 "
"무시됩니다."

#: ../Doc/library/wsgiref.rst:624
msgid ""
"The term \"Python\" is replaced with implementation specific term like "
"\"CPython\", \"Jython\" etc."
msgstr "\"Python\"이라는 용어는 \"CPython\", \"Jython\" 등과 같은 구현 특정 용어로 대체됩니다."

#: ../Doc/library/wsgiref.rst:630
msgid ""
"Return the URL scheme being used for the current request.  The default "
"implementation uses the :func:`guess_scheme` function from "
":mod:`wsgiref.util` to guess whether the scheme should be \"http\" or "
"\"https\", based on the current request's :attr:`environ` variables."
msgstr ""
"현재의 요청에 사용되고 있는 URL 스킴을 반환합니다. 기본 구현은 :mod:`wsgiref.util`\\의 "
":func:`guess_scheme` 함수를 사용하여, 현재 요청의 :attr:`environ` 변수를 기반으로, 스킴이 "
"\"http\"와 \"https\" 중 어느 것인지 추측합니다."

#: ../Doc/library/wsgiref.rst:638
msgid ""
"Set the :attr:`environ` attribute to a fully-populated WSGI environment."
"  The default implementation uses all of the above methods and "
"attributes, plus the :meth:`get_stdin`, :meth:`get_stderr`, and "
":meth:`add_cgi_vars` methods and the :attr:`wsgi_file_wrapper` attribute."
"  It also inserts a ``SERVER_SOFTWARE`` key if not present, as long as "
"the :attr:`origin_server` attribute is a true value and the "
":attr:`server_software` attribute is set."
msgstr ""
":attr:`environ` 어트리뷰트를 완전히 채워진 WSGI 환경으로 설정합니다. 기본 구현에서는 위의 모든 메서드와 "
"어트리뷰트에 더해 :meth:`get_stdin`, :meth:`get_stderr` 및 :meth:`add_cgi_vars` "
"메서드와 :attr:`wsgi_file_wrapper` 어트리뷰트를 모두 사용합니다. :attr:`origin_server` "
"어트리뷰트가 참이고 :attr:`server_software` 어트리뷰트가 설정된 경우 ``SERVER_SOFTWARE`` 키가 "
"없으면 삽입합니다."

#: ../Doc/library/wsgiref.rst:645
msgid "Methods and attributes for customizing exception handling:"
msgstr "예외 처리를 사용자 정의하기 위한 메서드와 어트리뷰트:"

#: ../Doc/library/wsgiref.rst:650
msgid ""
"Log the *exc_info* tuple in the server log.  *exc_info* is a ``(type, "
"value, traceback)`` tuple.  The default implementation simply writes the "
"traceback to the request's ``wsgi.errors`` stream and flushes it.  "
"Subclasses can override this method to change the format or retarget the "
"output, mail the traceback to an administrator, or whatever other action "
"may be deemed suitable."
msgstr ""
"*exc_info* 튜플을 서버 로그에 기록합니다. *exc_info*\\는 ``(type, value, traceback)`` "
"튜플입니다. 기본 구현은 요청의 ``wsgi.errors`` 스트림에 트레이스백을 쓰고 플러시 합니다. 서브 클래스는 이 메서드를 "
"재정의해서, 형식을 변경하거나 출력의 대상을 바꾸거나, 관리자에게 트레이스백을 메일로 보내거나, 적절한 것으로 생각되는 다른 액션을"
" 수행할 수 있습니다."

#: ../Doc/library/wsgiref.rst:659
msgid ""
"The maximum number of frames to include in tracebacks output by the "
"default :meth:`log_exception` method.  If ``None``, all frames are "
"included."
msgstr ""
"기본 :meth:`log_exception` 메서드에 의해 출력되는 트레이스백에 포함하는 프레임의 최대 수. "
"``None``\\이면, 모든 프레임이 포함됩니다."

#: ../Doc/library/wsgiref.rst:665
msgid ""
"This method is a WSGI application to generate an error page for the user."
"  It is only invoked if an error occurs before headers are sent to the "
"client."
msgstr ""
"이 메서드는 사용자를 위한 에러 페이지를 생성하는 WSGI 응용 프로그램입니다. 헤더가 클라이언트에 전송되기 전에 오류가 발생할 "
"때만 호출됩니다."

#: ../Doc/library/wsgiref.rst:668
msgid ""
"This method can access the current error information using "
"``sys.exc_info()``, and should pass that information to *start_response* "
"when calling it (as described in the \"Error Handling\" section of "
":pep:`3333`)."
msgstr ""
"이 메서드는 ``sys.exc_info()``\\를 사용하여 현재 에러 정보에 액세스할 수 있으며, 호출할 때 해당 정보를 "
"*start_response*\\로 전달해야 합니다 (:pep:`3333`\\의 \"에러 처리\" 절에서 설명하듯이)."

#: ../Doc/library/wsgiref.rst:672
msgid ""
"The default implementation just uses the :attr:`error_status`, "
":attr:`error_headers`, and :attr:`error_body` attributes to generate an "
"output page.  Subclasses can override this to produce more dynamic error "
"output."
msgstr ""
"기본 구현은 :attr:`error_status`, :attr:`error_headers` 및 :attr:`error_body` "
"어트리뷰트를 사용하여 출력 페이지를 생성합니다. 서브 클래스는 이것을 재정의하여, 더욱 동적인 에러 출력을 생성할 수 있습니다."

#: ../Doc/library/wsgiref.rst:676
msgid ""
"Note, however, that it's not recommended from a security perspective to "
"spit out diagnostics to any old user; ideally, you should have to do "
"something special to enable diagnostic output, which is why the default "
"implementation doesn't include any."
msgstr ""
"그러나, 보안 관점에서 오래된 사용자에게는 진단을 내보내지 않는 것이 좋습니다; 이상적으로, 진단 출력을 활성화하기 위해서는 특별한"
" 것을 해야 합니다. 이것이 기본 구현이 아무것도 포함하지 않는 이유입니다."

#: ../Doc/library/wsgiref.rst:684
msgid ""
"The HTTP status used for error responses.  This should be a status string"
" as defined in :pep:`3333`; it defaults to a 500 code and message."
msgstr ""
"에러 응답에 사용되는 HTTP 상태. :pep:`3333`\\에 정의된 상태 문자열이어야 합니다; 기본값은 500 코드와 "
"메시지입니다."

#: ../Doc/library/wsgiref.rst:690
msgid ""
"The HTTP headers used for error responses.  This should be a list of WSGI"
" response headers (``(name, value)`` tuples), as described in "
":pep:`3333`.  The default list just sets the content type to "
"``text/plain``."
msgstr ""
"에러 응답에 사용되는 HTTP 헤더. 이것은 :pep:`3333`\\에서 설명하는 WSGI 응답 헤더 (``(name, "
"value)`` 튜플)의 리스트여야 합니다. 기본 리스트는 단지 콘텐츠 형식을 ``text/plain``\\으로 설정합니다."

#: ../Doc/library/wsgiref.rst:697
msgid ""
"The error response body.  This should be an HTTP response body "
"bytestring. It defaults to the plain text, \"A server error occurred.  "
"Please contact the administrator.\""
msgstr ""
"에러 응답 바디. 이것은 HTTP 응답 바디 바이트열이어야 합니다. 기본적으로 \"A server error occurred.  "
"Please contact the administrator.\" 라는 단순 텍스트입니다."

#: ../Doc/library/wsgiref.rst:701
msgid ""
"Methods and attributes for :pep:`3333`'s \"Optional Platform-Specific "
"File Handling\" feature:"
msgstr ":pep:`3333`\\의 \"선택적 플랫폼 특정 파일 처리\" 기능을 위한 메서드와 어트리뷰트:"

#: ../Doc/library/wsgiref.rst:707
msgid ""
"A ``wsgi.file_wrapper`` factory, or ``None``.  The default value of this "
"attribute is the :class:`wsgiref.util.FileWrapper` class."
msgstr ""
"``wsgi.file_wrapper`` 팩토리나 ``None``. 이 어트리뷰트의 기본값은 "
":class:`wsgiref.util.FileWrapper` 클래스입니다."

#: ../Doc/library/wsgiref.rst:713
msgid ""
"Override to implement platform-specific file transmission.  This method "
"is called only if the application's return value is an instance of the "
"class specified by the :attr:`wsgi_file_wrapper` attribute.  It should "
"return a true value if it was able to successfully transmit the file, so "
"that the default transmission code will not be executed. The default "
"implementation of this method just returns a false value."
msgstr ""
"플랫폼 특정 파일 전송을 구현하기 위해 재정의합니다. 이 메서드는 응용 프로그램의 반환 값이 "
":attr:`wsgi_file_wrapper` 어트리뷰트로 지정된 클래스의 인스턴스일 때만 호출됩니다. 파일을 성공적으로 전송할 수"
" 있었으면 참값을 반환해야 합니다. 그러면 기본 전송 코드가 실행되지 않습니다. 이 메서드의 기본 구현은 단지 거짓 값을 "
"반환합니다."

#: ../Doc/library/wsgiref.rst:720
msgid "Miscellaneous methods and attributes:"
msgstr "기타 메서드와 어트리뷰트:"

#: ../Doc/library/wsgiref.rst:725
msgid ""
"This attribute should be set to a true value if the handler's "
":meth:`_write` and :meth:`_flush` are being used to communicate directly "
"to the client, rather than via a CGI-like gateway protocol that wants the"
" HTTP status in a special ``Status:`` header."
msgstr ""
"특별한 ``Status:`` 헤더를 통해 HTTP 상태를 원하는 CGI와 같은 게이트웨이 프로토콜을 통하는 것이 아니라, 처리기의 "
":meth:`_write`\\와 :meth:`_flush`\\가 클라이언트와 직접 통신하는 데 사용되는 경우 이 어트리뷰트를 참으로"
" 설정해야 합니다."

#: ../Doc/library/wsgiref.rst:730
msgid ""
"This attribute's default value is true in :class:`BaseHandler`, but false"
" in :class:`BaseCGIHandler` and :class:`CGIHandler`."
msgstr ""
":class:`BaseHandler`\\에서는 이 어트리뷰트의 기본값이 참이지만, :class:`BaseCGIHandler`\\와 "
":class:`CGIHandler`\\에서는 거짓입니다."

#: ../Doc/library/wsgiref.rst:736
msgid ""
"If :attr:`origin_server` is true, this string attribute is used to set "
"the HTTP version of the response set to the client.  It defaults to "
"``\"1.0\"``."
msgstr ""
":attr:`origin_server`\\가 참이면, 이 문자열 어트리뷰트를 사용하여 클라이언트로 보내는 응답 집합의 HTTP "
"버전을 설정합니다. 기본값은 ``\"1.0\"``\\입니다."

#: ../Doc/library/wsgiref.rst:742
#, fuzzy
msgid ""
"Transcode CGI variables from ``os.environ`` to :pep:`3333` \"bytes in "
"unicode\" strings, returning a new dictionary.  This function is used by "
":class:`CGIHandler` and :class:`IISCGIHandler` in place of directly using"
" ``os.environ``, which is not necessarily WSGI-compliant on all platforms"
" and web servers using Python 3 -- specifically, ones where the OS's "
"actual environment is Unicode (i.e. Windows), or ones where the "
"environment is bytes, but the system encoding used by Python to decode it"
" is anything other than ISO-8859-1 (e.g. Unix systems using UTF-8)."
msgstr ""
"CGI 변수를 ``os.environ``\\에서 PEP 3333 \"유니코드에 들어있는 바이트열\" 문자열로 변환하여, 새 "
"딕셔너리를 반환합니다. 이 함수는 ``os.environ``\\을 직접 사용하는 대신 :class:`CGIHandler`\\와 "
":class:`IISCGIHandler`\\에서 사용됩니다. ``os.environ``\\은 파이썬 3을 사용하는 모든 플랫폼과 웹"
" 서버에서 WSGI를 준수한다는 보장이 없습니다 -- 구체적으로, OS의 실제 환경이 유니코드인 곳(가령 윈도우)이나 환경은 "
"바이트열이지만 파이썬이 디코딩하기 위해 사용하는 시스템 인코딩이 ISO-8859-1 이외의 것인 곳(예를 들어 UTF-8을 사용하는"
" 유닉스 시스템)."

#: ../Doc/library/wsgiref.rst:751
msgid ""
"If you are implementing a CGI-based handler of your own, you probably "
"want to use this routine instead of just copying values out of "
"``os.environ`` directly."
msgstr ""
"여러분 자신의 CGI 기반 처리기를 구현한다면, ``os.environ``\\에서 직접 값을 복사하는 대신 이 루틴을 사용하는 것이"
" 좋습니다."

#: ../Doc/library/wsgiref.rst:759
msgid "Examples"
msgstr "예제"

#: ../Doc/library/wsgiref.rst:761
msgid "This is a working \"Hello World\" WSGI application::"
msgstr "이것은 \"Hello World\" WSGI 응용 프로그램입니다::"

#: ../Doc/library/wsgiref.rst:786
msgid ""
"Example of a WSGI application serving the current directory, accept "
"optional directory and port number (default: 8000) on the command line:"
msgstr ""

