# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/chunk.rst:2
msgid ":mod:`chunk` --- Read IFF chunked data"
msgstr ":mod:`chunk` --- IFF 청크된 데이터 읽기"

#: ../Doc/library/chunk.rst:10
msgid "**Source code:** :source:`Lib/chunk.py`"
msgstr "**소스 코드:** :source:`Lib/chunk.py`"

#: ../Doc/library/chunk.rst:21
msgid ""
"This module provides an interface for reading files that use EA IFF 85 "
"chunks. [#]_  This format is used in at least the Audio Interchange File "
"Format (AIFF/AIFF-C) and the Real Media File Format (RMFF).  The WAVE "
"audio file format is closely related and can also be read using this "
"module."
msgstr ""
"이 모듈은 EA IFF 85 청크를 사용하는 파일을 읽기 위한 인터페이스를 제공합니다. [#]_ 이 형식은 적어도 AIFF/AIFF-C "
"(Audio Interchange File Format) 와 RMFF (Real Media File Format)에서 사용됩니다. "
"WAVE 오디오 파일 형식은 밀접하게 관련되어 있으며 이 모듈을 사용하여 읽을 수도 있습니다."

#: ../Doc/library/chunk.rst:26
msgid "A chunk has the following structure:"
msgstr "청크의 구조는 다음과 같습니다:"

#: ../Doc/library/chunk.rst:29
msgid "Offset"
msgstr "오프셋"

#: ../Doc/library/chunk.rst:29
msgid "Length"
msgstr "길이"

#: ../Doc/library/chunk.rst:29
msgid "Contents"
msgstr "내용"

#: ../Doc/library/chunk.rst:31
msgid "0"
msgstr "0"

#: ../Doc/library/chunk.rst:31 ../Doc/library/chunk.rst:33
msgid "4"
msgstr "4"

#: ../Doc/library/chunk.rst:31
msgid "Chunk ID"
msgstr "청크 ID"

#: ../Doc/library/chunk.rst:33
msgid "Size of chunk in big-endian byte order, not including the header"
msgstr "빅 엔디안 바이트 순서로 청크의 크기. 헤더는 포함하지 않습니다."

#: ../Doc/library/chunk.rst:37
msgid "8"
msgstr "8"

#: ../Doc/library/chunk.rst:37
msgid "*n*"
msgstr "*n*"

#: ../Doc/library/chunk.rst:37
msgid "Data bytes, where *n* is the size given in the preceding field"
msgstr "데이터 바이트. 여기서 *n*\\은 앞 필드에서 주어진 크기입니다."

#: ../Doc/library/chunk.rst:41
msgid "8 + *n*"
msgstr "8 + *n*"

#: ../Doc/library/chunk.rst:41
msgid "0 or 1"
msgstr "0 또는 1"

#: ../Doc/library/chunk.rst:41
msgid "Pad byte needed if *n* is odd and chunk alignment is used"
msgstr "*n*\\가 홀수이고 청크 정렬이 사용된 경우 필요한 패드 바이트"

#: ../Doc/library/chunk.rst:45
msgid "The ID is a 4-byte string which identifies the type of chunk."
msgstr "ID는 청크의 유형을 식별하는 4바이트 문자열입니다."

#: ../Doc/library/chunk.rst:47
msgid ""
"The size field (a 32-bit value, encoded using big-endian byte order) "
"gives the size of the chunk data, not including the 8-byte header."
msgstr ""
"크기 필드(빅 엔디안 바이트 순서를 사용하여 인코딩된 32비트 값)는 청크 데이터의 크기를 제공하며, 8바이트 헤더는 포함하지 않습니다."

#: ../Doc/library/chunk.rst:50
msgid ""
"Usually an IFF-type file consists of one or more chunks.  The proposed "
"usage of the :class:`Chunk` class defined here is to instantiate an "
"instance at the start of each chunk and read from the instance until it "
"reaches the end, after which a new instance can be instantiated. At the "
"end of the file, creating a new instance will fail with an "
":exc:`EOFError` exception."
msgstr ""
"일반적으로 IFF 형식의 파일은 하나 이상의 청크로 구성됩니다. 여기에 정의된 :class:`Chunk` 클래스의 제안 된 사용법은 각 "
"청크의 시작 부분에서 인스턴스를 만들고 끝까지 도달할 때까지 인스턴스에서 읽는 것입니다. 그다음에 새 인스턴스를 만들 수 있습니다. "
"파일의 끝에서, 새 인스턴스를 만드는 것은 :exc:`EOFError` 예외로 실패합니다."

#: ../Doc/library/chunk.rst:59
msgid ""
"Class which represents a chunk.  The *file* argument is expected to be a "
"file-like object.  An instance of this class is specifically allowed.  "
"The only method that is needed is :meth:`~io.IOBase.read`.  If the "
"methods :meth:`~io.IOBase.seek` and :meth:`~io.IOBase.tell` are present "
"and don't raise an exception, they are also used. If these methods are "
"present and raise an exception, they are expected to not have altered the"
" object.  If the optional argument *align* is true, chunks are assumed to"
" be aligned on 2-byte boundaries.  If *align* is false, no alignment is "
"assumed.  The default value is true.  If the optional argument "
"*bigendian* is false, the chunk size is assumed to be in little-endian "
"order. This is needed for WAVE audio files. The default value is true.  "
"If the optional argument *inclheader* is true, the size given in the "
"chunk header includes the size of the header.  The default value is "
"false."
msgstr ""
"청크를 나타내는 클래스. *file* 인자는 파일류 객체를 기대합니다. 이 클래스의 인스턴스가 특별히 허용됩니다. 필요한 유일한 메서드는"
" :meth:`~io.IOBase.read`\\입니다. :meth:`~io.IOBase.seek` 와 "
":meth:`~io.IOBase.tell` 메서드가 있고 예외를 발생시키지 않으면 이것들도 사용됩니다. 이러한 메서드가 존재하고, 예외가"
" 발생하면, 객체가 변경되지 않았을 것으로 기대합니다. 선택적 인자 *align*\\이 참이면, 청크는 2바이트 경계에서 정렬되는 것으로"
" 가정합니다. *align*\\이 거짓이면 정렬을 가정하지 않습니다. 기본값은 참입니다. 선택적 인자 *bigendian*\\이 거짓이면"
" 청크 크기는 리틀 엔디안 순서로 간주합니다. 이것은 WAVE 오디오 파일에 필요합니다. 기본값은 참입니다. 선택적 인자 "
"*inclheader*\\가 참이면, 청크 헤더에 주어진 크기는 헤더의 크기를 포함합니다. 기본값은 거짓입니다."

#: ../Doc/library/chunk.rst:73
msgid "A :class:`Chunk` object supports the following methods:"
msgstr ":class:`Chunk` 객체는 다음 메서드를 지원합니다:"

#: ../Doc/library/chunk.rst:78
msgid ""
"Returns the name (ID) of the chunk.  This is the first 4 bytes of the "
"chunk."
msgstr "청크의 이름(ID)을 돌려줍니다. 이것은 청크의 처음 4바이트입니다."

#: ../Doc/library/chunk.rst:84
msgid "Returns the size of the chunk."
msgstr "청크의 크기를 돌려줍니다."

#: ../Doc/library/chunk.rst:89
msgid ""
"Close and skip to the end of the chunk.  This does not close the "
"underlying file."
msgstr "닫고 청크의 끝으로 건너뜁니다. 하부 파일을 닫지 않습니다."

#: ../Doc/library/chunk.rst:92
msgid ""
"The remaining methods will raise :exc:`OSError` if called after the "
":meth:`close` method has been called.  Before Python 3.3, they used to "
"raise :exc:`IOError`, now an alias of :exc:`OSError`."
msgstr ""
"나머지 메서드는 :meth:`close` 메서드가 호출된 후에 호출되면 :exc:`OSError`\\를 발생시킵니다. 파이썬 3.3 "
"이전에는 :exc:`IOError`\\를 발생시켰습니다. 이제는 :exc:`OSError`\\의 별칭입니다."

#: ../Doc/library/chunk.rst:99
msgid "Returns ``False``."
msgstr "``False``\\를 반환합니다."

#: ../Doc/library/chunk.rst:104
msgid ""
"Set the chunk's current position.  The *whence* argument is optional and "
"defaults to ``0`` (absolute file positioning); other values are ``1`` "
"(seek relative to the current position) and ``2`` (seek relative to the "
"file's end).  There is no return value. If the underlying file does not "
"allow seek, only forward seeks are allowed."
msgstr ""
"청크의 현재 위치를 설정합니다. *whence* 인자는 선택 사항이며 기본값은 ``0``\\(절대 파일 위치 지정)입니다; 다른 값은 "
"``1``\\(현재 위치에 상대적인 탐색)과 ``2``\\(파일의 끝에 상대적인 탐색)입니다. 반환 값이 없습니다. 하부 파일이 탐색을 "
"허용하지 않으면, 정방향 탐색만 허용됩니다."

#: ../Doc/library/chunk.rst:113
msgid "Return the current position into the chunk."
msgstr "청크의 현재 위치를 반환합니다."

#: ../Doc/library/chunk.rst:118
msgid ""
"Read at most *size* bytes from the chunk (less if the read hits the end "
"of the chunk before obtaining *size* bytes).  If the *size* argument is "
"negative or omitted, read all data until the end of the chunk.  An empty "
"bytes object is returned when the end of the chunk is encountered "
"immediately."
msgstr ""
"청크에서 최대 *size* 바이트를 읽습니다 (*size* 바이트를 얻기 전에 read가 청크 끝에 도달하면 덜 읽을 수 있습니다). "
"*size* 인자가 음수이거나 생략되면, 청크의 끝까지 모든 데이터를 읽습니다. 청크의 끝이 즉시 발견되면 빈 바이트열 객체가 "
"반환됩니다."

#: ../Doc/library/chunk.rst:127
msgid ""
"Skip to the end of the chunk.  All further calls to :meth:`read` for the "
"chunk will return ``b''``.  If you are not interested in the contents of "
"the chunk, this method should be called so that the file points to the "
"start of the next chunk."
msgstr ""
"청크의 끝으로 건너뜁니다. 청크에 대한 모든 추가 :meth:`read` 호출은 ``b''``\\를 반환합니다. 청크의 내용에 관심이 "
"없으면, 파일이 다음 청크의 시작을 가리키도록 이 메서드를 호출해야 합니다."

#: ../Doc/library/chunk.rst:134
msgid "Footnotes"
msgstr "각주"

#: ../Doc/library/chunk.rst:135
msgid ""
"\"EA IFF 85\" Standard for Interchange Format Files, Jerry Morrison, "
"Electronic Arts, January 1985."
msgstr ""
"\"EA IFF 85\" Standard for Interchange Format Files, Jerry Morrison, "
"Electronic Arts, 1985년 1월."
