# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-30 09:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/multiprocessing.rst:2
msgid ":mod:`multiprocessing` --- Process-based parallelism"
msgstr ":mod:`multiprocessing` --- 프로세스 기반 병렬 처리"

#: ../Doc/library/multiprocessing.rst:7
msgid "**Source code:** :source:`Lib/multiprocessing/`"
msgstr "**소스 코드:** :source:`Lib/multiprocessing/`"

#: ../Doc/library/multiprocessing.rst:12
msgid "Introduction"
msgstr "소개"

#: ../Doc/library/multiprocessing.rst:14
msgid ""
":mod:`multiprocessing` is a package that supports spawning processes "
"using an API similar to the :mod:`threading` module.  The "
":mod:`multiprocessing` package offers both local and remote concurrency, "
"effectively side-stepping the :term:`Global Interpreter Lock` by using "
"subprocesses instead of threads.  Due to this, the :mod:`multiprocessing`"
" module allows the programmer to fully leverage multiple processors on a "
"given machine.  It runs on both Unix and Windows."
msgstr ""
":mod:`multiprocessing` 은 :mod:`threading` 모듈과 유사한 API를 사용하여 프로세스 "
"스포닝(spawning)을 지원하는 패키지입니다. :mod:`multiprocessing` 패키지는 지역과 원격 동시성을 모두 제공하며 "
"스레드 대신 서브 프로세스를 사용하여 :term:`전역 인터프리터 록 <Global Interpreter Lock>` 을 효과적으로 "
"피합니다. 이것 때문에, :mod:`multiprocessing` 모듈은 프로그래머가 주어진 기계에서 다중 프로세서를 최대한 활용할 수 "
"있게 합니다. 유닉스와 윈도우에서 모두 실행됩니다."

#: ../Doc/library/multiprocessing.rst:22
msgid ""
"The :mod:`multiprocessing` module also introduces APIs which do not have "
"analogs in the :mod:`threading` module.  A prime example of this is the "
":class:`~multiprocessing.pool.Pool` object which offers a convenient "
"means of parallelizing the execution of a function across multiple input "
"values, distributing the input data across processes (data parallelism)."
"  The following example demonstrates the common practice of defining such"
" functions in a module so that child processes can successfully import "
"that module.  This basic example of data parallelism using "
":class:`~multiprocessing.pool.Pool`, ::"
msgstr ""
":mod:`multiprocessing` 모듈은 :mod:`threading` 모듈에 대응 물이 없는 API도 제공합니다. 이것의 "
"대표적인 예가 :class:`~multiprocessing.pool.Pool` 객체입니다. 이 객체는 여러 입력 값에 걸쳐 함수의 실행을"
" 병렬 처리하고 입력 데이터를 프로세스에 분산시키는 편리한 방법을 제공합니다(데이터 병렬 처리). 다음 예제는 자식 프로세스가 해당 "
"모듈을 성공적으로 임포트 할 수 있도록, 모듈에서 이러한 함수를 정의하는 일반적인 방법을 보여줍니다. 다음은 "
":class:`~multiprocessing.pool.Pool` 를 사용하는 데이터 병렬 처리의 기본 예제입니다::"

#: ../Doc/library/multiprocessing.rst:40
msgid "will print to standard output ::"
msgstr "표준 출력으로 다음과 같은 것을 인쇄합니다 ::"

#: ../Doc/library/multiprocessing.rst:46
msgid "The :class:`Process` class"
msgstr ":class:`Process` 클래스"

#: ../Doc/library/multiprocessing.rst:48
msgid ""
"In :mod:`multiprocessing`, processes are spawned by creating a "
":class:`Process` object and then calling its :meth:`~Process.start` "
"method.  :class:`Process` follows the API of :class:`threading.Thread`.  "
"A trivial example of a multiprocess program is ::"
msgstr ""
":mod:`multiprocessing`\\에서, 프로세스는 :class:`Process` 객체를 생성한 후 "
":meth:`~Process.start` 메서드를 호출해서 스폰합니다. :class:`Process` 는 "
":class:`threading.Thread` 의 API를 따릅니다. 다중 프로세스 프로그램의 간단한 예는 다음과 같습니다 ::"

#: ../Doc/library/multiprocessing.rst:63
msgid "To show the individual process IDs involved, here is an expanded example::"
msgstr "이 과정에 참여하는 개별 프로세스의 ID를 보기 위해, 이렇게 예제를 확장합니다::"

#: ../Doc/library/multiprocessing.rst:84
msgid ""
"For an explanation of why the ``if __name__ == '__main__'`` part is "
"necessary, see :ref:`multiprocessing-programming`."
msgstr ""
"``if __name__ == '__main__'`` 부분이 필요한 이유에 대한 설명은 :ref:`multiprocessing-"
"programming`\\을 보십시오."

#: ../Doc/library/multiprocessing.rst:90
msgid "Contexts and start methods"
msgstr "컨텍스트 및 시작 방법"

#: ../Doc/library/multiprocessing.rst:94
msgid ""
"Depending on the platform, :mod:`multiprocessing` supports three ways to "
"start a process.  These *start methods* are"
msgstr ""
"플랫폼에 따라, :mod:`multiprocessing`\\은 프로세스를 시작하는 세 가지 방법을 지원합니다. 이러한 *시작 방법* 은"

#: ../Doc/library/multiprocessing.rst:105
msgid "*spawn*"
msgstr "*spawn*"

#: ../Doc/library/multiprocessing.rst:98
msgid ""
"The parent process starts a fresh python interpreter process.  The child "
"process will only inherit those resources necessary to run the process "
"objects :meth:`~Process.run` method.  In particular, unnecessary file "
"descriptors and handles from the parent process will not be inherited.  "
"Starting a process using this method is rather slow compared to using "
"*fork* or *forkserver*."
msgstr ""
"부모 프로세스는 깨끗한 새 파이썬 인터프리터 프로세스를 시작합니다. 자식 프로세스는 프로세스 객체의 :meth:`~Process.run`"
" 메서드를 실행하는데 필요한 자원만 상속받습니다. 특히, 부모 프로세스의 불필요한 파일 기술자와 핸들은 상속되지 않습니다. 이 방법을 "
"사용하여 프로세스를 시작하는 것은 *fork* 나 *forkserver* 를 사용하는 것에 비해 다소 느립니다."

#: ../Doc/library/multiprocessing.rst:105
msgid "Available on Unix and Windows.  The default on Windows."
msgstr "유닉스 및 윈도우에서 사용 가능합니다. 윈도우의 기본값."

#: ../Doc/library/multiprocessing.rst:114
msgid "*fork*"
msgstr "*fork*"

#: ../Doc/library/multiprocessing.rst:108
msgid ""
"The parent process uses :func:`os.fork` to fork the Python interpreter.  "
"The child process, when it begins, is effectively identical to the parent"
" process.  All resources of the parent are inherited by the child "
"process.  Note that safely forking a multithreaded process is "
"problematic."
msgstr ""
"부모 프로세스는 :func:`os.fork` 를 사용하여 파이썬 인터프리터를 포크 합니다. 자식 프로세스는, 시작될 때, 부모 프로세스와"
" 실질적으로 같습니다. 부모의 모든 자원이 자식 프로세스에 의해 상속됩니다. 다중 스레드 프로세스를 안전하게 포크 하기 어렵다는 점에 "
"주의하십시오."

#: ../Doc/library/multiprocessing.rst:114
msgid "Available on Unix only.  The default on Unix."
msgstr "유닉스에서만 사용 가능합니다. 유닉스의 기본값."

#: ../Doc/library/multiprocessing.rst:125
msgid "*forkserver*"
msgstr "*forkserver*"

#: ../Doc/library/multiprocessing.rst:117
msgid ""
"When the program starts and selects the *forkserver* start method, a "
"server process is started.  From then on, whenever a new process is "
"needed, the parent process connects to the server and requests that it "
"fork a new process.  The fork server process is single threaded so it is "
"safe for it to use :func:`os.fork`.  No unnecessary resources are "
"inherited."
msgstr ""
"프로그램이 시작되고 *forkserver* 시작 방법을 선택하면, 서버 프로세스가 시작됩니다. 그 이후부터, 새로운 프로세스가 필요할 "
"때마다, 부모 프로세스는 서버에 연결하여 새로운 프로세스를 포크 하도록 요청합니다. 포크 서버 프로세스는 단일 스레드이므로 "
":func:`os.fork` 를 사용하는 것이 안전합니다. 불필요한 자원은 상속되지 않습니다."

#: ../Doc/library/multiprocessing.rst:124
msgid ""
"Available on Unix platforms which support passing file descriptors over "
"Unix pipes."
msgstr "유닉스 파이프를 통해 파일 기술자를 전달할 수 있는 유닉스 플랫폼에서 사용할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:127
msgid ""
"*spawn* added on all unix platforms, and *forkserver* added for some unix"
" platforms. Child processes no longer inherit all of the parents "
"inheritable handles on Windows."
msgstr ""
"모든 유닉스 플랫폼에 *spawn* 이 추가되었고, 일부 유닉스 플랫폼에는 *forkserver* 가 추가되었습니다. 윈도우에서 자식 "
"프로세스는 상속 가능한 모든 부모 핸들을 더는 상속하지 않습니다."

#: ../Doc/library/multiprocessing.rst:133
msgid ""
"On Unix using the *spawn* or *forkserver* start methods will also start a"
" *semaphore tracker* process which tracks the unlinked named semaphores "
"created by processes of the program.  When all processes have exited the "
"semaphore tracker unlinks any remaining semaphores. Usually there should "
"be none, but if a process was killed by a signal there may be some "
"\"leaked\" semaphores.  (Unlinking the named semaphores is a serious "
"matter since the system allows only a limited number, and they will not "
"be automatically unlinked until the next reboot.)"
msgstr ""
"유닉스에서 *spawn* 또는 *forkserver* 시작 방법을 사용하면 *세마포어 추적기* 프로세스 역시 시작되는데, 프로그램의 "
"프로세스들이 만든 삭제되지 않은 이름있는 세마포어를 추적합니다. 모든 프로세스가 종료된 후 세마포어 추적기는 남아있는 세마포어를 "
"제거합니다. 일반적으로 아무것도 남아 있지 않아야 하지만, 프로세스가 시그널에 의해 죽으면 \"누수된\" 세마포어가 있을 수 있습니다. "
"(이름있는 세마포어의 제거는 심각한 문제인데, 시스템이 제한된 수만 허용하고 다음 재부팅 때까지 자동으로 제거되지 않기 때문입니다.)"

#: ../Doc/library/multiprocessing.rst:142
msgid ""
"To select a start method you use the :func:`set_start_method` in the ``if"
" __name__ == '__main__'`` clause of the main module.  For example::"
msgstr ""
"시작 방법을 선택하려면 메인 모듈의 ``if __name__ == '__main__'`` 절에서 "
":func:`set_start_method`\\를 사용하십시오. 예를 들면::"

#: ../Doc/library/multiprocessing.rst:159
msgid ":func:`set_start_method` should not be used more than once in the program."
msgstr ":func:`set_start_method` 는 프로그램에서 한 번만 사용되어야 합니다."

#: ../Doc/library/multiprocessing.rst:162
msgid ""
"Alternatively, you can use :func:`get_context` to obtain a context "
"object.  Context objects have the same API as the multiprocessing module,"
" and allow one to use multiple start methods in the same program. ::"
msgstr ""
"또는, :func:`get_context`\\를 사용하여 컨텍스트 객체를 얻을 수 있습니다. 컨텍스트 객체는 multiprocessing"
" 모듈과 같은 API를 제공하므로 한 프로그램에서 여러 시작 방법을 사용할 수 있습니다. ::"

#: ../Doc/library/multiprocessing.rst:180
msgid ""
"Note that objects related to one context may not be compatible with "
"processes for a different context.  In particular, locks created using "
"the *fork* context cannot be passed to processes started using the "
"*spawn* or *forkserver* start methods."
msgstr ""
"한 컨텍스트와 관련된 객체는 다른 컨텍스트의 프로세스와 호환되지 않을 수 있음에 주의하십시오. 특히 *fork* 컨텍스트를 사용하여 "
"생성된 록은 *spawn* 또는 *forkserver* 시작 방법을 사용하여 시작된 프로세스로 전달될 수 없습니다."

#: ../Doc/library/multiprocessing.rst:185
msgid ""
"A library which wants to use a particular start method should probably "
"use :func:`get_context` to avoid interfering with the choice of the "
"library user."
msgstr ""
"특정 시작 방법을 사용하고자 하는 라이브러리는 아마도 :func:`get_context`\\를 사용하여 라이브러리 사용자의 선택을 "
"방해하지 않아야 합니다."

#: ../Doc/library/multiprocessing.rst:191
msgid "Exchanging objects between processes"
msgstr "프로세스 간 객체 교환"

#: ../Doc/library/multiprocessing.rst:193
msgid ""
":mod:`multiprocessing` supports two types of communication channel "
"between processes:"
msgstr ":mod:`multiprocessing` 은 두 가지 유형의 프로세스 간 통신 채널을 지원합니다:"

#: ../Doc/library/multiprocessing.rst:196
msgid "**Queues**"
msgstr "**큐**"

#: ../Doc/library/multiprocessing.rst:198
msgid ""
"The :class:`Queue` class is a near clone of :class:`queue.Queue`.  For "
"example::"
msgstr ":class:`Queue` 클래스는 :class:`queue.Queue` 의 클론에 가깝습니다. 예를 들면::"

#: ../Doc/library/multiprocessing.rst:213
msgid "Queues are thread and process safe."
msgstr "큐는 스레드와 프로세스에 안전합니다."

#: ../Doc/library/multiprocessing.rst:215
msgid "**Pipes**"
msgstr "**파이프**"

#: ../Doc/library/multiprocessing.rst:217
msgid ""
"The :func:`Pipe` function returns a pair of connection objects connected "
"by a pipe which by default is duplex (two-way).  For example::"
msgstr ""
":func:`Pipe` 함수는 파이프로 연결된 한 쌍의 연결 객체를 돌려주는데 기본적으로 양방향(duplex)입니다. 예를 들면::"

#: ../Doc/library/multiprocessing.rst:233
msgid ""
"The two connection objects returned by :func:`Pipe` represent the two "
"ends of the pipe.  Each connection object has :meth:`~Connection.send` "
"and :meth:`~Connection.recv` methods (among others).  Note that data in a"
" pipe may become corrupted if two processes (or threads) try to read from"
" or write to the *same* end of the pipe at the same time.  Of course "
"there is no risk of corruption from processes using different ends of the"
" pipe at the same time."
msgstr ""
":func:`Pipe` 가 반환하는 두 개의 연결 객체는 파이프의 두 끝을 나타냅니다. 각 연결 객체에는 (다른 것도 있지만) "
":meth:`~Connection.send` 및 :meth:`~Connection.recv` 메서드가 있습니다. 두 프로세스 (또는 "
"스레드)가 파이프의 *같은* 끝에서 동시에 읽거나 쓰려고 하면 파이프의 데이터가 손상될 수 있습니다. 물론 파이프의 다른 끝을 동시에 "
"사용하는 프로세스로 인해 손상될 위험은 없습니다."

#: ../Doc/library/multiprocessing.rst:243
msgid "Synchronization between processes"
msgstr "프로세스 간 동기화"

#: ../Doc/library/multiprocessing.rst:245
msgid ""
":mod:`multiprocessing` contains equivalents of all the synchronization "
"primitives from :mod:`threading`.  For instance one can use a lock to "
"ensure that only one process prints to standard output at a time::"
msgstr ""
":mod:`multiprocessing` 은 :mod:`threading` 에 있는 모든 동기화 프리미티브의 등가물을 포함합니다. 예를 "
"들어 한 번에 하나의 프로세스만 표준 출력으로 인쇄하도록 록을 사용할 수 있습니다::"

#: ../Doc/library/multiprocessing.rst:264
msgid ""
"Without using the lock output from the different processes is liable to "
"get all mixed up."
msgstr "록을 사용하지 않으면 다른 프로세스의 출력들이 모두 섞일 수 있습니다."

#: ../Doc/library/multiprocessing.rst:269
msgid "Sharing state between processes"
msgstr "프로세스 간 상태 공유"

#: ../Doc/library/multiprocessing.rst:271
msgid ""
"As mentioned above, when doing concurrent programming it is usually best "
"to avoid using shared state as far as possible.  This is particularly "
"true when using multiple processes."
msgstr ""
"위에서 언급했듯이, 동시성 프로그래밍을 할 때 보통 가능한 한 공유된 상태를 사용하지 않는 것이 최선입니다. 여러 프로세스를 사용할 때 "
"특히 그렇습니다."

#: ../Doc/library/multiprocessing.rst:275
msgid ""
"However, if you really do need to use some shared data then "
":mod:`multiprocessing` provides a couple of ways of doing so."
msgstr "그러나, 정말로 공유 데이터를 사용해야 한다면 :mod:`multiprocessing` 이 몇 가지 방법을 제공합니다."

#: ../Doc/library/multiprocessing.rst:278
msgid "**Shared memory**"
msgstr "**공유 메모리**"

#: ../Doc/library/multiprocessing.rst:280
msgid ""
"Data can be stored in a shared memory map using :class:`Value` or "
":class:`Array`.  For example, the following code ::"
msgstr ""
"데이터는 :class:`Value` 또는 :class:`Array`\\를 사용하여 공유 메모리 맵에 저장 될 수 있습니다. 예를 들어, "
"다음 코드는 ::"

#: ../Doc/library/multiprocessing.rst:301
#: ../Doc/library/multiprocessing.rst:347
msgid "will print ::"
msgstr "를 인쇄할 것입니다 ::"

#: ../Doc/library/multiprocessing.rst:306
msgid ""
"The ``'d'`` and ``'i'`` arguments used when creating ``num`` and ``arr`` "
"are typecodes of the kind used by the :mod:`array` module: ``'d'`` "
"indicates a double precision float and ``'i'`` indicates a signed "
"integer.  These shared objects will be process and thread-safe."
msgstr ""
"``num`` 과 ``arr`` 을 만들 때 사용되는 ``'d'`` 와 ``'i'`` 인자는 :mod:`array` 모듈에서 사용되는 "
"종류의 타입 코드입니다: ``'d'`` 는 배정밀도 부동 소수점을 나타내고, ``'i'`` 는 부호 있는 정수를 나타냅니다. 이러한 공유"
" 객체는 프로세스 및 스레드에 안전합니다."

#: ../Doc/library/multiprocessing.rst:311
msgid ""
"For more flexibility in using shared memory one can use the "
":mod:`multiprocessing.sharedctypes` module which supports the creation of"
" arbitrary ctypes objects allocated from shared memory."
msgstr ""
"공유 메모리를 더 유연하게 사용하려면, 공유 메모리에 할당된 임의의 ctypes 객체 생성을 지원하는 "
":mod:`multiprocessing.sharedctypes` 모듈을 사용할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:315
msgid "**Server process**"
msgstr "**서버 프로세스**"

#: ../Doc/library/multiprocessing.rst:317
msgid ""
"A manager object returned by :func:`Manager` controls a server process "
"which holds Python objects and allows other processes to manipulate them "
"using proxies."
msgstr ""
":func:`Manager` 가 반환한 관리자 객체는 파이썬 객체를 유지하고 다른 프로세스가 프락시를 사용하여 이 객체를 조작할 수 있게"
" 하는 서버 프로세스를 제어합니다."

#: ../Doc/library/multiprocessing.rst:321
msgid ""
"A manager returned by :func:`Manager` will support types :class:`list`, "
":class:`dict`, :class:`~managers.Namespace`, :class:`Lock`, "
":class:`RLock`, :class:`Semaphore`, :class:`BoundedSemaphore`, "
":class:`Condition`, :class:`Event`, :class:`Barrier`, :class:`Queue`, "
":class:`Value` and :class:`Array`.  For example, ::"
msgstr ""
":func:`Manager` 가 반환한 관리자는 :class:`list`, :class:`dict`, "
":class:`~managers.Namespace`, :class:`Lock`, :class:`RLock`, "
":class:`Semaphore`, :class:`BoundedSemaphore`, :class:`Condition`, "
":class:`Event`, :class:`Barrier`, :class:`Queue`, :class:`Value` 그리고 "
":class:`Array` 형을 지원합니다. 예를 들어, 다음 코드는 ::"

#: ../Doc/library/multiprocessing.rst:352
msgid ""
"Server process managers are more flexible than using shared memory "
"objects because they can be made to support arbitrary object types.  "
"Also, a single manager can be shared by processes on different computers "
"over a network. They are, however, slower than using shared memory."
msgstr ""
"서버 프로세스 관리자는 임의의 객체 형을 지원하도록 만들 수 있으므로 공유 메모리 객체를 사용하는 것보다 융통성이 있습니다. 또한, 단일"
" 관리자를 네트워크를 통해 서로 다른 컴퓨터의 프로세스에서 공유 할 수 있습니다. 그러나 공유 메모리를 사용할 때보다 느립니다."

#: ../Doc/library/multiprocessing.rst:359
msgid "Using a pool of workers"
msgstr "작업자 풀 사용"

#: ../Doc/library/multiprocessing.rst:361
msgid ""
"The :class:`~multiprocessing.pool.Pool` class represents a pool of worker"
" processes.  It has methods which allows tasks to be offloaded to the "
"worker processes in a few different ways."
msgstr ""
":class:`~multiprocessing.pool.Pool` 클래스는 작업자 프로세스 풀을 나타냅니다. 여기에는 몇 가지 다른 "
"방법으로 작업을 작업자 프로세스로 넘길 수 있는 메서드가 있습니다."

#: ../Doc/library/multiprocessing.rst:365
msgid "For example::"
msgstr "예를 들면::"

#: ../Doc/library/multiprocessing.rst:409
msgid ""
"Note that the methods of a pool should only ever be used by the process "
"which created it."
msgstr "풀의 메서드는 풀을 만든 프로세스에서만 사용되어야 함에 유의하세요."

#: ../Doc/library/multiprocessing.rst:414
msgid ""
"Functionality within this package requires that the ``__main__`` module "
"be importable by the children. This is covered in :ref:`multiprocessing-"
"programming` however it is worth pointing out here. This means that some "
"examples, such as the :class:`multiprocessing.pool.Pool` examples will "
"not work in the interactive interpreter. For example::"
msgstr ""
"이 패키지 내의 기능을 사용하려면 ``__main__`` 모듈을 자식이 임포트 할 수 있어야 합니다. 이것은 "
":ref:`multiprocessing-programming`\\에서 다루지만, 여기에서 지적할 가치가 있습니다. 이것은 몇몇 예제, "
"가령 :class:`multiprocessing.pool.Pool` 예제가 대화형 인터프리터에서 동작하지 않음을 의미합니다. 예를 "
"들면::"

#: ../Doc/library/multiprocessing.rst:436
msgid ""
"(If you try this it will actually output three full tracebacks "
"interleaved in a semi-random fashion, and then you may have to stop the "
"master process somehow.)"
msgstr ""
"(이것을 시도해 보면 실제로 세 개의 전체 트레이스백이 어느 정도 임의로 번갈아 출력됩니다. 그런 다음 마스터 프로세스를 중지시켜야 할 "
"수도 있습니다.)"

#: ../Doc/library/multiprocessing.rst:442
msgid "Reference"
msgstr "레퍼런스"

#: ../Doc/library/multiprocessing.rst:444
msgid ""
"The :mod:`multiprocessing` package mostly replicates the API of the "
":mod:`threading` module."
msgstr ":mod:`multiprocessing` 패키지는 대부분 :mod:`threading` 모듈의 API를 복제합니다."

#: ../Doc/library/multiprocessing.rst:449
msgid ":class:`Process` and exceptions"
msgstr ":class:`Process`\\와 예외"

#: ../Doc/library/multiprocessing.rst:454
msgid ""
"Process objects represent activity that is run in a separate process. The"
" :class:`Process` class has equivalents of all the methods of "
":class:`threading.Thread`."
msgstr ""
"프로세스 객체는 별도의 프로세스에서 실행되는 작업을 나타냅니다. :class:`Process` 클래스는 "
":class:`threading.Thread` 의 모든 메서드와 같은 메서드를 갖습니다."

#: ../Doc/library/multiprocessing.rst:458
msgid ""
"The constructor should always be called with keyword arguments. *group* "
"should always be ``None``; it exists solely for compatibility with "
":class:`threading.Thread`.  *target* is the callable object to be invoked"
" by the :meth:`run()` method.  It defaults to ``None``, meaning nothing "
"is called. *name* is the process name (see :attr:`name` for more "
"details). *args* is the argument tuple for the target invocation.  "
"*kwargs* is a dictionary of keyword arguments for the target invocation."
"  If provided, the keyword-only *daemon* argument sets the process "
":attr:`daemon` flag to ``True`` or ``False``.  If ``None`` (the default),"
" this flag will be inherited from the creating process."
msgstr ""
"생성자는 항상 키워드 인자로 호출해야 합니다. *group* 은 항상 ``None`` 이어야 합니다; 이것은 "
":class:`threading.Thread` 와의 호환성을 위해서만 존재합니다. *target* 은 :meth:`run()` 메서드에 "
"의해 호출될 콜러블 객체입니다. 기본값은 ``None`` 인데, 아무것도 호출되지 않음을 의미합니다. *name* 은 프로세스 이름입니다"
" (자세한 내용은 :attr:`name` 참조). *args* 는 target 호출을 위한 인자 튜플입니다. *kwargs* 는 "
"target 호출을 위한 키워드 인자 딕셔너리입니다. 제공되는 경우, 키워드 전용 *daemon* 인자는 프로세스 "
":attr:`daemon` 플래그를 ``True`` 또는 ``False`` 로 설정합니다. ``None`` (기본값) 이면, 이 플래그는"
" 만드는 프로세스로부터 상속됩니다."

#: ../Doc/library/multiprocessing.rst:469
msgid "By default, no arguments are passed to *target*."
msgstr "기본적으로, 아무 인자도 *target* 에 전달되지 않습니다."

#: ../Doc/library/multiprocessing.rst:471
msgid ""
"If a subclass overrides the constructor, it must make sure it invokes the"
" base class constructor (:meth:`Process.__init__`) before doing anything "
"else to the process."
msgstr ""
"서브 클래스가 생성자를 재정의하면, 프로세스에 다른 작업을 하기 전에 베이스 클래스 "
"생성자(:meth:`Process.__init__`)를 호출해야 합니다."

#: ../Doc/library/multiprocessing.rst:475
msgid "Added the *daemon* argument."
msgstr "*daemon* 인자가 추가되었습니다."

#: ../Doc/library/multiprocessing.rst:480
msgid "Method representing the process's activity."
msgstr "프로세스의 활동을 나타내는 메서드."

#: ../Doc/library/multiprocessing.rst:482
msgid ""
"You may override this method in a subclass.  The standard :meth:`run` "
"method invokes the callable object passed to the object's constructor as "
"the target argument, if any, with sequential and keyword arguments taken "
"from the *args* and *kwargs* arguments, respectively."
msgstr ""
"서브 클래스에서 이 메서드를 재정의할 수 있습니다. 표준 :meth:`run` 메서드는 객체의 생성자에 target 인자로 전달된 콜러블"
" 객체를 호출하는데 (있다면) *args* 와 *kwargs* 인자를 각각 위치 인자와 키워드 인자로 사용합니다."

#: ../Doc/library/multiprocessing.rst:489
msgid "Start the process's activity."
msgstr "프로세스의 활동을 시작합니다."

#: ../Doc/library/multiprocessing.rst:491
msgid ""
"This must be called at most once per process object.  It arranges for the"
" object's :meth:`run` method to be invoked in a separate process."
msgstr ""
"이것은 프로세스 객체 당 최대 한 번 호출되어야 합니다. 객체의 :meth:`run` 메서드가 별도의 프로세스에서 호출되도록 합니다."

#: ../Doc/library/multiprocessing.rst:496
msgid ""
"If the optional argument *timeout* is ``None`` (the default), the method "
"blocks until the process whose :meth:`join` method is called terminates. "
"If *timeout* is a positive number, it blocks at most *timeout* seconds. "
"Note that the method returns ``None`` if its process terminates or if the"
" method times out.  Check the process's :attr:`exitcode` to determine if "
"it terminated."
msgstr ""
"선택적 인자 *timeout* 이 ``None`` (기본값) 인 경우, 메서드는 :meth:`join` 메서드가 호출된 프로세스가 종료될"
" 때까지 블록 됩니다. *timeout* 이 양수면 최대 *timeout* 초 동안 블록 됩니다. 이 메서드는 프로세스가 종료되거나 "
"메서드가 시간 초과 되면 ``None`` 을 돌려줌에 주의해야 합니다. 프로세스의 :attr:`exitcode` 를 검사하여 종료되었는지"
" 확인하십시오."

#: ../Doc/library/multiprocessing.rst:503
msgid "A process can be joined many times."
msgstr "프로세스는 여러 번 조인할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:505
msgid ""
"A process cannot join itself because this would cause a deadlock.  It is "
"an error to attempt to join a process before it has been started."
msgstr ""
"교착 상태를 유발할 수 있으므로 프로세스는 자신을 조인할 수 없습니다. 프로세스가 시작되기 전에 프로세스에 조인하려고 하면 에러가 "
"발생합니다."

#: ../Doc/library/multiprocessing.rst:510
msgid ""
"The process's name.  The name is a string used for identification "
"purposes only.  It has no semantics.  Multiple processes may be given the"
" same name."
msgstr ""
"프로세스의 이름. 이름은 식별 목적으로만 사용되는 문자열입니다. 다른 의미는 없습니다. 여러 프로세스에 같은 이름이 주어질 수 있습니다."

#: ../Doc/library/multiprocessing.rst:514
msgid ""
"The initial name is set by the constructor.  If no explicit name is "
"provided to the constructor, a name of the form 'Process-N\\ :sub:`1`:N\\"
" :sub:`2`:...:N\\ :sub:`k`' is constructed, where each N\\ :sub:`k` is "
"the N-th child of its parent."
msgstr ""
"초기 이름은 생성자에 의해 설정됩니다. 명시적 이름이 생성자에 제공되지 않으면, 'Process-N\\ :sub:`1`:N\\ "
":sub:`2`:...:N\\ :sub:`k`' 형식의 이름이 만들어지는데, 각각의 N\\ :sub:`k` 는 부모의 N 번째 "
"자식입니다."

#: ../Doc/library/multiprocessing.rst:521
msgid "Return whether the process is alive."
msgstr "프로세스가 살아있는지 아닌지를 반환합니다."

#: ../Doc/library/multiprocessing.rst:523
msgid ""
"Roughly, a process object is alive from the moment the :meth:`start` "
"method returns until the child process terminates."
msgstr "대략, 프로세스 객체는 :meth:`start` 메서드가 반환하는 순간부터 자식 프로세스가 종료될 때까지 살아있습니다."

#: ../Doc/library/multiprocessing.rst:528
msgid ""
"The process's daemon flag, a Boolean value.  This must be set before "
":meth:`start` is called."
msgstr "프로세스의 데몬 플래그, 논리값. :meth:`start` 가 호출되기 전에 설정되어야 합니다."

#: ../Doc/library/multiprocessing.rst:531
msgid "The initial value is inherited from the creating process."
msgstr "초깃값은 생성 프로세스에서 상속됩니다."

#: ../Doc/library/multiprocessing.rst:533
msgid ""
"When a process exits, it attempts to terminate all of its daemonic child "
"processes."
msgstr "프로세스가 종료할 때, 모든 데몬 자식 프로세스를 강제 종료시키려고(terminate) 시도합니다."

#: ../Doc/library/multiprocessing.rst:536
msgid ""
"Note that a daemonic process is not allowed to create child processes. "
"Otherwise a daemonic process would leave its children orphaned if it gets"
" terminated when its parent process exits. Additionally, these are "
"**not** Unix daemons or services, they are normal processes that will be "
"terminated (and not joined) if non-daemonic processes have exited."
msgstr ""
"데몬 프로세스는 하위 프로세스를 만들 수 없음에 유의하십시오. 그렇지 않으면 부모 프로세스가 종료될 때 데몬 프로세스가 강제 종료되어, "
"데몬 프로세스가 자식 프로세스를 고아로 남기게 됩니다. 또한, 이들은 유닉스 데몬이나 서비스가 **아닙니다**, 데몬이 아닌 프로세스들이"
" 종료되면 강제 종료되는 (그리고 조인되지 않는) 일반 프로세스입니다."

#: ../Doc/library/multiprocessing.rst:542
msgid ""
"In addition to the  :class:`threading.Thread` API, :class:`Process` "
"objects also support the following attributes and methods:"
msgstr ""
":class:`threading.Thread` API 외에도 :class:`Process` 객체는 다음 어트리뷰트와 메서드도 지원합니다 "
":"

#: ../Doc/library/multiprocessing.rst:547
msgid ""
"Return the process ID.  Before the process is spawned, this will be "
"``None``."
msgstr "프로세스 ID를 돌려줍니다. 프로세스가 스폰 되기 전에는 ``None`` 입니다."

#: ../Doc/library/multiprocessing.rst:552
msgid ""
"The child's exit code.  This will be ``None`` if the process has not yet "
"terminated.  A negative value *-N* indicates that the child was "
"terminated by signal *N*."
msgstr ""
"자식의 종료 코드. 프로세스가 아직 종료되지 않았으면 ``None`` 이 됩니다. 음수 값 *-N* 은 자식이 시그널 *N* 에 의해 "
"강제 종료되었음을 나타냅니다."

#: ../Doc/library/multiprocessing.rst:558
msgid "The process's authentication key (a byte string)."
msgstr "프로세스의 인증 키 (바이트열) 입니다."

#: ../Doc/library/multiprocessing.rst:560
msgid ""
"When :mod:`multiprocessing` is initialized the main process is assigned a"
" random string using :func:`os.urandom`."
msgstr ""
":mod:`multiprocessing` 이 초기화될 때, 메인 프로세스는 :func:`os.urandom` 을 사용하여 임의의 문자열을"
" 할당받습니다."

#: ../Doc/library/multiprocessing.rst:563
msgid ""
"When a :class:`Process` object is created, it will inherit the "
"authentication key of its parent process, although this may be changed by"
" setting :attr:`authkey` to another byte string."
msgstr ""
":class:`Process` 객체가 생성될 때, 부모 프로세스의 인증 키를 상속받습니다. :attr:`authkey` 를 다른 "
"바이트열로 설정하여 변경할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:567
msgid "See :ref:`multiprocessing-auth-keys`."
msgstr ":ref:`multiprocessing-auth-keys`\\를 참조하세요."

#: ../Doc/library/multiprocessing.rst:571
msgid ""
"A numeric handle of a system object which will become \"ready\" when the "
"process ends."
msgstr "프로세스가 끝나면 \"준비(ready)\" 될 시스템 객체의 숫자 핸들."

#: ../Doc/library/multiprocessing.rst:574
msgid ""
"You can use this value if you want to wait on several events at once "
"using :func:`multiprocessing.connection.wait`.  Otherwise calling "
":meth:`join()` is simpler."
msgstr ""
":func:`multiprocessing.connection.wait` 를 사용해서 한 번에 여러 이벤트를 기다리고 싶다면, 이 값을 "
"사용할 수 있습니다. 그렇지 않으면 :meth:`join()`\\을 호출하는 것이 더 간단합니다."

#: ../Doc/library/multiprocessing.rst:578
msgid ""
"On Windows, this is an OS handle usable with the ``WaitForSingleObject`` "
"and ``WaitForMultipleObjects`` family of API calls.  On Unix, this is a "
"file descriptor usable with primitives from the :mod:`select` module."
msgstr ""
"윈도우에서, 이것은 ``WaitForSingleObject`` 및 ``WaitForMultipleObjects`` 계열의 API 호출에서"
" 사용할 수 있는 OS 핸들입니다. 유닉스에서, 이것은 :mod:`select` 모듈의 프리미티브들에서 사용할 수 있는 파일 "
"기술자입니다."

#: ../Doc/library/multiprocessing.rst:586
msgid ""
"Terminate the process.  On Unix this is done using the ``SIGTERM`` "
"signal; on Windows :c:func:`TerminateProcess` is used.  Note that exit "
"handlers and finally clauses, etc., will not be executed."
msgstr ""
"프로세스를 강제 종료합니다. 유닉스에서는 ``SIGTERM`` 시그널을 사용합니다; 윈도우에서는 "
":c:func:`TerminateProcess` 가 사용됩니다. 종료 처리기(exit handler)와 finally 절 등이 실행되지 "
"않음에 주의하십시오."

#: ../Doc/library/multiprocessing.rst:590
msgid ""
"Note that descendant processes of the process will *not* be terminated --"
" they will simply become orphaned."
msgstr "프로세스의 자손 프로세스들은 강제 종료되지 *않을* 것입니다 -- 단순히 고아가 될 것입니다."

#: ../Doc/library/multiprocessing.rst:595
msgid ""
"If this method is used when the associated process is using a pipe or "
"queue then the pipe or queue is liable to become corrupted and may become"
" unusable by other process.  Similarly, if the process has acquired a "
"lock or semaphore etc. then terminating it is liable to cause other "
"processes to deadlock."
msgstr ""
"연결된 프로세스가 파이프 또는 큐를 사용할 때 이 메서드를 사용하면, 파이프 또는 큐가 손상되어 다른 프로세스에서 사용할 수 없게 될 수"
" 있습니다. 마찬가지로, 프로세스가 록이나 세마포어 등을 획득한 경우 강제 종료하면 다른 프로세스가 교착 상태가 될 수 있습니다."

#: ../Doc/library/multiprocessing.rst:603
msgid "Same as :meth:`terminate()` but using the ``SIGKILL`` signal on Unix."
msgstr ":meth:`terminate()`\\와 같지만, 유닉스에서 ``SIGKILL`` 시그널을 사용합니다."

#: ../Doc/library/multiprocessing.rst:609
msgid ""
"Close the :class:`Process` object, releasing all resources associated "
"with it.  :exc:`ValueError` is raised if the underlying process is still "
"running.  Once :meth:`close` returns successfully, most other methods and"
" attributes of the :class:`Process` object will raise :exc:`ValueError`."
msgstr ""
":class:`Process` 객체를 닫아, 그것과 관련된 모든 자원을 해제합니다. 하부 프로세스가 여전히 실행 중이면 "
":exc:`ValueError` 가 발생합니다. 일단 :meth:`close` 가 성공적으로 반환되면, :class:`Process` "
"객체의 다른 대부분의 메서드와 어트리뷰트는 :exc:`ValueError` 를 발생시킵니다."

#: ../Doc/library/multiprocessing.rst:617
msgid ""
"Note that the :meth:`start`, :meth:`join`, :meth:`is_alive`, "
":meth:`terminate` and :attr:`exitcode` methods should only be called by "
"the process that created the process object."
msgstr ""
":meth:`start`, :meth:`join`, :meth:`is_alive`, :meth:`terminate` 및 "
":attr:`exitcode` 메서드는 프로세스 객체를 생성한 프로세스에 의해서만 호출되어야 합니다."

#: ../Doc/library/multiprocessing.rst:621
msgid "Example usage of some of the methods of :class:`Process`:"
msgstr ":class:`Process` 의 몇몇 메서드를 사용하는 예제:"

#: ../Doc/library/multiprocessing.rst:641
msgid "The base class of all :mod:`multiprocessing` exceptions."
msgstr "모든 :mod:`multiprocessing` 예외의 베이스 클래스입니다."

#: ../Doc/library/multiprocessing.rst:645
msgid ""
"Exception raised by :meth:`Connection.recv_bytes_into()` when the "
"supplied buffer object is too small for the message read."
msgstr ""
":meth:`Connection.recv_bytes_into()` 가, 제공된 버퍼 객체가 읽은 메시지에 비해 너무 작을 때 일으키는 "
"예외."

#: ../Doc/library/multiprocessing.rst:648
msgid ""
"If ``e`` is an instance of :exc:`BufferTooShort` then ``e.args[0]`` will "
"give the message as a byte string."
msgstr ""
"``e`` 가 :exc:`BufferTooShort` 의 인스턴스라면, ``e.args[0]`` 는 메시지를 바이트열로 줍니다."

#: ../Doc/library/multiprocessing.rst:653
msgid "Raised when there is an authentication error."
msgstr "인증 에러가 일어날 때 발생합니다."

#: ../Doc/library/multiprocessing.rst:657
msgid "Raised by methods with a timeout when the timeout expires."
msgstr "시간제한이 초과하였을 때 시간제한을 건 메서드에 의해 발생합니다."

#: ../Doc/library/multiprocessing.rst:660
msgid "Pipes and Queues"
msgstr "파이프와 큐"

#: ../Doc/library/multiprocessing.rst:662
msgid ""
"When using multiple processes, one generally uses message passing for "
"communication between processes and avoids having to use any "
"synchronization primitives like locks."
msgstr ""
"여러 프로세스를 사용할 때, 일반적으로 프로세스 간 통신을 위해 메시지 전달을 사용하고 록과 같은 동기화 프리미티브 사용을 피합니다."

#: ../Doc/library/multiprocessing.rst:666
msgid ""
"For passing messages one can use :func:`Pipe` (for a connection between "
"two processes) or a queue (which allows multiple producers and "
"consumers)."
msgstr ""
"메시지를 전달하기 위해 :func:`Pipe` (두 프로세스 간의 연결) 또는 큐(여러 생산자와 소비자를 허용합니다)를 사용할 수 "
"있습니다."

#: ../Doc/library/multiprocessing.rst:669
msgid ""
"The :class:`Queue`, :class:`SimpleQueue` and :class:`JoinableQueue` types"
" are multi-producer, multi-consumer :abbr:`FIFO (first-in, first-out)` "
"queues modelled on the :class:`queue.Queue` class in the standard "
"library.  They differ in that :class:`Queue` lacks the "
":meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join` methods "
"introduced into Python 2.5's :class:`queue.Queue` class."
msgstr ""
":class:`Queue`, :class:`SimpleQueue` 그리고 :class:`JoinableQueue` 형은, 표준 "
"라이브러리의 :class:`queue.Queue` 클래스에 따라 모델링 된, 다중 생산자, 다중 소비자 :abbr:`FIFO "
"(first-in, first-out)` 큐입니다. 이것들은 파이썬 2.5의 :class:`queue.Queue` 클래스에서 도입된 "
":meth:`~queue.Queue.task_done`\\과 :meth:`~queue.Queue.join` 메서드가 "
":class:`Queue` 에 없다는 점에서 다릅니다."

#: ../Doc/library/multiprocessing.rst:676
msgid ""
"If you use :class:`JoinableQueue` then you **must** call "
":meth:`JoinableQueue.task_done` for each task removed from the queue or "
"else the semaphore used to count the number of unfinished tasks may "
"eventually overflow, raising an exception."
msgstr ""
":class:`JoinableQueue`\\를 사용하면, 큐에서 제거된 작업마다 "
":meth:`JoinableQueue.task_done`\\을 호출해야 합니다. 그렇지 않으면 완료되지 않은 작업의 수를 세는 데 "
"사용되는 세마포어가 결국 오버플로 되어 예외를 일으킵니다."

#: ../Doc/library/multiprocessing.rst:681
msgid ""
"Note that one can also create a shared queue by using a manager object --"
" see :ref:`multiprocessing-managers`."
msgstr ""
"관리자 객체를 사용하여 공유 큐를 생성할 수도 있습니다 -- :ref:`multiprocessing-managers`\\를 보세요."

#: ../Doc/library/multiprocessing.rst:686
msgid ""
":mod:`multiprocessing` uses the usual :exc:`queue.Empty` and "
":exc:`queue.Full` exceptions to signal a timeout.  They are not available"
" in the :mod:`multiprocessing` namespace so you need to import them from "
":mod:`queue`."
msgstr ""
":mod:`multiprocessing` 은 제한 시간 초과 신호를 보내기 위해 보통 :exc:`queue.Empty` 와 "
":exc:`queue.Full` 예외를 사용합니다. :mod:`multiprocessing` 이름 공간에는 없으므로 "
":mod:`queue`\\에서 임포트 해야 합니다."

#: ../Doc/library/multiprocessing.rst:693
msgid ""
"When an object is put on a queue, the object is pickled and a background "
"thread later flushes the pickled data to an underlying pipe.  This has "
"some consequences which are a little surprising, but should not cause any"
" practical difficulties -- if they really bother you then you can instead"
" use a queue created with a :ref:`manager <multiprocessing-managers>`."
msgstr ""
"객체를 큐에 넣으면, 객체는 피클 되고 배경 스레드가 나중에 피클 된 데이터를 하부 파이프로 플러시 합니다. 이것은 다소 의외의 결과로 "
"이어지지만, 실제적인 어려움을 일으키지는 않아야 합니다 -- 이것이 여러분을 정말로 신경 쓰이게 한다면, 대신 :ref:`관리자 "
"<multiprocessing-managers>` 로 만든 큐를 사용할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:700
msgid ""
"After putting an object on an empty queue there may be an infinitesimal "
"delay before the queue's :meth:`~Queue.empty` method returns "
":const:`False` and :meth:`~Queue.get_nowait` can return without raising "
":exc:`queue.Empty`."
msgstr ""
"빈 큐에 객체를 넣은 후에, :meth:`~Queue.empty` 메서드가 :const:`False`\\를 반환하고 "
":meth:`~Queue.get_nowait`\\가 :exc:`queue.Empty` 를 일으키지 않고 반환할 수 있기 전까지 극히 작은"
" 지연이 있을 수 있습니다."

#: ../Doc/library/multiprocessing.rst:705
msgid ""
"If multiple processes are enqueuing objects, it is possible for the "
"objects to be received at the other end out-of-order. However, objects "
"enqueued by the same process will always be in the expected order with "
"respect to each other."
msgstr ""
"여러 프로세스가 객체를 큐에 넣는 경우, 반대편에서 객체가 다른 순서로 수신될 수 있습니다. 그러나, 같은 프로세스에 의해 큐에 들어간 "
"객체들은 항상 상대적인 순서가 유지됩니다."

#: ../Doc/library/multiprocessing.rst:712
msgid ""
"If a process is killed using :meth:`Process.terminate` or :func:`os.kill`"
" while it is trying to use a :class:`Queue`, then the data in the queue "
"is likely to become corrupted.  This may cause any other process to get "
"an exception when it tries to use the queue later on."
msgstr ""
":class:`Queue`\\를 사용하려고 하는 동안 :meth:`Process.terminate` 또는 :func:`os.kill` 을"
" 사용하여 프로세스를 죽이면, 큐의 데이터가 손상될 수 있습니다. 이로 인해 나중에 다른 프로세스가 큐를 사용하려고 할 때 예외가 발생할"
" 수 있습니다."

#: ../Doc/library/multiprocessing.rst:719
msgid ""
"As mentioned above, if a child process has put items on a queue (and it "
"has not used :meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>`), then that process will not "
"terminate until all buffered items have been flushed to the pipe."
msgstr ""
"위에서 언급했듯이, 자식 프로세스가 항목을 큐에 넣었을 때 (그리고 "
":meth:`JoinableQueue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` 를 사용하지 않았다면), 버퍼링 된 모든 항목이 파이프로 "
"플러시 될 때까지 해당 프로세스가 종료되지 않습니다."

#: ../Doc/library/multiprocessing.rst:724
msgid ""
"This means that if you try joining that process you may get a deadlock "
"unless you are sure that all items which have been put on the queue have "
"been consumed.  Similarly, if the child process is non-daemonic then the "
"parent process may hang on exit when it tries to join all its non-"
"daemonic children."
msgstr ""
"이것은, 여러분이 그 자식 프로세스를 조인하려고 하면, 큐에 넣은 모든 항목을 소진하지 않는 한 교착 상태가 발생할 수 있다는 뜻입니다."
" 마찬가지로, 그 자식 프로세스가 데몬이 아니면 부모 프로세스가 종료 시점에 데몬이 아닌 모든 자식을 조인하려고 할 때 정지될 수 "
"있습니다."

#: ../Doc/library/multiprocessing.rst:729
msgid ""
"Note that a queue created using a manager does not have this issue.  See "
":ref:`multiprocessing-programming`."
msgstr ""
"관리자를 사용하여 생성된 큐에는 이 문제가 없습니다. :ref:`multiprocessing-programming`\\을 참조하세요."

#: ../Doc/library/multiprocessing.rst:732
msgid ""
"For an example of the usage of queues for interprocess communication see "
":ref:`multiprocessing-examples`."
msgstr "프로세스 간 통신을 위해 큐를 사용하는 예는 :ref:`multiprocessing-examples`\\을 참조하십시오."

#: ../Doc/library/multiprocessing.rst:738
msgid ""
"Returns a pair ``(conn1, conn2)`` of "
":class:`~multiprocessing.connection.Connection` objects representing the "
"ends of a pipe."
msgstr ""
"파이프의 끝을 나타내는 :class:`~multiprocessing.connection.Connection` 객체 쌍 ``(conn1, "
"conn2)`` 를 반환합니다."

#: ../Doc/library/multiprocessing.rst:742
msgid ""
"If *duplex* is ``True`` (the default) then the pipe is bidirectional.  If"
" *duplex* is ``False`` then the pipe is unidirectional: ``conn1`` can "
"only be used for receiving messages and ``conn2`` can only be used for "
"sending messages."
msgstr ""
"*duplex* 가 ``True`` (기본값) 면 파이프는 양방향입니다. *duplex* 가 ``False`` 인 경우 파이프는 "
"단방향입니다: ``conn1`` 은 메시지를 받는 데에만 사용할 수 있고, ``conn2`` 는 메시지를 보낼 때만 사용할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:750
msgid ""
"Returns a process shared queue implemented using a pipe and a few "
"locks/semaphores.  When a process first puts an item on the queue a "
"feeder thread is started which transfers objects from a buffer into the "
"pipe."
msgstr ""
"파이프와 몇 개의 록/세마포어를 사용하여 구현된 프로세스 공유 큐를 반환합니다. 프로세스가 처음으로 항목을 큐에 넣으면 버퍼에서 파이프로"
" 객체를 전송하는 피더 스레드가 시작됩니다."

#: ../Doc/library/multiprocessing.rst:754
msgid ""
"The usual :exc:`queue.Empty` and :exc:`queue.Full` exceptions from the "
"standard library's :mod:`queue` module are raised to signal timeouts."
msgstr ""
"제한 시간 초과를 알리기 위해 표준 라이브러리의 :mod:`queue` 모듈에서 정의되는 :exc:`queue.Empty` 와 "
":exc:`queue.Full` 예외를 일으킵니다."

#: ../Doc/library/multiprocessing.rst:757
msgid ""
":class:`Queue` implements all the methods of :class:`queue.Queue` except "
"for :meth:`~queue.Queue.task_done` and :meth:`~queue.Queue.join`."
msgstr ""
":class:`Queue` 는 :meth:`~queue.Queue.task_done`\\과 :meth:`~queue.Queue.join`"
" 을 제외한 :class:`queue.Queue` 의 모든 메서드를 구현합니다."

#: ../Doc/library/multiprocessing.rst:762
msgid ""
"Return the approximate size of the queue.  Because of "
"multithreading/multiprocessing semantics, this number is not reliable."
msgstr "큐의 대략의 크기를 돌려줍니다. 다중 스레딩/다중 프로세싱 특성을 타기 때문에 이 숫자는 신뢰할 수 없습니다."

#: ../Doc/library/multiprocessing.rst:765
msgid ""
"Note that this may raise :exc:`NotImplementedError` on Unix platforms "
"like Mac OS X where ``sem_getvalue()`` is not implemented."
msgstr ""
"이것은 ``sem_getvalue()`` 가 구현되지 않은 Mac OS X와 ​​같은 유닉스 플랫폼에서 "
":exc:`NotImplementedError`\\를 발생시킬 수 있습니다."

#: ../Doc/library/multiprocessing.rst:770
msgid ""
"Return ``True`` if the queue is empty, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"큐가 비어 있다면 ``True`` 를, 그렇지 않으면 ``False`` 를 반환합니다. 다중 스레딩/다중 프로세싱 특성을 타기 때문에 "
"신뢰할 수 없습니다."

#: ../Doc/library/multiprocessing.rst:775
msgid ""
"Return ``True`` if the queue is full, ``False`` otherwise.  Because of "
"multithreading/multiprocessing semantics, this is not reliable."
msgstr ""
"큐가 가득 차면 ``True`` 를, 그렇지 않으면 ``False`` 를 반환합니다. 다중 스레딩/다중 프로세싱 특성을 타기 때문에 "
"신뢰할 수 없습니다."

#: ../Doc/library/multiprocessing.rst:780
msgid ""
"Put obj into the queue.  If the optional argument *block* is ``True`` "
"(the default) and *timeout* is ``None`` (the default), block if necessary"
" until a free slot is available.  If *timeout* is a positive number, it "
"blocks at most *timeout* seconds and raises the :exc:`queue.Full` "
"exception if no free slot was available within that time.  Otherwise "
"(*block* is ``False``), put an item on the queue if a free slot is "
"immediately available, else raise the :exc:`queue.Full` exception "
"(*timeout* is ignored in that case)."
msgstr ""
"obj를 큐에 넣습니다. 선택적 인자 *block* 이 ``True`` (기본값)이고 *timeout* 이 ``None`` (기본값) "
"이면, 빈 슬롯이 생길 때까지 필요한 경우 블록합니다. *timeout* 이 양수인 경우, 최대 *timeout* 초만큼 블록하고 그 "
"시간 내에 사용 가능 슬롯이 생기지 않으면 :exc:`queue.Full` 예외를 발생시킵니다. 그렇지 않으면 (*block* 이 "
"``False``) 빈 슬롯을 즉시 사용할 수 있으면 큐에 항목을 넣고, 그렇지 않으면 :exc:`queue.Full` 예외를 "
"발생시킵니다 (이 경우 *timeout* 은 무시됩니다)."

#: ../Doc/library/multiprocessing.rst:791
msgid "Equivalent to ``put(obj, False)``."
msgstr "``put(obj, False)`` 와 같습니다."

#: ../Doc/library/multiprocessing.rst:795
msgid ""
"Remove and return an item from the queue.  If optional args *block* is "
"``True`` (the default) and *timeout* is ``None`` (the default), block if "
"necessary until an item is available.  If *timeout* is a positive number,"
" it blocks at most *timeout* seconds and raises the :exc:`queue.Empty` "
"exception if no item was available within that time.  Otherwise (block is"
" ``False``), return an item if one is immediately available, else raise "
"the :exc:`queue.Empty` exception (*timeout* is ignored in that case)."
msgstr ""
"큐에서 항목을 제거하고 반환합니다. 선택적 인자 *block* 이 ``True`` (기본값)이고 *timeout* 이 ``None`` "
"(기본값) 이면, 항목이 들어올 때까지 필요한 경우 블록합니다. *timeout* 이 양수인 경우, 최대 *timeout* 초만큼 "
"블록하고 그 시간 내에 항목이 들어오지 않으면 :exc:`queue.Empty` 예외를 발생시킵니다. 그렇지 않으면 (block이 "
"``False``) 즉시 사용할 수 있는 항목이 있으면 반환하고, 그렇지 않으면 :exc:`queue.Empty` 예외를 발생시킵니다 "
"(이 경우 *timeout* 은 무시됩니다)."

#: ../Doc/library/multiprocessing.rst:805
msgid "Equivalent to ``get(False)``."
msgstr "``get(False)`` 와 같습니다."

#: ../Doc/library/multiprocessing.rst:807
msgid ""
":class:`multiprocessing.Queue` has a few additional methods not found in "
":class:`queue.Queue`.  These methods are usually unnecessary for most "
"code:"
msgstr ""
":class:`multiprocessing.Queue` 에는 :class:`queue.Queue` 에서 찾을 수 없는 몇 가지 추가 "
"메서드가 있습니다. 일반적으로 이러한 메서드는 대부분 코드에서 필요하지 않습니다:"

#: ../Doc/library/multiprocessing.rst:813
msgid ""
"Indicate that no more data will be put on this queue by the current "
"process.  The background thread will quit once it has flushed all "
"buffered data to the pipe.  This is called automatically when the queue "
"is garbage collected."
msgstr ""
"현재 프로세스가 이 큐에 더는 데이터를 넣지 않을 것을 나타냅니다. 버퍼에 저장된 모든 데이터를 파이프로 플러시 하면 배경 스레드가 "
"종료됩니다. 큐가 가비지 수집될 때 자동으로 호출됩니다."

#: ../Doc/library/multiprocessing.rst:820
msgid ""
"Join the background thread.  This can only be used after :meth:`close` "
"has been called.  It blocks until the background thread exits, ensuring "
"that all data in the buffer has been flushed to the pipe."
msgstr ""
"배경 스레드에 조인합니다. :meth:`close` 가 호출된 후에만 ​​사용할 수 있습니다. 배경 스레드가 종료될 때까지 블록해서 "
"버퍼의 모든 데이터가 파이프로 플러시 되었음을 보증합니다."

#: ../Doc/library/multiprocessing.rst:824
msgid ""
"By default if a process is not the creator of the queue then on exit it "
"will attempt to join the queue's background thread.  The process can call"
" :meth:`cancel_join_thread` to make :meth:`join_thread` do nothing."
msgstr ""
"기본적으로 프로세스가 큐를 만든 주체가 아니면 종료할 때 큐의 배경 스레드를 조인하려고 합니다. 프로세스는 "
":meth:`cancel_join_thread`\\를 호출하여 :meth:`join_thread` 가 아무것도 하지 않게 할 수 "
"있습니다."

#: ../Doc/library/multiprocessing.rst:830
msgid ""
"Prevent :meth:`join_thread` from blocking.  In particular, this prevents "
"the background thread from being joined automatically when the process "
"exits -- see :meth:`join_thread`."
msgstr ""
":meth:`join_thread` 의 블록을 방지합니다. 특히, 프로세스가 종료할 때 배경 스레드를 자동으로 조인하는 것을 막습니다 "
"-- :meth:`join_thread`\\를 보십시오."

#: ../Doc/library/multiprocessing.rst:834
msgid ""
"A better name for this method might be ``allow_exit_without_flush()``.  "
"It is likely to cause enqueued data to lost, and you almost certainly "
"will not need to use it. It is really only there if you need the current "
"process to exit immediately without waiting to flush enqueued data to the"
" underlying pipe, and you don't care about lost data."
msgstr ""
"이 메서드의 더 좋은 이름은 ``allow_exit_without_flush()`` 일 것입니다. 큐에 포함된 데이터가 유실될 가능성이 "
"크며, 거의 확실히 ​​사용할 필요가 없을 겁니다. 현재 프로세스가 하부 파이프로 대기 중인 데이터를 플러시 할 때까지 기다리지 않고 "
"즉시 종료해야 하고 데이터 손실에 대해서는 신경 쓰지 않을 때만을 위한 것입니다."

#: ../Doc/library/multiprocessing.rst:843
msgid ""
"This class's functionality requires a functioning shared semaphore "
"implementation on the host operating system. Without one, the "
"functionality in this class will be disabled, and attempts to instantiate"
" a :class:`Queue` will result in an :exc:`ImportError`. See :issue:`3770`"
" for additional information.  The same holds true for any of the "
"specialized queue types listed below."
msgstr ""
"이 클래스의 기능은 호스트 운영 체제의 작동하는 공유 세마포어 구현을 요구합니다. 그런 것이 없으면, 클래스의 기능이 비활성화되고, "
":class:`Queue` 의 인스턴스를 만들려고 하면 :exc:`ImportError` 를 일으킵니다. 자세한 내용은 "
":issue:`3770`\\을 참조하십시오. 아래에 나열된 특수 큐 형들도 마찬가지입니다."

#: ../Doc/library/multiprocessing.rst:852
msgid ""
"It is a simplified :class:`Queue` type, very close to a locked "
":class:`Pipe`."
msgstr "이것은 단순화된 :class:`Queue` 형으로, 록이 걸린 :class:`Pipe` 에 매우 가깝습니다."

#: ../Doc/library/multiprocessing.rst:856
msgid "Return ``True`` if the queue is empty, ``False`` otherwise."
msgstr "큐가 비어 있다면 ``True`` 를, 그렇지 않으면 ``False`` 를 반환합니다."

#: ../Doc/library/multiprocessing.rst:860
msgid "Remove and return an item from the queue."
msgstr "큐에서 항목을 제거하고 반환합니다."

#: ../Doc/library/multiprocessing.rst:864
msgid "Put *item* into the queue."
msgstr "*item* 을 큐에 넣습니다."

#: ../Doc/library/multiprocessing.rst:869
msgid ""
":class:`JoinableQueue`, a :class:`Queue` subclass, is a queue which "
"additionally has :meth:`task_done` and :meth:`join` methods."
msgstr ""
":class:`Queue` 서브 클래스 :class:`JoinableQueue` 는 추가로 :meth:`task_done`\\과 "
":meth:`join` 메서드를 가진 큐입니다."

#: ../Doc/library/multiprocessing.rst:874
msgid ""
"Indicate that a formerly enqueued task is complete. Used by queue "
"consumers.  For each :meth:`~Queue.get` used to fetch a task, a "
"subsequent call to :meth:`task_done` tells the queue that the processing "
"on the task is complete."
msgstr ""
"앞서 큐에 넣은 작업이 완료되었음을 나타냅니다. 큐 소비자가 사용합니다. 작업을 가져오는데 사용된 각 :meth:`~Queue.get` "
"마다, 뒤따르는 :meth:`task_done` 호출은 작업에 대한 처리가 완료되었음을 큐에 알립니다."

#: ../Doc/library/multiprocessing.rst:879
msgid ""
"If a :meth:`~queue.Queue.join` is currently blocking, it will resume when"
" all items have been processed (meaning that a :meth:`task_done` call was"
" received for every item that had been :meth:`~Queue.put` into the "
"queue)."
msgstr ""
"만약 :meth:`~queue.Queue.join` 이 현재 블록하고 있다면, 모든 항목이 처리될 때 재개될 것입니다 "
"(:meth:`~Queue.put` 으로 큐에 넣은 모든 항목에 대해 :meth:`task_done` 호출을 수신했다는 뜻입니다)."

#: ../Doc/library/multiprocessing.rst:883
msgid ""
"Raises a :exc:`ValueError` if called more times than there were items "
"placed in the queue."
msgstr "큐에 있는 항목보다 많이 호출되면 :exc:`ValueError` 를 발생시킵니다."

#: ../Doc/library/multiprocessing.rst:889
msgid "Block until all items in the queue have been gotten and processed."
msgstr "큐의 모든 항목을 가져가서 처리할 때까지 블록합니다."

#: ../Doc/library/multiprocessing.rst:891
msgid ""
"The count of unfinished tasks goes up whenever an item is added to the "
"queue.  The count goes down whenever a consumer calls :meth:`task_done` "
"to indicate that the item was retrieved and all work on it is complete.  "
"When the count of unfinished tasks drops to zero, "
":meth:`~queue.Queue.join` unblocks."
msgstr ""
"항목이 큐에 추가될 때마다 완료되지 않은 작업의 수는 올라갑니다. 소비자가 그 항목을 꺼냈고 그에 대한 모든 작업을 완료했음을 알리기 "
"위해 :meth:`task_done`\\을 호출할 때마다 숫자는 줄어듭니다. 완료되지 않은 작업의 수가 0으로 떨어지면 "
":meth:`~queue.Queue.join` 이 블록으로부터 풀려납니다."

#: ../Doc/library/multiprocessing.rst:899
msgid "Miscellaneous"
msgstr "잡동사니"

#: ../Doc/library/multiprocessing.rst:903
msgid "Return list of all live children of the current process."
msgstr "현재 프로세스의 모든 살아있는 자식 리스트를 반환합니다."

#: ../Doc/library/multiprocessing.rst:905
msgid ""
"Calling this has the side effect of \"joining\" any processes which have "
"already finished."
msgstr "이것을 호출하면 이미 완료된 프로세스에 \"조인\" 하는 부작용이 있습니다."

#: ../Doc/library/multiprocessing.rst:910
msgid "Return the number of CPUs in the system."
msgstr "시스템의 CPU 수를 반환합니다."

#: ../Doc/library/multiprocessing.rst:912
msgid ""
"This number is not equivalent to the number of CPUs the current process "
"can use.  The number of usable CPUs can be obtained with "
"``len(os.sched_getaffinity(0))``"
msgstr ""
"이 숫자는 현재 프로세스에서 사용할 수 있는 CPU 수와 같지 않습니다. 사용 가능한 CPU 수는 "
"``len(os.sched_getaffinity(0))`` 로 얻을 수 있습니다."

#: ../Doc/library/multiprocessing.rst:916
msgid "May raise :exc:`NotImplementedError`."
msgstr ":exc:`NotImplementedError`\\를 일으킬 수 있습니다."

#: ../Doc/library/multiprocessing.rst:919
msgid ":func:`os.cpu_count`"
msgstr ":func:`os.cpu_count`"

#: ../Doc/library/multiprocessing.rst:923
msgid "Return the :class:`Process` object corresponding to the current process."
msgstr "현재 프로세스에 해당하는 :class:`Process` 객체를 반환합니다."

#: ../Doc/library/multiprocessing.rst:925
msgid "An analogue of :func:`threading.current_thread`."
msgstr ":func:`threading.current_thread`\\와 유사한 기능을 제공합니다."

#: ../Doc/library/multiprocessing.rst:929
msgid ""
"Add support for when a program which uses :mod:`multiprocessing` has been"
" frozen to produce a Windows executable.  (Has been tested with "
"**py2exe**, **PyInstaller** and **cx_Freeze**.)"
msgstr ""
":mod:`multiprocessing`\\을 사용하는 프로그램이 고정되어(frozen) 윈도우 실행 파일을 생성할 때를 위한 지원을 "
"추가합니다. (**py2exe**, **PyInstaller** 및 **cx_Freeze** 에서 테스트 되었습니다.)"

#: ../Doc/library/multiprocessing.rst:933
msgid ""
"One needs to call this function straight after the ``if __name__ == "
"'__main__'`` line of the main module.  For example::"
msgstr "메인 모듈의 ``if __name__ == '__main__'`` 줄 바로 뒤에서 이 함수를 호출해야 합니다. 예를 들면::"

#: ../Doc/library/multiprocessing.rst:945
msgid ""
"If the ``freeze_support()`` line is omitted then trying to run the frozen"
" executable will raise :exc:`RuntimeError`."
msgstr ""
"``freeze_support()`` 줄이 생략된 경우 고정된 실행 파일을 실행하려고 하면 :exc:`RuntimeError` 가 "
"발생합니다."

#: ../Doc/library/multiprocessing.rst:948
msgid ""
"Calling ``freeze_support()`` has no effect when invoked on any operating "
"system other than Windows.  In addition, if the module is being run "
"normally by the Python interpreter on Windows (the program has not been "
"frozen), then ``freeze_support()`` has no effect."
msgstr ""
"``freeze_support()`` 호출은 윈도우가 아닌 다른 운영 체제에서 실행될 때는 아무런 영향을 미치지 않습니다. 또한, 모듈이"
" 윈도우상의 파이썬 인터프리터에 의해 정상적으로 실행되는 경우 (프로그램이 고정되지 않은 경우)에도 ``freeze_support()``"
" 는 아무 효과가 없습니다."

#: ../Doc/library/multiprocessing.rst:955
msgid ""
"Returns a list of the supported start methods, the first of which is the "
"default.  The possible start methods are ``'fork'``, ``'spawn'`` and "
"``'forkserver'``.  On Windows only ``'spawn'`` is available.  On Unix "
"``'fork'`` and ``'spawn'`` are always supported, with ``'fork'`` being "
"the default."
msgstr ""
"지원되는 시작 방법의 리스트를 반환하는데, 그 중 첫 번째가 기본값입니다. 가능한 시작 방법은 ``'fork'``, ``'spawn'``"
" 및 ``'forkserver'`` 입니다. 윈도우에서는 ``'spawn'`` 만 사용할 수 있습니다. 유닉스에서는 ``'fork'`` "
"와 ``'spawn'`` 이 항상 지원되며 ``'fork'`` 가 기본값입니다."

#: ../Doc/library/multiprocessing.rst:965
msgid ""
"Return a context object which has the same attributes as the "
":mod:`multiprocessing` module."
msgstr ":mod:`multiprocessing` 모듈과 같은 어트리뷰트를 가진 컨텍스트 객체를 반환합니다."

#: ../Doc/library/multiprocessing.rst:968
msgid ""
"If *method* is ``None`` then the default context is returned. Otherwise "
"*method* should be ``'fork'``, ``'spawn'``, ``'forkserver'``.  "
":exc:`ValueError` is raised if the specified start method is not "
"available."
msgstr ""
"*method* 가 ``None`` 이면 기본 컨텍스트가 반환됩니다. 그렇지 않으면 *method* 는 ``'fork'``, "
"``'spawn'``, ``'forkserver'`` 이어야 합니다. 지정된 시작 방법을 사용할 수 없는 경우 "
":exc:`ValueError` 가 발생합니다."

#: ../Doc/library/multiprocessing.rst:977
msgid "Return the name of start method used for starting processes."
msgstr "프로세스를 기동하기 위해서 사용되는 시작 방법의 이름을 돌려줍니다."

#: ../Doc/library/multiprocessing.rst:979
msgid ""
"If the start method has not been fixed and *allow_none* is false, then "
"the start method is fixed to the default and the name is returned.  If "
"the start method has not been fixed and *allow_none* is true then "
"``None`` is returned."
msgstr ""
"시작 방법이 고정되지 않았고 *allow_none* 이 거짓이면, 시작 방법이 기본값으로 고정되고 이름이 반환됩니다. 시작 방법이 "
"고정되지 않았고 *allow_none*\\이 참이면, ``None`` 이 반환됩니다."

#: ../Doc/library/multiprocessing.rst:984
msgid ""
"The return value can be ``'fork'``, ``'spawn'``, ``'forkserver'`` or "
"``None``.  ``'fork'`` is the default on Unix, while ``'spawn'`` is the "
"default on Windows."
msgstr ""
"반환 값은 ``'fork'``, ``'spawn'``, ``'forkserver'`` 또는 ``None`` 입니다. 유닉스에서는 "
"``'fork'`` 가 기본값이고, 윈도우에서는 ``'spawn'`` 이 기본값입니다."

#: ../Doc/library/multiprocessing.rst:992
msgid ""
"Sets the path of the Python interpreter to use when starting a child "
"process. (By default :data:`sys.executable` is used).  Embedders will "
"probably need to do some thing like ::"
msgstr ""
"자식 프로세스를 시작할 때 사용할 파이썬 인터프리터의 경로를 설정합니다. (기본적으로 :data:`sys.executable` 이 "
"사용됩니다). 파이썬은 내장하는 사람들은 아마도 다음과 같이 할 필요가 있습니다 ::"

#: ../Doc/library/multiprocessing.rst:998
msgid "before they can create child processes."
msgstr "자식 프로세스를 만들기 전에 해야 합니다."

#: ../Doc/library/multiprocessing.rst:1000
msgid "Now supported on Unix when the ``'spawn'`` start method is used."
msgstr "이제 ``'spawn'`` 시작 방법을 사용할 때 유닉스에서 지원됩니다."

#: ../Doc/library/multiprocessing.rst:1005
msgid ""
"Set the method which should be used to start child processes. *method* "
"can be ``'fork'``, ``'spawn'`` or ``'forkserver'``."
msgstr ""
"자식 프로세스를 시작하는 데 사용해야 하는 방법을 설정합니다. *method* 는 ``'fork'``, ``'spawn'`` 또는 "
"``'forkserver'`` 일 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1008
msgid ""
"Note that this should be called at most once, and it should be protected "
"inside the ``if __name__ == '__main__'`` clause of the main module."
msgstr ""
"이것은 한 번만 호출해야 하며, 메인 모듈의 ``if __name__ == '__main__'`` 절 내에서 보호되어야 합니다."

#: ../Doc/library/multiprocessing.rst:1016
msgid ""
":mod:`multiprocessing` contains no analogues of "
":func:`threading.active_count`, :func:`threading.enumerate`, "
":func:`threading.settrace`, :func:`threading.setprofile`, "
":class:`threading.Timer`, or :class:`threading.local`."
msgstr ""
":mod:`multiprocessing` 에는 :func:`threading.active_count`, "
":func:`threading.enumerate`, :func:`threading.settrace`, "
":func:`threading.setprofile`, :class:`threading.Timer` 또는 "
":class:`threading.local` 의 대응 물이 없습니다."

#: ../Doc/library/multiprocessing.rst:1023
msgid "Connection Objects"
msgstr "Connection 객체"

#: ../Doc/library/multiprocessing.rst:1027
msgid ""
"Connection objects allow the sending and receiving of picklable objects "
"or strings.  They can be thought of as message oriented connected "
"sockets."
msgstr ""
"연결 객체를 사용하면 피클 가능한 객체나 문자열을 보내고 받을 수 있습니다. 메시지 지향 연결된 소켓으로 생각할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1030
msgid ""
"Connection objects are usually created using :func:`Pipe "
"<multiprocessing.Pipe>` -- see also :ref:`multiprocessing-listeners-"
"clients`."
msgstr ""
"연결 객체는 보통 :func:`Pipe <multiprocessing.Pipe>` 를 사용해서 만들어집니다 -- "
":ref:`multiprocessing-listeners-clients` 도 참고하세요."

#: ../Doc/library/multiprocessing.rst:1038
msgid ""
"Send an object to the other end of the connection which should be read "
"using :meth:`recv`."
msgstr "연결의 반대편 끝에서 :meth:`recv`\\를 사용하여 읽을 객체를 보냅니다."

#: ../Doc/library/multiprocessing.rst:1041
msgid ""
"The object must be picklable.  Very large pickles (approximately 32 MiB+,"
" though it depends on the OS) may raise a :exc:`ValueError` exception."
msgstr ""
"객체는 피클 가능해야 합니다. 매우 큰 피클(약 32 MiB+, OS에 따라 다릅니다)은 :exc:`ValueError` 예외를 발생시킬"
" 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1046
msgid ""
"Return an object sent from the other end of the connection using "
":meth:`send`.  Blocks until there is something to receive.  Raises "
":exc:`EOFError` if there is nothing left to receive and the other end was"
" closed."
msgstr ""
"연결의 반대편 끝에서 :meth:`send`\\로 보낸 객체를 반환합니다. 뭔가 수신할 때까지 블록합니다. 수신할 내용이 없고 반대편 "
"끝이 닫혔으면 :exc:`EOFError`\\를 발생시킵니다."

#: ../Doc/library/multiprocessing.rst:1053
msgid "Return the file descriptor or handle used by the connection."
msgstr "연결이 사용하는 파일 기술자나 핸들을 돌려줍니다."

#: ../Doc/library/multiprocessing.rst:1057
msgid "Close the connection."
msgstr "연결을 닫습니다."

#: ../Doc/library/multiprocessing.rst:1059
msgid "This is called automatically when the connection is garbage collected."
msgstr "연결이 가비지 수집될 때 자동으로 호출됩니다."

#: ../Doc/library/multiprocessing.rst:1063
msgid "Return whether there is any data available to be read."
msgstr "읽어 들일 데이터가 있는지를 돌려줍니다."

#: ../Doc/library/multiprocessing.rst:1065
msgid ""
"If *timeout* is not specified then it will return immediately.  If "
"*timeout* is a number then this specifies the maximum time in seconds to "
"block.  If *timeout* is ``None`` then an infinite timeout is used."
msgstr ""
"*timeout* 을 지정하지 않으면 즉시 반환됩니다. *timeout* 이 숫자면 블록할 최대 시간(초)을 지정합니다. "
"*timeout* 이 ``None`` 이면 시간제한이 없습니다."

#: ../Doc/library/multiprocessing.rst:1069
msgid ""
"Note that multiple connection objects may be polled at once by using "
":func:`multiprocessing.connection.wait`."
msgstr ""
"여러 개의 연결 객체를 :func:`multiprocessing.connection.wait` 을 사용하여 한 번에 폴링 할 수 "
"있습니다."

#: ../Doc/library/multiprocessing.rst:1074
msgid "Send byte data from a :term:`bytes-like object` as a complete message."
msgstr ":term:`바이트열류 객체 <bytes-like object>` 의 바이트 데이터를 하나의 완전한 메시지로 보냅니다."

#: ../Doc/library/multiprocessing.rst:1076
msgid ""
"If *offset* is given then data is read from that position in *buffer*.  "
"If *size* is given then that many bytes will be read from buffer.  Very "
"large buffers (approximately 32 MiB+, though it depends on the OS) may "
"raise a :exc:`ValueError` exception"
msgstr ""
"*offset* 이 주어지면 *buffer* 의 해당 위치부터 데이터를 읽습니다. *size* 가 주어지면 그만큼의 바이트를 버퍼에서 "
"읽습니다. 매우 큰 버퍼(약 32 MiB+, OS에 따라 다릅니다)는 :exc:`ValueError` 예외를 발생시킬 수 있습니다"

#: ../Doc/library/multiprocessing.rst:1083
msgid ""
"Return a complete message of byte data sent from the other end of the "
"connection as a string.  Blocks until there is something to receive. "
"Raises :exc:`EOFError` if there is nothing left to receive and the other "
"end has closed."
msgstr ""
"접속의 반대편 끝에서 송신된 바이트 데이터의 완전한 메시지를 문자열로 돌려줍니다. 뭔가 수신할 때까지 블록합니다. 수신할 내용이 없고 "
"반대편 끝이 닫혔으면 :exc:`EOFError`\\를 발생시킵니다."

#: ../Doc/library/multiprocessing.rst:1088
msgid ""
"If *maxlength* is specified and the message is longer than *maxlength* "
"then :exc:`OSError` is raised and the connection will no longer be "
"readable."
msgstr ""
"*maxlength* 가 지정되고 메시지가 *maxlength* 보다 길면 :exc:`OSError` 가 발생하고 연결은 더는 읽을 수 "
"없게 됩니다."

#: ../Doc/library/multiprocessing.rst:1092
msgid ""
"This function used to raise :exc:`IOError`, which is now an alias of "
":exc:`OSError`."
msgstr "이 함수는 :exc:`IOError` 를 발생시켜왔는데, 이제는 :exc:`OSError` 의 별칭입니다."

#: ../Doc/library/multiprocessing.rst:1099
msgid ""
"Read into *buffer* a complete message of byte data sent from the other "
"end of the connection and return the number of bytes in the message.  "
"Blocks until there is something to receive.  Raises :exc:`EOFError` if "
"there is nothing left to receive and the other end was closed."
msgstr ""
"연결의 반대편 끝에서 보낸 바이트 데이터의 전체 메시지를 *buffer* 로 읽어 들이고, 메시지의 바이트 수를 반환합니다. 뭔가 수신할"
" 때까지 블록합니다. 수신할 내용이 없고 반대편 끝이 닫혔으면 :exc:`EOFError`\\를 발생시킵니다."

#: ../Doc/library/multiprocessing.rst:1105
msgid ""
"*buffer* must be a writable :term:`bytes-like object`.  If *offset* is "
"given then the message will be written into the buffer from that "
"position.  Offset must be a non-negative integer less than the length of "
"*buffer* (in bytes)."
msgstr ""
"*buffer* 는 쓰기 가능한 :term:`바이트열류 객체 <bytes-like object>` 여야 합니다. *offset* 이 "
"지정되면, 버퍼의 그 위치로부터 메시지를 씁니다. offset은 *buffer* 길이보다 작은 음수가 아닌 정수여야 합니다 (바이트 "
"단위)."

#: ../Doc/library/multiprocessing.rst:1110
msgid ""
"If the buffer is too short then a :exc:`BufferTooShort` exception is "
"raised and the complete message is available as ``e.args[0]`` where ``e``"
" is the exception instance."
msgstr ""
"버퍼가 너무 작으면 :exc:`BufferTooShort` 예외가 발생하고, 완전한 메시지는 ``e.args[0]`` 으로 제공되는데, "
"여기서 ``e`` 는 예외 인스턴스입니다."

#: ../Doc/library/multiprocessing.rst:1114
msgid ""
"Connection objects themselves can now be transferred between processes "
"using :meth:`Connection.send` and :meth:`Connection.recv`."
msgstr ""
"이제 연결 객체 자체를 :meth:`Connection.send` 와 :meth:`Connection.recv` 를 사용하여 프로세스 "
"간에 전송할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1118
msgid ""
"Connection objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the"
" connection object, and :meth:`~contextmanager.__exit__` calls "
":meth:`close`."
msgstr ""
"이제 연결 객체는 컨텍스트 관리 프로토콜을 지원합니다 -- :ref:`typecontextmanager`\\를 보세요. "
":meth:`~contextmanager.__enter__` 는 연결 객체를 반환하고, "
":meth:`~contextmanager.__exit__` 는 :meth:`close`\\를 호출합니다."

#: ../Doc/library/multiprocessing.rst:1123
msgid "For example:"
msgstr "예를 들어:"

#: ../Doc/library/multiprocessing.rst:1147
msgid ""
"The :meth:`Connection.recv` method automatically unpickles the data it "
"receives, which can be a security risk unless you can trust the process "
"which sent the message."
msgstr ""
":meth:`Connection.recv` 메서드는 수신한 데이터를 자동으로 언 피클 합니다. 메시지를 보낸 프로세스를 신뢰할 수 없다면"
" 보안상 위험 할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1151
msgid ""
"Therefore, unless the connection object was produced using :func:`Pipe` "
"you should only use the :meth:`~Connection.recv` and "
":meth:`~Connection.send` methods after performing some sort of "
"authentication.  See :ref:`multiprocessing-auth-keys`."
msgstr ""
"따라서, 연결 객체가 :func:`Pipe`\\를 사용하여 생성되지 않았다면, 일종의 인증을 수행한 후에만 "
":meth:`~Connection.recv` 및 :meth:`~Connection.send` 메서드를 사용해야 합니다. "
":ref:`multiprocessing-auth-keys`\\를 참조하세요."

#: ../Doc/library/multiprocessing.rst:1158
msgid ""
"If a process is killed while it is trying to read or write to a pipe then"
" the data in the pipe is likely to become corrupted, because it may "
"become impossible to be sure where the message boundaries lie."
msgstr ""
"프로세스가 파이프에 읽거나 쓰려고 할 때 죽으면, 파이프의 데이터가 손상될 가능성이 있습니다. 메시지 경계가 어디에 있는지 확신할 수 "
"없는 상태가 될 가능성이 있기 때문입니다."

#: ../Doc/library/multiprocessing.rst:1164
msgid "Synchronization primitives"
msgstr "동기화 프리미티브"

#: ../Doc/library/multiprocessing.rst:1168
msgid ""
"Generally synchronization primitives are not as necessary in a "
"multiprocess program as they are in a multithreaded program.  See the "
"documentation for :mod:`threading` module."
msgstr ""
"일반적으로 다중 프로세스 프로그램에서는 동기화 프리미티브가 다중 스레드 프로그램에서만큼 필요하지는 않습니다. "
":mod:`threading` 모듈에 대한 설명서를 참조하십시오."

#: ../Doc/library/multiprocessing.rst:1172
msgid ""
"Note that one can also create synchronization primitives by using a "
"manager object -- see :ref:`multiprocessing-managers`."
msgstr ""
"관리자 객체를 사용하여 동기화 프리미티브를 생성할 수도 있습니다 -- :ref:`multiprocessing-managers`\\를 "
"참조하세요."

#: ../Doc/library/multiprocessing.rst:1177
msgid "A barrier object: a clone of :class:`threading.Barrier`."
msgstr "배리어(barrier) 객체: :class:`threading.Barrier` 의 복제본."

#: ../Doc/library/multiprocessing.rst:1183
msgid ""
"A bounded semaphore object: a close analog of "
":class:`threading.BoundedSemaphore`."
msgstr "제한된 세마포어 객체: :class:`threading.BoundedSemaphore` 과 유사한 대응 물."

#: ../Doc/library/multiprocessing.rst:1186
#: ../Doc/library/multiprocessing.rst:1324
msgid ""
"A solitary difference from its close analog exists: its ``acquire`` "
"method's first argument is named *block*, as is consistent with "
":meth:`Lock.acquire`."
msgstr ""
"대응 물과 한 가지 차이가 있습니다: ``acquire`` 메서드의 첫 번째 인자에 *block* 이라는 이름을 사용해서 "
":meth:`Lock.acquire` 와의 일관성을 유지합니다."

#: ../Doc/library/multiprocessing.rst:1190
msgid ""
"On Mac OS X, this is indistinguishable from :class:`Semaphore` because "
"``sem_getvalue()`` is not implemented on that platform."
msgstr ""
"Mac OS X에서, ``sem_getvalue()`` 가 해당 플랫폼에 구현되어 있지 않기 때문에 "
":class:`Semaphore`\\와 구별되지 않습니다."

#: ../Doc/library/multiprocessing.rst:1195
msgid "A condition variable: an alias for :class:`threading.Condition`."
msgstr "조건 변수: :class:`threading.Condition` 의 별칭."

#: ../Doc/library/multiprocessing.rst:1197
msgid ""
"If *lock* is specified then it should be a :class:`Lock` or "
":class:`RLock` object from :mod:`multiprocessing`."
msgstr ""
"*lock* 을 지정할 때는 :mod:`multiprocessing` 의 :class:`Lock` 이나 :class:`RLock` "
"객체여야 합니다."

#: ../Doc/library/multiprocessing.rst:1200
#: ../Doc/library/multiprocessing.rst:1734
msgid "The :meth:`~threading.Condition.wait_for` method was added."
msgstr ":meth:`~threading.Condition.wait_for` 메서드가 추가되었습니다."

#: ../Doc/library/multiprocessing.rst:1205
msgid "A clone of :class:`threading.Event`."
msgstr ":class:`threading.Event` 의 복제본."

#: ../Doc/library/multiprocessing.rst:1210
msgid ""
"A non-recursive lock object: a close analog of :class:`threading.Lock`. "
"Once a process or thread has acquired a lock, subsequent attempts to "
"acquire it from any process or thread will block until it is released; "
"any process or thread may release it.  The concepts and behaviors of "
":class:`threading.Lock` as it applies to threads are replicated here in "
":class:`multiprocessing.Lock` as it applies to either processes or "
"threads, except as noted."
msgstr ""
"비 재귀적 록 객체: :class:`threading.Lock` 과 유사한 대응 물. 일단 프로세스 또는 스레드가 록을 획득하면, "
"프로세스 또는 스레드에서 록을 획득하려는 후속 시도는 록이 해제될 때까지 블록 됩니다; 모든 프로세스 또는 스레드가 이를 해제할 수 "
"있습니다. 스레드에 적용되는 :class:`threading.Lock` 의 개념과 동작은, 명시된 경우를 제외하고, "
":class:`multiprocessing.Lock` 를 통해 프로세스나 스레드에 그대로 적용됩니다."

#: ../Doc/library/multiprocessing.rst:1218
msgid ""
"Note that :class:`Lock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.Lock`` initialized with a "
"default context."
msgstr ""
":class:`Lock` 은 실제로 기본 컨텍스트로 초기화된 ``multiprocessing.synchronize.Lock`` 의 "
"인스턴스를 반환하는 팩토리 함수입니다."

#: ../Doc/library/multiprocessing.rst:1222
msgid ""
":class:`Lock` supports the :term:`context manager` protocol and thus may "
"be used in :keyword:`with` statements."
msgstr ""
":class:`Lock` 은 :term:`컨텍스트 관리자 <context manager>` 프로토콜을 지원하므로 "
":keyword:`with` 문에서 사용될 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1227
#: ../Doc/library/multiprocessing.rst:1278
msgid "Acquire a lock, blocking or non-blocking."
msgstr "블록하거나 블록하지 않는 방식으로 록을 획득합니다."

#: ../Doc/library/multiprocessing.rst:1229
msgid ""
"With the *block* argument set to ``True`` (the default), the method call "
"will block until the lock is in an unlocked state, then set it to locked "
"and return ``True``.  Note that the name of this first argument differs "
"from that in :meth:`threading.Lock.acquire`."
msgstr ""
"*block* 인자가 ``True`` (기본값) 로 설정되면, 메서드 호출은 록이 해제 상태가 될 때까지 블록 한 다음, 잠금 상태로 "
"만들고 ``True`` 를 반환합니다. 이 첫 번째 인자의 이름은 :meth:`threading.Lock.acquire` 와 다르다는 "
"것에 유의하세요."

#: ../Doc/library/multiprocessing.rst:1234
msgid ""
"With the *block* argument set to ``False``, the method call does not "
"block.  If the lock is currently in a locked state, return ``False``; "
"otherwise set the lock to a locked state and return ``True``."
msgstr ""
"*block* 인자가 ``False`` 로 설정되면, 메서드 호출은 블록 되지 않습니다. 록이 현재 잠금 상태면 ``False`` 를 "
"반환합니다. 그렇지 않으면 록을 잠금 상태로 설정하고 ``True`` 를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1238
msgid ""
"When invoked with a positive, floating-point value for *timeout*, block "
"for at most the number of seconds specified by *timeout* as long as the "
"lock can not be acquired.  Invocations with a negative value for "
"*timeout* are equivalent to a *timeout* of zero.  Invocations with a "
"*timeout* value of ``None`` (the default) set the timeout period to "
"infinite.  Note that the treatment of negative or ``None`` values for "
"*timeout* differs from the implemented behavior in "
":meth:`threading.Lock.acquire`.  The *timeout* argument has no practical "
"implications if the *block* argument is set to ``False`` and is thus "
"ignored.  Returns ``True`` if the lock has been acquired or ``False`` if "
"the timeout period has elapsed."
msgstr ""
"*timeout* 에 대해 양의 부동 소수점 값을 사용하여 호출하는 경우, 록을 얻을 수 없는 한 최대 *timeout* 으로 지정된 "
"시간(초) 동안 블록합니다. *timeout* 을 음수 값으로 호출하는 것은 *timeout* 에 0을 주는 것과 같습니다. "
"*timeout* 값이 ``None`` (기본값) 인 호출은 제한 시간을 무한대로 설정합니다. *timeout* 에 대한 음수와 "
"``None`` 값의 처리는 :meth:`threading.Lock.acquire` 에서 구현된 동작과 다르다는 것에 주의하십시오. "
"*timeout* 인자는 *block* 인자가 ``False`` 로 설정되면 실제적인 의미는 없고 무시됩니다. 록이 획득되면 "
"``True`` 를 돌려주고, 제한 시간 초과가 발생하면 ``False`` 를 돌려줍니다."

#: ../Doc/library/multiprocessing.rst:1253
msgid ""
"Release a lock.  This can be called from any process or thread, not only "
"the process or thread which originally acquired the lock."
msgstr "록을 해제합니다. 이것은 원래 록을 획득한 프로세스나 스레드뿐만 아니라 모든 프로세스나 스레드에서 호출 할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1256
msgid ""
"Behavior is the same as in :meth:`threading.Lock.release` except that "
"when invoked on an unlocked lock, a :exc:`ValueError` is raised."
msgstr ""
"동작은 :meth:`threading.Lock.release` 와 같지만, 해제된 록에서 호출될 때 :exc:`ValueError` 가 "
"발생한다는 점만 다릅니다."

#: ../Doc/library/multiprocessing.rst:1262
msgid ""
"A recursive lock object: a close analog of :class:`threading.RLock`.  A "
"recursive lock must be released by the process or thread that acquired "
"it. Once a process or thread has acquired a recursive lock, the same "
"process or thread may acquire it again without blocking; that process or "
"thread must release it once for each time it has been acquired."
msgstr ""
"재귀적 록 객체: :class:`threading.RLock` 과 유사한 대응 물. 재귀적 록은 획득한 프로세스 또는 스레드에 의해 "
"해제되어야 합니다. 일단 프로세스나 스레드가 재귀적 록을 획득하면, 같은 프로세스나 스레드가 블록 없이 다시 획득할 수 있습니다; 해당 "
"프로세스나 스레드는 획득할 때마다 한 번 해제해야 합니다."

#: ../Doc/library/multiprocessing.rst:1268
msgid ""
"Note that :class:`RLock` is actually a factory function which returns an "
"instance of ``multiprocessing.synchronize.RLock`` initialized with a "
"default context."
msgstr ""
":class:`RLock` 은 실제로 기본 컨텍스트로 초기화된 ``multiprocessing.synchronize.RLock`` 의 "
"인스턴스를 반환하는 팩토리 함수입니다."

#: ../Doc/library/multiprocessing.rst:1272
msgid ""
":class:`RLock` supports the :term:`context manager` protocol and thus may"
" be used in :keyword:`with` statements."
msgstr ""
":class:`RLock` 은 :term:`컨텍스트 관리자 <context manager>` 프로토콜을 지원하므로 "
":keyword:`with` 문에서 사용될 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1280
msgid ""
"When invoked with the *block* argument set to ``True``, block until the "
"lock is in an unlocked state (not owned by any process or thread) unless "
"the lock is already owned by the current process or thread.  The current "
"process or thread then takes ownership of the lock (if it does not "
"already have ownership) and the recursion level inside the lock "
"increments by one, resulting in a return value of ``True``.  Note that "
"there are several differences in this first argument's behavior compared "
"to the implementation of :meth:`threading.RLock.acquire`, starting with "
"the name of the argument itself."
msgstr ""
"*block* 인자를 ``True`` 로 설정해서 호출하면, 록이 현재 프로세스나 스레드가 이미 획득한 상태가 아니면 록이 (어떤 "
"프로세스나 스레드도 획득하지 않은) 록 해제 상태가 될 때까지 블록합니다. 이후에 현재 프로세스나 스레드가 (소유권이 아직 없는 경우) "
"록 소유권을 얻게 되며 록 내 재귀 수준이 1 증가하고 ``True`` 를 반환합니다. 이 첫 번째 인자의 동작에는, 인자의 이름부터 "
"시작해서 :meth:`threading.RLock.acquire` 구현과 비교되는 몇 가지 차이점이 있습니다."

#: ../Doc/library/multiprocessing.rst:1290
msgid ""
"When invoked with the *block* argument set to ``False``, do not block. If"
" the lock has already been acquired (and thus is owned) by another "
"process or thread, the current process or thread does not take ownership "
"and the recursion level within the lock is not changed, resulting in a "
"return value of ``False``.  If the lock is in an unlocked state, the "
"current process or thread takes ownership and the recursion level is "
"incremented, resulting in a return value of ``True``."
msgstr ""
"*block* 인자를 ``False`` 로 설정해서 호출하면 블록하지 않습니다. 록이 이미 다른 프로세스나 스레드에 의해 획득되었으면 "
"(그래서 소유하고 있으면), 현재 프로세스나 스레드는 소유권을 갖지 않으며 록 내 재귀 수준은 변경되지 않고 ``False`` 를 "
"반환합니다. 록이 해제 상태에 있으면, 현재 프로세스 또는 스레드가 소유권을 가져오며 재귀 수준이 증가하고 ``True`` 를 "
"반환합니다."

#: ../Doc/library/multiprocessing.rst:1298
msgid ""
"Use and behaviors of the *timeout* argument are the same as in "
":meth:`Lock.acquire`.  Note that some of these behaviors of *timeout* "
"differ from the implemented behaviors in :meth:`threading.RLock.acquire`."
msgstr ""
"*timeout* 인자의 사용법과 동작은 :meth:`Lock.acquire` 와 같습니다. *timeout* 의 이러한 동작 중 일부는"
" :meth:`threading.RLock.acquire` 에서 구현된 동작과 다르다는 것에 주의하십시오."

#: ../Doc/library/multiprocessing.rst:1305
msgid ""
"Release a lock, decrementing the recursion level.  If after the decrement"
" the recursion level is zero, reset the lock to unlocked (not owned by "
"any process or thread) and if any other processes or threads are blocked "
"waiting for the lock to become unlocked, allow exactly one of them to "
"proceed.  If after the decrement the recursion level is still nonzero, "
"the lock remains locked and owned by the calling process or thread."
msgstr ""
"재귀 수준을 감소시키면서 록을 해제합니다. 감소 후에 재귀 수준이 0이면, 록을 해제 상태(어떤 프로세스나 스레드에도 소유되지 않음)로 "
"재설정하고, 다른 프로세스나 스레드가 록이 해제될 때까지 기다리며 블록하고 있는 경우 해당 프로세스나 스레드 중 정확히 하나가 계속 "
"진행하도록 허용합니다. 감소 후에 재귀 수준이 여전히 0이 아닌 경우, 록은 획득된 상태로 남고 호출한 프로세스나 스레드에 의해 "
"소유됩니다."

#: ../Doc/library/multiprocessing.rst:1313
msgid ""
"Only call this method when the calling process or thread owns the lock. "
"An :exc:`AssertionError` is raised if this method is called by a process "
"or thread other than the owner or if the lock is in an unlocked (unowned)"
" state.  Note that the type of exception raised in this situation differs"
" from the implemented behavior in :meth:`threading.RLock.release`."
msgstr ""
"호출한 프로세스나 스레드가 록을 소유하고 있을 때만 이 메서드를 호출하십시오. 이 메서드가 소유자가 아닌 프로세스나 스레드에 의해 "
"호출되거나, 록이 해제 (소유되지 않은) 상태면 :exc:`AssertionError` 가 발생합니다. 이 상황에서 발생하는 예외 형은 "
":meth:`threading.RLock.release` 에서 구현된 동작과 다릅니다."

#: ../Doc/library/multiprocessing.rst:1322
msgid "A semaphore object: a close analog of :class:`threading.Semaphore`."
msgstr "세마포어 객체: :class:`threading.Semaphore` 와 유사한 대응 물."

#: ../Doc/library/multiprocessing.rst:1329
msgid ""
"On Mac OS X, ``sem_timedwait`` is unsupported, so calling ``acquire()`` "
"with a timeout will emulate that function's behavior using a sleeping "
"loop."
msgstr ""
"Mac OS X에서, ``sem_timedwait`` 가 지원되지 않기 때문에, ``acquire()`` 를 시간제한 있게 호출하면 "
"잠자는 루프를 사용하여 해당 함수의 동작을 흉내 냅니다."

#: ../Doc/library/multiprocessing.rst:1334
msgid ""
"If the SIGINT signal generated by :kbd:`Ctrl-C` arrives while the main "
"thread is blocked by a call to :meth:`BoundedSemaphore.acquire`, "
":meth:`Lock.acquire`, :meth:`RLock.acquire`, :meth:`Semaphore.acquire`, "
":meth:`Condition.acquire` or :meth:`Condition.wait` then the call will be"
" immediately interrupted and :exc:`KeyboardInterrupt` will be raised."
msgstr ""
"메인 스레드가 :meth:`BoundedSemaphore.acquire`, :meth:`Lock.acquire`, "
":meth:`RLock.acquire`, :meth:`Semaphore.acquire`, :meth:`Condition.acquire` "
"또는 :meth:`Condition.wait` 호출 때문에 블록 된 동안, :kbd:`Ctrl-C` 에 의해 만들어진 SIGINT "
"시그널이 도착하면, 호출이 즉시 중단되고 :exc:`KeyboardInterrupt` 가 발생합니다."

#: ../Doc/library/multiprocessing.rst:1340
msgid ""
"This differs from the behaviour of :mod:`threading` where SIGINT will be "
"ignored while the equivalent blocking calls are in progress."
msgstr "이것은 :mod:`threading` 의 동작과는 다른데, SIGINT는 해당 블로킹 호출이 진행되는 동안 무시됩니다."

#: ../Doc/library/multiprocessing.rst:1345
msgid ""
"Some of this package's functionality requires a functioning shared "
"semaphore implementation on the host operating system. Without one, the "
":mod:`multiprocessing.synchronize` module will be disabled, and attempts "
"to import it will result in an :exc:`ImportError`. See :issue:`3770` for "
"additional information."
msgstr ""
"이 패키지의 기능 중 일부는 호스트 운영 체제의 작동하는 공유 세마포어 구현을 요구합니다. 그런 것이 없으면, "
":mod:`multiprocessing.synchronize` 모듈이 비활성화되고, 임포트하려고 하면 :exc:`ImportError` "
"를 일으킵니다. 자세한 내용은 :issue:`3770`\\을 참조하십시오."

#: ../Doc/library/multiprocessing.rst:1353
msgid "Shared :mod:`ctypes` Objects"
msgstr "공유 :mod:`ctypes` 객체"

#: ../Doc/library/multiprocessing.rst:1355
msgid ""
"It is possible to create shared objects using shared memory which can be "
"inherited by child processes."
msgstr "자식 프로세스가 상속할 수 있는 공유 메모리를 사용하여 공유 객체를 만들 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1360
msgid ""
"Return a :mod:`ctypes` object allocated from shared memory.  By default "
"the return value is actually a synchronized wrapper for the object.  The "
"object itself can be accessed via the *value* attribute of a "
":class:`Value`."
msgstr ""
"공유 메모리에 할당된 :mod:`ctypes` 객체를 반환합니다. 기본적으로 반환 값은, 사실 객체에 대한 동기화 된 래퍼입니다. 객체 "
"자체는 :class:`Value` 의 *value* 어트리뷰트를 통해 접근 할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1364
#: ../Doc/library/multiprocessing.rst:1451
msgid ""
"*typecode_or_type* determines the type of the returned object: it is "
"either a ctypes type or a one character typecode of the kind used by the "
":mod:`array` module.  *\\*args* is passed on to the constructor for the "
"type."
msgstr ""
"*typecode_or_type* 은 반환된 객체의 형을 결정합니다: ctypes 형이거나 :mod:`array` 모듈에 의해 사용되는 "
"종류의 한 문자 typecode입니다. *\\*args* 는 형의 생성자로 전달됩니다."

#: ../Doc/library/multiprocessing.rst:1368
msgid ""
"If *lock* is ``True`` (the default) then a new recursive lock object is "
"created to synchronize access to the value.  If *lock* is a :class:`Lock`"
" or :class:`RLock` object then that will be used to synchronize access to"
" the value.  If *lock* is ``False`` then access to the returned object "
"will not be automatically protected by a lock, so it will not necessarily"
" be \"process-safe\"."
msgstr ""
"*lock* 이 ``True`` (기본값) 면 값에 대한 액세스를 동기화하기 위해 새 재귀적 록 객체가 생성됩니다. *lock* 이 "
":class:`Lock` 또는 :class:`RLock` 객체인 경우, 이 값이 값에 대한 액세스를 동기화하는 데 사용됩니다. "
"*lock* 이 ``False`` 면, 반환된 객체에 대한 액세스는 록에 의해 자동으로 보호되지 않으므로 \"프로세스 안전\" 하지 "
"않습니다."

#: ../Doc/library/multiprocessing.rst:1375
msgid ""
"Operations like ``+=`` which involve a read and write are not atomic.  So"
" if, for instance, you want to atomically increment a shared value it is "
"insufficient to just do ::"
msgstr ""
"읽기와 쓰기를 포함하는 ``+=`` 와 같은 연산은 원자 적(atomic)이지 않습니다. 따라서, 예를 들어, 공유 값을 원자 적으로 "
"증가시키려면, 다음과 같이 하는 것으로는 충분하지 않습니다::"

#: ../Doc/library/multiprocessing.rst:1381
msgid ""
"Assuming the associated lock is recursive (which it is by default) you "
"can instead do ::"
msgstr "연관된 록이 재귀적이라고 가정하면 (기본적으로 그렇습니다), 대신 다음과 같이 할 수 있습니다 ::"

#: ../Doc/library/multiprocessing.rst:1387
#: ../Doc/library/multiprocessing.rst:1477
#: ../Doc/library/multiprocessing.rst:1492
msgid "Note that *lock* is a keyword-only argument."
msgstr "*lock* 은 키워드 전용 인자입니다."

#: ../Doc/library/multiprocessing.rst:1391
msgid ""
"Return a ctypes array allocated from shared memory.  By default the "
"return value is actually a synchronized wrapper for the array."
msgstr "공유 메모리에서 할당된 ctypes 배열을 반환합니다. 기본적으로 반환 값은, 사실 배열에 대한 동기화 된 래퍼입니다."

#: ../Doc/library/multiprocessing.rst:1394
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind"
" used by the :mod:`array` module.  If *size_or_initializer* is an "
"integer, then it determines the length of the array, and the array will "
"be initially zeroed. Otherwise, *size_or_initializer* is a sequence which"
" is used to initialize the array and whose length determines the length "
"of the array."
msgstr ""
"*typecode_or_type* 은 반환된 배열의 요소의 형을 결정합니다: ctypes 형이거나 :mod:`array` 모듈에 의해 "
"사용되는 종류의 한 문자 typecode입니다. *size_or_initializer* 가 정수면, 배열의 길이를 결정하고 배열은 0으로"
" 초기화됩니다. 그렇지 않으면, *size_or_initializer* 는 배열을 초기화하는 데 사용되는 시퀀스고, 길이는 배열의 길이를"
" 결정합니다."

#: ../Doc/library/multiprocessing.rst:1401
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a :class:`Lock` or "
":class:`RLock` object then that will be used to synchronize access to the"
" value.  If *lock* is ``False`` then access to the returned object will "
"not be automatically protected by a lock, so it will not necessarily be "
"\"process-safe\"."
msgstr ""
"*lock* 이 ``True`` (기본값) 면 값에 대한 액세스를 동기화하기 위해 새 록 객체가 생성됩니다. *lock* 이 "
":class:`Lock` 또는 :class:`RLock` 객체인 경우, 이 값이 값에 대한 액세스를 동기화하는 데 사용됩니다. "
"*lock* 이 ``False`` 면, 반환된 객체에 대한 액세스는 록에 의해 자동으로 보호되지 않으므로 \"프로세스 안전\" 하지 "
"않습니다."

#: ../Doc/library/multiprocessing.rst:1408
msgid "Note that *lock* is a keyword only argument."
msgstr "*lock* 은 키워드 전용 인자입니다."

#: ../Doc/library/multiprocessing.rst:1410
msgid ""
"Note that an array of :data:`ctypes.c_char` has *value* and *raw* "
"attributes which allow one to use it to store and retrieve strings."
msgstr ""
":data:`ctypes.c_char` 의 배열은 *value* 와 *raw* 어트리뷰트를 가지고 있습니다. 이 어트리뷰트를 사용하여 "
"문자열을 저장하고 꺼낼 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1415
msgid "The :mod:`multiprocessing.sharedctypes` module"
msgstr ":mod:`multiprocessing.sharedctypes` 모듈"

#: ../Doc/library/multiprocessing.rst:1420
msgid ""
"The :mod:`multiprocessing.sharedctypes` module provides functions for "
"allocating :mod:`ctypes` objects from shared memory which can be "
"inherited by child processes."
msgstr ""
":mod:`multiprocessing.sharedctypes` 모듈은 자식 프로세스에 의해 상속될 수 있는 공유 메모리에 "
":mod:`ctypes` 객체를 할당하는 기능을 제공합니다."

#: ../Doc/library/multiprocessing.rst:1426
msgid ""
"Although it is possible to store a pointer in shared memory remember that"
" this will refer to a location in the address space of a specific "
"process. However, the pointer is quite likely to be invalid in the "
"context of a second process and trying to dereference the pointer from "
"the second process may cause a crash."
msgstr ""
"공유 메모리에 포인터를 저장할 수는 있지만, 특정 프로세스의 주소 공간에 있는 위치를 참조하게 됩니다. 그러나 포인터는 두 번째 "
"프로세스의 컨텍스트에서는 유효하지 않을 가능성이 커서, 두 번째 프로세스에서 포인터를 역 참조하려고 하면 충돌이 일어날 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1434
msgid "Return a ctypes array allocated from shared memory."
msgstr "공유 메모리에 할당된 ctypes 배열을 반환합니다."

#: ../Doc/library/multiprocessing.rst:1436
msgid ""
"*typecode_or_type* determines the type of the elements of the returned "
"array: it is either a ctypes type or a one character typecode of the kind"
" used by the :mod:`array` module.  If *size_or_initializer* is an integer"
" then it determines the length of the array, and the array will be "
"initially zeroed. Otherwise *size_or_initializer* is a sequence which is "
"used to initialize the array and whose length determines the length of "
"the array."
msgstr ""
"*typecode_or_type* 은 반환된 배열의 요소의 형을 결정합니다: ctypes 형이거나 :mod:`array` 모듈에 의해 "
"사용되는 종류의 한 문자 typecode입니다. *size_or_initializer* 가 정수면, 배열의 길이를 결정하고 배열은 0으로"
" 초기화됩니다. 그렇지 않으면, *size_or_initializer* 는 배열을 초기화하는 데 사용되는 시퀀스고, 길이는 배열의 길이를"
" 결정합니다."

#: ../Doc/library/multiprocessing.rst:1443
msgid ""
"Note that setting and getting an element is potentially non-atomic -- use"
" :func:`Array` instead to make sure that access is automatically "
"synchronized using a lock."
msgstr ""
"요소를 쓰고 읽는 것은 잠재적으로 원자 적이지 않습니다 -- 액세스가 록을 사용하여 자동으로 동기화되기 원하면 "
":func:`Array`\\를 대신 사용하세요."

#: ../Doc/library/multiprocessing.rst:1449
msgid "Return a ctypes object allocated from shared memory."
msgstr "공유 메모리에 할당된 ctypes 객체를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1455
msgid ""
"Note that setting and getting the value is potentially non-atomic -- use "
":func:`Value` instead to make sure that access is automatically "
"synchronized using a lock."
msgstr ""
"값을 쓰고 읽는 것은 잠재적으로 원자 적이지 않습니다 -- 액세스가 록을 사용하여 자동으로 동기화되기 원하면 "
":func:`Value`\\를 대신 사용하세요."

#: ../Doc/library/multiprocessing.rst:1459
msgid ""
"Note that an array of :data:`ctypes.c_char` has ``value`` and ``raw`` "
"attributes which allow one to use it to store and retrieve strings -- see"
" documentation for :mod:`ctypes`."
msgstr ""
":data:`ctypes.c_char` 의 배열은 *value* 와 *raw* 어트리뷰트를 가지고 있습니다. 이 어트리뷰트를 사용하여 "
"문자열을 저장하고 꺼낼 수 있습니다 -- :mod:`ctypes` 설명서를 보십시오."

#: ../Doc/library/multiprocessing.rst:1465
msgid ""
"The same as :func:`RawArray` except that depending on the value of *lock*"
" a process-safe synchronization wrapper may be returned instead of a raw "
"ctypes array."
msgstr ""
"*lock* 값에 따라, 날 ctypes 배열 대신 프로세스 안전한 동기화 래퍼가 반환될 수 있다는 것을 제외하고는 "
":func:`RawArray` 와 같습니다."

#: ../Doc/library/multiprocessing.rst:1469
#: ../Doc/library/multiprocessing.rst:1485
msgid ""
"If *lock* is ``True`` (the default) then a new lock object is created to "
"synchronize access to the value.  If *lock* is a "
":class:`~multiprocessing.Lock` or :class:`~multiprocessing.RLock` object "
"then that will be used to synchronize access to the value.  If *lock* is "
"``False`` then access to the returned object will not be automatically "
"protected by a lock, so it will not necessarily be \"process-safe\"."
msgstr ""
"*lock* 이 ``True`` (기본값) 면 값에 대한 액세스를 동기화하기 위해 새 록 객체가 생성됩니다. *lock* 이 "
":class:`~multiprocessing.Lock` 또는 :class:`~multiprocessing.RLock` 객체인 경우, 이 "
"값이 값에 대한 액세스를 동기화하는 데 사용됩니다. *lock* 이 ``False`` 면, 반환된 객체에 대한 액세스는 록에 의해 "
"자동으로 보호되지 않으므로 \"프로세스 안전\" 하지 않습니다."

#: ../Doc/library/multiprocessing.rst:1481
msgid ""
"The same as :func:`RawValue` except that depending on the value of *lock*"
" a process-safe synchronization wrapper may be returned instead of a raw "
"ctypes object."
msgstr ""
"*lock* 값에 따라, 날 ctypes 객체 대신 프로세스 안전한 동기화 래퍼가 반환될 수 있다는 것을 제외하고는 "
":func:`RawValue` 와 같습니다."

#: ../Doc/library/multiprocessing.rst:1496
msgid ""
"Return a ctypes object allocated from shared memory which is a copy of "
"the ctypes object *obj*."
msgstr "공유 메모리에서 할당된 ctypes 객체를 반환합니다. 이 객체는 ctypes 객체 *obj* 의 복사본입니다."

#: ../Doc/library/multiprocessing.rst:1501
msgid ""
"Return a process-safe wrapper object for a ctypes object which uses "
"*lock* to synchronize access.  If *lock* is ``None`` (the default) then a"
" :class:`multiprocessing.RLock` object is created automatically."
msgstr ""
"*lock* 을 사용하여 액세스를 동기화하는 ctypes 객체에 대한 프로세스 안전한 래퍼 객체를 반환합니다. *lock* 이 "
"``None`` (기본값)이면 :class:`multiprocessing.RLock` 객체가 자동으로 생성됩니다."

#: ../Doc/library/multiprocessing.rst:1505
msgid ""
"A synchronized wrapper will have two methods in addition to those of the "
"object it wraps: :meth:`get_obj` returns the wrapped object and "
":meth:`get_lock` returns the lock object used for synchronization."
msgstr ""
"동기화 래퍼는 래핑 된 객체의 메서드 외에도 두 개의 메서드를 더 갖습니다: :meth:`get_obj` 는 래핑 된 객체를 반환하고, "
":meth:`get_lock` 은 동기화에 사용되는 록 객체를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1509
msgid ""
"Note that accessing the ctypes object through the wrapper can be a lot "
"slower than accessing the raw ctypes object."
msgstr "래퍼를 통해 ctypes 객체에 액세스하는 것은, 날 ctypes 객체에 액세스하는 것보다 훨씬 느릴 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1512
msgid "Synchronized objects support the :term:`context manager` protocol."
msgstr "동기화된 객체는 :term:`컨텍스트 관리자 <context manager>` 프로토콜을 지원합니다."

#: ../Doc/library/multiprocessing.rst:1516
msgid ""
"The table below compares the syntax for creating shared ctypes objects "
"from shared memory with the normal ctypes syntax.  (In the table "
"``MyStruct`` is some subclass of :class:`ctypes.Structure`.)"
msgstr ""
"아래 표는 공유 메모리에 공유 ctypes 객체를 만드는 문법과 일반적인 ctypes 문법을 비교합니다. (표에서 ``MyStruct``"
" 는 :class:`ctypes.Structure` 의 서브 클래스입니다.)"

#: ../Doc/library/multiprocessing.rst:1521
msgid "ctypes"
msgstr "ctypes"

#: ../Doc/library/multiprocessing.rst:1521
msgid "sharedctypes using type"
msgstr "type을 사용하는 공유 ctypes"

#: ../Doc/library/multiprocessing.rst:1521
msgid "sharedctypes using typecode"
msgstr "typecode를 사용하는 공유 ctypes"

#: ../Doc/library/multiprocessing.rst:1523
msgid "c_double(2.4)"
msgstr "c_double(2.4)"

#: ../Doc/library/multiprocessing.rst:1523
msgid "RawValue(c_double, 2.4)"
msgstr "RawValue(c_double, 2.4)"

#: ../Doc/library/multiprocessing.rst:1523
msgid "RawValue('d', 2.4)"
msgstr "RawValue('d', 2.4)"

#: ../Doc/library/multiprocessing.rst:1524
msgid "MyStruct(4, 6)"
msgstr "MyStruct(4, 6)"

#: ../Doc/library/multiprocessing.rst:1524
msgid "RawValue(MyStruct, 4, 6)"
msgstr "RawValue(MyStruct, 4, 6)"

#: ../Doc/library/multiprocessing.rst:1525
msgid "(c_short * 7)()"
msgstr "(c_short * 7)()"

#: ../Doc/library/multiprocessing.rst:1525
msgid "RawArray(c_short, 7)"
msgstr "RawArray(c_short, 7)"

#: ../Doc/library/multiprocessing.rst:1525
msgid "RawArray('h', 7)"
msgstr "RawArray('h', 7)"

#: ../Doc/library/multiprocessing.rst:1526
msgid "(c_int * 3)(9, 2, 8)"
msgstr "(c_int * 3)(9, 2, 8)"

#: ../Doc/library/multiprocessing.rst:1526
msgid "RawArray(c_int, (9, 2, 8))"
msgstr "RawArray(c_int, (9, 2, 8))"

#: ../Doc/library/multiprocessing.rst:1526
msgid "RawArray('i', (9, 2, 8))"
msgstr "RawArray('i', (9, 2, 8))"

#: ../Doc/library/multiprocessing.rst:1530
msgid ""
"Below is an example where a number of ctypes objects are modified by a "
"child process::"
msgstr "다음은 자식 프로세스가 여러 ctypes 객체를 수정하는 예입니다::"

#: ../Doc/library/multiprocessing.rst:1568
msgid "The results printed are ::"
msgstr "인쇄되는 결과는 이렇습니다 ::"

#: ../Doc/library/multiprocessing.rst:1581
msgid "Managers"
msgstr "관리자"

#: ../Doc/library/multiprocessing.rst:1583
msgid ""
"Managers provide a way to create data which can be shared between "
"different processes, including sharing over a network between processes "
"running on different machines. A manager object controls a server process"
" which manages *shared objects*.  Other processes can access the shared "
"objects by using proxies."
msgstr ""
"관리자는 서로 다른 컴퓨터에서 실행되는 프로세스 간에 네트워크를 통해 공유하는 것을 포함하여 서로 다른 프로세스 간에 공유할 수 있는 "
"데이터를 만드는 방법을 제공합니다. 관리자 객체는 *공유 객체* 를 관리하는 서버 프로세스를 제어합니다. 다른 프로세스는 프락시를 "
"사용하여 공유 객체에 액세스 할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1591
msgid ""
"Returns a started :class:`~multiprocessing.managers.SyncManager` object "
"which can be used for sharing objects between processes.  The returned "
"manager object corresponds to a spawned child process and has methods "
"which will create shared objects and return corresponding proxies."
msgstr ""
"프로세스 간에 객체를 공유하는 데 사용할 수 있는 시작된 "
":class:`~multiprocessing.managers.SyncManager` 객체를 반환합니다. 반환된 관리자 객체는 생성된 자식"
" 프로세스에 해당하며 공유 객체를 만들고 해당 프락시를 반환하는 메서드가 있습니다."

#: ../Doc/library/multiprocessing.rst:1599
msgid ""
"Manager processes will be shutdown as soon as they are garbage collected "
"or their parent process exits.  The manager classes are defined in the "
":mod:`multiprocessing.managers` module:"
msgstr ""
"관리자 프로세스는 가비지 수집되거나 상위 프로세스가 종료되자마자 종료됩니다. 관리자 클래스는 "
":mod:`multiprocessing.managers` 모듈에 정의되어 있습니다 :"

#: ../Doc/library/multiprocessing.rst:1605
msgid "Create a BaseManager object."
msgstr "BaseManager 객체를 만듭니다."

#: ../Doc/library/multiprocessing.rst:1607
msgid ""
"Once created one should call :meth:`start` or "
"``get_server().serve_forever()`` to ensure that the manager object refers"
" to a started manager process."
msgstr ""
"일단 생성되면 관리자 객체가 시작된 관리자 프로세스를 참조하게 하려고 :meth:`start` 또는 "
"``get_server().serve_forever()`` 를 호출해야 합니다."

#: ../Doc/library/multiprocessing.rst:1610
msgid ""
"*address* is the address on which the manager process listens for new "
"connections.  If *address* is ``None`` then an arbitrary one is chosen."
msgstr ""
"*address* 는 관리자 프로세스가 새 연결을 리슨하는 주소입니다. *address* 가 ``None`` 이면 임의의 것이 "
"선택됩니다."

#: ../Doc/library/multiprocessing.rst:1613
msgid ""
"*authkey* is the authentication key which will be used to check the "
"validity of incoming connections to the server process.  If *authkey* is "
"``None`` then ``current_process().authkey`` is used. Otherwise *authkey* "
"is used and it must be a byte string."
msgstr ""
"*authkey* 는 서버 프로세스로 들어오는 연결의 유효성을 검사하는 데 사용되는 인증 키입니다. *authkey* 가 ``None``"
" 이면 ``current_process().authkey`` 가 사용됩니다. 그렇지 않으면 *authkey* 가 사용되며 바이트열이어야 "
"합니다."

#: ../Doc/library/multiprocessing.rst:1620
msgid ""
"Start a subprocess to start the manager.  If *initializer* is not "
"``None`` then the subprocess will call ``initializer(*initargs)`` when it"
" starts."
msgstr ""
"관리자를 시작시키기 위해 서브 프로세스를 시작합니다. *initializer* 가 ``None`` 이 아닌 경우, 서브 프로세스는 시작할"
" 때 ``initializer(*initargs)`` 를 호출합니다."

#: ../Doc/library/multiprocessing.rst:1625
msgid ""
"Returns a :class:`Server` object which represents the actual server under"
" the control of the Manager. The :class:`Server` object supports the "
":meth:`serve_forever` method::"
msgstr ""
"Manager의 제어를 받는 실제 서버를 나타내는 :class:`Server` 객체를 반환합니다. :class:`Server` 객체는 "
":meth:`serve_forever` 메서드를 지원합니다::"

#: ../Doc/library/multiprocessing.rst:1634
msgid ":class:`Server` additionally has an :attr:`address` attribute."
msgstr ":class:`Server` 는 추가로 :attr:`address` 어트리뷰트를 가지고 있습니다."

#: ../Doc/library/multiprocessing.rst:1638
msgid "Connect a local manager object to a remote manager process::"
msgstr "지역 관리자 객체를 원격 관리자 프로세스에 연결합니다::"

#: ../Doc/library/multiprocessing.rst:1646
msgid ""
"Stop the process used by the manager.  This is only available if "
":meth:`start` has been used to start the server process."
msgstr ""
"관리자가 사용하는 프로세스를 중지합니다. :meth:`start`\\를 사용하여 서버 프로세스를 시작한 경우에만 사용할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1649
msgid "This can be called multiple times."
msgstr "여러 번 호출 될 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1653
msgid ""
"A classmethod which can be used for registering a type or callable with "
"the manager class."
msgstr "관리자 클래스에 형이나 콜러블을 등록하는데 사용할 수 있는 클래스 메서드."

#: ../Doc/library/multiprocessing.rst:1656
msgid ""
"*typeid* is a \"type identifier\" which is used to identify a particular "
"type of shared object.  This must be a string."
msgstr "*typeid* 는 특정 형의 공유 객체를 식별하는 데 사용되는 \"형 식별자\" 입니다. 문자열이어야 합니다."

#: ../Doc/library/multiprocessing.rst:1659
msgid ""
"*callable* is a callable used for creating objects for this type "
"identifier.  If a manager instance will be connected to the server using "
"the :meth:`connect` method, or if the *create_method* argument is "
"``False`` then this can be left as ``None``."
msgstr ""
"*callable* 은 이 형 식별자에 대한 객체를 만드는 데 사용되는 콜러블 객체입니다. 관리자 인스턴스가 :meth:`connect`"
" 메서드를 사용하여 서버에 연결되거나, *create_method* 인자가 ``False`` 면 ``None`` 으로 남겨 둘 수 "
"있습니다."

#: ../Doc/library/multiprocessing.rst:1665
msgid ""
"*proxytype* is a subclass of :class:`BaseProxy` which is used to create "
"proxies for shared objects with this *typeid*.  If ``None`` then a proxy "
"class is created automatically."
msgstr ""
"*proxytype* 은, 이 *typeid* 의 공유 객체의 프락시를 만드는 데 사용되는 :class:`BaseProxy` 의 서브 "
"클래스입니다. ``None`` 이면 프락시 클래스가 자동으로 생성됩니다."

#: ../Doc/library/multiprocessing.rst:1669
msgid ""
"*exposed* is used to specify a sequence of method names which proxies for"
" this typeid should be allowed to access using "
":meth:`BaseProxy._callmethod`.  (If *exposed* is ``None`` then "
":attr:`proxytype._exposed_` is used instead if it exists.)  In the case "
"where no exposed list is specified, all \"public methods\" of the shared "
"object will be accessible.  (Here a \"public method\" means any attribute"
" which has a :meth:`~object.__call__` method and whose name does not "
"begin with ``'_'``.)"
msgstr ""
"*exposed* 는 이 typeid에 대한 프락시가 :meth:`BaseProxy._callmethod` 를 사용하여 액세스 할 수 "
"있도록 허용해야 하는 메서드 이름의 시퀀스를 지정하는 데 사용됩니다. (만약 *exposed* 가 ``None`` 이면, 존재하는 경우,"
" :attr:`proxytype._exposed_` 가 대신 사용됩니다.) exposed 리스트가 지정되지 않은 경우, 공유 객체의 모든"
" \"공용 메서드\" 에 액세스 할 수 있습니다. (여기서 \"공용 메서드\" 는 :meth:`~object.__call__` 메서드가 "
"있고 그 이름이 ``'_'`` 로 시작하지 않는 어트리뷰트를 의미합니다.)"

#: ../Doc/library/multiprocessing.rst:1678
msgid ""
"*method_to_typeid* is a mapping used to specify the return type of those "
"exposed methods which should return a proxy.  It maps method names to "
"typeid strings.  (If *method_to_typeid* is ``None`` then "
":attr:`proxytype._method_to_typeid_` is used instead if it exists.)  If a"
" method's name is not a key of this mapping or if the mapping is ``None``"
" then the object returned by the method will be copied by value."
msgstr ""
"*method_to_typeid* 는 프락시를 반환해야 하는 노출된 메서드의 반환형을 지정하는 데 사용되는 매핑입니다. 메서드 이름을 "
"typeid 문자열로 매핑합니다. (만일 *method_to_typeid* 가 ``None`` 이면, 존재한다면, "
":attr:`proxytype._method_to_typeid_` 가 대신 사용됩니다.) 메서드의 이름이 이 매핑의 키가 아니거나 매핑이"
" ``None`` 이면, 메서드에 의해 반환된 객체는 값으로 복사됩니다."

#: ../Doc/library/multiprocessing.rst:1685
msgid ""
"*create_method* determines whether a method should be created with name "
"*typeid* which can be used to tell the server process to create a new "
"shared object and return a proxy for it.  By default it is ``True``."
msgstr ""
"*create_method* 는 이름이 *typeid* 인 메서드를 만들어야 하는지를 결정합니다. 이 메서드는 서버 프로세스에 새 공유 "
"객체를 만들고 프락시를 반환하도록 지시하는 데 사용될 수 있습니다. 기본적으로 ``True`` 입니다."

#: ../Doc/library/multiprocessing.rst:1689
msgid ":class:`BaseManager` instances also have one read-only property:"
msgstr ":class:`BaseManager` 인스턴스는 읽기 전용 프로퍼티를 하나 가지고 있습니다:"

#: ../Doc/library/multiprocessing.rst:1693
msgid "The address used by the manager."
msgstr "관리자가 사용하는 주소."

#: ../Doc/library/multiprocessing.rst:1695
msgid ""
"Manager objects support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` starts the "
"server process (if it has not already started) and then returns the "
"manager object.  :meth:`~contextmanager.__exit__` calls :meth:`shutdown`."
msgstr ""
"관리자 객체는 컨텍스트 관리 프로토콜을 지원합니다 -- :ref:`typecontextmanager`\\를 보세요. "
":meth:`~contextmanager.__enter__` 는 서버 프로세스를 시작하고 (아직 시작하지 않았다면), 관리자 객체를 "
"반환합니다. :meth:`~contextmanager.__exit__` 는 :meth:`shutdown`\\을 호출합니다."

#: ../Doc/library/multiprocessing.rst:1701
msgid ""
"In previous versions :meth:`~contextmanager.__enter__` did not start the "
"manager's server process if it was not already started."
msgstr ""
"이전 버전에서 :meth:`~contextmanager.__enter__` 는 관리자의 서버 프로세스가 아직 시작되지 않았을 때 "
"시작시키지 않았습니다."

#: ../Doc/library/multiprocessing.rst:1706
msgid ""
"A subclass of :class:`BaseManager` which can be used for the "
"synchronization of processes.  Objects of this type are returned by "
":func:`multiprocessing.Manager`."
msgstr ""
"프로세스의 동기화에 사용할 수 있는 :class:`BaseManager` 의 서브 클래스입니다. 이 형의 객체는 "
":func:`multiprocessing.Manager` 에 의해 반환됩니다."

#: ../Doc/library/multiprocessing.rst:1710
msgid ""
"Its methods create and return :ref:`multiprocessing-proxy_objects` for a "
"number of commonly used data types to be synchronized across processes. "
"This notably includes shared lists and dictionaries."
msgstr ""
"이 클래스의 메서드는 여러 프로세스에서 동기화 할 수 있도록 일반적으로 사용되는 많은 데이터형을 생성하고 "
":ref:`multiprocessing-proxy_objects`\\를 반환합니다. 특히 공유 리스트와 딕셔너리가 포함됩니다."

#: ../Doc/library/multiprocessing.rst:1716
msgid ""
"Create a shared :class:`threading.Barrier` object and return a proxy for "
"it."
msgstr "공유 :class:`threading.Barrier` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1723
msgid ""
"Create a shared :class:`threading.BoundedSemaphore` object and return a "
"proxy for it."
msgstr "공유 :class:`threading.BoundedSemaphore` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1728
msgid ""
"Create a shared :class:`threading.Condition` object and return a proxy "
"for it."
msgstr "공유 :class:`threading.Condition` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1731
msgid ""
"If *lock* is supplied then it should be a proxy for a "
":class:`threading.Lock` or :class:`threading.RLock` object."
msgstr ""
"*lock* 이 제공되면 :class:`threading.Lock` 또는 :class:`threading.RLock` 객체에 대한 "
"프락시여야 합니다."

#: ../Doc/library/multiprocessing.rst:1739
msgid "Create a shared :class:`threading.Event` object and return a proxy for it."
msgstr "공유 :class:`threading.Event` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1743
msgid "Create a shared :class:`threading.Lock` object and return a proxy for it."
msgstr "공유 :class:`threading.Lock` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1747
msgid "Create a shared :class:`Namespace` object and return a proxy for it."
msgstr "공유 :class:`Namespace` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1751
msgid "Create a shared :class:`queue.Queue` object and return a proxy for it."
msgstr "공유 :class:`queue.Queue` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1755
msgid "Create a shared :class:`threading.RLock` object and return a proxy for it."
msgstr "공유 :class:`threading.RLock` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1759
msgid ""
"Create a shared :class:`threading.Semaphore` object and return a proxy "
"for it."
msgstr "공유 :class:`threading.Semaphore` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1764
msgid "Create an array and return a proxy for it."
msgstr "배열을 만들고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1768
msgid ""
"Create an object with a writable ``value`` attribute and return a proxy "
"for it."
msgstr "쓰기 가능한 ``value`` 어트리뷰트를 가진 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1775
msgid "Create a shared :class:`dict` object and return a proxy for it."
msgstr "공유 :class:`dict` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1780
msgid "Create a shared :class:`list` object and return a proxy for it."
msgstr "공유 :class:`list` 객체를 생성하고 프락시를 반환합니다."

#: ../Doc/library/multiprocessing.rst:1782
msgid ""
"Shared objects are capable of being nested.  For example, a shared "
"container object such as a shared list can contain other shared objects "
"which will all be managed and synchronized by the :class:`SyncManager`."
msgstr ""
"공유 객체는 중첩될 수 있습니다. 예를 들어, 공유 리스트와 같은 공유 컨테이너 객체는, :class:`SyncManager` 에 의해 "
"모두 관리되고 동기화되는 다른 공유 객체를 포함 할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1789
msgid "A type that can register with :class:`SyncManager`."
msgstr ":class:`SyncManager` 로 등록 할 수 있는 형입니다."

#: ../Doc/library/multiprocessing.rst:1791
msgid ""
"A namespace object has no public methods, but does have writable "
"attributes. Its representation shows the values of its attributes."
msgstr ""
"이름 공간 객체에는 공용 메서드가 없지만, 쓰기 가능한 어트리뷰트가 있습니다. repr 은 그것의 어트리뷰트 값을 보여줍니다."

#: ../Doc/library/multiprocessing.rst:1794
msgid ""
"However, when using a proxy for a namespace object, an attribute "
"beginning with ``'_'`` will be an attribute of the proxy and not an "
"attribute of the referent:"
msgstr ""
"그러나, 이름 공간 객체의 프락시를 사용할 때, ``'_'`` 로 시작하는 어트리뷰트는 프락시의 어트리뷰트가 되며 참조 대상의 "
"어트리뷰트가 아닙니다:"

#: ../Doc/library/multiprocessing.rst:1810
msgid "Customized managers"
msgstr "사용자 정의 관리자"

#: ../Doc/library/multiprocessing.rst:1812
msgid ""
"To create one's own manager, one creates a subclass of "
":class:`BaseManager` and uses the :meth:`~BaseManager.register` "
"classmethod to register new types or callables with the manager class.  "
"For example::"
msgstr ""
"자신만의 관리자를 만들려면, :class:`BaseManager` 의 서브 클래스를 만들고 "
":meth:`~BaseManager.register` 클래스 메서드를 사용하여 새로운 형이나 콜러블을 관리자 클래스에 등록합니다. 예를 "
"들면::"

#: ../Doc/library/multiprocessing.rst:1837
msgid "Using a remote manager"
msgstr "원격 관리자 사용하기"

#: ../Doc/library/multiprocessing.rst:1839
msgid ""
"It is possible to run a manager server on one machine and have clients "
"use it from other machines (assuming that the firewalls involved allow "
"it)."
msgstr ""
"한 기계에서 관리자 서버를 실행하고 다른 기계의 클라이언트가 관리자 서버를 사용하도록 할 수 있습니다 (관련된 방화벽이 허용한다고 "
"가정합니다)."

#: ../Doc/library/multiprocessing.rst:1842
msgid ""
"Running the following commands creates a server for a single shared queue"
" which remote clients can access::"
msgstr "다음 명령을 실행하면 원격 클라이언트가 액세스 할 수 있는 단일 공유 큐를 위한 서버가 만들어집니다::"

#: ../Doc/library/multiprocessing.rst:1854
msgid "One client can access the server as follows::"
msgstr "한 클라이언트는 다음과 같이 서버에 액세스 할 수 있습니다::"

#: ../Doc/library/multiprocessing.rst:1864
msgid "Another client can also use it::"
msgstr "또 다른 클라이언트도 사용할 수 있습니다::"

#: ../Doc/library/multiprocessing.rst:1875
msgid ""
"Local processes can also access that queue, using the code from above on "
"the client to access it remotely::"
msgstr "지역 프로세스 역시, 위의 클라이언트가 원격으로 액세스하는 코드를 사용하여 같은 큐에 액세스 할 수 있습니다::"

#: ../Doc/library/multiprocessing.rst:1900
msgid "Proxy Objects"
msgstr "프락시 객체"

#: ../Doc/library/multiprocessing.rst:1902
msgid ""
"A proxy is an object which *refers* to a shared object which lives "
"(presumably) in a different process.  The shared object is said to be the"
" *referent* of the proxy.  Multiple proxy objects may have the same "
"referent."
msgstr ""
"프락시는 (아마도) 다른 프로세스에 있는 공유 객체를 *가리키는* 객체입니다. 공유 객체는 프락시의 *지시 대상* 이라고 합니다. 여러 "
"프락시 객체는 같은 지시 대상을 가질 수 있습니다."

#: ../Doc/library/multiprocessing.rst:1906
msgid ""
"A proxy object has methods which invoke corresponding methods of its "
"referent (although not every method of the referent will necessarily be "
"available through the proxy).  In this way, a proxy can be used just like"
" its referent can:"
msgstr ""
"프락시 객체에는 지시 대상의 해당 메서드를 호출하는 메서드가 있습니다 (그러나 지시 대상의 모든 메서드가 반드시 프락시를 통해 사용할 수"
" 있는 것은 아닙니다). 이런 식으로, 프락시는 지시 대상처럼 사용될 수 있습니다:"

#: ../Doc/library/multiprocessing.rst:1924
msgid ""
"Notice that applying :func:`str` to a proxy will return the "
"representation of the referent, whereas applying :func:`repr` will return"
" the representation of the proxy."
msgstr ""
"프락시에 :func:`str` 을 적용하면 지시 대상의 표현이 반환되는 반면, :func:`repr` 을 적용하면 프락시의 표현이 "
"반환됩니다."

#: ../Doc/library/multiprocessing.rst:1928
msgid ""
"An important feature of proxy objects is that they are picklable so they "
"can be passed between processes.  As such, a referent can contain :ref"
":`multiprocessing-proxy_objects`.  This permits nesting of these managed "
"lists, dicts, and other :ref:`multiprocessing-proxy_objects`:"
msgstr ""
"프락시 객체의 중요한 특징은, 피클 가능해서 프로세스 간에 전달될 수 있다는 것입니다. 지시 대상은 "
":ref:`multiprocessing-proxy_objects`\\를 포함 할 수 있습니다. 이것은 관리된 리스트, 딕셔너리 및 다른 "
":ref:`multiprocessing-proxy_objects` 의 중첩을 허용합니다:"

#: ../Doc/library/multiprocessing.rst:1944
msgid "Similarly, dict and list proxies may be nested inside one another::"
msgstr "비슷하게, 딕셔너리와 리스트 프락시는 서로 중첩될 수 있습니다::"

#: ../Doc/library/multiprocessing.rst:1957
msgid ""
"If standard (non-proxy) :class:`list` or :class:`dict` objects are "
"contained in a referent, modifications to those mutable values will not "
"be propagated through the manager because the proxy has no way of knowing"
" when the values contained within are modified.  However, storing a value"
" in a container proxy (which triggers a ``__setitem__`` on the proxy "
"object) does propagate through the manager and so to effectively modify "
"such an item, one could re-assign the modified value to the container "
"proxy::"
msgstr ""
"(프락시가 아닌) 표준 :class:`list` 또는 :class:`dict` 객체가 지시 대상에 포함되어있는 경우, 이 가변 값들에 "
"대한 수정은 관리자를 통해 전파되지 않습니다. 포함된 값이 언제 수정되는지 프락시가 알 방법이 없기 때문입니다. 그러나 컨테이너 프락시에"
" 값을 저장하는 것(프락시 객체의 ``__setitem__`` 을 호출합니다)은 관리자를 통해 전파되므로, 그 항목을 효과적으로 수정하기"
" 위해, 수정된 값을 컨테이너 프락시에 다시 대입할 수 있습니다::"

#: ../Doc/library/multiprocessing.rst:1976
msgid ""
"This approach is perhaps less convenient than employing nested :ref"
":`multiprocessing-proxy_objects` for most use cases but also demonstrates"
" a level of control over the synchronization."
msgstr ""
"이 접근법은 아마도 대부분의 사용 사례에서 중첩된 :ref:`multiprocessing-proxy_objects`\\를 사용하는 것보다"
" 불편하지만, 동기화에 대한 제어 수준을 보여줍니다."

#: ../Doc/library/multiprocessing.rst:1982
msgid ""
"The proxy types in :mod:`multiprocessing` do nothing to support "
"comparisons by value.  So, for instance, we have:"
msgstr ""
":mod:`multiprocessing` 의 프락시 형은 값으로 비교하는 것을 지원하지 않습니다. 그래서, 예를 들어, 이런 결과를 "
"얻습니다:"

#: ../Doc/library/multiprocessing.rst:1990
msgid ""
"One should just use a copy of the referent instead when making "
"comparisons."
msgstr "비교할 때는 지시 대상의 사본을 대신 사용해야 합니다."

#: ../Doc/library/multiprocessing.rst:1994
msgid "Proxy objects are instances of subclasses of :class:`BaseProxy`."
msgstr "프락시 객체는 :class:`BaseProxy` 의 서브 클래스의 인스턴스입니다."

#: ../Doc/library/multiprocessing.rst:1998
msgid "Call and return the result of a method of the proxy's referent."
msgstr "프락시의 지시 대상 메서드를 호출하고 결과를 반환합니다."

#: ../Doc/library/multiprocessing.rst:2000
msgid "If ``proxy`` is a proxy whose referent is ``obj`` then the expression ::"
msgstr "``proxy`` 가 프락시이고, 그 지시 대상이 ``obj`` 면, 표현식 ::"

#: ../Doc/library/multiprocessing.rst:2004
msgid "will evaluate the expression ::"
msgstr "은 표현식 ::"

#: ../Doc/library/multiprocessing.rst:2008
msgid "in the manager's process."
msgstr "을 관리자 프로세스에서 평가합니다."

#: ../Doc/library/multiprocessing.rst:2010
msgid ""
"The returned value will be a copy of the result of the call or a proxy to"
" a new shared object -- see documentation for the *method_to_typeid* "
"argument of :meth:`BaseManager.register`."
msgstr ""
"반환된 값은 호출 결과의 복사본이거나 새 공유 객체에 대한 프락시입니다 -- :meth:`BaseManager.register` 의 "
"*method_to_typeid* 인자에 대한 설명서를 보십시오."

#: ../Doc/library/multiprocessing.rst:2014
msgid ""
"If an exception is raised by the call, then is re-raised by "
":meth:`_callmethod`.  If some other exception is raised in the manager's "
"process then this is converted into a :exc:`RemoteError` exception and is"
" raised by :meth:`_callmethod`."
msgstr ""
"호출 때문에 예외가 발생하면, :meth:`_callmethod` 가 다시 일으킵니다. 관리자 프로세스에서 다른 예외가 발생하면 "
":exc:`RemoteError` 예외로 변환되어 :meth:`_callmethod` 가 일으킵니다."

#: ../Doc/library/multiprocessing.rst:2019
msgid ""
"Note in particular that an exception will be raised if *methodname* has "
"not been *exposed*."
msgstr "특히, *methodname* 이 *노출되지* 않았으면 예외가 발생합니다."

#: ../Doc/library/multiprocessing.rst:2022
msgid "An example of the usage of :meth:`_callmethod`:"
msgstr ":meth:`_callmethod` 사용법의 예:"

#: ../Doc/library/multiprocessing.rst:2038
msgid "Return a copy of the referent."
msgstr "지시 대상의 복사본을 반환합니다."

#: ../Doc/library/multiprocessing.rst:2040
msgid "If the referent is unpicklable then this will raise an exception."
msgstr "지시 대상이 피클 가능하지 않으면 예외가 발생합니다."

#: ../Doc/library/multiprocessing.rst:2044
msgid "Return a representation of the proxy object."
msgstr "프락시 객체의 표현을 반환합니다."

#: ../Doc/library/multiprocessing.rst:2048
msgid "Return the representation of the referent."
msgstr "지시 대상의 표현을 반환합니다."

#: ../Doc/library/multiprocessing.rst:2052
msgid "Cleanup"
msgstr "정리"

#: ../Doc/library/multiprocessing.rst:2054
msgid ""
"A proxy object uses a weakref callback so that when it gets garbage "
"collected it deregisters itself from the manager which owns its referent."
msgstr "프락시 객체는 weakref 콜백을 사용해서 가비지 수집 시 자신의 지시 대상을 소유한 관리자에서 자신을 등록 취소합니다."

#: ../Doc/library/multiprocessing.rst:2057
msgid ""
"A shared object gets deleted from the manager process when there are no "
"longer any proxies referring to it."
msgstr "더는 참조하는 프락시가 없는 경우 공유 객체는 관리자 프로세스에서 삭제됩니다."

#: ../Doc/library/multiprocessing.rst:2062
msgid "Process Pools"
msgstr "프로세스 풀"

#: ../Doc/library/multiprocessing.rst:2067
msgid ""
"One can create a pool of processes which will carry out tasks submitted "
"to it with the :class:`Pool` class."
msgstr ":class:`Pool` 클래스를 사용하여, 제출된 작업을 수행할 프로세스 풀을 만들 수 있습니다."

#: ../Doc/library/multiprocessing.rst:2072
msgid ""
"A process pool object which controls a pool of worker processes to which "
"jobs can be submitted.  It supports asynchronous results with timeouts "
"and callbacks and has a parallel map implementation."
msgstr ""
"작업을 제출할 수 있는 작업자 프로세스 풀을 제어하는 ​​프로세스 풀 객체. 제한 시간과 콜백을 사용하는 비동기 결과를 지원하고 병렬 "
"map 구현을 제공합니다."

#: ../Doc/library/multiprocessing.rst:2076
msgid ""
"*processes* is the number of worker processes to use.  If *processes* is "
"``None`` then the number returned by :func:`os.cpu_count` is used."
msgstr ""
"*processes* 는 사용할 작업자 프로세스 수입니다. *processes* 가 ``None`` 이면 "
":func:`os.cpu_count` 에 의해 반환되는 수가 사용됩니다."

#: ../Doc/library/multiprocessing.rst:2079
msgid ""
"If *initializer* is not ``None`` then each worker process will call "
"``initializer(*initargs)`` when it starts."
msgstr ""
"*initializer* 가 ``None`` 이 아니면, 각 작업자 프로세스는 시작할 때 ``initializer(*initargs)``"
" 를 호출합니다."

#: ../Doc/library/multiprocessing.rst:2082
msgid ""
"*maxtasksperchild* is the number of tasks a worker process can complete "
"before it will exit and be replaced with a fresh worker process, to "
"enable unused resources to be freed. The default *maxtasksperchild* is "
"``None``, which means worker processes will live as long as the pool."
msgstr ""
"*maxtasksperchild* 는, 사용되지 않는 자원을 해제할 수 있도록, 작업 프로세스가 종료되고 새 작업 프로세스로 교체되기 "
"전에 완료할 수 있는 작업 수입니다. 기본 *maxtasksperchild* 는 ``None`` 입니다. 이는 작업자 프로세스가 풀만큼 "
"오래감을 의미합니다."

#: ../Doc/library/multiprocessing.rst:2087
msgid ""
"*context* can be used to specify the context used for starting the worker"
" processes.  Usually a pool is created using the function "
":func:`multiprocessing.Pool` or the :meth:`Pool` method of a context "
"object.  In both cases *context* is set appropriately."
msgstr ""
"*context* 는 작업자 프로세스를 시작하는 데 사용되는 컨텍스트를 지정하는 데 사용할 수 있습니다. 보통 풀은 "
":func:`multiprocessing.Pool` 또는 컨텍스트 객체의 :meth:`Pool` 메서드를 사용하여 생성됩니다. 두 경우 "
"모두 *context* 가 적절하게 설정됩니다."

#: ../Doc/library/multiprocessing.rst:2093
msgid ""
"Note that the methods of the pool object should only be called by the "
"process which created the pool."
msgstr "풀 객체의 메서드는 풀을 생성한 프로세스에 의해서만 호출되어야 합니다."

#: ../Doc/library/multiprocessing.rst:2096
msgid "*maxtasksperchild*"
msgstr "*maxtasksperchild*"

#: ../Doc/library/multiprocessing.rst:2099
msgid "*context*"
msgstr "*context*"

#: ../Doc/library/multiprocessing.rst:2104
msgid ""
"Worker processes within a :class:`Pool` typically live for the complete "
"duration of the Pool's work queue. A frequent pattern found in other "
"systems (such as Apache, mod_wsgi, etc) to free resources held by workers"
" is to allow a worker within a pool to complete only a set amount of work"
" before being exiting, being cleaned up and a new process spawned to "
"replace the old one. The *maxtasksperchild* argument to the :class:`Pool`"
" exposes this ability to the end user."
msgstr ""
":class:`Pool` 내의 작업자 프로세스는 일반적으로 Pool의 작업 큐의 전체 지속 기간 지속합니다. 작업자가 잡은 자원을 "
"해제하기 위해 다른 시스템 (가령 Apache, mod_wsgi 등)에서 흔히 사용되는 패턴은, 풀 내에 있는 작업자가 종료되고 새 "
"프로세스가 스폰 되어 예전 것을 교체하기 전에 일정한 분량의 작업만 완료하도록 하는 것입니다. :class:`Pool` 의 "
"*maxtasksperchild* 인자는 이 기능을 일반 사용자에게 노출합니다."

#: ../Doc/library/multiprocessing.rst:2114
msgid ""
"Call *func* with arguments *args* and keyword arguments *kwds*.  It "
"blocks until the result is ready. Given this blocks, :meth:`apply_async` "
"is better suited for performing work in parallel. Additionally, *func* is"
" only executed in one of the workers of the pool."
msgstr ""
"인자 *args* 및 키워드 인자 *kwds* 를 사용하여 *func* 를 호출합니다. 결과가 준비될 때까지 블록 됩니다. 이 블록 "
"때문에, :meth:`apply_async` 가 병렬로 작업을 수행하는 데 더 적합합니다. 또한 *func* 는 풀의 작업자 중 "
"하나에서만 실행됩니다."

#: ../Doc/library/multiprocessing.rst:2121
msgid "A variant of the :meth:`apply` method which returns a result object."
msgstr "결과 객체를 반환하는 :meth:`apply` 메서드의 변형입니다."

#: ../Doc/library/multiprocessing.rst:2123
#: ../Doc/library/multiprocessing.rst:2148
msgid ""
"If *callback* is specified then it should be a callable which accepts a "
"single argument.  When the result becomes ready *callback* is applied to "
"it, that is unless the call failed, in which case the *error_callback* is"
" applied instead."
msgstr ""
"*callback* 이 지정되면 단일 인자를 받아들이는 콜러블이어야 합니다. 결과가 준비되면 *callback* 을 이 결과를 인자로 "
"호출합니다. 실패한 결과면 *error_callback* 이 대신 적용됩니다."

#: ../Doc/library/multiprocessing.rst:2128
#: ../Doc/library/multiprocessing.rst:2153
msgid ""
"If *error_callback* is specified then it should be a callable which "
"accepts a single argument.  If the target function fails, then the "
"*error_callback* is called with the exception instance."
msgstr ""
"*error_callback* 이 지정되면 단일 인자를 허용하는 콜러블이어야 합니다. 대상 함수가 실패하면, "
"*error_callback* 이 예외 인스턴스를 인자로 호출됩니다."

#: ../Doc/library/multiprocessing.rst:2132
#: ../Doc/library/multiprocessing.rst:2157
msgid ""
"Callbacks should complete immediately since otherwise the thread which "
"handles the results will get blocked."
msgstr "콜백은 즉시 완료되어야 합니다. 그렇지 않으면 결과를 처리하는 스레드가 블록 됩니다."

#: ../Doc/library/multiprocessing.rst:2137
msgid ""
"A parallel equivalent of the :func:`map` built-in function (it supports "
"only one *iterable* argument though).  It blocks until the result is "
"ready."
msgstr ""
":func:`map` 내장 함수의 병렬 버전입니다 (하지만 하나의 *iterable* 인자만 지원합니다). 결과가 준비될 때까지 블록 "
"됩니다."

#: ../Doc/library/multiprocessing.rst:2140
msgid ""
"This method chops the iterable into a number of chunks which it submits "
"to the process pool as separate tasks.  The (approximate) size of these "
"chunks can be specified by setting *chunksize* to a positive integer."
msgstr ""
"이 메서드는 iterable을 여러 묶음으로 잘라서 별도의 작업으로 프로세스 풀에 제출합니다. 이러한 묶음의 (대략적인) 크기는 "
"*chunksize* 를 양의 정수로 설정하여 지정할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:2146
msgid "A variant of the :meth:`.map` method which returns a result object."
msgstr "결과 객체를 반환하는 :meth:`.map` 메서드의 변형입니다."

#: ../Doc/library/multiprocessing.rst:2162
msgid "A lazier version of :meth:`map`."
msgstr ":meth:`map` 의 느긋한 버전."

#: ../Doc/library/multiprocessing.rst:2164
msgid ""
"The *chunksize* argument is the same as the one used by the :meth:`.map` "
"method.  For very long iterables using a large value for *chunksize* can "
"make the job complete **much** faster than using the default value of "
"``1``."
msgstr ""
"*chunksize* 인자는 :meth:`.map` 메서드에서 사용된 인자와 같습니다. 매우 긴 iterable의 경우 "
"*chunksize* 에 큰 값을 사용하면 기본값 ``1`` 을 사용하는 것보다 작업을 **많이** 빠르게 완료 할 수 있습니다."

#: ../Doc/library/multiprocessing.rst:2169
msgid ""
"Also if *chunksize* is ``1`` then the :meth:`!next` method of the "
"iterator returned by the :meth:`imap` method has an optional *timeout* "
"parameter: ``next(timeout)`` will raise "
":exc:`multiprocessing.TimeoutError` if the result cannot be returned "
"within *timeout* seconds."
msgstr ""
"또한 *chunksize* 가 ``1`` 이면 :meth:`imap` 메서드에 의해 반환된 이터레이터의 :meth:`!next` 메서드는"
" 선택적 *timeout* 매개 변수를 가집니다: ``next(timeout)`` 은 결과가 *timeout* 초 내에 반환될 수 없는 "
"경우 :exc:`multiprocessing.TimeoutError` 를 발생시킵니다."

#: ../Doc/library/multiprocessing.rst:2176
msgid ""
"The same as :meth:`imap` except that the ordering of the results from the"
" returned iterator should be considered arbitrary.  (Only when there is "
"only one worker process is the order guaranteed to be \"correct\".)"
msgstr ""
":meth:`imap`\\과 같지만, 반환된 이터레이터가 제공하는 결과의 순서가 임의적인 것으로 간주하여야 합니다. (단 하나의 작업자 "
"프로세스가 있는 경우에만 순서가 \"올바름\" 이 보장됩니다."

#: ../Doc/library/multiprocessing.rst:2182
msgid ""
"Like :meth:`map` except that the elements of the *iterable* are expected "
"to be iterables that are unpacked as arguments."
msgstr ":meth:`map`\\과 같지만, *iterable* 의 요소가 인자로 언팩 될 이터러블일 것으로 기대합니다."

#: ../Doc/library/multiprocessing.rst:2185
msgid ""
"Hence an *iterable* of ``[(1,2), (3, 4)]`` results in ``[func(1,2), "
"func(3,4)]``."
msgstr ""
"따라서 *iterable* 이 ``[(1,2), (3, 4)]`` 미면 결과는 ``[func(1,2), func(3,4)]`` 가 "
"됩니다."

#: ../Doc/library/multiprocessing.rst:2192
msgid ""
"A combination of :meth:`starmap` and :meth:`map_async` that iterates over"
" *iterable* of iterables and calls *func* with the iterables unpacked. "
"Returns a result object."
msgstr ""
":meth:`starmap` 과 :meth:`map_async` 의 조합으로 이터러블의 *iterable* 을 이터레이트하고 이터러블을 "
"언팩해서 *func* 를 호출합니다. 결과 객체를 반환합니다."

#: ../Doc/library/multiprocessing.rst:2200
msgid ""
"Prevents any more tasks from being submitted to the pool.  Once all the "
"tasks have been completed the worker processes will exit."
msgstr "더는 작업이 풀에 제출되지 않도록 합니다. 모든 작업이 완료되면 작업자 프로세스가 종료됩니다."

#: ../Doc/library/multiprocessing.rst:2205
msgid ""
"Stops the worker processes immediately without completing outstanding "
"work.  When the pool object is garbage collected :meth:`terminate` will "
"be called immediately."
msgstr ""
"계류 중인 작업을 완료하지 않고 즉시 작업자 프로세스를 중지합니다. 풀 객체가 가비지 수집될 때 :meth:`terminate` 가 즉시"
" 호출됩니다."

#: ../Doc/library/multiprocessing.rst:2211
msgid ""
"Wait for the worker processes to exit.  One must call :meth:`close` or "
":meth:`terminate` before using :meth:`join`."
msgstr ""
"작업자 프로세스가 종료될 때까지 기다립니다. :meth:`join` 호출 전에 반드시 :meth:`close` 나 "
":meth:`terminate`\\를 호출해야합니다 ."

#: ../Doc/library/multiprocessing.rst:2214
msgid ""
"Pool objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the"
" pool object, and :meth:`~contextmanager.__exit__` calls "
":meth:`terminate`."
msgstr ""
"풀 객체는 이제 컨텍스트 관리 프로토콜을 지원합니다 -- :ref:`typecontextmanager`\\를 보십시오. "
":meth:`~contextmanager.__enter__` 는 풀 객체를 반환하고, "
":meth:`~contextmanager.__exit__` 는 :meth:`terminate`\\를 호출합니다."

#: ../Doc/library/multiprocessing.rst:2222
msgid ""
"The class of the result returned by :meth:`Pool.apply_async` and "
":meth:`Pool.map_async`."
msgstr ":meth:`Pool.apply_async`\\와 :meth:`Pool.map_async` 에 의해 반환되는 결과의 클래스."

#: ../Doc/library/multiprocessing.rst:2227
msgid ""
"Return the result when it arrives.  If *timeout* is not ``None`` and the "
"result does not arrive within *timeout* seconds then "
":exc:`multiprocessing.TimeoutError` is raised.  If the remote call raised"
" an exception then that exception will be reraised by :meth:`get`."
msgstr ""
"결과가 도착할 때 반환합니다. *timeout* 이 ``None`` 이 아니고 결과가 *timeout* 초 내에 도착하지 않으면 "
":exc:`multiprocessing.TimeoutError` 가 발생합니다. 원격 호출이 예외를 발생시키는 경우 해당 예외는 "
":meth:`get` 에 의해 다시 발생합니다."

#: ../Doc/library/multiprocessing.rst:2234
msgid "Wait until the result is available or until *timeout* seconds pass."
msgstr "결과가 사용 가능할 때까지 또는 *timeout* 초가 지날 때까지 기다립니다."

#: ../Doc/library/multiprocessing.rst:2238
msgid "Return whether the call has completed."
msgstr "호출이 완료했는지를 돌려줍니다."

#: ../Doc/library/multiprocessing.rst:2242
msgid ""
"Return whether the call completed without raising an exception.  Will "
"raise :exc:`AssertionError` if the result is not ready."
msgstr ""
"예외를 발생시키지 않고 호출이 완료되었는지를 돌려줍니다. 결과가 준비되지 않았으면 :exc:`AssertionError` 를 "
"발생시킵니다."

#: ../Doc/library/multiprocessing.rst:2245
msgid "The following example demonstrates the use of a pool::"
msgstr "다음 예제는 풀 사용 방법을 보여줍니다.::"

#: ../Doc/library/multiprocessing.rst:2272
msgid "Listeners and Clients"
msgstr "리스너와 클라이언트"

#: ../Doc/library/multiprocessing.rst:2277
msgid ""
"Usually message passing between processes is done using queues or by "
"using :class:`~Connection` objects returned by "
":func:`~multiprocessing.Pipe`."
msgstr ""
"보통 프로세스 간 메시지 전달은 큐를 사용하거나 :func:`~multiprocessing.Pipe` 가 반환하는 "
":class:`~Connection` 객체를 사용하여 수행됩니다."

#: ../Doc/library/multiprocessing.rst:2281
msgid ""
"However, the :mod:`multiprocessing.connection` module allows some extra "
"flexibility.  It basically gives a high level message oriented API for "
"dealing with sockets or Windows named pipes.  It also has support for "
"*digest authentication* using the :mod:`hmac` module, and for polling "
"multiple connections at the same time."
msgstr ""
"그러나, :mod:`multiprocessing.connection` 모듈은 약간의 추가적인 유연성을 허용합니다. 기본적으로 소켓이나 "
"윈도우의 이름있는 파이프를 다루는 높은 수준의 메시지 지향 API를 제공합니다. 또한 :mod:`hmac` 모듈을 사용한 *다이제스트 "
"인증* 과 다중 연결을 동시에 폴링하는 방법을 지원합니다."

#: ../Doc/library/multiprocessing.rst:2290
msgid ""
"Send a randomly generated message to the other end of the connection and "
"wait for a reply."
msgstr "무작위로 생성된 메시지를 연결의 다른 쪽 끝으로 보내고 응답을 기다립니다."

#: ../Doc/library/multiprocessing.rst:2293
msgid ""
"If the reply matches the digest of the message using *authkey* as the key"
" then a welcome message is sent to the other end of the connection.  "
"Otherwise :exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"응답이 *authkey* 를 키로 사용하는 메시지의 다이제스트와 일치하면 환영 메시지가 연결의 다른 끝으로 전송됩니다. 그렇지 않으면 "
":exc:`~multiprocessing.AuthenticationError` 가 발생합니다."

#: ../Doc/library/multiprocessing.rst:2299
msgid ""
"Receive a message, calculate the digest of the message using *authkey* as"
" the key, and then send the digest back."
msgstr "메시지를 수신하고, *authkey* 를 키로 사용하여 메시지의 다이제스트를 계산한 다음, 다이제스트를 다시 보냅니다."

#: ../Doc/library/multiprocessing.rst:2302
msgid ""
"If a welcome message is not received, then "
":exc:`~multiprocessing.AuthenticationError` is raised."
msgstr ""
"환영 메시지가 수신되지 않으면, :exc:`~multiprocessing.AuthenticationError` 가 발생합니다."

#: ../Doc/library/multiprocessing.rst:2307
msgid ""
"Attempt to set up a connection to the listener which is using address "
"*address*, returning a :class:`~Connection`."
msgstr ""
"주소 *address* 를 사용하는 리스너에 대한 연결을 설정하려고 시도하고, :class:`~Connection`\\을 반환합니다."

#: ../Doc/library/multiprocessing.rst:2310
msgid ""
"The type of the connection is determined by *family* argument, but this "
"can generally be omitted since it can usually be inferred from the format"
" of *address*. (See :ref:`multiprocessing-address-formats`)"
msgstr ""
"연결 유형은 *family* 인자에 의해 결정되지만, 일반적으로 *address* 형식에서 유추 할 수 있으므로 일반적으로 생략 할 수 "
"있습니다. (:ref:`multiprocessing-address-formats`\\를 참조하세요)"

#: ../Doc/library/multiprocessing.rst:2314
#: ../Doc/library/multiprocessing.rst:2349
msgid ""
"If *authkey* is given and not None, it should be a byte string and will "
"be used as the secret key for an HMAC-based authentication challenge. No "
"authentication is done if *authkey* is None. "
":exc:`~multiprocessing.AuthenticationError` is raised if authentication "
"fails. See :ref:`multiprocessing-auth-keys`."
msgstr ""
"*authkey* 가 주어지고 None이 아니라면, 바이트열이어야 하며 HMAC 기반 인증 챌린지의 비밀 키로 사용됩니다. "
"*authkey* 가 None이면, 인증이 수행되지 않습니다. 인증이 실패하면 "
":exc:`~multiprocessing.AuthenticationError` 가 발생합니다. :ref:`multiprocessing-"
"auth-keys`\\를 보세요."

#: ../Doc/library/multiprocessing.rst:2322
msgid ""
"A wrapper for a bound socket or Windows named pipe which is 'listening' "
"for connections."
msgstr "연결을 '리스닝' 하는 바인드된 소켓이나 윈도우의 이름있는 파이프에 대한 래퍼입니다."

#: ../Doc/library/multiprocessing.rst:2325
msgid ""
"*address* is the address to be used by the bound socket or named pipe of "
"the listener object."
msgstr "*address* 는 리스너 객체의 바인드된 소켓이나 이름있는 파이프가 사용할 주소입니다."

#: ../Doc/library/multiprocessing.rst:2330
msgid ""
"If an address of '0.0.0.0' is used, the address will not be a connectable"
" end point on Windows. If you require a connectable end-point, you should"
" use '127.0.0.1'."
msgstr ""
"주소가 '0.0.0.0' 인 경우, 주소는 윈도우에서 연결 가능한 끝점이 아닙니다. 연결할 수 있는 끝점이 필요한 경우, "
"'127.0.0.1'\\을 사용해야 합니다."

#: ../Doc/library/multiprocessing.rst:2334
msgid ""
"*family* is the type of socket (or named pipe) to use.  This can be one "
"of the strings ``'AF_INET'`` (for a TCP socket), ``'AF_UNIX'`` (for a "
"Unix domain socket) or ``'AF_PIPE'`` (for a Windows named pipe).  Of "
"these only the first is guaranteed to be available.  If *family* is "
"``None`` then the family is inferred from the format of *address*.  If "
"*address* is also ``None`` then a default is chosen.  This default is the"
" family which is assumed to be the fastest available.  See :ref"
":`multiprocessing-address-formats`.  Note that if *family* is "
"``'AF_UNIX'`` and address is ``None`` then the socket will be created in "
"a private temporary directory created using :func:`tempfile.mkstemp`."
msgstr ""
"*family* 는 사용할 소켓(또는 이름있는 파이프)의 유형입니다. 문자열 ``'AF_INET'`` (TCP 소켓), "
"``'AF_UNIX'`` (유닉스 도메인 소켓), ``'AF_PIPE'`` (윈도우 이름있는 파이프) 중 하나일 수 있습니다. 이 중 "
"오직 첫 번째 것만 항상 사용할 수 있음이 보장됩니다. *family* 가 ``None`` 이면, *address* 의 형식으로부터 "
"유추됩니다. *address* 역시 ``None`` 이면, 기본값이 선택됩니다. 이 기본값은 사용 가능한 것 중 가장 빠른 것으로 "
"기대되는 것입니다. :ref:`multiprocessing-address-formats`\\를 참조하세요. *family* 가 "
"``'AF_UNIX'`` 이고 주소가 ``None`` 이면, 소켓은 :func:`tempfile.mkstemp` 를 사용하여 만들어진 "
"비공개 임시 디렉터리에 생성됩니다."

#: ../Doc/library/multiprocessing.rst:2345
msgid ""
"If the listener object uses a socket then *backlog* (1 by default) is "
"passed to the :meth:`~socket.socket.listen` method of the socket once it "
"has been bound."
msgstr ""
"리스너 객체가 소켓을 사용하면, *backlog* (기본적으로 1) 는 소켓이 바인드되면 소켓의 "
":meth:`~socket.socket.listen` 메서드에 전달됩니다."

#: ../Doc/library/multiprocessing.rst:2357
msgid ""
"Accept a connection on the bound socket or named pipe of the listener "
"object and return a :class:`~Connection` object. If authentication is "
"attempted and fails, then :exc:`~multiprocessing.AuthenticationError` is "
"raised."
msgstr ""
"리스너 객체의 바인드된 소켓 또는 이름있는 파이프에 대한 연결을 수락하고 :class:`~Connection` 객체를 반환합니다. 인증이"
" 시도되고 실패하면 :exc:`~multiprocessing.AuthenticationError` 가 발생합니다."

#: ../Doc/library/multiprocessing.rst:2364
msgid ""
"Close the bound socket or named pipe of the listener object.  This is "
"called automatically when the listener is garbage collected.  However it "
"is advisable to call it explicitly."
msgstr ""
"리스너 객체의 바운드된 소켓 또는 이름있는 파이프를 닫습니다. 리스너가 가비지 수집될 때 자동으로 호출됩니다. 그러나 명시적으로 호출하는"
" 것이 좋습니다."

#: ../Doc/library/multiprocessing.rst:2368
msgid "Listener objects have the following read-only properties:"
msgstr "리스너 객체는 다음과 같은 읽기 전용 프로퍼티를 가집니다:"

#: ../Doc/library/multiprocessing.rst:2372
msgid "The address which is being used by the Listener object."
msgstr "리스너 객체에서 사용 중인 주소."

#: ../Doc/library/multiprocessing.rst:2376
msgid ""
"The address from which the last accepted connection came.  If this is "
"unavailable then it is ``None``."
msgstr "마지막으로 수락한 연결이 온 주소. 없으면 ``None`` 입니다."

#: ../Doc/library/multiprocessing.rst:2379
msgid ""
"Listener objects now support the context management protocol -- see "
":ref:`typecontextmanager`.  :meth:`~contextmanager.__enter__` returns the"
" listener object, and :meth:`~contextmanager.__exit__` calls "
":meth:`close`."
msgstr ""
"리스너 객체는 컨텍스트 관리 프로토콜을 지원합니다 -- :ref:`typecontextmanager`\\를 보세요. "
":meth:`~contextmanager.__enter__` 는 리스너 객체를 반환하고, "
":meth:`~contextmanager.__exit__` 는 :meth:`close`\\를 호출합니다."

#: ../Doc/library/multiprocessing.rst:2386
msgid ""
"Wait till an object in *object_list* is ready.  Returns the list of those"
" objects in *object_list* which are ready.  If *timeout* is a float then "
"the call blocks for at most that many seconds.  If *timeout* is ``None`` "
"then it will block for an unlimited period. A negative timeout is "
"equivalent to a zero timeout."
msgstr ""
"*object_list* 에 있는 객체가 준비될 때까지 기다립니다. *object_list* 에 있는 객체 중 준비된 것들의 리스트를 "
"반환합니다. *timeout* 이 float면, 호출이 최대 지정된 초만큼 블록 됩니다. *timeout* 이 ``None`` 이면, "
"시간제한 없이 블록 됩니다. 음수 timeout은 0과 같습니다."

#: ../Doc/library/multiprocessing.rst:2392
msgid "For both Unix and Windows, an object can appear in *object_list* if it is"
msgstr "유닉스와 윈도우에서 모두, *object_list* 에 등장할 수 있는 객체는 다음과 같습니다."

#: ../Doc/library/multiprocessing.rst:2395
msgid "a readable :class:`~multiprocessing.connection.Connection` object;"
msgstr "읽기 가능한 :class:`~multiprocessing.connection.Connection` 객체;"

#: ../Doc/library/multiprocessing.rst:2396
msgid "a connected and readable :class:`socket.socket` object; or"
msgstr "연결되고 읽기 가능한 :class:`socket.socket` 객체; 또는"

#: ../Doc/library/multiprocessing.rst:2397
msgid ""
"the :attr:`~multiprocessing.Process.sentinel` attribute of a "
":class:`~multiprocessing.Process` object."
msgstr ""
":class:`~multiprocessing.Process` 객체의 "
":attr:`~multiprocessing.Process.sentinel` 어트리뷰트."

#: ../Doc/library/multiprocessing.rst:2400
msgid ""
"A connection or socket object is ready when there is data available to be"
" read from it, or the other end has been closed."
msgstr "연결이나 소켓 객체는 읽을 수 있는 데이터가 있거나 반대편 끝이 닫히면 준비가 됩니다."

#: ../Doc/library/multiprocessing.rst:2403
msgid ""
"**Unix**: ``wait(object_list, timeout)`` almost equivalent "
"``select.select(object_list, [], [], timeout)``.  The difference is that,"
" if :func:`select.select` is interrupted by a signal, it can raise "
":exc:`OSError` with an error number of ``EINTR``, whereas :func:`wait` "
"will not."
msgstr ""
"**유닉스**: ``wait(object_list, timeout)`` 은 ``select.select(object_list, [], "
"[], timeout)``\\과 거의 동등합니다. 차이점은, :func:`select.select` 가 시그널에 의해 인터럽트 되면, "
"에러 번호 ``EINTR`` 로 :exc:`OSError` 를 일으키지만, :func:`wait` 는 예외를 일으키지 않는다는 것입니다."

#: ../Doc/library/multiprocessing.rst:2409
msgid ""
"**Windows**: An item in *object_list* must either be an integer handle "
"which is waitable (according to the definition used by the documentation "
"of the Win32 function ``WaitForMultipleObjects()``) or it can be an "
"object with a :meth:`fileno` method which returns a socket handle or pipe"
" handle.  (Note that pipe handles and socket handles are **not** waitable"
" handles.)"
msgstr ""
"**윈도우**: *object_list* 의 항목은 (Win32 함수 ``WaitForMultipleObjects()`` 의 설명서에서 "
"사용된 정의에 따라) 대기 가능한 정수 핸들이거나, 소켓 핸들이나 파이프 핸들을 반환하는 :meth:`fileno` 메서드가 있는 "
"개체입니다. (파이프 핸들과 소켓 핸들은 대기 가능한 핸들이 **아님** 에 유의하십시오.)"

#: ../Doc/library/multiprocessing.rst:2419
msgid "**Examples**"
msgstr "**예제**"

#: ../Doc/library/multiprocessing.rst:2421
msgid ""
"The following server code creates a listener which uses ``'secret "
"password'`` as an authentication key.  It then waits for a connection and"
" sends some data to the client::"
msgstr ""
"다음 서버 코드는 인증 키로 ``'secret password'`` 를 사용하는 리스너를 만듭니다. 그런 다음 연결을 기다리고 어떤 "
"데이터를 클라이언트로 보냅니다.::"

#: ../Doc/library/multiprocessing.rst:2440
msgid ""
"The following code connects to the server and receives some data from the"
" server::"
msgstr "다음 코드는 서버에 연결하고 서버로부터 어떤 데이터를 받습니다::"

#: ../Doc/library/multiprocessing.rst:2457
msgid ""
"The following code uses :func:`~multiprocessing.connection.wait` to wait "
"for messages from multiple processes at once::"
msgstr ""
"다음 코드는 :func:`~multiprocessing.connection.wait` 을 사용하여 여러 프로세스로부터 오는 메시지를 한 "
"번에 기다립니다::"

#: ../Doc/library/multiprocessing.rst:2496
msgid "Address Formats"
msgstr "주소 형식"

#: ../Doc/library/multiprocessing.rst:2498
msgid ""
"An ``'AF_INET'`` address is a tuple of the form ``(hostname, port)`` "
"where *hostname* is a string and *port* is an integer."
msgstr ""
"``'AF_INET'`` 주소는 ``(hostname, port)`` 형식의 튜플입니다. *hostname* 은 문자열이고, *port*"
" 는 정수입니다."

#: ../Doc/library/multiprocessing.rst:2501
msgid ""
"An ``'AF_UNIX'`` address is a string representing a filename on the "
"filesystem."
msgstr "``'AF_UNIX'`` 주소는 파일 시스템의 파일 이름을 나타내는 문자열입니다."

#: ../Doc/library/multiprocessing.rst:2507
msgid "An ``'AF_PIPE'`` address is a string of the form"
msgstr "``'AF_PIPE'`` 주소는 형식"

#: ../Doc/library/multiprocessing.rst:2505
msgid ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'`.  To use :func:`Client` to "
"connect to a named pipe on a remote computer called *ServerName* one "
"should use an address of the form "
":samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` instead."
msgstr ""
":samp:`r'\\\\\\\\.\\\\pipe\\\\{PipeName}'` 의 문자열입니다. :func:`Client` 를 사용하여 "
"*ServerName* 이라는 원격 컴퓨터의 이름있는 파이프에 연결하려면, 대신 "
":samp:`r'\\\\\\\\{ServerName}\\\\pipe\\\\{PipeName}'` 형식의 주소를 사용해야 합니다."

#: ../Doc/library/multiprocessing.rst:2509
msgid ""
"Note that any string beginning with two backslashes is assumed by default"
" to be an ``'AF_PIPE'`` address rather than an ``'AF_UNIX'`` address."
msgstr ""
"두 개의 역 슬래시로 시작하는 문자열은 기본적으로 ``'AF_UNIX'`` 주소가 아니라 ``'AF_PIPE'`` 주소로 간주합니다."

#: ../Doc/library/multiprocessing.rst:2516
msgid "Authentication keys"
msgstr "인증 키"

#: ../Doc/library/multiprocessing.rst:2518
msgid ""
"When one uses :meth:`Connection.recv <Connection.recv>`, the data "
"received is automatically unpickled. Unfortunately unpickling data from "
"an untrusted source is a security risk. Therefore :class:`Listener` and "
":func:`Client` use the :mod:`hmac` module to provide digest "
"authentication."
msgstr ""
":meth:`Connection.recv <Connection.recv>` 를 사용할 때, 수신된 데이터는 자동으로 언 피클 됩니다. "
"안타깝게도, 신뢰할 수 없는 출처의 데이터를 언 피클 하는 것은 보안상의 위험입니다. 때문에 :class:`Listener`\\와 "
":func:`Client` 는 :mod:`hmac` 모듈을 사용하여 다이제스트 인증을 제공합니다."

#: ../Doc/library/multiprocessing.rst:2524
msgid ""
"An authentication key is a byte string which can be thought of as a "
"password: once a connection is established both ends will demand proof "
"that the other knows the authentication key.  (Demonstrating that both "
"ends are using the same key does **not** involve sending the key over the"
" connection.)"
msgstr ""
"인증 키는 암호로 여겨질 수 있는 바이트열입니다: 일단 연결이 이루어지면 양 끝은 다른 쪽이 인증 키를 알고 있음을 증명하도록 "
"요구합니다. (양쪽 끝이 같은 키를 사용하고 있음을 증명하는 데는 연결을 통해 키를 보내는 것을 수반하지 **않습니다**.)"

#: ../Doc/library/multiprocessing.rst:2530
msgid ""
"If authentication is requested but no authentication key is specified "
"then the return value of ``current_process().authkey`` is used (see "
":class:`~multiprocessing.Process`).  This value will be automatically "
"inherited by any :class:`~multiprocessing.Process` object that the "
"current process creates. This means that (by default) all processes of a "
"multi-process program will share a single authentication key which can be"
" used when setting up connections between themselves."
msgstr ""
"인증이 요청되었지만 인증 키가 지정되지 않으면, ``current_process().authkey`` 의 반환 값이 사용됩니다 "
"(:class:`~multiprocessing.Process` 를 보세요). 이 값은 현재 프로세스가 생성하는 "
":class:`~multiprocessing.Process` 객체에 의해 자동으로 상속됩니다. 이것은 다중 프로세스 프로그램의 모든 "
"프로세스는 (기본적으로) 자신들 간의 연결을 설정할 때 사용할 수 있는 하나의 인증 키를 공유한다는 것을 뜻합니다."

#: ../Doc/library/multiprocessing.rst:2538
msgid ""
"Suitable authentication keys can also be generated by using "
":func:`os.urandom`."
msgstr "적절한 인증 키는 :func:`os.urandom` 을 사용하여 생성할 수도 있습니다."

#: ../Doc/library/multiprocessing.rst:2542
msgid "Logging"
msgstr "로깅"

#: ../Doc/library/multiprocessing.rst:2544
msgid ""
"Some support for logging is available.  Note, however, that the "
":mod:`logging` package does not use process shared locks so it is "
"possible (depending on the handler type) for messages from different "
"processes to get mixed up."
msgstr ""
"로깅에 대한 일부 지원이 제공됩니다. 그러나, :mod:`logging` 패키지는 프로세스 공유 록을 사용하지 않으므로 (처리기형에 "
"따라) 다른 프로세스의 메시지가 뒤섞일 가능성이 있습니다."

#: ../Doc/library/multiprocessing.rst:2551
msgid ""
"Returns the logger used by :mod:`multiprocessing`.  If necessary, a new "
"one will be created."
msgstr ":mod:`multiprocessing`\\에서 사용되는 로거를 반환합니다. 필요하다면, 새로운 것이 만들어집니다."

#: ../Doc/library/multiprocessing.rst:2554
msgid ""
"When first created the logger has level :data:`logging.NOTSET` and no "
"default handler. Messages sent to this logger will not by default "
"propagate to the root logger."
msgstr ""
"로거가 처음 생성되면 수준 :data:`logging.NOTSET` 을 가지며 기본 처리기가 없습니다. 이 로거로 보낸 메시지는 "
"기본적으로 루트 로거에 전파되지 않습니다."

#: ../Doc/library/multiprocessing.rst:2558
msgid ""
"Note that on Windows child processes will only inherit the level of the "
"parent process's logger -- any other customization of the logger will not"
" be inherited."
msgstr ""
"윈도우에서 자식 프로세스는 부모 프로세스의 로거의 수준만 상속받습니다 -- 그 밖의 다른 로거 사용자 지정은 상속되지 않습니다."

#: ../Doc/library/multiprocessing.rst:2565
#, python-format
msgid ""
"This function performs a call to :func:`get_logger` but in addition to "
"returning the logger created by get_logger, it adds a handler which sends"
" output to :data:`sys.stderr` using format "
"``'[%(levelname)s/%(processName)s] %(message)s'``."
msgstr ""
"이 함수는 :func:`get_logger`\\를 호출하지만, get_logger에 의해 생성된 로거를 반환하는 것 외에, "
"``'[%(levelname)s/%(processName)s] %(message)s'`` 포맷을 사용하여 "
":data:`sys.stderr` 에 출력을 전송하는 처리기를 추가합니다."

#: ../Doc/library/multiprocessing.rst:2570
msgid "Below is an example session with logging turned on::"
msgstr "다음은 로깅이 켜져 있는 예제 세션입니다::"

#: ../Doc/library/multiprocessing.rst:2585
msgid "For a full table of logging levels, see the :mod:`logging` module."
msgstr "로깅 수준의 전체 표는 :mod:`logging` 모듈을 참조하십시오."

#: ../Doc/library/multiprocessing.rst:2589
msgid "The :mod:`multiprocessing.dummy` module"
msgstr ":mod:`multiprocessing.dummy` 모듈"

#: ../Doc/library/multiprocessing.rst:2594
msgid ""
":mod:`multiprocessing.dummy` replicates the API of :mod:`multiprocessing`"
" but is no more than a wrapper around the :mod:`threading` module."
msgstr ""
":mod:`multiprocessing.dummy` 는 :mod:`multiprocessing` 의 API를 복제하지만 "
":mod:`threading` 모듈에 대한 래퍼일 뿐입니다."

#: ../Doc/library/multiprocessing.rst:2601
msgid "Programming guidelines"
msgstr "프로그래밍 지침"

#: ../Doc/library/multiprocessing.rst:2603
msgid ""
"There are certain guidelines and idioms which should be adhered to when "
"using :mod:`multiprocessing`."
msgstr ":mod:`multiprocessing`\\를 사용할 때 준수해야 할 지침과 관용구가 있습니다."

#: ../Doc/library/multiprocessing.rst:2608
msgid "All start methods"
msgstr "모든 시작 방법"

#: ../Doc/library/multiprocessing.rst:2610
msgid "The following applies to all start methods."
msgstr "다음은 모든 시작 방법에 적용됩니다."

#: ../Doc/library/multiprocessing.rst:2612
msgid "Avoid shared state"
msgstr "공유 상태를 피하세요"

#: ../Doc/library/multiprocessing.rst:2614
msgid ""
"As far as possible one should try to avoid shifting large amounts of data"
" between processes."
msgstr "가능한 한 프로세스 간에 많은 양의 데이터가 이동하지 않도록 해야 합니다."

#: ../Doc/library/multiprocessing.rst:2617
msgid ""
"It is probably best to stick to using queues or pipes for communication "
"between processes rather than using the lower level synchronization "
"primitives."
msgstr "저수준 동기화 프리미티브를 사용하기보다, 프로세스 간 통신을 위해 큐나 파이프를 사용하는 것이 아마도 최선입니다."

#: ../Doc/library/multiprocessing.rst:2621
msgid "Picklability"
msgstr "피클 가능성"

#: ../Doc/library/multiprocessing.rst:2623
msgid "Ensure that the arguments to the methods of proxies are picklable."
msgstr "프락시 메서드에 대한 인자가 피클 가능한지 확인하십시오."

#: ../Doc/library/multiprocessing.rst:2625
msgid "Thread safety of proxies"
msgstr "프락시의 스레드 안전성"

#: ../Doc/library/multiprocessing.rst:2627
msgid ""
"Do not use a proxy object from more than one thread unless you protect it"
" with a lock."
msgstr "록으로 보호하지 않는 한 둘 이상의 스레드에서 프락시 객체를 사용하지 마십시오."

#: ../Doc/library/multiprocessing.rst:2630
msgid ""
"(There is never a problem with different processes using the *same* "
"proxy.)"
msgstr "(여러 프로세스가 *같은* 프락시를 사용하는 문제는 존재하지 않습니다.)"

#: ../Doc/library/multiprocessing.rst:2632
msgid "Joining zombie processes"
msgstr "좀비 프로세스 조인하기"

#: ../Doc/library/multiprocessing.rst:2634
msgid ""
"On Unix when a process finishes but has not been joined it becomes a "
"zombie. There should never be very many because each time a new process "
"starts (or :func:`~multiprocessing.active_children` is called) all "
"completed processes which have not yet been joined will be joined.  Also "
"calling a finished process's :meth:`Process.is_alive "
"<multiprocessing.Process.is_alive>` will join the process.  Even so it is"
" probably good practice to explicitly join all the processes that you "
"start."
msgstr ""
"유닉스에서 프로세스가 끝났지만 조인되지 않으면 좀비가 됩니다. 너무 많이 생기지는 않아야 하는데, 새로운 프로세스가 시작될 때마다 (또는"
" :func:`~multiprocessing.active_children` 이 호출 되면) 아직 조인되지 않은 모든 완료된 프로세스를 "
"조인하기 때문입니다. 또한, 완료된 프로세스의 :meth:`Process.is_alive "
"<multiprocessing.Process.is_alive>` 를 호출하면 조인합니다. 그렇다고 하더라도 여러분이 시작시키는 모든 "
"프로세스를 명시적으로 조인하는 것이 좋습니다."

#: ../Doc/library/multiprocessing.rst:2642
msgid "Better to inherit than pickle/unpickle"
msgstr "피클/언 피클보다 상속하는 것이 더 좋습니다."

#: ../Doc/library/multiprocessing.rst:2644
msgid ""
"When using the *spawn* or *forkserver* start methods many types from "
":mod:`multiprocessing` need to be picklable so that child processes can "
"use them.  However, one should generally avoid sending shared objects to "
"other processes using pipes or queues. Instead you should arrange the "
"program so that a process which needs access to a shared resource created"
" elsewhere can inherit it from an ancestor process."
msgstr ""
"*spawn* 이나 *forkserver* 시작 방법을 사용할 때, :mod:`multiprocessing` 의 여러 형은 자식 "
"프로세스가 사용할 수 있도록 피클 가능할 필요가 있습니다. 그러나, 일반적으로 파이프나 큐를 사용하여 공유 객체를 다른 프로세스로 보내는"
" 것을 피해야 합니다. 대신 다른 곳에 만들어진 공유 자원에 접근해야 하는 프로세스가 조상 프로세스에서 그것들을 상속받을 수 있도록 "
"프로그램을 배치해야 합니다."

#: ../Doc/library/multiprocessing.rst:2652
msgid "Avoid terminating processes"
msgstr "프로세스 강제 종료를 피하세요"

#: ../Doc/library/multiprocessing.rst:2654
msgid ""
"Using the :meth:`Process.terminate <multiprocessing.Process.terminate>` "
"method to stop a process is liable to cause any shared resources (such as"
" locks, semaphores, pipes and queues) currently being used by the process"
" to become broken or unavailable to other processes."
msgstr ""
":meth:`Process.terminate <multiprocessing.Process.terminate>` 메서드를 사용해서 "
"프로세스를 정지시키는 것은, 그 프로세스가 현재 사용하고 있는 공유 자원(가령 록, 세마포어, 파이프, 큐)을 손상하거나 다른 "
"프로세스에서 사용할 수 없게 만들 수 있습니다."

#: ../Doc/library/multiprocessing.rst:2660
msgid ""
"Therefore it is probably best to only consider using "
":meth:`Process.terminate <multiprocessing.Process.terminate>` on "
"processes which never use any shared resources."
msgstr ""
"따라서, 아마도 어떤 공유 자원도 사용하지 않는 프로세스에만 :meth:`Process.terminate "
"<multiprocessing.Process.terminate>` 사용을 고려하는 것이 최선일 겁니다."

#: ../Doc/library/multiprocessing.rst:2664
msgid "Joining processes that use queues"
msgstr "큐를 사용하는 프로세스 조인하기"

#: ../Doc/library/multiprocessing.rst:2666
msgid ""
"Bear in mind that a process that has put items in a queue will wait "
"before terminating until all the buffered items are fed by the \"feeder\""
" thread to the underlying pipe.  (The child process can call the "
":meth:`Queue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` method of the queue to avoid "
"this behaviour.)"
msgstr ""
"큐에 항목을 넣은 프로세스는 종료되기 전에 버퍼링 된 모든 항목이 \"피더\" 스레드에 의해 하부 파이프로 공급될 때까지 대기합니다. "
"(자식 프로세스는 :meth:`Queue.cancel_join_thread "
"<multiprocessing.Queue.cancel_join_thread>` 메서드를 호출해서 이 동작을 회피할 수 있습니다.)"

#: ../Doc/library/multiprocessing.rst:2672
msgid ""
"This means that whenever you use a queue you need to make sure that all "
"items which have been put on the queue will eventually be removed before "
"the process is joined.  Otherwise you cannot be sure that processes which"
" have put items on the queue will terminate.  Remember also that non-"
"daemonic processes will be joined automatically."
msgstr ""
"이것은, 큐를 사용할 때마다 큐에 넣은 모든 항목이 결국 프로세스가 조인되기 전에 제거되도록 해야 함을 의미합니다. 그렇지 않으면 큐에 "
"항목을 넣은 프로세스가 종료되리라고 보장할 수 없습니다. 데몬이 아닌 프로세스가 자동으로 조인된다는 것도 기억하세요."

#: ../Doc/library/multiprocessing.rst:2678
msgid "An example which will deadlock is the following::"
msgstr "교착 상태에 빠지는 예는 다음과 같습니다::"

#: ../Doc/library/multiprocessing.rst:2692
msgid ""
"A fix here would be to swap the last two lines (or simply remove the "
"``p.join()`` line)."
msgstr ""
"이 문제를 고치는 방법은 마지막 두 줄의 순서를 바꾸는 것입니다 (또는 간단히 ``p.join()`` 줄을 지우는 것입니다)."

#: ../Doc/library/multiprocessing.rst:2695
msgid "Explicitly pass resources to child processes"
msgstr "자식 프로세스에 자원을 명시적으로 전달하세요."

#: ../Doc/library/multiprocessing.rst:2697
msgid ""
"On Unix using the *fork* start method, a child process can make use of a "
"shared resource created in a parent process using a global resource.  "
"However, it is better to pass the object as an argument to the "
"constructor for the child process."
msgstr ""
"*fork* 시작 방법을 사용하는 유닉스에서, 자식 프로세스는 전역 자원을 사용하여 부모 프로세스에서 생성된 공유 자원을 사용할 수 "
"있습니다. 그러나 자식 프로세스의 생성자에 객체를 인자로 전달하는 것이 더 좋습니다."

#: ../Doc/library/multiprocessing.rst:2702
msgid ""
"Apart from making the code (potentially) compatible with Windows and the "
"other start methods this also ensures that as long as the child process "
"is still alive the object will not be garbage collected in the parent "
"process.  This might be important if some resource is freed when the "
"object is garbage collected in the parent process."
msgstr ""
"윈도우 및 다른 시작 방법과 (잠재적으로) 호환될 수 있는 코드를 만드는 것 외에도, 이것은 자식 프로세스가 아직 살아있는 동안 객체가 "
"부모 프로세스에서 가비지 수집되지 않음을 보장합니다. 부모 프로세스에서 그 객체가 가비지 수집될 때 일부 자원이 해제되면 이것이 중요 할"
" 수 있습니다."

#: ../Doc/library/multiprocessing.rst:2709
msgid "So for instance ::"
msgstr "그래서 예를 들면 ::"

#: ../Doc/library/multiprocessing.rst:2721
msgid "should be rewritten as ::"
msgstr "는 다음과 같이 다시 써야 합니다 ::"

#: ../Doc/library/multiprocessing.rst:2733
msgid "Beware of replacing :data:`sys.stdin` with a \"file like object\""
msgstr ":data:`sys.stdin` 을 \"파일류 객체\"로 교체할 때 조심하세요"

#: ../Doc/library/multiprocessing.rst:2735
msgid ":mod:`multiprocessing` originally unconditionally called::"
msgstr ":mod:`multiprocessing`\\은 원래 무조건 다음과 같이 호출했습니다 ::"

#: ../Doc/library/multiprocessing.rst:2739
msgid ""
"in the :meth:`multiprocessing.Process._bootstrap` method --- this "
"resulted in issues with processes-in-processes. This has been changed "
"to::"
msgstr ""
":meth:`multiprocessing.Process._bootstrap` 메서드에서 하는 작업입니다 --- 이것은 손자 프로세스와 "
"관련된 문제로 이어졌습니다. 이것은 다음과 같이 변경되었습니다::"

#: ../Doc/library/multiprocessing.rst:2745
msgid ""
"Which solves the fundamental issue of processes colliding with each other"
" resulting in a bad file descriptor error, but introduces a potential "
"danger to applications which replace :func:`sys.stdin` with a \"file-like"
" object\" with output buffering.  This danger is that if multiple "
"processes call :meth:`~io.IOBase.close()` on this file-like object, it "
"could result in the same data being flushed to the object multiple times,"
" resulting in corruption."
msgstr ""
"이것은 프로세스가 서로 충돌해서 파일 기술자 에러를 일으키는 근본적인 문제를 해결하지만, :func:`sys.stdin` 을 출력 "
"버퍼링을 사용하는 \"파일과 유사한 객체\"로 교체하는 응용 프로그램에 잠재적 위험을 만듭니다. 이 위험은, 다중 프로세스가 이 파일류 "
"객체에 :meth:`~io.IOBase.close()`\\를 호출하면, 같은 데이터가 객체에 여러 번 플러시 되도록 만들어 손상을 일으킬"
" 수 있다는 것입니다."

#: ../Doc/library/multiprocessing.rst:2752
msgid ""
"If you write a file-like object and implement your own caching, you can "
"make it fork-safe by storing the pid whenever you append to the cache, "
"and discarding the cache when the pid changes. For example::"
msgstr ""
"파일류 객체를 작성하고 여러분 자신의 캐싱을 구현하면, 캐시에 추가할 때마다 pid를 저장하고, pid가 변경되면 캐시를 버려서 포크에 "
"안전하게 만들 수 있습니다. 예를 들면::"

#: ../Doc/library/multiprocessing.rst:2764
msgid "For more information, see :issue:`5155`, :issue:`5313` and :issue:`5331`"
msgstr "자세한 내용은 :issue:`5155`, :issue:`5313` 및 :issue:`5331`\\을 참조하십시오."

#: ../Doc/library/multiprocessing.rst:2767
msgid "The *spawn* and *forkserver* start methods"
msgstr "*spawn* 과 *forkserver* 시작 방법"

#: ../Doc/library/multiprocessing.rst:2769
msgid ""
"There are a few extra restriction which don't apply to the *fork* start "
"method."
msgstr "*fork* 시작 방법에는 적용되지 않는 몇 가지 추가 제한 사항이 있습니다."

#: ../Doc/library/multiprocessing.rst:2772
msgid "More picklability"
msgstr "더 높은 피클 가능성"

#: ../Doc/library/multiprocessing.rst:2774
msgid ""
"Ensure that all arguments to :meth:`Process.__init__` are picklable. "
"Also, if you subclass :class:`~multiprocessing.Process` then make sure "
"that instances will be picklable when the :meth:`Process.start "
"<multiprocessing.Process.start>` method is called."
msgstr ""
":meth:`Process.__init__` 에 대한 모든 인자가 피클 가능한지 확인하십시오. 또한, "
":class:`~multiprocessing.Process` 의 서브 클래스를 만들면, :meth:`Process.start "
"<multiprocessing.Process.start>` 메서드가 호출될 때 그 인스턴스가 피클 가능하도록 해야 합니다."

#: ../Doc/library/multiprocessing.rst:2779
msgid "Global variables"
msgstr "전역 변수"

#: ../Doc/library/multiprocessing.rst:2781
msgid ""
"Bear in mind that if code run in a child process tries to access a global"
" variable, then the value it sees (if any) may not be the same as the "
"value in the parent process at the time that :meth:`Process.start "
"<multiprocessing.Process.start>` was called."
msgstr ""
"자식 프로세스에서 실행되는 코드가 전역 변수에 접근하려고 시도하면, 그 값은 (있는 경우) :meth:`Process.start "
"<multiprocessing.Process.start>` 가 호출되는 시점의 부모 프로세스의 값과 같지 않을 수 있습니다."

#: ../Doc/library/multiprocessing.rst:2786
msgid ""
"However, global variables which are just module level constants cause no "
"problems."
msgstr "하지만, 모듈 수준의 상수인 전역 변수는 문제가 되지 않습니다."

#: ../Doc/library/multiprocessing.rst:2789
msgid "Safe importing of main module"
msgstr "메인 모듈의 안전한 임포트"

#: ../Doc/library/multiprocessing.rst:2791
msgid ""
"Make sure that the main module can be safely imported by a new Python "
"interpreter without causing unintended side effects (such a starting a "
"new process)."
msgstr ""
"메인 모듈이 의도하지 않은 부작용(가령 새 프로세스 시작)을 일으키지 않고 새 파이썬 인터프리터가 안전하게 임포트 할 수 있는지 "
"확인하십시오."

#: ../Doc/library/multiprocessing.rst:2795
msgid ""
"For example, using the *spawn* or *forkserver* start method running the "
"following module would fail with a :exc:`RuntimeError`::"
msgstr ""
"예를 들어, *spawn* 또는 *forkserver* 시작 방법을 사용해서 다음 모듈을 실행하면 :exc:`RuntimeError` 로"
" 실패합니다::"

#: ../Doc/library/multiprocessing.rst:2807
msgid ""
"Instead one should protect the \"entry point\" of the program by using "
"``if __name__ == '__main__':`` as follows::"
msgstr ""
"대신 다음과 같이 ``if __name__ == '__main__':`` 을 사용하여 프로그램의 \"진입 지점\"을 보호해야 합니다::"

#: ../Doc/library/multiprocessing.rst:2821
msgid ""
"(The ``freeze_support()`` line can be omitted if the program will be run "
"normally instead of frozen.)"
msgstr "(``freeze_support()`` 줄은 프로그램이 프로즌 되지 않고 정상적으로 실행될 경우 생략될 수 있습니다.)"

#: ../Doc/library/multiprocessing.rst:2824
msgid ""
"This allows the newly spawned Python interpreter to safely import the "
"module and then run the module's ``foo()`` function."
msgstr ""
"이것은 새로 스폰 된 파이썬 인터프리터가 모듈을 안전하게 임포트 한 다음 모듈의 ``foo()`` 함수를 ​​실행할 수 있게 해줍니다."

#: ../Doc/library/multiprocessing.rst:2827
msgid ""
"Similar restrictions apply if a pool or manager is created in the main "
"module."
msgstr "메인 모듈에서 풀이나 관리자를 만들면 비슷한 제한이 적용됩니다."

#: ../Doc/library/multiprocessing.rst:2834
msgid "Examples"
msgstr "예제"

#: ../Doc/library/multiprocessing.rst:2836
msgid "Demonstration of how to create and use customized managers and proxies:"
msgstr "사용자 정의된 관리자와 프락시를 만들고 사용하는 방법에 대한 시연:"

#: ../Doc/library/multiprocessing.rst:2842
msgid "Using :class:`~multiprocessing.pool.Pool`:"
msgstr ":class:`~multiprocessing.pool.Pool` 사용하기:"

#: ../Doc/library/multiprocessing.rst:2848
msgid ""
"An example showing how to use queues to feed tasks to a collection of "
"worker processes and collect the results:"
msgstr "큐를 사용하여 작업을 작업자 프로세스 집단에 제공하고 결과를 수집하는 방법을 보여주는 예:"
