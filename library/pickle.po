# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 11:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- 파이썬 객체 직렬화"

#: ../Doc/library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**소스 코드:** :source:`Lib/pickle.py`"

#: ../Doc/library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and "
"de-serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and "
"*\"unpickling\"* is the inverse operation, whereby a byte stream (from a "
":term:`binary file` or :term:`bytes-like object`) is converted back into "
"an object hierarchy.  Pickling (and unpickling) is alternatively known as"
" \"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
":mod:`pickle` 모듈은 파이썬 객체 구조의 직렬화와 역 직렬화를 위한 바이너리 프로토콜을 구현합니다. "
"*\"피클링(pickling)\"*\\은 파이썬 객체 계층 구조가 바이트 스트림으로 변환되는 절차이며, *\"역 "
"피클링(unpickling)\"*\\은 반대 연산으로, (:term:`바이너리 파일 <binary file>` 이나 "
":term:`바이트열류 객체 <bytes-like object>`\\로 부터의) 바이트 스트림을 객체 계층 구조로 복원합니다. "
"피클링(그리고 역 피클링)은 \"직렬화(serialization)\", \"마샬링(marshalling)\" [#]_ 또는 "
"\"평탄화(flattening)\" 라고도 합니다; 그러나, 혼란을 피하고자, 여기에서 사용된 용어는 \"피클링\" 과 \"역 피클링\""
" 입니다."

#: ../Doc/library/pickle.rst:33
msgid ""
"The :mod:`pickle` module is not secure against erroneous or maliciously "
"constructed data.  Never unpickle data received from an untrusted or "
"unauthenticated source."
msgstr ""
":mod:`pickle` 모듈은 잘못되었거나 악의적으로 생성된 데이터에 대해 안전하지 않습니다. 신뢰할 수 없거나 인증되지 않은 출처에서"
" 받은 데이터를 절대로 역 피클 하지 마십시오."

#: ../Doc/library/pickle.rst:39
msgid "Relationship to other Python modules"
msgstr "다른 파이썬 모듈과의 관계"

#: ../Doc/library/pickle.rst:42
msgid "Comparison with ``marshal``"
msgstr "``marshal`` 과의 비교"

#: ../Doc/library/pickle.rst:44
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, "
"but in general :mod:`pickle` should always be the preferred way to "
"serialize Python objects.  :mod:`marshal` exists primarily to support "
"Python's :file:`.pyc` files."
msgstr ""
"파이썬이 :mod:`marshal` 이라 불리는 좀 더 원시적인 직렬화 모듈을 가지고 있지만, 일반적으로 :mod:`pickle` 은 "
"항상 파이썬 객체를 직렬화하기 위해 선호되는 방법이어야 합니다. :mod:`marshal` 은 주로 파이썬의 :file:`.pyc` "
"파일을 지원하기 위해 존재합니다."

#: ../Doc/library/pickle.rst:49
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several "
"significant ways:"
msgstr ":mod:`pickle` 모듈은 :mod:`marshal`\\과 몇 가지 중요한 점에서 다릅니다:"

#: ../Doc/library/pickle.rst:51
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be "
"serialized again. :mod:`marshal` doesn't do this."
msgstr ""
":mod:`pickle` 모듈은 이미 직렬화된 객체를 추적하므로 나중에 같은 객체에 대한 참조가 다시 직렬화되지 않습니다. "
":mod:`marshal` 은 이렇게 하지 않습니다."

#: ../Doc/library/pickle.rst:55
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  "
"These are not handled by marshal, and in fact, attempting to marshal "
"recursive objects will crash your Python interpreter.  Object sharing "
"happens when there are multiple references to the same object in "
"different places in the object hierarchy being serialized.  :mod:`pickle`"
" stores such objects only once, and ensures that all other references "
"point to the master copy.  Shared objects remain shared, which can be "
"very important for mutable objects."
msgstr ""
"이는 재귀 객체와 객체 공유에 모두 관련이 있습니다. 재귀 객체는 자신에 대한 참조를 포함하는 객체입니다. 이것은 마샬에 의해 처리되지 "
"않으며, 실제로 재귀 객체를 마샬 하려고 하면 파이썬 인터프리터가 충돌합니다. 객체 공유는 직렬화되는 객체 계층의 다른 위치에서 같은 "
"객체에 대한 다중 참조가 있을 때 발생합니다. :mod:`pickle` 은 그러한 객체를 한 번만 저장하고, 다른 모든 참조가 마스터 "
"복사본을 가리키도록 만듭니다. 공유 객체는 공유된 상태로 유지되는데, 가변 객체의 경우 매우 중요할 수 있습니다."

#: ../Doc/library/pickle.rst:64
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their"
" instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live "
"in the same module as when the object was stored."
msgstr ""
":mod:`marshal`\\은 사용자 정의 클래스와 인스턴스를 직렬화하는 데 사용할 수 없습니다. :mod:`pickle` 은 클래스 "
"인스턴스를 투명하게 저장하고 복원할 수 있지만, 클래스 정의는 객체를 저장할 때와 같은 모듈에 존재하고 임포트 할 수 있어야 합니다."

#: ../Doc/library/pickle.rst:69
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support "
":file:`.pyc` files, the Python implementers reserve the right to change "
"the serialization format in non-backwards compatible ways should the need"
" arise. The :mod:`pickle` serialization format is guaranteed to be "
"backwards compatible across Python releases."
msgstr ""
":mod:`marshal` 직렬화 형식은 파이썬 버전 간에 이식성이 보장되지 않습니다. 가장 중요한 일은 :file:`.pyc` 파일을 "
"지원하는 것이므로, 파이썬 구현자는 필요할 때 직렬화 형식을 과거 호환되지 않는 방식으로 변경할 권리를 갖습니다. "
":mod:`pickle` 직렬화 형식은 파이썬 배포 간의 과거 호환성을 보장합니다."

#: ../Doc/library/pickle.rst:77
msgid "Comparison with ``json``"
msgstr "``json`` 과의 비교"

#: ../Doc/library/pickle.rst:79
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"
msgstr ""
"pickle 프로토콜과 `JSON (JavaScript Object Notation) <http://json.org>`_ 간에는 근본적인"
" 차이가 있습니다:"

#: ../Doc/library/pickle.rst:82
msgid ""
"JSON is a text serialization format (it outputs unicode text, although "
"most of the time it is then encoded to ``utf-8``), while pickle is a "
"binary serialization format;"
msgstr ""
"JSON은 텍스트 직렬화 형식(유니코드 텍스트를 출력하지만, 대개는 ``utf-8`` 으로 인코딩됩니다)인 반면, pickle은 바이너리"
" 직렬화 형식입니다."

#: ../Doc/library/pickle.rst:86
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON은 사람이 읽을 수 있지만, 피클은 그렇지 않습니다."

#: ../Doc/library/pickle.rst:88
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, "
"while pickle is Python-specific;"
msgstr "JSON은 상호 운용이 가능하며 파이썬 생태계 외부에서 널리 사용되는 반면, 피클은 파이썬으로만 한정됩니다."

#: ../Doc/library/pickle.rst:91
msgid ""
"JSON, by default, can only represent a subset of the Python built-in "
"types, and no custom classes; pickle can represent an extremely large "
"number of Python types (many of them automatically, by clever usage of "
"Python's introspection facilities; complex cases can be tackled by "
"implementing :ref:`specific object APIs <pickle-inst>`)."
msgstr ""
"JSON은, 기본적으로, 파이썬 내장형 일부만 표시할 수 있으며 사용자 정의 클래스는 표시할 수 없습니다; 피클은 매우 많은 수의 파이썬"
" 형을 나타낼 수 있습니다 (그중 많은 것들은 파이썬의 인트로스펙션 기능을 영리하게 사용하여 자동으로; 복잡한 경우는 :ref:`특정 "
"객체 API <pickle-inst>` 를 구현해서 해결할 수 있습니다)."

#: ../Doc/library/pickle.rst:98
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ":mod:`json` 모듈: JSON 직렬화와 역 직렬화를 가능하게 하는 표준 라이브러리 모듈."

#: ../Doc/library/pickle.rst:105
msgid "Data stream format"
msgstr "데이터 스트림 형식"

#: ../Doc/library/pickle.rst:110
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards "
"such as JSON or XDR (which can't represent pointer sharing); however it "
"means that non-Python programs may not be able to reconstruct pickled "
"Python objects."
msgstr ""
":mod:`pickle` 이 사용하는 데이터 형식은 파이썬에 고유합니다. 이것은 JSON 또는 XDR (포인터 공유를 나타낼 수 없음)과"
" 같은 외부 표준에 의해 부과된 제약이 없다는 장점이 있습니다. 그러나 비 파이썬 프로그램은 피클 된 파이썬 객체를 재구성할 수 없다는 "
"것을 의미합니다."

#: ../Doc/library/pickle.rst:115
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact "
"binary representation.  If you need optimal size characteristics, you can"
" efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"기본적으로, :mod:`pickle` 데이터 포맷은 상대적으로 간결한 바이너리 표현을 사용합니다. 최적의 크기 특성이 필요하다면, 피클 "
"된 데이터를 효율적으로 :doc:`압축 <archiving>` 할 수 있습니다."

#: ../Doc/library/pickle.rst:119
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive"
" comments about opcodes used by pickle protocols."
msgstr ""
"모듈 :mod:`pickletools` 에는 :mod:`pickle` 에 의해 생성된 데이터 스트림을 분석하는 도구가 있습니다. "
":mod:`pickletools` 소스 코드에는 피클 프로토콜에서 사용되는 옵코드(opcode)에 대한 광범위한 주석이 있습니다."

#: ../Doc/library/pickle.rst:123
msgid ""
"There are currently 5 different protocols which can be used for pickling."
" The higher the protocol used, the more recent the version of Python "
"needed to read the pickle produced."
msgstr ""
"현재 피클링에 쓸 수 있는 5가지 프로토콜이 있습니다. 사용된 프로토콜이 높을수록, 생성된 피클을 읽으려면 더 최신 파이썬 버전이 "
"필요합니다."

#: ../Doc/library/pickle.rst:127
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr "프로토콜 버전 0은 최초의 \"사람이 읽을 수 있는\" 프로토콜이며 이전 버전의 파이썬과 과거 호환됩니다."

#: ../Doc/library/pickle.rst:130
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr "프로토콜 버전 1은 역시 이전 버전의 파이썬과 호환되는 오래된 바이너리 형식입니다."

#: ../Doc/library/pickle.rst:133
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es.  Refer to :pep:`307` "
"for information about improvements brought by protocol 2."
msgstr ""
"프로토콜 버전 2는 파이썬 2.3에서 소개되었습니다. 그것은 훨씬 더 효율적인 :term:`뉴스타일 클래스 <new-style "
"class>`\\의 피클링을 제공합니다. 프로토콜 2에 의해 개선된 사항에 대한 정보는 :pep:`307`\\을 참조하십시오."

#: ../Doc/library/pickle.rst:137
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for "
":class:`bytes` objects and cannot be unpickled by Python 2.x.  This is "
"the default protocol, and the recommended protocol when compatibility "
"with other Python 3 versions is required."
msgstr ""
"프로토콜 버전 3은 파이썬 3.0에서 추가되었습니다. 명시적으로 :class:`bytes` 객체를 지원하며 파이썬 2.x에서 역 피클 될"
" 수 없습니다. 이것은 기본 프로토콜이며, 다른 파이썬 3 버전과의 호환성이 필요한 경우 권장되는 프로토콜입니다."

#: ../Doc/library/pickle.rst:142
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very "
"large objects, pickling more kinds of objects, and some data format "
"optimizations.  Refer to :pep:`3154` for information about improvements "
"brought by protocol 4."
msgstr ""
"프로토콜 버전 4가 파이썬 3.4에 추가되었습니다. 매우 큰 객체, 더 많은 종류의 객체에 대한 피클링, 일부 데이터 형식 최적화에 대한"
" 지원을 추가합니다. 프로토콜 4에 의해 개선된 사항에 대한 정보는 :pep:`3154`\\를 참조하십시오."

#: ../Doc/library/pickle.rst:148
msgid ""
"Serialization is a more primitive notion than persistence; although "
":mod:`pickle` reads and writes file objects, it does not handle the issue"
" of naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the "
"byte stream into an object with the same internal structure.  Perhaps the"
" most obvious thing to do with these byte streams is to write them onto a"
" file, but it is also conceivable to send them across a network or store "
"them in a database.  The :mod:`shelve` module provides a simple interface"
" to pickle and unpickle objects on DBM-style database files."
msgstr ""
"직렬화는 지속성보다 더 원시적인 개념입니다; :mod:`pickle` 이 파일 객체를 읽거나 쓰기는 하지만, 지속적인 객체의 이름 지정도"
" (더 복잡한) 지속적인 객체에 대한 동시 액세스 문제도 처리하지 않습니다. :mod:`pickle` 모듈은 복잡한 객체를 바이트 "
"스트림으로 변환할 수 있고 바이트 스트림을 같은 내부 구조를 가진 객체로 변환할 수 있습니다. 아마도 이러한 바이트 스트림으로 할 가장 "
"분명한 작업은 파일에 쓰는 것이겠지만, 네트워크를 통해 보내거나 데이터베이스에 저장하는 것도 고려할 수 있습니다. "
":mod:`shelve` 모듈은 DBM 스타일의 데이터베이스 파일에 객체를 피클/역 피클 하는 간단한 인터페이스를 제공합니다."

#: ../Doc/library/pickle.rst:161
msgid "Module Interface"
msgstr "모듈 인터페이스"

#: ../Doc/library/pickle.rst:163
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the "
":func:`loads` function. However, if you want more control over "
"serialization and de-serialization, you can create a :class:`Pickler` or "
"an :class:`Unpickler` object, respectively."
msgstr ""
"객체 계층 구조를 직렬화하려면, 단순히 :func:`dumps` 함수를 호출하면 됩니다. 마찬가지로, 데이터 스트림을 역 직렬화하려면 "
":func:`loads` 함수를 호출합니다. 그러나, 직렬화와 역 직렬화에 대한 더 많은 제어를 원하면, 각각 "
":class:`Pickler` 나 :class:`Unpickler` 객체를 만들 수 있습니다."

#: ../Doc/library/pickle.rst:168
msgid "The :mod:`pickle` module provides the following constants:"
msgstr ":mod:`pickle` 모듈은 다음과 같은 상수를 제공합니다:"

#: ../Doc/library/pickle.rst:173
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions "
":func:`dump` and :func:`dumps` as well as the :class:`Pickler` "
"constructor."
msgstr ""
"정수, 사용 가능한 가장 높은 :ref:`프로토콜 버전 <pickle-protocols>`. 이 값은 함수 :func:`dump`\\와 "
":func:`dumps` 그리고 :class:`Pickler` 생성자에 *protocol* 값으로 전달될 수 있습니다."

#: ../Doc/library/pickle.rst:180
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used "
"for pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the "
"default protocol is 3, a new protocol designed for Python 3."
msgstr ""
"정수, 피클링에 사용되는 기본 :ref:`프로토콜 버전 <pickle-protocols>`. :data:`HIGHEST_PROTOCOL`"
" 보다 작을 수 있습니다. 현재 기본 프로토콜은 3인데, 파이썬 3 용으로 설계된 새로운 프로토콜입니다."

#: ../Doc/library/pickle.rst:185
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ":mod:`pickle` 모듈은 피클링 절차를 보다 편리하게 하려고 다음과 같은 함수를 제공합니다:"

#: ../Doc/library/pickle.rst:190
msgid ""
"Write a pickled representation of *obj* to the open :term:`file object` "
"*file*. This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"*obj* 의 피클 된 표현을 열린 :term:`파일 객체 <file object>` *file* 에 씁니다. 이것은 "
"``Pickler(file, protocol).dump(obj)`` 와 동등합니다."

#: ../Doc/library/pickle.rst:193 ../Doc/library/pickle.rst:289
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use "
"the given protocol; supported protocols are 0 to "
":data:`HIGHEST_PROTOCOL`. If not specified, the default is "
":data:`DEFAULT_PROTOCOL`.  If a negative number is specified, "
":data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"선택적 *protocol* 인자(정수)는 피클러가 주어진 프로토콜을 사용하도록 지시합니다; 지원되는 프로토콜은 0부터 "
":data:`HIGHEST_PROTOCOL` 입니다. 지정하지 않으면 기본값은 :data:`DEFAULT_PROTOCOL` 입니다. "
"음수가 지정되면, :data:`HIGHEST_PROTOCOL` 이 선택됩니다."

#: ../Doc/library/pickle.rst:198 ../Doc/library/pickle.rst:294
msgid ""
"The *file* argument must have a write() method that accepts a single "
"bytes argument.  It can thus be an on-disk file opened for binary "
"writing, an :class:`io.BytesIO` instance, or any other custom object that"
" meets this interface."
msgstr ""
"*file* 인자에는 단일 바이트열 인자를 받아들이는 write() 메서드가 있어야 합니다. 따라서 바이너리 쓰기를 위해 열린 디스크 "
"상의 파일, :class:`io.BytesIO` 인스턴스 또는 이 인터페이스를 충족시키는 다른 사용자 정의 객체일 수 있습니다."

#: ../Doc/library/pickle.rst:203 ../Doc/library/pickle.rst:299
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try "
"to map the new Python 3 names to the old module names used in Python 2, "
"so that the pickle data stream is readable with Python 2."
msgstr ""
"*fix_imports* 가 참이고 *protocol* 이 3보다 작으면, pickle은 새로운 파이썬 3 이름을 파이썬 2에서 사용된 "
"이전 모듈 이름에 매핑하려고 시도하여, 파이썬 2에서 피클 데이터 스트림을 읽을 수 있도록 합니다."

#: ../Doc/library/pickle.rst:209
msgid ""
"Return the pickled representation of the object as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr "객체의 피클 된 표현을 파일에 쓰는 대신 :class:`bytes` 객체로 반환합니다."

#: ../Doc/library/pickle.rst:212
msgid ""
"Arguments *protocol* and *fix_imports* have the same meaning as in "
":func:`dump`."
msgstr "인자 *protocol* 과 *fix_imports* 는 :func:`dump`\\와 같은 의미입니다."

#: ../Doc/library/pickle.rst:217
msgid ""
"Read a pickled object representation from the open :term:`file object` "
"*file* and return the reconstituted object hierarchy specified therein. "
"This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"열린 :term:`파일 객체 <file object>` *file* 에서 피클 된 객체 표현을 읽고, 그 안에 지정된 객체 계층 구조를 "
"재구성하여 반환합니다. 이것은 ``Unpickler(file).load()`` 와 동등합니다."

#: ../Doc/library/pickle.rst:221 ../Doc/library/pickle.rst:244
msgid ""
"The protocol version of the pickle is detected automatically, so no "
"protocol argument is needed.  Bytes past the pickled object's "
"representation are ignored."
msgstr ""
"피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인자가 필요하지 않습니다. 피클 된 객체의 표현 뒤에 남는 바이트열은 무시됩니다."

#: ../Doc/library/pickle.rst:225
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  "
"Both methods should return bytes.  Thus *file* can be an on-disk file "
"opened for binary reading, an :class:`io.BytesIO` object, or any other "
"custom object that meets this interface."
msgstr ""
"인자 *file* 에는 두 가지 메서드가 있어야 합니다, 정수 인자를 받아들이는 read() 메서드와 인자가 없는 readline() "
"메서드. 두 메서드 모두 바이트열를 반환해야 합니다. 따라서 *file* 은 바이너리 읽기를 위해 열린 디스크 상의 파일, "
":class:`io.BytesIO` 객체 또는 이 인터페이스를 만족하는 다른 사용자 정의 객체일 수 있습니다."

#: ../Doc/library/pickle.rst:231 ../Doc/library/pickle.rst:248
#: ../Doc/library/pickle.rst:367
msgid ""
"Optional keyword arguments are *fix_imports*, *encoding* and *errors*, "
"which are used to control compatibility support for pickle stream "
"generated by Python 2.  If *fix_imports* is true, pickle will try to map "
"the old Python 2 names to the new names used in Python 3.  The *encoding*"
" and *errors* tell pickle how to decode 8-bit string instances pickled by"
" Python 2; these default to 'ASCII' and 'strict', respectively.  The "
"*encoding* can be 'bytes' to read these 8-bit string instances as bytes "
"objects."
msgstr ""
"선택적 키워드 인자는 *fix_imports*, *encoding* 및 *errors* 인데, 파이썬 2에서 생성된 피클 스트림에 대한 "
"호환성 지원을 제어하는 데 사용됩니다. *fix_imports* 가 참이면, pickle은 이전 파이썬 2 이름을 파이썬 3에서 "
"사용된 새로운 이름으로 매핑하려고 합니다. *encoding* 과 *errors* 는 파이썬 2에 의해 피클 된 8비트 문자열 인스턴스를"
" 디코딩하는 방법을 pickle에게 알려줍니다. 기본값은 각각 'ASCII'\\와 'strict' 입니다. *encoding* 은 "
"'bytes' 가 될 수 있는데, 8비트 문자열 인스턴스를 바이트열 객체로 읽습니다."

#: ../Doc/library/pickle.rst:241
msgid ""
"Read a pickled object hierarchy from a :class:`bytes` object and return "
"the reconstituted object hierarchy specified therein."
msgstr ":class:`bytes` 객체에서 피클 된 객체 계층 구조를 읽고 그 안에 지정된 객체 계층 구조를 재구성하여 반환합니다."

#: ../Doc/library/pickle.rst:257
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr ":mod:`pickle` 모듈은 세 가지 예외를 정의합니다:"

#: ../Doc/library/pickle.rst:261
msgid ""
"Common base class for the other pickling exceptions.  It inherits "
":exc:`Exception`."
msgstr "다른 피클링 예외의 공통 베이스 클래스입니다. :exc:`Exception`\\을 상속합니다."

#: ../Doc/library/pickle.rst:266
msgid ""
"Error raised when an unpicklable object is encountered by "
":class:`Pickler`. It inherits :exc:`PickleError`."
msgstr ""
":class:`Pickler` 가 피클 가능하지 않은 객체를 만날 때 발생하는 에러. :exc:`PickleError` 를 상속합니다."

#: ../Doc/library/pickle.rst:269
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr "어떤 종류의 객체가 피클 될 수 있는지 배우려면 :ref:`pickle-picklable`\\를 참조하십시오."

#: ../Doc/library/pickle.rst:274
msgid ""
"Error raised when there is a problem unpickling an object, such as a data"
" corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""
"데이터 손상 또는 보안 위반과 같이 객체를 역 피클 할 때 문제가 있으면 발생하는 에러. :exc:`PickleError` 를 "
"상속합니다."

#: ../Doc/library/pickle.rst:277
msgid ""
"Note that other exceptions may also be raised during unpickling, "
"including (but not necessarily limited to) AttributeError, EOFError, "
"ImportError, and IndexError."
msgstr ""
"역 피클링 중에 다른 예외도 발생할 수 있음에 유의하십시오. AttributeError, EOFError, ImportError, "
"IndexError 등이 발생할 수 있지만, 이에 국한되지는 않습니다."

#: ../Doc/library/pickle.rst:282
msgid ""
"The :mod:`pickle` module exports two classes, :class:`Pickler` and "
":class:`Unpickler`:"
msgstr ""
":mod:`pickle` 모듈은 두 개의 클래스를 노출합니다, :class:`Pickler`\\와 :class:`Unpickler`:"

#: ../Doc/library/pickle.rst:287
msgid "This takes a binary file for writing a pickle data stream."
msgstr "피클 데이터 스트림을 쓸 바이너리 파일을 받아들입니다."

#: ../Doc/library/pickle.rst:305
msgid ""
"Write a pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr "생성자에 주어진 열린 파일 객체에 *obj* 의 피클 된 표현을 씁니다."

#: ../Doc/library/pickle.rst:310
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr "기본적으로 아무것도 하지 않습니다. 이것은 서브 클래스가 재정의할 수 있게 하려고 존재합니다."

#: ../Doc/library/pickle.rst:312
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  "
"Any other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value "
"returned by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
":meth:`persistent_id` 가 ``None`` 을 반환하면, *obj* 는 보통 때처럼 피클 됩니다. 다른 값은 "
":class:`Pickler` 가 *obj* 의 지속성(persistent) ID로 반환 값을 출력하도록 합니다. 이 지속성 ID의 "
"의미는 :meth:`Unpickler.persistent_load` 에 의해 정의되어야 합니다. :meth:`persistent_id` "
"에 의해 반환된 값 자체는 지속성 ID를 가질 수 없음에 유의하십시오."

#: ../Doc/library/pickle.rst:318 ../Doc/library/pickle.rst:389
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "자세한 내용과 사용 예는 :ref:`pickle-persistent`\\를 참조하십시오."

#: ../Doc/library/pickle.rst:322
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* "
"of the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions."
"  A reduction function takes a single argument of the associated class "
"and should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""
"피클러 객체의 디스패치 테이블은 :func:`copyreg.pickle` 을 사용하여 선언할 수 있는 *환원 함수(reduction "
"functions)* 의 등록소입니다. 키가 클래스이고 값이 환원 함수인 매핑입니다. 환원 함수는 관련 클래스의 단일 인자를 취하며 "
":meth:`__reduce__` 메서드와 같은 인터페이스를 따라야 합니다."

#: ../Doc/library/pickle.rst:330
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by "
"the :mod:`copyreg` module. However, to customize the pickling for a "
"specific pickler object one can set the :attr:`dispatch_table` attribute "
"to a dict-like object.  Alternatively, if a subclass of :class:`Pickler` "
"has a :attr:`dispatch_table` attribute then this will be used as the "
"default dispatch table for instances of that class."
msgstr ""
"기본적으로, 피클러 객체는 :attr:`dispatch_table` 어트리뷰트를 가지지 않을 것이고, 대신 :mod:`copyreg` "
"모듈에 의해 관리되는 전역 디스패치 테이블을 사용할 것입니다. 그러나 특정 피클러 객체의 피클링을 사용자 정의하기 위해서 "
":attr:`dispatch_table` 어트리뷰트를 딕셔너리류 객체로 설정할 수 있습니다. 또는, :class:`Pickler` 의 "
"서브 클래스가 :attr:`dispatch_table` 어트리뷰트를 가지고 있다면, 이 클래스의 인스턴스를 위한 기본 디스패치 테이블로 "
"사용됩니다."

#: ../Doc/library/pickle.rst:339
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "사용 예는 :ref:`pickle-dispatch`\\을 참조하십시오."

#: ../Doc/library/pickle.rst:345
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode "
"disables the usage of memo, therefore speeding the pickling process by "
"not generating superfluous PUT opcodes.  It should not be used with self-"
"referential objects, doing otherwise will cause :class:`Pickler` to "
"recurse infinitely."
msgstr ""
"폐지되었습니다. 참값으로 설정된 경우 빠른 모드를 활성화합니다. 빠른 모드는 메모 사용을 비활성화하므로, 불필요한 PUT 옵코드를 "
"생성하지 않아 피클링 절차의 속도를 높입니다. 자신을 참조하는 객체에 사용되면 안 됩니다. 그렇지 않으면 :class:`Pickler` "
"가 무한 재귀에 빠집니다."

#: ../Doc/library/pickle.rst:351
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr "더 간결한 피클이 필요하면 :func:`pickletools.optimize` 를 사용하십시오."

#: ../Doc/library/pickle.rst:356
msgid "This takes a binary file for reading a pickle data stream."
msgstr "피클 데이터 스트림을 읽는 데 사용될 바이너리 파일을 받아들입니다."

#: ../Doc/library/pickle.rst:358
msgid ""
"The protocol version of the pickle is detected automatically, so no "
"protocol argument is needed."
msgstr "피클의 프로토콜 버전이 자동으로 감지되므로 프로토콜 인자가 필요하지 않습니다."

#: ../Doc/library/pickle.rst:361
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  "
"Both methods should return bytes.  Thus *file* can be an on-disk file "
"object opened for binary reading, an :class:`io.BytesIO` object, or any "
"other custom object that meets this interface."
msgstr ""
"인자 *file* 에는 두 가지 메서드가 있어야 합니다, 정수 인자를 받아들이는 read() 메서드와 인자가 없는 readline() "
"메서드. 두 메서드 모두 바이트열을 반환해야 합니다. 따라서 *file* 은 바이너리 읽기를 위해 열린 디스크 상의 파일 객체, "
":class:`io.BytesIO` 객체 또는 이 인터페이스를 만족하는 다른 사용자 정의 객체일 수 있습니다."

#: ../Doc/library/pickle.rst:377
msgid ""
"Read a pickled object representation from the open file object given in "
"the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled object's representation are ignored."
msgstr ""
"생성자에 주어진 열린 파일 객체에서 피클 된 객체 표현을 읽고, 그 안에 지정된 객체 계층 구조를 재구성하여 반환합니다. 피클 된 객체의"
" 표현 뒤에 남는 바이트열은 무시됩니다."

#: ../Doc/library/pickle.rst:383
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "기본적으로 :exc:`UnpicklingError`\\를 발생시킵니다."

#: ../Doc/library/pickle.rst:385
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by"
" the persistent ID *pid*.  If an invalid persistent ID is encountered, an"
" :exc:`UnpicklingError` should be raised."
msgstr ""
"정의되면, :meth:`persistent_load` 는 지속성 ID *pid* 로 지정된 객체를 반환해야 합니다. 유효하지 않은 지속성"
" ID가 발견되면 :exc:`UnpicklingError`\\를 일으켜야 합니다."

#: ../Doc/library/pickle.rst:393
msgid ""
"Import *module* if necessary and return the object called *name* from it,"
" where the *module* and *name* arguments are :class:`str` objects.  Note,"
" unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"필요하면 *module* 을 임포트하고 거기에서 *name* 이라는 객체를 반환합니다. 여기서 *module* 및 *name* 인자는 "
":class:`str` 객체입니다. 그 이름이 제시하는 것과는 달리, :meth:`find_class` 는 함수를 찾는 데에도 사용됨에 "
"유의하십시오."

#: ../Doc/library/pickle.rst:398
msgid ""
"Subclasses may override this to gain control over what type of objects "
"and how they can be loaded, potentially reducing security risks. Refer to"
" :ref:`pickle-restrict` for details."
msgstr ""
"로드되는 객체의 형과 로드 방법을 제어하기 위해 서브 클래스는 이것을 재정의할 수 있고, 잠재적으로 보안 위험을 감소시킵니다. 자세한 "
"내용은 :ref:`pickle-restrict`\\를 참조하십시오."

#: ../Doc/library/pickle.rst:406
msgid "What can be pickled and unpickled?"
msgstr "어떤 것이 피클 되고 역 피클 될 수 있을까요?"

#: ../Doc/library/pickle.rst:408
msgid "The following types can be pickled:"
msgstr "다음 형을 피클 할 수 있습니다:"

#: ../Doc/library/pickle.rst:410
msgid "``None``, ``True``, and ``False``"
msgstr "``None``, ``True`` 와 ``False``"

#: ../Doc/library/pickle.rst:412
msgid "integers, floating point numbers, complex numbers"
msgstr "정수, 실수, 복소수"

#: ../Doc/library/pickle.rst:414
msgid "strings, bytes, bytearrays"
msgstr "문자열, 바이트열, 바이트 배열(bytearray)"

#: ../Doc/library/pickle.rst:416
msgid "tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr "피클 가능한 객체만 포함하는 튜플, 리스트, 집합과 딕셔너리"

#: ../Doc/library/pickle.rst:418
msgid ""
"functions defined at the top level of a module (using :keyword:`def`, not"
" :keyword:`lambda`)"
msgstr "모듈의 최상위 수준에서 정의된 함수 (:keyword:`lambda` 가 아니라 :keyword:`def` 를 사용하는)"

#: ../Doc/library/pickle.rst:421
msgid "built-in functions defined at the top level of a module"
msgstr "모듈의 최상위 수준에서 정의된 내장 함수"

#: ../Doc/library/pickle.rst:423
msgid "classes that are defined at the top level of a module"
msgstr "모듈의 최상위 수준에서 정의된 클래스"

#: ../Doc/library/pickle.rst:425
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of"
" calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-"
"inst` for details)."
msgstr ""
"그런 클래스의 인스턴스 중에서 :attr:`~object.__dict__` 나 :meth:`__getstate__` 를 호출한 결과가 "
"피클 가능한 것들 (자세한 내용은 :ref:`pickle-inst` 절을 참조하세요)."

#: ../Doc/library/pickle.rst:429
msgid ""
"Attempts to pickle unpicklable objects will raise the "
":exc:`PicklingError` exception; when this happens, an unspecified number "
"of bytes may have already been written to the underlying file.  Trying to"
" pickle a highly recursive data structure may exceed the maximum "
"recursion depth, a :exc:`RecursionError` will be raised in this case.  "
"You can carefully raise this limit with :func:`sys.setrecursionlimit`."
msgstr ""
"피클 가능하지 않은 객체를 피클 하려고 하면 :exc:`PicklingError` 예외가 발생합니다; 이런 일이 일어났을 때, 특정할 수"
" 없는 길이의 바이트열이 하부 파일에 이미 기록되었을 수 있습니다. 매우 재귀적인 데이터 구조를 피클 하려고 하면 최대 재귀 깊이를 "
"초과할 수 있고, 이때 :exc:`RecursionError` 가 발생합니다. :func:`sys.setrecursionlimit` 을 "
"사용하여 이 제한을 조심스럽게 올릴 수 있습니다."

#: ../Doc/library/pickle.rst:436
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the module the function "
"is defined in.  Neither the function's code, nor any of its function "
"attributes are pickled.  Thus the defining module must be importable in "
"the unpickling environment, and the module must contain the named object,"
" otherwise an exception will be raised. [#]_"
msgstr ""
"함수(내장 및 사용자 정의)는 값이 아니라 \"완전히 정규화된\" 이름 참조로 피클 됨에 유의하십시오. [#]_ 이것은 함수가 정의된 "
"모듈의 이름과 함께 함수의 이름만 피클 된다는 것을 의미합니다. 함수의 코드도 함수 어트리뷰트도 피클 되지 않습니다. 따라서 정의하는 "
"모듈은 역 피클 환경에서 임포트 가능해야 하며, 모듈에는 그 이름의 객체가 있어야 합니다. 그렇지 않으면 예외가 발생합니다. [#]_"

#: ../Doc/library/pickle.rst:443
msgid ""
"Similarly, classes are pickled by named reference, so the same "
"restrictions in the unpickling environment apply.  Note that none of the "
"class's code or data is pickled, so in the following example the class "
"attribute ``attr`` is not restored in the unpickling environment::"
msgstr ""
"마찬가지로, 클래스는 이름 참조로 피클 되므로 역 피클링 환경에서 같은 제한이 적용됩니다. 클래스의 코드 나 데이터가 피클 되지 않음에 "
"유의하세요. 그래서 다음 예제에서 클래스 어트리뷰트 ``attr`` 은 역 피클링 환경에서 복원되지 않습니다::"

#: ../Doc/library/pickle.rst:453
msgid ""
"These restrictions are why picklable functions and classes must be "
"defined in the top level of a module."
msgstr "이러한 제한이 피클 가능한 함수와 클래스가 모듈의 최상위 수준에서 정의되어야 하는 이유입니다."

#: ../Doc/library/pickle.rst:456
msgid ""
"Similarly, when class instances are pickled, their class's code and data "
"are not pickled along with them.  Only the instance data are pickled.  "
"This is done on purpose, so you can fix bugs in a class or add methods to"
" the class and still load objects that were created with an earlier "
"version of the class.  If you plan to have long-lived objects that will "
"see many versions of a class, it may be worthwhile to put a version "
"number in the objects so that suitable conversions can be made by the "
"class's :meth:`__setstate__` method."
msgstr ""
"마찬가지로, 클래스 인스턴스가 피클 될 때, 클래스의 코드와 데이터는 함께 피클 되지 않습니다. 인스턴스 데이터만 피클 됩니다. 이는 "
"의도한 것으로, 클래스의 버그를 수정하거나 클래스에 메서드를 추가할 수 있고, 이전 버전의 클래스로 만들어진 객체를 여전히 로드 할 수 "
"있습니다. 여러 버전의 클래스에 걸치는 수명이 긴 객체를 만들 계획이라면, 클래스의 :meth:`__setstate__` 메서드로 적절한"
" 변환을 할 수 있도록 객체에 버전 번호를 넣는 것이 좋습니다."

#: ../Doc/library/pickle.rst:468
msgid "Pickling Class Instances"
msgstr "클래스 인스턴스 피클링"

#: ../Doc/library/pickle.rst:472
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and "
"unpickled."
msgstr ""
"이 절에서는 클래스 인스턴스를 피클 및 역 피클 하는 방법을 정의, 사용자 정의 및 제어할 수 있는 일반적인 메커니즘을 설명합니다."

#: ../Doc/library/pickle.rst:475
msgid ""
"In most cases, no additional code is needed to make instances picklable."
"  By default, pickle will retrieve the class and the attributes of an "
"instance via introspection. When a class instance is unpickled, its "
":meth:`__init__` method is usually *not* invoked.  The default behaviour "
"first creates an uninitialized instance and then restores the saved "
"attributes.  The following code shows an implementation of this "
"behaviour::"
msgstr ""
"대부분은, 인스턴스를 피클 가능하게 만드는 데 추가 코드가 필요하지 않습니다. 기본적으로, pickle은 인트로스펙션을 통해 인스턴스의 "
"클래스와 어트리뷰트를 조회합니다. 클래스 인스턴스가 역 피클 될 때, :meth:`__init__` 메서드는 보통 호출되지 *않습니다*."
" 기본 동작은, 먼저 초기화되지 않은 인스턴스를 만든 다음 저장된 어트리뷰트를 복원합니다. 다음 코드는 이 동작의 구현을 보여줍니다::"

#: ../Doc/library/pickle.rst:490
msgid ""
"Classes can alter the default behaviour by providing one or several "
"special methods:"
msgstr "클래스는 다음과 같은 하나 이상의 특수 메서드를 제공하여 기본 동작을 변경할 수 있습니다:"

#: ../Doc/library/pickle.rst:495
msgid ""
"In protocols 2 and newer, classes that implements the "
":meth:`__getnewargs_ex__` method can dictate the values passed to the "
":meth:`__new__` method upon unpickling.  The method must return a pair "
"``(args, kwargs)`` where *args* is a tuple of positional arguments and "
"*kwargs* a dictionary of named arguments for constructing the object.  "
"Those will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"프로토콜 2 이상에서, :meth:`__getnewargs_ex__` 메서드를 구현하는 클래스는 역 피클링 때 "
":meth:`__new__` 메서드에 전달되는 값을 지시할 수 있습니다. 이 메서드는 ``(args, kwargs)`` 쌍을 반환해야 "
"합니다. *args* 는 위치 인자의 튜플이고 *kwargs* 는 이름있는 인자의 딕셔너리인데, 객체를 구성하는 데 사용됩니다. 그것들은"
" 역 피클링 때 :meth:`__new__` 메서드로 전달될 것입니다."

#: ../Doc/library/pickle.rst:503
msgid ""
"You should implement this method if the :meth:`__new__` method of your "
"class requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"클래스의 :meth:`__new__` 메서드에 키워드 전용 인자가 필요하면 이 메서드를 구현해야 합니다. 그렇지 않으면 호환성을 위해 "
":meth:`__getnewargs__` 를 구현하는 것이 좋습니다."

#: ../Doc/library/pickle.rst:507
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` 는 이제 프로토콜 2와 3에서 사용됩니다."

#: ../Doc/library/pickle.rst:513
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon "
"unpickling."
msgstr ""
"이 메서드는 :meth:`__getnewargs_ex__` 와 비슷한 목적을 수행하지만, 위치 인자만 지원합니다. 역 피클링 때 "
":meth:`__new__` 메서드에 전달될 인자의 튜플 ``args`` 를 반환해야 합니다."

#: ../Doc/library/pickle.rst:517
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is"
" defined."
msgstr ":meth:`__getnewargs_ex__` 가 정의되면 :meth:`__getnewargs__` 는 호출되지 않습니다."

#: ../Doc/library/pickle.rst:520
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of "
":meth:`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"파이썬 3.6 이전에는, 프로토콜 2와 3에서 :meth:`__getnewargs_ex__` 대신 "
":meth:`__getnewargs__` 가 호출되었습니다."

#: ../Doc/library/pickle.rst:527
msgid ""
"Classes can further influence how their instances are pickled; if the "
"class defines the method :meth:`__getstate__`, it is called and the "
"returned object is pickled as the contents for the instance, instead of "
"the contents of the instance's dictionary.  If the :meth:`__getstate__` "
"method is absent, the instance's :attr:`~object.__dict__` is pickled as "
"usual."
msgstr ""
"클래스는 인스턴스가 피클 되는 방식에 더 많은 영향을 줄 수 있습니다; 클래스가 메서드 :meth:`__getstate__` 를 "
"정의하면, 인스턴스의 딕셔너리 내용 대신, 이 메서드가 호출되고 반환된 객체를 인스턴스의 내용으로 피클 합니다. "
":meth:`__getstate__` 메서드가 없다면, 인스턴스의 :attr:`~object.__dict__` 가 평소와 같이 피클 "
"됩니다."

#: ../Doc/library/pickle.rst:536
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"역 피클링 때, 클래스가 :meth:`__setstate__` 를 정의하면, 그것은 역 피클 된 상태(state)로 호출됩니다. 이 경우"
" 상태 객체가 딕셔너리일 필요는 없습니다. 그렇지 않으면, 피클 된 상태는 딕셔너리 여야하고 그 항목이 새 인스턴스의 딕셔너리에 "
"삽입됩니다."

#: ../Doc/library/pickle.rst:543
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""
":meth:`__getstate__` 가 거짓 값을 반환하면, :meth:`__setstate__` 메서드가 역 피클링 때 호출되지 "
"않습니다."

#: ../Doc/library/pickle.rst:547
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how "
"to use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""
":meth:`__getstate__` 와 :meth:`__setstate__` 메서드를 사용하는 방법에 대한 더 자세한 정보는 "
":ref:`pickle-state` 절을 참조하십시오."

#: ../Doc/library/pickle.rst:552
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, "
":meth:`__getattribute__`, or :meth:`__setattr__` may be called upon the "
"instance.  In case those methods rely on some internal invariant being "
"true, the type should implement :meth:`__getnewargs__` or "
":meth:`__getnewargs_ex__` to establish such an invariant; otherwise, "
"neither :meth:`__new__` nor :meth:`__init__` will be called."
msgstr ""
"역 피클링 시간에, :meth:`__getattr__`, :meth:`__getattribute__`, 또는 "
":meth:`__setattr__` 같은 메서드가 인스턴스에 호출될 수 있습니다. 그러한 메서드들이 어떤 내부 불변성이 참인 것에 "
"의존하는 경우, 형은 그런 불변성을 유지하기 위해 :meth:`__getnewargs__` 나 "
":meth:`__getnewargs_ex__` 를 구현해야 합니다; 그렇지 않으면, :meth:`__new__` 도 "
":meth:`__init__` 도 호출되지 않습니다."

#: ../Doc/library/pickle.rst:561
msgid ""
"As we shall see, pickle does not use directly the methods described "
"above.  In fact, these methods are part of the copy protocol which "
"implements the :meth:`__reduce__` special method.  The copy protocol "
"provides a unified interface for retrieving the data necessary for "
"pickling and copying objects. [#]_"
msgstr ""
"앞으로 살펴보겠지만, 피클은 위에서 설명한 메서드를 직접 사용하지 않습니다. 사실, 이 메서드들은 :meth:`__reduce__` 특수"
" 메서드를 구현하는 복사 프로토콜의 일부입니다. 복사 프로토콜은 객체를 피클 하고 복사하는 데 필요한 데이터를 조회하기 위한 통일된 "
"인터페이스를 제공합니다. [#]_"

#: ../Doc/library/pickle.rst:567
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your "
"classes is error prone.  For this reason, class designers should use the "
"high-level interface (i.e., :meth:`__getnewargs_ex__`, "
":meth:`__getstate__` and :meth:`__setstate__`) whenever possible.  We "
"will show, however, cases where using :meth:`__reduce__` is the only "
"option or leads to more efficient pickling or both."
msgstr ""
"강력하기는 하지만, 여러분의 클래스에서 직접 :meth:`__reduce__` 를 구현하면 잘못되기 쉽습니다. 이런 이유로, 클래스 "
"설계자는 가능하면 고수준 인터페이스(즉, :meth:`__getnewargs_ex__`, :meth:`__getstate__` 및 "
":meth:`__setstate__`)를 사용해야 합니다. 하지만, 우리는 :meth:`__reduce__` 를 사용하는 것이 유일한 "
"옵션이거나 더 효율적인 피클링을 제공하거나 혹은 둘 다인 경우를 보여줄 것입니다."

#: ../Doc/library/pickle.rst:576
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a"
" tuple (the returned object is often referred to as the \"reduce "
"value\")."
msgstr ""
"인터페이스는 현재 다음과 같이 정의됩니다. :meth:`__reduce__` 메서드는 아무런 인자도 받아들이지 않으며 문자열이나 "
"바람직하게는 튜플을 반환합니다 (반환된 객체는 흔히 \"환원 값(reduce value)\"이라고 불립니다)."

#: ../Doc/library/pickle.rst:580
msgid ""
"If a string is returned, the string should be interpreted as the name of "
"a global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"문자열이 반환되면, 문자열은 전역 변수의 이름으로 해석되어야 합니다. 모듈에 상대적인 객체의 지역 이름이어야 합니다; pickle 모듈은"
" 객체의 모듈을 결정하기 위해 모듈 이름 공간을 검색합니다. 이 동작은 일반적으로 싱글톤에 유용합니다."

#: ../Doc/library/pickle.rst:585
msgid ""
"When a tuple is returned, it must be between two and five items long. "
"Optional items can either be omitted, or ``None`` can be provided as "
"their value.  The semantics of each item are in order:"
msgstr ""
"튜플이 반환될 때는, 길이가 2나 5가 되어야 합니다. 선택적인 항목은 생략되거나 ``None`` 이 값으로 제공될 수 있습니다. 각 "
"항목의 의미는 순서대로 다음과 같습니다:"

#: ../Doc/library/pickle.rst:591
msgid ""
"A callable object that will be called to create the initial version of "
"the object."
msgstr "객체의 초기 버전을 만들기 위해 호출할 콜러블 객체."

#: ../Doc/library/pickle.rst:594
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be "
"given if the callable does not accept any argument."
msgstr "콜러블 객체에 대한 인자의 튜플. 콜러블 객체가 인자를 받아들이지 않으면 빈 튜플을 제공해야 합니다."

#: ../Doc/library/pickle.rst:597
msgid ""
"Optionally, the object's state, which will be passed to the object's "
":meth:`__setstate__` method as previously described.  If the object has "
"no such method then, the value must be a dictionary and it will be added "
"to the object's :attr:`~object.__dict__` attribute."
msgstr ""
"선택적으로, 객체의 상태. 앞에서 설명한 대로 객체의 :meth:`__setstate__` 메서드에 전달됩니다. 객체에 그런 메서드가 "
"없다면, 그 값은 딕셔너리 여야 하며 객체의 :attr:`~object.__dict__` 어트리뷰트에 추가됩니다."

#: ../Doc/library/pickle.rst:602
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using "
"``obj.append(item)`` or, in batch, using ``obj.extend(list_of_items)``. "
"This is primarily used for list subclasses, but may be used by other "
"classes as long as they have :meth:`append` and :meth:`extend` methods "
"with the appropriate signature.  (Whether :meth:`append` or "
":meth:`extend` is used depends on which pickle protocol version is used "
"as well as the number of items to append, so both must be supported.)"
msgstr ""
"선택적으로, 연속적인 항목을 생성하는 이터레이터(시퀀스가 아닙니다). 이 항목들은 ``obj.append(item)`` 을 사용하거나 "
"한꺼번에 ``obj.extend(list_of_items)`` 를 사용하여 객체에 추가될 것입니다. 이것은 주로 리스트 서브 클래스에 "
"사용되지만, 적절한 서명을 갖는 :meth:`append`\\와 :meth:`extend` 메서드가 있는 한 다른 클래스에서 사용될 수 "
"있습니다. (:meth:`append` 나 :meth:`extend` 중 어느 것이 사용되는지는 어떤 피클 프로토콜 버전이 사용되는가와 "
"추가 할 항목의 수에 따라 달려있으므로 둘 다 지원되어야 합니다.)"

#: ../Doc/library/pickle.rst:611
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be "
"used by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"선택적으로, 연속적인 키-값 쌍을 생성하는 이터레이터(시퀀스가 아닙니다). 이 항목들은 ``obj[key] = value`` 를 사용하여"
" 객체에 저장됩니다. 이것은 주로 딕셔너리 서브 클래스에 사용되지만, :meth:`__setitem__` 을 구현하는 한 다른 클래스에서"
" 사용될 수 있습니다."

#: ../Doc/library/pickle.rst:619
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the "
":meth:`__reduce__` method.  In addition, :meth:`__reduce__` automatically"
" becomes a synonym for the extended version.  The main use for this "
"method is to provide backwards-compatible reduce values for older Python "
"releases."
msgstr ""
"또는, :meth:`__reduce_ex__` 메서드를 정의할 수 있습니다. 유일한 차이점은 이 메서드가 프로토콜 버전인 단일 정수 "
"인자를 받아들여야 한다는 것입니다. 정의되면, pickle은 :meth:`__reduce__` 메서드보다 선호합니다. 또한, "
":meth:`__reduce__` 는 자동으로 확장 버전의 동의어가 됩니다. 이 메서드의 주된 용도는 구형 파이썬 배포를 위해 과거 "
"호환성 있는 환원 값을 제공하는 것입니다."

#: ../Doc/library/pickle.rst:631
msgid "Persistence of External Objects"
msgstr "외부 객체의 지속성"

#: ../Doc/library/pickle.rst:637
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports "
"the notion of a reference to an object outside the pickled data stream.  "
"Such objects are referenced by a persistent ID, which should be either a "
"string of alphanumeric characters (for protocol 0) [#]_ or just an "
"arbitrary object (for any newer protocol)."
msgstr ""
"객체 지속성의 효용을 위해, :mod:`pickle` 모듈은 피클 된 데이터 스트림 밖의 객체에 대한 참조 개념을 지원합니다. 이러한 "
"객체는 지속성 ID에 의해 참조되며, 영숫자 문자열(프로토콜 0의 경우) [#]_ 또는 임의의 객체(모든 최신 프로토콜의 경우)여야 "
"합니다."

#: ../Doc/library/pickle.rst:643
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle`"
" module; it will delegate this resolution to the user defined methods on "
"the pickler and unpickler, :meth:`~Pickler.persistent_id` and "
":meth:`~Unpickler.persistent_load` respectively."
msgstr ""
"그러한 지속성 ID의 해석은 :mod:`pickle` 모듈에 의해 정의되지 않습니다; 이 해석을 피클러와 역 피클러의 사용자 정의 "
"메서드에 위임합니다, 각각 :meth:`~Pickler.persistent_id`\\와 "
":meth:`~Unpickler.persistent_load`."

#: ../Doc/library/pickle.rst:648
msgid ""
"To pickle objects that have an external persistent id, the pickler must "
"have a custom :meth:`~Pickler.persistent_id` method that takes an object "
"as an argument and returns either ``None`` or the persistent id for that "
"object. When ``None`` is returned, the pickler simply pickles the object "
"as normal. When a persistent ID string is returned, the pickler will "
"pickle that object, along with a marker so that the unpickler will "
"recognize it as a persistent ID."
msgstr ""
"지속성 id를 가진 객체를 피클 하기 위해서, 피클러는 객체를 인자로 받아서 그 객체에 대해 ``None`` 또는 지속성 id를 반환하는"
" 사용자 정의 :meth:`~Pickler.persistent_id` 메서드가 있어야 합니다. ``None`` 이 반환되면, 피클러는 "
"단순히 객체를 피클 합니다. 지속성 ID 문자열이 반환되면, 피클러는 마커와 함께 해당 객체를 피클 하여 역 피클러가 이를 지속성 ID로"
" 인식하게 합니다."

#: ../Doc/library/pickle.rst:655
msgid ""
"To unpickle external objects, the unpickler must have a custom "
":meth:`~Unpickler.persistent_load` method that takes a persistent ID "
"object and returns the referenced object."
msgstr ""
"외부 객체를 역 피클 하려면, 역 피클러는 지속성 ID 객체를 받아들여 참조된 객체를 반환하는 사용자 정의 "
":meth:`~Unpickler.persistent_load` 메서드를 가져야 합니다."

#: ../Doc/library/pickle.rst:659
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used "
"to pickle external objects by reference."
msgstr "다음은 지속성 ID를 외부 객체를 참조로 피클 하는데 사용하는 방법을 보여주는 포괄적인 예입니다."

#: ../Doc/library/pickle.rst:667
msgid "Dispatch Tables"
msgstr "디스패치 테이블"

#: ../Doc/library/pickle.rst:669
msgid ""
"If one wants to customize pickling of some classes without disturbing any"
" other code which depends on pickling, then one can create a pickler with"
" a private dispatch table."
msgstr ""
"피클링에 의존하는 다른 코드를 방해하지 않고 일부 클래스의 피클링을 사용자 정의하려면, 사설 디스패치 테이블을 갖는 피클러를 만들 수 "
"있습니다."

#: ../Doc/library/pickle.rst:673
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is "
"available as :data:`copyreg.dispatch_table`.  Therefore, one may choose "
"to use a modified copy of :data:`copyreg.dispatch_table` as a private "
"dispatch table."
msgstr ""
":mod:`copyreg` 모듈에 의해 관리되는 전역 디스패치 테이블은 :data:`copyreg.dispatch_table`\\로 사용"
" 가능합니다. 그러므로, 사설 디스패치 테이블로 :data:`copyreg.dispatch_table` 의 수정된 복사본을 사용할 수 "
"있습니다."

#: ../Doc/library/pickle.rst:678
msgid "For example ::"
msgstr "예를 들면 ::"

#: ../Doc/library/pickle.rst:685
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch "
"table which handles the ``SomeClass`` class specially.  Alternatively, "
"the code ::"
msgstr ""
"는 ``SomeClass`` 클래스를 특별히 처리하는 사설 디스패치 테이블을 갖는 :class:`pickle.Pickler` 의 "
"인스턴스를 생성합니다. 또는, 코드 ::"

#: ../Doc/library/pickle.rst:695
msgid ""
"does the same, but all instances of ``MyPickler`` will by default share "
"the same dispatch table.  The equivalent code using the :mod:`copyreg` "
"module is ::"
msgstr ""
"가 같은 일을 하지만, ``MyPickler`` 의 모든 인스턴스는 기본적으로 같은 디스패치 테이블을 공유합니다. "
":mod:`copyreg` 모듈을 사용하는 동등한 코드는 다음과 같습니다 ::"

#: ../Doc/library/pickle.rst:706
msgid "Handling Stateful Objects"
msgstr "상태 저장 객체 처리"

#: ../Doc/library/pickle.rst:712
msgid ""
"Here's an example that shows how to modify pickling behavior for a class."
" The :class:`TextReader` class opens a text file, and returns the line "
"number and line contents each time its :meth:`!readline` method is "
"called. If a :class:`TextReader` instance is pickled, all attributes "
"*except* the file object member are saved. When the instance is "
"unpickled, the file is reopened, and reading resumes from the last "
"location. The :meth:`__setstate__` and :meth:`__getstate__` methods are "
"used to implement this behavior. ::"
msgstr ""
"다음은 클래스의 피클 동작을 수정하는 방법을 보여주는 예제입니다. :class:`TextReader` 클래스는 텍스트 파일을 열고, "
":meth:`!readline` 메서드가 호출될 때마다 줄 번호와 줄 내용을 반환합니다. :class:`TextReader` 인스턴스가 "
"피클 되면, 파일 객체 멤버를 *제외한* 모든 어트리뷰트가 저장됩니다. 인스턴스가 역 피클 될 때, 파일이 다시 열리고, 마지막 위치에서"
" 읽기가 다시 시작됩니다. :meth:`__setstate__` 와 :meth:`__getstate__` 메서드가 이 행동을 구현하는 데"
" 사용됩니다. ::"

#: ../Doc/library/pickle.rst:758
msgid "A sample usage might be something like this::"
msgstr "사용 예는 다음과 같은 식입니다::"

#: ../Doc/library/pickle.rst:773
msgid "Restricting Globals"
msgstr "전역 제한하기"

#: ../Doc/library/pickle.rst:778
msgid ""
"By default, unpickling will import any class or function that it finds in"
" the pickle data.  For many applications, this behaviour is unacceptable "
"as it permits the unpickler to import and invoke arbitrary code.  Just "
"consider what this hand-crafted pickle data stream does when loaded::"
msgstr ""
"기본적으로, 역 피클링은 피클 데이터에서 찾은 모든 클래스나 함수를 임포트 합니다. 많은 응용 프로그램에서는, 역 피클러가 임의 코드를 "
"임포트하고 호출할 수 있으므로, 이 동작을 받아들일 수 없습니다. 이 손으로 만든 피클 데이터 스트림이 로드될 때 하는 일을 "
"생각해보십시오::"

#: ../Doc/library/pickle.rst:788
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and"
" then apply the string argument \"echo hello world\".  Although this "
"example is inoffensive, it is not difficult to imagine one that could "
"damage your system."
msgstr ""
"이 예제에서, 역 피클러는 :func:`os.system` 함수를 임포트하고 문자열 인자 \"echo hello world\"를 "
"적용합니다. 이 예제가 공격적이지는 않지만, 어떤 것들은 시스템을 손상할 수 있다고 상상하기 어렵지 않습니다."

#: ../Doc/library/pickle.rst:792
msgid ""
"For this reason, you may want to control what gets unpickled by "
"customizing :meth:`Unpickler.find_class`.  Unlike its name suggests, "
":meth:`Unpickler.find_class` is called whenever a global (i.e., a class "
"or a function) is requested.  Thus it is possible to either completely "
"forbid globals or restrict them to a safe subset."
msgstr ""
"이런 이유로, 여러분은 :meth:`Unpickler.find_class`\\를 사용자 정의하여 언 피클 되는 것을 제어하고 싶을 수 "
"있습니다. 이름이 제안하는 것과는 달리, :meth:`Unpickler.find_class` 는 전역(즉, 클래스나 함수)이 요청될 "
"때마다 호출됩니다. 따라서 전역을 완전히 금지하거나 안전한 부분집합으로 제한할 수 있습니다."

#: ../Doc/library/pickle.rst:798
msgid ""
"Here is an example of an unpickler allowing only few safe classes from "
"the :mod:`builtins` module to be loaded::"
msgstr "다음은 :mod:`builtins` 모듈에서 몇 가지 안전한 클래스만 로드되도록 허용하는 역 피클러의 예입니다::"

#: ../Doc/library/pickle.rst:827
msgid "A sample usage of our unpickler working has intended::"
msgstr "우리의 역 피클러 작업이 의도한 사용 예::"

#: ../Doc/library/pickle.rst:846
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or "
"third-party solutions."
msgstr ""
"예를 통해 알 수 있듯이, 역 피클을 허락하는 것에 주의를 기울여야 합니다. 따라서 보안이 중요하다면, "
":mod:`xmlrpc.client` 나 제삼자 솔루션의 마샬링 API 같은 대안을 고려할 수 있습니다."

#: ../Doc/library/pickle.rst:853
msgid "Performance"
msgstr "성능"

#: ../Doc/library/pickle.rst:855
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) "
"feature efficient binary encodings for several common features and built-"
"in types. Also, the :mod:`pickle` module has a transparent optimizer "
"written in C."
msgstr ""
"최신 버전의 피클 프로토콜(프로토콜 2 이상)은 몇 가지 공통 기능 및 내장형에 대한 효율적인 바이너리 인코딩을 제공합니다. 또한, "
":mod:`pickle` 모듈은 C로 작성된 투명한 최적화기를 가지고 있습니다."

#: ../Doc/library/pickle.rst:863
msgid "Examples"
msgstr "예제"

#: ../Doc/library/pickle.rst:865
msgid "For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr "가장 간단한 코드로, :func:`dump`\\와 :func:`load` 함수를 사용하십시오. ::"

#: ../Doc/library/pickle.rst:881
msgid "The following example reads the resulting pickled data. ::"
msgstr "다음 예제는 결과로 나온 피클 데이터를 읽습니다. ::"

#: ../Doc/library/pickle.rst:898
msgid "Module :mod:`copyreg`"
msgstr "모듈 :mod:`copyreg`"

#: ../Doc/library/pickle.rst:898
msgid "Pickle interface constructor registration for extension types."
msgstr "확장형에 대한 피클 인터페이스 생성자 등록"

#: ../Doc/library/pickle.rst:901
msgid "Module :mod:`pickletools`"
msgstr "모듈 :mod:`pickletools`"

#: ../Doc/library/pickle.rst:901
msgid "Tools for working with and analyzing pickled data."
msgstr "피클 된 데이터로 작업하고 분석하는 도구."

#: ../Doc/library/pickle.rst:904
msgid "Module :mod:`shelve`"
msgstr "모듈 :mod:`shelve`"

#: ../Doc/library/pickle.rst:904
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr "객체의 인덱싱 된 데이터베이스; :mod:`pickle`\\을 사용합니다."

#: ../Doc/library/pickle.rst:907
msgid "Module :mod:`copy`"
msgstr "모듈 :mod:`copy`"

#: ../Doc/library/pickle.rst:907
msgid "Shallow and deep object copying."
msgstr "얕거나 깊은 객체 복사."

#: ../Doc/library/pickle.rst:909
msgid "Module :mod:`marshal`"
msgstr "모듈 :mod:`marshal`"

#: ../Doc/library/pickle.rst:910
msgid "High-performance serialization of built-in types."
msgstr "내장형의 고성능 직렬화."

#: ../Doc/library/pickle.rst:914
msgid "Footnotes"
msgstr "각주"

#: ../Doc/library/pickle.rst:915
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr "이것을 :mod:`marshal` 모듈과 혼동하지 마십시오."

#: ../Doc/library/pickle.rst:917
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all "
":keyword:`lambda` functions share the same name:  ``<lambda>``."
msgstr ""
"이것이 :keyword:`lambda` 함수가 pickle 될 수 없는 이유입니다: 모든 :keyword:`lambda` 함수는 같은 "
"이름을 공유합니다: ``<lambda>``."

#: ../Doc/library/pickle.rst:920
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an "
":exc:`AttributeError` but it could be something else."
msgstr ""
"발생하는 예외는 :exc:`ImportError` 나 :exc:`AttributeError` 일 가능성이 크지만, 그 밖의 다른 것일 수"
" 있습니다."

#: ../Doc/library/pickle.rst:923
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ":mod:`copy` 모듈은 얕거나 깊은 복사 연산에 이 프로토콜을 사용합니다."

#: ../Doc/library/pickle.rst:926
msgid ""
"The limitation on alphanumeric characters is due to the fact the "
"persistent IDs, in protocol 0, are delimited by the newline character.  "
"Therefore if any kind of newline characters occurs in persistent IDs, the"
" resulting pickle will become unreadable."
msgstr ""
"영숫자 문자의 제한은 프로토콜 0에서 지속성 ID가 개행 문자로 구분되기 때문입니다. 따라서 지속성 ID에 개행 문자가 포함되면 결과 "
"피클을 읽을 수 없게 됩니다."
