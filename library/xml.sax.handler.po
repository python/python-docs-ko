# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/xml.sax.handler.rst:2
msgid ":mod:`xml.sax.handler` --- Base classes for SAX handlers"
msgstr ":mod:`xml.sax.handler` --- SAX 처리기의 베이스 클래스"

#: ../Doc/library/xml.sax.handler.rst:10
msgid "**Source code:** :source:`Lib/xml/sax/handler.py`"
msgstr "**소스 코드:** :source:`Lib/xml/sax/handler.py`"

#: ../Doc/library/xml.sax.handler.rst:14
msgid ""
"The SAX API defines four kinds of handlers: content handlers, DTD "
"handlers, error handlers, and entity resolvers. Applications normally "
"only need to implement those interfaces whose events they are interested "
"in; they can implement the interfaces in a single object or in multiple "
"objects. Handler implementations should inherit from the base classes "
"provided in the module :mod:`xml.sax.handler`, so that all methods get "
"default implementations."
msgstr ""
"SAX API는 네 가지 처리기를 정의합니다: 콘텐츠 처리기, DTD 처리기, 에러 처리기 및 엔티티 해석기. 응용 프로그램은 "
"일반적으로 이벤트에 관심이 있는 인터페이스 만 구현하면 됩니다; 단일 객체나 여러 객체에서 인터페이스를 구현할 수 있습니다. 처리기"
" 구현은 모든 메서드가 기본 구현을 갖도록 :mod:`xml.sax.handler` 모듈에서 제공된 베이스 클래스에서 상속해야 "
"합니다."

#: ../Doc/library/xml.sax.handler.rst:24
msgid ""
"This is the main callback interface in SAX, and the one most important to"
" applications. The order of events in this interface mirrors the order of"
" the information in the document."
msgstr ""
"이것은 SAX의 주 콜백 인터페이스이며, 응용 프로그램에 가장 중요한 인터페이스입니다. 이 인터페이스의 이벤트 순서는 문서에서의 "
"정보 순서를 반영합니다."

#: ../Doc/library/xml.sax.handler.rst:31
msgid "Handle DTD events."
msgstr "DTD 이벤트를 처리합니다."

#: ../Doc/library/xml.sax.handler.rst:33
msgid ""
"This interface specifies only those DTD events required for basic parsing"
" (unparsed entities and attributes)."
msgstr "이 인터페이스는 기본 구문 분석에 필요한 DTD 이벤트만 지정합니다 (구문 분석되지 않은 엔티티와 어트리뷰트)."

#: ../Doc/library/xml.sax.handler.rst:39
msgid ""
"Basic interface for resolving entities. If you create an object "
"implementing this interface, then register the object with your Parser, "
"the parser will call the method in your object to resolve all external "
"entities."
msgstr ""
"엔티티 해석을 위한 기본 인터페이스. 이 인터페이스를 구현하는 객체를 만든 후 구문 분석기에 객체를 등록하면, 구문 분석기는 객체의"
" 메서드를 호출하여 모든 외부 엔티티를 해석합니다."

#: ../Doc/library/xml.sax.handler.rst:46
msgid ""
"Interface used by the parser to present error and warning messages to the"
" application.  The methods of this object control whether errors are "
"immediately converted to exceptions or are handled in some other way."
msgstr ""
"응용 프로그램에 에러와 경고 메시지를 표시하기 위해 구문 분석기에서 사용하는 인터페이스. 이 객체의 메서드는 에러가 즉시 예외로 "
"변환되는지 또는 다른 방식으로 처리되는지를 제어합니다."

#: ../Doc/library/xml.sax.handler.rst:50
msgid ""
"In addition to these classes, :mod:`xml.sax.handler` provides symbolic "
"constants for the feature and property names."
msgstr "이러한 클래스 외에도, :mod:`xml.sax.handler`\\는 기능과 속성 이름에 대한 기호 상수를 제공합니다."

#: ../Doc/library/xml.sax.handler.rst:56
msgid "value: ``\"http://xml.org/sax/features/namespaces\"``"
msgstr "값: ``\"http://xml.org/sax/features/namespaces\"``"

#: ../Doc/library/xml.sax.handler.rst:57
msgid "true: Perform Namespace processing."
msgstr "참: 이름 공간 처리를 수행합니다."

#: ../Doc/library/xml.sax.handler.rst:59
msgid ""
"false: Optionally do not perform Namespace processing (implies namespace-"
"prefixes; default)."
msgstr "거짓: 선택적으로 이름 공간 처리를 수행하지 않습니다 (namespace-prefixes를 암시합니다; 기본값)."

#: ../Doc/library/xml.sax.handler.rst:60 ../Doc/library/xml.sax.handler.rst:70
#: ../Doc/library/xml.sax.handler.rst:79 ../Doc/library/xml.sax.handler.rst:88
#: ../Doc/library/xml.sax.handler.rst:96 ../Doc/library/xml.sax.handler.rst:106
#: ../Doc/library/xml.sax.handler.rst:138
msgid "access: (parsing) read-only; (not parsing) read/write"
msgstr "액세스: (구문 분석) 읽기 전용; (구문 분석하지 않음) 읽기/쓰기"

#: ../Doc/library/xml.sax.handler.rst:65
msgid "value: ``\"http://xml.org/sax/features/namespace-prefixes\"``"
msgstr "값: ``\"http://xml.org/sax/features/namespace-prefixes\"``"

#: ../Doc/library/xml.sax.handler.rst:67
msgid ""
"true: Report the original prefixed names and attributes used for "
"Namespace declarations."
msgstr "참: 이름 공간 선언에 사용된 원래 접두사 이름과 어트리뷰트를 보고합니다."

#: ../Doc/library/xml.sax.handler.rst:69
msgid ""
"false: Do not report attributes used for Namespace declarations, and "
"optionally do not report original prefixed names (default)."
msgstr "거짓: 이름 공간 선언에 사용된 어트리뷰트를 보고하지 않고, 선택적으로 원래 접두사 이름을 보고하지 않습니다 (기본값)."

#: ../Doc/library/xml.sax.handler.rst:75
msgid "value: ``\"http://xml.org/sax/features/string-interning\"``"
msgstr "값: ``\"http://xml.org/sax/features/string-interning\"``"

#: ../Doc/library/xml.sax.handler.rst:77
msgid ""
"true: All element names, prefixes, attribute names, Namespace URIs, and "
"local names are interned using the built-in intern function."
msgstr ""
"참: 모든 엘리먼트 이름, 접두사, 어트리뷰트 이름, 이름 공간 URI 및 지역 이름은 내장 intern 함수를 사용하여 인턴 "
"됩니다."

#: ../Doc/library/xml.sax.handler.rst:78
msgid "false: Names are not necessarily interned, although they may be (default)."
msgstr "거짓: 그럴 수 있지만, 이름이 반드시 인턴 될 필요는 없습니다 (기본값)."

#: ../Doc/library/xml.sax.handler.rst:84
msgid "value: ``\"http://xml.org/sax/features/validation\"``"
msgstr "값: ``\"http://xml.org/sax/features/validation\"``"

#: ../Doc/library/xml.sax.handler.rst:86
msgid ""
"true: Report all validation errors (implies external-general-entities and"
" external-parameter-entities)."
msgstr ""
"참: 모든 유효성 검사 에러를 보고합니다 (external-general-entities와 external-parameter-"
"entities를 암시합니다)."

#: ../Doc/library/xml.sax.handler.rst:87
msgid "false: Do not report validation errors."
msgstr "거짓: 유효성 검사 에러를 보고하지 않습니다."

#: ../Doc/library/xml.sax.handler.rst:93
msgid "value: ``\"http://xml.org/sax/features/external-general-entities\"``"
msgstr "값: ``\"http://xml.org/sax/features/external-general-entities\"``"

#: ../Doc/library/xml.sax.handler.rst:94
msgid "true: Include all external general (text) entities."
msgstr "참: 모든 외부 일반 (텍스트) 엔티티를 포함합니다."

#: ../Doc/library/xml.sax.handler.rst:95
msgid "false: Do not include external general entities."
msgstr "거짓: 외부 일반 엔티티를 포함하지 않습니다."

#: ../Doc/library/xml.sax.handler.rst:101
msgid "value: ``\"http://xml.org/sax/features/external-parameter-entities\"``"
msgstr "값: ``\"http://xml.org/sax/features/external-parameter-entities\"``"

#: ../Doc/library/xml.sax.handler.rst:103
msgid ""
"true: Include all external parameter entities, including the external DTD"
" subset."
msgstr "참: 외부 DTD 서브 세트를 포함하여, 모든 외부 파라미터 엔티티를 포함합니다."

#: ../Doc/library/xml.sax.handler.rst:105
msgid ""
"false: Do not include any external parameter entities, even the external "
"DTD subset."
msgstr "거짓: 외부 DTD 서브 세트를 포함하여, 어떤 외부 파라미터 엔티티도 포함하지 않습니다."

#: ../Doc/library/xml.sax.handler.rst:111
msgid "List of all features."
msgstr "모든 기능 리스트."

#: ../Doc/library/xml.sax.handler.rst:116
msgid "value: ``\"http://xml.org/sax/properties/lexical-handler\"``"
msgstr "값: ``\"http://xml.org/sax/properties/lexical-handler\"``"

#: ../Doc/library/xml.sax.handler.rst:117
msgid "data type: xml.sax.sax2lib.LexicalHandler (not supported in Python 2)"
msgstr "데이터형: xml.sax.sax2lib.LexicalHandler (파이썬 2에서는 지원되지 않습니다)"

#: ../Doc/library/xml.sax.handler.rst:119
msgid ""
"description: An optional extension handler for lexical events like "
"comments."
msgstr "설명: 주석과 같은 어휘 이벤트에 대한 선택적 확장 처리기."

#: ../Doc/library/xml.sax.handler.rst:120
#: ../Doc/library/xml.sax.handler.rst:129
msgid "access: read/write"
msgstr "액세스: 읽기/쓰기"

#: ../Doc/library/xml.sax.handler.rst:125
msgid "value: ``\"http://xml.org/sax/properties/declaration-handler\"``"
msgstr "값: ``\"http://xml.org/sax/properties/declaration-handler\"``"

#: ../Doc/library/xml.sax.handler.rst:126
msgid "data type: xml.sax.sax2lib.DeclHandler (not supported in Python 2)"
msgstr "데이터형: xml.sax.sax2lib.DeclHandler (파이썬 2에서는 지원되지 않습니다)"

#: ../Doc/library/xml.sax.handler.rst:128
msgid ""
"description: An optional extension handler for DTD-related events other "
"than notations and unparsed entities."
msgstr "설명: 표기법과 구문 분석되지 않은 엔티티 이외의 DTD 관련 이벤트에 대한 선택적 확장 처리기."

#: ../Doc/library/xml.sax.handler.rst:134
msgid "value: ``\"http://xml.org/sax/properties/dom-node\"``"
msgstr "값: ``\"http://xml.org/sax/properties/dom-node\"``"

#: ../Doc/library/xml.sax.handler.rst:135
msgid "data type: org.w3c.dom.Node (not supported in Python 2)"
msgstr "데이터형: org.w3c.dom.Node (파이썬 2에서는 지원되지 않습니다)"

#: ../Doc/library/xml.sax.handler.rst:137
msgid ""
"description: When parsing, the current DOM node being visited if this is "
"a DOM iterator; when not parsing, the root DOM node for iteration."
msgstr ""
"설명: 구문 분석할 때, 이것이 DOM 이터레이터이면 방문 중인 현재 DOM 노드; 구문 분석하지 않을 때, 이터레이션을 위한 루트"
" DOM 노드."

#: ../Doc/library/xml.sax.handler.rst:143
msgid "value: ``\"http://xml.org/sax/properties/xml-string\"``"
msgstr "값: ``\"http://xml.org/sax/properties/xml-string\"``"

#: ../Doc/library/xml.sax.handler.rst:144
msgid "data type: String"
msgstr "데이터형: 문자열"

#: ../Doc/library/xml.sax.handler.rst:146
msgid ""
"description: The literal string of characters that was the source for the"
" current event."
msgstr "설명: 현재 이벤트의 소스인 리터럴 문자열."

#: ../Doc/library/xml.sax.handler.rst:147
msgid "access: read-only"
msgstr "액세스: 읽기 전용"

#: ../Doc/library/xml.sax.handler.rst:152
msgid "List of all known property names."
msgstr "알려진 모든 속성 이름 리스트"

#: ../Doc/library/xml.sax.handler.rst:158
msgid "ContentHandler Objects"
msgstr "ContentHandler 객체"

#: ../Doc/library/xml.sax.handler.rst:160
msgid ""
"Users are expected to subclass :class:`ContentHandler` to support their "
"application.  The following methods are called by the parser on the "
"appropriate events in the input document:"
msgstr ""
"사용자는 자신의 응용 프로그램을 지원하기 위해 :class:`ContentHandler`\\를 서브 클래싱 할 것으로 기대됩니다. "
"입력 문서에서 적절한 이벤트에 대해 구문 분석기가 다음 메서드를 호출합니다:"

#: ../Doc/library/xml.sax.handler.rst:167
msgid ""
"Called by the parser to give the application a locator for locating the "
"origin of document events."
msgstr "응용 프로그램에 문서 이벤트의 출처를 찾기 위한 로케이터(locator)를 제공하기 위해 구문 분석기가 호출합니다."

#: ../Doc/library/xml.sax.handler.rst:170
msgid ""
"SAX parsers are strongly encouraged (though not absolutely required) to "
"supply a locator: if it does so, it must supply the locator to the "
"application by invoking this method before invoking any of the other "
"methods in the DocumentHandler interface."
msgstr ""
"SAX 구문 분석기가 (절대적으로 필요한 것은 아니지만) 로케이터를 제공할 것을 강력히 권장합니다: 그렇게 한다면, "
"DocumentHandler 인터페이스의 다른 메서드를 호출하기 전에 이 메서드를 호출하여 로케이터를 응용 프로그램에 제공해야 "
"합니다."

#: ../Doc/library/xml.sax.handler.rst:175
msgid ""
"The locator allows the application to determine the end position of any "
"document-related event, even if the parser is not reporting an error. "
"Typically, the application will use this information for reporting its "
"own errors (such as character content that does not match an "
"application's business rules). The information returned by the locator is"
" probably not sufficient for use with a search engine."
msgstr ""
"로케이터를 사용하면 구문 분석기가 에러를 보고하지 않더라도 응용 프로그램이 문서 관련 이벤트의 종료 위치를 판별할 수 있습니다. "
"일반적으로, 응용 프로그램은 이 정보를 사용하여 자체 에러(가령 응용 프로그램의 비즈니스 규칙과 일치하지 않는 문자 내용)를 "
"보고합니다. 로케이터가 반환한 정보는 아마도 검색 엔진에 사용하기에는 충분하지 않을 것입니다."

#: ../Doc/library/xml.sax.handler.rst:182
msgid ""
"Note that the locator will return correct information only during the "
"invocation of the events in this interface. The application should not "
"attempt to use it at any other time."
msgstr ""
"로케이터는 이 인터페이스에서 이벤트를 호출하는 동안에만 올바른 정보를 반환함에 유의하십시오. 응용 프로그램은 다른 시간에 사용하려고"
" 시도해서는 안 됩니다."

#: ../Doc/library/xml.sax.handler.rst:189
msgid "Receive notification of the beginning of a document."
msgstr "문서 시작 알림을 받습니다."

#: ../Doc/library/xml.sax.handler.rst:191
msgid ""
"The SAX parser will invoke this method only once, before any other "
"methods in this interface or in DTDHandler (except for "
":meth:`setDocumentLocator`)."
msgstr ""
"SAX 구문 분석기는 이 인터페이스나 DTDHandler의 다른 모든 메서드(:meth:`setDocumentLocator` 제외)"
" 전에 이 메서드를 한 번만 호출합니다."

#: ../Doc/library/xml.sax.handler.rst:197
msgid "Receive notification of the end of a document."
msgstr "문서 끝 알림을 받습니다."

#: ../Doc/library/xml.sax.handler.rst:199
msgid ""
"The SAX parser will invoke this method only once, and it will be the last"
" method invoked during the parse. The parser shall not invoke this method"
" until it has either abandoned parsing (because of an unrecoverable "
"error) or reached the end of input."
msgstr ""
"SAX 구문 분석기는 이 메서드를 한 번만 호출하며, 그것이 구문 분석 중에 마지막으로 호출된 메서드가 됩니다. 구문 분석기는 "
"(복구할 수 없는 에러로 인해) 구문 분석을 포기했거나 입력 끝에 도달할 때까지 이 메서드를 호출하지 않아야 합니다."

#: ../Doc/library/xml.sax.handler.rst:207
msgid "Begin the scope of a prefix-URI Namespace mapping."
msgstr "접두사 URI 이름 공간 매핑의 스코프를 시작합니다."

#: ../Doc/library/xml.sax.handler.rst:209
msgid ""
"The information from this event is not necessary for normal Namespace "
"processing: the SAX XML reader will automatically replace prefixes for "
"element and attribute names when the ``feature_namespaces`` feature is "
"enabled (the default)."
msgstr ""
"이 이벤트의 정보는 일반적인 이름 공간 처리에 필요하지 않습니다: SAX XML 판독기는 ``feature_namespaces`` "
"기능이 활성화되면 (기본값) 엘리먼트와 어트리뷰트 이름의 접두사를 자동으로 대체합니다."

#: ../Doc/library/xml.sax.handler.rst:214
msgid ""
"There are cases, however, when applications need to use prefixes in "
"character data or in attribute values, where they cannot safely be "
"expanded automatically; the :meth:`startPrefixMapping` and "
":meth:`endPrefixMapping` events supply the information to the application"
" to expand prefixes in those contexts itself, if necessary."
msgstr ""
"그러나, 응용 프로그램이 문자 데이터나 어트리뷰트 값에 접두사를 사용해야 할 때 자동으로 안전하게 확장할 수 없는 경우가 있습니다;"
" :meth:`startPrefixMapping` 과 :meth:`endPrefixMapping` 이벤트는 필요한 경우 해당 "
"컨텍스트에서 스스로 접두사를 확장하도록 정보를 응용 프로그램에 제공합니다."

#: ../Doc/library/xml.sax.handler.rst:222
msgid ""
"Note that :meth:`startPrefixMapping` and :meth:`endPrefixMapping` events "
"are not guaranteed to be properly nested relative to each-other: all "
":meth:`startPrefixMapping` events will occur before the corresponding "
":meth:`startElement` event, and all :meth:`endPrefixMapping` events will "
"occur after the corresponding :meth:`endElement` event, but their order "
"is not guaranteed."
msgstr ""
":meth:`startPrefixMapping` 과 :meth:`endPrefixMapping` 이벤트는 서로에 대해 올바르게 "
"중첩된다고 보장되지 않음에 유의하십시오: 모든 :meth:`startPrefixMapping` 이벤트는 해당 "
":meth:`startElement` 이벤트 전에 발생하고, 모든 :meth:`endPrefixMapping` 이벤트는 해당 "
":meth:`endElement` 이벤트 후에 발생하지만, 그들 간의 순서는 보장되지 않습니다."

#: ../Doc/library/xml.sax.handler.rst:232
msgid "End the scope of a prefix-URI mapping."
msgstr "접두사 URI 매핑 스코프를 끝냅니다."

#: ../Doc/library/xml.sax.handler.rst:234
msgid ""
"See :meth:`startPrefixMapping` for details. This event will always occur "
"after the corresponding :meth:`endElement` event, but the order of "
":meth:`endPrefixMapping` events is not otherwise guaranteed."
msgstr ""
"자세한 내용은 :meth:`startPrefixMapping` 을 참조하십시오. 이 이벤트는 항상 해당 "
":meth:`endElement` 이벤트 이후에 발생하지만, :meth:`endPrefixMapping` 이벤트의 순서는 이 "
"이상으로는 보장되지 않습니다."

#: ../Doc/library/xml.sax.handler.rst:241
msgid "Signals the start of an element in non-namespace mode."
msgstr "이름 공간이 아닌 모드에서 엘리먼트의 시작을 알립니다."

#: ../Doc/library/xml.sax.handler.rst:243
msgid ""
"The *name* parameter contains the raw XML 1.0 name of the element type as"
" a string and the *attrs* parameter holds an object of the "
":class:`~xml.sax.xmlreader.Attributes` interface (see :ref:`attributes-"
"objects`) containing the attributes of the element.  The object passed as"
" *attrs* may be re-used by the parser; holding on to a reference to it is"
" not a reliable way to keep a copy of the attributes. To keep a copy of "
"the attributes, use the :meth:`copy` method of the *attrs* object."
msgstr ""
"*name* 매개 변수는 엘리먼트 유형의 원시 XML 1.0 이름을 문자열로 포함하고 *attrs* 매개 변수는 엘리먼트의 "
"어트리뷰트를 포함하는 :class:`~xml.sax.xmlreader.Attributes` 인터페이스 (:ref"
":`attributes-objects`\\를 참조하십시오)의 객체를 담습니다. *attrs*\\로 전달된 객체는 구문 분석기에 의해"
" 재사용 될 수 있습니다; 그것에 대한 참조를 유지하는 것은 어트리뷰트의 사본을 유지하는 신뢰할 수 있는 방법이 아닙니다. "
"어트리뷰트의 사본을 유지하려면, *attrs* 객체의 :meth:`copy` 메서드를 사용하십시오."

#: ../Doc/library/xml.sax.handler.rst:255
msgid "Signals the end of an element in non-namespace mode."
msgstr "이름 공간이 아닌 모드에서 엘리먼트의 끝을 알립니다."

#: ../Doc/library/xml.sax.handler.rst:257
msgid ""
"The *name* parameter contains the name of the element type, just as with "
"the :meth:`startElement` event."
msgstr "*name* 매개 변수는 :meth:`startElement` 이벤트와 마찬가지로 엘리먼트 유형의 이름을 포함합니다."

#: ../Doc/library/xml.sax.handler.rst:263
msgid "Signals the start of an element in namespace mode."
msgstr "이름 공간 모드에서 엘리먼트의 시작을 알립니다."

#: ../Doc/library/xml.sax.handler.rst:265
msgid ""
"The *name* parameter contains the name of the element type as a ``(uri, "
"localname)`` tuple, the *qname* parameter contains the raw XML 1.0 name "
"used in the source document, and the *attrs* parameter holds an instance "
"of the :class:`~xml.sax.xmlreader.AttributesNS` interface (see :ref"
":`attributes-ns-objects`) containing the attributes of the element.  If "
"no namespace is associated with the element, the *uri* component of "
"*name* will be ``None``.  The object passed as *attrs* may be re-used by "
"the parser; holding on to a reference to it is not a reliable way to keep"
" a copy of the attributes.  To keep a copy of the attributes, use the "
":meth:`copy` method of the *attrs* object."
msgstr ""
"*name* 매개 변수는 엘리먼트 유형의 이름을 ``(uri, localname)`` 튜플로 포함하고, *qname* 매개 변수는 "
"소스 문서에서 사용된 원시 XML 1.0 이름을 포함하며, *attrs* 매개 변수는 엘리먼트의 어트리뷰트를 포함하는 "
":class:`~xml.sax.xmlreader.AttributesNS` 인터페이스(:ref:`attributes-ns-"
"objects`\\를 참조하십시오)의 인스턴스를 담습니다. 아무런 이름 공간도 엘리먼트와 연관되지 않았으면 *name*\\의 "
"*uri* 구성 요소는 ``None``\\입니다. *attrs*\\로 전달된 객체는 구문 분석기에 의해 재사용 될 수 있습니다; "
"그것에 대한 참조를 유지하는 것은 어트리뷰트의 사본을 유지하는 신뢰할 수 있는 방법이 아닙니다. 어트리뷰트의 사본을 유지하려면 "
"*attrs* 객체의 :meth:`copy` 메서드를 사용하십시오."

#: ../Doc/library/xml.sax.handler.rst:276
msgid ""
"Parsers may set the *qname* parameter to ``None``, unless the "
"``feature_namespace_prefixes`` feature is activated."
msgstr ""
"``feature_namespace_prefixes`` 기능이 활성화되지 않는 한, 구문 분석기는 *qname* 매개 변수를 "
"``None``\\으로 설정할 수 있습니다."

#: ../Doc/library/xml.sax.handler.rst:282
msgid "Signals the end of an element in namespace mode."
msgstr "이름 공간 모드에서 엘리먼트의 끝을 알립니다."

#: ../Doc/library/xml.sax.handler.rst:284
msgid ""
"The *name* parameter contains the name of the element type, just as with "
"the :meth:`startElementNS` method, likewise the *qname* parameter."
msgstr ""
"*name* 매개 변수는 :meth:`startElementNS` 메서드와 마찬가지로 *qname* 매개 변수처럼 엘리먼트 유형의 "
"이름을 포함합니다."

#: ../Doc/library/xml.sax.handler.rst:290
msgid "Receive notification of character data."
msgstr "문자 데이터의 알림을 받습니다."

#: ../Doc/library/xml.sax.handler.rst:292
msgid ""
"The Parser will call this method to report each chunk of character data. "
"SAX parsers may return all contiguous character data in a single chunk, "
"or they may split it into several chunks; however, all of the characters "
"in any single event must come from the same external entity so that the "
"Locator provides useful information."
msgstr ""
"구문 분석기는 이 메서드를 호출하여 각 문자 데이터 청크를 보고합니다. SAX 구문 분석기는 연속된 모든 문자 데이터를 단일 청크로"
" 반환하거나 여러 청크로 분할할 수 있습니다; 그러나, 로케이터가 유용한 정보를 제공할 수 있도록, 단일 이벤트의 모든 문자는 같은"
" 외부 엔티티에서 온 것이어야 합니다."

#: ../Doc/library/xml.sax.handler.rst:298
msgid ""
"*content* may be a string or bytes instance; the ``expat`` reader module "
"always produces strings."
msgstr "*content*\\는 문자열이나 바이트열 인스턴스일 수 있습니다; ``expat`` 판독기 모듈은 항상 문자열을 생성합니다."

#: ../Doc/library/xml.sax.handler.rst:303
msgid ""
"The earlier SAX 1 interface provided by the Python XML Special Interest "
"Group used a more Java-like interface for this method.  Since most "
"parsers used from Python did not take advantage of the older interface, "
"the simpler signature was chosen to replace it.  To convert old code to "
"the new interface, use *content* instead of slicing content with the old "
"*offset* and *length* parameters."
msgstr ""
"Python XML Special Interest Group에서 제공된 이전 SAX 1 인터페이스는 이 메서드에 더 Java와 "
"유사한 인터페이스를 사용했습니다. 파이썬에서 사용되는 대부분의 구문 분석기가 구식 인터페이스의 장점을 취하지 않았기 때문에, 더 "
"간단한 서명으로 변경했습니다. 이전 코드를 새 인터페이스로 변환하려면, 이전 *offset*\\과 *length* 매개 변수로 "
"콘텐츠를 슬라이싱하는 대신 *content*\\를 사용하십시오."

#: ../Doc/library/xml.sax.handler.rst:312
msgid "Receive notification of ignorable whitespace in element content."
msgstr "엘리먼트 내용에서 무시할 수 있는 공백에 대한 알림을 받습니다."

#: ../Doc/library/xml.sax.handler.rst:314
msgid ""
"Validating Parsers must use this method to report each chunk of ignorable"
" whitespace (see the W3C XML 1.0 recommendation, section 2.10): non-"
"validating parsers may also use this method if they are capable of "
"parsing and using content models."
msgstr ""
"유효성 검사 구문 분석기는 무시할 수 있는 공백의 각 청크를 보고하기 위해 이 메서드를 사용해야 합니다 (W3C XML 1.0 권장"
" 사항, 섹션 2.10을 참조하십시오)."

#: ../Doc/library/xml.sax.handler.rst:319
msgid ""
"SAX parsers may return all contiguous whitespace in a single chunk, or "
"they may split it into several chunks; however, all of the characters in "
"any single event must come from the same external entity, so that the "
"Locator provides useful information."
msgstr ""
"SAX 구문 분석기는 모든 연속적인 공백을 단일 청크로 반환하거나 여러 청크로 나눌 수 있습니다; 그러나 로케이터가 유용한 정보를 "
"제공할 수 있도록, 단일 이벤트의 모든 문자는 같은 외부 엔티티에서 온 것이어야 합니다."

#: ../Doc/library/xml.sax.handler.rst:327
msgid "Receive notification of a processing instruction."
msgstr "처리 명령의 알림을 받습니다."

#: ../Doc/library/xml.sax.handler.rst:329
msgid ""
"The Parser will invoke this method once for each processing instruction "
"found: note that processing instructions may occur before or after the "
"main document element."
msgstr ""
"구문 분석기는 발견된 각 처리 명령에 대해 이 메서드를 한 번 호출합니다: 처리 명령은 메인 문서 엘리먼트 전후에 발생할 수 있음에"
" 유의하십시오."

#: ../Doc/library/xml.sax.handler.rst:333
msgid ""
"A SAX parser should never report an XML declaration (XML 1.0, section "
"2.8) or a text declaration (XML 1.0, section 4.3.1) using this method."
msgstr ""
"SAX 구문 분석기는 이 메서드를 사용하여 XML 선언(XML 1.0, 섹션 2.8)이나 텍스트 선언(XML 1.0, 섹션 "
"4.3.1)을 보고해서는 안 됩니다."

#: ../Doc/library/xml.sax.handler.rst:339
msgid "Receive notification of a skipped entity."
msgstr "건너뛴 엔티티의 알림을 받습니다."

#: ../Doc/library/xml.sax.handler.rst:341
msgid ""
"The Parser will invoke this method once for each entity skipped. Non-"
"validating processors may skip entities if they have not seen the "
"declarations (because, for example, the entity was declared in an "
"external DTD subset). All processors may skip external entities, "
"depending on the values of the ``feature_external_ges`` and the "
"``feature_external_pes`` properties."
msgstr ""
"구문 분석기는 각 엔티티를 건너뛸 때마다 이 메서드를 한 번 호출합니다. 유효성을 검사하지 않는 프로세서는 선언을 보지 않으면 "
"엔티티를 건너뛸 수 있습니다 (예를 들어 엔티티가 외부 DTD 서브 세트에서 선언되었기 때문에). "
"``feature_external_ges``\\와 ``feature_external_pes`` 속성의 값에 따라, 모든 프로세서가 "
"외부 엔티티를 건너뛸 수 있습니다."

#: ../Doc/library/xml.sax.handler.rst:351
msgid "DTDHandler Objects"
msgstr "DTDHandler 객체"

#: ../Doc/library/xml.sax.handler.rst:353
msgid ":class:`DTDHandler` instances provide the following methods:"
msgstr ":class:`DTDHandler` 인스턴스는 다음 메서드를 제공합니다:"

#: ../Doc/library/xml.sax.handler.rst:358
msgid "Handle a notation declaration event."
msgstr "표기법 선언 이벤트를 처리합니다."

#: ../Doc/library/xml.sax.handler.rst:363
msgid "Handle an unparsed entity declaration event."
msgstr "구문 분석되지 않은 엔티티 선언 이벤트를 처리합니다."

#: ../Doc/library/xml.sax.handler.rst:369
msgid "EntityResolver Objects"
msgstr "EntityResolver 객체"

#: ../Doc/library/xml.sax.handler.rst:374
msgid ""
"Resolve the system identifier of an entity and return either the system "
"identifier to read from as a string, or an InputSource to read from. The "
"default implementation returns *systemId*."
msgstr ""
"엔티티의 시스템 식별자를 해석하고 읽을 시스템 식별자를 문자열로 반환하거나, 읽을 InputSource를 반환합니다. 기본 구현은 "
"*systemId*\\를 반환합니다."

#: ../Doc/library/xml.sax.handler.rst:382
msgid "ErrorHandler Objects"
msgstr "ErrorHandler 객체"

#: ../Doc/library/xml.sax.handler.rst:384
msgid ""
"Objects with this interface are used to receive error and warning "
"information from the :class:`~xml.sax.xmlreader.XMLReader`.  If you "
"create an object that implements this interface, then register the object"
" with your :class:`~xml.sax.xmlreader.XMLReader`, the parser will call "
"the methods in your object to report all warnings and errors. There are "
"three levels of errors available: warnings, (possibly) recoverable "
"errors, and unrecoverable errors.  All methods take a "
":exc:`SAXParseException` as the only parameter.  Errors and warnings may "
"be converted to an exception by raising the passed-in exception object."
msgstr ""
"이 인터페이스를 갖는 객체는 :class:`~xml.sax.xmlreader.XMLReader`\\에서 에러와 경고 정보를 받는 데"
" 사용됩니다. 이 인터페이스를 구현하는 객체를 만든 다음 :class:`~xml.sax.xmlreader.XMLReader`\\에 "
"객체를 등록하면, 구문 분석기는 객체의 메서드를 호출하여 모든 경고와 에러를 보고합니다. 세 가지 수준의 에러가 있습니다: 경고, "
"(어쩌면) 복구 가능한 에러 및 복구 불가능한 에러. 모든 메서드는 :exc:`SAXParseException`\\를 유일한 매개 "
"변수로 취합니다. 전달된 예외 객체를 발생 시켜 에러와 경고를 예외로 변환할 수 있습니다."

#: ../Doc/library/xml.sax.handler.rst:397
msgid ""
"Called when the parser encounters a recoverable error.  If this method "
"does not raise an exception, parsing may continue, but further document "
"information should not be expected by the application.  Allowing the "
"parser to continue may allow additional errors to be discovered in the "
"input document."
msgstr ""
"구문 분석기가 복구 가능한 에러를 만나면 호출됩니다. 이 메서드가 예외를 발생시키지 않으면, 구문 분석이 계속될 수 있지만, 응용 "
"프로그램에서 추가 문서 정보를 기대하지 않아야 합니다. 구문 분석기가 계속되도록 허용하면 입력 문서에서 추가 에러가 발견될 수 "
"있습니다."

#: ../Doc/library/xml.sax.handler.rst:405
msgid ""
"Called when the parser encounters an error it cannot recover from; "
"parsing is expected to terminate when this method returns."
msgstr "구문 분석기가 복구 불가능한 에러를 만나면 호출됩니다; 이 메서드가 반환될 때 구문 분석이 종료될 것으로 기대합니다."

#: ../Doc/library/xml.sax.handler.rst:411
msgid ""
"Called when the parser presents minor warning information to the "
"application. Parsing is expected to continue when this method returns, "
"and document information will continue to be passed to the application. "
"Raising an exception in this method will cause parsing to end."
msgstr ""
"구문 분석기가 응용 프로그램에 경미한 경고 정보를 제공할 때 호출됩니다. 이 메서드가 반환될 때 구문 분석이 계속될 것으로 "
"기대되며, 문서 정보는 계속 응용 프로그램에 전달됩니다. 이 메서드에서 예외를 발생시키면 구문 분석이 종료됩니다."

