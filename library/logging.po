# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-25 10:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/library/logging.rst:2
msgid ":mod:`logging` --- Logging facility for Python"
msgstr ":mod:`logging` --- 파이썬 로깅 시설"

#: ../Doc/library/logging.rst:10
msgid "**Source code:** :source:`Lib/logging/__init__.py`"
msgstr "**소스 코드:** :source:`Lib/logging/__init__.py`"

#: ../Doc/library/logging.rst:16
msgid ""
"This page contains the API reference information. For tutorial "
"information and discussion of more advanced topics, see"
msgstr "이 페이지는 API 레퍼런스 정보를 담고 있습니다. 자습서 정보 및 고급 주제에 대한 설명은 다음을 참조하십시오."

#: ../Doc/library/logging.rst:19
msgid ":ref:`Basic Tutorial <logging-basic-tutorial>`"
msgstr ":ref:`기초 자습서 <logging-basic-tutorial>`"

#: ../Doc/library/logging.rst:20
msgid ":ref:`Advanced Tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`고급 자습서 <logging-advanced-tutorial>`"

#: ../Doc/library/logging.rst:21
msgid ":ref:`Logging Cookbook <logging-cookbook>`"
msgstr ":ref:`로깅 요리책 <logging-cookbook>`"

#: ../Doc/library/logging.rst:25
msgid ""
"This module defines functions and classes which implement a flexible "
"event logging system for applications and libraries."
msgstr "이 모듈은 응용 프로그램과 라이브러리를 위한 유연한 이벤트 로깅 시스템을 구현하는 함수와 클래스를 정의합니다."

#: ../Doc/library/logging.rst:28
msgid ""
"The key benefit of having the logging API provided by a standard library "
"module is that all Python modules can participate in logging, so your "
"application log can include your own messages integrated with messages "
"from third-party modules."
msgstr ""
"표준 라이브러리 모듈로 로깅 API를 제공하는 것의 주요 이점은, 모든 파이썬 모듈이 로깅에 참여할 수 있어서, 응용 프로그램 "
"로그에 여러분 자신의 메시지를 제삼자 모듈의 메시지와 통합할 수 있다는 것입니다."

#: ../Doc/library/logging.rst:33
msgid ""
"The module provides a lot of functionality and flexibility.  If you are "
"unfamiliar with logging, the best way to get to grips with it is to see "
"the tutorials (see the links on the right)."
msgstr ""
"이 모듈은 많은 기능과 유연성을 제공합니다. 로깅에 익숙하지 않다면, 감을 잡는 가장 좋은 방법은 자습서를 보는 것입니다 (오른쪽 "
"링크를 참조하세요)."

#: ../Doc/library/logging.rst:37
msgid ""
"The basic classes defined by the module, together with their functions, "
"are listed below."
msgstr "모듈에 의해 정의된 기본 클래스와 그 기능은 다음과 같습니다."

#: ../Doc/library/logging.rst:40
msgid "Loggers expose the interface that application code directly uses."
msgstr "로거는 응용 프로그램 코드가 직접 사용하는 인터페이스를 노출합니다."

#: ../Doc/library/logging.rst:41
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr "처리기는 (로거가 만든) 로그 레코드를 적절한 목적지로 보냅니다."

#: ../Doc/library/logging.rst:43
msgid ""
"Filters provide a finer grained facility for determining which log "
"records to output."
msgstr "필터는 출력할 로그 레코드를 결정하기 위한 더 세분된 기능을 제공합니다."

#: ../Doc/library/logging.rst:45
msgid "Formatters specify the layout of log records in the final output."
msgstr "포매터는 최종 출력에서 로그 레코드의 배치를 지정합니다."

#: ../Doc/library/logging.rst:51
msgid "Logger Objects"
msgstr "Logger 객체"

#: ../Doc/library/logging.rst:53
msgid ""
"Loggers have the following attributes and methods.  Note that Loggers are"
" never instantiated directly, but always through the module-level "
"function ``logging.getLogger(name)``.  Multiple calls to "
":func:`getLogger` with the same name will always return a reference to "
"the same Logger object."
msgstr ""
"로거에는 다음과 같은 어트리뷰트와 메서드가 있습니다. 로거는 결코 직접 인스턴스를 만드는 일 없이, 항상 모듈 수준의 함수 "
"``logging.getLogger(name)`` 를 거치는 것에 주의하십시오. 같은 이름(name)으로 "
":func:`getLogger` 를 여러 번 호출해도 항상 같은 로거 객체에 대한 참조를 돌려줍니다."

#: ../Doc/library/logging.rst:58
msgid ""
"The ``name`` is potentially a period-separated hierarchical value, like "
"``foo.bar.baz`` (though it could also be just plain ``foo``, for "
"example). Loggers that are further down in the hierarchical list are "
"children of loggers higher up in the list.  For example, given a logger "
"with a name of ``foo``, loggers with names of ``foo.bar``, "
"``foo.bar.baz``, and ``foo.bam`` are all descendants of ``foo``.  The "
"logger name hierarchy is analogous to the Python package hierarchy, and "
"identical to it if you organise your loggers on a per-module basis using "
"the recommended construction ``logging.getLogger(__name__)``.  That's "
"because in a module, ``__name__`` is the module's name in the Python "
"package namespace."
msgstr ""
"``name`` 은 잠재적으로 ``foo.bar.baz`` 와 같이 마침표로 구분된 계층적 값입니다 (하지만 그냥 간단한 "
"``foo`` 도 가능합니다). 계층적 목록에서 더 아래쪽에 있는 로거는 목록에서 상위에 있는 로거의 자식입니다. 예를 들어, "
"이름이 ``foo`` 인 로거가 주어지면, ``foo.bar``, ``foo.bar.baz``, 그리고 ``foo.bam`` 의 "
"이름을 가진 로거는 모두 ``foo`` 의 자손입니다. 로거 이름 계층 구조는 파이썬 패키지 계층 구조와 비슷하며, "
"``logging.getLogger(__name__)`` 를 사용하여 모듈 단위로 로거를 구성하는 경우는 패키지 계층 구조와 "
"같아집니다. 왜냐하면, 모듈에서, ``__name__`` 은 파이썬 패키지 이름 공간의 모듈 이름이기 때문입니다."

#: ../Doc/library/logging.rst:74
msgid ""
"If this attribute evaluates to true, events logged to this logger will be"
" passed to the handlers of higher level (ancestor) loggers, in addition "
"to any handlers attached to this logger. Messages are passed directly to "
"the ancestor loggers' handlers - neither the level nor filters of the "
"ancestor loggers in question are considered."
msgstr ""
"이 어트리뷰트가 참으로 평가되면, 이 로거에 로그 된 이벤트는 이 로거에 첨부된 처리기뿐 아니라 상위 계층 (조상) 로거의 처리기로"
" 전달됩니다. 메시지는 조상 로거의 처리기에 직접 전달됩니다 - 조상 로거의 수준이나 필터는 고려하지 않습니다."

#: ../Doc/library/logging.rst:80
msgid ""
"If this evaluates to false, logging messages are not passed to the "
"handlers of ancestor loggers."
msgstr "이 값이 거짓으로 평가되면, 로깅 메시지가 조상 로거의 처리기로 전달되지 않습니다."

#: ../Doc/library/logging.rst:83
msgid "The constructor sets this attribute to ``True``."
msgstr "생성자는 이 어트리뷰트를 ``True`` 로 설정합니다."

#: ../Doc/library/logging.rst:85
msgid ""
"If you attach a handler to a logger *and* one or more of its ancestors, "
"it may emit the same record multiple times. In general, you should not "
"need to attach a handler to more than one logger - if you just attach it "
"to the appropriate logger which is highest in the logger hierarchy, then "
"it will see all events logged by all descendant loggers, provided that "
"their propagate setting is left set to ``True``. A common scenario is to "
"attach handlers only to the root logger, and to let propagation take care"
" of the rest."
msgstr ""
"로거 *와* 하나 이상의 조상에 처리기를 중복해서 연결하면, 같은 레코드를 여러 번 출력할 수 있습니다. 일반적으로, 하나 이상의 "
"로거에 처리기를 붙일 필요는 없습니다. 로거 계층에서 가장 높은 적절한 로거에 처리기를 연결하면, propagate 설정이 "
"``True`` 로 남아있는 모든 자식 로거들이 로그 하는 모든 이벤트를 보게 됩니다. 일반적인 시나리오는 루트 로거에만 처리기를 "
"연결하고, 전파가 나머지를 처리하도록 하는 것입니다."

#: ../Doc/library/logging.rst:96
msgid ""
"Sets the threshold for this logger to *level*. Logging messages which are"
" less severe than *level* will be ignored; logging messages which have "
"severity *level* or higher will be emitted by whichever handler or "
"handlers service this logger, unless a handler's level has been set to a "
"higher severity level than *level*."
msgstr ""
"이 로거의 수준 경계를 *level* 로 설정합니다. *level* 보다 덜 심각한 로깅 메시지는 무시됩니다; 심각도 *level*"
" 이상의 로깅 메시지는, 처리기 수준이 *level* 보다 높은 심각도 수준으로 설정되지 않는 한, 이 로거에 연결된 처리기가 "
"출력합니다."

#: ../Doc/library/logging.rst:101
msgid ""
"When a logger is created, the level is set to :const:`NOTSET` (which "
"causes all messages to be processed when the logger is the root logger, "
"or delegation to the parent when the logger is a non-root logger). Note "
"that the root logger is created with level :const:`WARNING`."
msgstr ""
"로거가 만들어질 때, 수준은 :const:`NOTSET` (로거가 루트 로거 일 때는 모든 메시지를 처리하게 하고, 로거가 루트 "
"로거가 아니면 모든 메시지를 부모에게 위임하도록 합니다) 으로 설정됩니다. 루트 로거는 수준 :const:`WARNING`\\으로 "
"만들어짐에 유의하세요."

#: ../Doc/library/logging.rst:106
msgid ""
"The term 'delegation to the parent' means that if a logger has a level of"
" NOTSET, its chain of ancestor loggers is traversed until either an "
"ancestor with a level other than NOTSET is found, or the root is reached."
msgstr ""
"'부모에게 위임'\\이라는 말은, 로거 수준이 NOTSET 인 경우, NOTSET 이외의 수준을 갖는 조상이 발견되거나 루트에 "
"도달할 때까지 조상 로거 체인을 탐색함을 의미합니다."

#: ../Doc/library/logging.rst:110
msgid ""
"If an ancestor is found with a level other than NOTSET, then that "
"ancestor's level is treated as the effective level of the logger where "
"the ancestor search began, and is used to determine how a logging event "
"is handled."
msgstr ""
"NOTSET 이외의 수준을 갖는 조상이 발견되면, 그 조상의 수준을 조상 검색이 시작된 로거의 유효 수준으로 간주하여, 로깅 "
"이벤트를 처리할지를 결정하는 데 사용됩니다."

#: ../Doc/library/logging.rst:114
msgid ""
"If the root is reached, and it has a level of NOTSET, then all messages "
"will be processed. Otherwise, the root's level will be used as the "
"effective level."
msgstr ""
"루트에 도달하면, 그리고 루트가 NOTSET 수준을 갖고 있으면, 모든 메시지가 처리됩니다. 그렇지 않으면 루트 수준이 유효 "
"수준으로 사용됩니다."

#: ../Doc/library/logging.rst:117 ../Doc/library/logging.rst:407
msgid "See :ref:`levels` for a list of levels."
msgstr "수준의 목록은 :ref:`levels`\\를 보세요."

#: ../Doc/library/logging.rst:119
msgid ""
"The *level* parameter now accepts a string representation of the level "
"such as 'INFO' as an alternative to the integer constants such as "
":const:`INFO`. Note, however, that levels are internally stored as "
"integers, and methods such as e.g. :meth:`getEffectiveLevel` and "
":meth:`isEnabledFor` will return/expect to be passed integers."
msgstr ""
"*level* 매개 변수는 이제 :const:`INFO`\\와 같은 정수 상수 대신 'INFO'\\와 같은 수준의 문자열 표현을 "
"허용합니다. 그러나 수준은 내부적으로 정수로 저장되며, :meth:`getEffectiveLevel` 및 "
":meth:`isEnabledFor`\\와 같은 메서드는 정수를 반환하거나 정수가 전달되기를 기대합니다."

#: ../Doc/library/logging.rst:129
msgid ""
"Indicates if a message of severity *lvl* would be processed by this "
"logger. This method checks first the module-level level set by "
"``logging.disable(lvl)`` and then the logger's effective level as "
"determined by :meth:`getEffectiveLevel`."
msgstr ""
"심각도 *lvl* 의 메시지가 이 로거에서 처리될지를 알려줍니다. 이 메서드는 먼저 ``logging.disable(lvl)`` 에"
" 의해 설정된 모듈 수준의 수준을 확인한 다음, :meth:`getEffectiveLevel`\\로 확인되는 로거의 유효 수준을 "
"검사합니다."

#: ../Doc/library/logging.rst:137
msgid ""
"Indicates the effective level for this logger. If a value other than "
":const:`NOTSET` has been set using :meth:`setLevel`, it is returned. "
"Otherwise, the hierarchy is traversed towards the root until a value "
"other than :const:`NOTSET` is found, and that value is returned. The "
"value returned is an integer, typically one of :const:`logging.DEBUG`, "
":const:`logging.INFO` etc."
msgstr ""
"이 로거의 유효 수준을 알려줍니다. :meth:`setLevel` 을 사용하여 :const:`NOTSET` 이외의 값이 설정되면, "
"그 값이 반환됩니다. 그렇지 않으면, :const:`NOTSET` 이외의 값이 발견될 때까지 루트를 향해 계층 구조를 탐색하고, 그"
" 값이 반환됩니다. 반환되는 값은 정수이며, 일반적으로 :const:`logging.DEBUG`, "
":const:`logging.INFO` 등 중 하나입니다."

#: ../Doc/library/logging.rst:147
msgid ""
"Returns a logger which is a descendant to this logger, as determined by "
"the suffix. Thus, ``logging.getLogger('abc').getChild('def.ghi')`` would "
"return the same logger as would be returned by "
"``logging.getLogger('abc.def.ghi')``. This is a convenience method, "
"useful when the parent logger is named using e.g. ``__name__`` rather "
"than a literal string."
msgstr ""
"접미사에 의해 결정되는, 이 로거의 자손 로거를 반환합니다. 그러므로, "
"``logging.getLogger('abc').getChild('def.ghi')`` 는 "
"``logging.getLogger('abc.def.ghi')`` 와 같은 로거를 반환합니다. 이것은 편의 메서드인데, 부모 로거가"
" 리터럴 문자열이 아닌 이름(가령 ``__name__``)을 사용하여 명명될 때 유용합니다."

#: ../Doc/library/logging.rst:158
msgid ""
"Logs a message with level :const:`DEBUG` on this logger. The *msg* is the"
" message format string, and the *args* are the arguments which are merged"
" into *msg* using the string formatting operator. (Note that this means "
"that you can use keywords in the format string, together with a single "
"dictionary argument.)"
msgstr ""
"이 로거에 수준 :const:`DEBUG` 메시지를 로그 합니다. *msg* 는 메시지 포맷 문자열이고, *args* 는 문자열 "
"포매팅 연산자를 사용하여 *msg* 에 병합되는 인자입니다. (이는 포맷 문자열에 키워드를 사용하고, 인자로 하나의 딕셔너리를 "
"전달할 수 있음을 의미합니다.)"

#: ../Doc/library/logging.rst:163
msgid ""
"There are three keyword arguments in *kwargs* which are inspected: "
"*exc_info*, *stack_info*, and *extra*."
msgstr "*kwargs* 에서 검사되는 세 개의 키워드 인자가 있습니다: *exc_info*, *stack_info* 및 *extra*."

#: ../Doc/library/logging.rst:166
msgid ""
"If *exc_info* does not evaluate as false, it causes exception information"
" to be added to the logging message. If an exception tuple (in the format"
" returned by :func:`sys.exc_info`) or an exception instance is provided, "
"it is used; otherwise, :func:`sys.exc_info` is called to get the "
"exception information."
msgstr ""
"*exc_info* 가 거짓으로 평가되지 않으면, 로깅 메시지에 예외 정보가 추가됩니다. 예외 튜플 "
"(:func:`sys.exc_info` 에 의해 반환되는 형식) 또는 예외 인스턴스가 제공되면 사용됩니다; 그렇지 않으면 예외 "
"정보를 얻기 위해 :func:`sys.exc_info` 를 호출합니다."

#: ../Doc/library/logging.rst:171 ../Doc/library/logging.rst:937
msgid ""
"The second optional keyword argument is *stack_info*, which defaults to "
"``False``. If true, stack information is added to the logging message, "
"including the actual logging call. Note that this is not the same stack "
"information as that displayed through specifying *exc_info*: The former "
"is stack frames from the bottom of the stack up to the logging call in "
"the current thread, whereas the latter is information about stack frames "
"which have been unwound, following an exception, while searching for "
"exception handlers."
msgstr ""
"두 번째 선택적 키워드 인자는 *stack_info* 이며, 기본값은 ``False`` 입니다. 참이면, 실제 로깅 호출을 포함하는"
" 스택 정보가 로깅 메시지에 추가됩니다. 이것은 *exc_info* 를 지정할 때 표시되는 것과 같은 스택 정보가 아닙니다: "
"전자(*stack_info*)는 스택의 맨 아래에서 현재 스레드의 로깅 호출까지의 스택 프레임이며, 후자(*exc_info*)는 "
"예외가 일어난 후에 예외 처리기를 찾으면서 되감은 스택 프레임에 대한 정보입니다."

#: ../Doc/library/logging.rst:180 ../Doc/library/logging.rst:946
msgid ""
"You can specify *stack_info* independently of *exc_info*, e.g. to just "
"show how you got to a certain point in your code, even when no exceptions"
" were raised. The stack frames are printed following a header line which "
"says:"
msgstr ""
"*exc_info* 와는 독립적으로 *stack_info* 를 지정할 수 있습니다. 예를 들어 예외가 발생하지 않은 경우에도 코드의"
" 특정 지점에 어떻게 도달했는지 보여줄 수 있습니다. 스택 프레임은 다음과 같은 헤더 행 다음에 인쇄됩니다:"

#: ../Doc/library/logging.rst:188 ../Doc/library/logging.rst:954
msgid ""
"This mimics the ``Traceback (most recent call last):`` which is used when"
" displaying exception frames."
msgstr "예외 프레임을 표시할 때 사용되는 ``Traceback (most recent call last):`` 을 흉내 내고 있습니다."

#: ../Doc/library/logging.rst:191
msgid ""
"The third keyword argument is *extra* which can be used to pass a "
"dictionary which is used to populate the __dict__ of the LogRecord "
"created for the logging event with user-defined attributes. These custom "
"attributes can then be used as you like. For example, they could be "
"incorporated into logged messages. For example::"
msgstr ""
"세 번째 키워드 인자는 *extra* 로, 로깅 이벤트용으로 만들어진 LogRecord의 __dict__ 를 사용자 정의 "
"어트리뷰트로 채우는 데 사용되는 딕셔너리를 전달할 수 있습니다. 이러한 사용자 정의 어트리뷰트는 원하는 대로 사용할 수 있습니다. "
"예를 들어, 로그 메시지에 포함할 수 있습니다. 예를 들면::"

#: ../Doc/library/logging.rst:203
msgid "would print something like"
msgstr "는 이렇게 인쇄할 것입니다"

#: ../Doc/library/logging.rst:209 ../Doc/library/logging.rst:974
msgid ""
"The keys in the dictionary passed in *extra* should not clash with the "
"keys used by the logging system. (See the :class:`Formatter` "
"documentation for more information on which keys are used by the logging "
"system.)"
msgstr ""
"*extra* 에 전달된 딕셔너리의 키가, 로깅 시스템에서 사용하는 키와 충돌해서는 안 됩니다. (어떤 키가 로깅 시스템에 의해 "
"사용되는지에 대한 더 많은 정보는 :class:`Formatter` 문서를 보십시오.)"

#: ../Doc/library/logging.rst:213 ../Doc/library/logging.rst:978
msgid ""
"If you choose to use these attributes in logged messages, you need to "
"exercise some care. In the above example, for instance, the "
":class:`Formatter` has been set up with a format string which expects "
"'clientip' and 'user' in the attribute dictionary of the LogRecord. If "
"these are missing, the message will not be logged because a string "
"formatting exception will occur. So in this case, you always need to pass"
" the *extra* dictionary with these keys."
msgstr ""
"로그 된 메시지에서 이러한 어트리뷰트를 사용하려면 몇 가지 주의를 기울여야 합니다. 위의 예에서, 예를 들어, "
":class:`Formatter` 에 설정한 포맷 문자열은 LogRecord의 어트리뷰트 딕셔너리에 'clientip' 과 "
"'user' 가 있을 것으로 기대하고 있습니다. 이것들이 없는 경우 문자열 포매팅 예외가 발생하기 때문에 메시지가 기록되지 "
"않습니다. 따라서 이 경우, 항상 이 키를 포함하는 *extra* 딕셔너리를 전달해야 합니다."

#: ../Doc/library/logging.rst:220 ../Doc/library/logging.rst:985
msgid ""
"While this might be annoying, this feature is intended for use in "
"specialized circumstances, such as multi-threaded servers where the same "
"code executes in many contexts, and interesting conditions which arise "
"are dependent on this context (such as remote client IP address and "
"authenticated user name, in the above example). In such circumstances, it"
" is likely that specialized :class:`Formatter`\\ s would be used with "
"particular :class:`Handler`\\ s."
msgstr ""
"성가신 일입니다만, 이 기능은 여러 문맥에서 같은 코드가 실행되고 관심 있는 조건들(가령 원격 클라이언트 IP 주소와 인증된 사용자"
" 이름)이 문맥에 따라 발생하는 다중 스레드 서버와 같은 특수한 상황을 위한 것입니다. 이런 상황에서는, 특수한 "
":class:`Formatter` 가 특정한 :class:`Handler`\\와 함께 사용될 가능성이 큽니다."

#: ../Doc/library/logging.rst:227 ../Doc/library/logging.rst:992
msgid "The *stack_info* parameter was added."
msgstr "*stack_info* 매개 변수가 추가되었습니다."

#: ../Doc/library/logging.rst:230
msgid "The *exc_info* parameter can now accept exception instances."
msgstr "*exc_info* 매개 변수는 이제 예외 인스턴스를 받아들입니다."

#: ../Doc/library/logging.rst:236
msgid ""
"Logs a message with level :const:`INFO` on this logger. The arguments are"
" interpreted as for :meth:`debug`."
msgstr "이 로거에 수준 :const:`INFO` 메시지를 로그 합니다. 인자는 :meth:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:242
msgid ""
"Logs a message with level :const:`WARNING` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr "이 로거에 수준 :const:`WARNING` 메시지를 로그 합니다. 인자는 :meth:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:245
msgid ""
"There is an obsolete method ``warn`` which is functionally identical to "
"``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"기능적으로 ``warning`` 와 같은, 구식의 ``warn`` 메서드가 있습니다. ``warn`` 은 폐지되었으므로 사용하지 "
"마십시오 - 대신 ``warning`` 을 사용하십시오."

#: ../Doc/library/logging.rst:251
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments "
"are interpreted as for :meth:`debug`."
msgstr "이 로거에 수준 :const:`ERROR` 메시지를 로그 합니다. 인자는 :meth:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:257
msgid ""
"Logs a message with level :const:`CRITICAL` on this logger. The arguments"
" are interpreted as for :meth:`debug`."
msgstr "이 로거에 수준 :const:`CRITICAL` 메시지를 로그 합니다. 인자는 :meth:`debug`\\ 처럼 해석됩니다."

#: ../Doc/library/logging.rst:263
msgid ""
"Logs a message with integer level *lvl* on this logger. The other "
"arguments are interpreted as for :meth:`debug`."
msgstr "이 로거에 정수 수준 *lvl* 로 메시지를 로그 합니다. 다른 인자는 :meth:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:269
msgid ""
"Logs a message with level :const:`ERROR` on this logger. The arguments "
"are interpreted as for :meth:`debug`. Exception info is added to the "
"logging message. This method should only be called from an exception "
"handler."
msgstr ""
"이 로거에 수준 :const:`ERROR` 메시지를 로그 합니다. 인자는 :meth:`debug`\\처럼 해석됩니다. 예외 정보가 "
"로깅 메시지에 추가됩니다. 이 메서드는 예외 처리기에서만 호출해야 합니다."

#: ../Doc/library/logging.rst:276
msgid "Adds the specified filter *filter* to this logger."
msgstr "지정된 필터 *filter* 를 이 로거에 추가합니다."

#: ../Doc/library/logging.rst:281
msgid "Removes the specified filter *filter* from this logger."
msgstr "이 로거에서 지정된 필터 *filter* 를 제거합니다."

#: ../Doc/library/logging.rst:286
msgid ""
"Applies this logger's filters to the record and returns a true value if "
"the record is to be processed. The filters are consulted in turn, until "
"one of them returns a false value. If none of them return a false value, "
"the record will be processed (passed to handlers). If one returns a false"
" value, no further processing of the record occurs."
msgstr ""
"이 로거의 필터를 레코드(record)에 적용하고 레코드가 처리 대상이면 참값을 반환합니다. 필터 중 어느 하나가 거짓 값을 반환할"
" 때까지 필터는 차례로 참조됩니다. 그중 아무것도 거짓 값을 반환하지 않으면 레코드가 처리됩니다 (처리기로 전달됩니다). 어느 "
"하나가 거짓 값을 반환하면, 더 이상의 레코드 처리는 이루어지지 않습니다."

#: ../Doc/library/logging.rst:295
msgid "Adds the specified handler *hdlr* to this logger."
msgstr "지정된 처리기 *hdlr* 를 이 로거에 추가합니다."

#: ../Doc/library/logging.rst:300
msgid "Removes the specified handler *hdlr* from this logger."
msgstr "이 로거에서 지정된 처리기 *hdlr* 을 제거합니다."

#: ../Doc/library/logging.rst:305
msgid ""
"Finds the caller's source filename and line number. Returns the filename,"
" line number, function name and stack information as a 4-element tuple. "
"The stack information is returned as ``None`` unless *stack_info* is "
"``True``."
msgstr ""
"호출자의 소스 파일 이름과 행 번호를 찾습니다. 파일 이름, 행 번호, 함수 이름 및 스택 정보를 4-요소 튜플로 반환합니다. 스택"
" 정보는 *stack_info* 가 ``True`` 가 아니면 ``None`` 으로 반환됩니다."

#: ../Doc/library/logging.rst:312
msgid ""
"Handles a record by passing it to all handlers associated with this "
"logger and its ancestors (until a false value of *propagate* is found). "
"This method is used for unpickled records received from a socket, as well"
" as those created locally. Logger-level filtering is applied using "
":meth:`~Logger.filter`."
msgstr ""
"이 로거와 그 조상(거짓 값의 *propagate* 가 발견될 때까지)과 연관된 모든 처리기에 레코드를 전달하여 레코드를 "
"처리합니다. 이 메서드는 로컬에서 만든 레코드뿐만 아니라 소켓에서 받아서 언피클된 레코드를 처리하는 데 사용됩니다. "
":meth:`~Logger.filter` 를 사용하여 로거 수준 필터링을 적용합니다."

#: ../Doc/library/logging.rst:320
msgid ""
"This is a factory method which can be overridden in subclasses to create "
"specialized :class:`LogRecord` instances."
msgstr "이 메서드는 특수한 :class:`LogRecord` 인스턴스를 만들기 위해 서브 클래스에서 재정의할 수 있는 팩토리 메서드입니다."

#: ../Doc/library/logging.rst:325
msgid ""
"Checks to see if this logger has any handlers configured. This is done by"
" looking for handlers in this logger and its parents in the logger "
"hierarchy. Returns ``True`` if a handler was found, else ``False``. The "
"method stops searching up the hierarchy whenever a logger with the "
"'propagate' attribute set to false is found - that will be the last "
"logger which is checked for the existence of handlers."
msgstr ""
"이 로거에 처리기가 구성되어 있는지 확인합니다. 이 로거의 처리기와 로거 계층의 부모를 찾습니다. 처리기가 발견되면 ``True``"
" 를 반환하고, 그렇지 않으면 ``False`` 를 반환합니다. 이 메서드는 'propagate' 어트리뷰트가 거짓으로 설정된 "
"로거가 발견될 때 계층 구조 검색을 중지합니다 - 그 로거가 처리기가 있는지 검사하는 마지막 로거가 됩니다."

#: ../Doc/library/logging.rst:334
msgid "Loggers can now be pickled and unpickled."
msgstr "이제 로거는 피클 되고 언피클 될 수 있습니다."

#: ../Doc/library/logging.rst:340
msgid "Logging Levels"
msgstr "로깅 수준"

#: ../Doc/library/logging.rst:342
msgid ""
"The numeric values of logging levels are given in the following table. "
"These are primarily of interest if you want to define your own levels, "
"and need them to have specific values relative to the predefined levels. "
"If you define a level with the same numeric value, it overwrites the "
"predefined value; the predefined name is lost."
msgstr ""
"로깅 수준의 숫자 값은 다음 표에 나와 있습니다. 여러분 자신의 수준을 정의하고, 미리 정의된 수준과 상대적인 특정 값을 갖도록 "
"하려는 경우 필요합니다. 같은 숫자 값을 가진 수준을 정의하면 미리 정의된 값을 덮어씁니다; 미리 정의된 이름이 유실됩니다."

#: ../Doc/library/logging.rst:349
msgid "Level"
msgstr "수준"

#: ../Doc/library/logging.rst:349
msgid "Numeric value"
msgstr "숫자 값"

#: ../Doc/library/logging.rst:351
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../Doc/library/logging.rst:351
msgid "50"
msgstr "50"

#: ../Doc/library/logging.rst:353
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../Doc/library/logging.rst:353
msgid "40"
msgstr "40"

#: ../Doc/library/logging.rst:355
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../Doc/library/logging.rst:355
msgid "30"
msgstr "30"

#: ../Doc/library/logging.rst:357
msgid "``INFO``"
msgstr "``INFO``"

#: ../Doc/library/logging.rst:357
msgid "20"
msgstr "20"

#: ../Doc/library/logging.rst:359
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../Doc/library/logging.rst:359
msgid "10"
msgstr "10"

#: ../Doc/library/logging.rst:361
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../Doc/library/logging.rst:361
msgid "0"
msgstr "0"

#: ../Doc/library/logging.rst:368
msgid "Handler Objects"
msgstr "Handler 객체"

#: ../Doc/library/logging.rst:370
msgid ""
"Handlers have the following attributes and methods. Note that "
":class:`Handler` is never instantiated directly; this class acts as a "
"base for more useful subclasses. However, the :meth:`__init__` method in "
"subclasses needs to call :meth:`Handler.__init__`."
msgstr ""
"처리기에는 다음과 같은 어트리뷰트와 메서드가 있습니다. :class:`Handler` 는 절대로 직접 인스턴스로 만들어지지 않음에 "
"주의하세요; 이 클래스는 더욱 유용한 서브 클래스의 베이스가 됩니다. 그러나, 서브 클래스의 :meth:`__init__` 메서드는"
" :meth:`Handler.__init__` 을 호출해야 합니다."

#: ../Doc/library/logging.rst:379
msgid ""
"Initializes the :class:`Handler` instance by setting its level, setting "
"the list of filters to the empty list and creating a lock (using "
":meth:`createLock`) for serializing access to an I/O mechanism."
msgstr ""
"수준을 설정하고, 필터 목록을 빈 리스트로 설정하고, I/O 메커니즘에 대한 액세스를 직렬화하기 위해 "
"(:meth:`createLock` 을 사용하여) 록을 생성함으로써 :class:`Handler` 인스턴스를 초기화합니다."

#: ../Doc/library/logging.rst:386
msgid ""
"Initializes a thread lock which can be used to serialize access to "
"underlying I/O functionality which may not be threadsafe."
msgstr "스레드 안전하지 않은 하부 I/O 기능에 대한 액세스를 직렬화하는 데 사용할 수 있는 스레드 록을 초기화합니다."

#: ../Doc/library/logging.rst:392
msgid "Acquires the thread lock created with :meth:`createLock`."
msgstr ":meth:`createLock` 로 생성된 스레드 록을 확보합니다."

#: ../Doc/library/logging.rst:397
msgid "Releases the thread lock acquired with :meth:`acquire`."
msgstr ":meth:`acquire`\\로 확보한 스레드 록을 반납합니다."

#: ../Doc/library/logging.rst:402
msgid ""
"Sets the threshold for this handler to *level*. Logging messages which "
"are less severe than *level* will be ignored. When a handler is created, "
"the level is set to :const:`NOTSET` (which causes all messages to be "
"processed)."
msgstr ""
"이 처리기의 수준 경계를 *level* 로 설정합니다. *level* 보다 덜 심각한 로깅 메시지는 무시됩니다. 처리기가 만들어질 "
"때, 수준은 :const:`NOTSET` (모든 메시지가 처리되게 합니다) 으로 설정됩니다."

#: ../Doc/library/logging.rst:409
msgid ""
"The *level* parameter now accepts a string representation of the level "
"such as 'INFO' as an alternative to the integer constants such as "
":const:`INFO`."
msgstr ""
"*level* 매개 변수는 이제 :const:`INFO`\\와 같은 정수 상수 대신 'INFO'\\와 같은 수준 문자열 표현을 "
"허용합니다."

#: ../Doc/library/logging.rst:417
msgid "Sets the :class:`Formatter` for this handler to *fmt*."
msgstr "이 처리기의 :class:`Formatter`\\를 *fmt* 로 설정합니다."

#: ../Doc/library/logging.rst:422
msgid "Adds the specified filter *filter* to this handler."
msgstr "지정된 필터 *filter* 를 이 처리기에 추가합니다."

#: ../Doc/library/logging.rst:427
msgid "Removes the specified filter *filter* from this handler."
msgstr "이 처리기에서 지정된 필터 *filter* 를 제거합니다."

#: ../Doc/library/logging.rst:432
msgid ""
"Applies this handler's filters to the record and returns a true value if "
"the record is to be processed. The filters are consulted in turn, until "
"one of them returns a false value. If none of them return a false value, "
"the record will be emitted. If one returns a false value, the handler "
"will not emit the record."
msgstr ""
"이 처리기의 필터를 레코드에 적용하고 레코드가 처리 대상이면 참값을 반환합니다. 필터 중 어느 하나가 거짓 값을 반환할 때까지 "
"필터는 차례로 확인됩니다. 그중 아무것도 거짓 값을 반환하지 않으면 레코드가 출력됩니다. 어느 하나가 거짓 값을 반환하면 처리기는 "
"레코드를 출력하지 않습니다."

#: ../Doc/library/logging.rst:441
msgid ""
"Ensure all logging output has been flushed. This version does nothing and"
" is intended to be implemented by subclasses."
msgstr "모든 로그 출력이 플러시 되었음을 확실히 합니다. 이 버전은 아무것도 하지 않으며, 서브 클래스에 의해 구현됩니다."

#: ../Doc/library/logging.rst:447
msgid ""
"Tidy up any resources used by the handler. This version does no output "
"but removes the handler from an internal list of handlers which is closed"
" when :func:`shutdown` is called. Subclasses should ensure that this gets"
" called from overridden :meth:`close` methods."
msgstr ""
"처리기가 사용하는 자원을 정리합니다. 이 버전은 출력하지 않지만, :func:`shutdown` 이 호출 될 때 닫히는 처리기의 "
"내부 목록에서 처리기를 제거합니다. 서브 클래스는 이것이 재정의된 :meth:`close` 메서드에서 이 메서드를 호출해야 합니다."

#: ../Doc/library/logging.rst:455
msgid ""
"Conditionally emits the specified logging record, depending on filters "
"which may have been added to the handler. Wraps the actual emission of "
"the record with acquisition/release of the I/O thread lock."
msgstr ""
"처리기에 추가된 필터에 따라 조건부로, 지정된 로깅 레코드를 출력합니다. 레코드의 실제 출력을 I/O 스레드 록의 확보/해제로 "
"둘러쌉니다."

#: ../Doc/library/logging.rst:462
msgid ""
"This method should be called from handlers when an exception is "
"encountered during an :meth:`emit` call. If the module-level attribute "
"``raiseExceptions`` is ``False``, exceptions get silently ignored. This "
"is what is mostly wanted for a logging system - most users will not care "
"about errors in the logging system, they are more interested in "
"application errors. You could, however, replace this with a custom "
"handler if you wish. The specified record is the one which was being "
"processed when the exception occurred. (The default value of "
"``raiseExceptions`` is ``True``, as that is more useful during "
"development)."
msgstr ""
"이 메서드는 :meth:`emit` 호출 중에 예외가 발생할 때 처리기에서 호출됩니다. 모듈 수준 어트리뷰트 "
"``raiseExceptions`` 가 ``False`` 인 경우 예외는 조용히 무시됩니다. 이 동작은 대부분 로깅 시스템에서 "
"원하는 방식입니다 - 대부분 사용자는 로깅 시스템 자체의 에러에 관심이 없고, 응용 프로그램 에러에 더 관심이 있습니다. 그러나 "
"원하는 경우, 사용자 정의 처리기로 바꿀 수 있습니다. 지정된 레코드는 예외가 발생할 때 처리되고 있던 레코드입니다. "
"(``raiseExceptions`` 의 기본값은 ``True`` 입니다. 개발 중에 더 유용합니다)."

#: ../Doc/library/logging.rst:475
msgid ""
"Do formatting for a record - if a formatter is set, use it. Otherwise, "
"use the default formatter for the module."
msgstr "레코드를 포맷합니다 - 포매터가 설정된 경우 사용합니다. 그렇지 않으면 모듈의 기본 포매터를 사용합니다."

#: ../Doc/library/logging.rst:481
msgid ""
"Do whatever it takes to actually log the specified logging record. This "
"version is intended to be implemented by subclasses and so raises a "
":exc:`NotImplementedError`."
msgstr ""
"지정된 로깅 레코드를 실제로 로그 하는 데 필요한 작업을 수행합니다. 이 버전은 서브 클래스에 의해 구현될 것으로 보고 "
":exc:`NotImplementedError`\\를 발생시킵니다."

#: ../Doc/library/logging.rst:485
msgid "For a list of handlers included as standard, see :mod:`logging.handlers`."
msgstr "표준으로 포함된 처리기 목록은 :mod:`logging.handlers` 를 참조하십시오."

#: ../Doc/library/logging.rst:490
msgid "Formatter Objects"
msgstr "Formatter 객체"

#: ../Doc/library/logging.rst:494
#, python-format
msgid ""
":class:`Formatter` objects have the following attributes and methods. "
"They are responsible for converting a :class:`LogRecord` to (usually) a "
"string which can be interpreted by either a human or an external system. "
"The base :class:`Formatter` allows a formatting string to be specified. "
"If none is supplied, the default value of ``'%(message)s'`` is used, "
"which just includes the message in the logging call. To have additional "
"items of information in the formatted output (such as a timestamp), keep "
"reading."
msgstr ""
":class:`Formatter` 객체는 다음과 같은 어트리뷰트와 메서드를 가지고 있습니다. 이들은 "
":class:`LogRecord` 를 (보통) 사람이나 외부 시스템이 해석 할 수 있는 문자열로 변환하는 역할을 합니다. 베이스 "
":class:`Formatter` 는 포매팅 문자열을 지정할 수 있게 합니다. 아무것도 지정하지 않으면, "
"``'%(message)s'`` 이 기본값으로 사용되는데, 단지 로깅 호출에서 제공된 메시지만 포함됩니다. 포맷된 출력에 추가 "
"정보(가령 타임스탬프)를 넣으려면 계속 읽으십시오."

#: ../Doc/library/logging.rst:502
#, python-format
msgid ""
"A Formatter can be initialized with a format string which makes use of "
"knowledge of the :class:`LogRecord` attributes - such as the default "
"value mentioned above making use of the fact that the user's message and "
"arguments are pre-formatted into a :class:`LogRecord`'s *message* "
"attribute.  This format string contains standard Python %-style mapping "
"keys. See section :ref:`old-string-formatting` for more information on "
"string formatting."
msgstr ""
"포매터는 :class:`LogRecord` 어트리뷰트에 포함된 정보를 사용하는 포맷 문자열로 초기화될 수 있습니다 - 위에서 언급 "
"한 기본값은 사용자의 메시지와 인자가 :class:`LogRecord` 의 *message* 어트리뷰트로 미리 포맷된다는 사실을 "
"활용합니다. 이 포맷 문자열은 표준 파이썬 %-스타일 매핑 키를 포함합니다. 문자열 포매팅에 대해서 더 많은 정보가 필요하면 "
":ref:`old-string-formatting`\\를 보세요."

#: ../Doc/library/logging.rst:509
msgid ""
"The useful mapping keys in a :class:`LogRecord` are given in the section "
"on :ref:`logrecord-attributes`."
msgstr ":class:`LogRecord` 에 있는 유용한 매핑 키는 :ref:`logrecord-attributes` 섹션에 있습니다."

#: ../Doc/library/logging.rst:515
#, python-format
msgid ""
"Returns a new instance of the :class:`Formatter` class.  The instance is "
"initialized with a format string for the message as a whole, as well as a"
" format string for the date/time portion of a message.  If no *fmt* is "
"specified, ``'%(message)s'`` is used.  If no *datefmt* is specified, a "
"format is used which is described in the :meth:`formatTime` "
"documentation."
msgstr ""
":class:`Formatter` 클래스의 새로운 인스턴스를 반환합니다. 인스턴스는 전체 메시지의 포맷 문자열과 메시지의 날짜/시간"
" 부분에 대한 포맷 문자열로 초기화됩니다. *fmt* 가 지정되지 않으면 ``'%(message)s'`` 가 사용됩니다. "
"*datefmt* 가 지정되지 않으면 :meth:`formatTime` 설명서에 기술된 포맷이 사용됩니다."

#: ../Doc/library/logging.rst:521
#, python-format
msgid ""
"The *style* parameter can be one of '%', '{' or '$' and determines how "
"the format string will be merged with its data: using one of "
"%-formatting, :meth:`str.format` or :class:`string.Template`. See :ref"
":`formatting-styles` for more information on using {- and $-formatting "
"for log messages."
msgstr ""
"*style* 매개 변수는 '%', '{' 또는 '$' 중 하나일 수 있으며, 포맷 문자열이 데이터와 병합되는 방식을 결정합니다: "
"%-포매팅, :meth:`str.format` 또는 :class:`string.Template` 중 하나를 사용합니다. 로그 "
"메시지에 {- 와 $-포매팅을 사용하는 방법에 대한 자세한 내용은 :ref:`formatting-styles`\\을 참조하십시오."

#: ../Doc/library/logging.rst:526
msgid "The *style* parameter was added."
msgstr "*style* 매개 변수가 추가되었습니다."

#: ../Doc/library/logging.rst:532
msgid ""
"The record's attribute dictionary is used as the operand to a string "
"formatting operation. Returns the resulting string. Before formatting the"
" dictionary, a couple of preparatory steps are carried out. The *message*"
" attribute of the record is computed using *msg* % *args*. If the "
"formatting string contains ``'(asctime)'``, :meth:`formatTime` is called "
"to format the event time. If there is exception information, it is "
"formatted using :meth:`formatException` and appended to the message. Note"
" that the formatted exception information is cached in attribute "
"*exc_text*. This is useful because the exception information can be "
"pickled and sent across the wire, but you should be careful if you have "
"more than one :class:`Formatter` subclass which customizes the formatting"
" of exception information. In this case, you will have to clear the "
"cached value after a formatter has done its formatting, so that the next "
"formatter to handle the event doesn't use the cached value but "
"recalculates it afresh."
msgstr ""
"레코드의 어트리뷰트 딕셔너리가 문자열 포매팅 연산의 피연산자로 사용됩니다. 결과 문자열을 반환합니다. 딕셔너리를 포맷하기 전에 몇 "
"가지 준비 단계가 수행됩니다. 레코드의 *message* 어트리뷰트를 *msg* % *args* 를 사용하여 계산합니다. 포매팅 "
"문자열에 ``'(asctime)'`` 이 들어 있으면, :meth:`formatTime` 이 호출되어 이벤트 시간을 포매팅합니다. "
"예외 정보가 있는 경우, :meth:`formatException` 을 사용하여 포매팅 되고 메시지에 덧붙입니다. 포맷된 예외 "
"정보는 *exc_text* 어트리뷰트에 캐시 됩니다. 예외 정보를 피클 해서 네트워크를 통해 전송할 수 있으므로 유용합니다만, 예외"
" 정보의 포매팅을 사용자 정의하는 :class:`Formatter` 서브 클래스가 두 개 이상 있는 경우 주의해야 합니다. 이 "
"경우, 한 포매터가 포매팅을 완료한 후 캐시 된 값을 지워서 그 이벤트를 처리하는 다음 포매터가 캐시 된 값을 사용하지 않고 새로 "
"계산할 수 있도록 해야 합니다."

#: ../Doc/library/logging.rst:548
msgid ""
"If stack information is available, it's appended after the exception "
"information, using :meth:`formatStack` to transform it if necessary."
msgstr "스택 정보가 있는 경우, 예외 정보 뒤에 덧붙입니다. 필요할 경우 :meth:`formatStack` 을 사용하여 변환합니다."

#: ../Doc/library/logging.rst:554
#, python-format
msgid ""
"This method should be called from :meth:`format` by a formatter which "
"wants to make use of a formatted time. This method can be overridden in "
"formatters to provide for any specific requirement, but the basic "
"behavior is as follows: if *datefmt* (a string) is specified, it is used "
"with :func:`time.strftime` to format the creation time of the record. "
"Otherwise, the format '%Y-%m-%d %H:%M:%S,uuu' is used, where the uuu part"
" is a millisecond value and the other letters are as per the "
":func:`time.strftime` documentation.  An example time in this format is "
"``2003-01-23 00:29:50,411``.  The resulting string is returned."
msgstr ""
"이 메서드는 포맷된 시간을 사용하려는 포매터에 의해 :meth:`format`\\에서 호출되어야 합니다. 이 메서드는 특정 요구 "
"사항을 제공하기 위해 포매터에서 재정의될 수 있지만, 기본 동작은 다음과 같습니다: *datefmt*\\(문자열)이 지정된 경우, "
":func:`time.strftime` 를 사용하여 레코드 생성 시간을 포매팅합니다. 그렇지 않으면 '%Y-%m-%d "
"%H:%M:%S,uuu' 포맷이 사용됩니다. 여기서 uuu 부분은 밀리 초 값이고, 다른 문자들은 "
":func:`time.strftime` 설명서를 따릅니다. 이 포맷의 표현된 시간의 예는 ``2003-01-23 "
"00:29:50,411`` 입니다. 결과 문자열이 반환됩니다."

#: ../Doc/library/logging.rst:564
msgid ""
"This function uses a user-configurable function to convert the creation "
"time to a tuple. By default, :func:`time.localtime` is used; to change "
"this for a particular formatter instance, set the ``converter`` attribute"
" to a function with the same signature as :func:`time.localtime` or "
":func:`time.gmtime`. To change it for all formatters, for example if you "
"want all logging times to be shown in GMT, set the ``converter`` "
"attribute in the ``Formatter`` class."
msgstr ""
"이 함수는 사용자가 구성할 수 있는 함수를 사용하여 생성 시간을 튜플로 변환합니다. 기본적으로 "
":func:`time.localtime` 이 사용됩니다; 특정 포매터 인스턴스에서 이를 변경하려면, ``converter`` "
"어트리뷰트를 :func:`time.localtime` 또는 :func:`time.gmtime` 과 같은 서명을 가진 함수로 "
"설정하십시오. 모든 포매터를 변경하려면, 예를 들어 모든 로깅 시간을 GMT로 표시하려면, ``Formatter`` 클래스의 "
"``converter`` 어트리뷰트를 설정하십시오."

#: ../Doc/library/logging.rst:572
#, python-format
msgid ""
"Previously, the default format was hard-coded as in this example: "
"``2010-09-06 22:38:15,292`` where the part before the comma is handled by"
" a strptime format string (``'%Y-%m-%d %H:%M:%S'``), and the part after "
"the comma is a millisecond value. Because strptime does not have a format"
" placeholder for milliseconds, the millisecond value is appended using "
"another format string, ``'%s,%03d'`` --- and both of these format strings"
" have been hardcoded into this method. With the change, these strings are"
" defined as class-level attributes which can be overridden at the "
"instance level when desired. The names of the attributes are "
"``default_time_format`` (for the strptime format string) and "
"``default_msec_format`` (for appending the millisecond value)."
msgstr ""
"예전에는, 기본 포맷이 다음과 같이 하드 코딩되었습니다: ``2010-09-06 22:38:15,292``. 쉼표 앞에 있는 부분은"
" strptime 포맷 문자열(``'%Y-%m-%d %H:%M:%S'``)이며, 쉼표 뒤의 부분은 밀리 초 값입니다. "
"strptime에 밀리 초 포맷 표시자가 없으므로, 밀리 초 값은 다른 포맷 문자열 ``'%s,%03d'`` 을 사용하여 추가됩니다"
" --- 이 두 포맷 문자열 모두 이 메서드에 하드 코드 되었습니다. 이 변경으로, 이 문자열들은 클래스 수준 어트리뷰트로 "
"정의되었고, 원하는 경우 인스턴스 수준에서 재정의할 수 있습니다. 어트리뷰트 이름은 "
"``default_time_format``\\(strptime 포맷 문자열)과 ``default_msec_format``\\(밀리 "
"초 값 추가용)입니다."

#: ../Doc/library/logging.rst:587
msgid ""
"Formats the specified exception information (a standard exception tuple "
"as returned by :func:`sys.exc_info`) as a string. This default "
"implementation just uses :func:`traceback.print_exception`. The resulting"
" string is returned."
msgstr ""
"지정된 예외 정보(:func:`sys.exc_info` 에 의해 반환되는 표준 예외 튜플)를 문자열로 포맷합니다. 이 기본 구현은 "
":func:`traceback.print_exception`\\을 사용합니다. 결과 문자열이 반환됩니다."

#: ../Doc/library/logging.rst:594
msgid ""
"Formats the specified stack information (a string as returned by "
":func:`traceback.print_stack`, but with the last newline removed) as a "
"string. This default implementation just returns the input value."
msgstr ""
"지정된 스택 정보(:func:`traceback.print_stack` 에 의해 반환된 문자열이지만 마지막 줄 바꿈이 제거됩니다)을"
" 문자열로 포맷합니다. 이 기본 구현은 입력 값을 그대로 반환합니다."

#: ../Doc/library/logging.rst:601
msgid "Filter Objects"
msgstr "Filter 객체"

#: ../Doc/library/logging.rst:603
msgid ""
"``Filters`` can be used by ``Handlers`` and ``Loggers`` for more "
"sophisticated filtering than is provided by levels. The base filter class"
" only allows events which are below a certain point in the logger "
"hierarchy. For example, a filter initialized with 'A.B' will allow events"
" logged by loggers 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' etc. but not "
"'A.BB', 'B.A.B' etc. If initialized with the empty string, all events are"
" passed."
msgstr ""
"``Filter`` 는 수준을 통해 제공되는 것보다 더 정교한 필터링을 위해 ``Handler`` 와 ``Logger`` 에 의해 "
"사용될 수 있습니다. 베이스 필터 클래스는 로거 계층 구조의 특정 지점 아래에 있는 이벤트만 허용합니다. 예를 들어 'A.B'\\로"
" 초기화된 필터는, 로거 'A.B', 'A.B.C', 'A.B.C.D', 'A.B.D' 등이 로그 한 이벤트를 허용하지만, "
"'A.BB', 'B.A.B' 등은 허용하지 않습니다. 빈 문자열을 사용하면 모든 이벤트를 통과시킵니다."

#: ../Doc/library/logging.rst:613
msgid ""
"Returns an instance of the :class:`Filter` class. If *name* is specified,"
" it names a logger which, together with its children, will have its "
"events allowed through the filter. If *name* is the empty string, allows "
"every event."
msgstr ""
":class:`Filter` 클래스의 인스턴스를 반환합니다. *name* 을 제공하면, 필터를 통과하도록 허용할 로거(그 자식들도 "
"포함합니다)의 이름을 지정합니다. *name* 이 빈 문자열이면, 모든 이벤트를 허용합니다."

#: ../Doc/library/logging.rst:620
msgid ""
"Is the specified record to be logged? Returns zero for no, nonzero for "
"yes. If deemed appropriate, the record may be modified in-place by this "
"method."
msgstr ""
"지정된 레코드가 로그 됩니까? 아니라면 0을 반환하고, 그렇다면 0이 아닌 값을 반환합니다. 적절하다고 판단되면, 이 메서드는 해당"
" 레코드를 수정할 수 있습니다."

#: ../Doc/library/logging.rst:624
msgid ""
"Note that filters attached to handlers are consulted before an event is "
"emitted by the handler, whereas filters attached to loggers are consulted"
" whenever an event is logged (using :meth:`debug`, :meth:`info`, etc.), "
"before sending an event to handlers. This means that events which have "
"been generated by descendant loggers will not be filtered by a logger's "
"filter setting, unless the filter has also been applied to those "
"descendant loggers."
msgstr ""
"처리기에 첨부된 필터는 이벤트를 처리기가 출력하기 전에 호출되는 반면, 로거에 첨부된 필터는 이벤트가 로깅될 때마다 "
"(:meth:`debug`, :meth:`info` 등) 처리기로 이벤트를 보내기 전에 호출됩니다. 이는 자손 로거가 만든 "
"이벤트들은, 같은 필터가 자손들에게도 적용되지 않는 한, 로거의 필터 설정으로 필터링 되지 않는다는 것을 뜻합니다."

#: ../Doc/library/logging.rst:631
msgid ""
"You don't actually need to subclass ``Filter``: you can pass any instance"
" which has a ``filter`` method with the same semantics."
msgstr ""
"실제로 ``Filter`` 의 서브 클래스를 만들 필요는 없습니다: 같은 의미가 있는 ``filter`` 메서드를 가진 인스턴스는 "
"무엇이건 전달할 수 있습니다."

#: ../Doc/library/logging.rst:634
msgid ""
"You don't need to create specialized ``Filter`` classes, or use other "
"classes with a ``filter`` method: you can use a function (or other "
"callable) as a filter. The filtering logic will check to see if the "
"filter object has a ``filter`` attribute: if it does, it's assumed to be "
"a ``Filter`` and its :meth:`~Filter.filter` method is called. Otherwise, "
"it's assumed to be a callable and called with the record as the single "
"parameter. The returned value should conform to that returned by "
":meth:`~Filter.filter`."
msgstr ""
"특수한 ``Filter`` 클래스를 만들거나 ``filter`` 메서드를 가진 다른 클래스를 사용할 필요가 없습니다: 함수(또는 "
"다른 콜러블)를 필터로 사용할 수 있습니다. 필터링 로직은 필터 객체가 ``filter`` 어트리뷰트를 가졌는지 확인합니다: 만약 "
"있다면 ``Filter`` 라고 가정하고 :meth:`~Filter.filter` 메서드를 호출합니다. 그렇지 않으면 콜러블이라고 "
"가정하고 레코드를 단일 매개 변수로 호출합니다. 반환된 값은 :meth:`~Filter.filter` 가 반환하는 값과 같은 의미를"
" 지녀야 합니다."

#: ../Doc/library/logging.rst:644
msgid ""
"Although filters are used primarily to filter records based on more "
"sophisticated criteria than levels, they get to see every record which is"
" processed by the handler or logger they're attached to: this can be "
"useful if you want to do things like counting how many records were "
"processed by a particular logger or handler, or adding, changing or "
"removing attributes in the LogRecord being processed. Obviously changing "
"the LogRecord needs to be done with some care, but it does allow the "
"injection of contextual information into logs (see :ref:`filters-"
"contextual`)."
msgstr ""
"필터는 수준보다 정교한 기준에 따라 레코드를 필터링하는 데 주로 사용되지만, 필터가 첨부되는 처리기나 로거에서 처리되는 모든 "
"레코드를 볼 수 있습니다: 이 특성은, 특정 로거나 처리기가 얼마나 많은 레코드를 처리하는지 센다거나, 처리 중인 "
"LogRecord에 어트리뷰트를 추가, 변경, 삭제하려고 할 때 유용합니다. 당연히, LogRecord를 변경하는 것은 주의를 "
"필요로 하는 일이지만, 로그에 문맥 정보를 주입하는 것을 허용합니다 (:ref:`filters-contextual`\\를 보세요)."

#: ../Doc/library/logging.rst:656
msgid "LogRecord Objects"
msgstr "LogRecord 객체"

#: ../Doc/library/logging.rst:658
msgid ""
":class:`LogRecord` instances are created automatically by the "
":class:`Logger` every time something is logged, and can be created "
"manually via :func:`makeLogRecord` (for example, from a pickled event "
"received over the wire)."
msgstr ""
":class:`LogRecord` 인스턴스는 뭔가 로깅 될 때마다 :class:`Logger` 에 의해 자동으로 생성되며, "
":func:`makeLogRecord`\\를 통해 수동으로 생성될 수 있습니다 (예를 들어, 네트워크에서 수신된 피클 된 이벤트의 "
"경우)."

#: ../Doc/library/logging.rst:666
msgid "Contains all the information pertinent to the event being logged."
msgstr "로그 되는 이벤트와 관련된 모든 정보를 담고 있습니다."

#: ../Doc/library/logging.rst:668
msgid ""
"The primary information is passed in :attr:`msg` and :attr:`args`, which "
"are combined using ``msg % args`` to create the :attr:`message` field of "
"the record."
msgstr ""
"주요 정보는 :attr:`msg`\\와 :attr:`args` 로 전달되며, ``msg % args`` 를 사용하여 병합되어 "
"레코드의 :attr:`message` 필드를 만듭니다."

#: ../Doc/library/logging.rst
msgid "Parameters"
msgstr "매개 변수"

#: ../Doc/library/logging.rst:672
msgid ""
"The name of the logger used to log the event represented by this "
"LogRecord. Note that this name will always have this value, even though "
"it may be emitted by a handler attached to a different (ancestor) logger."
msgstr ""
"이 LogRecord가 나타내는 이벤트를 로그 하는데 사용된 로거의 이름. 이 이름은 다른 (조상) 로거에 첨부된 처리기가 "
"출력하더라도 항상 이 값을 갖습니다."

#: ../Doc/library/logging.rst:676
msgid ""
"The numeric level of the logging event (one of DEBUG, INFO etc.) Note "
"that this is converted to *two* attributes of the LogRecord: ``levelno`` "
"for the numeric value and ``levelname`` for the corresponding level name."
msgstr ""
"로깅 이벤트의 숫자 수준 (DEBUG, INFO 등). 이 값은 LogRecord의 *두* 어트리뷰트로 변환됩니다: 숫자 값을 위한"
" ``levelno`` 와 해당 수준 이름을 위한 ``levelname``."

#: ../Doc/library/logging.rst:680
msgid "The full pathname of the source file where the logging call was made."
msgstr "로깅 호출이 발생한 소스 파일의 전체 경로명."

#: ../Doc/library/logging.rst:682
msgid "The line number in the source file where the logging call was made."
msgstr "로깅 호출이 발생한 소스 파일의 행 번호."

#: ../Doc/library/logging.rst:684
msgid ""
"The event description message, possibly a format string with placeholders"
" for variable data."
msgstr "이벤트 설명 메시지. 변수 데이터를 위한 자리 표시자가 있는 포맷 문자열일 수 있습니다."

#: ../Doc/library/logging.rst:686
msgid ""
"Variable data to merge into the *msg* argument to obtain the event "
"description."
msgstr "이벤트 설명을 얻기 위해 *msg* 인자에 병합할 변수 데이터."

#: ../Doc/library/logging.rst:688
msgid ""
"An exception tuple with the current exception information, or ``None`` if"
" no exception information is available."
msgstr "현재의 예외 정보를 가지는 예외 튜플. 예외 정보가 없는 경우는 ``None`` 입니다."

#: ../Doc/library/logging.rst:690
msgid ""
"The name of the function or method from which the logging call was "
"invoked."
msgstr "로깅 호출을 호출한 함수 또는 메서드의 이름."

#: ../Doc/library/logging.rst:692
msgid ""
"A text string representing stack information from the base of the stack "
"in the current thread, up to the logging call."
msgstr "현재 스레드에서 스택의 바닥부터 로깅 호출까지의 스택 정보를 나타내는 텍스트 문자열."

#: ../Doc/library/logging.rst:697
msgid ""
"Returns the message for this :class:`LogRecord` instance after merging "
"any user-supplied arguments with the message. If the user-supplied "
"message argument to the logging call is not a string, :func:`str` is "
"called on it to convert it to a string. This allows use of user-defined "
"classes as messages, whose ``__str__`` method can return the actual "
"format string to be used."
msgstr ""
"사용자가 제공 한 인자를 메시지와 병합한 후, 이 :class:`LogRecord` 인스턴스에 대한 메시지를 반환합니다. 로깅 "
"호출에 제공된 사용자 제공 메시지 인자가 문자열이 아닌 경우, :func:`str` 이 호출되어 문자열로 변환됩니다. 이렇게 해서 "
"사용자 정의 클래스를 메시지로 사용할 수 있도록 하는데, 그 클래스의 ``__str__`` 메서드는 사용할 실제 포맷 문자열을 반환"
" 할 수 있습니다."

#: ../Doc/library/logging.rst:704
msgid ""
"The creation of a ``LogRecord`` has been made more configurable by "
"providing a factory which is used to create the record. The factory can "
"be set using :func:`getLogRecordFactory` and :func:`setLogRecordFactory` "
"(see this for the factory's signature)."
msgstr ""
"레코드를 생성하는 데 사용되는 팩토리를 제공함으로써, ``LogRecord`` 의 생성을 더 구성할 수 있게 만들었습니다. 팩토리는"
" :func:`getLogRecordFactory`\\와 :func:`setLogRecordFactory` (팩토리의 서명은 이곳을"
" 참조하십시오) 를 사용하여 설정할 수 있습니다."

#: ../Doc/library/logging.rst:710
msgid ""
"This functionality can be used to inject your own values into a LogRecord"
" at creation time. You can use the following pattern::"
msgstr "이 기능은 LogRecord 생성 시에 여러분 자신의 값을 주입하는데 사용할 수 있습니다. 다음과 같은 패턴을 사용할 수 있습니다::"

#: ../Doc/library/logging.rst:722
msgid ""
"With this pattern, multiple factories could be chained, and as long as "
"they don't overwrite each other's attributes or unintentionally overwrite"
" the standard attributes listed above, there should be no surprises."
msgstr ""
"이 패턴을 사용하면 여러 팩토리를 체인으로 묶을 수 있으며, 서로의 어트리뷰트를 덮어쓰거나 위에 나열된 표준 어트리뷰트를 실수로 "
"덮어쓰지 않는 한 놀랄만한 일이 일어나지는 않아야 합니다."

#: ../Doc/library/logging.rst:731
msgid "LogRecord attributes"
msgstr "LogRecord 어트리뷰트"

#: ../Doc/library/logging.rst:733
#, python-format
msgid ""
"The LogRecord has a number of attributes, most of which are derived from "
"the parameters to the constructor. (Note that the names do not always "
"correspond exactly between the LogRecord constructor parameters and the "
"LogRecord attributes.) These attributes can be used to merge data from "
"the record into the format string. The following table lists (in "
"alphabetical order) the attribute names, their meanings and the "
"corresponding placeholder in a %-style format string."
msgstr ""
"LogRecord에는 많은 어트리뷰트가 있으며, 대부분 어트리뷰트는 생성자의 매개 변수에서 옵니다. (LogRecord 생성자 매개"
" 변수와 LogRecord 어트리뷰트의 이름이 항상 정확하게 일치하는 것은 아닙니다.) 이러한 어트리뷰트를 사용하여 레코드의 "
"데이터를 포맷 문자열로 병합 할 수 있습니다. 다음 표는 어트리뷰트 이름, 의미와 해당 자리 표시자를 %-스타일 포맷 문자열로 "
"(알파벳 순서로) 나열합니다."

#: ../Doc/library/logging.rst:741
msgid ""
"If you are using {}-formatting (:func:`str.format`), you can use "
"``{attrname}`` as the placeholder in the format string. If you are using "
"$-formatting (:class:`string.Template`), use the form ``${attrname}``. In"
" both cases, of course, replace ``attrname`` with the actual attribute "
"name you want to use."
msgstr ""
"{}-포매팅(:func:`str.format`)을 사용한다면, ``{attrname}`` 을 포맷 문자열의 자리 표시자로 사용할 수"
" 있습니다. $-포매팅(:class:`string.Template`)을 사용하고 있다면, ``${attrname}`` 형식을 "
"사용하십시오. 두 경우 모두, 물론, ``attrname`` 을 사용하려는 실제 어트리뷰트 이름으로 대체하십시오."

#: ../Doc/library/logging.rst:747
msgid ""
"In the case of {}-formatting, you can specify formatting flags by placing"
" them after the attribute name, separated from it with a colon. For "
"example: a placeholder of ``{msecs:03d}`` would format a millisecond "
"value of ``4`` as ``004``. Refer to the :meth:`str.format` documentation "
"for full details on the options available to you."
msgstr ""
"{}-포매팅의 경우, 어트리뷰트 이름 다음에 콜론(:)으로 구분하여 포매팅 플래그를 지정할 수 있습니다. 예를 들어, "
"``{msecs:03d}`` 자리 표시자는 밀리 초 값 ``4`` 를 ``004`` 로 포맷합니다. 사용할 수 있는 옵션에 대한 "
"자세한 내용은 :meth:`str.format` 설명서를 참조하십시오."

#: ../Doc/library/logging.rst:754
msgid "Attribute name"
msgstr "어트리뷰트 이름"

#: ../Doc/library/logging.rst:754 ../Doc/library/logging.rst:1130
msgid "Format"
msgstr "포맷"

#: ../Doc/library/logging.rst:754 ../Doc/library/logging.rst:1130
msgid "Description"
msgstr "설명"

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:756
msgid "args"
msgstr "args"

#: ../Doc/library/logging.rst:756 ../Doc/library/logging.rst:770
#: ../Doc/library/logging.rst:798 ../Doc/library/logging.rst:816
msgid "You shouldn't need to format this yourself."
msgstr "직접 포맷할 필요는 없습니다."

#: ../Doc/library/logging.rst:756
msgid ""
"The tuple of arguments merged into ``msg`` to produce ``message``, or a "
"dict whose values are used for the merge (when there is only one "
"argument, and it is a dictionary)."
msgstr ""
"``message`` 를 생성하기 위해 ``msg`` 에 병합되는 인자의 튜플. 또는 (인자가 하나뿐이고 딕셔너리일 때) 병합을 "
"위해 값이 사용되는 딕셔너리."

#: ../Doc/library/logging.rst:761
msgid "asctime"
msgstr "asctime"

#: ../Doc/library/logging.rst:761
#, python-format
msgid "``%(asctime)s``"
msgstr "``%(asctime)s``"

#: ../Doc/library/logging.rst:761
msgid ""
"Human-readable time when the :class:`LogRecord` was created.  By default "
"this is of the form '2003-07-08 16:49:45,896' (the numbers after the "
"comma are millisecond portion of the time)."
msgstr ""
"사람이 읽을 수 있는, :class:`LogRecord` 가 생성된 시간. 기본적으로 '2003-07-08 16:49:45,896'"
" 형식입니다 (쉼표 뒤의 숫자는 밀리 초 부분입니다)."

#: ../Doc/library/logging.rst:767
msgid "created"
msgstr "created"

#: ../Doc/library/logging.rst:767
#, python-format
msgid "``%(created)f``"
msgstr "``%(created)f``"

#: ../Doc/library/logging.rst:767
msgid ""
"Time when the :class:`LogRecord` was created (as returned by "
":func:`time.time`)."
msgstr ":class:`LogRecord` 가 생성된 시간 (:func:`time.time` 이 반환하는 시간)."

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:770
msgid "exc_info"
msgstr "exc_info"

#: ../Doc/library/logging.rst:770
msgid ""
"Exception tuple (à la ``sys.exc_info``) or, if no exception has occurred,"
" ``None``."
msgstr "예외 튜플 (``sys.exc_info`` 에서 제공) 또는, 예외가 발생하지 않았다면, ``None``."

#: ../Doc/library/logging.rst:773
msgid "filename"
msgstr "filename"

#: ../Doc/library/logging.rst:773
#, python-format
msgid "``%(filename)s``"
msgstr "``%(filename)s``"

#: ../Doc/library/logging.rst:773
msgid "Filename portion of ``pathname``."
msgstr "``pathname`` 의 파일명 부분."

#: ../Doc/library/logging.rst:775
msgid "funcName"
msgstr "funcName"

#: ../Doc/library/logging.rst:775
#, python-format
msgid "``%(funcName)s``"
msgstr "``%(funcName)s``"

#: ../Doc/library/logging.rst:775
msgid "Name of function containing the logging call."
msgstr "로깅 호출을 포함하는 함수의 이름."

#: ../Doc/library/logging.rst:777
msgid "levelname"
msgstr "levelname"

#: ../Doc/library/logging.rst:777
#, python-format
msgid "``%(levelname)s``"
msgstr "``%(levelname)s``"

#: ../Doc/library/logging.rst:777
msgid ""
"Text logging level for the message (``'DEBUG'``, ``'INFO'``, "
"``'WARNING'``, ``'ERROR'``, ``'CRITICAL'``)."
msgstr ""
"메시지의 텍스트 로깅 수준 (``'DEBUG'``, ``'INFO'``, ``'WARNING'``, ``'ERROR'``, "
"``'CRITICAL'``)."

#: ../Doc/library/logging.rst:781
msgid "levelno"
msgstr "levelno"

#: ../Doc/library/logging.rst:781
#, python-format
msgid "``%(levelno)s``"
msgstr "``%(levelno)s``"

#: ../Doc/library/logging.rst:781
msgid ""
"Numeric logging level for the message (:const:`DEBUG`, :const:`INFO`, "
":const:`WARNING`, :const:`ERROR`, :const:`CRITICAL`)."
msgstr ""
"메시지의 숫자 로깅 수준 (:const:`DEBUG`, :const:`INFO`, :const:`WARNING`, "
":const:`ERROR`, :const:`CRITICAL`)."

#: ../Doc/library/logging.rst:786
msgid "lineno"
msgstr "lineno"

#: ../Doc/library/logging.rst:786
#, python-format
msgid "``%(lineno)d``"
msgstr "``%(lineno)d``"

#: ../Doc/library/logging.rst:786
msgid "Source line number where the logging call was issued (if available)."
msgstr "로깅 호출이 일어난 소스 행 번호 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:789
msgid "message"
msgstr "message"

#: ../Doc/library/logging.rst:789
#, python-format
msgid "``%(message)s``"
msgstr "``%(message)s``"

#: ../Doc/library/logging.rst:789
msgid ""
"The logged message, computed as ``msg % args``. This is set when "
":meth:`Formatter.format` is invoked."
msgstr "로그 된 메시지. ``msg % args`` 로 계산됩니다. :meth:`Formatter.format` 이 호출 될 때 설정됩니다."

#: ../Doc/library/logging.rst:793
msgid "module"
msgstr "module"

#: ../Doc/library/logging.rst:793
#, python-format
msgid "``%(module)s``"
msgstr "``%(module)s``"

#: ../Doc/library/logging.rst:793
msgid "Module (name portion of ``filename``)."
msgstr "모듈 (``filename`` 의 이름 부분)."

#: ../Doc/library/logging.rst:795
msgid "msecs"
msgstr "msecs"

#: ../Doc/library/logging.rst:795
#, python-format
msgid "``%(msecs)d``"
msgstr "``%(msecs)d``"

#: ../Doc/library/logging.rst:795
msgid "Millisecond portion of the time when the :class:`LogRecord` was created."
msgstr ":class:`LogRecord` 가 생성된 시간의 밀리 초 부분."

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:798
msgid "msg"
msgstr "msg"

#: ../Doc/library/logging.rst:798
msgid ""
"The format string passed in the original logging call. Merged with "
"``args`` to produce ``message``, or an arbitrary object (see :ref"
":`arbitrary-object-messages`)."
msgstr ""
"원래 로깅 호출에서 전달된 포맷 문자열. ``args`` 와 병합하여 ``message`` 를 만듭니다. 또는 임의의 객체 "
"(:ref:`arbitrary-object-messages` 를 보세요)."

#: ../Doc/library/logging.rst ../Doc/library/logging.rst:803
msgid "name"
msgstr "name"

#: ../Doc/library/logging.rst:803
#, python-format
msgid "``%(name)s``"
msgstr "``%(name)s``"

#: ../Doc/library/logging.rst:803
msgid "Name of the logger used to log the call."
msgstr "로깅 호출에 사용된 로거의 이름."

#: ../Doc/library/logging.rst:805
msgid "pathname"
msgstr "pathname"

#: ../Doc/library/logging.rst:805
#, python-format
msgid "``%(pathname)s``"
msgstr "``%(pathname)s``"

#: ../Doc/library/logging.rst:805
msgid ""
"Full pathname of the source file where the logging call was issued (if "
"available)."
msgstr "로깅 호출이 일어난 소스 파일의 전체 경로명 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:808
msgid "process"
msgstr "process"

#: ../Doc/library/logging.rst:808
#, python-format
msgid "``%(process)d``"
msgstr "``%(process)d``"

#: ../Doc/library/logging.rst:808
msgid "Process ID (if available)."
msgstr "프로세스 ID (사용 가능한 경우)."

#: ../Doc/library/logging.rst:810
msgid "processName"
msgstr "processName"

#: ../Doc/library/logging.rst:810
#, python-format
msgid "``%(processName)s``"
msgstr "``%(processName)s``"

#: ../Doc/library/logging.rst:810
msgid "Process name (if available)."
msgstr "프로세스 이름 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:812
msgid "relativeCreated"
msgstr "relativeCreated"

#: ../Doc/library/logging.rst:812
#, python-format
msgid "``%(relativeCreated)d``"
msgstr "``%(relativeCreated)d``"

#: ../Doc/library/logging.rst:812
msgid ""
"Time in milliseconds when the LogRecord was created, relative to the time"
" the logging module was loaded."
msgstr "logging 모듈이 로드된 시간을 기준으로 LogRecord가 생성된 시간 (밀리 초)."

#: ../Doc/library/logging.rst:816
msgid "stack_info"
msgstr "stack_info"

#: ../Doc/library/logging.rst:816
msgid ""
"Stack frame information (where available) from the bottom of the stack in"
" the current thread, up to and including the stack frame of the logging "
"call which resulted in the creation of this record."
msgstr "현재 스레드의 스택 바닥에서 이 레코드를 생성한 로깅 호출의 스택 프레임까지의 스택 프레임 정보 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:822
msgid "thread"
msgstr "thread"

#: ../Doc/library/logging.rst:822
#, python-format
msgid "``%(thread)d``"
msgstr "``%(thread)d``"

#: ../Doc/library/logging.rst:822
msgid "Thread ID (if available)."
msgstr "스레드 ID (사용 가능한 경우)."

#: ../Doc/library/logging.rst:824
msgid "threadName"
msgstr "threadName"

#: ../Doc/library/logging.rst:824
#, python-format
msgid "``%(threadName)s``"
msgstr "``%(threadName)s``"

#: ../Doc/library/logging.rst:824
msgid "Thread name (if available)."
msgstr "스레드 이름 (사용 가능한 경우)."

#: ../Doc/library/logging.rst:827
msgid "*processName* was added."
msgstr "*processName* 이 추가되었습니다."

#: ../Doc/library/logging.rst:834
msgid "LoggerAdapter Objects"
msgstr "LoggerAdapter 객체"

#: ../Doc/library/logging.rst:836
msgid ""
":class:`LoggerAdapter` instances are used to conveniently pass contextual"
" information into logging calls. For a usage example, see the section on "
":ref:`adding contextual information to your logging output <context-"
"info>`."
msgstr ""
":class:`LoggerAdapter` 인스턴스는 문맥 정보를 로깅 호출에 편리하게 전달하는 데 사용됩니다. 사용 예는, "
":ref:`로그 출력에 문맥 정보 추가 <context-info>` 섹션을 참조하십시오."

#: ../Doc/library/logging.rst:842
msgid ""
"Returns an instance of :class:`LoggerAdapter` initialized with an "
"underlying :class:`Logger` instance and a dict-like object."
msgstr ""
"하부 :class:`Logger` 인스턴스와 딕셔너리 류 객체로 초기화된 :class:`LoggerAdapter` 의 인스턴스를 "
"반환합니다."

#: ../Doc/library/logging.rst:847
msgid ""
"Modifies the message and/or keyword arguments passed to a logging call in"
" order to insert contextual information. This implementation takes the "
"object passed as *extra* to the constructor and adds it to *kwargs* using"
" key 'extra'. The return value is a (*msg*, *kwargs*) tuple which has the"
" (possibly modified) versions of the arguments passed in."
msgstr ""
"문맥 정보를 삽입하기 위해 로깅 호출에 전달된 메시지 와 키워드 인자를 수정합니다. 이 구현은 생성자에 *extra* 로 전달된 "
"객체를 가져와서 'extra' 키를 사용하여 *kwargs* 에 추가합니다. 반환 값은 전달된 인자의 (수정된) 버전을 담은 "
"(*msg*, *kwargs*) 튜플입니다."

#: ../Doc/library/logging.rst:853
msgid ""
"In addition to the above, :class:`LoggerAdapter` supports the following "
"methods of :class:`Logger`: :meth:`~Logger.debug`, :meth:`~Logger.info`, "
":meth:`~Logger.warning`, :meth:`~Logger.error`, "
":meth:`~Logger.exception`, :meth:`~Logger.critical`, :meth:`~Logger.log`,"
" :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, "
":meth:`~Logger.setLevel` and :meth:`~Logger.hasHandlers`. These methods "
"have the same signatures as their counterparts in :class:`Logger`, so you"
" can use the two types of instances interchangeably."
msgstr ""
"위의 것에 더해, :class:`LoggerAdapter` 는 다음과 같은 :class:`Logger` 의 메서드를 지원합니다: "
":meth:`~Logger.debug`, :meth:`~Logger.info`, :meth:`~Logger.warning`, "
":meth:`~Logger.error`, :meth:`~Logger.exception`, "
":meth:`~Logger.critical`, :meth:`~Logger.log`, "
":meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, "
":meth:`~Logger.setLevel`, :meth:`~Logger.hasHandlers`. 이 메서드들은 "
":class:`Logger` 에 있는 것과 똑같은 서명을 가지므로, 두 형의 인스턴스를 바꿔쓸 수 있습니다."

#: ../Doc/library/logging.rst:862
msgid ""
"The :meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, "
":meth:`~Logger.setLevel` and :meth:`~Logger.hasHandlers` methods were "
"added to :class:`LoggerAdapter`.  These methods delegate to the "
"underlying logger."
msgstr ""
":meth:`~Logger.isEnabledFor`, :meth:`~Logger.getEffectiveLevel`, "
":meth:`~Logger.setLevel` 그리고 :meth:`~Logger.hasHandlers` 메서드가 "
":class:`LoggerAdapter` 에 추가되었습니다. 이 메서드는 하부 로거로 위임합니다."

#: ../Doc/library/logging.rst:869
msgid "Thread Safety"
msgstr "스레드 안전성"

#: ../Doc/library/logging.rst:871
msgid ""
"The logging module is intended to be thread-safe without any special work"
" needing to be done by its clients. It achieves this though using "
"threading locks; there is one lock to serialize access to the module's "
"shared data, and each handler also creates a lock to serialize access to "
"its underlying I/O."
msgstr ""
"로깅 모듈은 클라이언트가 특별한 주의를 기울이지 않아도 스레드 안전하도록 만들어졌습니다. 이렇게 하려고 threading 록을 "
"사용합니다; 모듈의 공유 데이터에 대한 액세스를 직렬화하는 록이 하나 있고, 각 처리기 또한 하부 I/O에 대한 액세스를 직렬화하는"
" 록을 만듭니다."

#: ../Doc/library/logging.rst:876
msgid ""
"If you are implementing asynchronous signal handlers using the "
":mod:`signal` module, you may not be able to use logging from within such"
" handlers. This is because lock implementations in the :mod:`threading` "
"module are not always re-entrant, and so cannot be invoked from such "
"signal handlers."
msgstr ""
":mod:`signal` 모듈을 사용하여 비동기 시그널 처리기를 구현한다면, 그 처리기 내에서는 logging을 사용할 수 없을 "
"수도 있습니다. 이는 :mod:`threading` 모듈의 록 구현이 언제나 재진입할 수 있지는 않아서 그러한 시그널 처리기에서 "
"호출할 수 없기 때문입니다."

#: ../Doc/library/logging.rst:883
msgid "Module-Level Functions"
msgstr "모듈 수준 함수"

#: ../Doc/library/logging.rst:885
msgid ""
"In addition to the classes described above, there are a number of module-"
"level functions."
msgstr "위에서 설명한 클래스 외에도 많은 모듈 수준 함수가 있습니다."

#: ../Doc/library/logging.rst:891
msgid ""
"Return a logger with the specified name or, if name is ``None``, return a"
" logger which is the root logger of the hierarchy. If specified, the name"
" is typically a dot-separated hierarchical name like *'a'*, *'a.b'* or "
"*'a.b.c.d'*. Choice of these names is entirely up to the developer who is"
" using logging."
msgstr ""
"지정된 이름(name)의 로거를 돌려주거나, name이 ``None`` 인 경우, 계층의 루트 로거인 로거를 돌려줍니다. 지정된 "
"경우, name은 일반적으로 *'a'*, *'a.b'* 또는 *'a.b.c.d'* 와 같이 점으로 구분된 계층적 이름입니다. 이 "
"이름의 선택은 전적으로 logging을 사용하는 개발자에게 달려 있습니다."

#: ../Doc/library/logging.rst:896
msgid ""
"All calls to this function with a given name return the same logger "
"instance. This means that logger instances never need to be passed "
"between different parts of an application."
msgstr ""
"같은 이름으로 이 함수를 여러 번 호출하면 모두 같은 로거 인스턴스를 반환합니다. 이것은 응용 프로그램의 다른 부분 간에 로거 "
"인스턴스를 전달할 필요가 없다는 것을 뜻합니다."

#: ../Doc/library/logging.rst:903
msgid ""
"Return either the standard :class:`Logger` class, or the last class "
"passed to :func:`setLoggerClass`. This function may be called from within"
" a new class definition, to ensure that installing a customized "
":class:`Logger` class will not undo customizations already applied by "
"other code. For example::"
msgstr ""
"표준 :class:`Logger` 클래스를 반환하거나, :func:`setLoggerClass` 에 전달된 마지막 클래스를 "
"반환합니다. 이 함수는 새 클래스 정의 내에서 호출하여, 사용자 정의 :class:`Logger` 클래스를 설치할 때 다른 코드가 "
"이미 적용한 사용자 정의를 취소하지 않도록 할 수 있습니다. 예를 들면::"

#: ../Doc/library/logging.rst:914
msgid "Return a callable which is used to create a :class:`LogRecord`."
msgstr ":class:`LogRecord` 를 생성하는 데 사용되는 콜러블을 반환합니다."

#: ../Doc/library/logging.rst:916
msgid ""
"This function has been provided, along with :func:`setLogRecordFactory`, "
"to allow developers more control over how the :class:`LogRecord` "
"representing a logging event is constructed."
msgstr ""
"이 함수는 :func:`setLogRecordFactory`\\와 함께 제공되어, 개발자가 로깅 이벤트를 나타내는 "
":class:`LogRecord` 가 만들어지는 방법을 더욱 잘 제어 할 수 있도록 합니다."

#: ../Doc/library/logging.rst:921
msgid ""
"See :func:`setLogRecordFactory` for more information about the how the "
"factory is called."
msgstr "팩토리가 어떻게 호출되는지에 대한 더 자세한 정보는 :func:`setLogRecordFactory`\\를 보세요."

#: ../Doc/library/logging.rst:926
msgid ""
"Logs a message with level :const:`DEBUG` on the root logger. The *msg* is"
" the message format string, and the *args* are the arguments which are "
"merged into *msg* using the string formatting operator. (Note that this "
"means that you can use keywords in the format string, together with a "
"single dictionary argument.)"
msgstr ""
"루트 로거에 수준 :const:`DEBUG` 메시지를 로그 합니다. *msg* 는 메시지 포맷 문자열이고, *args* 는 문자열 "
"포매팅 연산자를 사용하여 *msg* 에 병합되는 인자입니다. (이는 포맷 문자열에 키워드를 사용하고, 인자로 하나의 딕셔너리를 "
"전달할 수 있음을 의미합니다.)"

#: ../Doc/library/logging.rst:931
msgid ""
"There are three keyword arguments in *kwargs* which are inspected: "
"*exc_info* which, if it does not evaluate as false, causes exception "
"information to be added to the logging message. If an exception tuple (in"
" the format returned by :func:`sys.exc_info`) or an exception instance is"
" provided, it is used; otherwise, :func:`sys.exc_info` is called to get "
"the exception information."
msgstr ""
"*kwargs* 에서 검사되는 세 개의 키워드 인자가 있습니다: *exc_info* 가 거짓으로 평가되지 않으면, 로깅 메시지에 "
"예외 정보가 추가됩니다. 예외 튜플(:func:`sys.exc_info` 에 의해 반환되는 형식)이나 예외 인스턴스가 제공되면 "
"사용됩니다; 그렇지 않으면 예외 정보를 얻기 위해 :func:`sys.exc_info` 를 호출합니다."

#: ../Doc/library/logging.rst:957
msgid ""
"The third optional keyword argument is *extra* which can be used to pass "
"a dictionary which is used to populate the __dict__ of the LogRecord "
"created for the logging event with user-defined attributes. These custom "
"attributes can then be used as you like. For example, they could be "
"incorporated into logged messages. For example::"
msgstr ""
"세 번째 선택적 키워드 인자는 *extra* 로, 로깅 이벤트용으로 만들어진 LogRecord의 __dict__ 를 사용자 정의 "
"어트리뷰트로 채우는 데 사용되는 딕셔너리를 전달할 수 있습니다. 이러한 사용자 정의 어트리뷰트는 원하는 대로 사용할 수 있습니다. "
"예를 들어, 로그 메시지에 포함할 수 있습니다. 예를 들면::"

#: ../Doc/library/logging.rst:968
msgid "would print something like:"
msgstr "는 이렇게 인쇄할 것입니다:"

#: ../Doc/library/logging.rst:997
msgid ""
"Logs a message with level :const:`INFO` on the root logger. The arguments"
" are interpreted as for :func:`debug`."
msgstr "루트 로거에 수준 :const:`INFO` 메시지를 로그 합니다. 인자는 :func:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:1003
msgid ""
"Logs a message with level :const:`WARNING` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr "루트 로거에 수준 :const:`WARNING` 메시지를 로그 합니다. 인자는 :func:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:1006
msgid ""
"There is an obsolete function ``warn`` which is functionally identical to"
" ``warning``. As ``warn`` is deprecated, please do not use it - use "
"``warning`` instead."
msgstr ""
"기능적으로 ``warning`` 와 같은, 구식의 ``warn`` 함수가 있습니다. ``warn`` 은 폐지되었으므로 사용하지 "
"마십시오 - 대신 ``warning`` 을 사용하십시오."

#: ../Doc/library/logging.rst:1013
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr "루트 로거에 수준 :const:`ERROR` 메시지를 로그 합니다. 인자는 :func:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:1019
msgid ""
"Logs a message with level :const:`CRITICAL` on the root logger. The "
"arguments are interpreted as for :func:`debug`."
msgstr "루트 로거에 수준 :const:`CRITICAL` 메시지를 로그 합니다. 인자는 :func:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:1025
msgid ""
"Logs a message with level :const:`ERROR` on the root logger. The "
"arguments are interpreted as for :func:`debug`. Exception info is added "
"to the logging message. This function should only be called from an "
"exception handler."
msgstr ""
"루트 로거에 수준 :const:`ERROR` 메시지를 로그 합니다. 인자는 :func:`debug`\\처럼 해석됩니다. 예외 정보가"
" 로깅 메시지에 추가됩니다. 이 메서드는 예외 처리기에서만 호출해야 합니다."

#: ../Doc/library/logging.rst:1031
msgid ""
"Logs a message with level *level* on the root logger. The other arguments"
" are interpreted as for :func:`debug`."
msgstr "루트 로거에 수준 *level* 의 메시지를 로그 합니다. 다른 인자는 :func:`debug`\\처럼 해석됩니다."

#: ../Doc/library/logging.rst:1034
msgid ""
"The above module-level convenience functions, which delegate to the root "
"logger, call :func:`basicConfig` to ensure that at least one handler is "
"available. Because of this, they should *not* be used in threads, in "
"versions of Python earlier than 2.7.1 and 3.2, unless at least one "
"handler has been added to the root logger *before* the threads are "
"started. In earlier versions of Python, due to a thread safety "
"shortcoming in :func:`basicConfig`, this can (under rare circumstances) "
"lead to handlers being added multiple times to the root logger, which can"
" in turn lead to multiple messages for the same event."
msgstr ""
"위의 루트 로거에 위임하는 모듈 수준 편리 함수는 적어도 하나의 처리기를 사용할 수 있도록 :func:`basicConfig`\\를"
" 호출합니다. 이 때문에, 스레드가 시작되기 *전에* 적어도 하나의 처리기가 루트 로거에 추가되지 않는 한, 2.7.1 및 3.2 "
"이전의 파이썬 버전에서는 스레드에서 이 함수들을 사용하지 *않아야* 합니다. 이전 버전의 파이썬에서는, "
":func:`basicConfig` 의 스레드 안전성 결함으로 인해 (드물긴 하지만) 처리기가 루트 로거에 여러 번 추가될 수 "
"있으며, 같은 이벤트가 여러 번 기록되는 것으로 이어질 수 있습니다."

#: ../Doc/library/logging.rst:1046
msgid ""
"Provides an overriding level *lvl* for all loggers which takes precedence"
" over the logger's own level. When the need arises to temporarily "
"throttle logging output down across the whole application, this function "
"can be useful. Its effect is to disable all logging calls of severity "
"*lvl* and below, so that if you call it with a value of INFO, then all "
"INFO and DEBUG events would be discarded, whereas those of severity "
"WARNING and above would be processed according to the logger's effective "
"level. If ``logging.disable(logging.NOTSET)`` is called, it effectively "
"removes this overriding level, so that logging output again depends on "
"the effective levels of individual loggers."
msgstr ""
"모든 로거의 수준을 *lvl* 로 오버라이드합니다. 로거 자체 수준보다 우선합니다. 전체 응용 프로그램에서 로깅 출력을 일시적으로 "
"억제해야 할 필요가 생길 때 이 함수가 유용합니다. 그 효과는 심각도 *lvl* 및 그 밑의 모든 로깅 호출을 무효화시킵니다. "
"따라서 INFO 값으로 호출하면 모든 INFO 및 DEBUG 이벤트는 삭제되지만, WARNING 이상의 심각도는 로거의 유효 수준에"
" 따라 처리됩니다. ``logging.disable(logging.NOTSET)`` 이 호출되면, 이 오버라이딩 수준을 실질적으로 "
"제거하므로, 로깅 출력은 다시 개별 로거의 유효 수준에 따르게 됩니다."

#: ../Doc/library/logging.rst:1057
msgid ""
"Note that if you have defined any custom logging level higher than "
"``CRITICAL`` (this is not recommended), you won't be able to rely on the "
"default value for the *lvl* parameter, but will have to explicitly supply"
" a suitable value."
msgstr ""
"``CRITICAL`` 보다 더 높은 사용자 정의 로깅 수준을 정의했다면 (권장하지 않습니다), *lvl* 매개 변수의 기본값에 "
"의존할 수 없고 적절한 값을 명시적으로 제공해야 합니다."

#: ../Doc/library/logging.rst:1062
msgid ""
"The *lvl* parameter was defaulted to level ``CRITICAL``. See Issue #28524"
" for more information about this change."
msgstr ""
"*lvl* 매개 변수의 기본값은 수준 ``CRITICAL`` 입니다. 이 변경 사항에 대한 자세한 내용은 이슈 #28524를 "
"참조하십시오."

#: ../Doc/library/logging.rst:1068
msgid ""
"Associates level *lvl* with text *levelName* in an internal dictionary, "
"which is used to map numeric levels to a textual representation, for "
"example when a :class:`Formatter` formats a message. This function can "
"also be used to define your own levels. The only constraints are that all"
" levels used must be registered using this function, levels should be "
"positive integers and they should increase in increasing order of "
"severity."
msgstr ""
"내부 딕셔너리에 수준 *lvl* 을 텍스트 *levelName* 과 연결합니다. 이 딕셔너리는 숫자 수준을 텍스트 표현으로 "
"매핑하는데 (예를 들어, :class:`Formatter` 가 메시지를 포매팅할 때) 사용됩니다. 이 기능을 사용해서 여러분 자신의"
" 수준을 정의할 수도 있습니다. 제약 조건은, 사용되는 모든 수준이 이 함수를 사용하여 등록되어야 하고, 수준은 양의 정수이어야 "
"하며, 심각도가 높아질수록 값이 커져야 한다는 것입니다."

#: ../Doc/library/logging.rst:1075
msgid ""
"If you are thinking of defining your own levels, please see the section "
"on :ref:`custom-levels`."
msgstr "자신만의 수준을 정의할 생각이라면 :ref:`custom-levels` 섹션을 보십시오."

#: ../Doc/library/logging.rst:1080
#, python-format
msgid ""
"Returns the textual representation of logging level *lvl*. If the level "
"is one of the predefined levels :const:`CRITICAL`, :const:`ERROR`, "
":const:`WARNING`, :const:`INFO` or :const:`DEBUG` then you get the "
"corresponding string. If you have associated levels with names using "
":func:`addLevelName` then the name you have associated with *lvl* is "
"returned. If a numeric value corresponding to one of the defined levels "
"is passed in, the corresponding string representation is returned. "
"Otherwise, the string 'Level %s' % lvl is returned."
msgstr ""
"로깅 수준 *lvl* 의 텍스트 표현을 반환합니다. 수준이 미리 정의된 수준 :const:`CRITICAL`, "
":const:`ERROR`, :const:`WARNING`, :const:`INFO` 또는 :const:`DEBUG` 중 하나면 "
"해당 문자열을 얻게 됩니다. :func:`addLevelName`\\을 사용하여 수준과 이름을 연관 지었다면, *lvl* 과 연결된"
" 이름이 반환됩니다. 정의된 수준 중 하나에 해당하는 숫자 값이 전달되면, 해당 문자열 표현이 반환됩니다. 그렇지 않으면 문자열 "
"'Level %s' % lvl 이 반환됩니다."

#: ../Doc/library/logging.rst:1088
#, python-format
msgid ""
"Levels are internally integers (as they need to be compared in the "
"logging logic). This function is used to convert between an integer level"
" and the level name displayed in the formatted log output by means of the"
" ``%(levelname)s`` format specifier (see :ref:`logrecord-attributes`)."
msgstr ""
"수준은 (로깅 로직에서 비교해야 하므로) 내부적으로 정수입니다. 이 함수는 장수 수준과 ``%(levelname)s`` 포맷 "
"지정자(:ref:`logrecord-attributes`\\를 보세요)로 포맷된 로그 출력에 표시된 이름 간의 변환에 사용됩니다."

#: ../Doc/library/logging.rst:1093
msgid ""
"In Python versions earlier than 3.4, this function could also be passed a"
" text level, and would return the corresponding numeric value of the "
"level. This undocumented behaviour was considered a mistake, and was "
"removed in Python 3.4, but reinstated in 3.4.2 due to retain backward "
"compatibility."
msgstr ""
"3.4 이전의 파이썬 버전에서, 이 함수로 텍스트 수준을 전달할 수 있고, 해당 수준의 숫자 값을 반환합니다. 이 문서로 만들어지지"
" 않은 동작은 실수로 간주하여, 파이썬 3.4에서 제거되었습니다. 하지만 이전 버전과의 호환성을 유지하기 위해 3.4.2에서 "
"복원되었습니다."

#: ../Doc/library/logging.rst:1101
msgid ""
"Creates and returns a new :class:`LogRecord` instance whose attributes "
"are defined by *attrdict*. This function is useful for taking a pickled "
":class:`LogRecord` attribute dictionary, sent over a socket, and "
"reconstituting it as a :class:`LogRecord` instance at the receiving end."
msgstr ""
"어트리뷰트가 *attrdict* 로 정의된 새로운 :class:`LogRecord` 인스턴스를 만들어서 반환합니다. 이 함수는 피클"
" 된 :class:`LogRecord` 어트리뷰트 딕셔너리를 소켓으로 보내고, 수신 단에서 :class:`LogRecord` "
"인스턴스로 재구성할 때 유용합니다."

#: ../Doc/library/logging.rst:1109
msgid ""
"Does basic configuration for the logging system by creating a "
":class:`StreamHandler` with a default :class:`Formatter` and adding it to"
" the root logger. The functions :func:`debug`, :func:`info`, "
":func:`warning`, :func:`error` and :func:`critical` will call "
":func:`basicConfig` automatically if no handlers are defined for the root"
" logger."
msgstr ""
"기본 :class:`Formatter`\\로 :class:`StreamHandler` 를 생성하고 루트 로거에 추가하여 로깅 "
"시스템의 기본 구성을 수행합니다. 함수 :func:`debug`, :func:`info`, :func:`warning`, "
":func:`error` 그리고 :func:`critical`\\은 루트 로거에 처리기가 정의되어 있지 않으면 자동으로 "
":func:`basicConfig`\\를 호출합니다."

#: ../Doc/library/logging.rst:1115
msgid ""
"This function does nothing if the root logger already has handlers "
"configured for it."
msgstr "이 함수는 루트 로거에 이미 처리기가 구성되어있는 경우 아무 작업도 수행하지 않습니다."

#: ../Doc/library/logging.rst:1118
msgid ""
"This function should be called from the main thread before other threads "
"are started. In versions of Python prior to 2.7.1 and 3.2, if this "
"function is called from multiple threads, it is possible (in rare "
"circumstances) that a handler will be added to the root logger more than "
"once, leading to unexpected results such as messages being duplicated in "
"the log."
msgstr ""
"이 함수는 다른 스레드가 시작되기 전에 메인 스레드에서 호출되어야 합니다. 2.7.1과 3.2 이전의 파이썬 버전에서, 이 함수를 "
"여러 스레드에서 호출하면, (드문 경우지만) 처리기가 두 번 이상 루트 로거에 추가되어, 로그에 메시지가 중복되는 것과 같은 예기치"
" 않은 결과가 발생할 수 있습니다."

#: ../Doc/library/logging.rst:1125
msgid "The following keyword arguments are supported."
msgstr "다음 키워드 인자가 지원됩니다."

#: ../Doc/library/logging.rst:1132
msgid "*filename*"
msgstr "*filename*"

#: ../Doc/library/logging.rst:1132
msgid ""
"Specifies that a FileHandler be created, using the specified filename, "
"rather than a StreamHandler."
msgstr "StreamHandler 대신 지정된 파일명을 사용해 FileHandler를 만들도록 지정합니다."

#: ../Doc/library/logging.rst:1136
msgid "*filemode*"
msgstr "*filemode*"

#: ../Doc/library/logging.rst:1136
msgid ""
"If *filename* is specified, open the file in this :ref:`mode "
"<filemodes>`. Defaults to ``'a'``."
msgstr "*filename* 이 지정되었으면, 이 :ref:`모드 <filemodes>` 로 파일을 엽니다. 기본값은 ``'a'`` 입니다."

#: ../Doc/library/logging.rst:1140
msgid "*format*"
msgstr "*format*"

#: ../Doc/library/logging.rst:1140
msgid "Use the specified format string for the handler."
msgstr "처리기에 지정된 포맷 문자열을 사용합니다."

#: ../Doc/library/logging.rst:1143
msgid "*datefmt*"
msgstr "*datefmt*"

#: ../Doc/library/logging.rst:1143
msgid "Use the specified date/time format, as accepted by :func:`time.strftime`."
msgstr ":func:`time.strftime` 에서 허용하는 방식대로 지정된 날짜/시간 포맷을 사용합니다."

#: ../Doc/library/logging.rst:1146
msgid "*style*"
msgstr "*style*"

#: ../Doc/library/logging.rst:1146
msgid ""
"If *format* is specified, use this style for the format string. One of "
"``'%'``, ``'{'`` or ``'$'`` for :ref:`printf-style <old-string-"
"formatting>`, :meth:`str.format` or :class:`string.Template` "
"respectively. Defaults to ``'%'``."
msgstr ""
"*format* 을 지정하면, 포맷 문자열에 이 스타일을 사용합니다. ``'%'``, ``'{'``, ``'$'`` 중 하나인데 "
"각각 :ref:`printf 스타일 <old-string-formatting>`, :meth:`str.format`, "
":class:`string.Template` 에 대응됩니다. 기본값은 ``'%'`` 입니다."

#: ../Doc/library/logging.rst:1154
msgid "*level*"
msgstr "*level*"

#: ../Doc/library/logging.rst:1154
msgid "Set the root logger level to the specified :ref:`level <levels>`."
msgstr "루트 로거의 수준을 지정된 :ref:`수준 <levels>` 으로 설정합니다."

#: ../Doc/library/logging.rst:1157
msgid "*stream*"
msgstr "*stream*"

#: ../Doc/library/logging.rst:1157
msgid ""
"Use the specified stream to initialize the StreamHandler. Note that this "
"argument is incompatible with *filename* - if both are present, a "
"``ValueError`` is raised."
msgstr ""
"StreamHandler의 초기화에 지정된 스트림을 사용합니다. 이 인자는 *filename* 과 호환되지 않습니다 - 둘 다 "
"있으면 ``ValueError`` 가 발생합니다."

#: ../Doc/library/logging.rst:1162
msgid "*handlers*"
msgstr "*handlers*"

#: ../Doc/library/logging.rst:1162
msgid ""
"If specified, this should be an iterable of already created handlers to "
"add to the root logger. Any handlers which don't already have a formatter"
" set will be assigned the default formatter created in this function. "
"Note that this argument is incompatible with *filename* or *stream* - if "
"both are present, a ``ValueError`` is raised."
msgstr ""
"지정된 경우, 루트 로거에 추가할 이미 만들어진 처리기의 이터러블이어야 합니다. 아직 포매터 세트가 없는 처리기에는 이 함수에서 "
"만들어진 기본 포매터가 지정됩니다. 이 인자는 *filename* 또는 *stream* 과 호환되지 않습니다 - 둘 다 있으면 "
"``ValueError`` 가 발생합니다."

#: ../Doc/library/logging.rst:1172
msgid "The *style* argument was added."
msgstr "*style* 인자가 추가되었습니다."

#: ../Doc/library/logging.rst:1175
msgid ""
"The *handlers* argument was added. Additional checks were added to catch "
"situations where incompatible arguments are specified (e.g. *handlers* "
"together with *stream* or *filename*, or *stream* together with "
"*filename*)."
msgstr ""
"*handlers* 인자가 추가되었습니다. 호환되지 않는 인자(예를 들어, *handlers* 를 *stream* 이나 "
"*filename* 과 함께 쓰거나, *stream* 을 *filename* 과 함께 쓰는 경우)가 있는 상황을 파악하기 위한 "
"검사가 추가되었습니다."

#: ../Doc/library/logging.rst:1183
msgid ""
"Informs the logging system to perform an orderly shutdown by flushing and"
" closing all handlers. This should be called at application exit and no "
"further use of the logging system should be made after this call."
msgstr ""
"로깅 시스템에 모든 처리기를 플러시하고 닫아서 순차적인 종료를 수행하도록 알립니다. 응용 프로그램 종료 시 호출되어야 하고, 이 "
"호출 후에는 로깅 시스템을 더는 사용하지 않아야 합니다."

#: ../Doc/library/logging.rst:1190
msgid ""
"Tells the logging system to use the class *klass* when instantiating a "
"logger. The class should define :meth:`__init__` such that only a name "
"argument is required, and the :meth:`__init__` should call "
":meth:`Logger.__init__`. This function is typically called before any "
"loggers are instantiated by applications which need to use custom logger "
"behavior."
msgstr ""
"로거의 인스턴스를 만들 때 *klass* 클래스를 사용하도록 로깅 시스템에 지시합니다. 클래스는 :meth:`__init__` 을 "
"정의해야 하는데, name만 필수 인자로 요구하고, :meth:`__init__` 는 :meth:`Logger.__init__` 을"
" 호출해야 합니다. 이 함수는 일반적으로 사용자 정의된 로거 동작이 필요한 응용 프로그램에서 로거의 인스턴스가 만들어지기 전에 "
"호출됩니다."

#: ../Doc/library/logging.rst:1199
msgid "Set a callable which is used to create a :class:`LogRecord`."
msgstr ":class:`LogRecord` 를 만드는데 사용되는 콜러블을 설정합니다."

#: ../Doc/library/logging.rst:1201
msgid "The factory callable to be used to instantiate a log record."
msgstr "로그 레코드의 인스턴스를 만드는데 사용되는 팩토리 콜러블."

#: ../Doc/library/logging.rst:1203
msgid ""
"This function has been provided, along with :func:`getLogRecordFactory`, "
"to allow developers more control over how the :class:`LogRecord` "
"representing a logging event is constructed."
msgstr ""
"이 함수는 :func:`getLogRecordFactory`\\와 함께 제공되어, 개발자가 로깅 이벤트를 나타내는 "
":class:`LogRecord` 가 만들어지는 방법을 더욱 잘 제어 할 수 있도록 합니다."

#: ../Doc/library/logging.rst:1208
msgid "The factory has the following signature:"
msgstr "팩토리의 서명은 다음과 같습니다:"

#: ../Doc/library/logging.rst:1210
msgid ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, "
"sinfo=None, **kwargs)``"
msgstr ""
"``factory(name, level, fn, lno, msg, args, exc_info, func=None, "
"sinfo=None, **kwargs)``"

#: ../Doc/library/logging.rst:1212
msgid "The logger name."
msgstr "로거 이름."

#: ../Doc/library/logging.rst
msgid "level"
msgstr "level"

#: ../Doc/library/logging.rst:1213
msgid "The logging level (numeric)."
msgstr "로깅 수준 (숫자)."

#: ../Doc/library/logging.rst
msgid "fn"
msgstr "fn"

#: ../Doc/library/logging.rst:1214
msgid "The full pathname of the file where the logging call was made."
msgstr "로깅 호출이 이루어진 파일의 전체 경로명."

#: ../Doc/library/logging.rst
msgid "lno"
msgstr "lno"

#: ../Doc/library/logging.rst:1215
msgid "The line number in the file where the logging call was made."
msgstr "로깅 호출이 이루어진 파일의 행 번호."

#: ../Doc/library/logging.rst:1216
msgid "The logging message."
msgstr "로깅 메시지"

#: ../Doc/library/logging.rst:1217
msgid "The arguments for the logging message."
msgstr "로깅 메시지에 대한 인자."

#: ../Doc/library/logging.rst:1218
msgid "An exception tuple, or ``None``."
msgstr "예외 튜플 또는 ``None``."

#: ../Doc/library/logging.rst
msgid "func"
msgstr "func"

#: ../Doc/library/logging.rst:1219
msgid "The name of the function or method which invoked the logging call."
msgstr "로깅 호출을 호출한 함수 또는 메서드의 이름"

#: ../Doc/library/logging.rst
msgid "sinfo"
msgstr "sinfo"

#: ../Doc/library/logging.rst:1221
msgid ""
"A stack traceback such as is provided by :func:`traceback.print_stack`, "
"showing the call hierarchy."
msgstr ":func:`traceback.print_stack` 가 제공하는 것과 같은 스택 트레이스백. 호출 계층 구조를 보여줍니다."

#: ../Doc/library/logging.rst
msgid "kwargs"
msgstr "kwargs"

#: ../Doc/library/logging.rst:1223
msgid "Additional keyword arguments."
msgstr "추가 키워드 인자."

#: ../Doc/library/logging.rst:1227
msgid "Module-Level Attributes"
msgstr "모듈 수준 어트리뷰트"

#: ../Doc/library/logging.rst:1231
msgid ""
"A \"handler of last resort\" is available through this attribute. This is"
" a :class:`StreamHandler` writing to ``sys.stderr`` with a level of "
"``WARNING``, and is used to handle logging events in the absence of any "
"logging configuration. The end result is to just print the message to "
"``sys.stderr``. This replaces the earlier error message saying that \"no "
"handlers could be found for logger XYZ\". If you need the earlier "
"behaviour for some reason, ``lastResort`` can be set to ``None``."
msgstr ""
"\"최후 수단 처리기\" 는 이 어트리뷰트를 통해 제공됩니다. 이것은 ``WARNING`` 수준으로 ``sys.stderr`` 에 "
"쓰는 :class:`StreamHandler` 이고, 로깅 구성이 없을 때 로깅 이벤트를 처리하는 데 사용됩니다. 최종 결과는 "
"``sys.stderr`` 에 메시지를 출력하기만 하는 것입니다. 이것이 예전의 \"no handlers could be found"
" for logger XYZ\" 라는 에러 메시지를 대체합니다. 어떤 이유로 이전 동작이 필요하면 ``lastResort`` 를 "
"``None`` 으로 설정할 수 있습니다."

#: ../Doc/library/logging.rst:1242
msgid "Integration with the warnings module"
msgstr "warnings 모듈과의 통합"

#: ../Doc/library/logging.rst:1244
msgid ""
"The :func:`captureWarnings` function can be used to integrate "
":mod:`logging` with the :mod:`warnings` module."
msgstr ""
":func:`captureWarnings` 함수는 :mod:`logging`\\을 :mod:`warnings` 모듈과 통합하는데 "
"사용될 수 있습니다."

#: ../Doc/library/logging.rst:1249
msgid ""
"This function is used to turn the capture of warnings by logging on and "
"off."
msgstr "이 함수는 logging 이 경고를 캡처하는 것을 켜고 끄는 데 사용됩니다."

#: ../Doc/library/logging.rst:1252
msgid ""
"If *capture* is ``True``, warnings issued by the :mod:`warnings` module "
"will be redirected to the logging system. Specifically, a warning will be"
" formatted using :func:`warnings.formatwarning` and the resulting string "
"logged to a logger named ``'py.warnings'`` with a severity of "
":const:`WARNING`."
msgstr ""
"*capture* 가 ``True`` 면, :mod:`warnings` 모듈에 의해 발행된 경고는 로깅 시스템으로 리디렉션됩니다. "
"특히, 경고는 :func:`warnings.formatwarning` 을 사용하여 포맷되고, 결과 문자열을 "
"``'py.warnings'`` 라는 이름의 로거에 심각도 :const:`WARNING`\\으로 로그 합니다."

#: ../Doc/library/logging.rst:1257
msgid ""
"If *capture* is ``False``, the redirection of warnings to the logging "
"system will stop, and warnings will be redirected to their original "
"destinations (i.e. those in effect before ``captureWarnings(True)`` was "
"called)."
msgstr ""
"*capture* 가 ``False`` 면, 로깅 시스템으로의 경고 리디렉션은 멈추고, 경고는 원래 목적지(즉, "
"``captureWarnings(True)`` 가 호출되기 전에 적용되던 곳)로 리디렉션됩니다."

#: ../Doc/library/logging.rst:1265
msgid "Module :mod:`logging.config`"
msgstr "모듈 :mod:`logging.config`"

#: ../Doc/library/logging.rst:1265
msgid "Configuration API for the logging module."
msgstr "logging 모듈용 구성 API."

#: ../Doc/library/logging.rst:1268
msgid "Module :mod:`logging.handlers`"
msgstr "모듈 :mod:`logging.handlers`"

#: ../Doc/library/logging.rst:1268
msgid "Useful handlers included with the logging module."
msgstr "logging 모듈에 포함된 유용한 처리기."

#: ../Doc/library/logging.rst:1272
msgid ":pep:`282` - A Logging System"
msgstr ":pep:`282` - 로깅 시스템"

#: ../Doc/library/logging.rst:1271
msgid ""
"The proposal which described this feature for inclusion in the Python "
"standard library."
msgstr "파이썬 표준 라이브러리에 포함하기 위해 이 기능을 설명한 제안."

#: ../Doc/library/logging.rst:1277
msgid ""
"`Original Python logging package <https://www.red-"
"dove.com/python_logging.html>`_"
msgstr "`원본 파이썬 로깅 패키지 <https://www.red-dove.com/python_logging.html>`_"

#: ../Doc/library/logging.rst:1275
msgid ""
"This is the original source for the :mod:`logging` package.  The version "
"of the package available from this site is suitable for use with Python "
"1.5.2, 2.1.x and 2.2.x, which do not include the :mod:`logging` package "
"in the standard library."
msgstr ""
":mod:`logging` 패키지의 원래 소스입니다. 이 사이트에서 제공되는 패키지 버전은 표준 라이브러리에 "
":mod:`logging` 패키지를 포함하지 않는 파이썬 1.5.2, 2.1.x 및 2.2.x에서 사용하기에 적합합니다."

