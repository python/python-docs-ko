# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-12 08:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Hyukhoon Kwon <unace2u@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/unittest.rst:2
msgid ":mod:`unittest` --- Unit testing framework"
msgstr ":mod:`unittest` --- 단위 테스트 프레임워크"

#: ../Doc/library/unittest.rst:12
msgid "**Source code:** :source:`Lib/unittest/__init__.py`"
msgstr "**소스 코드:** :source:`Lib/unittest/__init__.py`"

#: ../Doc/library/unittest.rst:16
msgid ""
"(If you are already familiar with the basic concepts of testing, you "
"might want to skip to :ref:`the list of assert methods <assert-"
"methods>`.)"
msgstr ""
"(당신이 이미 테스트 기본 개념에 친숙하다면, :ref:`assert 메서드 목록 <assert-methods>`\\으로 건너뛰어도"
" 좋습니다.)"

#: ../Doc/library/unittest.rst:19
msgid ""
"The :mod:`unittest` unit testing framework was originally inspired by "
"JUnit and has a similar flavor as major unit testing frameworks in other "
"languages.  It supports test automation, sharing of setup and shutdown "
"code for tests, aggregation of tests into collections, and independence "
"of the tests from the reporting framework."
msgstr ""
":mod:`unittest` 단위 테스트 프레임워크는 본래 JUnit으로부터 영감을 받고 다른 언어의 주요 단위 테스트 프레임워크와"
" 비슷한 특징을 가지고 있습니다. 이것은 테스트 자동화, 테스트를 위한 사전 설정(setup)과 종료(shutdown) 코드 공유,"
" 테스트를 컬렉션에 종합하기, 테스트와 리포트 프레임워크의 분리 등을 지원합니다."

#: ../Doc/library/unittest.rst:25
msgid ""
"To achieve this, :mod:`unittest` supports some important concepts in an "
"object-oriented way:"
msgstr "이를 달성하기 위해 :mod:`unittest`\\는 객체 지향적인 방법으로 몇 가지 중요한 개념을 지원합니다."

#: ../Doc/library/unittest.rst:32
msgid "test fixture"
msgstr "테스트 픽스쳐"

#: ../Doc/library/unittest.rst:29
msgid ""
"A :dfn:`test fixture` represents the preparation needed to perform one or"
" more tests, and any associated cleanup actions.  This may involve, for "
"example, creating temporary or proxy databases, directories, or starting "
"a server process."
msgstr ""
":dfn:`테스트 픽스쳐 (test fixture)`\\는 1개 또는 그 이상의 테스트를 수행할 때 필요한 준비와 그와 관련된 정리"
" 동작에 해당합니다. 예를 들어 이것은 임시 또는 프락시 데이터베이스, 디렉터리를 생성하거나 서버 프로세스를 시작하는 것 등을 "
"포함합니다."

#: ../Doc/library/unittest.rst:37
msgid "test case"
msgstr "테스트 케이스"

#: ../Doc/library/unittest.rst:35
msgid ""
"A :dfn:`test case` is the individual unit of testing.  It checks for a "
"specific response to a particular set of inputs.  :mod:`unittest` "
"provides a base class, :class:`TestCase`, which may be used to create new"
" test cases."
msgstr ""
":dfn:`테스트 케이스(test case)`\\는 테스트의 개별 단위입니다. 이것은 특정한 입력 모음에 대해서 특정한 결과를 "
"확인합니다. :mod:`unittest`\\는 베이스 클래스인 :class:`TestCase`\\를 지원합니다. 이 클래스는 새로운"
" 테스트 케이스를 만드는 데 사용됩니다."

#: ../Doc/library/unittest.rst:41
msgid "test suite"
msgstr "테스트 묶음"

#: ../Doc/library/unittest.rst:40
msgid ""
"A :dfn:`test suite` is a collection of test cases, test suites, or both."
"  It is used to aggregate tests that should be executed together."
msgstr ""
":dfn:`테스트 묶음(test suite)`\\은 여러 테스트 케이스, 테스트 묶음, 또는 둘 다의 모임입니다. 이것은 서로 같이"
" 실행되어야 할 테스트들을 종합하는 데 사용됩니다."

#: ../Doc/library/unittest.rst:48
msgid "test runner"
msgstr "테스트 실행자"

#: ../Doc/library/unittest.rst:44
msgid ""
"A :dfn:`test runner` is a component which orchestrates the execution of "
"tests and provides the outcome to the user.  The runner may use a "
"graphical interface, a textual interface, or return a special value to "
"indicate the results of executing the tests."
msgstr ""
":dfn:`테스트 실행자(test runner)`\\는 테스트 실행을 조율하고 테스트 결과를 사용자에게 제공하는 역할을 하는 "
"컴포넌트입니다. 실행자는 테스트 실행 결과를 보여주기 위해 그래픽 인터페이스, 텍스트 인터페이스를 사용하거나 특별한 값을 반환할 "
"수도 있습니다. "

#: ../Doc/library/unittest.rst:53
msgid "Module :mod:`doctest`"
msgstr ":mod:`doctest` 모듈"

#: ../Doc/library/unittest.rst:53
msgid "Another test-support module with a very different flavor."
msgstr "매우 다른 특징을 가지고 있는 또 다른 테스트 지원 모듈"

#: ../Doc/library/unittest.rst:57
msgid ""
"`Simple Smalltalk Testing: With Patterns "
"<https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"
msgstr ""
"`Simple Smalltalk Testing: With Patterns "
"<https://web.archive.org/web/20150315073817/http://www.xprogramming.com/testfram.htm>`_"

#: ../Doc/library/unittest.rst:56
msgid ""
"Kent Beck's original paper on testing frameworks using the pattern shared"
" by :mod:`unittest`."
msgstr ":mod:`unittest`\\에 영향을 준 Kent Beck의 패턴을 사용한 테스트 프레임워크 원본 논문"

#: ../Doc/library/unittest.rst:61
msgid "`pytest <https://docs.pytest.org/>`_"
msgstr "`pytest <https://docs.pytest.org/>`_"

#: ../Doc/library/unittest.rst:60
msgid ""
"Third-party unittest framework with a lighter-weight syntax for writing "
"tests.  For example, ``assert func(10) == 42``."
msgstr ""
"테스트를 작성하기에 간편한 문법을 가지고 있는 제삼자의 단위 테스트 프레임워크. 예시, ``assert func(10) == "
"42``."

#: ../Doc/library/unittest.rst:65
msgid ""
"`The Python Testing Tools Taxonomy "
"<https://wiki.python.org/moin/PythonTestingToolsTaxonomy>`_"
msgstr "`파이썬 테스트 도구 분류 <https://wiki.python.org/moin/PythonTestingToolsTaxonomy>`_"

#: ../Doc/library/unittest.rst:64
msgid ""
"An extensive list of Python testing tools including functional testing "
"frameworks and mock object libraries."
msgstr "함수형 테스트 프레임워크와 모의 객체 라이브러리를 포함한 광범위한 파이썬 테스트 도구 목록"

#: ../Doc/library/unittest.rst:69
msgid ""
"`Testing in Python Mailing List <http://lists.idyll.org/listinfo/testing-"
"in-python>`_"
msgstr ""
"`Testing in Python 메일링 리스트 <http://lists.idyll.org/listinfo/testing-in-"
"python>`_"

#: ../Doc/library/unittest.rst:68
msgid ""
"A special-interest-group for discussion of testing, and testing tools, in"
" Python."
msgstr "파이썬에서 테스트하기와 테스트 도구에 대해 논의하는 특정-주제-그룹(special-interest-group)"

#: ../Doc/library/unittest.rst:71
msgid ""
"The script :file:`Tools/unittestgui/unittestgui.py` in the Python source "
"distribution is a GUI tool for test discovery and execution.  This is "
"intended largely for ease of use for those new to unit testing.  For "
"production environments it is recommended that tests be driven by a "
"continuous integration system such as `Buildbot "
"<https://buildbot.net/>`_, `Jenkins <https://jenkins.io/>`_ or `Travis-CI"
" <https://travis-ci.com>`_, or `AppVeyor <https://www.appveyor.com/>`_."
msgstr ""
"파이썬 소스 배포판에 있는 :file:`Tools/unittestgui/unittestgui.py` 스크립트는 테스트 탐색 및 "
"실행을 위한 GUI 도구입니다. 이것은 단위 테스트가 처음인 사람들이 쉽게 사용할 수 있도록 만들어졌습니다. 라이브 환경에서는 "
"`Buildbot <https://buildbot.net/>`_, `Jenkins <https://jenkins.io/>`_, "
"`Travis-CI <https://travis-ci.com>`_ 또는  `AppVeyor "
"<https://www.appveyor.com/>`_\\와 같은 지속적인 통합 시스템을 이용하여 테스트가 이루어지길 추천합니다."

#: ../Doc/library/unittest.rst:82
msgid "Basic example"
msgstr "기본 예시"

#: ../Doc/library/unittest.rst:84
msgid ""
"The :mod:`unittest` module provides a rich set of tools for constructing "
"and running tests.  This section demonstrates that a small subset of the "
"tools suffice to meet the needs of most users."
msgstr ""
":mod:`unittest` 모듈은 테스트를 구성하고 실행하는 데 풍부한 도구 모음을 제공하고 있습니다. 이 절에서는 대부분 "
"사용자의 요구를 충족시키기 위해 일부 도구 모음만으로도 충분하다는 것을 보여줍니다."

#: ../Doc/library/unittest.rst:88
msgid "Here is a short script to test three string methods::"
msgstr "문자열 관련된 3개의 메서드를 테스트하기 위한 짧은 스크립트가 여기에 있습니다::"

#: ../Doc/library/unittest.rst:112
msgid ""
"A testcase is created by subclassing :class:`unittest.TestCase`.  The "
"three individual tests are defined with methods whose names start with "
"the letters ``test``.  This naming convention informs the test runner "
"about which methods represent tests."
msgstr ""
"테스트 케이스는 :class:`unittest.TestCase`\\를 서브 클래스 해서 생성하였습니다. 각각 3개의 테스트는 "
"``test`` 글자로 시작하는 이름을 가진 메서드로 정의했습니다. 이 명명 규칙은 테스트 실행자가 어떤 메서드가 테스트인지 알게 "
"해줍니다."

#: ../Doc/library/unittest.rst:117
msgid ""
"The crux of each test is a call to :meth:`~TestCase.assertEqual` to check"
" for an expected result; :meth:`~TestCase.assertTrue` or "
":meth:`~TestCase.assertFalse` to verify a condition; or "
":meth:`~TestCase.assertRaises` to verify that a specific exception gets "
"raised.  These methods are used instead of the :keyword:`assert` "
"statement so the test runner can accumulate all test results and produce "
"a report."
msgstr ""
"각 테스트의 핵심은 기대되는 결과를 확인하기 위해 :meth:`~TestCase.assertEqual`\\를 호출, 조건을 검증하기"
" 위해 :meth:`~TestCase.assertTrue` 또는 :meth:`~TestCase.assertFalse`\\를 호출, "
"특정 예외가 발생했는지 검증하기 위해 :meth:`~TestCase.assertRaises`\\를 호출하는 것입니다. "
":keyword:`assert` 문장을 대신하여 이 메서드들을 사용하면 테스트 실행자가 모든 테스트 결과를 취합하여 리포트를 생성할"
" 수 있습니다."

#: ../Doc/library/unittest.rst:124
msgid ""
"The :meth:`~TestCase.setUp` and :meth:`~TestCase.tearDown` methods allow "
"you to define instructions that will be executed before and after each "
"test method. They are covered in more detail in the section :ref"
":`organizing-tests`."
msgstr ""
":meth:`~TestCase.setUp`\\과 :meth:`~TestCase.tearDown` 메서드로 각각의 테스트 메서드 전과"
" 후에 실행될 명령어를 정의할 수 있습니다. :ref:`organizing-tests`\\에서 이것을 더 자세히 다루겠습니다."

#: ../Doc/library/unittest.rst:128
msgid ""
"The final block shows a simple way to run the tests. "
":func:`unittest.main` provides a command-line interface to the test "
"script.  When run from the command line, the above script produces an "
"output that looks like this::"
msgstr ""
"마지막 블록은 테스트를 실행하는 간단한 방법을 보여줍니다. :func:`unittest.main`\\은 테스트 스크립트에 명령행 "
"인터페이스를 제공합니다. 명령행에서 위 스크립트를 실행하면, 다음과 같은 출력이 나옵니다::"

#: ../Doc/library/unittest.rst:138
msgid ""
"Passing the ``-v`` option to your test script will instruct "
":func:`unittest.main` to enable a higher level of verbosity, and produce "
"the following output::"
msgstr ""
"``-v`` 옵션을 테스트 스크립트에 넘겨주게 되면 :func:`unittest.main`\\은 높은 상세도(verbosity)를 "
"설정하여 그에 따른 출력이 나옵니다::"

#: ../Doc/library/unittest.rst:150
msgid ""
"The above examples show the most commonly used :mod:`unittest` features "
"which are sufficient to meet many everyday testing needs.  The remainder "
"of the documentation explores the full feature set from first principles."
msgstr ""
"위의 예시는 :mod:`unittest`\\에서 가장 자주 사용되는 기능을 보여주며 이것은 많은 일상적인 테스트 요구 사항을 "
"충족시키기에 충분합니다. 문서의 나머지 부분은 기초부터 시작해서 모든 기능을 살펴봅니다."

#: ../Doc/library/unittest.rst:158
msgid "Command-Line Interface"
msgstr "명령행 인터페이스"

#: ../Doc/library/unittest.rst:160
msgid ""
"The unittest module can be used from the command line to run tests from "
"modules, classes or even individual test methods::"
msgstr "unittest 모듈은 명령행을 사용하여 모듈, 클래스, 심지어 각 테스트 메서드의 테스트들을 실행할 수 있습니다::"

#: ../Doc/library/unittest.rst:167
msgid ""
"You can pass in a list with any combination of module names, and fully "
"qualified class or method names."
msgstr "모듈 이름이나 완전히 정규화된 클래스나 메서드 이름이 포함된 목록을 전달할 수 있습니다."

#: ../Doc/library/unittest.rst:170
msgid "Test modules can be specified by file path as well::"
msgstr "테스트 모듈은 파일 경로로도 지정할 수 있습니다::"

#: ../Doc/library/unittest.rst:174
msgid ""
"This allows you to use the shell filename completion to specify the test "
"module. The file specified must still be importable as a module. The path"
" is converted to a module name by removing the '.py' and converting path "
"separators into '.'. If you want to execute a test file that isn't "
"importable as a module you should execute the file directly instead."
msgstr ""
"이것으로 테스트 모듈을 지정할 때 셸(shell)의 파일 이름 완성 기능을 사용할 수 있습니다. 지정된 파일은 반드시 모듈로 임포트"
" 가능해야 합니다. 파일 경로는 '.py' 가 빠지면서 모듈 이름으로 변경되고 경로 구분자도 '.'로 변경됩니다. 만약 당신이 "
"임포트 가능하지 않은 테스트 파일을 모듈로 사용하고 싶으시다면 이 방법 대신에 그 파일을 직접 실행해야 합니다."

#: ../Doc/library/unittest.rst:180
msgid ""
"You can run tests with more detail (higher verbosity) by passing in the "
"-v flag::"
msgstr "-v 옵션을 사용하여 더 자세한 정보(높은 상세도)로 테스트를 실행할 수 있습니다::"

#: ../Doc/library/unittest.rst:184
msgid ""
"When executed without arguments :ref:`unittest-test-discovery` is "
"started::"
msgstr "아무 인자 없이 실행하면 :ref:`unittest-test-discovery`\\이 실행됩니다::"

#: ../Doc/library/unittest.rst:188
msgid "For a list of all the command-line options::"
msgstr "모든 명령행 옵션 목록을 보기::"

#: ../Doc/library/unittest.rst:192
msgid ""
"In earlier versions it was only possible to run individual test methods "
"and not modules or classes."
msgstr "이전 버전에서는 개별 테스트 메서드만 실행이 가능했고, 모듈과 클래스는 불가능했습니다."

#: ../Doc/library/unittest.rst:198
msgid "Command-line options"
msgstr "명령행 옵션"

#: ../Doc/library/unittest.rst:200
msgid ":program:`unittest` supports these command-line options:"
msgstr ":program:`unittest`\\는 다음과 같은 명령행 옵션을 제공합니다:"

#: ../Doc/library/unittest.rst:206
msgid ""
"The standard output and standard error streams are buffered during the "
"test run. Output during a passing test is discarded. Output is echoed "
"normally on test fail or error and is added to the failure messages."
msgstr ""
"테스트가 실행될 동안 표준 출력과 표준 에러 스트림이 버퍼링 됩니다. 통과한 테스트 중에 나온 출력은 버려집니다. 보통 테스트 "
"실패나 에러에서 나온 출력은 표시되고 실패 메시지에 추가됩니다."

#: ../Doc/library/unittest.rst:212
msgid ""
":kbd:`Control-C` during the test run waits for the current test to end "
"and then reports all the results so far. A second :kbd:`Control-C` raises"
" the normal :exc:`KeyboardInterrupt` exception."
msgstr ""
"테스트 실행 중에 :kbd:`Control-C`\\를 누르면 현재 테스트가 끝날 때까지 기다린 다음 지금까지의 모든 결과를 "
"보고합니다. :kbd:`Control-C`\\를 다시 누르면 일반적인 :exc:`KeyboardInterrupt` 예외를 "
"발생합니다."

#: ../Doc/library/unittest.rst:216
msgid "See `Signal Handling`_ for the functions that provide this functionality."
msgstr "이 기능과 관련된 함수는 `시그널 처리하기 <Signal Handling_>`_\\를 참고하십시오."

#: ../Doc/library/unittest.rst:220
msgid "Stop the test run on the first error or failure."
msgstr "첫 번째 에러나 실패가 발생하면 테스트 실행을 중단합니다."

#: ../Doc/library/unittest.rst:224
msgid ""
"Only run test methods and classes that match the pattern or substring. "
"This option may be used multiple times, in which case all test cases that"
" match of the given patterns are included."
msgstr ""
"패턴이나 부분 문자열과 일치하는 테스트 메서드나 클래스만 실행합니다. 이 옵션은 여러 번 사용될 수 있습니다. 이 경우 주어진 "
"패턴과 일치하는 모든 테스트 케이스가 포함됩니다. "

#: ../Doc/library/unittest.rst:228
msgid ""
"Patterns that contain a wildcard character (``*``) are matched against "
"the test name using :meth:`fnmatch.fnmatchcase`; otherwise simple case-"
"sensitive substring matching is used."
msgstr ""
"와일드카드 문자(``*``)를 포함한 패턴은 :meth:`fnmatch.fnmatchcase`\\를 사용하여 그에 일치하는 테스트 "
"이름을 찾고; 그렇지 않은 경우 단순히 대소문자를 구별하는 부분 문자열 일치가 사용됩니다."

#: ../Doc/library/unittest.rst:232
msgid ""
"Patterns are matched against the fully qualified test method name as "
"imported by the test loader."
msgstr "패턴을 테스트 로더가 임포트한 완전히 정규화된 테스트 메서드 이름과 대조합니다."

#: ../Doc/library/unittest.rst:235
msgid ""
"For example, ``-k foo`` matches ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``, but not "
"``bar_tests.FooTest.test_something``."
msgstr ""
"예를 들어 ``-k foo``\\는 ``foo_tests.SomeTest.test_something``, "
"``bar_tests.SomeTest.test_foo``\\에 일치하지만, "
"``bar_tests.FooTest.test_something``\\에는 일치하지 않습니다."

#: ../Doc/library/unittest.rst:240
msgid "Show local variables in tracebacks."
msgstr "트레이스백(traceback)에서 지역 변수를 표시합니다."

#: ../Doc/library/unittest.rst:242
msgid "The command-line options ``-b``, ``-c`` and ``-f`` were added."
msgstr "명령행 옵션인 ``-b``, ``-c``, ``-f``\\가 추가되었습니다."

#: ../Doc/library/unittest.rst:245
msgid "The command-line option ``--locals``."
msgstr "명령행 옵션 ``--locals``."

#: ../Doc/library/unittest.rst:248
msgid "The command-line option ``-k``."
msgstr "명령행 옵션 ``-k``."

#: ../Doc/library/unittest.rst:251
msgid ""
"The command line can also be used for test discovery, for running all of "
"the tests in a project or just a subset."
msgstr "명령행은 프로젝트의 모든 테스트 또는 일부분의 테스트 탐색을 위해서도 사용할 수 있습니다. "

#: ../Doc/library/unittest.rst:258
msgid "Test Discovery"
msgstr "테스트 탐색(Discovery)"

#: ../Doc/library/unittest.rst:262
msgid ""
"Unittest supports simple test discovery. In order to be compatible with "
"test discovery, all of the test files must be :ref:`modules <tut-"
"modules>` or :ref:`packages <tut-packages>` (including :term:`namespace "
"packages <namespace package>`) importable from the top-level directory of"
" the project (this means that their filenames must be valid "
":ref:`identifiers <identifiers>`)."
msgstr ""
"unittest는 간단한 테스트 탐색을 지원합니다. 테스트 탐색에 호환되기 위해서는 모든 테스트 파일은 반드시 프로젝트의 가장 상위"
" 디렉터리로부터 :ref:`모듈 <tut-modules>` 또는 :ref:`패키지 <tut-packages>`\\(:term:`이름"
" 공간 패키지 <namespace package>` 포함)로 임포트 가능해야 합니다(이 말은 파일 이름이 반드시 유효한 "
":ref:`식별자 <identifiers>`\\이어야 한다는 뜻입니다)."

#: ../Doc/library/unittest.rst:269
msgid ""
"Test discovery is implemented in :meth:`TestLoader.discover`, but can "
"also be used from the command line. The basic command-line usage is::"
msgstr ""
"테스트 탐색은 :meth:`TestLoader.discover`\\로 구현되어 있습니다, 그러나 명령행으로 사용할 수도 있습니다. "
"기본적인 명령행 사용법은 다음과 같습니다::"

#: ../Doc/library/unittest.rst:277
msgid ""
"As a shortcut, ``python -m unittest`` is the equivalent of ``python -m "
"unittest discover``. If you want to pass arguments to test discovery the "
"``discover`` sub-command must be used explicitly."
msgstr ""
"단축형인 ``python -m unittest``\\는 ``python -m unittest discover``\\와 같습니다. "
"테스트 탐색에 인자를 전달하고 싶을 때는 ``discover`` 부속 명령어(sub-command)를 명시적으로 사용해야 합니다."

#: ../Doc/library/unittest.rst:281
msgid "The ``discover`` sub-command has the following options:"
msgstr "``discover`` 부-명령어는 다음과 같은 옵션을 가지고 있습니다:"

#: ../Doc/library/unittest.rst:287
msgid "Verbose output"
msgstr "상세한 출력"

#: ../Doc/library/unittest.rst:291
msgid "Directory to start discovery (``.`` default)"
msgstr "탐색을 시작할 디렉터리(기본값 ``.``)"

#: ../Doc/library/unittest.rst:295
msgid "Pattern to match test files (``test*.py`` default)"
msgstr "테스트 파일을 검색할 패턴(기본값 ``test*.py``)"

#: ../Doc/library/unittest.rst:299
msgid "Top level directory of project (defaults to start directory)"
msgstr "프로젝트의 최상위 디렉터리(기본값 시작 디렉터리)"

#: ../Doc/library/unittest.rst:301
msgid ""
"The :option:`-s`, :option:`-p`, and :option:`-t` options can be passed in"
" as positional arguments in that order. The following two command lines "
"are equivalent::"
msgstr ""
":option:`-s`, :option:`-p`, :option:`-t` 옵션은 이 순서대로 위치 인자로서 사용할 수 있습니다. "
"다음 2개의 명령행은 같습니다::"

#: ../Doc/library/unittest.rst:308
msgid ""
"As well as being a path it is possible to pass a package name, for "
"example ``myproject.subpackage.test``, as the start directory. The "
"package name you supply will then be imported and its location on the "
"filesystem will be used as the start directory."
msgstr ""
"경로가 사용되는 곳에 패키지 이름을 전달하는 것도 가능합니다, 예를 들어 ``myproject.subpackage.test``\\를"
" 시작 디렉터리로 사용할 수 있습니다. 주어진 패키지 이름은 임포트되어 그것의 파일 시스템상의 위치를 시작 디렉터리로 사용하게 "
"됩니다."

#: ../Doc/library/unittest.rst:315
msgid ""
"Test discovery loads tests by importing them. Once test discovery has "
"found all the test files from the start directory you specify it turns "
"the paths into package names to import. For example "
":file:`foo/bar/baz.py` will be imported as ``foo.bar.baz``."
msgstr ""
"테스트 탐색은 테스트를 임포트하여 로드합니다. 테스트 탐색이 당신이 지정한 시작 디렉터리로부터 모든 테스트 파일을 찾았다면 "
"임포트하기 위해 그 파일 경로를 패키지 이름으로 바꿉니다. 예를 들어 :file:`foo/bar/baz.py`\\는 "
"``foo.bar.baz``\\로 임포트될 것입니다."

#: ../Doc/library/unittest.rst:320
msgid ""
"If you have a package installed globally and attempt test discovery on a "
"different copy of the package then the import *could* happen from the "
"wrong place. If this happens test discovery will warn you and exit."
msgstr ""
"만약 당신이 전역적으로 설치된 패키지가 있고 테스트 탐색을 다른 패키지 복사본에 하려고 시도한다면 임포트가 잘못된 위치에서 발생할 "
"*수도 있습니다*. 만약 이런 일이 발생한다면 테스트 탐색은 경고하고 종료될 것입니다."

#: ../Doc/library/unittest.rst:324
msgid ""
"If you supply the start directory as a package name rather than a path to"
" a directory then discover assumes that whichever location it imports "
"from is the location you intended, so you will not get the warning."
msgstr ""
"만약 당신이 시작 디렉터리로 경로가 아닌 패키지 이름을 전달했다면 테스트 탐색은 임포트가 어느 경로로부터 되었든 간에 당신이 의도한"
" 경로라고 간주하여 경고를 발생하지 않을 것입니다."

#: ../Doc/library/unittest.rst:329
msgid ""
"Test modules and packages can customize test loading and discovery by "
"through the `load_tests protocol`_."
msgstr ""
"테스트 모듈과 패키지는 `load_tests 프로토콜 <load_tests protocol_>`_\\을 통하여 테스트 로드와 탐색을"
" 사용자 정의할 수 있습니다."

#: ../Doc/library/unittest.rst:332
msgid "Test discovery supports :term:`namespace packages <namespace package>`."
msgstr "테스트 탐색은 :term:`이름 공간 패키지 <namespace package>`\\를 지원합니다."

#: ../Doc/library/unittest.rst:339
msgid "Organizing test code"
msgstr "테스트 코드 구조 잡기"

#: ../Doc/library/unittest.rst:341
msgid ""
"The basic building blocks of unit testing are :dfn:`test cases` --- "
"single scenarios that must be set up and checked for correctness.  In "
":mod:`unittest`, test cases are represented by :class:`unittest.TestCase`"
" instances. To make your own test cases you must write subclasses of "
":class:`TestCase` or use :class:`FunctionTestCase`."
msgstr ""
"단위 테스트의 기본 구성 블록은 :dfn:`테스트 케이스(test cases)` --- 정확성을 위해 설정되고 확인될 하나의 "
"시나리오입니다. :mod:`unittest`\\에서 테스트 케이스는 :class:`unittest.TestCase` 인스턴스에 "
"해당합니다. 당신만의 테스트 케이스를 만들기 위해서는 :class:`TestCase`\\의 서브 클래스를 작성하거나 "
":class:`FunctionTestCase`\\를 사용해야 합니다."

#: ../Doc/library/unittest.rst:347
msgid ""
"The testing code of a :class:`TestCase` instance should be entirely self "
"contained, such that it can be run either in isolation or in arbitrary "
"combination with any number of other test cases."
msgstr ""
":class:`TestCase` 인스턴스의 테스트 코드는 완전히 독립적으로 되어 있어야 합니다, 그래야지 이것을 각각 단독으로 "
"실행하거나 다른 여러 테스트 케이스와 함께 임의의 조합으로 실행할 수 있습니다."

#: ../Doc/library/unittest.rst:351
msgid ""
"The simplest :class:`TestCase` subclass will simply implement a test "
"method (i.e. a method whose name starts with ``test``) in order to "
"perform specific testing code::"
msgstr ""
"가장 간단한 :class:`TestCase`\\의 서브 클래스는 특정 테스트 코드를 수행하도록 단순히 테스트 메서드(즉 "
"``test``\\로 이름이 시작하는 함수)를 구현하는 것입니다::"

#: ../Doc/library/unittest.rst:362
msgid ""
"Note that in order to test something, we use one of the :meth:`assert\\*`"
" methods provided by the :class:`TestCase` base class.  If the test "
"fails, an exception will be raised with an explanatory message, and "
":mod:`unittest` will identify the test case as a :dfn:`failure`.  Any "
"other exceptions will be treated as :dfn:`errors`."
msgstr ""
"어떤 것을 테스트하기 위해서는 :class:`TestCase` 베이스 클래스에서 제공하는 :meth:`assert\\*` 메서드 중"
" 한 개를 사용합니다. 테스트가 실패한다면 그 이유를 설명한 메시지가 포함된 예외가 발생합니다, 그리고 "
":mod:`unittest`\\는 해당 테스트 케이스를 :dfn:`실패(failure)`\\로 취급합니다. 다른 모든 예외는 "
":dfn:`에러(errors)`\\로 취급합니다."

#: ../Doc/library/unittest.rst:368
msgid ""
"Tests can be numerous, and their set-up can be repetitive.  Luckily, we "
"can factor out set-up code by implementing a method called "
":meth:`~TestCase.setUp`, which the testing framework will automatically "
"call for every single test we run::"
msgstr ""
"테스트는 매우 많지만, 그것을 위한 사전 설정은 계속 반복될 수 있습니다. 다행히, "
":meth:`~TestCase.setUp`\\이란 메서드를 작성하여 사전 설정 코드를 밖으로 분리해낼 수 있습니다. 테스트 "
"프레임워크가 1개의 테스트마다 매번 자동으로 이것을 호출할 것입니다::"

#: ../Doc/library/unittest.rst:389
msgid ""
"The order in which the various tests will be run is determined by sorting"
" the test method names with respect to the built-in ordering for strings."
msgstr "다양한 테스트가 실행될 순서는 테스트 메서드의 이름을 가지고 내장된 문자열 정렬 순서에 의하여 결정될 것입니다."

#: ../Doc/library/unittest.rst:393
msgid ""
"If the :meth:`~TestCase.setUp` method raises an exception while the test "
"is running, the framework will consider the test to have suffered an "
"error, and the test method will not be executed."
msgstr ""
"만약 :meth:`~TestCase.setUp` 메서드가 테스트 실행 중에 예외를 발생시킨다면 프레임워크는 테스트에 오류가 있는 "
"것으로 간주하여 테스트 메서드를 실행하지 않을 것입니다."

#: ../Doc/library/unittest.rst:397
msgid ""
"Similarly, we can provide a :meth:`~TestCase.tearDown` method that tidies"
" up after the test method has been run::"
msgstr "마찬가지로 테스트 메서드가 실행되고 나서 정리하기 위해 :meth:`~TestCase.tearDown` 메서드를 제공합니다::"

#: ../Doc/library/unittest.rst:409
msgid ""
"If :meth:`~TestCase.setUp` succeeded, :meth:`~TestCase.tearDown` will be "
"run whether the test method succeeded or not."
msgstr ""
"만약 :meth:`~TestCase.setUp`\\이 성공했다면, 테스트가 성공했든 실패했든 상관없이 "
":meth:`~TestCase.tearDown`\\이 실행될 것입니다."

#: ../Doc/library/unittest.rst:412
msgid ""
"Such a working environment for the testing code is called a :dfn:`test "
"fixture`.  A new TestCase instance is created as a unique test fixture "
"used to execute each individual test method.  Thus "
":meth:`~TestCase.setUp`, :meth:`~TestCase.tearDown`, and "
":meth:`~TestCase.__init__` will be called once per test."
msgstr ""
"이와 같은 테스트를 위한 실행 환경을 :dfn:`테스트 픽스쳐(test fixture)`\\라고 부릅니다. 개별 테스트 메서드를 "
"실행하기 위해 고유한 테스트 픽스쳐에 해당하는 새로운 테스트 케이스 인스턴스가 생성됩니다. 따라서 "
":meth:`~TestCase.setUp`, :meth:`~TestCase.tearDown`, "
":meth:`~TestCase.__init__`\\는 테스트 당 1번씩 실행됩니다."

#: ../Doc/library/unittest.rst:418
msgid ""
"It is recommended that you use TestCase implementations to group tests "
"together according to the features they test.  :mod:`unittest` provides a"
" mechanism for this: the :dfn:`test suite`, represented by "
":mod:`unittest`'s :class:`TestSuite` class.  In most cases, calling "
":func:`unittest.main` will do the right thing and collect all the "
"module's test cases for you and execute them."
msgstr ""
"테스트하려는 기능에 따라 테스트들을 같이 모아서 테스트 케이스 구현을 사용하는 것을 추천합니다. 이것을 위해 "
":mod:`unittest`\\는 메커니즘을 제공합니다: :dfn:`테스트 묶음(test suite)`, 이것은 "
":mod:`unittest`\\의 :class:`TestSuite` 클래스에 해당합니다. 대부분의 경우 "
":func:`unittest.main`\\이 테스트를 실행하기 위해 모듈의 모든 테스트 케이스를 수집하여 적절한 행동을 취할 "
"것입니다."

#: ../Doc/library/unittest.rst:425
msgid ""
"However, should you want to customize the building of your test suite, "
"you can do it yourself::"
msgstr "그러나 당신이 테스트 묶음을 사용자 정의하고 싶다면 그것을 직접 만들어야 합니다::"

#: ../Doc/library/unittest.rst:438
msgid ""
"You can place the definitions of test cases and test suites in the same "
"modules as the code they are to test (such as :file:`widget.py`), but "
"there are several advantages to placing the test code in a separate "
"module, such as :file:`test_widget.py`:"
msgstr ""
"당신은 테스트 케이스와 테스트 묶음의 정의를 테스트하려는 코드와 같은 모듈(예를 들어 file:`widget.py`)에 넣을 수 "
"있습니다, 그러나 테스트 코드를 분리된 모듈(예를 들어 :file:`test_widget.py`)에 넣으면 몇 가지 이점이 "
"있습니다:"

#: ../Doc/library/unittest.rst:443
msgid "The test module can be run standalone from the command line."
msgstr "테스트 모듈이 명령행에서 독립적으로 작동할 수 있습니다."

#: ../Doc/library/unittest.rst:445
msgid "The test code can more easily be separated from shipped code."
msgstr "테스트 코드가 배포될 코드와 쉽게 분리될 수 있습니다."

#: ../Doc/library/unittest.rst:447
msgid ""
"There is less temptation to change test code to fit the code it tests "
"without a good reason."
msgstr "충분한 이유 없이 테스트하려는 코드에 맞춰서 테스트 코드를 바꾸려는 유혹이 덜 합니다."

#: ../Doc/library/unittest.rst:450
msgid "Test code should be modified much less frequently than the code it tests."
msgstr "테스트 코드가 테스트하려는 코드에 비해 훨씬 덜 빈번하게 수정되어야 합니다."

#: ../Doc/library/unittest.rst:452
msgid "Tested code can be refactored more easily."
msgstr "테스트하려는 코드는 더 쉽게 리팩토링할 수 있습니다."

#: ../Doc/library/unittest.rst:454
msgid ""
"Tests for modules written in C must be in separate modules anyway, so why"
" not be consistent?"
msgstr "C 언어로 작성된 모듈의 테스트 코드는 반드시 분리된 모듈에 위치해야 합니다, 따라서 일관성을 지키는 것이 어떨까요?"

#: ../Doc/library/unittest.rst:457
msgid ""
"If the testing strategy changes, there is no need to change the source "
"code."
msgstr "만약 테스트 전략이 바뀌더라도 소스 코드를 바꿀 필요가 없습니다."

#: ../Doc/library/unittest.rst:463
msgid "Re-using old test code"
msgstr "이전의 테스트 코드를 다시 사용하기"

#: ../Doc/library/unittest.rst:465
msgid ""
"Some users will find that they have existing test code that they would "
"like to run from :mod:`unittest`, without converting every old test "
"function to a :class:`TestCase` subclass."
msgstr ""
"어떤 사용자들은 이전의 모든 테스트 함수를 :class:`TestCase` 서브 클래스로 변경하는 작업 없이 기존의 테스트 코드를 "
":mod:`unittest`\\로 실행하고 싶어 할 것입니다."

#: ../Doc/library/unittest.rst:469
msgid ""
"For this reason, :mod:`unittest` provides a :class:`FunctionTestCase` "
"class. This subclass of :class:`TestCase` can be used to wrap an existing"
" test function.  Set-up and tear-down functions can also be provided."
msgstr ""
"이러한 이유로 :mod:`unittest`\\는 :class:`FunctionTestCase` 클래스를 제공합니다. 이 "
":class:`TestCase`\\의 서브 클래스는 기존 테스트 함수를 감싸는데 사용할 수 있습니다. 사전 설정과 정리 함수 또한 "
"같이 사용할 수 있습니다."

#: ../Doc/library/unittest.rst:473
msgid "Given the following test function::"
msgstr "다음과 같은 테스트 함수가 있을 때::"

#: ../Doc/library/unittest.rst:480
msgid ""
"one can create an equivalent test case instance as follows, with optional"
" set-up and tear-down methods::"
msgstr "다음과 같이 동등한 테스트 케이스 인스턴스를 생성할 수 있습니다, 추가로 사전 설정과 정리 메서드를 함께 설정합니다::"

#: ../Doc/library/unittest.rst:489
msgid ""
"Even though :class:`FunctionTestCase` can be used to quickly convert an "
"existing test base over to a :mod:`unittest`\\ -based system, this "
"approach is not recommended.  Taking the time to set up proper "
":class:`TestCase` subclasses will make future test refactorings "
"infinitely easier."
msgstr ""
":class:`FunctionTestCase`\\를 사용하여 기존 테스트를 :mod:`unittest`\\ -기반 시스템으로 빠르게"
" 변경할 수 있을지라도 이 방법을 추천하지는 않습니다. 시간을 들여서 적절한 :class:`TestCase` 서브 클래스를 설정하는"
" 것이 미래에 있을 테스트 리팩토링을 대단히 쉽게 만들어줄 것입니다."

#: ../Doc/library/unittest.rst:494
msgid ""
"In some cases, the existing tests may have been written using the "
":mod:`doctest` module.  If so, :mod:`doctest` provides a "
":class:`DocTestSuite` class that can automatically build "
":class:`unittest.TestSuite` instances from the existing :mod:`doctest`\\ "
"-based tests."
msgstr ""
"어떤 경우에는 :mod:`doctest` 모듈을 사용하여 기존 테스트가 작성되었을 수도 있습니다. 만약 그렇다면 "
":mod:`doctest`\\가 제공하는 :class:`DocTestSuite` 클래스를 사용하여 기존의 "
":mod:`doctest`\\ -기반 테스트로부터 :class:`unittest.TestSuite` 인스턴스를 자동으로 만들 수 "
"있습니다."

#: ../Doc/library/unittest.rst:503
msgid "Skipping tests and expected failures"
msgstr "테스트 건너뛰기와 예상된 실패"

#: ../Doc/library/unittest.rst:507
msgid ""
"Unittest supports skipping individual test methods and even whole classes"
" of tests.  In addition, it supports marking a test as an \"expected "
"failure,\" a test that is broken and will fail, but shouldn't be counted "
"as a failure on a :class:`TestResult`."
msgstr ""
"unittest는 테스트 중에서 개별 테스트 메서드나 심지어 전체 클래스를 건너뛸 수 있는 기능을 제공합니다. 게다가 테스트를 "
"\"예상된 실패\"로 표시하는 기능도 지원합니다, 테스트가 망가져서 실패하더라도 그것을 :class:`TestResult`\\에 "
"실패라고 기록하지 않습니다."

#: ../Doc/library/unittest.rst:512
msgid ""
"Skipping a test is simply a matter of using the :func:`skip` "
":term:`decorator` or one of its conditional variants, calling "
":meth:`TestCase.skipTest` within a :meth:`~TestCase.setUp` or test "
"method, or raising :exc:`SkipTest` directly."
msgstr ""
"테스트 건너뛰기는 단순히 :func:`skip` :term:`데코레이터 <decorator>`\\나 그것의 조건 변형 중 하나를 "
"사용하거나, :meth:`~TestCase.setUp`\\이나 테스트 메서드 안에서 "
":meth:`TestCase.skipTest`\\를 호출하거나, :exc:`SkipTest`\\를 직접 발생시키면 됩니다."

#: ../Doc/library/unittest.rst:516
msgid "Basic skipping looks like this::"
msgstr "기본적인 건너뛰기는 다음과 같습니다::"

#: ../Doc/library/unittest.rst:541
msgid "This is the output of running the example above in verbose mode::"
msgstr "아래는 위의 예를 상세 모드로 실행했을 때의 출력입니다::"

#: ../Doc/library/unittest.rst:553
msgid "Classes can be skipped just like methods::"
msgstr "클래스도 메서드처럼 건너뛰기가 가능합니다::"

#: ../Doc/library/unittest.rst:560
msgid ""
":meth:`TestCase.setUp` can also skip the test.  This is useful when a "
"resource that needs to be set up is not available."
msgstr ""
":meth:`TestCase.setUp` 또한 테스트를 건너뛸 수 있습니다. 이것은 사전 설정해야 할 자원을 사용할 수 없을 때 "
"유용합니다."

#: ../Doc/library/unittest.rst:563
msgid "Expected failures use the :func:`expectedFailure` decorator. ::"
msgstr "예상된 실패는 :func:`expectedFailure` 데코레이터를 사용합니다. ::"

#: ../Doc/library/unittest.rst:570
msgid ""
"It's easy to roll your own skipping decorators by making a decorator that"
" calls :func:`skip` on the test when it wants it to be skipped.  This "
"decorator skips the test unless the passed object has a certain "
"attribute::"
msgstr ""
"자신만의 건너뛰기 데코레이터를 만들기는 쉽습니다. 테스트를 건너뛰고 싶을 때 :func:`skip`\\를 호출하도록 데코레이터를 "
"만들면 됩니다. 다음의 데코레이터는 특정 어트리뷰트가 있는 객체가 전달되지 않으면 테스트를 건너뜁니다::"

#: ../Doc/library/unittest.rst:579
msgid ""
"The following decorators and exception implement test skipping and "
"expected failures:"
msgstr "다음 데코레이터들과 예외는 테스트 건너뛰기와 예상된 실패를 구현합니다:"

#: ../Doc/library/unittest.rst:583
msgid ""
"Unconditionally skip the decorated test.  *reason* should describe why "
"the test is being skipped."
msgstr "조건 없이 데코레이트된 테스트를 건너뜁니다. *reason*\\은 왜 이 테스트가 건너뛰어 졌는지를 설명해야 합니다."

#: ../Doc/library/unittest.rst:588
msgid "Skip the decorated test if *condition* is true."
msgstr "*condition*\\이 참이면 데코레이트된 테스트를 건너뜁니다."

#: ../Doc/library/unittest.rst:592
msgid "Skip the decorated test unless *condition* is true."
msgstr "*condition*\\이 참이 아니면 데코레이트된 테스트를 건너뜁니다."

#: ../Doc/library/unittest.rst:596
#, fuzzy
msgid ""
"Mark the test as an expected failure or error.  If the test fails or "
"errors it will be considered a success.  If the test passes, it will be "
"considered a failure."
msgstr "테스트가 예상된 실패라는 표시를 합니다. 테스트가 실패하면 성공으로 간주합니다. 테스트에 통과하면 실패로 간주합니다."

#: ../Doc/library/unittest.rst:602
msgid "This exception is raised to skip a test."
msgstr "이 예외는 테스트를 건너뛰기 위해서 발생합니다."

#: ../Doc/library/unittest.rst:604
msgid ""
"Usually you can use :meth:`TestCase.skipTest` or one of the skipping "
"decorators instead of raising this directly."
msgstr "보통은 이 예외를 직접 발생시키기보다는 :meth:`TestCase.skipTest`\\나 건너뛰기 데코레이터를 사용할 수 있습니다."

#: ../Doc/library/unittest.rst:607
msgid ""
"Skipped tests will not have :meth:`~TestCase.setUp` or "
":meth:`~TestCase.tearDown` run around them. Skipped classes will not have"
" :meth:`~TestCase.setUpClass` or :meth:`~TestCase.tearDownClass` run. "
"Skipped modules will not have :func:`setUpModule` or "
":func:`tearDownModule` run."
msgstr ""
"건너뛰는 테스트는 테스트 전후로 :meth:`~TestCase.setUp`\\이나 "
":meth:`~TestCase.tearDown`\\를 실행하지 않을 것입니다. 건너뛰는 클래스는 "
":meth:`~TestCase.setUpClass`\\나 :meth:`~TestCase.tearDownClass`\\를 실행하지 "
"않을 것입니다. 건너뛰는 모듈은 :func:`setUpModule`\\이나 :func:`tearDownModule`\\을 실행하지 "
"않을 것입니다."

#: ../Doc/library/unittest.rst:615
msgid "Distinguishing test iterations using subtests"
msgstr "부분 테스트(subtest)를 사용하여 테스트 반복 구별 짓기"

#: ../Doc/library/unittest.rst:619
msgid ""
"When there are very small differences among your tests, for instance some"
" parameters, unittest allows you to distinguish them inside the body of a"
" test method using the :meth:`~TestCase.subTest` context manager."
msgstr ""
"여러분의 테스트들이 아주 작은 부분에서만 다를 때, 예를 들어 몇몇 매개변수, unittest는 "
":meth:`~TestCase.subTest` 컨텍스트 관리자를 사용하여 테스트 메서드의 바디 안에서 그것들은 구별 짓게 해줍니다."

#: ../Doc/library/unittest.rst:623
msgid "For example, the following test::"
msgstr "예를 들어, 다음 테스트는::"

#: ../Doc/library/unittest.rst:635
msgid "will produce the following output::"
msgstr "다음의 출력을 만듭니다::"

#: ../Doc/library/unittest.rst:661
msgid ""
"Without using a subtest, execution would stop after the first failure, "
"and the error would be less easy to diagnose because the value of ``i`` "
"wouldn't be displayed::"
msgstr ""
"부분 테스트를 사용하지 않는다면 테스트 실행은 첫 번째 실패 후에 중단될 것이고 ``i`` 값이 표시되지 않기 때문에 에러를 "
"진단하는 데 쉽지 않을 것입니다::"

#: ../Doc/library/unittest.rst:677
msgid "Classes and functions"
msgstr "클래스와 함수"

#: ../Doc/library/unittest.rst:679
msgid "This section describes in depth the API of :mod:`unittest`."
msgstr "이 절은 :mod:`unittest`\\의 API를 심도 있게 설명합니다."

#: ../Doc/library/unittest.rst:685
msgid "Test cases"
msgstr "테스트 케이스"

#: ../Doc/library/unittest.rst:689
msgid ""
"Instances of the :class:`TestCase` class represent the logical test units"
" in the :mod:`unittest` universe.  This class is intended to be used as a"
" base class, with specific tests being implemented by concrete "
"subclasses.  This class implements the interface needed by the test "
"runner to allow it to drive the tests, and methods that the test code can"
" use to check for and report various kinds of failure."
msgstr ""
":class:`TestCase` 클래스의 인스턴스는 :mod:`unittest` 세계에서 논리적인 테스트 단위에 해당합니다. 이 "
"클래스는 베이스 클래스로 사용되며, 특정 테스트는 구상 클래스로 구현됩니다. 이 클래스는 테스트 실행자가 테스트를 실행할 수 있는 "
"인터페이스를 구현하고 테스트 코드가 검사하고 다양한 실패를 보고할 수 있는 메서드를 구현합니다."

#: ../Doc/library/unittest.rst:696
msgid ""
"Each instance of :class:`TestCase` will run a single base method: the "
"method named *methodName*. In most uses of :class:`TestCase`, you will "
"neither change the *methodName* nor reimplement the default ``runTest()``"
" method."
msgstr ""
":class:`TestCase`\\의 각 인스턴스는 하나의 베이스 메서드: *methodName*\\이 지정하는 이름의 메서드를 "
"실행할 것입니다. 대부분의 :class:`TestCase` 사용에서, 당신은 *methodName*\\을 바꾸거나 기본 "
"``runTest()`` 메서드를 재구현하지 않을 것입니다."

#: ../Doc/library/unittest.rst:701
msgid ""
":class:`TestCase` can be instantiated successfully without providing a "
"*methodName*. This makes it easier to experiment with :class:`TestCase` "
"from the interactive interpreter."
msgstr ""
"*methodName* 제공 없이도 :class:`TestCase`\\를 성공적으로 인스턴스화할 수 있습니다. 이것은 대화형 "
"인터프리터에서 :class:`TestCase`\\로 쉽게 실험을 할 수 있게 합니다."

#: ../Doc/library/unittest.rst:706
msgid ""
":class:`TestCase` instances provide three groups of methods: one group "
"used to run the test, another used by the test implementation to check "
"conditions and report failures, and some inquiry methods allowing "
"information about the test itself to be gathered."
msgstr ""
":class:`TestCase` 인스턴스는 3가지 메서드 그룹을 제공합니다: 한 그룹은 테스트를 실행하는 데 사용되고, 다른 한 "
"그룹은 조건을 확인하고 실패를 보고하는 테스트 구현으로 사용되고, 몇몇 조회 메서드는 테스트 자체에 관한 정보를 수집할 수 있게 "
"해줍니다."

#: ../Doc/library/unittest.rst:711
msgid "Methods in the first group (running the test) are:"
msgstr "첫 번째 그룹(테스트 실행) 안에 메서드는:"

#: ../Doc/library/unittest.rst:715
msgid ""
"Method called to prepare the test fixture.  This is called immediately "
"before calling the test method; other than :exc:`AssertionError` or "
":exc:`SkipTest`, any exception raised by this method will be considered "
"an error rather than a test failure. The default implementation does "
"nothing."
msgstr ""
"테스트 픽스쳐를 준비하기 위해 호출되는 메서드입니다. 이 메서드는 테스트 메서드를 호출하기 바로 직전에 호출됩니다; "
":exc:`AssertionError` 또는 :exc:`SkipTest`\\이외의 이 메서드에서 발생한 모든 예외는 테스트 실패가 "
"아닌 오류로 간주합니다. 기본 구현은 아무것도 하지 않습니다."

#: ../Doc/library/unittest.rst:723
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called even if the test method raised an "
"exception, so the implementation in subclasses may need to be "
"particularly careful about checking internal state.  Any exception, other"
" than :exc:`AssertionError` or :exc:`SkipTest`, raised by this method "
"will be considered an additional error rather than a test failure (thus "
"increasing the total number of reported errors). This method will only be"
" called if the :meth:`setUp` succeeds, regardless of the outcome of the "
"test method. The default implementation does nothing."
msgstr ""
"테스트 메서드가 불리고 결과가 기록되고 나서 바로 다음에 호출되는 메서드입니다. 테스트 메서드가 예외를 발생했더라도 이 메서드는 "
"불립니다, 따라서 서브 클래스의 구현은 내부 상태를 확인하는 데 특별히 주의를 기울여야 합니다. "
":exc:`AssertionError` 또는 :exc:`SkipTest`\\이외의 이 메서드에서 발생하는 모든 예외는 테스트 실패가"
" 아닌 오류로 간주합니다(따라서 보고된 오류의 총 숫자가 증가합니다). 이 메서드는 테스트 메서드의 결과물에 영향받지 않고 "
":meth:`setUp`\\이 성공했을 때만 불립니다. 기본 구현은 아무것도 하지 않습니다."

#: ../Doc/library/unittest.rst:736
msgid ""
"A class method called before tests in an individual class are run. "
"``setUpClass`` is called with the class as the only argument and must be "
"decorated as a :func:`classmethod`::"
msgstr ""
"개별 클래스의 테스트들이 실행되기 전에 불리는 클래스 메서드입니다. ``setUpClass``\\는 클래스만 인자로 받아 호출되고 "
":func:`classmethod`\\로 데코레이트해야 합니다::"

#: ../Doc/library/unittest.rst:744 ../Doc/library/unittest.rst:759
msgid "See `Class and Module Fixtures`_ for more details."
msgstr "더 자세한 것은 `클래스와 모듈 픽스쳐 <Class and Module Fixtures_>`_\\를 보십시오."

#: ../Doc/library/unittest.rst:751
msgid ""
"A class method called after tests in an individual class have run. "
"``tearDownClass`` is called with the class as the only argument and must "
"be decorated as a :meth:`classmethod`::"
msgstr ""
"개별 클래스의 테스트들이 실행되고 난 뒤에 불리는 클래스 메서드입니다. ``tearDownClass``\\는 클래스만 인자로 받아 "
"호출되고 :func:`classmethod`\\로 데코레이트해야 합니다::"

#: ../Doc/library/unittest.rst:766
msgid ""
"Run the test, collecting the result into the :class:`TestResult` object "
"passed as *result*.  If *result* is omitted or ``None``, a temporary "
"result object is created (by calling the :meth:`defaultTestResult` "
"method) and used. The result object is returned to :meth:`run`'s caller."
msgstr ""
"테스트를 실행하고, *result* 인자로 전달된 :class:`TestResult`\\에 결과를 수집합니다. 만약 *result*"
" 인자가 전달 안 되거나 ``None``\\이라면 임시 결과 객체를 (:meth:`defaultTestResult` 메서드를 "
"불러서) 생성하여 사용합니다. :meth:`run` 호출자에게 결과 객체를 반환합니다."

#: ../Doc/library/unittest.rst:772
msgid ""
"The same effect may be had by simply calling the :class:`TestCase` "
"instance."
msgstr "단순히 :class:`TestCase` 인스턴스를 호출하는 것으로 같은 효과를 볼 수 있습니다."

#: ../Doc/library/unittest.rst:775
msgid ""
"Previous versions of ``run`` did not return the result. Neither did "
"calling an instance."
msgstr "기존 버전의 ``run``\\은 결과를 반환하지 않았습니다. 인스턴스 호출 또한 그렇지 않았습니다."

#: ../Doc/library/unittest.rst:781
msgid ""
"Calling this during a test method or :meth:`setUp` skips the current "
"test.  See :ref:`unittest-skipping` for more information."
msgstr ""
"테스트 메서드나 :meth:`setUp`\\에서 이것을 호출하면 현재 테스트를 건너뜁니다. 자세한 정보는 :ref"
":`unittest-skipping`\\를 보십시오."

#: ../Doc/library/unittest.rst:789
msgid ""
"Return a context manager which executes the enclosed code block as a "
"subtest.  *msg* and *params* are optional, arbitrary values which are "
"displayed whenever a subtest fails, allowing you to identify them "
"clearly."
msgstr ""
"둘러싼 코드 블록을 부분 테스트로서 실행하는 컨텍스트 관리자를 반환합니다. *msg* 및 *params*\\는 선택 사항이며 부분 "
"테스트가 실패 할 때마다 표시되는 임의의 값으로 당신이 명확하게 알아보게 해줍니다."

#: ../Doc/library/unittest.rst:794
msgid ""
"A test case can contain any number of subtest declarations, and they can "
"be arbitrarily nested."
msgstr "테스트 케이스는 여러 개의 부분 테스트 선언을 포함할 수 있고, 그것들은 자유롭게 중첩될 수 있습니다."

#: ../Doc/library/unittest.rst:797
msgid "See :ref:`subtests` for more information."
msgstr "자세한 정보는 :ref:`subtests`\\를 보십시오."

#: ../Doc/library/unittest.rst:804
msgid ""
"Run the test without collecting the result.  This allows exceptions "
"raised by the test to be propagated to the caller, and can be used to "
"support running tests under a debugger."
msgstr ""
"결과를 수집하지 않고 테스트를 실행합니다. 이것은 테스트에서 발생한 예외가 호출자로 전파될 수 있게 해서, 디버거 환경에서 테스트를"
" 실행할 때 사용될 수 있습니다."

#: ../Doc/library/unittest.rst:810
msgid ""
"The :class:`TestCase` class provides several assert methods to check for "
"and report failures.  The following table lists the most commonly used "
"methods (see the tables below for more assert methods):"
msgstr ""
":class:`TestCase` 클래스는 값을 검사하고 실패를 보고하기 위해 몇 개의 assert 메서드를 제공합니다. 다음 표는 "
"보통 많이 사용되는 메서드들입니다(더 많은 assert 메서드는 표 아래를 보십시오):"

#: ../Doc/library/unittest.rst:815 ../Doc/library/unittest.rst:936
#: ../Doc/library/unittest.rst:1129 ../Doc/library/unittest.rst:1256
msgid "Method"
msgstr "메서드"

#: ../Doc/library/unittest.rst:815 ../Doc/library/unittest.rst:936
#: ../Doc/library/unittest.rst:1129
msgid "Checks that"
msgstr "검사하는 내용"

#: ../Doc/library/unittest.rst:815 ../Doc/library/unittest.rst:936
#: ../Doc/library/unittest.rst:1129 ../Doc/library/unittest.rst:1256
msgid "New in"
msgstr "추가된 버전"

#: ../Doc/library/unittest.rst:817
msgid ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"
msgstr ":meth:`assertEqual(a, b) <TestCase.assertEqual>`"

#: ../Doc/library/unittest.rst:817
msgid "``a == b``"
msgstr "``a == b``"

#: ../Doc/library/unittest.rst:820
msgid ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"
msgstr ":meth:`assertNotEqual(a, b) <TestCase.assertNotEqual>`"

#: ../Doc/library/unittest.rst:820
msgid "``a != b``"
msgstr "``a != b``"

#: ../Doc/library/unittest.rst:823
msgid ":meth:`assertTrue(x) <TestCase.assertTrue>`"
msgstr ":meth:`assertTrue(x) <TestCase.assertTrue>`"

#: ../Doc/library/unittest.rst:823
msgid "``bool(x) is True``"
msgstr "``bool(x) is True``"

#: ../Doc/library/unittest.rst:826
msgid ":meth:`assertFalse(x) <TestCase.assertFalse>`"
msgstr ":meth:`assertFalse(x) <TestCase.assertFalse>`"

#: ../Doc/library/unittest.rst:826
msgid "``bool(x) is False``"
msgstr "``bool(x) is False``"

#: ../Doc/library/unittest.rst:829
msgid ":meth:`assertIs(a, b) <TestCase.assertIs>`"
msgstr ":meth:`assertIs(a, b) <TestCase.assertIs>`"

#: ../Doc/library/unittest.rst:829
msgid "``a is b``"
msgstr "``a is b``"

#: ../Doc/library/unittest.rst:829 ../Doc/library/unittest.rst:832
#: ../Doc/library/unittest.rst:835 ../Doc/library/unittest.rst:838
#: ../Doc/library/unittest.rst:841 ../Doc/library/unittest.rst:844
#: ../Doc/library/unittest.rst:941 ../Doc/library/unittest.rst:1137
#: ../Doc/library/unittest.rst:1140 ../Doc/library/unittest.rst:1143
#: ../Doc/library/unittest.rst:1146 ../Doc/library/unittest.rst:1149
#: ../Doc/library/unittest.rst:1258 ../Doc/library/unittest.rst:1261
#: ../Doc/library/unittest.rst:1264 ../Doc/library/unittest.rst:1267
#: ../Doc/library/unittest.rst:1270 ../Doc/library/unittest.rst:1273
msgid "3.1"
msgstr "3.1"

#: ../Doc/library/unittest.rst:832
msgid ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"
msgstr ":meth:`assertIsNot(a, b) <TestCase.assertIsNot>`"

#: ../Doc/library/unittest.rst:832
msgid "``a is not b``"
msgstr "``a is not b``"

#: ../Doc/library/unittest.rst:835
msgid ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"
msgstr ":meth:`assertIsNone(x) <TestCase.assertIsNone>`"

#: ../Doc/library/unittest.rst:835
msgid "``x is None``"
msgstr "``x is None``"

#: ../Doc/library/unittest.rst:838
msgid ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"
msgstr ":meth:`assertIsNotNone(x) <TestCase.assertIsNotNone>`"

#: ../Doc/library/unittest.rst:838
msgid "``x is not None``"
msgstr "``x is not None``"

#: ../Doc/library/unittest.rst:841
msgid ":meth:`assertIn(a, b) <TestCase.assertIn>`"
msgstr ":meth:`assertIn(a, b) <TestCase.assertIn>`"

#: ../Doc/library/unittest.rst:841
msgid "``a in b``"
msgstr "``a in b``"

#: ../Doc/library/unittest.rst:844
msgid ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"
msgstr ":meth:`assertNotIn(a, b) <TestCase.assertNotIn>`"

#: ../Doc/library/unittest.rst:844
msgid "``a not in b``"
msgstr "``a not in b``"

#: ../Doc/library/unittest.rst:847
msgid ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"
msgstr ":meth:`assertIsInstance(a, b) <TestCase.assertIsInstance>`"

#: ../Doc/library/unittest.rst:847
msgid "``isinstance(a, b)``"
msgstr "``isinstance(a, b)``"

#: ../Doc/library/unittest.rst:847 ../Doc/library/unittest.rst:850
#: ../Doc/library/unittest.rst:944 ../Doc/library/unittest.rst:947
#: ../Doc/library/unittest.rst:1152 ../Doc/library/unittest.rst:1155
msgid "3.2"
msgstr "3.2"

#: ../Doc/library/unittest.rst:850
msgid ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"
msgstr ":meth:`assertNotIsInstance(a, b) <TestCase.assertNotIsInstance>`"

#: ../Doc/library/unittest.rst:850
msgid "``not isinstance(a, b)``"
msgstr "``not isinstance(a, b)``"

#: ../Doc/library/unittest.rst:854
msgid ""
"All the assert methods accept a *msg* argument that, if specified, is "
"used as the error message on failure (see also :data:`longMessage`). Note"
" that the *msg* keyword argument can be passed to :meth:`assertRaises`, "
":meth:`assertRaisesRegex`, :meth:`assertWarns`, :meth:`assertWarnsRegex` "
"only when they are used as a context manager."
msgstr ""
"모든 assert 메서드는 *msg* 인자를 받을 수 있습니다, 만약 그것이 전달된다면 실패 시 에러 메시지로 "
"사용됩니다(:data:`longMessage` 도 참고하십시오). :meth:`assertRaises`, "
":meth:`assertRaisesRegex`, :meth:`assertWarns`, "
":meth:`assertWarnsRegex`\\는 컨텍스트 관리자로서 사용될 때만 그들에게 *msg* 키워드 인자를 전달할 수 "
"있다는 점을 주의하십시오."

#: ../Doc/library/unittest.rst:862
msgid ""
"Test that *first* and *second* are equal.  If the values do not compare "
"equal, the test will fail."
msgstr "*first*\\와 *second*\\가 같은지 테스트합니다. 비교한 값이 같지 않으면 테스트는 실패할 것입니다."

#: ../Doc/library/unittest.rst:865
msgid ""
"In addition, if *first* and *second* are the exact same type and one of "
"list, tuple, dict, set, frozenset or str or any type that a subclass "
"registers with :meth:`addTypeEqualityFunc` the type-specific equality "
"function will be called in order to generate a more useful default error "
"message (see also the :ref:`list of type-specific methods <type-specific-"
"methods>`)."
msgstr ""
"추가로, 만약 *first*\\와 *second*\\가 정확히 같은 형(type)이고 list, tuple, dict, set, "
"frozenset, str 이거나 :meth:`addTypeEqualityFunc`\\에 등록된 서브 클래스 형 중 하나일 경우 더"
" 유용한 기본 에러 메시지를 생성하기 위해 형-특화(type-specific) 동등성 함수가 불릴 것입니다(:ref:`형-특화 "
"메서드 목록 <type-specific-methods>`\\을 참고하십시오)."

#: ../Doc/library/unittest.rst:872
msgid "Added the automatic calling of type-specific equality function."
msgstr "형-특화 동등성 함수가 자동으로 불리도록 추가"

#: ../Doc/library/unittest.rst:875
msgid ""
":meth:`assertMultiLineEqual` added as the default type equality function "
"for comparing strings."
msgstr "문자열 비교를 위해서 :meth:`assertMultiLineEqual`\\를 기본 형-특화 동등성 함수에 추가"

#: ../Doc/library/unittest.rst:882
msgid ""
"Test that *first* and *second* are not equal.  If the values do compare "
"equal, the test will fail."
msgstr "*first*\\와 *second*\\가 같지 않은지 테스트합니다, 비교한 값이 같으면 테스트는 실패할 것입니다."

#: ../Doc/library/unittest.rst:888
msgid "Test that *expr* is true (or false)."
msgstr "*expr*\\이 참(또는 거짓)인지 테스트합니다."

#: ../Doc/library/unittest.rst:890
msgid ""
"Note that this is equivalent to ``bool(expr) is True`` and not to ``expr "
"is True`` (use ``assertIs(expr, True)`` for the latter).  This method "
"should also be avoided when more specific methods are available (e.g. "
"``assertEqual(a, b)`` instead of ``assertTrue(a == b)``), because they "
"provide a better error message in case of failure."
msgstr ""
"이것은 ``bool(expr) is True``\\와 동등하고 ``expr is True``\\와 동등하지 않다는 것에 "
"주의하십시오(후자를 위해선 ``assertIs(expr, True)``\\를 사용하십시오). 더 구체적인 메서드를 사용할 수 있을 "
"때는 이 메서드를 지양해야 합니다(예, ``assertTrue(a == b)`` 대신에 ``assertEqual(a, b)``), "
"왜냐하면 실패의 경우에 구체적인 메서드가 더 나은 에러 메시지를 제공하기 때문입니다."

#: ../Doc/library/unittest.rst:900
#, fuzzy
msgid "Test that *first* and *second* are (or are not) the same object."
msgstr "*first*\\와 *second*\\가 같은 객체로 평가되는지(아닌지) 테스트합니다."

#: ../Doc/library/unittest.rst:908
msgid "Test that *expr* is (or is not) ``None``."
msgstr "*expr*\\이 ``None`` 인지(아닌지) 테스트합니다."

#: ../Doc/library/unittest.rst:916
msgid "Test that *member* is (or is not) in *container*."
msgstr "*member*\\가 *container* 안에 있는지(아닌지) 테스트합니다."

#: ../Doc/library/unittest.rst:924
msgid ""
"Test that *obj* is (or is not) an instance of *cls* (which can be a class"
" or a tuple of classes, as supported by :func:`isinstance`). To check for"
" the exact type, use :func:`assertIs(type(obj), cls) <assertIs>`."
msgstr ""
"*obj*\\가 *cls*\\(:func:`isinstance`\\가 지원하는 것처럼 클래스 또는 클래스의 튜플)의 "
"인스턴스인지(아닌지) 테스트합니다. 정확한 형 검사를 위해서는 :func:`assertIs(type(obj), cls) "
"<assertIs>`\\를 사용하십시오."

#: ../Doc/library/unittest.rst:932
msgid ""
"It is also possible to check the production of exceptions, warnings, and "
"log messages using the following methods:"
msgstr "다음의 메서드를 사용하여 예외, 경고, 로그 메시지의 발생을 검사할 수 있습니다:"

#: ../Doc/library/unittest.rst:938
msgid ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"
msgstr ":meth:`assertRaises(exc, fun, *args, **kwds) <TestCase.assertRaises>`"

#: ../Doc/library/unittest.rst:938
msgid "``fun(*args, **kwds)`` raises *exc*"
msgstr "``fun(*args, **kwds)``\\가 *exc*\\를 발생"

#: ../Doc/library/unittest.rst:941
msgid ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) "
"<TestCase.assertRaisesRegex>`"
msgstr ""
":meth:`assertRaisesRegex(exc, r, fun, *args, **kwds) "
"<TestCase.assertRaisesRegex>`"

#: ../Doc/library/unittest.rst:941
msgid "``fun(*args, **kwds)`` raises *exc* and the message matches regex *r*"
msgstr "``fun(*args, **kwds)``\\가 *exc*\\를 발생하고 메시지가 정규식 *r*\\에 일치"

#: ../Doc/library/unittest.rst:944
msgid ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"
msgstr ":meth:`assertWarns(warn, fun, *args, **kwds) <TestCase.assertWarns>`"

#: ../Doc/library/unittest.rst:944
msgid "``fun(*args, **kwds)`` raises *warn*"
msgstr "``fun(*args, **kwds)``\\가 *warn*\\을 발생"

#: ../Doc/library/unittest.rst:947
msgid ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) "
"<TestCase.assertWarnsRegex>`"
msgstr ""
":meth:`assertWarnsRegex(warn, r, fun, *args, **kwds) "
"<TestCase.assertWarnsRegex>`"

#: ../Doc/library/unittest.rst:947
msgid "``fun(*args, **kwds)`` raises *warn* and the message matches regex *r*"
msgstr "``fun(*args, **kwds)``\\가 *warn*\\을 발생하고 메시지가 정규식 *r*\\에 일치"

#: ../Doc/library/unittest.rst:950
msgid ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"
msgstr ":meth:`assertLogs(logger, level) <TestCase.assertLogs>`"

#: ../Doc/library/unittest.rst:950
msgid "The ``with`` block logs on *logger* with minimum *level*"
msgstr "``with`` 블록이 최소 *level*\\로 *logger*\\에 로그를 남김"

#: ../Doc/library/unittest.rst:950
msgid "3.4"
msgstr "3.4"

#: ../Doc/library/unittest.rst:957
msgid ""
"Test that an exception is raised when *callable* is called with any "
"positional or keyword arguments that are also passed to "
":meth:`assertRaises`.  The test passes if *exception* is raised, is an "
"error if another exception is raised, or fails if no exception is raised."
" To catch any of a group of exceptions, a tuple containing the exception "
"classes may be passed as *exception*."
msgstr ""
":meth:`assertRaises`\\에 전달된 어떤 위치 또는 키워드 인자와 함께 *callable*\\이 호출되었을 때 예외가"
" 발생하는지 테스트합니다. *exception*\\이 발생하면 테스트를 통과하고, 다른 예외가 발생하면 에러이고, 아무 예외도 "
"발생하지 않으면 실패입니다. 여러 예외 모음을 잡기 위해서 예외 클래스를 포함한 튜플을 *exception*\\으로 전달해도 "
"좋습니다."

#: ../Doc/library/unittest.rst:964
msgid ""
"If only the *exception* and possibly the *msg* arguments are given, "
"return a context manager so that the code under test can be written "
"inline rather than as a function::"
msgstr ""
"만약 선택적인 *msg*\\와 함께 오직 *exception* 인자만 전달된다면, 테스트할 코드를 함수가 아닌 인라인으로 작성할 수"
" 있도록 컨텍스트 관리자를 반환합니다::"

#: ../Doc/library/unittest.rst:971
msgid ""
"When used as a context manager, :meth:`assertRaises` accepts the "
"additional keyword argument *msg*."
msgstr "컨텍스트 관리자로 사용되면, :meth:`assertRaises`\\는 추가적인 키워드 인자인 *msg*\\를 받을 수 있습니다."

#: ../Doc/library/unittest.rst:974
msgid ""
"The context manager will store the caught exception object in its "
":attr:`exception` attribute.  This can be useful if the intention is to "
"perform additional checks on the exception raised::"
msgstr ""
"컨텍스트 관리자는 잡은 예외 객체를 :attr:`exception` 어트리뷰트에 저장할 것입니다. 이것은 발생한 예외에 대해서 "
"추가적인 검사를 수행하려는 경우에 유용할 수 있습니다::"

#: ../Doc/library/unittest.rst:984
msgid "Added the ability to use :meth:`assertRaises` as a context manager."
msgstr ":meth:`assertRaises`\\를 컨텍스트 관리자로 사용할 수 있도록 기능 추가."

#: ../Doc/library/unittest.rst:987
msgid "Added the :attr:`exception` attribute."
msgstr ":attr:`exception` 어트리뷰트 추가."

#: ../Doc/library/unittest.rst:990 ../Doc/library/unittest.rst:1016
#: ../Doc/library/unittest.rst:1057 ../Doc/library/unittest.rst:1080
msgid "Added the *msg* keyword argument when used as a context manager."
msgstr "컨텍스트 관리자로 사용될 때 *msg* 키워드 인자 추가."

#: ../Doc/library/unittest.rst:997
msgid ""
"Like :meth:`assertRaises` but also tests that *regex* matches on the "
"string representation of the raised exception.  *regex* may be a regular "
"expression object or a string containing a regular expression suitable "
"for use by :func:`re.search`.  Examples::"
msgstr ""
":meth:`assertRaises`\\와 비슷하지만 발생한 예외의 문자열 표현이 *regex*\\에 일치하는지 테스트합니다. "
"*regex*\\는 정규식 객체나 :func:`re.search`\\에 사용되기 적합한 정규식 문자열이 될 수 있습니다. 예::"

#: ../Doc/library/unittest.rst:1005 ../Doc/library/unittest.rst:1073
msgid "or::"
msgstr "또는::"

#: ../Doc/library/unittest.rst:1010
msgid "Added under the name ``assertRaisesRegexp``."
msgstr "``assertRaisesRegexp`` 라는 이름으로 추가되었습니다."

#: ../Doc/library/unittest.rst:1013
msgid "Renamed to :meth:`assertRaisesRegex`."
msgstr ":meth:`assertRaisesRegex`\\으로 이름 변경."

#: ../Doc/library/unittest.rst:1023
msgid ""
"Test that a warning is triggered when *callable* is called with any "
"positional or keyword arguments that are also passed to "
":meth:`assertWarns`.  The test passes if *warning* is triggered and fails"
" if it isn't.  Any exception is an error. To catch any of a group of "
"warnings, a tuple containing the warning classes may be passed as "
"*warnings*."
msgstr ""
":meth:`assertWarns`\\에 전달된 어떤 위치 또는 키워드 인자와 함께 *callable*\\이 호출되었을 때 "
"경고(warning)가 발생하는지 테스트합니다. *warning*\\이 발생하면 테스트를 통과하고, 그렇지 않으면 실패입니다. "
"예외가 발생하면 에러입니다. 여러 경고 모음을 잡기 위해서 경고 클래스를 포함한 튜플을 *warnings*\\로 전달해도 좋습니다."

#: ../Doc/library/unittest.rst:1030
msgid ""
"If only the *warning* and possibly the *msg* arguments are given, return "
"a context manager so that the code under test can be written inline "
"rather than as a function::"
msgstr ""
"만약 선택적인 *msg*\\와 함께 오직 *warning* 인자만 전달된다면, 테스트할 코드를 함수가 아닌 인라인으로 작성할 수 "
"있도록 컨텍스트 관리자를 반환합니다::"

#: ../Doc/library/unittest.rst:1037
msgid ""
"When used as a context manager, :meth:`assertWarns` accepts the "
"additional keyword argument *msg*."
msgstr "컨텍스트 관리자로 사용되면, :meth:`assertWarns`\\는 추가적인 키워드 인자인 *msg*\\를 받을 수 있습니다."

#: ../Doc/library/unittest.rst:1040
msgid ""
"The context manager will store the caught warning object in its "
":attr:`warning` attribute, and the source line which triggered the "
"warnings in the :attr:`filename` and :attr:`lineno` attributes. This can "
"be useful if the intention is to perform additional checks on the warning"
" caught::"
msgstr ""
"컨텍스트 관리자는 잡은 경고 객체를 :attr:`warning` 어트리뷰트에 저장하고, 경고를 발생한 소스코드 줄을 "
":attr:`filename`\\과 :attr:`lineno`\\에 저장할 것입니다. 이것은 발생한 경고에 대해서 추가적인 검사를 "
"수행하려는 경우에 유용할 수 있습니다::"

#: ../Doc/library/unittest.rst:1052
msgid ""
"This method works regardless of the warning filters in place when it is "
"called."
msgstr "이 메서드는 호출될 때 적용될 경고 필터와 관계없이 작동합니다."

#: ../Doc/library/unittest.rst:1064
msgid ""
"Like :meth:`assertWarns` but also tests that *regex* matches on the "
"message of the triggered warning.  *regex* may be a regular expression "
"object or a string containing a regular expression suitable for use by "
":func:`re.search`.  Example::"
msgstr ""
":meth:`assertWarns`\\와 비슷하지만 발생한 경고의 메시지가 *regex*\\에 일치하는지 테스트합니다. "
"*regex*\\는 정규식 객체나 :func:`re.search`\\에 사용되기 적합한 정규식 문자열이 될 수 있습니다. 예::"

#: ../Doc/library/unittest.rst:1085
msgid ""
"A context manager to test that at least one message is logged on the "
"*logger* or one of its children, with at least the given *level*."
msgstr "최소한 *level*\\로 *logger*\\나 그 자식들에 최소한 1개의 메시지가 기록되는지 테스트하는 컨텍스트 관리자입니다."

#: ../Doc/library/unittest.rst:1089
#, fuzzy
msgid ""
"If given, *logger* should be a :class:`logging.Logger` object or a "
":class:`str` giving the name of a logger.  The default is the root "
"logger, which will catch all messages that were not blocked by a non-"
"propagating descendent logger."
msgstr ""
"*logger*\\가 주어졌다면, :class:`logging.Logger` 객체이거나 로거의 이름인 "
":class:`str`\\이어야 합니다. 기본값은 모든 메시지를 잡을 루트 로거입니다."

#: ../Doc/library/unittest.rst:1094
msgid ""
"If given, *level* should be either a numeric logging level or its string "
"equivalent (for example either ``\"ERROR\"`` or :attr:`logging.ERROR`).  "
"The default is :attr:`logging.INFO`."
msgstr ""
"*level*\\이 주어졌다면, 로그 수준의 숫자 값이거나 그에 대응하는 문자열이어야 합니다(예를 들어 "
"``\"ERROR\"``\\이거나  :attr:`logging.ERROR`). 기본값은 "
":attr:`logging.INFO`\\입니다."

#: ../Doc/library/unittest.rst:1098
msgid ""
"The test passes if at least one message emitted inside the ``with`` block"
" matches the *logger* and *level* conditions, otherwise it fails."
msgstr ""
"만약 ``with`` 블록 안에서 *logger*\\와 *level* 조건을 만족하는 최소한 1개의 메시지가 나왔다면 테스트는 "
"성공하고, 그렇지 않으면 실패합니다."

#: ../Doc/library/unittest.rst:1101
msgid ""
"The object returned by the context manager is a recording helper which "
"keeps tracks of the matching log messages.  It has two attributes:"
msgstr ""
"컨텍스트 관리자에 의해 반환되는 객체는 조건에 일치하는 로그 메시지를 추적하기 위한 기록 도우미입니다. 이것은 2개의 어트리뷰트를 "
"가지고 있습니다:"

#: ../Doc/library/unittest.rst:1107
msgid "A list of :class:`logging.LogRecord` objects of the matching log messages."
msgstr "조건에 일치하는 메시지의 :class:`logging.LogRecord` 객체 목록."

#: ../Doc/library/unittest.rst:1112
msgid ""
"A list of :class:`str` objects with the formatted output of matching "
"messages."
msgstr "조건에 일치하는 메시지의 포맷 출력인 :class:`str` 객체 목록."

#: ../Doc/library/unittest.rst:1115
msgid "Example::"
msgstr "예::"

#: ../Doc/library/unittest.rst:1126
msgid ""
"There are also other methods used to perform more specific checks, such "
"as:"
msgstr "더 구체적인 검사를 수행하기 위한 또 다른 메서드가 있습니다, 아래와 같이:"

#: ../Doc/library/unittest.rst:1131
msgid ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"
msgstr ":meth:`assertAlmostEqual(a, b) <TestCase.assertAlmostEqual>`"

#: ../Doc/library/unittest.rst:1131
msgid "``round(a-b, 7) == 0``"
msgstr "``round(a-b, 7) == 0``"

#: ../Doc/library/unittest.rst:1134
msgid ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"
msgstr ":meth:`assertNotAlmostEqual(a, b) <TestCase.assertNotAlmostEqual>`"

#: ../Doc/library/unittest.rst:1134
msgid "``round(a-b, 7) != 0``"
msgstr "``round(a-b, 7) != 0``"

#: ../Doc/library/unittest.rst:1137
msgid ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"
msgstr ":meth:`assertGreater(a, b) <TestCase.assertGreater>`"

#: ../Doc/library/unittest.rst:1137
msgid "``a > b``"
msgstr "``a > b``"

#: ../Doc/library/unittest.rst:1140
msgid ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"
msgstr ":meth:`assertGreaterEqual(a, b) <TestCase.assertGreaterEqual>`"

#: ../Doc/library/unittest.rst:1140
msgid "``a >= b``"
msgstr "``a >= b``"

#: ../Doc/library/unittest.rst:1143
msgid ":meth:`assertLess(a, b) <TestCase.assertLess>`"
msgstr ":meth:`assertLess(a, b) <TestCase.assertLess>`"

#: ../Doc/library/unittest.rst:1143
msgid "``a < b``"
msgstr "``a < b``"

#: ../Doc/library/unittest.rst:1146
msgid ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"
msgstr ":meth:`assertLessEqual(a, b) <TestCase.assertLessEqual>`"

#: ../Doc/library/unittest.rst:1146
msgid "``a <= b``"
msgstr "``a <= b``"

#: ../Doc/library/unittest.rst:1149
msgid ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"
msgstr ":meth:`assertRegex(s, r) <TestCase.assertRegex>`"

#: ../Doc/library/unittest.rst:1149
msgid "``r.search(s)``"
msgstr "``r.search(s)``"

#: ../Doc/library/unittest.rst:1152
msgid ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"
msgstr ":meth:`assertNotRegex(s, r) <TestCase.assertNotRegex>`"

#: ../Doc/library/unittest.rst:1152
msgid "``not r.search(s)``"
msgstr "``not r.search(s)``"

#: ../Doc/library/unittest.rst:1155
msgid ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"
msgstr ":meth:`assertCountEqual(a, b) <TestCase.assertCountEqual>`"

#: ../Doc/library/unittest.rst:1155
msgid ""
"*a* and *b* have the same elements in the same number, regardless of "
"their order."
msgstr "순서와 상관없이 *a*\\와 *b*\\가 같은 개수의 같은 요소를 가졌는지."

#: ../Doc/library/unittest.rst:1164
msgid ""
"Test that *first* and *second* are approximately (or not approximately) "
"equal by computing the difference, rounding to the given number of "
"decimal *places* (default 7), and comparing to zero.  Note that these "
"methods round the values to the given number of *decimal places* (i.e. "
"like the :func:`round` function) and not *significant digits*."
msgstr ""
"*first*\\와 *second*\\가 근사하게 같은지(또는 근사하게 같지 않은지) 테스트합니다. 이는 값 차이를 계산하고, "
"주어진 소수 *자릿(places)*\\수(기본값 7)로 반올림한 뒤, 0과 비교하는 것으로 이루어집니다. 이 메서드는 값을 *유효 "
"숫자 자릿수(significant digits)*\\가 아닌 주어진 *소수 자릿수(decimal places)*\\(즉, "
":func:`round` 함수와 같이)로 반올림합니다. "

#: ../Doc/library/unittest.rst:1170
msgid ""
"If *delta* is supplied instead of *places* then the difference between "
"*first* and *second* must be less or equal to (or greater than) *delta*."
msgstr ""
"만약 *places* 대신에 *delta*\\가 주어진다면 *first*\\와 *second*\\의 값 차이는 반드시 "
"*delta*\\보다 작거나 같아야(또는 커야) 합니다."

#: ../Doc/library/unittest.rst:1173
msgid "Supplying both *delta* and *places* raises a :exc:`TypeError`."
msgstr "*delta*\\와 *places*\\가 동시에 주어지면 :exc:`TypeError`\\가 발생합니다."

#: ../Doc/library/unittest.rst:1175
msgid ""
":meth:`assertAlmostEqual` automatically considers almost equal objects "
"that compare equal.  :meth:`assertNotAlmostEqual` automatically fails if "
"the objects compare equal.  Added the *delta* keyword argument."
msgstr ""
":meth:`assertAlmostEqual`\\은 같다고 비교되는 거의 동등한 객체를 자동으로 고려합니다. "
":meth:`assertNotAlmostEqual`\\은 객체가 같다고 비교되면 자동으로 실패합니다. *delta* 키워드 인자를 "
"추가."

#: ../Doc/library/unittest.rst:1186
msgid ""
"Test that *first* is respectively >, >=, < or <= than *second* depending "
"on the method name.  If not, the test will fail::"
msgstr ""
"*first*\\를 *second*\\와 비교해서 각각 메서드 이름에 해당하는 >, >=, <, <= 인지 테스트합니다. 그렇지 "
"않으면 테스트는 실패합니다::"

#: ../Doc/library/unittest.rst:1198
msgid ""
"Test that a *regex* search matches (or does not match) *text*.  In case "
"of failure, the error message will include the pattern and the *text* (or"
" the pattern and the part of *text* that unexpectedly matched).  *regex* "
"may be a regular expression object or a string containing a regular "
"expression suitable for use by :func:`re.search`."
msgstr ""
"*regex* 검색이 *text*\\에 일치하는지(아닌지) 테스트합니다. 실패의 경우, 에러 메시지는 패턴과 *text*\\(또는 "
"패턴과 예상과 달리 일치한 *text*\\의 부분)를 포함할 것입니다. *regex*\\는 정규식 객체나 "
":func:`re.search`\\에 사용되기 적합한 정규식 문자열이 될 수 있습니다."

#: ../Doc/library/unittest.rst:1204
msgid "Added under the name ``assertRegexpMatches``."
msgstr "``assertRegexpMatches`` 라는 이름으로 추가되었습니다."

#: ../Doc/library/unittest.rst:1206
msgid ""
"The method ``assertRegexpMatches()`` has been renamed to "
":meth:`.assertRegex`."
msgstr "``assertRegexpMatches()`` 메서드가 :meth:`.assertRegex`\\로 이름 변경되었습니다."

#: ../Doc/library/unittest.rst:1209
msgid ":meth:`.assertNotRegex`."
msgstr ":meth:`.assertNotRegex`."

#: ../Doc/library/unittest.rst:1211
msgid ""
"The name ``assertNotRegexpMatches`` is a deprecated alias for "
":meth:`.assertNotRegex`."
msgstr "``assertNotRegexpMatches``\\이름은 :meth:`.assertNotRegex`\\의 폐지된 에일리어스입니다."

#: ../Doc/library/unittest.rst:1218
msgid ""
"Test that sequence *first* contains the same elements as *second*, "
"regardless of their order. When they don't, an error message listing the "
"differences between the sequences will be generated."
msgstr ""
"*first* 시퀀스가 순서에 상관없이 *second*\\와 같은 요소를 포함하는지 테스트합니다. 그렇지 않은 경우, 시퀀스들의 "
"차이를 나열한 에러 메시지가 생성됩니다."

#: ../Doc/library/unittest.rst:1222
msgid ""
"Duplicate elements are *not* ignored when comparing *first* and *second*."
" It verifies whether each element has the same count in both sequences. "
"Equivalent to: ``assertEqual(Counter(list(first)), "
"Counter(list(second)))`` but works with sequences of unhashable objects "
"as well."
msgstr ""
"*first*\\와 *second*\\를 비교할 때 중복된 요소는 무시하지 *않습니다*. 두 개의 시퀀스에 각 요소가 같은 수 만큼"
" 있는 것을 확인합니다. ``assertEqual(Counter(list(first)), "
"Counter(list(second)))``\\와 같지만 해시 불가능한(unhashable) 시퀀스에도 작동합니다."

#: ../Doc/library/unittest.rst:1233
msgid ""
"The :meth:`assertEqual` method dispatches the equality check for objects "
"of the same type to different type-specific methods.  These methods are "
"already implemented for most of the built-in types, but it's also "
"possible to register new methods using :meth:`addTypeEqualityFunc`:"
msgstr ""
":meth:`assertEqual` 메서드는 같은 형의 객체의 동등성 검사를 다른 형-특화 메서드에게로 보냅니다. 이러한 메서드들은"
" 대부분의 내장 형에 대해서 이미 구현되어 있지만, :meth:`addTypeEqualityFunc`\\을 사용하여 새로운 메서드를"
" 등록하는 것도 가능합니다:"

#: ../Doc/library/unittest.rst:1240
msgid ""
"Registers a type-specific method called by :meth:`assertEqual` to check "
"if two objects of exactly the same *typeobj* (not subclasses) compare "
"equal.  *function* must take two positional arguments and a third "
"msg=None keyword argument just as :meth:`assertEqual` does.  It must "
"raise :data:`self.failureException(msg) <failureException>` when "
"inequality between the first two parameters is detected -- possibly "
"providing useful information and explaining the inequalities in details "
"in the error message."
msgstr ""
"정확히 같은 (서브 클래스가 아닌) *typeobj* 형의 두 객체가 같은지 비교 검사하기 위해 "
":meth:`assertEqual`\\한테 불리는 형-특화 메서드를 등록합니다. *function*\\은 반드시 2개의 위치 인자를"
" 받아야 하고 :meth:`assertEqual`\\이 그러한 것처럼 msg=None 키워드 인자를 세 번째로 받아야 합니다. "
"이것은 처음 2개의 매개변수가 같지 않은 것이 확인될 경우 :data:`self.failureException(msg) "
"<failureException>`\\을 반드시 발생시켜야 합니다 -- 에러 메시지에 유용한 정보를 제공하고 비동등성을 자세히 "
"설명할 수 있을 것입니다."

#: ../Doc/library/unittest.rst:1251
msgid ""
"The list of type-specific methods automatically used by "
":meth:`~TestCase.assertEqual` are summarized in the following table.  "
"Note that it's usually not necessary to invoke these methods directly."
msgstr ""
":meth:`~TestCase.assertEqual`\\에서 자동으로 사용하는 형-특화 메서드 목록은 다음 표에 정리되어 있습니다."
" 보통은 이 메서드를 직접 부를 필요가 없다는 것을 기억하십시오."

#: ../Doc/library/unittest.rst:1256
msgid "Used to compare"
msgstr "을 비교하기 위해"

#: ../Doc/library/unittest.rst:1258
msgid ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"
msgstr ":meth:`assertMultiLineEqual(a, b) <TestCase.assertMultiLineEqual>`"

#: ../Doc/library/unittest.rst:1258
msgid "strings"
msgstr "문자열"

#: ../Doc/library/unittest.rst:1261
msgid ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"
msgstr ":meth:`assertSequenceEqual(a, b) <TestCase.assertSequenceEqual>`"

#: ../Doc/library/unittest.rst:1261
msgid "sequences"
msgstr "시퀀스"

#: ../Doc/library/unittest.rst:1264
msgid ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"
msgstr ":meth:`assertListEqual(a, b) <TestCase.assertListEqual>`"

#: ../Doc/library/unittest.rst:1264
msgid "lists"
msgstr "리스트"

#: ../Doc/library/unittest.rst:1267
msgid ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"
msgstr ":meth:`assertTupleEqual(a, b) <TestCase.assertTupleEqual>`"

#: ../Doc/library/unittest.rst:1267
msgid "tuples"
msgstr "튜플"

#: ../Doc/library/unittest.rst:1270
msgid ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"
msgstr ":meth:`assertSetEqual(a, b) <TestCase.assertSetEqual>`"

#: ../Doc/library/unittest.rst:1270
msgid "sets or frozensets"
msgstr "집합 또는 불변 집합"

#: ../Doc/library/unittest.rst:1273
msgid ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"
msgstr ":meth:`assertDictEqual(a, b) <TestCase.assertDictEqual>`"

#: ../Doc/library/unittest.rst:1273
msgid "dicts"
msgstr "딕셔너리"

#: ../Doc/library/unittest.rst:1281
msgid ""
"Test that the multiline string *first* is equal to the string *second*. "
"When not equal a diff of the two strings highlighting the differences "
"will be included in the error message. This method is used by default "
"when comparing strings with :meth:`assertEqual`."
msgstr ""
"여러 줄 문자열인 *first*\\와 *second*\\가 같은지 테스트합니다. 같지 않을 경우 에러 메시지에 다른 부분이 강조된 "
"두 문자열의 차이가 포함됩니다. 이 메서드는 :meth:`assertEqual`\\에서 문자열을 비교할 때 기본적으로 사용됩니다."

#: ../Doc/library/unittest.rst:1291
msgid ""
"Tests that two sequences are equal.  If a *seq_type* is supplied, both "
"*first* and *second* must be instances of *seq_type* or a failure will be"
" raised.  If the sequences are different an error message is constructed "
"that shows the difference between the two."
msgstr ""
"2개의 시퀀스가 같은지 테스트합니다. *seq_type*\\이 전달된 경우, *first*\\와 *second* 둘 다 "
"*seq_type*\\의 인스턴스이어야 하고 그렇지 않은 경우 실패가 발생합니다. 시퀀스가 다른 경우, 에러 메시지는 2개 사이의 "
"차이점을 보여주게 됩니다."

#: ../Doc/library/unittest.rst:1296
msgid ""
"This method is not called directly by :meth:`assertEqual`, but it's used "
"to implement :meth:`assertListEqual` and :meth:`assertTupleEqual`."
msgstr ""
"이 메서드는 :meth:`assertEqual`\\에서 직접 호출되진 않지만, :meth:`assertListEqual`\\와 "
":meth:`assertTupleEqual`\\을 구현할 때 사용됩니다."

#: ../Doc/library/unittest.rst:1306
msgid ""
"Tests that two lists or tuples are equal.  If not, an error message is "
"constructed that shows only the differences between the two.  An error is"
" also raised if either of the parameters are of the wrong type. These "
"methods are used by default when comparing lists or tuples with "
":meth:`assertEqual`."
msgstr ""
"2개의 리스트나 튜플이 같은지 테스트합니다. 만약 같지 않다면 에러 메시지는 2개 사이의 차이점만 보여주게 됩니다. 매개변수 중 "
"하나가 잘못된 형인 경우 에러가 발생합니다. 이 메서드는 :meth:`assertEqual`\\에서 리스트와 튜플을 비교할 때 "
"기본적으로 사용됩니다."

#: ../Doc/library/unittest.rst:1317
msgid ""
"Tests that two sets are equal.  If not, an error message is constructed "
"that lists the differences between the sets.  This method is used by "
"default when comparing sets or frozensets with :meth:`assertEqual`."
msgstr ""
"2개의 집합이 같은지 테스트합니다. 같지 않은 경우 에러 메시지는 집합 사이의 차이를 나열하게 됩니다. 이 메서드는 "
":meth:`assertEqual`\\에서 집합이나 불변 집합을 비교할 때 기본적으로 사용됩니다."

#: ../Doc/library/unittest.rst:1321
msgid ""
"Fails if either of *first* or *second* does not have a "
":meth:`set.difference` method."
msgstr "*first*\\와 *second* 중 하나가 :meth:`set.difference` 메서드를 가지고 있지 않으면 실패합니다."

#: ../Doc/library/unittest.rst:1329
msgid ""
"Test that two dictionaries are equal.  If not, an error message is "
"constructed that shows the differences in the dictionaries. This method "
"will be used by default to compare dictionaries in calls to "
":meth:`assertEqual`."
msgstr ""
"2개의 딕셔너리가 같은지 테스트합니다. 같지 않은 경우 에러 메시지는 딕셔너리 사이의 차이를 보여주게 됩니다. 이 메서드는 "
":meth:`assertEqual`\\에서 딕셔너리를 비교할 때 기본적으로 사용될 것입니다."

#: ../Doc/library/unittest.rst:1340
msgid ""
"Finally the :class:`TestCase` provides the following methods and "
"attributes:"
msgstr "마지막으로 :class:`TestCase`\\가 다음의 메서드와 어트리뷰트를 제공합니다:"

#: ../Doc/library/unittest.rst:1345
msgid ""
"Signals a test failure unconditionally, with *msg* or ``None`` for the "
"error message."
msgstr "무조건 테스트 실패 신호를 보냅니다, 에러 메시지를 위해 *msg*\\나 ``None``\\을 전달합니다."

#: ../Doc/library/unittest.rst:1351
msgid ""
"This class attribute gives the exception raised by the test method.  If a"
" test framework needs to use a specialized exception, possibly to carry "
"additional information, it must subclass this exception in order to "
"\"play fair\" with the framework.  The initial value of this attribute is"
" :exc:`AssertionError`."
msgstr ""
"이 클래스 어트리뷰트는 테스트 메서드에서 발생한 예외를 줍니다. 만약 테스트 프레임워크가 추가 정보를 전달하기 위해 특수한 예외를 "
"사용할 필요가 있다면, 프레임워크와 \"공정하게 행동하기\" 위해서 이 예외를 서브 클래스해야 합니다. 이 어트리뷰트의 초깃값은 "
":exc:`AssertionError` 입니다."

#: ../Doc/library/unittest.rst:1360
msgid ""
"This class attribute determines what happens when a custom failure "
"message is passed as the msg argument to an assertXYY call that fails. "
"``True`` is the default value. In this case, the custom message is "
"appended to the end of the standard failure message. When set to "
"``False``, the custom message replaces the standard message."
msgstr ""
"이 클래스 어트리뷰트는 실패한 assertXYY 호출에 msg 인자로 전달된 사용자 정의 실패 메시지가 어떻게 동작하는지를 "
"결정합니다. ``True``\\가 기본값입니다. 이 경우, 사용자 정의 메시지가 표준 실패 메시지 끝에 추가됩니다. "
"``False``\\로 설정할 경우 사용자 정의 메시지가 표준 메시지를 대체합니다."

#: ../Doc/library/unittest.rst:1366
msgid ""
"The class setting can be overridden in individual test methods by "
"assigning an instance attribute, self.longMessage, to ``True`` or "
"``False`` before calling the assert methods."
msgstr ""
"이 클래스 설정은 인스턴스 어트리뷰트를 설정하여 개별 테스트 메서드에 의해 재정의될 수 있습니다, assert 메서드를 호출하기 "
"전에 self.longMessage를 ``True`` 또는 ``False``\\로 설정하는 것입니다."

#: ../Doc/library/unittest.rst:1370
msgid "The class setting gets reset before each test call."
msgstr "이 클래스 설정은 각 테스트 호출 전에 재설정됩니다."

#: ../Doc/library/unittest.rst:1377
msgid ""
"This attribute controls the maximum length of diffs output by assert "
"methods that report diffs on failure. It defaults to 80*8 characters. "
"Assert methods affected by this attribute are :meth:`assertSequenceEqual`"
" (including all the sequence comparison methods that delegate to it), "
":meth:`assertDictEqual` and :meth:`assertMultiLineEqual`."
msgstr ""
"이 어트리뷰트는 실패 시 diff를 보고하는 assert 메서드의 최대 diff 출력 길이를 설정합니다. 기본값은 80*8 "
"문자입니다. 이 어트리뷰트에 영향을 받는 assert 메서드는 :meth:`assertSequenceEqual`\\(이것에 위임하는"
" 모든 시퀀스 비교 메서드를 포함), :meth:`assertDictEqual`, "
":meth:`assertMultiLineEqual` 입니다."

#: ../Doc/library/unittest.rst:1384
msgid ""
"Setting ``maxDiff`` to ``None`` means that there is no maximum length of "
"diffs."
msgstr "``maxDiff``\\를 ``None``\\으로 설정하면 diff의 최대 길이 제한이 없어지는 것을 뜻합니다."

#: ../Doc/library/unittest.rst:1390
msgid ""
"Testing frameworks can use the following methods to collect information "
"on the test:"
msgstr "테스트 프레임워크는 테스트에 관한 정보를 수집하기 위해 다음의 메서드를 사용할 수 있습니다:"

#: ../Doc/library/unittest.rst:1396
msgid ""
"Return the number of tests represented by this test object.  For "
":class:`TestCase` instances, this will always be ``1``."
msgstr ""
"이 테스트 객체에 해당하는 테스트 개수를 반환합니다. :class:`TestCase` 인스턴스에 대해서는 이것은 항상 "
"``1``\\입니다."

#: ../Doc/library/unittest.rst:1402
msgid ""
"Return an instance of the test result class that should be used for this "
"test case class (if no other result instance is provided to the "
":meth:`run` method)."
msgstr ""
"이 테스트 케이스 클래스를 위해서 사용되는 테스트 결과 클래스의 인스턴스를 반환합니다(:meth:`run` 메서드에 다른 결과 "
"인스턴스가 전달되지 않은 경우에)."

#: ../Doc/library/unittest.rst:1406
msgid ""
"For :class:`TestCase` instances, this will always be an instance of "
":class:`TestResult`; subclasses of :class:`TestCase` should override this"
" as necessary."
msgstr ""
":class:`TestCase` 인스턴스에 대해서는 이것은 항상 :class:`TestResult`\\의 인스턴스입니다; "
":class:`TestCase`\\의 서브 클래스는 이것을 필요에 따라 재정의해야 합니다. "

#: ../Doc/library/unittest.rst:1413
msgid ""
"Return a string identifying the specific test case.  This is usually the "
"full name of the test method, including the module and class name."
msgstr ""
"특정 테스트 케이스를 식별하는 문자열을 반환합니다. 이것은 보통 모듈과 클래스 이름을 포함한 테스트 메서드의 완전한 이름(full "
"name)입니다. "

#: ../Doc/library/unittest.rst:1419
msgid ""
"Returns a description of the test, or ``None`` if no description has been"
" provided.  The default implementation of this method returns the first "
"line of the test method's docstring, if available, or ``None``."
msgstr ""
"테스트의 설명을 반환하거나 설명이 제공되지 않았으면 ``None``\\을 반환합니다. 이 메서드의 기본 구현은 가능하다면 테스트 "
"메서드의 독스트링의 첫 번째 줄을 반환하고 그렇지 않으면 ``None``\\을 반환합니다. "

#: ../Doc/library/unittest.rst:1424
msgid ""
"In 3.1 this was changed to add the test name to the short description "
"even in the presence of a docstring.  This caused compatibility issues "
"with unittest extensions and adding the test name was moved to the "
":class:`TextTestResult` in Python 3.2."
msgstr ""
"3.1 버전에서 docstring이 있는 경우에도 짧은 설명에 테스트 이름을 추가하도록 변경되었습니다. 이것은 unittest "
"확장과 호환성 문제를 일으켰고 테스트 이름 추가는 파이썬 3.2에서 :class:`TextTestResult`\\로 옮겨졌습니다."

#: ../Doc/library/unittest.rst:1433
msgid ""
"Add a function to be called after :meth:`tearDown` to cleanup resources "
"used during the test. Functions will be called in reverse order to the "
"order they are added (:abbr:`LIFO (last-in, first-out)`).  They are "
"called with any arguments and keyword arguments passed into "
":meth:`addCleanup` when they are added."
msgstr ""
"테스트 중에 사용된 자원을 정리하기 위해 :meth:`tearDown` 이후에 불리는 함수를 추가합니다. 함수들은 추가된 순서의 "
"반대 순서대로 불리게 됩니다(:abbr:`LIFO(후입 선출법(last-in, first-out))`). 함수가 추가될 때 "
":meth:`addCleanup`\\에 같이 전달된 위치 인자나 키워드 인자와 함께 호출됩니다. "

#: ../Doc/library/unittest.rst:1439
msgid ""
"If :meth:`setUp` fails, meaning that :meth:`tearDown` is not called, then"
" any cleanup functions added will still be called."
msgstr ""
"만약 :meth:`setUp`\\이 실패한다면, 즉 :meth:`tearDown`\\이 불리지 않더라도, 정리 함수들은 여전히 "
"불리게 될 것입니다."

#: ../Doc/library/unittest.rst:1447
msgid ""
"This method is called unconditionally after :meth:`tearDown`, or after "
":meth:`setUp` if :meth:`setUp` raises an exception."
msgstr ""
"이 메서드는 :meth:`tearDown` 이후나, :meth:`setUp`\\이 예외를 발생시키면 "
":meth:`setUp`\\이후에 조건 없이 호출됩니다."

#: ../Doc/library/unittest.rst:1450
msgid ""
"It is responsible for calling all the cleanup functions added by "
":meth:`addCleanup`. If you need cleanup functions to be called *prior* to"
" :meth:`tearDown` then you can call :meth:`doCleanups` yourself."
msgstr ""
":meth:`addCleanup`\\에서 추가된 모든 정리 함수들을 호출하는 책임이 있습니다. 만약 정리 함수를 "
":meth:`tearDown` *이전에* 불러야 할 필요가 있다면 :meth:`doCleanups`\\를 직접 부를 수 있습니다. "

#: ../Doc/library/unittest.rst:1455
msgid ""
":meth:`doCleanups` pops methods off the stack of cleanup functions one at"
" a time, so it can be called at any time."
msgstr ":meth:`doCleanups`\\는 한 번에 하나씩 정리 함수 스택에서 메서드를 꺼내기 때문에 언제든지 호출될 수 있습니다."

#: ../Doc/library/unittest.rst:1462
msgid ""
"Add a function to be called after :meth:`tearDownClass` to cleanup "
"resources used during the test class. Functions will be called in reverse"
" order to the order they are added (:abbr:`LIFO (last-in, first-out)`). "
"They are called with any arguments and keyword arguments passed into "
":meth:`addClassCleanup` when they are added."
msgstr ""
"테스트 클래스 중에 사용된 자원을 정리하기 위해 :meth:`tearDownClass` 이후에 불리는 함수를 추가합니다. 함수들은 "
"추가된 순서의 반대 순서대로 불리게 됩니다(:abbr:`LIFO(후입 선출법(last-in, first-out))`). 함수가 "
"추가될 때 :meth:`addClassCleanup`\\에 같이 전달된 위치 인자나 키워드 인자와 함께 호출됩니다. "

#: ../Doc/library/unittest.rst:1468
msgid ""
"If :meth:`setUpClass` fails, meaning that :meth:`tearDownClass` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"만약 :meth:`setUpClass`\\가 실패한다면, 즉 :meth:`tearDownClass`\\가 불리지 않더라도, 정리 "
"함수들은 여전히 불리게 될 것입니다."

#: ../Doc/library/unittest.rst:1476
msgid ""
"This method is called unconditionally after :meth:`tearDownClass`, or "
"after :meth:`setUpClass` if :meth:`setUpClass` raises an exception."
msgstr ""
"이 메서드는 :meth:`tearDownClass` 이후나, :meth:`setUpClass`\\이 예외를 발생시키면 "
":meth:`setUpClass`\\이후에 조건 없이 호출됩니다."

#: ../Doc/library/unittest.rst:1479
msgid ""
"It is responsible for calling all the cleanup functions added by "
":meth:`addCleanupClass`. If you need cleanup functions to be called "
"*prior* to :meth:`tearDownClass` then you can call "
":meth:`doCleanupsClass` yourself."
msgstr ""
":meth:`addCleanupClass`\\에서 추가된 모든 정리 함수들을 호출하는 책임이 있습니다. 만약 정리 함수를 "
":meth:`tearDownClass` *이전에* 불러야 할 필요가 있다면 :meth:`doCleanupsClass`\\를 직접 "
"부를 수 있습니다. "

#: ../Doc/library/unittest.rst:1484
msgid ""
":meth:`doCleanupsClass` pops methods off the stack of cleanup functions "
"one at a time, so it can be called at any time."
msgstr ""
":meth:`doCleanupsClass`\\는 한 번에 하나씩 정리 함수 스택에서 메서드를 꺼내기 때문에 언제든지 호출될 수 "
"있습니다."

#: ../Doc/library/unittest.rst:1492
msgid ""
"This class provides an API similar to :class:`TestCase` and also accepts "
"coroutines as test functions."
msgstr "이 클래스는 :class:`TestCase`\\와 유사한 API를 제공하며 코루틴을 테스트 함수로 받아들입니다."

#: ../Doc/library/unittest.rst:1499
msgid ""
"Method called to prepare the test fixture. This is called after "
":meth:`setUp`. This is called immediately before calling the test method;"
" other than :exc:`AssertionError` or :exc:`SkipTest`, any exception "
"raised by this method will be considered an error rather than a test "
"failure. The default implementation does nothing."
msgstr ""
"테스트 픽스쳐를 준비하기 위해 호출되는 메서드입니다. 이 메서드는 :meth:`setUp`\\이후에 호출됩니다. 이 메서드는 테스트"
" 메서드를 호출하기 바로 직전에 호출됩니다; :exc:`AssertionError` 또는 :exc:`SkipTest`\\이외의 이 "
"메서드에서 발생한 모든 예외는 테스트 실패가 아닌 오류로 간주합니다. 기본 구현은 아무것도 하지 않습니다."

#: ../Doc/library/unittest.rst:1507
msgid ""
"Method called immediately after the test method has been called and the "
"result recorded.  This is called before :meth:`tearDown`. This is called "
"even if the test method raised an exception, so the implementation in "
"subclasses may need to be particularly careful about checking internal "
"state.  Any exception, other than :exc:`AssertionError` or "
":exc:`SkipTest`, raised by this method will be considered an additional "
"error rather than a test failure (thus increasing the total number of "
"reported errors). This method will only be called if the "
":meth:`asyncSetUp` succeeds, regardless of the outcome of the test "
"method. The default implementation does nothing."
msgstr ""
"테스트 메서드가 불리고 결과가 기록되고 나서 바로 다음에 호출되는 메서드입니다. 이 메서드는 :meth:`tearDown`\\전에 "
"호출됩니다. 테스트 메서드가 예외를 발생했더라도 이 메서드는 불립니다, 따라서 서브 클래스의 구현은 내부 상태를 확인하는 데 특별히"
" 주의를 기울여야 합니다. :exc:`AssertionError` 또는 :exc:`SkipTest`\\이외의 이 메서드에서 발생하는"
" 모든 예외는 테스트 실패가 아닌 오류로 간주합니다(따라서 보고된 오류의 총 숫자가 증가합니다). 이 메서드는 테스트 메서드의 "
"결과물에 영향받지 않고 :meth:`asyncSetUp`\\이 성공했을 때만 불립니다. 기본 구현은 아무것도 하지 않습니다."

#: ../Doc/library/unittest.rst:1519
msgid "This method accepts a coroutine that can be used as a cleanup function."
msgstr "이 메서드는 정리 함수로 사용할 수 있는 코루틴을 받아들입니다."

#: ../Doc/library/unittest.rst:1523
msgid ""
"Sets up a new event loop to run the test, collecting the result into the "
":class:`TestResult` object passed as *result*.  If *result* is omitted or"
" ``None``, a temporary result object is created (by calling the "
":meth:`defaultTestResult` method) and used. The result object is returned"
" to :meth:`run`'s caller. At the end of the test all the tasks in the "
"event loop are cancelled."
msgstr ""
"테스트를 실행하기 위한 새 이벤트 루프를 설정하고, *result* 인자로 전달된 :class:`TestResult`\\에 결과를 "
"수집합니다. 만약 *result* 인자가 전달 안 되거나 ``None``\\이라면 임시 결과 객체를 "
"(:meth:`defaultTestResult` 메서드를 불러서) 생성하여 사용합니다. :meth:`run` 호출자에게 결과 객체를"
" 반환합니다. 테스트의 끝에서 이벤트 루프의 모든 태스크는 취소됩니다."

#: ../Doc/library/unittest.rst:1531
msgid "An example illustrating the order::"
msgstr "순서를 보여주는 예::"

#: ../Doc/library/unittest.rst:1567
msgid ""
"After running the test, ``events`` would contain ``[\"setUp\", "
"\"asyncSetUp\", \"test_response\", \"asyncTearDown\", \"tearDown\", "
"\"cleanup\"]``."
msgstr ""
"테스트를 실행한 후, ``events``\\에는 ``[\"setUp\", \"asyncSetUp\", "
"\"test_response\", \"asyncTearDown\", \"tearDown\", \"cleanup\"]``\\가 "
"포함됩니다."

#: ../Doc/library/unittest.rst:1572
msgid ""
"This class implements the portion of the :class:`TestCase` interface "
"which allows the test runner to drive the test, but does not provide the "
"methods which test code can use to check and report errors.  This is used"
" to create test cases using legacy test code, allowing it to be "
"integrated into a :mod:`unittest`-based test framework."
msgstr ""
"이 클래스는 테스트 실행자가 테스트를 수행할 수 있게 :class:`TestCase` 인터페이스 일부를 구현합니다, 하지만 테스트 "
"코드가 검사하거나 에러를 보고하는 데 사용하는 메서드를 제공하지는 않습니다. 이것은 레거시 테스트 코드를 사용하여 테스트 케이스를 "
"생성할 때 사용할 수 있습니다, 이것은 레거시 테스트 코드가 :mod:`unittest`-기반 테스트 프레임워크에 통합될 수 있게 "
"해줍니다."

#: ../Doc/library/unittest.rst:1582
msgid "Deprecated aliases"
msgstr "폐지된 에일리어스"

#: ../Doc/library/unittest.rst:1584
msgid ""
"For historical reasons, some of the :class:`TestCase` methods had one or "
"more aliases that are now deprecated.  The following table lists the "
"correct names along with their deprecated aliases:"
msgstr ""
"역사적인 이유로 인해 :class:`TestCase` 메서드의 일부는 지금은 폐지된 에일리어스를 1개 또는 그 이상 가졌습니다. "
"다음 표는 폐지된 에일리어스과 그에 맞는 올바른 이름을 나열합니다:"

#: ../Doc/library/unittest.rst:1589
msgid "Method Name"
msgstr "메서드 이름"

#: ../Doc/library/unittest.rst:1589
msgid "Deprecated alias"
msgstr "폐지된 에일리어스"

#: ../Doc/library/unittest.rst:1591
msgid ":meth:`.assertEqual`"
msgstr ":meth:`.assertEqual`"

#: ../Doc/library/unittest.rst:1591
msgid "failUnlessEqual"
msgstr "failUnlessEqual"

#: ../Doc/library/unittest.rst:1591
msgid "assertEquals"
msgstr "assertEquals"

#: ../Doc/library/unittest.rst:1592
msgid ":meth:`.assertNotEqual`"
msgstr ":meth:`.assertNotEqual`"

#: ../Doc/library/unittest.rst:1592
msgid "failIfEqual"
msgstr "failIfEqual"

#: ../Doc/library/unittest.rst:1592
msgid "assertNotEquals"
msgstr "assertNotEquals"

#: ../Doc/library/unittest.rst:1593
msgid ":meth:`.assertTrue`"
msgstr ":meth:`.assertTrue`"

#: ../Doc/library/unittest.rst:1593
msgid "failUnless"
msgstr "failUnless"

#: ../Doc/library/unittest.rst:1593
msgid "assert\\_"
msgstr "assert\\_"

#: ../Doc/library/unittest.rst:1594
msgid ":meth:`.assertFalse`"
msgstr ":meth:`.assertFalse`"

#: ../Doc/library/unittest.rst:1594
msgid "failIf"
msgstr "failIf"

#: ../Doc/library/unittest.rst:1595
msgid ":meth:`.assertRaises`"
msgstr ":meth:`.assertRaises`"

#: ../Doc/library/unittest.rst:1595
msgid "failUnlessRaises"
msgstr "failUnlessRaises"

#: ../Doc/library/unittest.rst:1596
msgid ":meth:`.assertAlmostEqual`"
msgstr ":meth:`.assertAlmostEqual`"

#: ../Doc/library/unittest.rst:1596
msgid "failUnlessAlmostEqual"
msgstr "failUnlessAlmostEqual"

#: ../Doc/library/unittest.rst:1596
msgid "assertAlmostEquals"
msgstr "assertAlmostEquals"

#: ../Doc/library/unittest.rst:1597
msgid ":meth:`.assertNotAlmostEqual`"
msgstr ":meth:`.assertNotAlmostEqual`"

#: ../Doc/library/unittest.rst:1597
msgid "failIfAlmostEqual"
msgstr "failIfAlmostEqual"

#: ../Doc/library/unittest.rst:1597
msgid "assertNotAlmostEquals"
msgstr "assertNotAlmostEquals"

#: ../Doc/library/unittest.rst:1598
msgid ":meth:`.assertRegex`"
msgstr ":meth:`.assertRegex`"

#: ../Doc/library/unittest.rst:1598
msgid "assertRegexpMatches"
msgstr "assertRegexpMatches"

#: ../Doc/library/unittest.rst:1599
msgid ":meth:`.assertNotRegex`"
msgstr ":meth:`.assertNotRegex`"

#: ../Doc/library/unittest.rst:1599
msgid "assertNotRegexpMatches"
msgstr "assertNotRegexpMatches"

#: ../Doc/library/unittest.rst:1600
msgid ":meth:`.assertRaisesRegex`"
msgstr ":meth:`.assertRaisesRegex`"

#: ../Doc/library/unittest.rst:1600
msgid "assertRaisesRegexp"
msgstr "assertRaisesRegexp"

#: ../Doc/library/unittest.rst:1603
msgid "The fail* aliases listed in the second column have been deprecated."
msgstr "두 번째 열에 나열된 fail* 에일리어스는 폐지되었습니다."

#: ../Doc/library/unittest.rst:1605
msgid "The assert* aliases listed in the third column have been deprecated."
msgstr "세 번째 열에 나열된 assert* 에일리어스는 폐지되었습니다."

#: ../Doc/library/unittest.rst:1607
msgid ""
"``assertRegexpMatches`` and ``assertRaisesRegexp`` have been renamed to "
":meth:`.assertRegex` and :meth:`.assertRaisesRegex`."
msgstr ""
"``assertRegexpMatches``\\와 ``assertRaisesRegexp``\\는 "
":meth:`.assertRegex`\\와 :meth:`.assertRaisesRegex`\\로 이름이 변경되었습니다."

#: ../Doc/library/unittest.rst:1610
msgid ""
"The ``assertNotRegexpMatches`` name is deprecated in favor of "
":meth:`.assertNotRegex`."
msgstr "``assertNotRegexpMatches`` 이름은 폐지되고 :meth:`.assertNotRegex`\\으로 대체합니다."

#: ../Doc/library/unittest.rst:1616
msgid "Grouping tests"
msgstr "테스트 분류"

#: ../Doc/library/unittest.rst:1620
msgid ""
"This class represents an aggregation of individual test cases and test "
"suites. The class presents the interface needed by the test runner to "
"allow it to be run as any other test case.  Running a :class:`TestSuite` "
"instance is the same as iterating over the suite, running each test "
"individually."
msgstr ""
"이 클래스는 개별 테스트 케이스와 테스트 묶음의 집합체를 나타냅니다. 이 클래스는 테스트 실행자가 이것을 다른 테스트 케이스처럼 "
"실행할 수 있기 위해 필요한 인터페이스를 제공합니다. :class:`TestSuite` 인스턴스를 실행하는 것은 테스트 묶음을 "
"이터레이션하면서 각 테스트를 개별적으로 실행하는 것과 같습니다."

#: ../Doc/library/unittest.rst:1625
msgid ""
"If *tests* is given, it must be an iterable of individual test cases or "
"other test suites that will be used to build the suite initially. "
"Additional methods are provided to add test cases and suites to the "
"collection later on."
msgstr ""
"*tests*\\가 주어졌다면, 그것은 초기에 이 테스트 묶음을 만들 때 사용될 개별 테스트 케이스이거나 다른 테스트 묶음의 "
"이터러블이어야 합니다. 나중에 컬렉션에 테스트 케이스나 테스트 묶음을 추가할 수 있는 추가 메서드가 제공됩니다."

#: ../Doc/library/unittest.rst:1629
msgid ""
":class:`TestSuite` objects behave much like :class:`TestCase` objects, "
"except they do not actually implement a test.  Instead, they are used to "
"aggregate tests into groups of tests that should be run together. Some "
"additional methods are available to add tests to :class:`TestSuite` "
"instances:"
msgstr ""
":class:`TestSuite` 객체는 :class:`TestCase` 객체와 흡사하게 행동합니다만, 테스트를 실제로 구현하지 "
"않는 것이 다릅니다. 대신에, 이것은 다 같이 실행되어야 하는 테스트 그룹에 테스트들을 모으는 데 사용됩니다. "
":class:`TestSuite` 인스턴스에 테스트를 추가하기 위해 몇몇 추가적인 메서드를 사용할 수 있습니다."

#: ../Doc/library/unittest.rst:1637
msgid "Add a :class:`TestCase` or :class:`TestSuite` to the suite."
msgstr "테스트 묶음에 :class:`TestCase`\\나 :class:`TestSuite` 추가하기."

#: ../Doc/library/unittest.rst:1642
msgid ""
"Add all the tests from an iterable of :class:`TestCase` and "
":class:`TestSuite` instances to this test suite."
msgstr ""
"이 테스트 묶음에 :class:`TestCase`\\와 :class:`TestSuite` 인스턴스의 이터러블에서 나온 모든 테스트를"
" 추가하기."

#: ../Doc/library/unittest.rst:1645
msgid ""
"This is equivalent to iterating over *tests*, calling :meth:`addTest` for"
" each element."
msgstr "이것은 *tests*\\를 이터레이션하면서 각 요소에 대해 :meth:`addTest`\\를 호출하는 것과 같습니다."

#: ../Doc/library/unittest.rst:1648
msgid ":class:`TestSuite` shares the following methods with :class:`TestCase`:"
msgstr ":class:`TestSuite`\\는 다음 메서드를 :class:`TestCase`\\와 공유합니다:"

#: ../Doc/library/unittest.rst:1653
msgid ""
"Run the tests associated with this suite, collecting the result into the "
"test result object passed as *result*.  Note that unlike "
":meth:`TestCase.run`, :meth:`TestSuite.run` requires the result object to"
" be passed in."
msgstr ""
"이 테스트 묶음과 연관된 테스트를 실행하고, *result*\\로 전달된 테스트 결과 객체에 결과를 수집합니다. "
":meth:`TestCase.run`\\과 달리 :meth:`TestSuite.run`\\은 결과 객체가 반드시 전달되어야 합니다."
" "

#: ../Doc/library/unittest.rst:1661
msgid ""
"Run the tests associated with this suite without collecting the result. "
"This allows exceptions raised by the test to be propagated to the caller "
"and can be used to support running tests under a debugger."
msgstr ""
"결과를 수집하지 않고 이 테스트 묶음과 연관된 테스트를 실행합니다. 이것은 테스트에서 발생한 예외가 호출자로 전파될 수 있게 해서 "
"디버거 환경에서 테스트를 실행할 때 사용될 수 있습니다."

#: ../Doc/library/unittest.rst:1668
msgid ""
"Return the number of tests represented by this test object, including all"
" individual tests and sub-suites."
msgstr "이 테스트 객체에 해당하는 테스트 개수를 반환합니다, 모든 개별 테스트와 서브-테스트 묶음을 포함합니다."

#: ../Doc/library/unittest.rst:1674
msgid ""
"Tests grouped by a :class:`TestSuite` are always accessed by iteration. "
"Subclasses can lazily provide tests by overriding :meth:`__iter__`. Note "
"that this method may be called several times on a single suite (for "
"example when counting tests or comparing for equality) so the tests "
"returned by repeated iterations before :meth:`TestSuite.run` must be the "
"same for each call iteration. After :meth:`TestSuite.run`, callers should"
" not rely on the tests returned by this method unless the caller uses a "
"subclass that overrides :meth:`TestSuite._removeTestAtIndex` to preserve "
"test references."
msgstr ""
":class:`TestSuite`\\로 묶인 테스트들은 항상 이터레이션으로 접근합니다. 서브 클래스는 "
":meth:`__iter__`\\를 재정의하여 테스트를 지연해서 제공할 수 있습니다. 이 메서드는 한 개의 테스트 묶음에서 여러 번"
" 불릴 수 있다는 것을 기억하십시오(예를 들어 테스트 개수를 세거나 동등성을 위해 비교할 때), 그러므로 "
":meth:`TestSuite.run` 전에 수 번의 이터레이션이 반환한 테스트들은 매 이터레이션 호출마다 반드시 같아야 합니다. "
":meth:`TestSuite.run` 후에는 호출자가 테스트 참조를 보존하기 위해 "
":meth:`TestSuite._removeTestAtIndex`\\를 재정의한 서브 클래스를 사용하는 경우가 아니라면 이 메서드에"
" 의해 반환된 테스트에 의존하면 안 됩니다."

#: ../Doc/library/unittest.rst:1684
msgid ""
"In earlier versions the :class:`TestSuite` accessed tests directly rather"
" than through iteration, so overriding :meth:`__iter__` wasn't sufficient"
" for providing tests."
msgstr ""
"이전 버전에서는 :class:`TestSuite`\\가 이터레이션을 사용하기보다는 직접 테스트에 접근했습니다, 따라서 "
":meth:`__iter__`\\를 재정의하는 것은 테스트를 제공하기에 충분하지 않았습니다."

#: ../Doc/library/unittest.rst:1689
msgid ""
"In earlier versions the :class:`TestSuite` held references to each "
":class:`TestCase` after :meth:`TestSuite.run`. Subclasses can restore "
"that behavior by overriding :meth:`TestSuite._removeTestAtIndex`."
msgstr ""
"이전 버전에서는 :class:`TestSuite`\\가 :meth:`TestSuite.run` 후에 각 "
":class:`TestCase` 의 참조를 유지했습니다. 서브 클래스는 "
":meth:`TestSuite._removeTestAtIndex`\\를 재정의해서 이 동작을 복구할 수 있습니다."

#: ../Doc/library/unittest.rst:1694
msgid ""
"In the typical usage of a :class:`TestSuite` object, the :meth:`run` "
"method is invoked by a :class:`TestRunner` rather than by the end-user "
"test harness."
msgstr ""
":class:`TestSuite` 객체의 전형적인 사용법은 최종 사용자 테스트 장치(harness)보다는 "
":class:`TestRunner`\\에 의해 :meth:`run` 메서드가 호출되는 것입니다."

#: ../Doc/library/unittest.rst:1699
msgid "Loading and running tests"
msgstr "테스트를 로드하고 실행하기"

#: ../Doc/library/unittest.rst:1703
msgid ""
"The :class:`TestLoader` class is used to create test suites from classes "
"and modules.  Normally, there is no need to create an instance of this "
"class; the :mod:`unittest` module provides an instance that can be shared"
" as :data:`unittest.defaultTestLoader`.  Using a subclass or instance, "
"however, allows customization of some configurable properties."
msgstr ""
":class:`TestLoader` 클래스는 클래스와 모듈로부터 테스트 묶음을 생성하는 데 사용됩니다. 보통, 이 클래스의 "
"인스턴스를 생성할 필요는 없습니다; :mod:`unittest` 모듈은 공유 가능한 "
":data:`unittest.defaultTestLoader` 인스턴스를 제공합니다. 그러나 서브 클래스나 인스턴스를 사용함으로 "
"몇몇 변경 가능한 속성을 사용자 정의할 수 있습니다."

#: ../Doc/library/unittest.rst:1709
msgid ":class:`TestLoader` objects have the following attributes:"
msgstr ":class:`TestLoader` 객체는 다음 어트리뷰트를 가집니다:"

#: ../Doc/library/unittest.rst:1714
msgid ""
"A list of the non-fatal errors encountered while loading tests. Not reset"
" by the loader at any point. Fatal errors are signalled by the relevant a"
" method raising an exception to the caller. Non-fatal errors are also "
"indicated by a synthetic test that will raise the original error when "
"run."
msgstr ""
"테스트를 로드하는 동안 발생한 치명적이지 않은(non-fatal) 에러 목록입니다. 어떤 시점에도 로더에 의해 재설정되지 않습니다."
" 치명적인 에러는 예외를 발생시키는 관련 메서드에 의해 신호가 발생하여 호출자에게 전달됩니다. 치명적이지 않은 에러는 실행 시에 "
"원래 에러를 발생시킬 합성(synthetic) 테스트가 표시하기도 합니다."

#: ../Doc/library/unittest.rst:1723
msgid ":class:`TestLoader` objects have the following methods:"
msgstr ":class:`TestLoader` 객체는 다음 메서드를 가집니다:"

#: ../Doc/library/unittest.rst:1728
msgid ""
"Return a suite of all test cases contained in the :class:`TestCase`\\ "
"-derived :class:`testCaseClass`."
msgstr ""
":class:`TestCase`\\에서 파생된 :class:`testCaseClass`\\에 포함된 모든 테스트 케이스의 묶음을 "
"반환합니다."

#: ../Doc/library/unittest.rst:1731
msgid ""
"A test case instance is created for each method named by "
":meth:`getTestCaseNames`. By default these are the method names beginning"
" with ``test``. If :meth:`getTestCaseNames` returns no methods, but the "
":meth:`runTest` method is implemented, a single test case is created for "
"that method instead."
msgstr ""
"테스트 케이스 인스턴스는 :meth:`getTestCaseNames`\\에 의해 이름 지어진 각 메서드를 위해 생성됩니다. 기본값은"
" ``test``\\로 시작되는 메서드 이름입니다. 만약 :meth:`getTestCaseNames`\\가 아무 메서드도 반환하지 "
"않지만, :meth:`runTest` 메서드가 구현되었다면 이 메서드를 위해서 1개의 테스트 케이스가 대신 생성됩니다."

#: ../Doc/library/unittest.rst:1740
msgid ""
"Return a suite of all test cases contained in the given module. This "
"method searches *module* for classes derived from :class:`TestCase` and "
"creates an instance of the class for each test method defined for the "
"class."
msgstr ""
"주어진 모듈에 포함된 모든 테스트 케이스 묶음을 반환합니다. 이 메서드는 :class:`TestCase`\\에서 파생된 클래스를 "
"찾기 위해 *module*\\을 검색하고 클래스에 정의된 각 테스트 메서드를 위해 클래스의 인스턴스를 생성합니다. "

#: ../Doc/library/unittest.rst:1747
msgid ""
"While using a hierarchy of :class:`TestCase`\\ -derived classes can be "
"convenient in sharing fixtures and helper functions, defining test "
"methods on base classes that are not intended to be instantiated directly"
" does not play well with this method.  Doing so, however, can be useful "
"when the fixtures are different and defined in subclasses."
msgstr ""
":class:`TestCase`\\에서 파생된 클래스의 계층 사용이 픽스쳐와 도우미 함수를 공유하는 데 편리할 수 있지만 직접 "
"인스턴스화를 하도록 의도되지 않은 베이스 클래스에 테스트 메서드를 정의하는 것은 이 메서드와 잘 작동하지 않습니다. 그러나 그렇게 "
"하는 것이 픽스처들이 다르고 서브 클래스에서 정의될 경우에는 유용할 수 있습니다."

#: ../Doc/library/unittest.rst:1753
msgid ""
"If a module provides a ``load_tests`` function it will be called to load "
"the tests. This allows modules to customize test loading. This is the "
"`load_tests protocol`_.  The *pattern* argument is passed as the third "
"argument to ``load_tests``."
msgstr ""
"만약 모듈이 ``load_tests`` 함수를 제공한다면 테스트 로드를 위해 이것을 호출할 것입니다. 이것은 모듈이 테스트 로드를 "
"사용자 정의할 수 있도록 해줍니다. 이것은 `load_tests 프로토콜 <load_tests protocol_>`_\\입니다. "
"*pattern* 인자는 ``load_tests``\\에 세 번째 인자로 전달됩니다."

#: ../Doc/library/unittest.rst:1758
msgid "Support for ``load_tests`` added."
msgstr "``load_tests`` 지원이 추가됨."

#: ../Doc/library/unittest.rst:1761
msgid ""
"The undocumented and unofficial *use_load_tests* default argument is "
"deprecated and ignored, although it is still accepted for backward "
"compatibility.  The method also now accepts a keyword-only argument "
"*pattern* which is passed to ``load_tests`` as the third argument."
msgstr ""
"문서로 만들어 져 있지 않고 공식적이지 않은 *use_load_tests* 기본 인자를 폐지하고 무시합니다, 하지만 하위 호환성을 "
"위해 여전히 그것을 수용합니다. 이 메서드는 이제 ``load_tests``\\에 세 번째 인자로 전달되는 *pattern*\\을 "
"오직 키워드 인자로써 수용합니다."

#: ../Doc/library/unittest.rst:1770
msgid "Return a suite of all test cases given a string specifier."
msgstr "문자열 지정자에 맞는 모든 테스트 케이스 묶음을 반환합니다."

#: ../Doc/library/unittest.rst:1772
msgid ""
"The specifier *name* is a \"dotted name\" that may resolve either to a "
"module, a test case class, a test method within a test case class, a "
":class:`TestSuite` instance, or a callable object which returns a "
":class:`TestCase` or :class:`TestSuite` instance.  These checks are "
"applied in the order listed here; that is, a method on a possible test "
"case class will be picked up as \"a test method within a test case "
"class\", rather than \"a callable object\"."
msgstr ""
"지정자 *name*\\은 모듈, 테스트 케이스 클래스, 테스트 케이스 클래스에 있는 테스트 메서드, "
":class:`TestSuite` 인스턴스, :class:`TestCase`\\나 :class:`TestSuite` 인스턴스를 "
"반환하는 콜러블 객체로 해석될 수 있는 \"점으로 구분된 이름(dotted name)\"입니다. 이 검사는 여기에 나열된 순서대로 "
"적용됩니다; 즉, 테스트 케이스 클래스에 있는 메서드는 \"콜러블  객체\"보다는 \"테스트 케이스 클래스에 있는 테스트 "
"메서드\"로 선택될 것입니다."

#: ../Doc/library/unittest.rst:1780
msgid ""
"For example, if you have a module :mod:`SampleTests` containing a "
":class:`TestCase`\\ -derived class :class:`SampleTestCase` with three "
"test methods (:meth:`test_one`, :meth:`test_two`, and "
":meth:`test_three`), the specifier ``'SampleTests.SampleTestCase'`` would"
" cause this method to return a suite which will run all three test "
"methods. Using the specifier ``'SampleTests.SampleTestCase.test_two'`` "
"would cause it to return a test suite which will run only the "
":meth:`test_two` test method. The specifier can refer to modules and "
"packages which have not been imported; they will be imported as a side-"
"effect."
msgstr ""
"예를 들어, 만약 당신이 :class:`TestCase`\\에서 파생된 클래스인 :class:`SampleTestCase`\\를 "
"포함한 :mod:`SampleTests` 모듈을 가지고 있고 그 클래스는 3개의 테스트 메서드(:meth:`test_one`, "
":meth:`test_two`, :meth:`test_three`)를 가지고 있다면, 지정자 "
"``'SampleTests.SampleTestCase'`` 에 대해서 이 메서드는 모든 3개의 테스트 메서드를 실행할 테스트 "
"묶음으로 반환할 것입니다. 지정자가  ``'SampleTests.SampleTestCase.test_two'`` 라면 이 메서드는 "
"오직 :meth:`test_two` 테스트 메서드를 실행할 테스트 묶음을 반환할 것입니다. 지정자는 아직 임포트되지 않은 모듈이나 "
"패키지를 가리킬 수 있습니다; 부작용(side-effect)으로써 그것들이 임포트될 것입니다."

#: ../Doc/library/unittest.rst:1790
msgid "The method optionally resolves *name* relative to the given *module*."
msgstr "이 메서드는 주어진 *module*\\에 상대적인 *name*\\을 선택적으로 해석할 수 있습니다."

#: ../Doc/library/unittest.rst:1792
msgid ""
"If an :exc:`ImportError` or :exc:`AttributeError` occurs while traversing"
" *name* then a synthetic test that raises that error when run will be "
"returned. These errors are included in the errors accumulated by "
"self.errors."
msgstr ""
"만약 *name* 순회 중에 :exc:`ImportError`\\나 :exc:`AttributeError`\\가 발생한다면 실행할 "
"때 그 에러를 일으키는 합성 테스트가 반환될 것입니다. 이 에러는 self.errors 에러 모임에 포함될 것입니다."

#: ../Doc/library/unittest.rst:1801
msgid ""
"Similar to :meth:`loadTestsFromName`, but takes a sequence of names "
"rather than a single name.  The return value is a test suite which "
"supports all the tests defined for each name."
msgstr ""
":meth:`loadTestsFromName`\\와 비슷하지만, 1개의 이름이 아닌 이름의 시퀀스를 받습니다. 반환 값은 각 이름에"
" 정의된 모든 테스트를 지원하는 테스트 묶음입니다."

#: ../Doc/library/unittest.rst:1808
msgid ""
"Return a sorted sequence of method names found within *testCaseClass*; "
"this should be a subclass of :class:`TestCase`."
msgstr ""
"*testCaseClass* 안에서 찾은 메서드 이름을 정렬된 시퀀스로 반환합니다; 이 클래스는 "
":class:`TestCase`\\의 서브 클래스이어야 합니다."

#: ../Doc/library/unittest.rst:1814
msgid ""
"Find all the test modules by recursing into subdirectories from the "
"specified start directory, and return a TestSuite object containing them."
" Only test files that match *pattern* will be loaded. (Using shell style "
"pattern matching.) Only module names that are importable (i.e. are valid "
"Python identifiers) will be loaded."
msgstr ""
"지정된 시작 디렉터리부터 하위 디렉터리를 재귀적으로 순회하여 모든 테스트 모듈을 찾아, 이를 포함하는 TestSuite 객체를 "
"반환합니다. *pattern*\\에 일치하는 테스트 파일만 로드될 것입니다. (셸 방식의 패턴 일치를 사용합니다.) 임포트 "
"가능한(즉, 유효한 파이썬 식별자인) 모듈 이름만 로드될 것입니다."

#: ../Doc/library/unittest.rst:1820
msgid ""
"All test modules must be importable from the top level of the project. If"
" the start directory is not the top level directory then the top level "
"directory must be specified separately."
msgstr ""
"모든 테스트 모듈은 반드시 프로젝트의 최상위 수준에서 임포트 가능해야 합니다. 만약 시작 디렉터리가 최상위 디렉터리가 아니라면 "
"최상위 디렉터리를 따로 지정해야 합니다."

#: ../Doc/library/unittest.rst:1824
msgid ""
"If importing a module fails, for example due to a syntax error, then this"
" will be recorded as a single error and discovery will continue.  If the "
"import failure is due to :exc:`SkipTest` being raised, it will be "
"recorded as a skip instead of an error."
msgstr ""
"만약 모듈 임포트가 실패한다면, 예를 들어 문법 에러로 인해, 이것은 1개의 에러로 기록되고 탐색이 계속 진행될 것입니다. 만약 "
":exc:`SkipTest`\\가 발생해서 임포트가 실패했다면, 이것은 에러가 아닌 건너뛰기로 기록될 것입니다."

#: ../Doc/library/unittest.rst:1829
msgid ""
"If a package (a directory containing a file named :file:`__init__.py`) is"
" found, the package will be checked for a ``load_tests`` function. If "
"this exists then it will be called ``package.load_tests(loader, tests, "
"pattern)``. Test discovery takes care to ensure that a package is only "
"checked for tests once during an invocation, even if the load_tests "
"function itself calls ``loader.discover``."
msgstr ""
"만약 패키지(:file:`__init__.py` 라는 이름의 파일을 포함한 디렉터리)를 찾으면, ``load_tests`` 함수가 "
"있는지 패키지를 검사할 것입니다. 만약 존재한다면 그 패키지에 대해서 ``package.load_tests(loader, "
"tests, pattern)``\\가 불릴 것입니다. 만약 load_tests 함수 자체가 ``loader.discover``\\를"
" 호출할지라도, 테스트 탐색은 실행 중에 패키지에 대한 테스트 검사를 한 번만 실행하도록 보장합니다."

#: ../Doc/library/unittest.rst:1837
msgid ""
"If ``load_tests`` exists then discovery does *not* recurse into the "
"package, ``load_tests`` is responsible for loading all tests in the "
"package."
msgstr ""
"만약 ``load_tests``\\가 존재한다면 탐색은 패키지 안을 재귀 탐색하지 *않습니다*. ``load_tests``\\가 "
"패키지 안의 모든 테스트를 로드할 책임이 있습니다."

#: ../Doc/library/unittest.rst:1841
msgid ""
"The pattern is deliberately not stored as a loader attribute so that "
"packages can continue discovery themselves. *top_level_dir* is stored so "
"``load_tests`` does not need to pass this argument in to "
"``loader.discover()``."
msgstr ""
"패턴은 의도적으로 로더 어트리뷰트로 저장되지 않아 패키지가 자신에 대한 탐색을 계속할 수 있습니다. "
"*top_level_dir*\\는 저장되어 ``load_tests``\\가 ``loader.discover()``\\에게 이 인자를"
" 건네줄 필요가 없습니다."

#: ../Doc/library/unittest.rst:1846
msgid "*start_dir* can be a dotted module name as well as a directory."
msgstr "*start_dir*\\는 디렉터리뿐만 아니라 점으로 구분된 모듈 이름이 될 수 있습니다."

#: ../Doc/library/unittest.rst:1850
msgid ""
"Modules that raise :exc:`SkipTest` on import are recorded as skips,   not"
" errors. Discovery works for :term:`namespace packages <namespace "
"package>`. Paths are sorted before being imported so that execution order"
" is   the same even if the underlying file system's ordering is not   "
"dependent on file name."
msgstr ""
"임포트 시에 :exc:`SkipTest`\\가 발생한 모듈은 에러가 아닌, 건너뛰기로 기록됩니다. 탐색은 :term:`이름 공간 "
"패키지 <namespace package>`\\를 지원합니다. 임포트되기 전에 경로들이 정렬되어 파일 시스템의 정렬 순서가 파일 "
"이름에 의존하지 않더라도 실행 순서가 같아지도록 합니다."

#: ../Doc/library/unittest.rst:1858
msgid ""
"Found packages are now checked for ``load_tests`` regardless of whether "
"their path matches *pattern*, because it is impossible for a package name"
" to match the default pattern."
msgstr ""
"이제 발견된 패키지는 그것의 경로가 *pattern*\\과 일치하는지 여부와 상관없이 ``load_tests``\\를 검사합니다, "
"왜냐하면 패키지 이름이 기본 패턴과 일치하는 것이 불가능하기 때문입니다."

#: ../Doc/library/unittest.rst:1864
msgid ""
"The following attributes of a :class:`TestLoader` can be configured "
"either by subclassing or assignment on an instance:"
msgstr ":class:`TestLoader`\\의 다음 어트리뷰트들은 서브 클래스나 인스턴스에 대입을 통해 구성할 수 있습니다."

#: ../Doc/library/unittest.rst:1870
msgid ""
"String giving the prefix of method names which will be interpreted as "
"test methods.  The default value is ``'test'``."
msgstr "테스트 메서드로 해석할 메서드 이름의 접두사에 해당하는 문자열입니다. 기본값은 ``'test'`` 입니다."

#: ../Doc/library/unittest.rst:1873
msgid ""
"This affects :meth:`getTestCaseNames` and all the "
":meth:`loadTestsFrom\\*` methods."
msgstr "이것은 :meth:`getTestCaseNames` 과 모든 :meth:`loadTestsFrom\\*` 메서드에 영향을 미칩니다."

#: ../Doc/library/unittest.rst:1879
msgid ""
"Function to be used to compare method names when sorting them in "
":meth:`getTestCaseNames` and all the :meth:`loadTestsFrom\\*` methods."
msgstr ""
":meth:`getTestCaseNames`\\와 모든 :meth:`loadTestsFrom\\*` 메서드에서 메서드 이름 정렬 "
"시에 이름 비교하는 데 사용될 함수입니다."

#: ../Doc/library/unittest.rst:1885
msgid ""
"Callable object that constructs a test suite from a list of tests. No "
"methods on the resulting object are needed.  The default value is the "
":class:`TestSuite` class."
msgstr ""
"테스트 목록에서 테스트 묶음을 생성하는 콜러블 객체입니다. 결과 객체에 어떤 메서드도 필요하지 않습니다. 기본값은 "
":class:`TestSuite` 클래스입니다."

#: ../Doc/library/unittest.rst:1889 ../Doc/library/unittest.rst:1902
msgid "This affects all the :meth:`loadTestsFrom\\*` methods."
msgstr "이것은 모든 :meth:`loadTestsFrom\\*` 메서드에 영향을 미칩니다."

#: ../Doc/library/unittest.rst:1893
msgid ""
"List of Unix shell-style wildcard test name patterns that test methods "
"have to match to be included in test suites (see ``-v`` option)."
msgstr ""
"테스트 묶음에 포함되기 위해서 테스트 메서드가 일치해야 할 유닉스 셸-방식의 와일드카드 테스트 이름 패턴 목록입니다(``-v`` "
"옵션을 보십시오)."

#: ../Doc/library/unittest.rst:1896
msgid ""
"If this attribute is not ``None`` (the default), all test methods to be "
"included in test suites must match one of the patterns in this list. Note"
" that matches are always performed using :meth:`fnmatch.fnmatchcase`, so "
"unlike patterns passed to the ``-v`` option, simple substring patterns "
"will have to be converted using ``*`` wildcards."
msgstr ""
"만약 이 어트리뷰트가 ``None``\\(기본값)이 아니라면, 테스트 묶음에 포함될 모든 테스트 메서드는 이 목록의 패턴 중 1개와"
" 반드시 일치해야 합니다. 이 패턴 일치는 항상 :meth:`fnmatch.fnmatchcase`\\를 사용하여 수행된다는 것을 "
"기억하십시오, 그래서 ``-v`` 옵션에 패턴을 건네주는 것과 달리, 간단한 부분 문자열 패턴은 ``*`` 와일드카드를 사용하도록 "
"변경되어야 할 것입니다."

#: ../Doc/library/unittest.rst:1909
msgid ""
"This class is used to compile information about which tests have "
"succeeded and which have failed."
msgstr "어떤 테스트가 성공했고 어떤 테스트가 실패했는지에 관한 정보를 엮는데 사용되는 클래스입니다."

#: ../Doc/library/unittest.rst:1912
msgid ""
"A :class:`TestResult` object stores the results of a set of tests.  The "
":class:`TestCase` and :class:`TestSuite` classes ensure that results are "
"properly recorded; test authors do not need to worry about recording the "
"outcome of tests."
msgstr ""
":class:`TestResult` 객체는 여러 테스트의 결과들을 저장합니다. :class:`TestCase`\\와 "
":class:`TestSuite` 클래스는 결과가 올바르게 기록되는 것을 보장합니다; 테스트 작성자가 테스트 결과를 기록하는 것에 "
"대해서 걱정할 필요가 없습니다."

#: ../Doc/library/unittest.rst:1917
msgid ""
"Testing frameworks built on top of :mod:`unittest` may want access to the"
" :class:`TestResult` object generated by running a set of tests for "
"reporting purposes; a :class:`TestResult` instance is returned by the "
":meth:`TestRunner.run` method for this purpose."
msgstr ""
":mod:`unittest` 위에 만들어진 테스트 프레임워크는 보고 목적으로 여러 테스트가 실행하면서 만들어낸 "
":class:`TestResult` 객체에 접근하고 싶을 수도 있습니다; :meth:`TestRunner.run` 메서드는 이 "
"목적을 위해 :class:`TestResult` 인스턴스를 반환합니다."

#: ../Doc/library/unittest.rst:1922
msgid ""
":class:`TestResult` instances have the following attributes that will be "
"of interest when inspecting the results of running a set of tests:"
msgstr ""
":class:`TestResult` 인스턴스는 테스트 실행 결과를 조사할 때 관심이 생길만한 다음과 같은 어트리뷰트를 가지고 "
"있습니다."

#: ../Doc/library/unittest.rst:1928
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test which raised "
"an unexpected exception."
msgstr ""
":class:`TestCase` 인스턴스와 포맷된(formatted) 트레이스백 문자열로 구성된 2-튜플을 포함하는 목록입니다. 각"
" 튜플은 예기치 못한 예외가 발생한 테스트에 해당합니다."

#: ../Doc/library/unittest.rst:1934
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks. Each tuple represents a test where a "
"failure was explicitly signalled using the :meth:`TestCase.assert\\*` "
"methods."
msgstr ""
":class:`TestCase` 인스턴스와 포맷된(formatted) 트레이스백 문자열로 구성된 2-튜플을 포함하는 목록입니다. 각"
" 튜플은 :meth:`TestCase.assert\\*` 메서드를 사용하여 명시적으로 실패가 발생한 테스트에 해당합니다."

#: ../Doc/library/unittest.rst:1940
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding the reason for skipping the test."
msgstr ":class:`TestCase` 인스턴스와 테스트 건너뛰기한 이유 문자열로 구성된 2-튜플을 포함하는 목록입니다."

#: ../Doc/library/unittest.rst:1947
#, fuzzy
msgid ""
"A list containing 2-tuples of :class:`TestCase` instances and strings "
"holding formatted tracebacks.  Each tuple represents an expected failure "
"or error of the test case."
msgstr ""
":class:`TestCase` 인스턴스와 포맷된(formatted) 트레이스백 문자열로 구성된 2-튜플을 포함하는 목록입니다. 각"
" 튜플은 테스트 케이스의 예상된 실패에 해당합니다."

#: ../Doc/library/unittest.rst:1953
msgid ""
"A list containing :class:`TestCase` instances that were marked as "
"expected failures, but succeeded."
msgstr "예상된 실패로 표시되었지만 성공한 :class:`TestCase` 인스턴스를 포함하는 목록입니다."

#: ../Doc/library/unittest.rst:1958
msgid "Set to ``True`` when the execution of tests should stop by :meth:`stop`."
msgstr "테스트 실행이 :meth:`stop`\\에 의해 정지되어야 할 때 ``True``\\로 설정합니다."

#: ../Doc/library/unittest.rst:1962
msgid "The total number of tests run so far."
msgstr "이제까지 실행된 테스트 총 개수입니다."

#: ../Doc/library/unittest.rst:1966
msgid ""
"If set to true, ``sys.stdout`` and ``sys.stderr`` will be buffered in "
"between :meth:`startTest` and :meth:`stopTest` being called. Collected "
"output will only be echoed onto the real ``sys.stdout`` and "
"``sys.stderr`` if the test fails or errors. Any output is also attached "
"to the failure / error message."
msgstr ""
"참으로 설정하면 ``sys.stdout``\\와 ``sys.stderr``\\가 :meth:`startTest`\\와 "
":meth:`stopTest` 호출 사이에서 버퍼링될 것입니다. 수집된 출력은 테스트가 실패하거나 에러가 발생한 경우에만 실제 "
"``sys.stdout``\\와 ``sys.stderr``\\에 출력될 것입니다. 모든 출력은 실패 / 에러 메시지에도 첨부됩니다."

#: ../Doc/library/unittest.rst:1975
msgid ""
"If set to true :meth:`stop` will be called on the first failure or error,"
" halting the test run."
msgstr "참으로 설정하면 첫 번째 실패 또는 에러에서 :meth:`stop`\\이 호출될 것입니다."

#: ../Doc/library/unittest.rst:1982
msgid "If set to true then local variables will be shown in tracebacks."
msgstr "참으로 설정하면 지역 변수가 트레이스백에 보일 것입니다."

#: ../Doc/library/unittest.rst:1988
msgid ""
"Return ``True`` if all tests run so far have passed, otherwise returns "
"``False``."
msgstr "이제까지 실행한 모든 테스트가 성공했다면 ``True``\\를 반환하고, 그렇지 않으면 ``False``\\를 반환합니다."

#: ../Doc/library/unittest.rst:1991
msgid ""
"Returns ``False`` if there were any :attr:`unexpectedSuccesses` from "
"tests marked with the :func:`expectedFailure` decorator."
msgstr ""
":func:`expectedFailure` 데코레이터로 표시된 테스트에서 :attr:`unexpectedSuccesses`\\가 "
"있다면 ``False``\\를 반환합니다."

#: ../Doc/library/unittest.rst:1997
msgid ""
"This method can be called to signal that the set of tests being run "
"should be aborted by setting the :attr:`shouldStop` attribute to "
"``True``. :class:`TestRunner` objects should respect this flag and return"
" without running any additional tests."
msgstr ""
":attr:`shouldStop` 어트리뷰트를 ``True``\\로 설정하여 현재 실행 중인 테스트 모음을 중단해야 함을 알리기 "
"위한 용도로 이 메서드를 부를 수 있습니다. :class:`TestRunner` 객체는 이 신호를 존중하여 어떠한 추가 테스트 없이"
" 반환해야 합니다."

#: ../Doc/library/unittest.rst:2002
msgid ""
"For example, this feature is used by the :class:`TextTestRunner` class to"
" stop the test framework when the user signals an interrupt from the "
"keyboard.  Interactive tools which provide :class:`TestRunner` "
"implementations can use this in a similar manner."
msgstr ""
"예를 들어, 사용자가 키보드로 중단 신호를 보낼 때 테스트 프레임워크를 중단하기 위해 "
":class:`TextTestRunner`\\가 이 기능을 사용합니다. :class:`TestRunner` 구현을 제공하는 대화형 "
"도구는 비슷한 방법으로 이것을 사용할 수 있습니다."

#: ../Doc/library/unittest.rst:2007
msgid ""
"The following methods of the :class:`TestResult` class are used to "
"maintain the internal data structures, and may be extended in subclasses "
"to support additional reporting requirements.  This is particularly "
"useful in building tools which support interactive reporting while tests "
"are being run."
msgstr ""
":class:`TestResult` 클래스의 다음 메서드는 내부 자료 구조를 관리하려고 사용되고, 추가적인 보고 요구사항을 지원하기"
" 위해 서브 클래스에서 확장할 수도 있습니다. 이것은 테스트가 실행 중에 대화형 보고를 지원하는 도구를 만들 때 특별히 유용합니다."

#: ../Doc/library/unittest.rst:2015
msgid "Called when the test case *test* is about to be run."
msgstr "테스트 케이스 *test*\\가 막 실행되려 할 때 호출됩니다."

#: ../Doc/library/unittest.rst:2019
msgid ""
"Called after the test case *test* has been executed, regardless of the "
"outcome."
msgstr "결과에 상관없이 테스트 케이스 *test*\\가 실행되고 나서 호출됩니다."

#: ../Doc/library/unittest.rst:2024
msgid "Called once before any tests are executed."
msgstr "모든 테스트가 실행되기 전에 1번 호출됩니다."

#: ../Doc/library/unittest.rst:2031
msgid "Called once after all tests are executed."
msgstr "모든 테스트가 실행되고 나서 1번 호출됩니다."

#: ../Doc/library/unittest.rst:2038
msgid ""
"Called when the test case *test* raises an unexpected exception. *err* is"
" a tuple of the form returned by :func:`sys.exc_info`: ``(type, value, "
"traceback)``."
msgstr ""
"테스트 케이스 *test*\\가 예기치 못한 예외를 발생한 경우 호출됩니다. *err*\\는 "
":func:`sys.exc_info`\\가 반환한 형식의 튜플입니다: ``(type, value, traceback)``\\."

#: ../Doc/library/unittest.rst:2042
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to "
"the instance's :attr:`errors` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"기본 구현은 ``(test, formatted_err)`` 튜플을 인스턴스의 :attr:`errors` 어트리뷰트에 추가합니다, "
"여기서 *formatted_err*\\는 *err*\\에서 파생된 포맷한 트레이스백입니다."

#: ../Doc/library/unittest.rst:2049
msgid ""
"Called when the test case *test* signals a failure. *err* is a tuple of "
"the form returned by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"테스트 케이스 *test*\\가 실패 신호를 보낸 경우 호출됩니다. *err*\\는 :func:`sys.exc_info`\\가 "
"반환한 형식의 튜플입니다: ``(type, value, traceback)``\\."

#: ../Doc/library/unittest.rst:2052
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to "
"the instance's :attr:`failures` attribute, where *formatted_err* is a "
"formatted traceback derived from *err*."
msgstr ""
"기본 구현은 ``(test, formatted_err)`` 튜플을 인스턴스의 :attr:`failures` 어트리뷰트에 추가합니다,"
" 여기서 *formatted_err*\\는 *err*\\에서 파생된 포맷한 트레이스백입니다."

#: ../Doc/library/unittest.rst:2059
msgid "Called when the test case *test* succeeds."
msgstr "테스트 케이스 *test*\\가 성공하면 호출됩니다."

#: ../Doc/library/unittest.rst:2061
msgid "The default implementation does nothing."
msgstr "기본 구현은 아무것도 하지 않습니다."

#: ../Doc/library/unittest.rst:2066
msgid ""
"Called when the test case *test* is skipped.  *reason* is the reason the "
"test gave for skipping."
msgstr "테스트 케이스 *test*\\가 건너뛰어지면 호출됩니다. *reason*\\은 테스트가 준 건너뛰는 이유입니다."

#: ../Doc/library/unittest.rst:2069
msgid ""
"The default implementation appends a tuple ``(test, reason)`` to the "
"instance's :attr:`skipped` attribute."
msgstr "기본 구현은 ``(test, reason)`` 튜플을 인스턴스의 :attr:`skipped` 어트리뷰트에 추가합니다."

#: ../Doc/library/unittest.rst:2075
#, fuzzy
msgid ""
"Called when the test case *test* fails or errors, but was marked with the"
" :func:`expectedFailure` decorator."
msgstr "테스트 케이스 *test*\\가 실패했지만 :func:`expectedFailure` 데코레이터로 표시된 경우 호출됩니다"

#: ../Doc/library/unittest.rst:2078
msgid ""
"The default implementation appends a tuple ``(test, formatted_err)`` to "
"the instance's :attr:`expectedFailures` attribute, where *formatted_err* "
"is a formatted traceback derived from *err*."
msgstr ""
"기본 구현은 ``(test, formatted_err)`` 튜플을 인스턴스의 :attr:`expectedFailures` "
"어트리뷰트에 추가합니다, 여기서 *formatted_err*\\는 *err*\\에서 파생된 포맷한 트레이스백입니다."

#: ../Doc/library/unittest.rst:2085
msgid ""
"Called when the test case *test* was marked with the "
":func:`expectedFailure` decorator, but succeeded."
msgstr "테스트 케이스 *test*\\가 :func:`expectedFailure` 데코레이터로 표시되었지만, 성공한 경우 호출됩니다."

#: ../Doc/library/unittest.rst:2088
msgid ""
"The default implementation appends the test to the instance's "
":attr:`unexpectedSuccesses` attribute."
msgstr "기본 구현은 테스트를 인스턴스의 :attr:`unexpectedSuccesses` 어트리뷰트에 추가합니다."

#: ../Doc/library/unittest.rst:2094
msgid ""
"Called when a subtest finishes.  *test* is the test case corresponding to"
" the test method.  *subtest* is a custom :class:`TestCase` instance "
"describing the subtest."
msgstr ""
"부분 테스트가 완료되었을 때 호출됩니다. *test*\\는 테스트 메서드에 대응하는 테스트 케이스입니다. *subtest*\\는 "
"부분 테스트를 설명하는 사용자 지정 :class:`TestCase` 인스턴스입니다."

#: ../Doc/library/unittest.rst:2098
msgid ""
"If *outcome* is :const:`None`, the subtest succeeded.  Otherwise, it "
"failed with an exception where *outcome* is a tuple of the form returned "
"by :func:`sys.exc_info`: ``(type, value, traceback)``."
msgstr ""
"*outcome*\\이 :const:`None`\\이면, 부분 테스트가 성공한 것입니다. 그렇지 않으면 예외와 함께 실패한 것인데 "
"*outcome*\\은 :func:`sys.exc_info`\\가 반환한 형식의 튜플입니다: ``(type, value, "
"traceback)``\\."

#: ../Doc/library/unittest.rst:2102
msgid ""
"The default implementation does nothing when the outcome is a success, "
"and records subtest failures as normal failures."
msgstr "기본 구현은 결과가 성공인 경우 아무것도 하지 않고 부분 테스트의 실패를 일반적인 실패로 기록합니다."

#: ../Doc/library/unittest.rst:2110
msgid ""
"A concrete implementation of :class:`TestResult` used by the "
":class:`TextTestRunner`."
msgstr ":class:`TextTestRunner`\\에서 사용하는 :class:`TestResult`\\의 구체적인 구현입니다."

#: ../Doc/library/unittest.rst:2113
msgid ""
"This class was previously named ``_TextTestResult``. The old name still "
"exists as an alias but is deprecated."
msgstr "이 클래스는 이전에 ``_TextTestResult`` 이름이었습니다. 이 이름은 여전히 에일리어스로 존재하지만 폐지된 상태입니다."

#: ../Doc/library/unittest.rst:2120
msgid ""
"Instance of the :class:`TestLoader` class intended to be shared.  If no "
"customization of the :class:`TestLoader` is needed, this instance can be "
"used instead of repeatedly creating new instances."
msgstr ""
"공유 목적의 :class:`TestLoader` 클래스의 인스턴스입니다. 만약 :class:`TestLoader`\\를 사용자 "
"정의할 필요가 없다면, 계속 새로운 인스턴스를 생성하는 것 대신 이 인스턴스를 사용할 수 있습니다."

#: ../Doc/library/unittest.rst:2128
msgid ""
"A basic test runner implementation that outputs results to a stream. If "
"*stream* is ``None``, the default, :data:`sys.stderr` is used as the "
"output stream. This class has a few configurable parameters, but is "
"essentially very simple.  Graphical applications which run test suites "
"should provide alternate implementations. Such implementations should "
"accept ``**kwargs`` as the interface to construct runners changes when "
"features are added to unittest."
msgstr ""
"결과를 스트림으로 출력하는 기본 테스트 실행자 구현입니다. 만약 *stream*\\이 기본값인 ``None``\\이라면, "
":data:`sys.stderr`\\가 출력 스트림으로 사용됩니다. 이 클래스는 몇 가지 설정 가능한 매개변수를 가지고 있지만, "
"본질적으로 매우 간단합니다. 테스트 묶음을 실행하는 그래픽 애플리케이션은 대안 구현을 제공해야 합니다. 이러한 구현은 "
"unittest에 기능이 추가될 때 실행자를 만드는 인터페이스가 변하기 때문에 ``**kwargs``\\를 받아들여야 합니다."

#: ../Doc/library/unittest.rst:2135
msgid ""
"By default this runner shows :exc:`DeprecationWarning`, "
":exc:`PendingDeprecationWarning`, :exc:`ResourceWarning` and "
":exc:`ImportWarning` even if they are :ref:`ignored by default <warning-"
"ignored>`. Deprecation warnings caused by :ref:`deprecated unittest "
"methods <deprecated-aliases>` are also special-cased and, when the "
"warning filters are ``'default'`` or ``'always'``, they will appear only "
"once per-module, in order to avoid too many warning messages.  This "
"behavior can be overridden using Python's :option:`!-Wd` or "
":option:`!-Wa` options (see :ref:`Warning control <using-on-warnings>`) "
"and leaving *warnings* to ``None``."
msgstr ""
"기본적으로 이 실행자는 :exc:`DeprecationWarning`, :exc:`PendingDeprecationWarning`,"
" :exc:`ResourceWarning`, :exc:`ImportWarning`\\이 :ref:`기본적으로 무시 <warning-"
"ignored>` 설정이 되어 있더라도 이것들을 보여줍니다. :ref:`폐지된 unittest 메서드 <deprecated-"
"aliases>` 에 의해 발생한 폐지 경고도 특수한 경우이고, 경고 필터가 ``'default'`` 또는 ``'always'`` "
"일 때, 너무 많은 경고 메시지를 피하고자 그것들이 모듈당 1번만 보일 것입니다. 파이썬의 :option:`!-Wd`\\이나 "
":option:`!-Wa` 옵션(:ref:`경고 제어 <using-on-warnings>`\\를 보십시오)을 사용하고 "
"*warnings*\\를 ``None``\\으로 설정하여 이 동작을 오버라이드 할 수 있습니다."

#: ../Doc/library/unittest.rst:2146
msgid "Added the ``warnings`` argument."
msgstr "``warnings`` 인자 추가."

#: ../Doc/library/unittest.rst:2149
msgid ""
"The default stream is set to :data:`sys.stderr` at instantiation time "
"rather than import time."
msgstr "임포트 시간이 아닌 인스턴스화 시간에 기본 스트림이 :data:`sys.stderr`\\으로 설정됩니다."

#: ../Doc/library/unittest.rst:2153
msgid "Added the tb_locals parameter."
msgstr "tb_locals 매개변수 추가."

#: ../Doc/library/unittest.rst:2158
msgid ""
"This method returns the instance of ``TestResult`` used by :meth:`run`. "
"It is not intended to be called directly, but can be overridden in "
"subclasses to provide a custom ``TestResult``."
msgstr ""
"이 메서드는 :meth:`run`\\가 사용하는 ``TestResult`` 인스턴스를 반환합니다. 직접 호출하게 의도되지 않았지만,"
" 사용자 정의 ``TestResult``\\를 제공하기 위해 서브 클래스에서 오버라이드할 수 있습니다."

#: ../Doc/library/unittest.rst:2162
msgid ""
"``_makeResult()`` instantiates the class or callable passed in the "
"``TextTestRunner`` constructor as the ``resultclass`` argument. It "
"defaults to :class:`TextTestResult` if no ``resultclass`` is provided. "
"The result class is instantiated with the following arguments::"
msgstr ""
"``_makeResult()``\\는 ``TextTestRunner`` 생성자에 ``resultclass`` 인자로 전달된 클래스나"
" 콜러블을 인스턴스화합니다. 만약 ``resultclass``\\가 제공되지 않았다면 기본값은 "
":class:`TextTestResult` 입니다. 결과 클래스는 다음 인자와 함께 인스턴스화됩니다::"

#: ../Doc/library/unittest.rst:2171
msgid ""
"This method is the main public interface to the ``TextTestRunner``. This "
"method takes a :class:`TestSuite` or :class:`TestCase` instance. A "
":class:`TestResult` is created by calling :func:`_makeResult` and the "
"test(s) are run and the results printed to stdout."
msgstr ""
"이 메서드는 ``TextTestRunner``\\의 주된 공개 인터페이스입니다. 이 메서드는 :class:`TestSuite`\\나"
" :class:`TestCase` 인스턴스를 받습니다. :class:`TestResult`\\는 "
":func:`_makeResult`\\를 호출하여 생성하고 테스트가 실행되며 결과가 stdout에 출력됩니다."

#: ../Doc/library/unittest.rst:2182
msgid ""
"A command-line program that loads a set of tests from *module* and runs "
"them; this is primarily for making test modules conveniently executable. "
"The simplest use for this function is to include the following line at "
"the end of a test script::"
msgstr ""
"*module*\\에서 테스트 모음을 로드하고 실행하는 명령행 프로그램입니다; 이것은 주로 편리하게 실행 가능한 테스트 모듈을 "
"만들기 위한 것입니다. 이 함수의 가장 간단한 사용은 테스트 스크립트 마지막에 다음과 같은 줄을 포함하는 것입니다::"

#: ../Doc/library/unittest.rst:2190
msgid ""
"You can run tests with more detailed information by passing in the "
"verbosity argument::"
msgstr "당신은 상세도 인자를 전달하여 좀 더 자세한 정보와 함께 테스트를 실행할 수 있습니다::"

#: ../Doc/library/unittest.rst:2196
msgid ""
"The *defaultTest* argument is either the name of a single test or an "
"iterable of test names to run if no test names are specified via *argv*."
"  If not specified or ``None`` and no test names are provided via *argv*,"
" all tests found in *module* are run."
msgstr ""
"*defaultTest* 인자는 *argv*\\로 테스트 이름이 지정되지 않은 경우 실행될 1개의 테스트 이름이거나 테스트 이름의 "
"이터러블입니다. 만약 이 인자가 지정되지 않거나 ``None``\\이면서 *argv*\\로 테스트 이름이 지정되지 않으면 "
"*module* 안에서 찾은 모든 테스트가 실행됩니다."

#: ../Doc/library/unittest.rst:2201
msgid ""
"The *argv* argument can be a list of options passed to the program, with "
"the first element being the program name.  If not specified or ``None``, "
"the values of :data:`sys.argv` are used."
msgstr ""
"*argv* 인자는 프로그램에 전달된 옵션 목록이 될 수 있습니다, 첫 번째 요소는 프로그램 이름입니다. 만약 이 인자가 지정되지 "
"않거나 ``None``\\이면, :data:`sys.argv` 값이 사용됩니다."

#: ../Doc/library/unittest.rst:2205
msgid ""
"The *testRunner* argument can either be a test runner class or an already"
" created instance of it. By default ``main`` calls :func:`sys.exit` with "
"an exit code indicating success or failure of the tests run."
msgstr ""
"*testRunner* 인자는 테스트 실행자 클래스나 이미 생성된 테스트 실행자 인스턴스일 수 있습니다. 기본적으로 "
"``main``\\은 실행한 테스트가 성공인지 실패인지를 나타내는 종료 코드와 함께 :func:`sys.exit`\\을 호출합니다."

#: ../Doc/library/unittest.rst:2209
msgid ""
"The *testLoader* argument has to be a :class:`TestLoader` instance, and "
"defaults to :data:`defaultTestLoader`."
msgstr ""
"*testLoader* 인자는 :class:`TestLoader` 인스턴스이어야 하고 기본값은 "
":data:`defaultTestLoader` 입니다."

#: ../Doc/library/unittest.rst:2212
msgid ""
"``main`` supports being used from the interactive interpreter by passing "
"in the argument ``exit=False``. This displays the result on standard "
"output without calling :func:`sys.exit`::"
msgstr ""
"``main``\\은 ``exit=False`` 인자를 전달하여 대화형 인터프리터에서 사용하는 것을 지원합니다. 이것은 "
":func:`sys.exit` 호출 없이 결과가 표준 출력에 표시됩니다::"

#: ../Doc/library/unittest.rst:2219
msgid ""
"The *failfast*, *catchbreak* and *buffer* parameters have the same effect"
" as the same-name `command-line options`_."
msgstr ""
"*failfast*, *catchbreak*, *buffer* 매개변수는 `명령행 옵션 <command-line "
"options_>`_\\의 같은 이름과 같은 효과를 가지고 있습니다."

#: ../Doc/library/unittest.rst:2222
msgid ""
"The *warnings* argument specifies the :ref:`warning filter <warning-"
"filter>` that should be used while running the tests.  If it's not "
"specified, it will remain ``None`` if a :option:`!-W` option is passed to"
" :program:`python` (see :ref:`Warning control <using-on-warnings>`), "
"otherwise it will be set to ``'default'``."
msgstr ""
"*warnings* 인자는 테스트 실행 중에 사용되어야 할 :ref:`경고 필터 <warning-filter>`\\를 지정합니다. "
"만약 아무 값도 지정되지 않았다면, :option:`!-W` 옵션이 :program:`python`\\으로 전달된 "
"경우(:ref:`경고 제어 <using-on-warnings>`\\를 보십시오)에는 ``None``\\으로 남아 있고, 그렇지 않은"
" 경우에는 ``'default'``\\로 설정됩니다."

#: ../Doc/library/unittest.rst:2228
msgid ""
"Calling ``main`` actually returns an instance of the ``TestProgram`` "
"class. This stores the result of the tests run as the ``result`` "
"attribute."
msgstr ""
"사실 ``main`` 호출은 ``TestProgram`` 클래스의 인스턴스를 반환합니다. 이것은 실행된 테스트의 결과를 "
"``result`` 어트리뷰트에 저장합니다."

#: ../Doc/library/unittest.rst:2231
msgid "The *exit* parameter was added."
msgstr "*exit* 매개변수가 추가되었습니다."

#: ../Doc/library/unittest.rst:2234
msgid ""
"The *verbosity*, *failfast*, *catchbreak*, *buffer* and *warnings* "
"parameters were added."
msgstr "*verbosity*, *failfast*, *catchbreak*, *buffer*, *warnings* 매개변수가 추가되었습니다."

#: ../Doc/library/unittest.rst:2238
msgid ""
"The *defaultTest* parameter was changed to also accept an iterable of "
"test names."
msgstr "*defaultTest* 매개변수가 테스트 이름의 이터러블도 받을 수 있게 바뀌었습니다."

#: ../Doc/library/unittest.rst:2244
msgid "load_tests Protocol"
msgstr "load_tests 프로토콜"

#: ../Doc/library/unittest.rst:2248
msgid ""
"Modules or packages can customize how tests are loaded from them during "
"normal test runs or test discovery by implementing a function called "
"``load_tests``."
msgstr ""
"``load_tests`` 라 불리는 함수를 구현함으로써 모듈이나 패키지는 일반 테스트 실행이나 테스트 탐색 중에 그것들로부터 "
"테스트가 어떻게 로드될지를 사용자 정의할 수 있습니다."

#: ../Doc/library/unittest.rst:2251
msgid ""
"If a test module defines ``load_tests`` it will be called by "
":meth:`TestLoader.loadTestsFromModule` with the following arguments::"
msgstr ""
"만약 테스트 모듈이 ``load_tests``\\를 정의했다면 그것은 다음 인자와 함께 "
":meth:`TestLoader.loadTestsFromModule`\\의해 호출될 것입니다::"

#: ../Doc/library/unittest.rst:2256
msgid ""
"where *pattern* is passed straight through from ``loadTestsFromModule``."
"  It defaults to ``None``."
msgstr ""
"여기서 *pattern*\\은 ``loadTestsFromModule``\\에서 바로 전달된 것입니다. 기본값은 "
"``None``\\입니다."

#: ../Doc/library/unittest.rst:2259
msgid "It should return a :class:`TestSuite`."
msgstr "이것은 :class:`TestSuite`\\를 반환해야 합니다."

#: ../Doc/library/unittest.rst:2261
msgid ""
"*loader* is the instance of :class:`TestLoader` doing the loading. "
"*standard_tests* are the tests that would be loaded by default from the "
"module. It is common for test modules to only want to add or remove tests"
" from the standard set of tests. The third argument is used when loading "
"packages as part of test discovery."
msgstr ""
"*loader*\\는 로딩을 실행할 :class:`TestLoader` 인스턴스입니다. *standard_tests*\\는 모듈에서"
" 기본적으로 로드될 테스트입니다. 테스트 모듈이 테스트 기본 모음에서 오직 테스트를 추가하거나 빼기를 원하는 것은 흔한 일입니다. "
"세 번째 인자는 테스트 탐색의 일부로서 패키지를 로드할 때 사용됩니다."

#: ../Doc/library/unittest.rst:2267
msgid ""
"A typical ``load_tests`` function that loads tests from a specific set of"
" :class:`TestCase` classes may look like::"
msgstr "특정 :class:`TestCase` 클래스 모음에서 테스트를 로드하는 전형적인 ``load_tests`` 함수는 다음과 같습니다::"

#: ../Doc/library/unittest.rst:2279
msgid ""
"If discovery is started in a directory containing a package, either from "
"the command line or by calling :meth:`TestLoader.discover`, then the "
"package :file:`__init__.py` will be checked for ``load_tests``.  If that "
"function does not exist, discovery will recurse into the package as "
"though it were just another directory.  Otherwise, discovery of the "
"package's tests will be left up to ``load_tests`` which is called with "
"the following arguments::"
msgstr ""
"만약 탐색이 명령행 또는 :meth:`TestLoader.discover`\\로부터, 패키지가 포함된 디렉터리에서 시작된다면, "
"``load_tests``\\를 위해 패키지 :file:`__init__.py`\\를 검사합니다. 만약 함수가 존재하지 않으면, "
"탐색은 그저 다른 디렉터리인 것처럼 패키지 안을 재귀 순회할 것입니다. 그렇지 않다면, 패키지의 테스트를 위한 탐색은 다음 인자와 "
"함께 불리는 ``load_tests``\\에게 맡겨질 것입니다::"

#: ../Doc/library/unittest.rst:2288
msgid ""
"This should return a :class:`TestSuite` representing all the tests from "
"the package. (``standard_tests`` will only contain tests collected from "
":file:`__init__.py`.)"
msgstr ""
"이것은 패키지의 모든 테스트에 해당하는 :class:`TestSuite`\\를 반환해야 합니다. "
"(``standard_tests``\\는 오직 :file:`__init__.py`\\로부터 수집된 테스트만 포함할 것입니다."

#: ../Doc/library/unittest.rst:2292
msgid ""
"Because the pattern is passed into ``load_tests`` the package is free to "
"continue (and potentially modify) test discovery. A 'do nothing' "
"``load_tests`` function for a test package would look like::"
msgstr ""
"패턴이 load_tests로 전달되기 때문에 패키지는 테스트 검색을 계속 진행(그리고 잠재적으로 수정)할 수 있습니다. 테스트 "
"패키지를 위해서 '아무것도 하지 않는' ``load_tests`` 함수는 다음과 같을 것입니다::"

#: ../Doc/library/unittest.rst:2303
msgid ""
"Discovery no longer checks package names for matching *pattern* due to "
"the impossibility of package names matching the default pattern."
msgstr ""
"패키지 이름이 기본 패턴과 일치하는 것이 불가능하기 때문에 탐색이 더는 *pattern* 일치를 위해서 패키지 이름을 검사하지 "
"않습니다."

#: ../Doc/library/unittest.rst:2310
msgid "Class and Module Fixtures"
msgstr "클래스와 모듈 픽스쳐"

#: ../Doc/library/unittest.rst:2312
msgid ""
"Class and module level fixtures are implemented in :class:`TestSuite`. "
"When the test suite encounters a test from a new class then "
":meth:`tearDownClass` from the previous class (if there is one) is "
"called, followed by :meth:`setUpClass` from the new class."
msgstr ""
"클래스와 모듈 단계의 픽스쳐는 :class:`TestSuite`\\에 구현되어 있습니다. 테스트 묶음이 새로운 클래스의 테스트를 "
"만나면(만약 존재한다면) 이전 클래스의 :meth:`tearDownClass` 가 호출되고, 이어 새로운 클래스의 "
":meth:`setUpClass`\\가 호출됩니다."

#: ../Doc/library/unittest.rst:2317
msgid ""
"Similarly if a test is from a different module from the previous test "
"then ``tearDownModule`` from the previous module is run, followed by "
"``setUpModule`` from the new module."
msgstr ""
"마찬가지로 만약 테스트가 이전 테스트와 다른 모듈의 것이라면 이전 모듈의 ``tearDownModule``\\이 실행되고, 이어 "
"새로운 모듈의 ``setUpModule``\\이 호출됩니다."

#: ../Doc/library/unittest.rst:2321
msgid ""
"After all the tests have run the final ``tearDownClass`` and "
"``tearDownModule`` are run."
msgstr "모든 테스트가 실행된 뒤에 마지막으로 ``tearDownClass``\\와 ``tearDownModule``\\이 실행됩니다."

#: ../Doc/library/unittest.rst:2324
msgid ""
"Note that shared fixtures do not play well with [potential] features like"
" test parallelization and they break test isolation. They should be used "
"with care."
msgstr ""
"공유하는 픽스쳐의 경우 테스트 병렬화와 같은 [잠재적인] 기능과 잘 동작하지 않고 이것은 테스트 분리를 망가트립니다. 이것을 주의 "
"깊게 사용해야 합니다."

#: ../Doc/library/unittest.rst:2327
msgid ""
"The default ordering of tests created by the unittest test loaders is to "
"group all tests from the same modules and classes together. This will "
"lead to ``setUpClass`` / ``setUpModule`` (etc) being called exactly once "
"per class and module. If you randomize the order, so that tests from "
"different modules and classes are adjacent to each other, then these "
"shared fixture functions may be called multiple times in a single test "
"run."
msgstr ""
"unittest의 테스트 로더에 의해 생성된 테스트들의 기본 정렬 순서는 같은 모듈과 클래스의 모든 테스트를 그룹화하는 것입니다. "
"이것은 ``setUpClass`` / ``setUpModule``\\(등) 이 클래스와 모듈별로 정확하게 1번씩 호출되게 할 "
"것입니다. 만약 당신이 무작위로 순서를 정하여, 그래서 다른 모듈과 클래스의 테스트가 서로 인접한다면, 이 공유 픽스처 함수는 "
"1번의 테스트 실행에서 여러 번 호출될 수 있습니다."

#: ../Doc/library/unittest.rst:2334
msgid ""
"Shared fixtures are not intended to work with suites with non-standard "
"ordering. A ``BaseTestSuite`` still exists for frameworks that don't want"
" to support shared fixtures."
msgstr ""
"공유 픽스처는 비표준 정렬 순서를 사용하는 테스트 묶음과 같이 작동하는 것을 의도하지 않습니다. 공유 픽스처를 지원하길 원치 않는 "
"프레임워크를 위해서 ``BaseTestSuite``\\가 여전히 존재합니다."

#: ../Doc/library/unittest.rst:2338
msgid ""
"If there are any exceptions raised during one of the shared fixture "
"functions the test is reported as an error. Because there is no "
"corresponding test instance an ``_ErrorHolder`` object (that has the same"
" interface as a :class:`TestCase`) is created to represent the error. If "
"you are just using the standard unittest test runner then this detail "
"doesn't matter, but if you are a framework author it may be relevant."
msgstr ""
"공유 픽스처 함수 중 1개에서 발생한 예외가 있다면, 테스트를 에러로 보고합니다. 해당 테스트 인스턴스가 없기 때문에 에러를 "
"나타내기 위해 ``_ErrorHolder`` 객체(:class:`TestCase`\\와 같은 인터페이스를 가진)가 생성됩니다. "
"당신이 그저 표준 unittest의 테스트 실행자를 사용한다면 이 세부 항목은 중요하지 않습니다, 그러나 당신이 프레임워크의 "
"저자라면 이것은 관련이 있을 수 있습니다."

#: ../Doc/library/unittest.rst:2347
msgid "setUpClass and tearDownClass"
msgstr "setUpClass 와 tearDownClass"

#: ../Doc/library/unittest.rst:2349
msgid "These must be implemented as class methods::"
msgstr "이것들은 반드시 클래스 메서드로 구현되어야 합니다::"

#: ../Doc/library/unittest.rst:2362
msgid ""
"If you want the ``setUpClass`` and ``tearDownClass`` on base classes "
"called then you must call up to them yourself. The implementations in "
":class:`TestCase` are empty."
msgstr ""
"만약 당신이 베이스 클래스의 ``setUpClass``\\와 ``tearDownClass``\\를 호출하고 싶다면 당신이 그것을 "
"직접 호출해야만 합니다. :class:`TestCase`\\의 구현은 비어있습니다."

#: ../Doc/library/unittest.rst:2366
msgid ""
"If an exception is raised during a ``setUpClass`` then the tests in the "
"class are not run and the ``tearDownClass`` is not run. Skipped classes "
"will not have ``setUpClass`` or ``tearDownClass`` run. If the exception "
"is a :exc:`SkipTest` exception then the class will be reported as having "
"been skipped instead of as an error."
msgstr ""
"만약 ``setUpClass`` 중에 예외가 발생한다면 클래스의 테스트는 실행되지 않고 ``tearDownClass`` 는 실행되지"
" 않습니다. 건너뛴 클래스는 ``setUpClass`` 또는 ``tearDownClass``\\가 실행되지 않을 것입니다. 만약 "
"예외가 :exc:`SkipTest` 예외라면 클래스는 에러 대신 건너뛰어졌다고 보고될 것입니다."

#: ../Doc/library/unittest.rst:2374
msgid "setUpModule and tearDownModule"
msgstr "setUpModule 과 tearDownModule"

#: ../Doc/library/unittest.rst:2376
msgid "These should be implemented as functions::"
msgstr "이것들은 함수로 구현되어야 합니다::"

#: ../Doc/library/unittest.rst:2384
msgid ""
"If an exception is raised in a ``setUpModule`` then none of the tests in "
"the module will be run and the ``tearDownModule`` will not be run. If the"
" exception is a :exc:`SkipTest` exception then the module will be "
"reported as having been skipped instead of as an error."
msgstr ""
"만약 ``setUpModule`` 중에 예외가 발생한다면 모듈의 테스트는 실행되지 않고 ``tearDownModule`` 는 "
"실행되지 않습니다. 만약 예외가 :exc:`SkipTest` 예외라면 모듈은 에러 대신 건너뛰어졌다고 보고될 것입니다."

#: ../Doc/library/unittest.rst:2389
msgid ""
"To add cleanup code that must be run even in the case of an exception, "
"use ``addModuleCleanup``:"
msgstr "예외가 발생하는 경우에도 실행해야 하는 정리 코드를 추가하려면, ``addModuleCleanup``\\을 사용하십시오:"

#: ../Doc/library/unittest.rst:2395
msgid ""
"Add a function to be called after :func:`tearDownModule` to cleanup "
"resources used during the test class. Functions will be called in reverse"
" order to the order they are added (:abbr:`LIFO (last-in, first-out)`). "
"They are called with any arguments and keyword arguments passed into "
":meth:`addModuleCleanup` when they are added."
msgstr ""
"테스트 클래스 중에 사용된 자원을 정리하기 위해 :func:`tearDownModule` 이후에 불리는 함수를 추가합니다. 함수들은"
" 추가된 순서의 반대 순서대로 불리게 됩니다(:abbr:`LIFO(후입 선출법(last-in, first-out))`). 함수가 "
"추가될 때 :meth:`addModuleCleanup`\\에 같이 전달된 위치 인자나 키워드 인자와 함께 호출됩니다. "

#: ../Doc/library/unittest.rst:2401
msgid ""
"If :meth:`setUpModule` fails, meaning that :func:`tearDownModule` is not "
"called, then any cleanup functions added will still be called."
msgstr ""
"만약 :meth:`setUpModule`\\이 실패한다면, 즉 :func:`tearDownModule`\\이 불리지 않더라도, 정리"
" 함수들은 여전히 불리게 될 것입니다."

#: ../Doc/library/unittest.rst:2409
msgid ""
"This function is called unconditionally after :func:`tearDownModule`, or "
"after :func:`setUpModule` if :func:`setUpModule` raises an exception."
msgstr ""
"이 함수는 :func:`tearDownModule` 이후나, :func:`setUpModule`\\이 예외를 발생시키면 "
":func:`setUpModule`\\이후에 조건 없이 호출됩니다."

#: ../Doc/library/unittest.rst:2412
msgid ""
"It is responsible for calling all the cleanup functions added by "
":func:`addCleanupModule`. If you need cleanup functions to be called "
"*prior* to :func:`tearDownModule` then you can call "
":func:`doModuleCleanups` yourself."
msgstr ""
":func:`addCleanupModule`\\에서 추가된 모든 정리 함수들을 호출하는 책임이 있습니다. 만약 정리 함수를 "
":func:`tearDownModule` *이전에* 불러야 할 필요가 있다면 :func:`doModuleCleanups`\\를 직접"
" 부를 수 있습니다. "

#: ../Doc/library/unittest.rst:2417
msgid ""
":func:`doModuleCleanups` pops methods off the stack of cleanup functions "
"one at a time, so it can be called at any time."
msgstr ""
":func:`doModuleCleanups`\\는 한 번에 하나씩 정리 함수 스택에서 메서드를 꺼내기 때문에 언제든지 호출될 수 "
"있습니다."

#: ../Doc/library/unittest.rst:2423
msgid "Signal Handling"
msgstr "시그널 처리하기"

#: ../Doc/library/unittest.rst:2427
msgid ""
"The :option:`-c/--catch <unittest -c>` command-line option to unittest, "
"along with the ``catchbreak`` parameter to :func:`unittest.main()`, "
"provide more friendly handling of control-C during a test run. With catch"
" break behavior enabled control-C will allow the currently running test "
"to complete, and the test run will then end and report all the results so"
" far. A second control-c will raise a :exc:`KeyboardInterrupt` in the "
"usual way."
msgstr ""
"unittest의 :option:`-c/--catch <unittest -c>` 명령행 옵션은, "
":func:`unittest.main()`\\의 ``catchbreak`` 매개 변수와 함께, 테스트 실행 중에 control-C를"
" 사용하기 편하게 처리하도록 합니다. 중단 시그널 잡기를 활성화 하면 control-C는 현재 실행 중인 테스트를 완료하고, 그러면"
" 테스트 실행이 끝나고 이제까지의 모든 결과를 보고할 것입니다. 두 번째 control-c는 평소와 같이 "
":exc:`KeyboardInterrupt`\\를 발생할 것입니다."

#: ../Doc/library/unittest.rst:2434
msgid ""
"The control-c handling signal handler attempts to remain compatible with "
"code or tests that install their own :const:`signal.SIGINT` handler. If "
"the ``unittest`` handler is called but *isn't* the installed "
":const:`signal.SIGINT` handler, i.e. it has been replaced by the system "
"under test and delegated to, then it calls the default handler. This will"
" normally be the expected behavior by code that replaces an installed "
"handler and delegates to it. For individual tests that need ``unittest`` "
"control-c handling disabled the :func:`removeHandler` decorator can be "
"used."
msgstr ""
"control-c 시그널 처리기는 자체 :const:`signal.SIGINT` 처리기를 설치하는 코드 또는 테스트와의 호환성을 "
"유지하려고 노력합니다. 만약 ``unittest`` 처리기가 불리지만 그것이 설치된 :const:`signal.SIGINT` "
"처리기가 *아니면*, 즉 그것이 테스트 중에 시스템에 의해 대체되고 위임된다면, 그것은 기본 처리기를 호출합니다. 이것은 설치된 "
"처리기를 대체하고 위임하는 코드에 의해 일반적으로 기대되는 동작입니다. ``unittest`` control-c 처리를 개별 테스트"
" 별로 비활성화하고 싶을 때는 :func:`removeHandler` 데코레이터를 사용할 수 있습니다."

#: ../Doc/library/unittest.rst:2443
msgid ""
"There are a few utility functions for framework authors to enable "
"control-c handling functionality within test frameworks."
msgstr "프레임워크 작성자가 테스트 프레임워크에서 control-c 처리 기능을 활성화하기 위해 몇 가지 유틸리티 함수가 있습니다."

#: ../Doc/library/unittest.rst:2448
msgid ""
"Install the control-c handler. When a :const:`signal.SIGINT` is received "
"(usually in response to the user pressing control-c) all registered "
"results have :meth:`~TestResult.stop` called."
msgstr ""
"control-c 처리기를 설치합니다. :const:`signal.SIGINT`\\를 받았을 때(보통 사용자가 control-c를 "
"눌렀을 때의 응답으로써) 모든 등록된 결과에 :meth:`~TestResult.stop`\\이 호출됩니다."

#: ../Doc/library/unittest.rst:2455
msgid ""
"Register a :class:`TestResult` object for control-c handling. Registering"
" a result stores a weak reference to it, so it doesn't prevent the result"
" from being garbage collected."
msgstr ""
"control-c 처리를 위해서 :class:`TestResult` 객체를 등록합니다. 결과 등록은 그것의 약한 참조를 저장합니다,"
" 그래서 결과가 가비지 수거되는 것을 막지 않습니다."

#: ../Doc/library/unittest.rst:2459
msgid ""
"Registering a :class:`TestResult` object has no side-effects if control-c"
" handling is not enabled, so test frameworks can unconditionally register"
" all results they create independently of whether or not handling is "
"enabled."
msgstr ""
"만약 control-c 처리가 활성화되지 않았다면 :class:`TestResult` 객체 등록은 부작용이 없습니다, 그래서 테스트"
" 프레임워크는 처리가 가능한지 여부와 관계없이 자신이 만든 모든 결과를 무조건 등록할 수 있습니다."

#: ../Doc/library/unittest.rst:2466
msgid ""
"Remove a registered result. Once a result has been removed then "
":meth:`~TestResult.stop` will no longer be called on that result object "
"in response to a control-c."
msgstr ""
"등록한 결과를 제거합니다. 결과가 제거되고 나면 control-c에 대한 응답으로 결과 객체의 "
":meth:`~TestResult.stop`\\을 더는 호출하지 않게 됩니다."

#: ../Doc/library/unittest.rst:2473
msgid ""
"When called without arguments this function removes the control-c handler"
" if it has been installed. This function can also be used as a test "
"decorator to temporarily remove the handler while the test is being "
"executed::"
msgstr ""
"인자 없이 호출된 경우 이 함수는 만약 control-c 처리기가 설치되었다면 그것을 제거합니다. 또한 이 함수는 테스트 실행 중에"
" 임시로 처리기를 제거하기 위해 테스트 데코레이터로써 사용될 수도 있습니다::"

