# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-07-15 15:23+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/exceptions.rst:4
msgid "Built-in Exceptions"
msgstr "내장 예외"

#: ../Doc/library/exceptions.rst:10
msgid ""
"In Python, all exceptions must be instances of a class that derives from "
":class:`BaseException`.  In a :keyword:`try` statement with an "
":keyword:`except` clause that mentions a particular class, that clause "
"also handles any exception classes derived from that class (but not "
"exception classes from which *it* is derived).  Two exception classes "
"that are not related via subclassing are never equivalent, even if they "
"have the same name."
msgstr ""
"파이썬에서, 모든 예외는 :class:`BaseException` 에서 파생된 클래스의 인스턴스여야 합니다. 특정 클래스를 언급하는"
" :keyword:`except` 절을 갖는 :keyword:`try` 문에서, 그 절은 그 클래스에서 파생된 모든 예외 클래스를 "
"처리합니다 (하지만 *그것* 이 계승하는 예외 클래스는 처리하지 않습니다). 서브 클래싱을 통해 관련되지 않은 두 개의 예외 "
"클래스는 같은 이름을 갖는다 할지라도 결코 등등하게 취급되지 않습니다."

#: ../Doc/library/exceptions.rst:19
msgid ""
"The built-in exceptions listed below can be generated by the interpreter "
"or built-in functions.  Except where mentioned, they have an \"associated"
" value\" indicating the detailed cause of the error.  This may be a "
"string or a tuple of several items of information (e.g., an error code "
"and a string explaining the code).  The associated value is usually "
"passed as arguments to the exception class's constructor."
msgstr ""
"아래 나열된 내장 예외는 인터프리터나 내장 함수에 의해 생성될 수 있습니다. 따로 언급된 경우를 제외하고는, 에러의 자세한 원인을 "
"나타내는 \"연관된 값\"을 갖습니다. 이것은 여러 항목의 정보 (예, 에러 코드와 그 코드를 설명하는 문자열)를 담은 문자열이나 "
"튜플 일 수 있습니다. 연관된 값은 보통 예외 클래스의 생성자에 인자로 전달됩니다."

#: ../Doc/library/exceptions.rst:26
msgid ""
"User code can raise built-in exceptions.  This can be used to test an "
"exception handler or to report an error condition \"just like\" the "
"situation in which the interpreter raises the same exception; but beware "
"that there is nothing to prevent user code from raising an inappropriate "
"error."
msgstr ""
"사용자 코드는 내장 예외를 일으킬 수 있습니다. 이것은 예외 처리기를 검사하거나 인터프리터가 같은 예외를 발생시키는 상황과 "
"\"같은\" 에러 조건을 보고하는 데 사용할 수 있습니다. 그러나 사용자 코드가 부적절한 에러를 발생시키는 것을 막을 방법이 없음을"
" 유의하십시오."

#: ../Doc/library/exceptions.rst:31
msgid ""
"The built-in exception classes can be subclassed to define new "
"exceptions; programmers are encouraged to derive new exceptions from the "
":exc:`Exception` class or one of its subclasses, and not from "
":exc:`BaseException`.  More information on defining exceptions is "
"available in the Python Tutorial under :ref:`tut-userexceptions`."
msgstr ""
"내장 예외 클래스는 새 예외를 정의하기 위해 서브 클래싱 될 수 있습니다. :exc:`BaseException` 이 아니라 "
":exc:`Exception` 클래스 나 그 서브 클래스 중 하나에서 새로운 예외를 파생시킬 것을 권장합니다. 예외 정의에 대한 더"
" 많은 정보는 파이썬 자습서의 :ref:`tut-userexceptions` 에 있습니다."

#: ../Doc/library/exceptions.rst:37
msgid ""
"When raising (or re-raising) an exception in an :keyword:`except` or "
":keyword:`finally` clause :attr:`__context__` is automatically set to the"
" last exception caught; if the new exception is not handled the traceback"
" that is eventually displayed will include the originating exception(s) "
"and the final exception."
msgstr ""
":keyword:`except` 또는 :keyword:`finally` 절에서 예외를 일으킬 때 (또는 다시 일으킬 때), "
":attr:`__context__` 는 자동으로 마지막으로 잡힌 예외로 설정됩니다; 이 새 예외가 처리되지 않으면, 결국 표시되는 "
"트레이스백은 원래 예외와 최종 예외를 포함합니다."

#: ../Doc/library/exceptions.rst:43
msgid ""
"When raising a new exception (rather than using a bare ``raise`` to re-"
"raise the exception currently being handled), the implicit exception "
"context can be supplemented with an explicit cause by using "
":keyword:`from` with :keyword:`raise`::"
msgstr ""
"(현재 처리 중인 예외를 다시 발생시키기 위해 ``raise``\\만 사용하는 대신) 새 예외를 일으킬 때, 묵시적인 예외 "
"컨텍스트는 암시적인 예외 상황은 명시적 원인으로 보충될 수 있는데, :keyword:`raise`\\와 "
":keyword:`from`\\을 사용합니다::"

#: ../Doc/library/exceptions.rst:50
msgid ""
"The expression following :keyword:`from` must be an exception or "
"``None``. It will be set as :attr:`__cause__` on the raised exception. "
"Setting :attr:`__cause__` also implicitly sets the "
":attr:`__suppress_context__` attribute to ``True``, so that using ``raise"
" new_exc from None`` effectively replaces the old exception with the new "
"one for display purposes (e.g. converting :exc:`KeyError` to "
":exc:`AttributeError`), while leaving the old exception available in "
":attr:`__context__` for introspection when debugging."
msgstr ""
":keyword:`from` 다음의 표현식은 예외이거나 ``None`` 이어야 합니다. 이 표현식을 새로 일으키는 예외의 "
":attr:`__cause__` 로 설정합니다. :attr:`__cause__` 를 설정하면, 묵시적으로 "
":attr:`__suppress_context__` 를 ``True`` 로 설정합니다. 그래서, ``raise new_exc "
"from None`` 을 사용하면 표시의 목적상 이전 예외를 새로운 것으로 대체 하는 효과를 주면서 (예를 들어 "
":exc:`KeyError` 를 :exc:`AttributeError` 로), 디버깅할 때 검사할 수 있도록 이전의 예외를 "
":attr:`__context__` 에 남겨둡니다."

#: ../Doc/library/exceptions.rst:59
msgid ""
"The default traceback display code shows these chained exceptions in "
"addition to the traceback for the exception itself. An explicitly chained"
" exception in :attr:`__cause__` is always shown when present. An "
"implicitly chained exception in :attr:`__context__` is shown only if "
":attr:`__cause__` is :const:`None` and :attr:`__suppress_context__` is "
"false."
msgstr ""
"기본 트레이스백 표시 코드는 예외 자체의 트레이스백 뿐만 아니라 이러한 연결된 예외를 보여줍니다. :attr:`__cause__` "
"에 명시적으로 연결된 예외는 있으면 항상 표시됩니다. :attr:`__context__` 에 묵시적으로 연결된 예외는 "
":attr:`__cause__` 가 :const:`None` 이고 :attr:`__suppress_context__` 가 거짓인 "
"경우에만 표시됩니다."

#: ../Doc/library/exceptions.rst:65
msgid ""
"In either case, the exception itself is always shown after any chained "
"exceptions so that the final line of the traceback always shows the last "
"exception that was raised."
msgstr "두 경우 모두, 예외 자신은 항상 연결된 예외 뒤에 표시되어서, 트레이스백의 마지막 줄은 항상 마지막에 발생한 예외를 보여줍니다."

#: ../Doc/library/exceptions.rst:71
msgid "Base classes"
msgstr "베이스 클래스"

#: ../Doc/library/exceptions.rst:73
msgid ""
"The following exceptions are used mostly as base classes for other "
"exceptions."
msgstr "다음 예외는 주로 다른 예외의 베이스 클래스로 사용됩니다."

#: ../Doc/library/exceptions.rst:77
msgid ""
"The base class for all built-in exceptions.  It is not meant to be "
"directly inherited by user-defined classes (for that, use "
":exc:`Exception`).  If :func:`str` is called on an instance of this "
"class, the representation of the argument(s) to the instance are "
"returned, or the empty string when there were no arguments."
msgstr ""
"모든 내장 예외의 베이스 클래스입니다. 사용자 정의 클래스에 의해 직접 상속되는 것이 아닙니다 (그런 목적으로는 "
":exc:`Exception`\\을 사용하세요). 이 클래스의 인스턴스에 대해 :func:`str` 이 호출되면, 인스턴스로 전달된"
" 인자(들)의 표현을 돌려줍니다. 인자가 없는 경우는 빈 문자열을 돌려줍니다."

#: ../Doc/library/exceptions.rst:85
msgid ""
"The tuple of arguments given to the exception constructor.  Some built-in"
" exceptions (like :exc:`OSError`) expect a certain number of arguments "
"and assign a special meaning to the elements of this tuple, while others "
"are usually called only with a single string giving an error message."
msgstr ""
"예외 생성자에 주어진 인자들의 튜플. 일부 내장 예외(예, :exc:`OSError`)는 특정 수의 인자를 기대하고 이 튜플의 "
"요소에 특별한 의미를 할당하는 반면, 다른 것들은 보통 오류 메시지를 제공하는 단일 문자열로만 호출됩니다."

#: ../Doc/library/exceptions.rst:92
msgid ""
"This method sets *tb* as the new traceback for the exception and returns "
"the exception object.  It is usually used in exception handling code like"
" this::"
msgstr ""
"이 메서드는 *tb* 를 예외의 새 트레이스백으로 설정하고 예외 객체를 돌려줍니다. 일반적으로 다음과 같은 예외 처리 코드에서 "
"사용됩니다::"

#: ../Doc/library/exceptions.rst:105
msgid ""
"All built-in, non-system-exiting exceptions are derived from this class."
"  All user-defined exceptions should also be derived from this class."
msgstr "모든 시스템 종료 외의 내장 예외는 이 클래스 파생됩니다. 모든 사용자 정의 예외도 이 클래스에서 파생되어야 합니다."

#: ../Doc/library/exceptions.rst:111
msgid ""
"The base class for those built-in exceptions that are raised for various "
"arithmetic errors: :exc:`OverflowError`, :exc:`ZeroDivisionError`, "
":exc:`FloatingPointError`."
msgstr ""
"다양한 산술 에러가 일으키는 내장 예외들의 베이스 클래스: :exc:`OverflowError`, "
":exc:`ZeroDivisionError`, :exc:`FloatingPointError`."

#: ../Doc/library/exceptions.rst:118
msgid ""
"Raised when a :ref:`buffer <bufferobjects>` related operation cannot be "
"performed."
msgstr ":ref:`버퍼 <bufferobjects>` 관련 연산을 수행할 수 없을 때 발생합니다."

#: ../Doc/library/exceptions.rst:124
msgid ""
"The base class for the exceptions that are raised when a key or index "
"used on a mapping or sequence is invalid: :exc:`IndexError`, "
":exc:`KeyError`.  This can be raised directly by :func:`codecs.lookup`."
msgstr ""
"매핑 또는 시퀀스에 사용된 키 나 인덱스가 잘못되었을 때 발생하는 예외의 베이스 클래스: :exc:`IndexError`, "
":exc:`KeyError`. :func:`codecs.lookup` 은 이 예외를 직접 일으킬 수 있습니다."

#: ../Doc/library/exceptions.rst:130
msgid "Concrete exceptions"
msgstr "구체적인 예외"

#: ../Doc/library/exceptions.rst:132
msgid "The following exceptions are the exceptions that are usually raised."
msgstr "다음 예외는 일반적으로 직접 일으키는데 사용하는 예외입니다."

#: ../Doc/library/exceptions.rst:138
msgid "Raised when an :keyword:`assert` statement fails."
msgstr ":keyword:`assert` 문이 실패할 때 발생합니다."

#: ../Doc/library/exceptions.rst:143
msgid ""
"Raised when an attribute reference (see :ref:`attribute-references`) or "
"assignment fails.  (When an object does not support attribute references "
"or attribute assignments at all, :exc:`TypeError` is raised.)"
msgstr ""
"어트리뷰트 참조(:ref:`attribute-references`\\를 보세요)나 대입이 실패할 때 발생합니다. (객체가 어트리뷰트"
" 참조나 어트리뷰트 대입을 아예 지원하지 않으면 :exc:`TypeError` 가 발생합니다.)"

#: ../Doc/library/exceptions.rst:150
msgid ""
"Raised when the :func:`input` function hits an end-of-file condition "
"(EOF) without reading any data. (N.B.: the :meth:`io.IOBase.read` and "
":meth:`io.IOBase.readline` methods return an empty string when they hit "
"EOF.)"
msgstr ""
":func:`input` 함수가 데이터를 읽지 못한 상태에서 EOF (end-of-file) 조건을 만날 때 발생합니다. "
"(주의하세요: :meth:`io.IOBase.read` 와 :meth:`io.IOBase.readline` 메서드는 EOF를 만날 "
"때 빈 문자열을 돌려줍니다.)"

#: ../Doc/library/exceptions.rst:157
msgid "Not currently used."
msgstr "현재 사용되지 않습니다."

#: ../Doc/library/exceptions.rst:162
msgid ""
"Raised when a :term:`generator` or :term:`coroutine` is closed; see "
":meth:`generator.close` and :meth:`coroutine.close`.  It directly "
"inherits from :exc:`BaseException` instead of :exc:`Exception` since it "
"is technically not an error."
msgstr ""
":term:`제너레이터 <generator>` 또는 :term:`코루틴 <coroutine>` 이 닫힐 때 발생합니다; "
":meth:`generator.close` 와 :meth:`coroutine.close` 를 보십시오. 기술적으로 에러가 아니므로 "
":exc:`Exception` 대신에 :exc:`BaseException` 을 직접 계승합니다."

#: ../Doc/library/exceptions.rst:170
msgid ""
"Raised when the :keyword:`import` statement has troubles trying to load a"
" module.  Also raised when the \"from list\" in ``from ... import`` has a"
" name that cannot be found."
msgstr ""
":keyword:`import` 문이 모듈을 로드하는 데 문제가 있을 때 발생합니다. 또한 ``from ... import`` 에서"
" 임포트 하려는 이름을 찾을 수 없을 때도 발생합니다."

#: ../Doc/library/exceptions.rst:174
msgid ""
"The :attr:`name` and :attr:`path` attributes can be set using keyword-"
"only arguments to the constructor. When set they represent the name of "
"the module that was attempted to be imported and the path to any file "
"which triggered the exception, respectively."
msgstr ""
":attr:`name`\\과 :attr:`path` 어트리뷰트는 생성자에 키워드 전용 인자를 사용하여 설정할 수 있습니다. 설정된 "
"경우, 각각 임포트하려고 시도한 모듈의 이름과 예외를 유발한 파일의 경로를 나타냅니다."

#: ../Doc/library/exceptions.rst:179
msgid "Added the :attr:`name` and :attr:`path` attributes."
msgstr ":attr:`name`\\과 :attr:`path` 어트리뷰트를 추가했습니다."

#: ../Doc/library/exceptions.rst:184
msgid ""
"A subclass of :exc:`ImportError` which is raised by :keyword:`import` "
"when a module could not be located.  It is also raised when ``None`` is "
"found in :data:`sys.modules`."
msgstr ""
":exc:`ImportError` 의 서브 클래스인데, 모듈을 찾을 수 없을 때 :keyword:`import` 가 일으킵니다. "
":data:`sys.modules` 에서 ``None`` 이 발견될 때도 발생합니다."

#: ../Doc/library/exceptions.rst:193
msgid ""
"Raised when a sequence subscript is out of range.  (Slice indices are "
"silently truncated to fall in the allowed range; if an index is not an "
"integer, :exc:`TypeError` is raised.)"
msgstr ""
"시퀀스 인덱스가 범위를 벗어날 때 발생합니다. (슬라이스 인덱스는 허용된 범위 내에 들어가도록 자동으로 잘립니다; 인덱스가 정수가 "
"아니면 :exc:`TypeError` 가 발생합니다.)"

#: ../Doc/library/exceptions.rst:202
msgid ""
"Raised when a mapping (dictionary) key is not found in the set of "
"existing keys."
msgstr "매핑 (딕셔너리) 키가 기존 키 집합에서 발견되지 않을 때 발생합니다."

#: ../Doc/library/exceptions.rst:209
msgid ""
"Raised when the user hits the interrupt key (normally :kbd:`Control-C` or"
" :kbd:`Delete`).  During execution, a check for interrupts is made "
"regularly. The exception inherits from :exc:`BaseException` so as to not "
"be accidentally caught by code that catches :exc:`Exception` and thus "
"prevent the interpreter from exiting."
msgstr ""
"사용자가 인터럽트 키(일반적으로 :kbd:`Control-C` 또는 :kbd:`Delete`)를 누를 때 발생합니다. 실행 중에 "
"인터럽트 검사가 정기적으로 수행됩니다. :exc:`Exception`\\을 잡는 코드에 의해 우연히 잡혀서, 인터프리터가 종료하는 "
"것을 막지 못하도록 :exc:`BaseException` 를 계승합니다."

#: ../Doc/library/exceptions.rst:218
msgid ""
"Raised when an operation runs out of memory but the situation may still "
"be rescued (by deleting some objects).  The associated value is a string "
"indicating what kind of (internal) operation ran out of memory. Note that"
" because of the underlying memory management architecture (C's "
":c:func:`malloc` function), the interpreter may not always be able to "
"completely recover from this situation; it nevertheless raises an "
"exception so that a stack traceback can be printed, in case a run-away "
"program was the cause."
msgstr ""
"작업에 메모리가 부족하지만, 상황이 여전히 (일부 객체를 삭제해서) 복구될 수 있는 경우 발생합니다. 연관된 값은 어떤 종류의 "
"(내부) 연산이 메모리를 다 써 버렸는지를 나타내는 문자열입니다. 하부 메모리 관리 아키텍처(C의 :c:func:`malloc` "
"함수)때문에, 인터프리터가 항상 이 상황을 완벽하게 복구할 수 있는 것은 아닙니다; 그런데도 통제를 벗어난 프로그램이 원인인 경우를"
" 위해, 스택 트레이스백을 인쇄할 수 있도록 예외를 일으킵니다."

#: ../Doc/library/exceptions.rst:229
msgid ""
"Raised when a local or global name is not found.  This applies only to "
"unqualified names.  The associated value is an error message that "
"includes the name that could not be found."
msgstr ""
"지역 또는 전역 이름을 찾을 수 없을 때 발생합니다. 이는 정규화되지 않은 이름에만 적용됩니다. 연관된 값은 찾을 수 없는 이름을 "
"포함하는 에러 메시지입니다."

#: ../Doc/library/exceptions.rst:236
msgid ""
"This exception is derived from :exc:`RuntimeError`.  In user defined base"
" classes, abstract methods should raise this exception when they require "
"derived classes to override the method, or while the class is being "
"developed to indicate that the real implementation still needs to be "
"added."
msgstr ""
"이 예외는 :exc:`RuntimeError` 에서 파생됩니다. 사용자 정의 베이스 클래스에서, 파생 클래스가 재정의하도록 요구하는"
" 추상 메서드나, 클래스가 개발되는 도중에 실제 구현이 추가될 필요가 있음을 나타낼 때 이 예외를 발생시켜야 합니다."

#: ../Doc/library/exceptions.rst:243
msgid ""
"It should not be used to indicate that an operator or method is not meant"
" to be supported at all -- in that case either leave the operator / "
"method undefined or, if a subclass, set it to :data:`None`."
msgstr ""
"연산자 나 메서드가 아예 지원되지 않는다는 것을 나타내는 데 사용해서는 안 됩니다 -- 그 경우는 연산자 / 메서드를 정의하지 "
"않거나, 서브 클래스면 :data:`None` 으로 설정하십시오."

#: ../Doc/library/exceptions.rst:249
msgid ""
"``NotImplementedError`` and ``NotImplemented`` are not interchangeable, "
"even though they have similar names and purposes.  See "
":data:`NotImplemented` for details on when to use it."
msgstr ""
"``NotImplementedError`` 와 ``NotImplemented`` 는 비슷한 이름과 목적이 있습니다만, 바꿔쓸 수 "
"없습니다. 언제 사용하는지에 대한 자세한 내용은 :data:`NotImplemented` 를 참조하세요."

#: ../Doc/library/exceptions.rst:258
msgid ""
"This exception is raised when a system function returns a system-related "
"error, including I/O failures such as \"file not found\" or \"disk full\""
" (not for illegal argument types or other incidental errors)."
msgstr ""
"이 예외는 시스템 함수가 시스템 관련 에러를 돌려줄 때 발생하는데, \"파일을 찾을 수 없습니다(file not found)\" 나"
" \"디스크가 꽉 찼습니다(disk full)\" 와 같은 (잘못된 인자형이나 다른 부수적인 에러가 아닌) 입출력 실패를 "
"포함합니다."

#: ../Doc/library/exceptions.rst:262
msgid ""
"The second form of the constructor sets the corresponding attributes, "
"described below.  The attributes default to :const:`None` if not "
"specified.  For backwards compatibility, if three arguments are passed, "
"the :attr:`~BaseException.args` attribute contains only a 2-tuple of the "
"first two constructor arguments."
msgstr ""
"생성자의 두 번째 형식은 아래에 설명된 해당 어트리뷰트를 설정합니다. 어트리뷰트를 지정하지 않으면 기본적으로 "
":const:`None` 이 됩니다. 이전 버전과의 호환성을 위해, 세 개의 인자가 전달되면, "
":attr:`~BaseException.args` 어트리뷰트는 처음 두 생성자 인자의 2-튜플만 포함합니다."

#: ../Doc/library/exceptions.rst:268
msgid ""
"The constructor often actually returns a subclass of :exc:`OSError`, as "
"described in `OS exceptions`_ below.  The particular subclass depends on "
"the final :attr:`.errno` value.  This behaviour only occurs when "
"constructing :exc:`OSError` directly or via an alias, and is not "
"inherited when subclassing."
msgstr ""
"아래의 `OS 예외 <OS exceptions_>`_ 에서 설명하는 것처럼, 생성자는 종종 :exc:`OSError` 의 서브 "
"클래스를 돌려줍니다. 구체적인 서브 클래스는 최종 :attr:`.errno` 값에 따라 다릅니다. 이 동작은 "
":exc:`OSError` 를 직접 혹은 별칭을 통해 생성할 때만 일어나고, 서브 클래싱할 때는 상속되지 않습니다."

#: ../Doc/library/exceptions.rst:276
msgid "A numeric error code from the C variable :c:data:`errno`."
msgstr "C 변수 :c:data:`errno` 로부터 온 숫자 에러 코드."

#: ../Doc/library/exceptions.rst:280
msgid ""
"Under Windows, this gives you the native Windows error code.  The "
":attr:`.errno` attribute is then an approximate translation, in POSIX "
"terms, of that native error code."
msgstr ""
"윈도우에서, 네이티브 윈도우 에러 코드를 제공합니다. :attr:`.errno` 어트리뷰트는 이 네이티브 에러 코드를 POSIX "
"코드로 대략 변환한 것입니다."

#: ../Doc/library/exceptions.rst:284
msgid ""
"Under Windows, if the *winerror* constructor argument is an integer, the "
":attr:`.errno` attribute is determined from the Windows error code, and "
"the *errno* argument is ignored.  On other platforms, the *winerror* "
"argument is ignored, and the :attr:`winerror` attribute does not exist."
msgstr ""
"윈도우에서, *winerror* 생성자 인자가 정수인 경우, :attr:`.errno` 어트리뷰트는 윈도우 에러 코드에서 결정되며 "
"*errno* 인자는 무시됩니다. 다른 플랫폼에서는 *winerror* 인자가 무시되고 :attr:`winerror` 어트리뷰트가 "
"없습니다."

#: ../Doc/library/exceptions.rst:292
msgid ""
"The corresponding error message, as provided by the operating system.  It"
" is formatted by the C functions :c:func:`perror` under POSIX, and "
":c:func:`FormatMessage` under Windows."
msgstr ""
"운영 체제에서 제공하는 해당 에러 메시지. POSIX에서는 C 함수 :c:func:`perror` 로, 윈도우에서는 "
":c:func:`FormatMessage` 로 포맷합니다."

#: ../Doc/library/exceptions.rst:300
msgid ""
"For exceptions that involve a file system path (such as :func:`open` or "
":func:`os.unlink`), :attr:`filename` is the file name passed to the "
"function. For functions that involve two file system paths (such as "
":func:`os.rename`), :attr:`filename2` corresponds to the second file name"
" passed to the function."
msgstr ""
"(:func:`open` 또는 :func:`os.unlink` 와 같은) 파일 시스템 경로와 관련된 예외의 경우, "
":attr:`filename` 은 함수에 전달 된 파일 이름입니다. (:func:`os.rename`\\처럼) 두 개의 파일 시스템"
" 경로를 수반하는 함수의 경우, :attr:`filename2` 는 두 번째 파일 이름에 해당합니다."

#: ../Doc/library/exceptions.rst:307
msgid ""
":exc:`EnvironmentError`, :exc:`IOError`, :exc:`WindowsError`, "
":exc:`socket.error`, :exc:`select.error` and :exc:`mmap.error` have been "
"merged into :exc:`OSError`, and the constructor may return a subclass."
msgstr ""
":exc:`EnvironmentError`, :exc:`IOError`, :exc:`WindowsError`, "
":exc:`socket.error`, :exc:`select.error`, :exc:`mmap.error` 가 "
":exc:`OSError` 로 병합되었고, 생성자는 서브 클래스를 반환할 수 있습니다."

#: ../Doc/library/exceptions.rst:313
msgid ""
"The :attr:`filename` attribute is now the original file name passed to "
"the function, instead of the name encoded to or decoded from the "
"filesystem encoding.  Also, the *filename2* constructor argument and "
"attribute was added."
msgstr ""
":attr:`filename` 속성은 이제 파일 시스템 인코딩으로 인코딩되거나 디코딩된 이름 대신 함수에 전달 된 원래 파일 "
"이름입니다. 또한 *filename2* 생성자 인자 및 어트리뷰트가 추가되었습니다."

#: ../Doc/library/exceptions.rst:322
msgid ""
"Raised when the result of an arithmetic operation is too large to be "
"represented.  This cannot occur for integers (which would rather raise "
":exc:`MemoryError` than give up).  However, for historical reasons, "
"OverflowError is sometimes raised for integers that are outside a "
"required range.   Because of the lack of standardization of floating "
"point exception handling in C, most floating point operations are not "
"checked."
msgstr ""
"산술 연산의 결과가 너무 커서 표현할 수 없을 때 발생합니다. 정수에서는 발생하지 않습니다 (포기하기보다는 "
":exc:`MemoryError` 를 일으키게 될 겁니다). 그러나, 역사적인 이유로, 때로 OverflowError는 요구되는 "
"범위를 벗어난 정수의 경우도 발생합니다. C에서 부동 소수점 예외 처리의 표준화가 부족하므로, 대부분의 부동 소수점 연산은 검사되지"
" 않습니다."

#: ../Doc/library/exceptions.rst:332
msgid ""
"This exception is derived from :exc:`RuntimeError`.  It is raised when "
"the interpreter detects that the maximum recursion depth (see "
":func:`sys.getrecursionlimit`) is exceeded."
msgstr ""
"이 예외는 :exc:`RuntimeError` 에서 파생됩니다. 인터프리터가 최대 재귀 "
"깊이(:func:`sys.getrecursionlimit` 참조)가 초과하였음을 감지할 때 발생합니다."

#: ../Doc/library/exceptions.rst:336
msgid "Previously, a plain :exc:`RuntimeError` was raised."
msgstr "이전에는 평범한 :exc:`RuntimeError` 가 발생했습니다."

#: ../Doc/library/exceptions.rst:342
msgid ""
"This exception is raised when a weak reference proxy, created by the "
":func:`weakref.proxy` function, is used to access an attribute of the "
"referent after it has been garbage collected. For more information on "
"weak references, see the :mod:`weakref` module."
msgstr ""
"이 예외는 :func:`weakref.proxy` 함수가 만든 약한 참조 프락시가 이미 가비지 수집된 참조 대상의 어트리뷰트를 "
"액세스하는 데 사용될 때 발생합니다. 약한 참조에 대한 더 자세한 정보는 :mod:`weakref` 모듈을 보십시오."

#: ../Doc/library/exceptions.rst:350
msgid ""
"Raised when an error is detected that doesn't fall in any of the other "
"categories.  The associated value is a string indicating what precisely "
"went wrong."
msgstr "다른 범주에 속하지 않는 에러가 감지될 때 발생합니다. 연관된 값은 정확히 무엇이 잘못되었는지를 나타내는 문자열입니다."

#: ../Doc/library/exceptions.rst:357
msgid ""
"Raised by built-in function :func:`next` and an :term:`iterator`\\'s "
":meth:`~iterator.__next__` method to signal that there are no further "
"items produced by the iterator."
msgstr ""
"이터레이터에 의해 생성된 항목이 더 없다는 것을 알려주기 위해, 내장 함수 :func:`next`\\와 :term:`이터레이터 "
"<iterator>`\\의 :meth:`~iterator.__next__` 메서드가 일으킵니다."

#: ../Doc/library/exceptions.rst:361
msgid ""
"The exception object has a single attribute :attr:`value`, which is given"
" as an argument when constructing the exception, and defaults to "
":const:`None`."
msgstr ""
"예외 객체는 :attr:`value`\\라는 하나의 어트리뷰트를 가지고 있습니다. 이 어트리뷰트는 예외를 생성할 때 인자로 "
"주어지며, 기본값은 :const:`None` 입니다."

#: ../Doc/library/exceptions.rst:365
msgid ""
"When a :term:`generator` or :term:`coroutine` function returns, a new "
":exc:`StopIteration` instance is raised, and the value returned by the "
"function is used as the :attr:`value` parameter to the constructor of the"
" exception."
msgstr ""
":term:`제너레이터 <generator>` 나 :term:`코루틴 <coroutine>` 함수가 복귀할 때, 새 "
":exc:`StopIteration` 인스턴스를 발생시키고, 함수가 돌려주는 값을 예외 생성자의 :attr:`value` 매개변수로"
" 사용합니다."

#: ../Doc/library/exceptions.rst:370
msgid ""
"If a generator code directly or indirectly raises :exc:`StopIteration`, "
"it is converted into a :exc:`RuntimeError` (retaining the "
":exc:`StopIteration` as the new exception's cause)."
msgstr ""
"제너레이터 코드가 직간접적으로 :exc:`StopIteration` 를 일으키면, :exc:`RuntimeError` 로 변환됩니다"
" (:exc:`StopIteration` 은 새 예외의 원인(``__cause__``)으로 남겨둡니다)."

#: ../Doc/library/exceptions.rst:374
msgid ""
"Added ``value`` attribute and the ability for generator functions to use "
"it to return a value."
msgstr "``value`` 어트리뷰트와 제너레이터 함수가 이 값을 돌려주는 기능을 추가했습니다."

#: ../Doc/library/exceptions.rst:378
msgid ""
"Introduced the RuntimeError transformation via ``from __future__ import "
"generator_stop``, see :pep:`479`."
msgstr ""
"``from __future__ import generator_stop`` 를 통한 RuntimeError 변환을 도입했습니다. "
":pep:`479`\\를 참조하세요."

#: ../Doc/library/exceptions.rst:382
msgid ""
"Enable :pep:`479` for all code by default: a :exc:`StopIteration` error "
"raised in a generator is transformed into a :exc:`RuntimeError`."
msgstr ""
"기본적으로 모든 코드에서 :pep:`479`\\를 활성화합니다: 제너레이터에서 발생한 :exc:`StopIteration` 에러는 "
":exc:`RuntimeError` 로 변환됩니다."

#: ../Doc/library/exceptions.rst:388
msgid ""
"Must be raised by :meth:`__anext__` method of an :term:`asynchronous "
"iterator` object to stop the iteration."
msgstr ""
"반드시 :term:`비동기 이터레이터 <asynchronous iterator>` 객체의 :meth:`__anext__` 메서드가 "
"이터레이션을 멈추고자 할 때 발생시켜야 합니다."

#: ../Doc/library/exceptions.rst:395
msgid ""
"Raised when the parser encounters a syntax error.  This may occur in an "
":keyword:`import` statement, in a call to the built-in functions "
":func:`exec` or :func:`eval`, or when reading the initial script or "
"standard input (also interactively)."
msgstr ""
"파서가 문법 오류를 만날 때 발생합니다. :keyword:`import` 문에서, 내장 함수 :func:`exec` 나 "
":func:`eval` 호출에서, 초기 스크립트나 (대화형으로) 표준 입력을 읽을 때 발생할 수 있습니다."

#: ../Doc/library/exceptions.rst:400
msgid ""
"Instances of this class have attributes :attr:`filename`, :attr:`lineno`,"
" :attr:`offset` and :attr:`text` for easier access to the details.  "
":func:`str` of the exception instance returns only the message."
msgstr ""
"세부 사항을 쉽게 확인할 수 있도록, 이 클래스의 인스턴스에는 :attr:`filename`, :attr:`lineno`, "
":attr:`offset` 및 :attr:`text` 어트리뷰트가 있습니다. 예외 인스턴스의 :func:`str`\\은 메시지만 "
"돌려줍니다."

#: ../Doc/library/exceptions.rst:407
msgid ""
"Base class for syntax errors related to incorrect indentation.  This is a"
" subclass of :exc:`SyntaxError`."
msgstr "잘못된 들여쓰기와 관련된 문법 오류의 베이스 클래스입니다. :exc:`SyntaxError` 의 서브 클래스입니다."

#: ../Doc/library/exceptions.rst:413
msgid ""
"Raised when indentation contains an inconsistent use of tabs and spaces. "
"This is a subclass of :exc:`IndentationError`."
msgstr ""
"들여쓰기가 일관성없는 탭과 스페이스 사용을 포함하는 경우 발생합니다. :exc:`IndentationError` 의 서브 "
"클래스입니다."

#: ../Doc/library/exceptions.rst:419
msgid ""
"Raised when the interpreter finds an internal error, but the situation "
"does not look so serious to cause it to abandon all hope. The associated "
"value is a string indicating what went wrong (in low-level terms)."
msgstr ""
"인터프리터가 내부 에러를 발견했지만, 모든 희망을 포기할 만큼 상황이 심각해 보이지는 않을 때 발생합니다. 연관된 값은 무엇이 "
"잘못되었는지 (저수준의 용어로) 나타내는 문자열입니다."

#: ../Doc/library/exceptions.rst:423
msgid ""
"You should report this to the author or maintainer of your Python "
"interpreter. Be sure to report the version of the Python interpreter "
"(``sys.version``; it is also printed at the start of an interactive "
"Python session), the exact error message (the exception's associated "
"value) and if possible the source of the program that triggered the "
"error."
msgstr ""
"이것을 파이썬 인터프리터의 저자 또는 관리자에게 알려야 합니다. 파이썬 인터프리터의 버전 (``sys.version``; 대화식 "
"파이썬 세션의 시작 부분에도 출력됩니다), 정확한 에러 메시지 (예외의 연관된 값) 그리고 가능하다면 에러를 일으킨 프로그램의 "
"소스를 제공해 주십시오."

#: ../Doc/library/exceptions.rst:432
msgid ""
"This exception is raised by the :func:`sys.exit` function.  It inherits "
"from :exc:`BaseException` instead of :exc:`Exception` so that it is not "
"accidentally caught by code that catches :exc:`Exception`.  This allows "
"the exception to properly propagate up and cause the interpreter to exit."
"  When it is not handled, the Python interpreter exits; no stack "
"traceback is printed.  The constructor accepts the same optional argument"
" passed to :func:`sys.exit`. If the value is an integer, it specifies the"
" system exit status (passed to C's :c:func:`exit` function); if it is "
"``None``, the exit status is zero; if it has another type (such as a "
"string), the object's value is printed and the exit status is one."
msgstr ""
"이 예외는 :func:`sys.exit` 함수가 일으킵니다. :exc:`Exception`\\을 잡는 코드에 의해 우연히 잡히지 "
"않도록, :exc:`Exception` 대신에 :exc:`BaseException` 을 상속합니다. 이렇게 하면 예외가 올바르게 "
"전파되어 인터프리터가 종료됩니다. 처리되지 않으면, 파이썬 인터프리터가 종료됩니다; 스택 트레이스백은 인쇄되지 않습니다. 생성자는 "
":func:`sys.exit` 에 전달된 것과 같은 선택적 인자를 받아들입니다. 값이 정수이면 시스템 종료 상태를 지정합니다 (C의"
" :c:func:`exit` 함수에 전달됩니다); ``None`` 이면 종료 상태는 0입니다; 다른 형(가령 문자열)이면 객체의 "
"값이 인쇄되고 종료 상태는 1입니다."

#: ../Doc/library/exceptions.rst:443
msgid ""
"A call to :func:`sys.exit` is translated into an exception so that clean-"
"up handlers (:keyword:`finally` clauses of :keyword:`try` statements) can"
" be executed, and so that a debugger can execute a script without running"
" the risk of losing control.  The :func:`os._exit` function can be used "
"if it is absolutely positively necessary to exit immediately (for "
"example, in the child process after a call to :func:`os.fork`)."
msgstr ""
":func:`sys.exit` 에 대한 호출은 예외로 변환되어 뒷정리 처리기 (:keyword:`try` 문의 "
":keyword:`finally` 절) 가 실행될 수 있도록 합니다. 그래서 디버거는 제어권을 잃을 위험 없이 스크립트를 실행할 수"
" 있습니다. 즉시 종료가 절대적으로 필요한 경우에는 :func:`os._exit` 함수를 사용할 수 있습니다 (예를 들어, "
":func:`os.fork` 호출 후의 자식 프로세스에서)."

#: ../Doc/library/exceptions.rst:452
msgid ""
"The exit status or error message that is passed to the constructor. "
"(Defaults to ``None``.)"
msgstr "생성자에 전달되는 종료 상태 또는 에러 메시지입니다. (기본값은 ``None`` 입니다.)"

#: ../Doc/library/exceptions.rst:458
msgid ""
"Raised when an operation or function is applied to an object of "
"inappropriate type.  The associated value is a string giving details "
"about the type mismatch."
msgstr "연산이나 함수가 부적절한 형의 객체에 적용될 때 발생합니다. 연관된 값은 형 불일치에 대한 세부 정보를 제공하는 문자열입니다."

#: ../Doc/library/exceptions.rst:461
msgid ""
"This exception may be raised by user code to indicate that an attempted "
"operation on an object is not supported, and is not meant to be. If an "
"object is meant to support a given operation but has not yet provided an "
"implementation, :exc:`NotImplementedError` is the proper exception to "
"raise."
msgstr ""
"이 예외는 객체에 시도된 연산이 지원되지 않으며 그럴 의도도 없음을 나타내기 위해 사용자 코드가 발생시킬 수 있습니다. 만약 객체가"
" 주어진 연산을 지원할 의사는 있지만, 아직 구현을 제공하지 않는 경우라면, :exc:`NotImplementedError` 를 "
"발생시키는 것이 적합합니다."

#: ../Doc/library/exceptions.rst:466
msgid ""
"Passing arguments of the wrong type (e.g. passing a :class:`list` when an"
" :class:`int` is expected) should result in a :exc:`TypeError`, but "
"passing arguments with the wrong value (e.g. a number outside expected "
"boundaries) should result in a :exc:`ValueError`."
msgstr ""
"잘못된 형의 인자를 전달하면 (가령 :class:`int` 를 기대하는데 :class:`list`\\를 전달하기), "
":exc:`TypeError` 를 일으켜야 합니다. 하지만 잘못된 값을 갖는 인자를 전달하면 (가령 범위를 넘어서는 숫자) "
":exc:`ValueError` 를 일으켜야 합니다."

#: ../Doc/library/exceptions.rst:473
msgid ""
"Raised when a reference is made to a local variable in a function or "
"method, but no value has been bound to that variable.  This is a subclass"
" of :exc:`NameError`."
msgstr ""
"함수 나 메서드에서 지역 변수를 참조하지만, 해당 변수에 값이 연결되지 않으면 발생합니다. 이것은 :exc:`NameError` 의"
" 서브 클래스입니다."

#: ../Doc/library/exceptions.rst:480
msgid ""
"Raised when a Unicode-related encoding or decoding error occurs.  It is a"
" subclass of :exc:`ValueError`."
msgstr "유니코드 관련 인코딩 또는 디코딩 에러가 일어날 때 발생합니다. :exc:`ValueError` 의 서브 클래스입니다."

#: ../Doc/library/exceptions.rst:483
msgid ""
":exc:`UnicodeError` has attributes that describe the encoding or decoding"
" error.  For example, ``err.object[err.start:err.end]`` gives the "
"particular invalid input that the codec failed on."
msgstr ""
":exc:`UnicodeError` 는 인코딩이나 디코딩 에러를 설명하는 어트리뷰트를 가지고 있습니다. 예를 들어, "
"``err.object[err.start:err.end]`` 는 코덱이 실패한 잘못된 입력을 제공합니다."

#: ../Doc/library/exceptions.rst:489
msgid "The name of the encoding that raised the error."
msgstr "에러를 발생시킨 인코딩의 이름입니다."

#: ../Doc/library/exceptions.rst:493
msgid "A string describing the specific codec error."
msgstr "구체적인 코덱 오류를 설명하는 문자열입니다."

#: ../Doc/library/exceptions.rst:497
msgid "The object the codec was attempting to encode or decode."
msgstr "코덱이 인코딩 또는 디코딩하려고 시도한 객체입니다."

#: ../Doc/library/exceptions.rst:501
msgid "The first index of invalid data in :attr:`object`."
msgstr ":attr:`object` 에 있는 잘못된 데이터의 최초 인덱스입니다."

#: ../Doc/library/exceptions.rst:505
msgid "The index after the last invalid data in :attr:`object`."
msgstr ":attr:`object` 에 있는 마지막으로 잘못된 데이터의 바로 다음 인덱스입니다."

#: ../Doc/library/exceptions.rst:510
msgid ""
"Raised when a Unicode-related error occurs during encoding.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr "인코딩 중에 유니코드 관련 에러가 일어나면 발생합니다. :exc:`UnicodeError` 의 서브 클래스입니다."

#: ../Doc/library/exceptions.rst:516
msgid ""
"Raised when a Unicode-related error occurs during decoding.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr "디코딩 중에 유니코드 관련 에러가 일어나면 발생합니다. :exc:`UnicodeError` 의 서브 클래스입니다."

#: ../Doc/library/exceptions.rst:522
msgid ""
"Raised when a Unicode-related error occurs during translating.  It is a "
"subclass of :exc:`UnicodeError`."
msgstr "번역 중에 유니코드 관련 에러가 일어나면 발생합니다. :exc:`UnicodeError` 의 서브 클래스입니다."

#: ../Doc/library/exceptions.rst:528
msgid ""
"Raised when an operation or function receives an argument that has the "
"right type but an inappropriate value, and the situation is not described"
" by a more precise exception such as :exc:`IndexError`."
msgstr ""
"연산이나 함수가 올바른 형이지만 부적절한 값을 가진 인자를 받았고, 상황이 :exc:`IndexError` 처럼 더 구체적인 예외로"
" 설명되지 않는 경우 발생합니다."

#: ../Doc/library/exceptions.rst:535
msgid ""
"Raised when the second argument of a division or modulo operation is "
"zero.  The associated value is a string indicating the type of the "
"operands and the operation."
msgstr "나누기 또는 모듈로 연산의 두 번째 인자가 0일 때 발생합니다. 연관된 값은 피연산자의 형과 연산을 나타내는 문자열입니다."

#: ../Doc/library/exceptions.rst:540
msgid ""
"The following exceptions are kept for compatibility with previous "
"versions; starting from Python 3.3, they are aliases of :exc:`OSError`."
msgstr "다음 예외는 이전 버전과의 호환성을 위해 유지됩니다; 파이썬 3.3부터는 :exc:`OSError` 의 별칭입니다."

#: ../Doc/library/exceptions.rst:549
msgid "Only available on Windows."
msgstr "윈도우에서만 사용할 수 있습니다."

#: ../Doc/library/exceptions.rst:553
msgid "OS exceptions"
msgstr "OS 예외"

#: ../Doc/library/exceptions.rst:555
msgid ""
"The following exceptions are subclasses of :exc:`OSError`, they get "
"raised depending on the system error code."
msgstr "다음의 예외는 :exc:`OSError` 의 서브 클래스이며, 시스템 에러 코드에 따라 발생합니다."

#: ../Doc/library/exceptions.rst:560
msgid ""
"Raised when an operation would block on an object (e.g. socket) set for "
"non-blocking operation. Corresponds to :c:data:`errno` ``EAGAIN``, "
"``EALREADY``, ``EWOULDBLOCK`` and ``EINPROGRESS``."
msgstr ""
"비 블록 동작으로 설정된 객체(가령 소켓)에 블록이 필요한 연산이 수행되면 발생합니다. :c:data:`errno` "
"``EAGAIN``, ``EALREADY``, ``EWOULDBLOCK``, ``EINPROGRESS`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:565
msgid ""
"In addition to those of :exc:`OSError`, :exc:`BlockingIOError` can have "
"one more attribute:"
msgstr ":exc:`OSError` 의 것 외에도, :exc:`BlockingIOError` 는 어트리뷰트를 하나 더 가질 수 있습니다:"

#: ../Doc/library/exceptions.rst:570
msgid ""
"An integer containing the number of characters written to the stream "
"before it blocked.  This attribute is available when using the buffered "
"I/O classes from the :mod:`io` module."
msgstr ""
"블록 되기 전에 스트림에 쓴 문자 수를 포함하는 정수. 이 어트리뷰트는 :mod:`io` 모듈에서 버퍼링 된 입출력 클래스를 사용할"
" 때 쓸 수 있습니다."

#: ../Doc/library/exceptions.rst:576
msgid ""
"Raised when an operation on a child process failed. Corresponds to "
":c:data:`errno` ``ECHILD``."
msgstr "자식 프로세스에 대한 작업이 실패할 때 발생합니다. :c:data:`errno` ``ECHILD`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:581
msgid "A base class for connection-related issues."
msgstr "연결 관련 문제에 대한 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:583
msgid ""
"Subclasses are :exc:`BrokenPipeError`, :exc:`ConnectionAbortedError`, "
":exc:`ConnectionRefusedError` and :exc:`ConnectionResetError`."
msgstr ""
"서브 클래스는 :exc:`BrokenPipeError`, :exc:`ConnectionAbortedError`, "
":exc:`ConnectionRefusedError` 및 :exc:`ConnectionResetError` 입니다."

#: ../Doc/library/exceptions.rst:588
msgid ""
"A subclass of :exc:`ConnectionError`, raised when trying to write on a "
"pipe while the other end has been closed, or trying to write on a socket "
"which has been shutdown for writing. Corresponds to :c:data:`errno` "
"``EPIPE`` and ``ESHUTDOWN``."
msgstr ""
":exc:`ConnectionError` 의 서브 클래스로서, 다른 쪽 끝이 닫힌 파이프에 쓰려고 하거나, 쓰기가 종료된 소켓에 "
"쓰려고 할 때 발생합니다. :c:data:`errno` ``EPIPE`` 와 ``ESHUTDOWN`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:595
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection attempt is"
" aborted by the peer. Corresponds to :c:data:`errno` ``ECONNABORTED``."
msgstr ""
":exc:`ConnectionError` 의 서브 클래스로서, 연결 시도가 상대방에 의해 중단(abort)될 때 발생합니다. "
":c:data:`errno` ``ECONNABORTED`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:601
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection attempt is"
" refused by the peer. Corresponds to :c:data:`errno` ``ECONNREFUSED``."
msgstr ""
":exc:`ConnectionError` 의 서브 클래스로서, 연결 시도가 상대방에 의해 거부(refuse)될 때 발생합니다. "
":c:data:`errno` ``ECONNREFUSED`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:607
msgid ""
"A subclass of :exc:`ConnectionError`, raised when a connection is reset "
"by the peer. Corresponds to :c:data:`errno` ``ECONNRESET``."
msgstr ""
":exc:`ConnectionError` 의 서브 클래스로서, 연결이 상대방에 의해 강제 종료(reset)될 때 발생합니다. "
":c:data:`errno` ``ECONNRESET`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:613
msgid ""
"Raised when trying to create a file or directory which already exists. "
"Corresponds to :c:data:`errno` ``EEXIST``."
msgstr "이미 존재하는 파일이나 디렉터리를 만들려고 할 때 발생합니다. :c:data:`errno` ``EEXIST`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:618
msgid ""
"Raised when a file or directory is requested but doesn't exist. "
"Corresponds to :c:data:`errno` ``ENOENT``."
msgstr "파일이나 디렉터리가 요청되었지만 존재하지 않을 때 발생합니다. :c:data:`errno` ``ENOENT`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:623
msgid ""
"Raised when a system call is interrupted by an incoming signal. "
"Corresponds to :c:data:`errno` :py:data:`~errno.EINTR`."
msgstr ""
"시스템 호출이 들어오는 시그널에 의해 중단될 때 발생합니다. :c:data:`errno` :py:data:`~errno.EINTR`"
" 에 해당합니다."

#: ../Doc/library/exceptions.rst:626
msgid ""
"Python now retries system calls when a syscall is interrupted by a "
"signal, except if the signal handler raises an exception (see :pep:`475` "
"for the rationale), instead of raising :exc:`InterruptedError`."
msgstr ""
"이제 파이썬은 시스템 호출이 시그널에 의해 중단될 때, 시그널 처리기가 예외를 일으키는 경우를 제외하고 (이유는 :pep:`475`"
" 를 참조하세요), :exc:`InterruptedError` 를 일으키는 대신 시스템 호출을 재시도합니다."

#: ../Doc/library/exceptions.rst:633
msgid ""
"Raised when a file operation (such as :func:`os.remove`) is requested on "
"a directory. Corresponds to :c:data:`errno` ``EISDIR``."
msgstr ""
"디렉터리에 파일 연산(가령 :func:`os.remove`)이 요청되었을 때 발생합니다. :c:data:`errno` "
"``EISDIR`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:639
msgid ""
"Raised when a directory operation (such as :func:`os.listdir`) is "
"requested on something which is not a directory. Corresponds to "
":c:data:`errno` ``ENOTDIR``."
msgstr ""
"디렉터리가 아닌 것에 디렉터리 연산(가령 :func:`os.listdir`)이 요청되었을 때 발생합니다. "
":c:data:`errno` ``ENOTDIR`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:645
msgid ""
"Raised when trying to run an operation without the adequate access rights"
" - for example filesystem permissions. Corresponds to :c:data:`errno` "
"``EACCES`` and ``EPERM``."
msgstr ""
"적절한 접근권 (가령 파일 시스템 권한) 없이 연산을 실행하려고 할 때 발생합니다. :c:data:`errno` ``EACCES``"
" 와 ``EPERM`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:651
msgid ""
"Raised when a given process doesn't exist. Corresponds to :c:data:`errno`"
" ``ESRCH``."
msgstr "주어진 프로세스가 존재하지 않을 때 발생합니다. :c:data:`errno` ``ESRCH`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:656
msgid ""
"Raised when a system function timed out at the system level. Corresponds "
"to :c:data:`errno` ``ETIMEDOUT``."
msgstr "시스템 함수가 시스템 수준에서 시간 초과 될 때 발생합니다. :c:data:`errno` ``ETIMEDOUT`` 에 해당합니다."

#: ../Doc/library/exceptions.rst:659
msgid "All the above :exc:`OSError` subclasses were added."
msgstr "위의 모든 :exc:`OSError` 서브 클래스가 추가되었습니다."

#: ../Doc/library/exceptions.rst:665
msgid ":pep:`3151` - Reworking the OS and IO exception hierarchy"
msgstr ":pep:`3151` - OS 및 IO 예외 계층 구조 재작업"

#: ../Doc/library/exceptions.rst:671
msgid "Warnings"
msgstr "경고"

#: ../Doc/library/exceptions.rst:673
msgid ""
"The following exceptions are used as warning categories; see the :ref"
":`warning-categories` documentation for more details."
msgstr "다음 예외는 경고 범주로 사용됩니다; 자세한 정보는 :ref:`warning-categories` 설명서를 보십시오."

#: ../Doc/library/exceptions.rst:678
msgid "Base class for warning categories."
msgstr "경고 범주의 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:683
msgid "Base class for warnings generated by user code."
msgstr "사용자 코드에 의해 만들어지는 경고의 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:688
msgid ""
"Base class for warnings about deprecated features when those warnings are"
" intended for other Python developers."
msgstr "폐지된 기능에 대한 경고의 베이스 클래스인데, 그 경고가 다른 파이썬 개발자를 대상으로 하는 경우입니다."

#: ../Doc/library/exceptions.rst:694
msgid ""
"Base class for warnings about features which are obsolete and expected to"
" be deprecated in the future, but are not deprecated at the moment."
msgstr "더는 사용되지 않고 장래에 폐지될 예정이지만, 지금 당장 폐지되지는 않은 기능에 관한 경고의 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:698
msgid ""
"This class is rarely used as emitting a warning about a possible upcoming"
" deprecation is unusual, and :exc:`DeprecationWarning` is preferred for "
"already active deprecations."
msgstr ""
"앞으로 있을 수도 있는 폐지에 관한 경고는 일반적이지 않기 때문에, 이 클래스는 거의 사용되지 않습니다. 이미 활성화된 폐지에는 "
":exc:`DeprecationWarning`\\을 선호합니다."

#: ../Doc/library/exceptions.rst:705
msgid "Base class for warnings about dubious syntax."
msgstr "모호한 문법에 대한 경고의 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:710
msgid "Base class for warnings about dubious runtime behavior."
msgstr "모호한 실행 시간 동작에 대한 경고의 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:715
msgid ""
"Base class for warnings about deprecated features when those warnings are"
" intended for end users of applications that are written in Python."
msgstr "폐지된 기능에 대한 경고의 베이스 클래스인데, 그 경고가 파이썬으로 작성된 응용 프로그램의 최종 사용자를 대상으로 하는 경우입니다."

#: ../Doc/library/exceptions.rst:721
msgid "Base class for warnings about probable mistakes in module imports."
msgstr "모듈 임포트에 있을 수 있는 실수에 대한 경고의 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:726
msgid "Base class for warnings related to Unicode."
msgstr "유니코드와 관련된 경고의 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:731
msgid "Base class for warnings related to :class:`bytes` and :class:`bytearray`."
msgstr ":class:`bytes` 및 :class:`bytearray` 와 관련된 경고의 베이스 클래스입니다."

#: ../Doc/library/exceptions.rst:736
msgid ""
"Base class for warnings related to resource usage. Ignored by the default"
" warning filters."
msgstr "자원 사용과 관련된 경고의 베이스 클래스입니다. 기본 경고 필터에 의해 무시됩니다."

#: ../Doc/library/exceptions.rst:744
msgid "Exception hierarchy"
msgstr "예외 계층 구조"

#: ../Doc/library/exceptions.rst:746
msgid "The class hierarchy for built-in exceptions is:"
msgstr "내장 예외의 클래스 계층 구조는 다음과 같습니다:"

