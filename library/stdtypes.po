# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-30 09:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "내장형"

#: ../Doc/library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into "
"the interpreter."
msgstr "다음 섹션에서는 인터프리터에 내장된 표준형에 관해 설명합니다."

#: ../Doc/library/stdtypes.rst:15
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions."
msgstr "기본 내장 유형은 숫자, 시퀀스, 매핑, 클래스, 인스턴스 및 예외입니다."

#: ../Doc/library/stdtypes.rst:18
msgid ""
"Some collection classes are mutable.  The methods that add, subtract, or "
"rearrange their members in place, and don't return a specific item, never"
" return the collection instance itself but ``None``."
msgstr ""
"일부 컬렉션 클래스는 가변입니다. 제자리에서 멤버를 추가, 삭제 또는 재배치하고 특정 항목을 반환하지 않는 메서드는 컬렉션 인스턴스"
" 자체를 반환하지 않고 ``None`` 을 반환합니다."

#: ../Doc/library/stdtypes.rst:22
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :func:`repr` function or the slightly "
"different :func:`str` function).  The latter function is implicitly used "
"when an object is written by the :func:`print` function."
msgstr ""
"일부 연산들은 여러 객체 형에서 지원됩니다; 특히 사실상 모든 객체를 비교하고, 논리값을 검사하고, (:func:`repr` 함수 "
"또는 약간 다른 :func:`str` 함수를 사용해서) 문자열로 변환할 수 있습니다. 두 번째 함수는 :func:`print` "
"함수로 객체를 쓸 때 묵시적으로 사용됩니다."

#: ../Doc/library/stdtypes.rst:32
msgid "Truth Value Testing"
msgstr "논리값 검사"

#: ../Doc/library/stdtypes.rst:41
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or "
":keyword:`while` condition or as operand of the Boolean operations below."
msgstr ""
"모든 객체는 논리값을 검사할 수 있는데, :keyword:`if` 또는 :keyword:`while` 조건 또는 다음에 나오는 논리"
" 연산의 피연산자로 사용될 수 있도록 합니다."

#: ../Doc/library/stdtypes.rst:46
msgid ""
"By default, an object is considered true unless its class defines either "
"a :meth:`__bool__` method that returns ``False`` or a :meth:`__len__` "
"method that returns zero, when called with the object. [1]_  Here are "
"most of the built-in objects considered false:"
msgstr ""
"기본적으로 객체는 클래스가 그 객체에 대해 호출될 때 ``False`` 를 돌려주는 :meth:`__bool__` 메서드나 0을 "
"돌려주는 :meth:`__len__` 메서드를 정의하지 않는 한 참으로 간주합니다. [1]_ 여기에 거짓으로 간주하는 대부분의 내장"
" 객체들이 있습니다:"

#: ../Doc/library/stdtypes.rst:55
msgid "constants defined to be false: ``None`` and ``False``."
msgstr "거짓으로 정의된 상수: ``None`` 과 ``False``."

#: ../Doc/library/stdtypes.rst:57
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr "모든 숫자 형들의 영: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, ``Fraction(0, 1)``"

#: ../Doc/library/stdtypes.rst:60
msgid ""
"empty sequences and collections: ``''``, ``()``, ``[]``, ``{}``, "
"``set()``, ``range(0)``"
msgstr "빈 시퀀스와 컬렉션: ``''``, ``()``, ``[]``, ``{}``, ``set()``, ``range(0)``"

#: ../Doc/library/stdtypes.rst:69
msgid ""
"Operations and built-in functions that have a Boolean result always "
"return ``0`` or ``False`` for false and ``1`` or ``True`` for true, "
"unless otherwise stated. (Important exception: the Boolean operations "
"``or`` and ``and`` always return one of their operands.)"
msgstr ""
"논리값을 돌려주는 연산과 내장 함수는 달리 명시하지 않는 한 항상 거짓의 경우 ``0`` 이나 ``False`` 를, 참이면 "
"``1`` 이나 ``True`` 를 돌려줍니다. (중요한 예외: 논리 연산 ``or`` 와 ``and`` 는 항상 피연산자 중 "
"하나를 돌려줍니다.)"

#: ../Doc/library/stdtypes.rst:78
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr "논리 연산 --- :keyword:`and`, :keyword:`or`, :keyword:`not`"

#: ../Doc/library/stdtypes.rst:82
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr "이것들은 우선순위에 따라 오름차순으로 정렬된 논리 연산들입니다:"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:143
#: ../Doc/library/stdtypes.rst:271 ../Doc/library/stdtypes.rst:360
#: ../Doc/library/stdtypes.rst:410 ../Doc/library/stdtypes.rst:846
#: ../Doc/library/stdtypes.rst:1041
msgid "Operation"
msgstr "연산"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:271
#: ../Doc/library/stdtypes.rst:360 ../Doc/library/stdtypes.rst:410
#: ../Doc/library/stdtypes.rst:846 ../Doc/library/stdtypes.rst:1041
msgid "Result"
msgstr "결과"

#: ../Doc/library/stdtypes.rst:85 ../Doc/library/stdtypes.rst:271
#: ../Doc/library/stdtypes.rst:410 ../Doc/library/stdtypes.rst:846
#: ../Doc/library/stdtypes.rst:1041 ../Doc/library/stdtypes.rst:2178
#: ../Doc/library/stdtypes.rst:3300
msgid "Notes"
msgstr "노트"

#: ../Doc/library/stdtypes.rst:87
msgid "``x or y``"
msgstr "``x or y``"

#: ../Doc/library/stdtypes.rst:87
msgid "if *x* is false, then *y*, else *x*"
msgstr "*x* 가 거짓이면 *y*, 그렇지 않으면 *x*"

#: ../Doc/library/stdtypes.rst:87 ../Doc/library/stdtypes.rst:281
#: ../Doc/library/stdtypes.rst:848 ../Doc/library/stdtypes.rst:851
#: ../Doc/library/stdtypes.rst:1052 ../Doc/library/stdtypes.rst:2184
#: ../Doc/library/stdtypes.rst:3306
msgid "\\(1)"
msgstr "\\(1)"

#: ../Doc/library/stdtypes.rst:90
msgid "``x and y``"
msgstr "``x and y``"

#: ../Doc/library/stdtypes.rst:90
msgid "if *x* is false, then *x*, else *y*"
msgstr "*x*가 거짓이면 *x*, 그렇지 않으면 *y*"

#: ../Doc/library/stdtypes.rst:90 ../Doc/library/stdtypes.rst:284
#: ../Doc/library/stdtypes.rst:304 ../Doc/library/stdtypes.rst:1080
#: ../Doc/library/stdtypes.rst:2188 ../Doc/library/stdtypes.rst:2190
#: ../Doc/library/stdtypes.rst:3310 ../Doc/library/stdtypes.rst:3312
msgid "\\(2)"
msgstr "\\(2)"

#: ../Doc/library/stdtypes.rst:93
msgid "``not x``"
msgstr "``not x``"

#: ../Doc/library/stdtypes.rst:93
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "*x* 가 거짓이면 ``True``, 그렇지 않으면 ``False``"

#: ../Doc/library/stdtypes.rst:93 ../Doc/library/stdtypes.rst:860
#: ../Doc/library/stdtypes.rst:1083 ../Doc/library/stdtypes.rst:2192
#: ../Doc/library/stdtypes.rst:2194 ../Doc/library/stdtypes.rst:2196
#: ../Doc/library/stdtypes.rst:2198 ../Doc/library/stdtypes.rst:3314
#: ../Doc/library/stdtypes.rst:3316 ../Doc/library/stdtypes.rst:3318
#: ../Doc/library/stdtypes.rst:3320
msgid "\\(3)"
msgstr "\\(3)"

#: ../Doc/library/stdtypes.rst:102 ../Doc/library/stdtypes.rst:315
#: ../Doc/library/stdtypes.rst:428 ../Doc/library/stdtypes.rst:887
#: ../Doc/library/stdtypes.rst:1091 ../Doc/library/stdtypes.rst:2224
#: ../Doc/library/stdtypes.rst:3350
msgid "Notes:"
msgstr "노트:"

#: ../Doc/library/stdtypes.rst:105
msgid ""
"This is a short-circuit operator, so it only evaluates the second "
"argument if the first one is false."
msgstr "이것은 단락-회로 연산자이므로 첫 번째 인자가 거짓일 때만 두 번째의 값을 구합니다."

#: ../Doc/library/stdtypes.rst:109
msgid ""
"This is a short-circuit operator, so it only evaluates the second "
"argument if the first one is true."
msgstr "이것은 단락-회로 연산자이므로 첫 번째 인자가 참일 때만 두 번째의 값을 구합니다."

#: ../Doc/library/stdtypes.rst:113
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == "
"b`` is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax "
"error."
msgstr ""
"``not`` 은 비논리 연산자들보다 낮은 우선순위를 갖습니다. 그래서, ``not a == b`` 는 ``not (a == "
"b)`` 로 해석되고, ``a == not b`` 는 문법 오류입니다."

#: ../Doc/library/stdtypes.rst:120
msgid "Comparisons"
msgstr "비교"

#: ../Doc/library/stdtypes.rst:134
msgid ""
"There are eight comparison operations in Python.  They all have the same "
"priority (which is higher than that of the Boolean operations).  "
"Comparisons can be chained arbitrarily; for example, ``x < y <= z`` is "
"equivalent to ``x < y and y <= z``, except that *y* is evaluated only "
"once (but in both cases *z* is not evaluated at all when ``x < y`` is "
"found to be false)."
msgstr ""
"파이썬에는 8가지 비교 연산이 있습니다. 이들 모두는 같은 우선순위를 가집니다 (논리 연산보다는 높습니다). 비교는 임의로 연결될 "
"수 있습니다; 예를 들어 ``x < y <= z`` 는 *y* 의 값을 한 번만 구한다는 점을 제외하고는 ``x < y and y "
"<= z`` 와 동등합니다 (하지만 두 경우 모두 ``x < y`` 가 거짓으로 밝혀지면 *z* 의 값을 구하지 않습니다)."

#: ../Doc/library/stdtypes.rst:140
msgid "This table summarizes the comparison operations:"
msgstr "이 표는 비교 연산을 요약합니다:"

#: ../Doc/library/stdtypes.rst:143 ../Doc/library/stdtypes.rst:2155
#: ../Doc/library/stdtypes.rst:2178 ../Doc/library/stdtypes.rst:3277
#: ../Doc/library/stdtypes.rst:3300
msgid "Meaning"
msgstr "뜻"

#: ../Doc/library/stdtypes.rst:145
msgid "``<``"
msgstr "``<``"

#: ../Doc/library/stdtypes.rst:145
msgid "strictly less than"
msgstr "엄격히 작다"

#: ../Doc/library/stdtypes.rst:147
msgid "``<=``"
msgstr "``<=``"

#: ../Doc/library/stdtypes.rst:147
msgid "less than or equal"
msgstr "작거나 같다"

#: ../Doc/library/stdtypes.rst:149
msgid "``>``"
msgstr "``>``"

#: ../Doc/library/stdtypes.rst:149
msgid "strictly greater than"
msgstr "엄격히 크다"

#: ../Doc/library/stdtypes.rst:151
msgid "``>=``"
msgstr "``>=``"

#: ../Doc/library/stdtypes.rst:151
msgid "greater than or equal"
msgstr "크거나 같다"

#: ../Doc/library/stdtypes.rst:153
msgid "``==``"
msgstr "``==``"

#: ../Doc/library/stdtypes.rst:153
msgid "equal"
msgstr "같다"

#: ../Doc/library/stdtypes.rst:155
msgid "``!=``"
msgstr "``!=``"

#: ../Doc/library/stdtypes.rst:155
msgid "not equal"
msgstr "같지 않다"

#: ../Doc/library/stdtypes.rst:157
msgid "``is``"
msgstr "``is``"

#: ../Doc/library/stdtypes.rst:157
msgid "object identity"
msgstr "객체 아이덴티티"

#: ../Doc/library/stdtypes.rst:159
msgid "``is not``"
msgstr "``is not``"

#: ../Doc/library/stdtypes.rst:159
msgid "negated object identity"
msgstr "부정된 객체 아이덴티티"

#: ../Doc/library/stdtypes.rst:166
msgid ""
"Objects of different types, except different numeric types, never compare"
" equal. Furthermore, some types (for example, function objects) support "
"only a degenerate notion of comparison where any two objects of that type"
" are unequal.  The ``<``, ``<=``, ``>`` and ``>=`` operators will raise a"
" :exc:`TypeError` exception when comparing a complex number with another "
"built-in numeric type, when the objects are of different types that "
"cannot be compared, or in other cases where there is no defined ordering."
msgstr ""
"서로 다른 숫자 형을 제외하고는 서로 다른 형의 객체들은 같다고 비교되지 않습니다. 더 나아가, 어떤 형들은 (예를 들어, 함수 "
"객체) 그 형의 모든 두 객체가 다르다고 비교되는 비교의 축약적인 개념만을 지원합니다. ``<``, ``<=``, ``>``, "
"``>=`` 연산자들은 복소수를 다른 내장 숫자 형과 비교할 때, 객체들이 비교될 수 없는 다른 형일 때, 정의된 순서가 없을 때 "
":exc:`TypeError` 예외를 일으킵니다."

#: ../Doc/library/stdtypes.rst:182
msgid ""
"Non-identical instances of a class normally compare as non-equal unless "
"the class defines the :meth:`__eq__` method."
msgstr "클래스의 같지 않은 인스턴스들은 그 클래스가 :meth:`__eq__` 메서드를 정의하지 않는 이상 보통 같지 않다고 비교됩니다."

#: ../Doc/library/stdtypes.rst:185
msgid ""
"Instances of a class cannot be ordered with respect to other instances of"
" the same class, or other types of object, unless the class defines "
"enough of the methods :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, and"
" :meth:`__ge__` (in general, :meth:`__lt__` and :meth:`__eq__` are "
"sufficient, if you want the conventional meanings of the comparison "
"operators)."
msgstr ""
"클래스가 :meth:`__lt__`, :meth:`__le__`, :meth:`__gt__`, :meth:`__ge__` 메서드들을"
" 충분히 정의하지 않는 이상, 클래스의 인스턴스들은 같은 클래스의 다른 인스턴스나 다른 형의 객체와의 순서가 정해지지 않습니다 "
"(일반적으로, 여러분이 비교 연산자의 관습적인 의미를 원한다면 :meth:`__lt__` 와 :meth:`__eq__` 만으로 "
"충분합니다)."

#: ../Doc/library/stdtypes.rst:191
msgid ""
"The behavior of the :keyword:`is` and :keyword:`is not` operators cannot "
"be customized; also they can be applied to any two objects and never "
"raise an exception."
msgstr ""
":keyword:`is` 와 :keyword:`is not` 연산자의 동작은 사용자 정의할 수 없습니다; 또한 임의의 두 객체에 "
"적용할 수 있으며 예외를 발생시키지 않습니다."

#: ../Doc/library/stdtypes.rst:199
msgid ""
"Two more operations with the same syntactic priority, :keyword:`in` and "
":keyword:`not in`, are supported only by sequence types (below)."
msgstr ""
"같은 문법적 우선순위를 갖는 두 개의 연산, :keyword:`in` 과 :keyword:`not in`, 은 (아래에 나오는) "
"시퀀스 형에서만 지원됩니다."

#: ../Doc/library/stdtypes.rst:206
msgid "Numeric Types --- :class:`int`, :class:`float`, :class:`complex`"
msgstr "숫자 형 --- :class:`int`, :class:`float`, :class:`complex`"

#: ../Doc/library/stdtypes.rst:216
msgid ""
"There are three distinct numeric types: :dfn:`integers`, :dfn:`floating "
"point numbers`, and :dfn:`complex numbers`.  In addition, Booleans are a "
"subtype of integers.  Integers have unlimited precision.  Floating point "
"numbers are usually implemented using :c:type:`double` in C; information "
"about the precision and internal representation of floating point numbers"
" for the machine on which your program is running is available in "
":data:`sys.float_info`.  Complex numbers have a real and imaginary part, "
"which are each a floating point number.  To extract these parts from a "
"complex number *z*, use ``z.real`` and ``z.imag``. (The standard library "
"includes additional numeric types, :mod:`fractions` that hold rationals, "
"and :mod:`decimal` that hold floating-point numbers with user-definable "
"precision.)"
msgstr ""
"세 가지 다른 숫자 형이 있습니다: :dfn:`정수 (integers)`, :dfn:`실수 (floating point "
"numbers)`, :dfn:`복소수 (complex numbers)`. 또한 논리형은 정수의 하위 유형입니다. 정수는 무제한의 "
"정밀도를 갖습니다. 실수는 보통 C의 :c:type:`double`\\을 사용해서 구현됩니다; 프로그램이 실행되고 있는 기계의 부동"
" 소수점 숫자의 정밀도와 내부 표현에 관한 정보는 :data:`sys.float_info`\\에서 얻을 수 있습니다. 복소수는 각각"
" 실수로 표현되는 실수부와 허수부를 가집니다. 복소수 *z* 에서 이들 부분을 추출하려면 ``z.real`` 과 ``z.imag``"
" 를 사용하십시오. (표준 라이브러리는 추가적인 숫자 형들을 포함하는데, :mod:`fractions`\\는 유리수를, "
":mod:`decimal` 은 사용자가 정의할 수 있는 정밀도로 부동 소수점 숫자를 다룹니다.)"

#: ../Doc/library/stdtypes.rst:238
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including hex, "
"octal and binary numbers) yield integers.  Numeric literals containing a "
"decimal point or an exponent sign yield floating point numbers.  "
"Appending ``'j'`` or ``'J'`` to a numeric literal yields an imaginary "
"number (a complex number with a zero real part) which you can add to an "
"integer or float to get a complex number with real and imaginary parts."
msgstr ""
"숫자는 숫자 리터럴 또는 내장 함수와 연산자의 결과로 만들어집니다. 꾸밈없는 정수 리터럴(16진수, 8진수, 2진수 포함)은 정수를"
" 만듭니다. 소수점 또는 지수 기호가 포함된 숫자 리터럴은 실수를 만듭니다. 숫자 리터럴에 ``'j'`` 나 ``'J'`` 를 "
"덧붙이면 허수 (실수부가 0인 복소수) 가 만들어지는데, 정수나 실수에 더해서 실수부와 허수부가 있는 복소수를 만들 수 있습니다."

#: ../Doc/library/stdtypes.rst:259
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator"
" has operands of different numeric types, the operand with the "
"\"narrower\" type is widened to that of the other, where integer is "
"narrower than floating point, which is narrower than complex.  "
"Comparisons between numbers of mixed type use the same rule. [2]_ The "
"constructors :func:`int`, :func:`float`, and :func:`complex` can be used "
"to produce numbers of a specific type."
msgstr ""
"파이썬은 혼합 산술을 완벽하게 지원합니다: 이항 산술 연산자가 다른 숫자 형의 피연산자를 가질 때, \"더 좁은\" 형의 피연산자는"
" 다른 피연산자의 형으로 넓혀집니다. 정수는 실수보다 좁고, 실수는 복소수보다 좁습니다. 혼합형 숫자 사이의 비교는 같은 규칙을 "
"사용합니다. [2]_ 생성자 :func:`int`, :func:`float`, :func:`complex`\\를 특정 형의 숫자를 "
"만드는데 사용할 수 있습니다."

#: ../Doc/library/stdtypes.rst:266
msgid ""
"All numeric types (except complex) support the following operations, "
"sorted by ascending priority (all numeric operations have a higher "
"priority than comparison operations):"
msgstr ""
"(복소수를 제외한) 모든 숫자 형은 다음과 같은 연산들을 지원하는데, 우선순위에 따라 오름차순 정렬되어 있습니다 (모든 숫자 연산은"
" 비교 연산보다 높은 우선순위를 갖습니다):"

#: ../Doc/library/stdtypes.rst:271
msgid "Full documentation"
msgstr "전체 문서"

#: ../Doc/library/stdtypes.rst:273
msgid "``x + y``"
msgstr "``x + y``"

#: ../Doc/library/stdtypes.rst:273
msgid "sum of *x* and *y*"
msgstr "*x* 와 *y* 의 합"

#: ../Doc/library/stdtypes.rst:275
msgid "``x - y``"
msgstr "``x - y``"

#: ../Doc/library/stdtypes.rst:275
msgid "difference of *x* and *y*"
msgstr "*x* 와 *y* 의 차"

#: ../Doc/library/stdtypes.rst:277
msgid "``x * y``"
msgstr "``x * y``"

#: ../Doc/library/stdtypes.rst:277
msgid "product of *x* and *y*"
msgstr "*x* 와 *y* 의 곱"

#: ../Doc/library/stdtypes.rst:279
msgid "``x / y``"
msgstr "``x / y``"

#: ../Doc/library/stdtypes.rst:279
msgid "quotient of *x* and *y*"
msgstr "*x* 와 *y* 의 몫"

#: ../Doc/library/stdtypes.rst:281
msgid "``x // y``"
msgstr "``x // y``"

#: ../Doc/library/stdtypes.rst:281
msgid "floored quotient of *x* and *y*"
msgstr "*x* 와 *y* 의 정수로 내림한 몫"

#: ../Doc/library/stdtypes.rst:284
msgid "``x % y``"
msgstr "``x % y``"

#: ../Doc/library/stdtypes.rst:284
msgid "remainder of ``x / y``"
msgstr "``x / y`` 의 나머지"

#: ../Doc/library/stdtypes.rst:286
msgid "``-x``"
msgstr "``-x``"

#: ../Doc/library/stdtypes.rst:286
msgid "*x* negated"
msgstr "음의 *x*"

#: ../Doc/library/stdtypes.rst:288
msgid "``+x``"
msgstr "``+x``"

#: ../Doc/library/stdtypes.rst:288
msgid "*x* unchanged"
msgstr "*x* 그대로"

#: ../Doc/library/stdtypes.rst:290
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../Doc/library/stdtypes.rst:290
msgid "absolute value or magnitude of *x*"
msgstr "*x* 의 절댓값 또는 크기"

#: ../Doc/library/stdtypes.rst:290
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../Doc/library/stdtypes.rst:293
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../Doc/library/stdtypes.rst:293
msgid "*x* converted to integer"
msgstr "정수로 변환된 *x*"

#: ../Doc/library/stdtypes.rst:293
msgid "\\(3)\\(6)"
msgstr "\\(3)\\(6)"

#: ../Doc/library/stdtypes.rst:293
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../Doc/library/stdtypes.rst:295
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../Doc/library/stdtypes.rst:295
msgid "*x* converted to floating point"
msgstr "실수로 변환된 *x*"

#: ../Doc/library/stdtypes.rst:295
msgid "\\(4)\\(6)"
msgstr "\\(4)\\(6)"

#: ../Doc/library/stdtypes.rst:295
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../Doc/library/stdtypes.rst:297
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../Doc/library/stdtypes.rst:297
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults "
"to zero."
msgstr "실수부 *re* 와 허수부 *im* 으로 구성된 복소수. *im* 의 기본값은 0입니다."

#: ../Doc/library/stdtypes.rst:297 ../Doc/library/stdtypes.rst:1073
#: ../Doc/library/stdtypes.rst:2186 ../Doc/library/stdtypes.rst:3337
msgid "\\(6)"
msgstr "\\(6)"

#: ../Doc/library/stdtypes.rst:297
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../Doc/library/stdtypes.rst:301
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../Doc/library/stdtypes.rst:301
msgid "conjugate of the complex number *c*"
msgstr "복소수 *c* 의 켤레"

#: ../Doc/library/stdtypes.rst:304
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../Doc/library/stdtypes.rst:304
msgid "the pair ``(x // y, x % y)``"
msgstr "쌍 ``(x // y, x % y)``"

#: ../Doc/library/stdtypes.rst:304
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../Doc/library/stdtypes.rst:306
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../Doc/library/stdtypes.rst:306 ../Doc/library/stdtypes.rst:308
msgid "*x* to the power *y*"
msgstr "*x* 의 *y* 거듭제곱"

#: ../Doc/library/stdtypes.rst:306 ../Doc/library/stdtypes.rst:308
#: ../Doc/library/stdtypes.rst:1062 ../Doc/library/stdtypes.rst:1065
#: ../Doc/library/stdtypes.rst:2211 ../Doc/library/stdtypes.rst:2214
#: ../Doc/library/stdtypes.rst:2217 ../Doc/library/stdtypes.rst:3333
#: ../Doc/library/stdtypes.rst:3340
msgid "\\(5)"
msgstr "\\(5)"

#: ../Doc/library/stdtypes.rst:306
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../Doc/library/stdtypes.rst:308
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../Doc/library/stdtypes.rst:318
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int.  The result is "
"always rounded towards minus infinity: ``1//2`` is ``0``, ``(-1)//2`` is "
"``-1``, ``1//(-2)`` is ``-1``, and ``(-1)//(-2)`` is ``0``."
msgstr ""
"정수 나눗셈이라고 도합니다. 결괏값의 형이 꼭 int 일 필요는 없지만, 결괏값은 항상 정수입니다. 결과는 항상 음의 무한대를 향해"
" 내림 됩니다: ``1//2`` 는 ``0``, ``(-1)//2`` 는 ``-1``, ``1//(-2)`` 는 ``-1``, "
"``(-1)//(-2)`` 는 ``0`` 입니다."

#: ../Doc/library/stdtypes.rst:324
msgid ""
"Not for complex numbers.  Instead convert to floats using :func:`abs` if "
"appropriate."
msgstr "복소수에는 사용할 수 없습니다. 적절한 경우 :func:`abs`\\를 사용하여 실수로 변환하십시오."

#: ../Doc/library/stdtypes.rst:336
msgid ""
"Conversion from floating point to integer may round or truncate as in C; "
"see functions :func:`math.floor` and :func:`math.ceil` for well-defined "
"conversions."
msgstr ""
"실수에서 정수로의 변환은 C에서처럼 반올림이나 자름이 발생할 수 있습니다; 잘 정의된 변환을 위해서는 "
":func:`math.floor` 와 :func:`math.ceil` 함수를 보십시오."

#: ../Doc/library/stdtypes.rst:341
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional "
"prefix \"+\" or \"-\" for Not a Number (NaN) and positive or negative "
"infinity."
msgstr ""
"float는 또한 숫자가 아님(NaN)과 양 또는 음의 무한대를 나타내는 문자열 \"nan\"과 접두사 \"+\" 나 \"-\" 가"
" 선택적으로 붙을 수 있는 \"inf\"를 받아들입니다."

#: ../Doc/library/stdtypes.rst:345
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for"
" programming languages."
msgstr ""
"파이썬은 프로그래밍 언어들에서 흔히 그렇듯이, 있는 것처럼 ``pow(0, 0)`` 와 ``0 ** 0`` 이 ``1`` 이 되도록"
" 정의합니다."

#: ../Doc/library/stdtypes.rst:349
msgid ""
"The numeric literals accepted include the digits ``0`` to ``9`` or any "
"Unicode equivalent (code points with the ``Nd`` property)."
msgstr ""
"받아들여지는 숫자 리터럴은 ``0`` 에서 ``9`` 까지 또는 모든 동등한 유니코드들을 (``Nd`` 속성을 가진 코드 포인트들)"
" 포함합니다."

#: ../Doc/library/stdtypes.rst:352
#, fuzzy
msgid ""
"See "
"http://www.unicode.org/Public/10.0.0/ucd/extracted/DerivedNumericType.txt"
" for a complete list of code points with the ``Nd`` property."
msgstr ""
"``Nd`` 속성을 가진 코드 포인트의 전체 목록을 보려면 "
"http://www.unicode.org/Public/9.0.0/ucd/extracted/DerivedNumericType.txt "
"를 보십시오."

#: ../Doc/library/stdtypes.rst:356
msgid ""
"All :class:`numbers.Real` types (:class:`int` and :class:`float`) also "
"include the following operations:"
msgstr ""
"모든 :class:`numbers.Real` 형 (:class:`int` 와 :class:`float`) 은 또한 다음과 같은 "
"연산들을 포함합니다:"

#: ../Doc/library/stdtypes.rst:362
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../Doc/library/stdtypes.rst:362
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* 는 :class:`~numbers.Integral` 로 잘립니다"

#: ../Doc/library/stdtypes.rst:365
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) <round>`"

#: ../Doc/library/stdtypes.rst:365
msgid ""
"*x* rounded to *n* digits, rounding half to even. If *n* is omitted, it "
"defaults to 0."
msgstr "*x* 를 *n* 자리로 반올림하는데, 절반 값은 짝수로 반올림합니다. *n* 을 생략하면 기본값은 0입니다."

#: ../Doc/library/stdtypes.rst:369
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../Doc/library/stdtypes.rst:369
msgid "the greatest :class:`~numbers.Integral` <= *x*"
msgstr "가장 큰 :class:`~numbers.Integral` <= *x*"

#: ../Doc/library/stdtypes.rst:372
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../Doc/library/stdtypes.rst:372
msgid "the least :class:`~numbers.Integral` >= *x*"
msgstr "가장 작은 :class:`~numbers.Integral` >= *x*"

#: ../Doc/library/stdtypes.rst:376
msgid ""
"For additional numeric operations see the :mod:`math` and :mod:`cmath` "
"modules."
msgstr "추가적인 숫자 연산은 :mod:`math`\\와 :mod:`cmath` 모듈을 보십시오."

#: ../Doc/library/stdtypes.rst:385
msgid "Bitwise Operations on Integer Types"
msgstr "정수 형에 대한 비트 연산"

#: ../Doc/library/stdtypes.rst:399
msgid ""
"Bitwise operations only make sense for integers.  Negative numbers are "
"treated as their 2's complement value (this assumes that there are enough"
" bits so that no overflow occurs during the operation)."
msgstr ""
"비트 연산은 정수에 대해서만 의미가 있습니다. 음수는 2의 보수 값으로 처리됩니다 (이는 연산 중에 오버플로가 발생하지 않도록 "
"충분한 비트가 있다고 가정합니다)."

#: ../Doc/library/stdtypes.rst:403
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` "
"and ``-``)."
msgstr ""
"이진 비트 연산의 우선순위는 모두 숫자 연산보다 낮고 비교보다 높습니다; 일항 연산 ``~`` 은 다른 일항 연산들 (``+`` 와"
" ``-``) 과 같은 우선순위를 가집니다."

#: ../Doc/library/stdtypes.rst:407
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr "이 표는 비트 연산을 나열하는데, 우선순위에 따라 오름차순으로 정렬되어 있습니다:"

#: ../Doc/library/stdtypes.rst:412
msgid "``x | y``"
msgstr "``x | y``"

#: ../Doc/library/stdtypes.rst:412
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "*x* 와 *y* 의 비트별 :dfn:`or`"

#: ../Doc/library/stdtypes.rst:415
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../Doc/library/stdtypes.rst:415
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "*x* 와 *y* 의 비트별 :dfn:`배타적 or (exclusive or)`"

#: ../Doc/library/stdtypes.rst:418
msgid "``x & y``"
msgstr "``x & y``"

#: ../Doc/library/stdtypes.rst:418
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "*x* 와 *y* 의 비트별 :dfn:`and`"

#: ../Doc/library/stdtypes.rst:421
msgid "``x << n``"
msgstr "``x << n``"

#: ../Doc/library/stdtypes.rst:421
msgid "*x* shifted left by *n* bits"
msgstr "*x* 를 *n* 비트만큼 왼쪽으로 시프트"

#: ../Doc/library/stdtypes.rst:421
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../Doc/library/stdtypes.rst:423
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../Doc/library/stdtypes.rst:423
msgid "*x* shifted right by *n* bits"
msgstr "*x* 를 *n* 비트만큼 오른쪽으로 시프트"

#: ../Doc/library/stdtypes.rst:423
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../Doc/library/stdtypes.rst:425
msgid "``~x``"
msgstr "``~x``"

#: ../Doc/library/stdtypes.rst:425
msgid "the bits of *x* inverted"
msgstr "*x* 의 비트 반전"

#: ../Doc/library/stdtypes.rst:431
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be "
"raised."
msgstr "음의 시프트 수는 허락되지 않고 :exc:`ValueError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:434
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``"
" without overflow check."
msgstr "*n* 비트만큼의 왼쪽 시프트는 오버플로 검사 없이 ``pow(2, n)`` 를 곱하는 것과 동등합니다."

#: ../Doc/library/stdtypes.rst:438
msgid ""
"A right shift by *n* bits is equivalent to division by ``pow(2, n)`` "
"without overflow check."
msgstr "*n* 비트만큼 오른쪽으로 시프트 하는 것은 오버플로 검사 없이 ``pow(2, n)`` 로 나누는 것과 동등합니다."

#: ../Doc/library/stdtypes.rst:443
msgid "Additional Methods on Integer Types"
msgstr "정수 형에 대한 추가 메서드"

#: ../Doc/library/stdtypes.rst:445
msgid ""
"The int type implements the :class:`numbers.Integral` :term:`abstract "
"base class`. In addition, it provides a few more methods:"
msgstr ""
"int 형은 :class:`numbers.Integral` :term:`추상 베이스 클래스 <abstract base class>`"
" 를 구현합니다. 또한, 몇 가지 메서드를 더 제공합니다:"

#: ../Doc/library/stdtypes.rst:450
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr "부호와 선행 0을 제외하고, 이진수로 정수를 나타내는 데 필요한 비트 수를 돌려줍니다::"

#: ../Doc/library/stdtypes.rst:459
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the "
"unique positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded"
" logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then "
"``x.bit_length()`` returns ``0``."
msgstr ""
"좀 더 정확하게 말하자면, ``x`` 가 0이 아니면, ``x.bit_length()`` 는 ``2**(k-1) <= abs(x) "
"< 2**k`` 를 만족하는 유일한 양의 정수 ``k`` 입니다. 동등하게, ``abs(x)`` 가 정확하게 반올림된 로그값을 가질"
" 만큼 아주 작으면, ``k = 1 + int(log(abs(x), 2))`` 가 됩니다. ``x`` 가 0이면, "
"``x.bit_length()`` 는 ``0`` 을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:465
msgid "Equivalent to::"
msgstr "다음 코드와 동등합니다::"

#: ../Doc/library/stdtypes.rst:476
msgid "Return an array of bytes representing an integer."
msgstr "정수를 나타내는 바이트의 배열을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:488
msgid ""
"The integer is represented using *length* bytes.  An :exc:`OverflowError`"
" is raised if the integer is not representable with the given number of "
"bytes."
msgstr ""
"정수는 *length* 바이트를 사용하여 표현됩니다. 정수가 주어진 바이트 수로 표현할 수 없는 경우 An "
":exc:`OverflowError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:492 ../Doc/library/stdtypes.rst:524
msgid ""
"The *byteorder* argument determines the byte order used to represent the "
"integer.  If *byteorder* is ``\"big\"``, the most significant byte is at "
"the beginning of the byte array.  If *byteorder* is ``\"little\"``, the "
"most significant byte is at the end of the byte array.  To request the "
"native byte order of the host system, use :data:`sys.byteorder` as the "
"byte order value."
msgstr ""
"*byteorder* 인자는 정수를 나타내는 데 사용되는 바이트 순서를 결정합니다. *byteorder* 가 ``\"big\"`` "
"인 경우, 최상위 바이트는 바이트 배열의 처음에 있습니다. *byteorder* 가 ``\"little\"`` 인 경우, 최상위 "
"바이트는 바이트 배열의 끝에 있습니다. 호스트 시스템의 기본 바이트 순서를 요청하려면 바이트 순서 값으로 "
":data:`sys.byteorder` 를 사용하십시오."

#: ../Doc/library/stdtypes.rst:499
msgid ""
"The *signed* argument determines whether two's complement is used to "
"represent the integer.  If *signed* is ``False`` and a negative integer "
"is given, an :exc:`OverflowError` is raised. The default value for "
"*signed* is ``False``."
msgstr ""
"*signed* 인자는 정수를 표현하는데 2의 보수가 사용되는지를 결정합니다. *signed* 가 ``False`` 이고 음의 "
"정수가 주어지면, :exc:`OverflowError` 가 일어납니다. *signed* 의 기본값은 ``False`` 입니다."

#: ../Doc/library/stdtypes.rst:508
msgid "Return the integer represented by the given array of bytes."
msgstr "주어진 바이트 배열로 표현되는 정수를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:521
msgid ""
"The argument *bytes* must either be a :term:`bytes-like object` or an "
"iterable producing bytes."
msgstr ""
"인자 *bytes* 는 :term:`바이트열류 객체 <bytes-like object>` 이거나 바이트를 생성하는 이터러블이어야 "
"합니다."

#: ../Doc/library/stdtypes.rst:531
msgid ""
"The *signed* argument indicates whether two's complement is used to "
"represent the integer."
msgstr "*signed* 인자는 정수를 표현하는데 2의 보수가 사용되는지를 나타냅니다."

#: ../Doc/library/stdtypes.rst:538
msgid "Additional Methods on Float"
msgstr "실수에 대한 추가 메서드"

#: ../Doc/library/stdtypes.rst:540
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"float 형은 :class:`numbers.Real` :term:`추상 베이스 클래스 <abstract base class>` 를"
" 구현합니다. 또한, float는 다음과 같은 추가 메서드를 갖습니다."

#: ../Doc/library/stdtypes.rst:545
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original "
"float and with a positive denominator.  Raises :exc:`OverflowError` on "
"infinities and a :exc:`ValueError` on NaNs."
msgstr ""
"비율이 원래 float와 정확히 같고 양의 분모를 갖는 정수 쌍을 돌려줍니다. 무한대에는 :exc:`OverflowError` 를,"
" NaN 에는 a :exc:`ValueError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:552
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr "float 인스턴스가 정숫값을 가진 유한이면 ``True`` 를, 그렇지 않으면 ``False`` 를 돌려줍니다::"

#: ../Doc/library/stdtypes.rst:560
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a "
"float to or from a *decimal* string usually involves a small rounding "
"error.  In contrast, hexadecimal strings allow exact representation and "
"specification of floating-point numbers.  This can be useful when "
"debugging, and in numerical work."
msgstr ""
"두 가지 메서드가 16진수 문자열과의 변환을 지원합니다. 파이썬의 float는 내부적으로 이진수로 저장되기 때문에 float를 "
"*십진수* 문자열로 또는 그 반대로 변환하는 것은 보통 반올림 오류를 수반합니다. 이에 반해, 16진수 문자열은 부동 소수점 숫자의"
" 정확한 표현과 지정을 가능하게 합니다. 이것은 디버깅 및 수치 작업에 유용할 수 있습니다."

#: ../Doc/library/stdtypes.rst:571
msgid ""
"Return a representation of a floating-point number as a hexadecimal "
"string.  For finite floating-point numbers, this representation will "
"always include a leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"부동 소수점의 16진수 문자열 표현을 돌려줍니다. 유한 부동 소수점의 경우, 이 표현은 항상 선행하는 ``0x`` 와 후행하는 "
"``p`` 와 지수를 포함합니다."

#: ../Doc/library/stdtypes.rst:579
msgid ""
"Class method to return the float represented by a hexadecimal string *s*."
"  The string *s* may have leading and trailing whitespace."
msgstr "16진수 문자열 *s* 로 표현되는 float를 돌려주는 클래스 메서드. 문자열 *s* 는 앞뒤 공백을 가질 수 있습니다."

#: ../Doc/library/stdtypes.rst:584
msgid ""
"Note that :meth:`float.hex` is an instance method, while "
":meth:`float.fromhex` is a class method."
msgstr ":meth:`float.hex` 는 인스턴스 메서드인 반면, :meth:`float.fromhex` 는 클래스 메서드임에 주의하세요."

#: ../Doc/library/stdtypes.rst:587
msgid "A hexadecimal string takes the form::"
msgstr "16진수 문자열은 다음과 같은 형식을 취합니다::"

#: ../Doc/library/stdtypes.rst:591
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and"
" ``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, "
"and there must be at least one hexadecimal digit in either the integer or"
" the fraction.  This syntax is similar to the syntax specified in section"
" 6.4.4.2 of the C99 standard, and also to the syntax used in Java 1.5 "
"onwards.  In particular, the output of :meth:`float.hex` is usable as a "
"hexadecimal floating-point literal in C or Java code, and hexadecimal "
"strings produced by C's ``%a`` format character or Java's "
"``Double.toHexString`` are accepted by :meth:`float.fromhex`."
msgstr ""
"선택적인 ``sign`` 은 ``+`` 나 ``-`` 가 될 수 있고, ``integer`` 와 ``fraction`` 은 16진수"
" 문자열이고, ``exponent`` 는 선택적인 선행 부호가 붙을 수 있는 십진수입니다. 대소 문자는 중요하지 않으며 "
"integer 나 fraction 중 어느 하나에 적어도 하나의 16진수가 있어야 합니다. 이 문법은 C99 표준의 6.4.4.2 "
"절에 지정된 문법과 비슷하며, 자바 1.5 이상에서 사용되는 문법과도 비슷합니다. 특히, :meth:`float.hex` 의 출력은"
" C 또는 자바 코드에서 16진수의 부동 소수점 리터럴로 사용할 수 있으며, C의 ``%a`` 포맷 문자나 자바의 "
"``Double.toHexString`` 가 만들어내는 16진수 문자열은 :meth:`float.fromhex` 가 받아들입니다."

#: ../Doc/library/stdtypes.rst:604
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and"
" that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-"
"point number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"지수는 16진수가 아닌 십진수로 쓰이고, 숫자에 곱해지는 2의 거듭제곱을 제공한다는 점에 유의하십시오. 예를 들어, 16진수 문자열"
" ``0x3.a7p10`` 는 부동 소수점 숫자 ``(3 + 10./16 + 7./16**2) * 2.0**10`` 또는 "
"``3740.0`` 를 나타냅니다::"

#: ../Doc/library/stdtypes.rst:614
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different "
"hexadecimal string representing the same number::"
msgstr "``3740.0`` 에 역변환을 적용하면 같은 숫자를 나타내는 다른 16진수 문자열을 얻을 수 있습니다::"

#: ../Doc/library/stdtypes.rst:624
msgid "Hashing of numeric types"
msgstr "숫자 형의 해싱"

#: ../Doc/library/stdtypes.rst:626
msgid ""
"For numbers ``x`` and ``y``, possibly of different types, it's a "
"requirement that ``hash(x) == hash(y)`` whenever ``x == y`` (see the "
":meth:`__hash__` method documentation for more details).  For ease of "
"implementation and efficiency across a variety of numeric types "
"(including :class:`int`, :class:`float`, :class:`decimal.Decimal` and "
":class:`fractions.Fraction`) Python's hash for numeric types is based on "
"a single mathematical function that's defined for any rational number, "
"and hence applies to all instances of :class:`int` and "
":class:`fractions.Fraction`, and all finite instances of :class:`float` "
"and :class:`decimal.Decimal`.  Essentially, this function is given by "
"reduction modulo ``P`` for a fixed prime ``P``.  The value of ``P`` is "
"made available to Python as the :attr:`modulus` attribute of "
":data:`sys.hash_info`."
msgstr ""
"숫자 ``x`` 와 ``y``, 서로 다른 형이어도 됩니다, 에 대하여, ``x == y`` 면 항상 ``hash(x) == "
"hash(y)`` 일 것이 요구됩니다 (자세한 내용은 :meth:`__hash__` 메서드 도큐멘테이션을 보세요). 다양한 숫자 "
"형(:class:`int`, :class:`float`, :class:`decimal.Decimal`, "
":class:`fractions.Fraction` 포함)들의 구현의 편의성과 효율 때문에, 파이썬의 숫자 형의 해시는 단일한 수학 "
"함수에 기반을 두고 있고, 이 함수는 임의의 유리수에 대해 정의되어서 :class:`int` 와 "
":class:`fractions.Fraction` 의 모든 인스턴스, :class:`float`\\와 "
":class:`decimal.Decimal` 의 모든 유한 인스턴스에 적용됩니다. 본질에서, 이 함수는 고정 소수 ``P`` 에 "
"대해 모듈로 ``P`` 환원(reduction modulo ``P``)으로 주어집니다. ``P`` 의 값은 "
":data:`sys.hash_info` 의 :attr:`modulus` 어트리뷰트로 파이썬에 제공됩니다."

#: ../Doc/library/stdtypes.rst:641
msgid ""
"Currently, the prime used is ``P = 2**31 - 1`` on machines with 32-bit C "
"longs and ``P = 2**61 - 1`` on machines with 64-bit C longs."
msgstr ""
"현재, 사용되는 소수는 32-비트 C long을 가진 기계에서는 ``P = 2**31 - 1`` 이고, 64-비트 C long을 "
"가진 기계에서는 ``P = 2**61 - 1`` 입니다."

#: ../Doc/library/stdtypes.rst:644
msgid "Here are the rules in detail:"
msgstr "다음은 규칙에 대한 세부 사항입니다:"

#: ../Doc/library/stdtypes.rst:646
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is not "
"divisible by ``P``, define ``hash(x)`` as ``m * invmod(n, P) % P``, where"
" ``invmod(n, P)`` gives the inverse of ``n`` modulo ``P``."
msgstr ""
"``x = m / n`` 이 음이 아닌 유리수이고 ``n`` 이 ``P`` 로 나뉘지 않는다면, ``hash(x)`` 를 ``m *"
" invmod(n, P) % P`` 로 정의합니다. 여기서 ``invmod(n, P)`` 는 ``n`` 의 모듈로 ``P`` 역수를"
" 줍니다."

#: ../Doc/library/stdtypes.rst:650
msgid ""
"If ``x = m / n`` is a nonnegative rational number and ``n`` is divisible "
"by ``P`` (but ``m`` is not) then ``n`` has no inverse modulo ``P`` and "
"the rule above doesn't apply; in this case define ``hash(x)`` to be the "
"constant value ``sys.hash_info.inf``."
msgstr ""
"``x = m / n`` 이 음이 아닌 유리수이고 ``n`` 이 ``P`` 나뉘면 (하지만 ``m`` 은 나뉘지 않으면) ``n``"
" 은 모듈로 ``P`` 역수를 가지지 않고 위의 규칙은 적용되지 않습니다; 이 경우 ``hash(x)`` 를 상숫값 "
"``sys.hash_info.inf`` 로 정의합니다."

#: ../Doc/library/stdtypes.rst:655
msgid ""
"If ``x = m / n`` is a negative rational number define ``hash(x)`` as "
"``-hash(-x)``.  If the resulting hash is ``-1``, replace it with ``-2``."
msgstr ""
"``x = m / n`` 이 음의 유리수이면 ``hash(x)`` 를 ``-hash(-x)`` 로 정의합니다. 얻어진 해시가 "
"``-1`` 이면 ``-2`` 로 바꿉니다."

#: ../Doc/library/stdtypes.rst:659
msgid ""
"The particular values ``sys.hash_info.inf``, ``-sys.hash_info.inf`` and "
"``sys.hash_info.nan`` are used as hash values for positive infinity, "
"negative infinity, or nans (respectively).  (All hashable nans have the "
"same hash value.)"
msgstr ""
"특별한 값 ``sys.hash_info.inf``, ``-sys.hash_info.inf``, "
"``sys.hash_info.nan`` 은 각각 무한대, 음의 무한대, nan 으로 사용됩니다. (모든 해시 가능 nan 은 같은 "
"해시값을 가집니다.)"

#: ../Doc/library/stdtypes.rst:664
msgid ""
"For a :class:`complex` number ``z``, the hash values of the real and "
"imaginary parts are combined by computing ``hash(z.real) + "
"sys.hash_info.imag * hash(z.imag)``, reduced modulo "
"``2**sys.hash_info.width`` so that it lies in "
"``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))``.  "
"Again, if the result is ``-1``, it's replaced with ``-2``."
msgstr ""
"복소수(:class:`complex`) ``z`` 의 경우, ``hash(z.real) + sys.hash_info.imag * "
"hash(z.imag)`` 를 계산하여 실수부와 허수부의 해시값을 결합하는데, ``2**sys.hash_info.width`` 의 "
"모듈로로 환원해서 ``range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width "
"- 1))`` 범위에 들어가도록 만듭니다. 다시 한번, 결과가 ``-1`` 이라면 ``-2`` 로 바꿉니다."

#: ../Doc/library/stdtypes.rst:672
msgid ""
"To clarify the above rules, here's some example Python code, equivalent "
"to the built-in hash, for computing the hash of a rational number, "
":class:`float`, or :class:`complex`::"
msgstr ""
"위의 규칙을 명확히 하기 위해, 여기에 유리수, :class:`float`, :class:`complex` 의 해시를 계산하는, "
"내장 해시와 동등한, 파이썬 코드를 예시합니다::"

#: ../Doc/library/stdtypes.rst:727
msgid "Iterator Types"
msgstr "이터레이터 형"

#: ../Doc/library/stdtypes.rst:735
msgid ""
"Python supports a concept of iteration over containers.  This is "
"implemented using two distinct methods; these are used to allow user-"
"defined classes to support iteration.  Sequences, described below in more"
" detail, always support the iteration methods."
msgstr ""
"파이썬은 컨테이너에 대한 이터레이션 개념을 지원합니다. 이것은 두 개의 메서드를 사용해서 구현됩니다; 이것들은 사용자 정의 클래스가"
" 이터레이션을 지원할 수 있도록 하는 데 사용됩니다. 아래에서 더 자세히 설명할 시퀀스는 항상 이터레이션 메서드를 지원합니다."

#: ../Doc/library/stdtypes.rst:740
msgid ""
"One method needs to be defined for container objects to provide iteration"
" support:"
msgstr "컨테이너 객체가 이터레이션 지원을 제공하려면 한가지 메서드를 정의할 필요가 있습니다.:"

#: ../Doc/library/stdtypes.rst:747
msgid ""
"Return an iterator object.  The object is required to support the "
"iterator protocol described below.  If a container supports different "
"types of iteration, additional methods can be provided to specifically "
"request iterators for those iteration types.  (An example of an object "
"supporting multiple forms of iteration would be a tree structure which "
"supports both breadth-first and depth-first traversal.)  This method "
"corresponds to the :c:member:`~PyTypeObject.tp_iter` slot of the type "
"structure for Python objects in the Python/C API."
msgstr ""
"이터레이터 객체를 돌려줍니다. 이 객체는 아래에서 설명하는 이터레이터 프로토콜을 지원해야 합니다. 컨테이너가 여러 유형의 "
"이터레이션을 지원하는 경우, 이터레이션 유형에 대한 이터레이터를 구체적으로 요구하는 추가 메서드를 제공할 수 있습니다. (여러 "
"형태의 이터레이션을 지원하는 객체의 예로 너비 우선과 깊이 우선 탐색을 모두 지원하는 트리 구조를 들 수 있습니다.) 이 메서드는 "
"파이썬/C API에서 파이썬 객체를 위한 구조체의 :c:member:`~PyTypeObject.tp_iter` 슬롯에 대응합니다."

#: ../Doc/library/stdtypes.rst:756
msgid ""
"The iterator objects themselves are required to support the following two"
" methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"이터레이터 객체 자체는 다음과 같은 두 가지 메서드를 지원해야 하는데, 둘이 함께 :dfn:`이터레이터 프로토콜 (iterator "
"protocol)` 를 이룹니다.:"

#: ../Doc/library/stdtypes.rst:762
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and "
":keyword:`in` statements. This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"이터레이터 객체 자신을 돌려줍니다. 이는 :keyword:`for` 와 :keyword:`in` 문에 컨테이너와 이터레이터 모두 "
"사용될 수 있게 하는 데 필요합니다. 이 메서드는 파이썬/C API에서 파이썬 객체를 위한 구조체의 "
":c:member:`~PyTypeObject.tp_iter` 슬롯에 대응합니다."

#: ../Doc/library/stdtypes.rst:770
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the"
" :c:member:`~PyTypeObject.tp_iternext` slot of the type structure for "
"Python objects in the Python/C API."
msgstr ""
"컨테이너의 다음 항목을 돌려줍니다. 더 항목이 없으면 :exc:`StopIteration` 예외를 일으킵니다. 이 메서드는 "
"파이썬/C API에서 파이썬 객체를 위한 구조체의 :c:member:`~PyTypeObject.tp_iternext` 슬롯에 "
"대응합니다."

#: ../Doc/library/stdtypes.rst:775
msgid ""
"Python defines several iterator objects to support iteration over general"
" and specific sequence types, dictionaries, and other more specialized "
"forms.  The specific types are not important beyond their implementation "
"of the iterator protocol."
msgstr ""
"파이썬은 일반적이거나 특정한 시퀀스 형, 딕셔너리, 기타 더 특화된 형태에 대한 이터레이션을 지원하기 위해 여러 이터레이터 객체를 "
"정의합니다. 이터레이터 프로토콜의 구현을 넘어서 개별적인 형이 중요하지는 않습니다."

#: ../Doc/library/stdtypes.rst:780
msgid ""
"Once an iterator's :meth:`~iterator.__next__` method raises "
":exc:`StopIteration`, it must continue to do so on subsequent calls. "
"Implementations that do not obey this property are deemed broken."
msgstr ""
"일단 이터레이터의 :meth:`~iterator.__next__` 메서드가 :exc:`StopIteration` 를 일으키면, 그 "
"이후의 호출에 대해서도 같이 동작해야 합니다. 이 속성을 따르지 않는 구현은 망가진 것으로 간주합니다."

#: ../Doc/library/stdtypes.rst:788
msgid "Generator Types"
msgstr "제너레이터 형"

#: ../Doc/library/stdtypes.rst:790
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator "
"object (technically, a generator object) supplying the :meth:`__iter__` "
"and :meth:`~generator.__next__` methods. More information about "
"generators can be found in :ref:`the documentation for the yield "
"expression <yieldexpr>`."
msgstr ""
"파이썬의 :term:`제너레이터 <generator>` 는 이터레이터 프로토콜을 구현하는 편리한 방법을 제공합니다. 컨테이너 객체의"
" :meth:`__iter__` 메서드가 제너레이터로 구현되면, :meth:`__iter__` 와 "
":meth:`~generator.__next__` 메서드를 제공하는 이터레이터 객체(기술적으로, 제너레이터 객체)를 자동으로 "
"돌려줍니다. 제너레이터에 대한 더 자세한 정보는 :ref:`일드 표현식 도큐멘테이션 <yieldexpr>` 에서 찾을 수 있습니다."

#: ../Doc/library/stdtypes.rst:802
msgid "Sequence Types --- :class:`list`, :class:`tuple`, :class:`range`"
msgstr "시퀀스 형 --- :class:`list`, :class:`tuple`, :class:`range`"

#: ../Doc/library/stdtypes.rst:804
msgid ""
"There are three basic sequence types: lists, tuples, and range objects. "
"Additional sequence types tailored for processing of :ref:`binary data "
"<binaryseq>` and :ref:`text strings <textseq>` are described in dedicated"
" sections."
msgstr ""
"세 가지 기본 시퀀스 형이 있습니다: 리스트, 튜플, 범위 객체. :ref:`바이너리 데이터 <binaryseq>` 와 "
":ref:`텍스트 문자열 <textseq>` 의 처리를 위해 추가된 시퀀스 형들은 별도의 섹션에서 설명합니다."

#: ../Doc/library/stdtypes.rst:813
msgid "Common Sequence Operations"
msgstr "공통 시퀀스 연산"

#: ../Doc/library/stdtypes.rst:817
msgid ""
"The operations in the following table are supported by most sequence "
"types, both mutable and immutable. The :class:`collections.abc.Sequence` "
"ABC is provided to make it easier to correctly implement these operations"
" on custom sequence types."
msgstr ""
"다음 표의 연산들은 대부분의 가변과 불변 시퀀스에서 지원됩니다. 사용자 정의 시퀀스에서 이 연산들을 올바르게 구현하기 쉽게 하려고 "
":class:`collections.abc.Sequence` ABC가 제공됩니다."

#: ../Doc/library/stdtypes.rst:822
msgid ""
"This table lists the sequence operations sorted in ascending priority.  "
"In the table, *s* and *t* are sequences of the same type, *n*, *i*, *j* "
"and *k* are integers and *x* is an arbitrary object that meets any type "
"and value restrictions imposed by *s*."
msgstr ""
"이 표는 우선순위에 따라 오름차순으로 시퀀스 연산들을 나열합니다. 표에서, *s* 와 *t* 는 같은 형의 시퀀스고, *n*, "
"*i*, *j*, *k* 는 정수이고, *x* 는 *s* 가 요구하는 형과 값 제한을 만족하는 임의의 객체입니다."

#: ../Doc/library/stdtypes.rst:827
msgid ""
"The ``in`` and ``not in`` operations have the same priorities as the "
"comparison operations. The ``+`` (concatenation) and ``*`` (repetition) "
"operations have the same priority as the corresponding numeric "
"operations. [3]_"
msgstr ""
"``in`` 과 ``not in`` 연산은 비교 연산과 우선순위가 같습니다. ``+`` (이어 붙이기)와 ``*`` (반복) 연산은"
" 대응하는 숫자 연산과 같은 우선순위를 갖습니다. [3]_"

#: ../Doc/library/stdtypes.rst:848
msgid "``x in s``"
msgstr "``x in s``"

#: ../Doc/library/stdtypes.rst:848
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "*s* 의 항목 중 하나가 *x* 와 같으면 ``True``, 그렇지 않으면 ``False``"

#: ../Doc/library/stdtypes.rst:851
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../Doc/library/stdtypes.rst:851
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "*s* 의 항목 중 하나가 *x* 와 같으면 ``False``, 그렇지 않으면 ``True``"

#: ../Doc/library/stdtypes.rst:854
msgid "``s + t``"
msgstr "``s + t``"

#: ../Doc/library/stdtypes.rst:854
msgid "the concatenation of *s* and *t*"
msgstr "*s* 와 *t* 의 이어 붙이기"

#: ../Doc/library/stdtypes.rst:854
msgid "(6)(7)"
msgstr "(6)(7)"

#: ../Doc/library/stdtypes.rst:857
msgid "``s * n`` or ``n * s``"
msgstr "``s * n`` 또는 ``n * s``"

#: ../Doc/library/stdtypes.rst:857
msgid "equivalent to adding *s* to itself *n* times"
msgstr "*s* 를 그 자신에 *n* 번 더하는 것과 같습니다"

#: ../Doc/library/stdtypes.rst:857
msgid "(2)(7)"
msgstr "(2)(7)"

#: ../Doc/library/stdtypes.rst:860
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../Doc/library/stdtypes.rst:860
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*s* 의 *i* 번째 항목, 0에서 시작합니다"

#: ../Doc/library/stdtypes.rst:862
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../Doc/library/stdtypes.rst:862
msgid "slice of *s* from *i* to *j*"
msgstr "*s* 의 *i* 에서 *j* 까지의 슬라이스"

#: ../Doc/library/stdtypes.rst:862
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../Doc/library/stdtypes.rst:864
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:864
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "*s* 의 *i* 에서 *j* 까지 스텝 *k* 의 슬라이스"

#: ../Doc/library/stdtypes.rst:864
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../Doc/library/stdtypes.rst:867
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../Doc/library/stdtypes.rst:867
msgid "length of *s*"
msgstr "*s* 의 길이"

#: ../Doc/library/stdtypes.rst:869
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../Doc/library/stdtypes.rst:869
msgid "smallest item of *s*"
msgstr "*s* 의 가장 작은 항목"

#: ../Doc/library/stdtypes.rst:871
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../Doc/library/stdtypes.rst:871
msgid "largest item of *s*"
msgstr "*s* 의 가장 큰 항목"

#: ../Doc/library/stdtypes.rst:873
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../Doc/library/stdtypes.rst:873
msgid ""
"index of the first occurrence of *x* in *s* (at or after index *i* and "
"before index *j*)"
msgstr "(인덱스 *i* 또는 그 이후에, 인덱스 *j* 전에 등장하는) *s* 의 첫 번째 *x* 의 인덱스"

#: ../Doc/library/stdtypes.rst:873 ../Doc/library/stdtypes.rst:3308
msgid "\\(8)"
msgstr "\\(8)"

#: ../Doc/library/stdtypes.rst:877
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../Doc/library/stdtypes.rst:877
msgid "total number of occurrences of *x* in *s*"
msgstr "*s* 등장하는 *x* 의 총수"

#: ../Doc/library/stdtypes.rst:881
msgid ""
"Sequences of the same type also support comparisons.  In particular, "
"tuples and lists are compared lexicographically by comparing "
"corresponding elements. This means that to compare equal, every element "
"must compare equal and the two sequences must be of the same type and "
"have the same length.  (For full details see :ref:`comparisons` in the "
"language reference.)"
msgstr ""
"같은 형의 시퀀스는 비교를 지원합니다. 특히, 튜플과 리스트는 대응하는 항목들을 사전적으로 비교합니다. 이것은 같다고 비교되기 "
"위해서는, 모든 항목이 같다고 비교되고, 두 시퀀스의 형과 길이가 같아야 함을 의미합니다. (자세한 내용은 언어 레퍼런스의 "
":ref:`comparisons`\\를 참조하십시오.)"

#: ../Doc/library/stdtypes.rst:890
msgid ""
"While the ``in`` and ``not in`` operations are used only for simple "
"containment testing in the general case, some specialised sequences (such"
" as :class:`str`, :class:`bytes` and :class:`bytearray`) also use them "
"for subsequence testing::"
msgstr ""
"``in`` 과 ``not in`` 연산은 일반적으로 단순한 포함 검사를 위해서만 사용되지만, 몇몇 특수한 시퀀스 "
"(:class:`str`, :class:`bytes`, :class:`bytearray` 같은) 들은 서브 시퀀스 검사에 사용하기도"
" 합니다::"

#: ../Doc/library/stdtypes.rst:899
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty"
" sequence of the same type as *s*).  Note that items in the sequence *s* "
"are not copied; they are referenced multiple times.  This often haunts "
"new Python programmers; consider::"
msgstr ""
"*n* 의 값이 ``0`` 보다 작으면 ``0`` 으로 처리됩니다 (*s* 와 같은 형의 빈 시퀀스가 됩니다). 시퀀스 *s* 의 "
"항목들이 복사되지 않음에 주의해야 합니다; 그들은 여러 번 참조됩니다. 이것은 종종 새 파이썬 프로그래머들을 괴롭힙니다; 이 코드를"
" 살펴보세요::"

#: ../Doc/library/stdtypes.rst:911
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an "
"empty list, so all three elements of ``[[]] * 3`` are references to this "
"single empty list.  Modifying any of the elements of ``lists`` modifies "
"this single list. You can create a list of different lists this way::"
msgstr ""
"무슨 일이 일어났는가 하면, ``[[]]`` 는 빈 리스트를 포함하는 길이 1인 리스트인데, ``[[]] * 3`` 의 세 항목은 "
"모두 같은 빈 리스트를 참조합니다. ``lists`` 의 어느 항목을 수정하더라도 이 하나의 리스트를 수정하게 됩니다. 서로 다른 "
"리스트들을 포함하는 리스트는 이런 식으로 만들 수 있습니다::"

#: ../Doc/library/stdtypes.rst:923
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-"
"multidimensional-list`."
msgstr "더 자세한 설명은 FAQ 항목 :ref:`faq-multidimensional-list`\\에서 얻을 수 있습니다."

#: ../Doc/library/stdtypes.rst:927
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence "
"*s*: ``len(s) + i`` or ``len(s) + j`` is substituted.  But note that "
"``-0`` is still ``0``."
msgstr ""
"*i* 또는 *j* 가 음수인 경우, 인덱스는 시퀀스 *s* 의 끝에 상대적입니다: ``len(s) + i`` 이나 ``len(s)"
" + j`` 로 치환됩니다. 하지만 ``-0`` 은 여전히 ``0`` 입니다."

#: ../Doc/library/stdtypes.rst:932
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with"
" index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  "
"If *j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or"
" equal to *j*, the slice is empty."
msgstr ""
"*i* 에서 *j* 까지의 *s* 의 슬라이스는 ``i <= k < j`` 를 만족하는 인덱스 *k* 의 항목들로 구성된 시퀀스로 "
"정의됩니다. *i* 또는 *j* 가 ``len(s)`` 보다 크면 ``len(s)`` 을 사용합니다. *i* 가 생략되거나 "
"``None`` 이라면 ``0`` 을 사용합니다. *j* 가 생략되거나 ``None`` 이면 ``len(s)`` 을 사용합니다. "
"*i* 가 *j* 보다 크거나 같으면 빈 슬라이스가 됩니다."

#: ../Doc/library/stdtypes.rst:939
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence"
" of items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In"
" other words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so"
" on, stopping when *j* is reached (but never including *j*).  When *k* is"
" positive, *i* and *j* are reduced to ``len(s)`` if they are greater. "
"When *k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they "
"are greater.  If *i* or *j* are omitted or ``None``, they become \"end\" "
"values (which end depends on the sign of *k*).  Note, *k* cannot be zero."
" If *k* is ``None``, it is treated like ``1``."
msgstr ""
"스텝 *k* 가 있는 *i* 에서 *j* 까지의 슬라이스는 ``0 <= n < (j-i)/k`` 를 만족하는 인덱스 ``x = i "
"+ n*k`` 의 항목들로 구성된 시퀀스로 정의됩니다. 다시 말하면, 인덱스는 ``i``, ``i+k``, ``i+2*k``, "
"``i+3*k`` 등이며 *j* 에 도달할 때 멈춥니다 (하지만 절대 *j* 를 포함하지는 않습니다). *k* 가 양수면 *i* 와"
" *j* 는 더 큰 경우 ``len(s)`` 로 줄어듭니다. *k* 가 음수면, *i* 와 *j* 는 더 큰 경우 ``len(s) "
"- 1`` 로 줄어듭니다. *i* 또는 *j* 가 생략되거나 ``None`` 이면, 그것들은 \"끝\" 값이 됩니다 (끝은 *k* "
"의 부호에 따라 달라집니다). *k* 는 0일 수 없음에 주의하세요. *k* 가 ``None`` 이면 ``1`` 로 취급됩니다."

#: ../Doc/library/stdtypes.rst:950
msgid ""
"Concatenating immutable sequences always results in a new object.  This "
"means that building up a sequence by repeated concatenation will have a "
"quadratic runtime cost in the total sequence length.  To get a linear "
"runtime cost, you must switch to one of the alternatives below:"
msgstr ""
"불변 시퀀스를 이어 붙이면 항상 새로운 객체가 생성됩니다. 이것은 반복적으로 이어붙이기를 해서 시퀀스를 만들 때 실행 시간이 "
"시퀀스의 총 길이의 제곱에 비례한다는 뜻입니다. 선형 실행 시간 비용을 얻으려면 아래 대안 중 하나로 전환해야 합니다:"

#: ../Doc/library/stdtypes.rst:955
msgid ""
"if concatenating :class:`str` objects, you can build a list and use "
":meth:`str.join` at the end or else write to an :class:`io.StringIO` "
"instance and retrieve its value when complete"
msgstr ""
":class:`str` 객체를 이어붙이기를 한다면, 리스트를 만들고 마지막에 :meth:`str.join` 을 사용하거나 "
":class:`io.StringIO` 인스턴스에 쓰고 완료될 때 값을 꺼낼 수 있습니다"

#: ../Doc/library/stdtypes.rst:959
msgid ""
"if concatenating :class:`bytes` objects, you can similarly use "
":meth:`bytes.join` or :class:`io.BytesIO`, or you can do in-place "
"concatenation with a :class:`bytearray` object.  :class:`bytearray` "
"objects are mutable and have an efficient overallocation mechanism"
msgstr ""
":class:`bytes` 객체를 연결하는 경우 비슷하게 :meth:`bytes.join` 또는 :class:`io.BytesIO`"
" 를 사용하거나, :class:`bytearray` 객체를 사용하여 제자리에서 이어붙이기를 할 수 있습니다. "
":class:`bytearray` 객체는 가변이고 효율적인 과할당(overallocation) 메커니즘을 가지고 있습니다."

#: ../Doc/library/stdtypes.rst:964
msgid "if concatenating :class:`tuple` objects, extend a :class:`list` instead"
msgstr ":class:`tuple` 객체를 이어붙이기를 한다면, 대신 :class:`list`\\를 extend 하십시오."

#: ../Doc/library/stdtypes.rst:966
msgid "for other types, investigate the relevant class documentation"
msgstr "다른 형의 경우 관련 클래스 문서를 조사하십시오."

#: ../Doc/library/stdtypes.rst:970
msgid ""
"Some sequence types (such as :class:`range`) only support item sequences "
"that follow specific patterns, and hence don't support sequence "
"concatenation or repetition."
msgstr ""
"일부 시퀀스 형 (예를 들어 :class:`range`)은 특정 패턴을 따르는 항목 시퀀스 만 지원하기 때문에 시퀀스 이어붙이기나 "
"반복을 지원하지 않습니다."

#: ../Doc/library/stdtypes.rst:975
msgid ""
"``index`` raises :exc:`ValueError` when *x* is not found in *s*. Not all "
"implementations support passing the additional arguments *i* and *j*. "
"These arguments allow efficient searching of subsections of the sequence."
" Passing the extra arguments is roughly equivalent to using "
"``s[i:j].index(x)``, only without copying any data and with the returned "
"index being relative to the start of the sequence rather than the start "
"of the slice."
msgstr ""
"*s* 에 *x* 가 없을 때 ``index`` 는 :exc:`ValueError` 를 일으킵니다. 모든 구현이 추가 인자 *i* "
"및 *j* 전달을 지원하지는 않습니다. 이러한 인자를 사용하면 시퀀스의 부분을 효율적으로 검색할 수 있습니다. 추가 인자를 전달하는"
" 것은 대략 ``s[i:j].index(x)`` 를 사용하는 것과 비슷한데, 데이터를 복사하지 않고 반환된 인덱스가 슬라이스의 "
"시작이 아닌 시퀀스의 시작을 기준으로 삼습니다."

#: ../Doc/library/stdtypes.rst:986
msgid "Immutable Sequence Types"
msgstr "불변 시퀀스 형"

#: ../Doc/library/stdtypes.rst:993
msgid ""
"The only operation that immutable sequence types generally implement that"
" is not also implemented by mutable sequence types is support for the "
":func:`hash` built-in."
msgstr "불변 시퀀스 형이 일반적으로 구현하지만, 가변 시퀀스 형에서는 구현되지 않는 연산은 내장 :func:`hash` 에 대한 지원입니다."

#: ../Doc/library/stdtypes.rst:997
msgid ""
"This support allows immutable sequences, such as :class:`tuple` "
"instances, to be used as :class:`dict` keys and stored in :class:`set` "
"and :class:`frozenset` instances."
msgstr ""
"이 지원은 :class:`tuple` 인스턴스와 같은 불변 시퀀스를 :class:`dict` 키로 사용하고 :class:`set` "
"및 :class:`frozenset` 인스턴스에 저장할 수 있도록 합니다."

#: ../Doc/library/stdtypes.rst:1001
msgid ""
"Attempting to hash an immutable sequence that contains unhashable values "
"will result in :exc:`TypeError`."
msgstr "해시 불가능 값을 포함하는 불변 시퀀스를 해시 하려고 하면 :exc:`TypeError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:1008
msgid "Mutable Sequence Types"
msgstr "가변 시퀀스 형"

#: ../Doc/library/stdtypes.rst:1015
msgid ""
"The operations in the following table are defined on mutable sequence "
"types. The :class:`collections.abc.MutableSequence` ABC is provided to "
"make it easier to correctly implement these operations on custom sequence"
" types."
msgstr ""
"다음 표의 연산들은 가변 시퀀스 형에 정의되어 있습니다. 사용자 정의 시퀀스에서 이 연산들을 올바르게 구현하기 쉽게 하려고 "
":class:`collections.abc.MutableSequence` ABC가 제공됩니다."

#: ../Doc/library/stdtypes.rst:1019
msgid ""
"In the table *s* is an instance of a mutable sequence type, *t* is any "
"iterable object and *x* is an arbitrary object that meets any type and "
"value restrictions imposed by *s* (for example, :class:`bytearray` only "
"accepts integers that meet the value restriction ``0 <= x <= 255``)."
msgstr ""
"표에서 *s* 는 가변 시퀀스 형의 인스턴스이고, *t* 는 임의의 이터러블 객체이며, *x* 는 *s* 가 요구하는 형 및 값 "
"제한을 충족시키는 임의의 객체입니다 (예를 들어, :class:`bytearray` 는 값 제한 ``0 <= x <= 255`` 를"
" 만족하는 정수만 받아들입니다."

#: ../Doc/library/stdtypes.rst:1043
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../Doc/library/stdtypes.rst:1043
msgid "item *i* of *s* is replaced by *x*"
msgstr "*s* 의 항목 *i* 를 *x* 로 대체합니다"

#: ../Doc/library/stdtypes.rst:1046
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../Doc/library/stdtypes.rst:1046
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable "
"*t*"
msgstr "*i* 에서 *j* 까지의 *s* 슬라이스가 이터러블 *t* 의 내용으로 대체됩니다"

#: ../Doc/library/stdtypes.rst:1050
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../Doc/library/stdtypes.rst:1050
msgid "same as ``s[i:j] = []``"
msgstr "``s[i:j] = []`` 와 같습니다"

#: ../Doc/library/stdtypes.rst:1052
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../Doc/library/stdtypes.rst:1052
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "``s[i:j:k]`` 의 항목들이 *t* 의 항목들로 대체됩니다"

#: ../Doc/library/stdtypes.rst:1055
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../Doc/library/stdtypes.rst:1055
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "리스트에서 ``s[i:j:k]`` 의 항목들을 제거합니다"

#: ../Doc/library/stdtypes.rst:1058
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../Doc/library/stdtypes.rst:1058
msgid ""
"appends *x* to the end of the sequence (same as ``s[len(s):len(s)] = "
"[x]``)"
msgstr "시퀀스의 끝에 *x* 를 추가합니다 (``s[len(s):len(s)] = [x]`` 와 같습니다)"

#: ../Doc/library/stdtypes.rst:1062
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../Doc/library/stdtypes.rst:1062
msgid "removes all items from ``s`` (same as ``del s[:]``)"
msgstr "``s`` 에서 모든 항목을 제거합니다 (``del s[:]`` 와 같습니다)"

#: ../Doc/library/stdtypes.rst:1065
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../Doc/library/stdtypes.rst:1065
msgid "creates a shallow copy of ``s`` (same as ``s[:]``)"
msgstr "``s`` 의 얕은 복사본을 만듭니다 (``s[:]`` 와 같습니다)"

#: ../Doc/library/stdtypes.rst:1068
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` 또는 ``s += t``"

#: ../Doc/library/stdtypes.rst:1068
msgid ""
"extends *s* with the contents of *t* (for the most part the same as "
"``s[len(s):len(s)] = t``)"
msgstr "*t* 의 내용으로 *s* 를 확장합니다 (대부분 ``s[len(s):len(s)] = t`` 와 같습니다)"

#: ../Doc/library/stdtypes.rst:1073
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../Doc/library/stdtypes.rst:1073
msgid "updates *s* with its contents repeated *n* times"
msgstr "내용이 *n* 번 반복되도록 *s* 를 갱신합니다"

#: ../Doc/library/stdtypes.rst:1076
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../Doc/library/stdtypes.rst:1076
msgid "inserts *x* into *s* at the index given by *i* (same as ``s[i:i] = [x]``)"
msgstr "*x* 를 *s* 의 *i* 로 주어진 인덱스에 삽입합니다 (``s[i:i] = [x]`` 와 같습니다)"

#: ../Doc/library/stdtypes.rst:1080
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../Doc/library/stdtypes.rst:1080
msgid "retrieves the item at *i* and also removes it from *s*"
msgstr "*i* 에 있는 항목을 꺼냄과 동시에 *s* 에서 제거합니다"

#: ../Doc/library/stdtypes.rst:1083
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../Doc/library/stdtypes.rst:1083
#, fuzzy
msgid "remove the first item from *s* where ``s[i]`` is equal to *x*"
msgstr "``s[i] == x`` 가 되는 첫 번째 항목을 *s* 에서 제거합니다"

#: ../Doc/library/stdtypes.rst:1086
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../Doc/library/stdtypes.rst:1086
msgid "reverses the items of *s* in place"
msgstr "제자리에서 *s* 의 항목들의 순서를 뒤집습니다"

#: ../Doc/library/stdtypes.rst:1086 ../Doc/library/stdtypes.rst:2200
#: ../Doc/library/stdtypes.rst:2204 ../Doc/library/stdtypes.rst:3322
#: ../Doc/library/stdtypes.rst:3326
msgid "\\(4)"
msgstr "\\(4)"

#: ../Doc/library/stdtypes.rst:1094
msgid "*t* must have the same length as the slice it is replacing."
msgstr "*t* 는 교체할 슬라이스와 길이가 같아야 합니다."

#: ../Doc/library/stdtypes.rst:1097
msgid ""
"The optional argument *i* defaults to ``-1``, so that by default the last"
" item is removed and returned."
msgstr "선택적 인자 *i* 의 기본값은 ``-1`` 입니다. 그래서 기본적으로 마지막 항목이 제거되면서 반환됩니다."

#: ../Doc/library/stdtypes.rst:1101
msgid "``remove`` raises :exc:`ValueError` when *x* is not found in *s*."
msgstr "*x* 가 *s* 에서 발견되지 않으면 ``remove`` 는 :exc:`ValueError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:1104
msgid ""
"The :meth:`reverse` method modifies the sequence in place for economy of "
"space when reversing a large sequence.  To remind users that it operates "
"by side effect, it does not return the reversed sequence."
msgstr ""
"큰 시퀀스를 뒤집을 때 공간 절약을 위해 :meth:`reverse` 메서드는 제자리에서 시퀀스를 수정합니다. 부작용으로 작동한다는"
" 것을 사용자에게 상기시키기 위해 뒤집힌 시퀀스를 돌려주지 않습니다."

#: ../Doc/library/stdtypes.rst:1109
msgid ""
":meth:`clear` and :meth:`!copy` are included for consistency with the "
"interfaces of mutable containers that don't support slicing operations "
"(such as :class:`dict` and :class:`set`)"
msgstr ""
":meth:`clear`\\와 :meth:`!copy` 는 슬라이싱 연산을 지원하지 않는 (:class:`dict` 와 "
":class:`set` 같은) 가변 컨테이너들의 인터페이스와 일관성을 유지하기 위해 포함됩니다"

#: ../Doc/library/stdtypes.rst:1113
msgid ":meth:`clear` and :meth:`!copy` methods."
msgstr ":meth:`clear`\\와 :meth:`!copy` 메서드."

#: ../Doc/library/stdtypes.rst:1117
msgid ""
"The value *n* is an integer, or an object implementing "
":meth:`~object.__index__`.  Zero and negative values of *n* clear the "
"sequence.  Items in the sequence are not copied; they are referenced "
"multiple times, as explained for ``s * n`` under :ref:`typesseq-common`."
msgstr ""
"*n* 값은 정수이거나, :meth:`~object.__index__` 를 구현하는 객체입니다. *n* 이 0 이거나 음수면 "
"시퀀스를 지웁니다. 시퀀스의 항목들은 복사되지 않습니다; :ref:`typesseq-common`\\에서 ``s * n`` 를 위해"
" 설명한 것처럼 여러 번 참조됩니다."

#: ../Doc/library/stdtypes.rst:1126
msgid "Lists"
msgstr "리스트"

#: ../Doc/library/stdtypes.rst:1130
msgid ""
"Lists are mutable sequences, typically used to store collections of "
"homogeneous items (where the precise degree of similarity will vary by "
"application)."
msgstr ""
"리스트는 가변 시퀀스로, 일반적으로 등질 항목들의 모음을 저장하는 데 사용됩니다 (정확한 유사도는 응용 프로그램마다 다를 수 "
"있습니다)."

#: ../Doc/library/stdtypes.rst:1136
msgid "Lists may be constructed in several ways:"
msgstr "리스트는 여러 가지 방법으로 만들 수 있습니다:"

#: ../Doc/library/stdtypes.rst:1138
msgid "Using a pair of square brackets to denote the empty list: ``[]``"
msgstr "꺾쇠괄호를 사용하여 빈 리스트를 표시하기: ``[]``"

#: ../Doc/library/stdtypes.rst:1139
msgid ""
"Using square brackets, separating items with commas: ``[a]``, ``[a, b, "
"c]``"
msgstr "꺾쇠괄호를 사용하여 쉼표로 항목 구분하기: ``[a]``, ``[a, b, c]``"

#: ../Doc/library/stdtypes.rst:1140
msgid "Using a list comprehension: ``[x for x in iterable]``"
msgstr "리스트 컴프리헨션 사용하기: ``[x for x in iterable]``"

#: ../Doc/library/stdtypes.rst:1141
msgid "Using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "형 생성자를 사용하기: ``list()`` 또는 ``list(iterable)``"

#: ../Doc/library/stdtypes.rst:1143
msgid ""
"The constructor builds a list whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* "
"is already a list, a copy is made and returned, similar to "
"``iterable[:]``. For example, ``list('abc')`` returns ``['a', 'b', 'c']``"
" and ``list( (1, 2, 3) )`` returns ``[1, 2, 3]``. If no argument is "
"given, the constructor creates a new empty list, ``[]``."
msgstr ""
"생성자는 항목들과 그 순서가 *iterable* 과 같은 리스트를 만듭니다. *iterable* 은 시퀀스, 이터레이션을 지원하는 "
"컨테이너, 이터레이터 객체가 될 수 있습니다. *iterable* 이 이미 리스트라면, ``iterable[:]`` 과 비슷하게 "
"복사본을 만들어서 반환합니다. 예를 들어, ``list('abc')`` 는 ``['a', 'b', 'c']`` 를 반환하고 "
"``list( (1, 2, 3) )`` 는 ``[1, 2, 3]`` 를 반환합니다. 인자가 주어지지 않으면, 생성자는 새로운 빈 "
"리스트인 ``[]`` 을 만듭니다."

#: ../Doc/library/stdtypes.rst:1152
msgid ""
"Many other operations also produce lists, including the :func:`sorted` "
"built-in."
msgstr "다른 많은 연산도 리스트를 만드는데, 내장 :func:`sorted` 도 그런 것 중 하나다."

#: ../Doc/library/stdtypes.rst:1155
msgid ""
"Lists implement all of the :ref:`common <typesseq-common>` and "
":ref:`mutable <typesseq-mutable>` sequence operations. Lists also provide"
" the following additional method:"
msgstr ""
"리스트는 :ref:`공통 <typesseq-common>` 과 :ref:`가변 <typesseq-mutable>` 시퀀스 연산들을 "
"모두 구현합니다. 또한, 리스트는 다음과 같은 추가 메서드를 제공합니다:"

#: ../Doc/library/stdtypes.rst:1161
msgid ""
"This method sorts the list in place, using only ``<`` comparisons between"
" items. Exceptions are not suppressed - if any comparison operations "
"fail, the entire sort operation will fail (and the list will likely be "
"left in a partially modified state)."
msgstr ""
"이 메서드는 항목 간의 ``<`` 비교만 사용하여 리스트를 제자리에서 정렬합니다. 예외는 억제되지 않습니다 - 비교 연산이 실패하면"
" 전체 정렬 연산이 실패합니다 (리스트는 부분적으로 수정된 상태로 남아있게 됩니다)."

#: ../Doc/library/stdtypes.rst:1166
msgid ""
":meth:`sort` accepts two arguments that can only be passed by keyword "
"(:ref:`keyword-only arguments <keyword-only_parameter>`):"
msgstr ""
":meth:`sort` 는 키워드로만 전달할 수 있는 두 개의 인자를 받아들입니다 (:ref:`키워드-전용 인자 <keyword-"
"only_parameter>`):"

#: ../Doc/library/stdtypes.rst:1169
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element (for example, ``key=str.lower``). "
"The key corresponding to each item in the list is calculated once and "
"then used for the entire sorting process. The default value of ``None`` "
"means that list items are sorted directly without calculating a separate "
"key value."
msgstr ""
"*key* 는 인자 하나를 받아들이는 함수를 지정하는데, 각 리스트 요소에서 비교 키를 추출하는 데 사용됩니다 (예들 들어, "
"``key=str.lower``). 리스트의 각 항목에 해당하는 키는 한 번만 계산된 후 전체 정렬 프로세스에 사용됩니다. 기본값 "
"``None`` 은 리스트 항목들이 별도의 키값을 계산하지 않고 직접 정렬된다는 것을 의미합니다."

#: ../Doc/library/stdtypes.rst:1176
msgid ""
"The :func:`functools.cmp_to_key` utility is available to convert a 2.x "
"style *cmp* function to a *key* function."
msgstr ""
":func:`functools.cmp_to_key` 유틸리티는 2.x 스타일 *cmp* 함수를 *key* 함수로 변환하는 데 사용할"
" 수 있습니다."

#: ../Doc/library/stdtypes.rst:1179
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements"
" are sorted as if each comparison were reversed."
msgstr "*reverse* 는 논리값입니다. ``True`` 로 설정되면, 각 비교가 역전된 것처럼 리스트 요소들이 정렬됩니다."

#: ../Doc/library/stdtypes.rst:1182
msgid ""
"This method modifies the sequence in place for economy of space when "
"sorting a large sequence.  To remind users that it operates by side "
"effect, it does not return the sorted sequence (use :func:`sorted` to "
"explicitly request a new sorted list instance)."
msgstr ""
"이 메서드는 큰 시퀀스를 정렬할 때 공간 절약을 위해 시퀀스를 제자리에서 수정합니다. 부작용으로 작동한다는 것을 사용자에게 "
"상기시키기 위해 정렬된 시퀀스를 돌려주지 않습니다 (새 정렬 된 리스트 인스턴스를 명시적으로 요청하려면 "
":func:`sorted`\\를 사용하십시오)."

#: ../Doc/library/stdtypes.rst:1187
msgid ""
"The :meth:`sort` method is guaranteed to be stable.  A sort is stable if "
"it guarantees not to change the relative order of elements that compare "
"equal --- this is helpful for sorting in multiple passes (for example, "
"sort by department, then by salary grade)."
msgstr ""
":meth:`sort` 메서드는 안정적임이 보장됩니다. 정렬은 같다고 비교되는 요소들의 상대적 순서를 변경하지 않으면 안정적입니다 "
"--- 이는 여러 번 정렬하는 데 유용합니다 (예를 들어, 부서별로 정렬한 후에 급여 등급으로 정렬)."

#: ../Doc/library/stdtypes.rst:1194
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even"
" inspect, the list is undefined.  The C implementation of Python makes "
"the list appear empty for the duration, and raises :exc:`ValueError` if "
"it can detect that the list has been mutated during a sort."
msgstr ""
"리스트가 정렬되는 동안, 리스트를 변경하려고 할 때의, 또는 관찰하려고 할 때조차, 효과는 정의되지 않습니다. 파이썬의 C 구현은 "
"그동안 리스트를 비어있는 것으로 보이게 하고, 정렬 중에 리스트가 변경되었음을 감지할 수 있다면 :exc:`ValueError` 를"
" 일으킵니다."

#: ../Doc/library/stdtypes.rst:1203
msgid "Tuples"
msgstr "튜플"

#: ../Doc/library/stdtypes.rst:1207
msgid ""
"Tuples are immutable sequences, typically used to store collections of "
"heterogeneous data (such as the 2-tuples produced by the "
":func:`enumerate` built-in). Tuples are also used for cases where an "
"immutable sequence of homogeneous data is needed (such as allowing "
"storage in a :class:`set` or :class:`dict` instance)."
msgstr ""
"튜플은 불변 시퀀스인데, 보통 이질적인 데이터의 모음을 저장하는 데 사용됩니다 (예를 들어, 내장 :func:`enumerate` "
"가 만드는 2-튜플). 튜플은 등질적인 데이터의 불변 시퀀스가 필요한 경우에도 사용됩니다 (예를 들어, :class:`set` 이나"
" :class:`dict` 인스턴스에 저장하고자 하는 경우)."

#: ../Doc/library/stdtypes.rst:1215
msgid "Tuples may be constructed in a number of ways:"
msgstr "튜플은 여러 가지 방법으로 만들 수 있습니다:"

#: ../Doc/library/stdtypes.rst:1217
msgid "Using a pair of parentheses to denote the empty tuple: ``()``"
msgstr "괄호를 사용하여 빈 튜플을 나타내기: ``()``"

#: ../Doc/library/stdtypes.rst:1218
msgid "Using a trailing comma for a singleton tuple: ``a,`` or ``(a,)``"
msgstr "단일 항목 튜플을 위해 끝에 쉼표를 붙이기: ``a,`` 또는 ``(a,)``"

#: ../Doc/library/stdtypes.rst:1219
msgid "Separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "항목을 쉼표로 구분하기: ``a, b, c`` 또는``(a, b, c)``"

#: ../Doc/library/stdtypes.rst:1220
msgid "Using the :func:`tuple` built-in: ``tuple()`` or ``tuple(iterable)``"
msgstr "내장 :func:`tuple` 사용하기: ``tuple()`` 또는 ``tuple(iterable)``"

#: ../Doc/library/stdtypes.rst:1222
msgid ""
"The constructor builds a tuple whose items are the same and in the same "
"order as *iterable*'s items.  *iterable* may be either a sequence, a "
"container that supports iteration, or an iterator object.  If *iterable* "
"is already a tuple, it is returned unchanged. For example, "
"``tuple('abc')`` returns ``('a', 'b', 'c')`` and ``tuple( [1, 2, 3] )`` "
"returns ``(1, 2, 3)``. If no argument is given, the constructor creates a"
" new empty tuple, ``()``."
msgstr ""
"생성자는 항목들과 그 순서가 *iterable* 과 같은 튜플을 만듭니다. *iterable* 은 시퀀스, 이터레이션을 지원하는 "
"컨테이너, 이터레이터 객체가 될 수 있습니다. *iterable* 이 이미 튜플이라면 변경되지 않은 상태로 반환됩니다. 예를 들어 "
"``tuple('abc')`` 는 ``('a', 'b', 'c')`` 를 반환하고, ``tuple( [1, 2, 3] )`` 는 "
"``(1, 2, 3)`` 을 반환합니다. 인자가 주어지지 않으면, 생성자는 새로운 빈 튜플인 ``()`` 을 만듭니다."

#: ../Doc/library/stdtypes.rst:1230
msgid ""
"Note that it is actually the comma which makes a tuple, not the "
"parentheses. The parentheses are optional, except in the empty tuple "
"case, or when they are needed to avoid syntactic ambiguity. For example, "
"``f(a, b, c)`` is a function call with three arguments, while ``f((a, b, "
"c))`` is a function call with a 3-tuple as the sole argument."
msgstr ""
"튜플을 만드는 것은 실제로는 괄호가 아닌 쉼표임에 유의하십시오. 괄호는 빈 튜플의 경우를 제외하고는 선택적이거나 문법상의 모호함을 "
"피하고자 필요합니다. 예를 들어, ``f(a, b, c)`` 는 3개의 인자를 가진 함수 호출이지만, ``f((a, b, c))``"
" 는 하나의 인자로 3-튜플을 갖는 함수 호출입니다."

#: ../Doc/library/stdtypes.rst:1236
msgid ""
"Tuples implement all of the :ref:`common <typesseq-common>` sequence "
"operations."
msgstr "튜플은 :ref:`공통 <typesseq-common>` 시퀀스 연산을 모두 구현합니다."

#: ../Doc/library/stdtypes.rst:1239
msgid ""
"For heterogeneous collections of data where access by name is clearer "
"than access by index, :func:`collections.namedtuple` may be a more "
"appropriate choice than a simple tuple object."
msgstr ""
"이름에 의한 액세스가 인덱스에 의한 액세스보다 더 명확한 이질적 데이터 컬렉션의 경우, "
":func:`collections.namedtuple` 이 단순한 튜플 객체보다 더 적절한 선택일 수 있습니다."

#: ../Doc/library/stdtypes.rst:1247
msgid "Ranges"
msgstr "범위"

#: ../Doc/library/stdtypes.rst:1251
msgid ""
"The :class:`range` type represents an immutable sequence of numbers and "
"is commonly used for looping a specific number of times in :keyword:`for`"
" loops."
msgstr ""
":class:`range` 형은 숫자의 불변 시퀀스를 나타내며 :keyword:`for` 루프에서 특정 횟수만큼 반복하는 데 흔히 "
"사용됩니다."

#: ../Doc/library/stdtypes.rst:1258
msgid ""
"The arguments to the range constructor must be integers (either built-in "
":class:`int` or any object that implements the ``__index__`` special "
"method).  If the *step* argument is omitted, it defaults to ``1``. If the"
" *start* argument is omitted, it defaults to ``0``. If *step* is zero, "
":exc:`ValueError` is raised."
msgstr ""
"범위 생성자에 대해 인자는 정수여야 합니다 (내장 :class:`int` 또는 ``__index__`` 특수 메서드를 구현하는 "
"임의의 객체). *step* 인자가 생략되면 기본값 ``1`` 이 사용됩니다. *start* 인자가 생략되면 기본값 ``0`` 이 "
"사용됩니다. *step* 이 0이면 :exc:`ValueError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:1264
msgid ""
"For a positive *step*, the contents of a range ``r`` are determined by "
"the formula ``r[i] = start + step*i`` where ``i >= 0`` and ``r[i] < "
"stop``."
msgstr ""
"양수 *step* 의 경우, 범위 ``r`` 의 내용은 식 ``r[i] = start + step*i`` 에 의해 결정됩니다. 이때"
" ``i >= 0`` 이고 ``r[i] < stop`` 입니다."

#: ../Doc/library/stdtypes.rst:1268
msgid ""
"For a negative *step*, the contents of the range are still determined by "
"the formula ``r[i] = start + step*i``, but the constraints are ``i >= 0``"
" and ``r[i] > stop``."
msgstr ""
"음수 *step* 의 경우, 범위의 내용은 여전히 식 ``r[i] = start + step*i`` 에 의해 결정되지만, 제약 "
"조건은 ``i >= 0`` 과 ``r[i] > stop`` 이 됩니다."

#: ../Doc/library/stdtypes.rst:1272
msgid ""
"A range object will be empty if ``r[0]`` does not meet the value "
"constraint. Ranges do support negative indices, but these are interpreted"
" as indexing from the end of the sequence determined by the positive "
"indices."
msgstr ""
"``r[0]`` 제약 조건을 만족시키지 않으면 범위 객체는 비게 됩니다. 범위는 음의 인덱스를 지원하지만, 이는 시퀀스의 끝에서부터"
" 양의 인덱스만큼 떨어진 인덱스로 해석됩니다."

#: ../Doc/library/stdtypes.rst:1277
msgid ""
"Ranges containing absolute values larger than :data:`sys.maxsize` are "
"permitted but some features (such as :func:`len`) may raise "
":exc:`OverflowError`."
msgstr ""
":data:`sys.maxsize` 보다 큰 절댓값을 포함하는 범위는 허용되지만, (:func:`len` 과 같은) 일부 기능은 "
":exc:`OverflowError` 를 발생시킬 수 있습니다."

#: ../Doc/library/stdtypes.rst:1281
msgid "Range examples::"
msgstr "범위 예제::"

#: ../Doc/library/stdtypes.rst:1298
msgid ""
"Ranges implement all of the :ref:`common <typesseq-common>` sequence "
"operations except concatenation and repetition (due to the fact that "
"range objects can only represent sequences that follow a strict pattern "
"and repetition and concatenation will usually violate that pattern)."
msgstr ""
"범위는 이어 붙이기와 반복을 제외한 :ref:`공통 <typesseq-common>` 시퀀스 연산을 모두 구현합니다 (범위 객체는 "
"엄격한 패턴을 따르는 시퀀스 만 나타낼 수 있는데 반복과 이어 붙이기는 보통 그 패턴을 위반한다는 사실에 기인합니다)."

#: ../Doc/library/stdtypes.rst:1305
msgid ""
"The value of the *start* parameter (or ``0`` if the parameter was not "
"supplied)"
msgstr "*start* 파라미터의 값 (또는 파라미터가 제공되지 않으면 ``0``)"

#: ../Doc/library/stdtypes.rst:1310
msgid "The value of the *stop* parameter"
msgstr "*stop* 파라미터의 값"

#: ../Doc/library/stdtypes.rst:1314
msgid ""
"The value of the *step* parameter (or ``1`` if the parameter was not "
"supplied)"
msgstr "*step* 파라미터의 값 (또는 파라미터가 제공되지 않으면 ``1``)"

#: ../Doc/library/stdtypes.rst:1317
msgid ""
"The advantage of the :class:`range` type over a regular :class:`list` or "
":class:`tuple` is that a :class:`range` object will always take the same "
"(small) amount of memory, no matter the size of the range it represents "
"(as it only stores the ``start``, ``stop`` and ``step`` values, "
"calculating individual items and subranges as needed)."
msgstr ""
"정규 :class:`list` 나 :class:`tuple` 에 비해 :class:`range` 형의 장점은 "
":class:`range` 객체는 표현하는 범위의 크기에 무관하게 항상 같은 (작은) 양의 메모리를 사용한다는 것입니다 "
"(``start``, ``stop``, ``step`` 값만을 저장하고, 필요에 따라 개별 항목과 하위 범위를 계산하기 "
"때문입니다)."

#: ../Doc/library/stdtypes.rst:1323
msgid ""
"Range objects implement the :class:`collections.abc.Sequence` ABC, and "
"provide features such as containment tests, element index lookup, slicing"
" and support for negative indices (see :ref:`typesseq`):"
msgstr ""
"범위 객체는 :class:`collections.abc.Sequence` ABC를 구현하고, 포함 검사, 요소 인덱스 검색, "
"슬라이싱, 음수 인덱스 지원과 같은 기능을 제공합니다 (:ref:`typesseq` 를 보세요):"

#: ../Doc/library/stdtypes.rst:1343
msgid ""
"Testing range objects for equality with ``==`` and ``!=`` compares them "
"as sequences.  That is, two range objects are considered equal if they "
"represent the same sequence of values.  (Note that two range objects that"
" compare equal might have different :attr:`~range.start`, "
":attr:`~range.stop` and :attr:`~range.step` attributes, for example "
"``range(0) == range(2, 1, 3)`` or ``range(0, 3, 2) == range(0, 4, 2)``.)"
msgstr ""
"``==`` 나 ``!=`` 로 범위 객체가 같은지 검사하면 시퀀스처럼 비교합니다. 즉, 두 범위 객체가 같은 시퀀스의 값을 나타낼"
" 때 같다고 취급됩니다. (같다고 비교되는 두 개의 범위 객체가 서로 다른 :attr:`~range.start`, "
":attr:`~range.stop`, :attr:`~range.step` 어트리뷰트를 가질 수 있음에 주의하세요. 예를 들어, "
"``range(0) == range(2, 1, 3)`` 또는 ``range(0, 3, 2) == range(0, 4, 2)``.)"

#: ../Doc/library/stdtypes.rst:1350
msgid ""
"Implement the Sequence ABC. Support slicing and negative indices. Test "
":class:`int` objects for membership in constant time instead of iterating"
" through all items."
msgstr "시퀀스 ABC를 구현합니다. :class:`int` 객체의 포함 검사는 모든 항목을 이터레이트하는 대신 상수 시간으로 수행됩니다."

#: ../Doc/library/stdtypes.rst:1356
msgid ""
"Define '==' and '!=' to compare range objects based on the sequence of "
"values they define (instead of comparing based on object identity)."
msgstr ""
"(객체 아이덴티티에 기반을 두는 대신) 범위 객체가 정의하는 값들의 시퀀스에 기반을 둔 비교를 위해 '==' 와 '!=' 를 "
"정의합니다."

#: ../Doc/library/stdtypes.rst:1361
msgid ""
"The :attr:`~range.start`, :attr:`~range.stop` and :attr:`~range.step` "
"attributes."
msgstr ":attr:`~range.start`, :attr:`~range.stop`, :attr:`~range.step` 어트리뷰트."

#: ../Doc/library/stdtypes.rst:1367
msgid ""
"The `linspace recipe <http://code.activestate.com/recipes/579000/>`_ "
"shows how to implement a lazy version of range that suitable for floating"
" point applications."
msgstr ""
"`linspace recipe <http://code.activestate.com/recipes/579000/>`_ 에서는 부동 "
"소수점 응용 프로그램에 적합한 범위의 지연된 버전을 구현하는 방법을 보여줍니다."

#: ../Doc/library/stdtypes.rst:1379
msgid "Text Sequence Type --- :class:`str`"
msgstr "텍스트 시퀀스 형 --- :class:`str`"

#: ../Doc/library/stdtypes.rst:1381
msgid ""
"Textual data in Python is handled with :class:`str` objects, or "
":dfn:`strings`. Strings are immutable :ref:`sequences <typesseq>` of "
"Unicode code points.  String literals are written in a variety of ways:"
msgstr ""
"파이썬의 텍스트 데이터는 :class:`str`, 또는 :dfn:`문자열 (strings)`, 객체를 사용하여 처리됩니다. 문자열은"
" 유니코드 코드 포인트의 불변 :ref:`시퀀스 <typesseq>` 입니다. 문자열 리터럴은 다양한 방법으로 작성됩니다:"

#: ../Doc/library/stdtypes.rst:1386
msgid "Single quotes: ``'allows embedded \"double\" quotes'``"
msgstr "작은따옴표: ``'\"큰\" 따옴표를 담을 수 있습니다'``"

#: ../Doc/library/stdtypes.rst:1387
msgid "Double quotes: ``\"allows embedded 'single' quotes\"``."
msgstr "큰따옴표: ``\"'작은' 따옴표를 담을 수 있습니다\"``."

#: ../Doc/library/stdtypes.rst:1388
msgid ""
"Triple quoted: ``'''Three single quotes'''``, ``\"\"\"Three double "
"quotes\"\"\"``"
msgstr "삼중 따옴표: ``'''세 개의 작은따옴표'''``, ``\"\"\"세 개의 큰따옴표\"\"\"``"

#: ../Doc/library/stdtypes.rst:1390
msgid ""
"Triple quoted strings may span multiple lines - all associated whitespace"
" will be included in the string literal."
msgstr "삼중 따옴표로 묶인 문자열은 여러 줄에 걸쳐있을 수 있습니다 - 연관된 모든 공백이 문자열 리터럴에 포함됩니다."

#: ../Doc/library/stdtypes.rst:1393
msgid ""
"String literals that are part of a single expression and have only "
"whitespace between them will be implicitly converted to a single string "
"literal. That is, ``(\"spam \" \"eggs\") == \"spam eggs\"``."
msgstr ""
"단일 표현식의 일부이고 그 들 사이에 공백만 있는 문자열 리터럴은 묵시적으로 단일 문자열 리터럴로 변환됩니다. 즉, "
"``(\"spam \" \"eggs\") == \"spam eggs\"``."

#: ../Doc/library/stdtypes.rst:1397
msgid ""
"See :ref:`strings` for more about the various forms of string literal, "
"including supported escape sequences, and the ``r`` (\"raw\") prefix that"
" disables most escape sequence processing."
msgstr ""
"지원되는 이스케이프 시퀀스와 대부분의 이스케이프 시퀀스 처리를 비활성화하는 ``r`` (\"날\") 접두어를 포함하여 문자열 "
"리터럴의 다양한 형식에 대한 자세한 내용은 :ref:`strings` 을 참조하십시오."

#: ../Doc/library/stdtypes.rst:1401
msgid ""
"Strings may also be created from other objects using the :class:`str` "
"constructor."
msgstr "문자열은 :class:`str` 생성자를 사용하여 다른 객체로부터 만들어질 수도 있습니다."

#: ../Doc/library/stdtypes.rst:1404
msgid ""
"Since there is no separate \"character\" type, indexing a string produces"
" strings of length 1. That is, for a non-empty string *s*, ``s[0] == "
"s[0:1]``."
msgstr ""
"별도의 \"문자\" 형이 없으므로 문자열을 인덱싱하면 길이가 1인 문자열이 생성됩니다. 즉, 비어 있지 않은 문자열 *s* 의 "
"경우, ``s[0] == s[0:1]`` 입니다."

#: ../Doc/library/stdtypes.rst:1410
msgid ""
"There is also no mutable string type, but :meth:`str.join` or "
":class:`io.StringIO` can be used to efficiently construct strings from "
"multiple fragments."
msgstr ""
"또한, 가변 문자열형은 없지만, 여러 단편으로부터 문자열을 효율적으로 구성하는데 :meth:`str.join` 또는 "
":class:`io.StringIO` 를 사용할 수 있습니다."

#: ../Doc/library/stdtypes.rst:1414
msgid ""
"For backwards compatibility with the Python 2 series, the ``u`` prefix is"
" once again permitted on string literals. It has no effect on the meaning"
" of string literals and cannot be combined with the ``r`` prefix."
msgstr ""
"파이썬 2시리즈와의 하위 호환성을 위해서, ``u`` 접두어가 문자열 리터럴에 다시 한번 허용됩니다. 문자열 리터럴의 의미에 영향을"
" 미치지 않으며 ``r`` 접두사와 결합 될 수 없습니다."

#: ../Doc/library/stdtypes.rst:1426
msgid ""
"Return a :ref:`string <textseq>` version of *object*.  If *object* is not"
" provided, returns the empty string.  Otherwise, the behavior of "
"``str()`` depends on whether *encoding* or *errors* is given, as follows."
msgstr ""
"*object* 의 :ref:`문자열 <textseq>` 버전을 돌려줍니다. *object* 가 제공되지 않으면, 빈 문자열을 "
"돌려줍니다. 그렇지 않으면, ``str()`` 의 동작은 *encoding* 또는 *errors* 가 주어졌는지에 따라 달라지는데,"
" 다음과 같습니다."

#: ../Doc/library/stdtypes.rst:1430
msgid ""
"If neither *encoding* nor *errors* is given, ``str(object)`` returns "
":meth:`object.__str__() <object.__str__>`, which is the \"informal\" or "
"nicely printable string representation of *object*.  For string objects, "
"this is the string itself.  If *object* does not have a "
":meth:`~object.__str__` method, then :func:`str` falls back to returning "
":meth:`repr(object) <repr>`."
msgstr ""
"*encoding* 과 *errors* 모두 주어지지 않으면, ``str(object)`` 는 "
":meth:`object.__str__() <object.__str__>` 를 돌려주는데, *object* 의 \"비형식적\" 또는"
" 멋지게 인쇄 가능한 문자열 표현입니다. 문자열 객체의 경우, 이것은 문자열 자신입니다. 만약 *object* 가 "
":meth:`~object.__str__` 메서드를 가지고 있지 않다면, :func:`str`\\은 대신 "
":meth:`repr(object) <repr>` 를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1441
msgid ""
"If at least one of *encoding* or *errors* is given, *object* should be a "
":term:`bytes-like object` (e.g. :class:`bytes` or :class:`bytearray`).  "
"In this case, if *object* is a :class:`bytes` (or :class:`bytearray`) "
"object, then ``str(bytes, encoding, errors)`` is equivalent to "
":meth:`bytes.decode(encoding, errors) <bytes.decode>`.  Otherwise, the "
"bytes object underlying the buffer object is obtained before calling "
":meth:`bytes.decode`.  See :ref:`binaryseq` and :ref:`bufferobjects` for "
"information on buffer objects."
msgstr ""
"*encoding* 또는 *errors* 중 적어도 하나가 주어지면, *object* 는 :term:`bytes-like "
"object` (예, :class:`bytes` 또는 :class:`bytearray`) 이어야 합니다. 이 경우, *object*"
" 가 :class:`bytes` (또는 :class:`bytearray`) 객체이면, ``str(bytes, encoding, "
"errors)`` 는 :meth:`bytes.decode(encoding, errors) <bytes.decode>` 와 "
"동등합니다. 그 이외의 경우, :meth:`bytes.decode` 호출 전에 버퍼 객체의 하부 바이트열 객체를 얻습니다. 버퍼 "
"객체에 대한 정보는 :ref:`binaryseq`\\와 :ref:`bufferobjects` 를 보십시오."

#: ../Doc/library/stdtypes.rst:1450
msgid ""
"Passing a :class:`bytes` object to :func:`str` without the *encoding* or "
"*errors* arguments falls under the first case of returning the informal "
"string representation (see also the :option:`-b` command-line option to "
"Python).  For example::"
msgstr ""
"*encoding* 또는 *errors* 인자 없이 :class:`bytes` 객체를 :func:`str` 에 전달하는 것은 "
"비형식적 문자열 표현을 반환하는 첫 번째 상황에 해당합니다 (파이썬 명령행 옵션 :option:`-b` 도 보십시오). 예를 "
"들면::"

#: ../Doc/library/stdtypes.rst:1458
msgid ""
"For more information on the ``str`` class and its methods, see "
":ref:`textseq` and the :ref:`string-methods` section below.  To output "
"formatted strings, see the :ref:`f-strings` and :ref:`formatstrings` "
"sections.  In addition, see the :ref:`stringservices` section."
msgstr ""
"``str`` 클래스와 그 메서드에 대한 더 자세한 정보는 :ref:`textseq`\\와 아래의 :ref:`string-"
"methods` 섹션을 보십시오. 포맷된 문자열을 출력하려면 :ref:`f-strings` 및 :ref:`formatstrings`"
" 섹션을 참조하십시오. 또한, :ref:`stringservices` 섹션을 보십시오."

#: ../Doc/library/stdtypes.rst:1470
msgid "String Methods"
msgstr "문자열 메서드"

#: ../Doc/library/stdtypes.rst:1475
msgid ""
"Strings implement all of the :ref:`common <typesseq-common>` sequence "
"operations, along with the additional methods described below."
msgstr ""
"문자열은 :ref:`공통 <typesseq-common>` 시퀀스 연산들을 모두 구현하고, 아래에 기술된 추가적인 메서드도 "
"구현합니다."

#: ../Doc/library/stdtypes.rst:1478
msgid ""
"Strings also support two styles of string formatting, one providing a "
"large degree of flexibility and customization (see :meth:`str.format`, "
":ref:`formatstrings` and :ref:`string-formatting`) and the other based on"
" C ``printf`` style formatting that handles a narrower range of types and"
" is slightly harder to use correctly, but is often faster for the cases "
"it can handle (:ref:`old-string-formatting`)."
msgstr ""
"문자열은 또한 두 가지 스타일의 문자열 포매팅을 지원합니다. 하나는 큰 폭의 유연성과 사용자 지정을 제공하고 (참조 "
":meth:`str.format`, :ref:`formatstrings`, :ref:`string-formatting`\\을 "
"참조하세요) 다른 하나는 C ``printf`` 스타일에 기반을 두는데, 더 좁은 범위의 형을 처리하고 올바르게 사용하기는 다소 "
"어렵지만, 처리할 수 있는 경우에는 종종 더 빠릅니다 (:ref:`old-string-formatting`)."

#: ../Doc/library/stdtypes.rst:1485
msgid ""
"The :ref:`textservices` section of the standard library covers a number "
"of other modules that provide various text related utilities (including "
"regular expression support in the :mod:`re` module)."
msgstr ""
"표준 라이브러리의 :ref:`textservices` 섹션은 다양한 텍스트 관련 유틸리티를 (:mod:`re` 모듈의 정규식 지원을"
" 포함합니다) 제공하는 많은 다른 모듈들을 다룹니다."

#: ../Doc/library/stdtypes.rst:1491
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr "첫 문자가 대문자이고 나머지가 소문자인 문자열의 복사본을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1497
msgid ""
"Return a casefolded copy of the string. Casefolded strings may be used "
"for caseless matching."
msgstr "케이스 폴딩 된 문자열을 반환합니다. 케이스 폴딩 된 문자열은 대소문자를 무시한 매칭에 사용될 수 있습니다."

#: ../Doc/library/stdtypes.rst:1500
msgid ""
"Casefolding is similar to lowercasing but more aggressive because it is "
"intended to remove all case distinctions in a string. For example, the "
"German lowercase letter ``'ß'`` is equivalent to ``\"ss\"``. Since it is "
"already lowercase, :meth:`lower` would do nothing to ``'ß'``; "
":meth:`casefold` converts it to ``\"ss\"``."
msgstr ""
"케이스 폴딩은 소문자로 변환하는 것과 비슷하지만 문자열의 모든 케이스 구분을 제거하기 때문에 보다 공격적입니다. 예를 들어, 독일어"
" 소문자 ``'ß'`` 는 ``\"ss\"`` 와 동등합니다. 이미 소문자이므로 :meth:`lower` 는 ``'ß'`` 에 "
"아무런 영향을 미치지 않습니다; :meth:`casefold` 는 ``\"ss\"`` 로 변환합니다."

#: ../Doc/library/stdtypes.rst:1506
msgid ""
"The casefolding algorithm is described in section 3.13 of the Unicode "
"Standard."
msgstr "케이스 폴딩 알고리즘은 유니코드 표준의 섹션 3.13 에 설명되어 있습니다."

#: ../Doc/library/stdtypes.rst:1514
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is an ASCII space). The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"길이 *width* 인 문자열의 가운데에 정렬한 값을 돌려줍니다. 지정된 *fillchar* (기본값은 ASCII 스페이스)을 "
"사용하여 채웁니다. *width* 가 ``len(s)`` 보다 작거나 같은 경우 원래 문자열이 반환됩니다."

#: ../Doc/library/stdtypes.rst:1522
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in "
"the range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"범위 [*start*, *end*] 에서 서브 스트링 *sub* 가 중첩되지 않고 등장하는 횟수를 돌려줍니다. 선택적 인자 "
"*start* 와 *end* 는 슬라이스 표기법으로 해석됩니다."

#: ../Doc/library/stdtypes.rst:1529
msgid ""
"Return an encoded version of the string as a bytes object. Default "
"encoding is ``'utf-8'``. *errors* may be given to set a different error "
"handling scheme. The default for *errors* is ``'strict'``, meaning that "
"encoding errors raise a :exc:`UnicodeError`. Other possible values are "
"``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, "
"``'backslashreplace'`` and any other name registered via "
":func:`codecs.register_error`, see section :ref:`error-handlers`. For a "
"list of possible encodings, see section :ref:`standard-encodings`."
msgstr ""
"문자열의 바이트열 객체로 인코딩된 버전을 돌려줍니다. 기본 인코딩은 ``'utf-8'`` 입니다. *errors* 는 다른 오류 "
"처리 방식을 설정하기 위해 제공될 수 있습니다. *errors* 의 기본값은 ``'strict'`` 인데, 인코딩 오류가 있으면 "
":exc:`UnicodeError` 를 일으키라는 뜻입니다. 다른 가능한 값은 ``'ignore'``, ``'replace'``, "
"``'xmlcharrefreplace'``, ``'backslashreplace'`` 와 "
":func:`codecs.register_error` 를 통해 등록된 다른 이름들입니다. :ref:`error-"
"handlers`\\를 보세요. 가능한 인코딩의 목록을 보려면 :ref:`standard-encodings` 섹션을 참조하십시오."

#: ../Doc/library/stdtypes.rst:1538
msgid "Support for keyword arguments added."
msgstr "키워드 인자 지원이 추가되었습니다."

#: ../Doc/library/stdtypes.rst:1544
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise"
" return ``False``.  *suffix* can also be a tuple of suffixes to look for."
"  With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"문자열이 지정된 *suffix* 로 끝나면 ``True`` 를 돌려주고, 그렇지 않으면 ``False`` 를 돌려줍니다. "
"*suffix* 는 찾고자 하는 접미사들의 튜플이 될 수도 있습니다. 선택적 *start* 가 제공되면 그 위치에서 검사를 "
"시작합니다. 선택적 *end* 를 사용하면 해당 위치에서 비교를 중단합니다."

#: ../Doc/library/stdtypes.rst:1552
msgid ""
"Return a copy of the string where all tab characters are replaced by one "
"or more spaces, depending on the current column and the given tab size.  "
"Tab positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the "
"current column is set to zero and the string is examined character by "
"character.  If the character is a tab (``\\t``), one or more space "
"characters are inserted in the result until the current column is equal "
"to the next tab position. (The tab character itself is not copied.)  If "
"the character is a newline (``\\n``) or return (``\\r``), it is copied "
"and the current column is reset to zero.  Any other character is copied "
"unchanged and the current column is incremented by one regardless of how "
"the character is represented when printed."
msgstr ""
"모든 탭 문자들을 현재의 열과 주어진 탭 크기에 따라 하나나 그 이상의 스페이스로 치환한 문자열의 복사본을 돌려줍니다. 탭 위치는 "
"*tabsize* 문자마다 발생합니다 (기본값은 8이고, 열 0, 8, 16 등에 탭 위치를 지정합니다). 문자열을 확장하기 위해 "
"현재 열이 0으로 설정되고 문자열을 문자 단위로 검사합니다. 문자가 탭 (``\\t``) 이면, 현재 열이 다음 탭 위치와 같아질 "
"때까지 하나 이상의 스페이스 문자가 삽입됩니다. (탭 문자 자체는 복사되지 않습니다.) 문자가 개행 문자 (``\\n``) 또는 "
"캐리지 리턴 (``\\r``) 이면 복사되고 현재 열은 0으로 재설정됩니다. 다른 문자는 변경되지 않고 복사되고 현재 열은 인쇄할 "
"때 문자가 어떻게 표시되는지에 관계없이 1씩 증가합니다."

#: ../Doc/library/stdtypes.rst:1573
msgid ""
"Return the lowest index in the string where substring *sub* is found "
"within the slice ``s[start:end]``.  Optional arguments *start* and *end* "
"are interpreted as in slice notation.  Return ``-1`` if *sub* is not "
"found."
msgstr ""
"서브 스트링 *sub* 가 슬라이스 ``s[start:end]`` 내에 등장하는 가장 작은 문자열의 인덱스를 돌려줍니다. 선택적 "
"인자 *start* 와 *end* 는 슬라이스 표기법으로 해석됩니다. *sub* 가 없으면 ``-1`` 을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1579
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""
":meth:`~str.find` 메서드는 *sub* 의 위치를 ​​알아야 할 경우에만 사용해야 합니다. *sub* 가 서브 "
"스트링인지 확인하려면 :keyword:`in` 연산자를 사용하십시오::"

#: ../Doc/library/stdtypes.rst:1589
msgid ""
"Perform a string formatting operation.  The string on which this method "
"is called can contain literal text or replacement fields delimited by "
"braces ``{}``.  Each replacement field contains either the numeric index "
"of a positional argument, or the name of a keyword argument.  Returns a "
"copy of the string where each replacement field is replaced with the "
"string value of the corresponding argument."
msgstr ""
"문자열 포맷 연산을 수행합니다. 이 메서드가 호출되는 문자열은 리터럴 텍스트나 중괄호 ``{}`` 로 구분된 치환 필드를 포함할 수"
" 있습니다. 각 치환 필드는 위치 인자의 숫자 인덱스나 키워드 인자의 이름을 가질 수 있습니다. 각 치환 필드를 해당 인자의 문자열"
" 값으로 치환한 문자열의 사본을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1599
msgid ""
"See :ref:`formatstrings` for a description of the various formatting "
"options that can be specified in format strings."
msgstr "포맷 문자열에 지정할 수 있는 다양한 포맷 옵션에 대한 설명은 :ref:`formatstrings` 을 참조하십시오."

#: ../Doc/library/stdtypes.rst:1603
msgid ""
"When formatting a number (:class:`int`, :class:`float`, :class:`float` "
"and subclasses) with the ``n`` type (ex: ``'{:n}'.format(1234)``), the "
"function sets temporarily the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` "
"locale to decode ``decimal_point`` and ``thousands_sep`` fields of "
":c:func:`localeconv` if they are non-ASCII or longer than 1 byte, and the"
" ``LC_NUMERIC`` locale is different than the ``LC_CTYPE`` locale. This "
"temporary change affects other threads."
msgstr ""
"숫자(:class:`int`, :class:`float`, :class:`float`\\와 서브 클래스)를 ``n`` 형식으로 "
"포매팅할 때 (예: ``'{:n}'.format(1234)``), 이 함수는 일시적으로 ``LC_CTYPE`` 로케일을 "
"``LC_NUMERIC`` 로케일로 설정하여 :c:func:`localeconv` 의 ``decimal_point`` 와 "
"``thousands_sep`` 필드를 디코드하는데, 이 필드들이 ASCII가 아니거나 1바이트보다 길고, "
"``LC_NUMERIC`` 로케일이 ``LC_CTYPE`` 로케일과 다를 때만 그렇게 합니다. 이 임시 변경은 다른 스레드에 영향을"
" 줍니다."

#: ../Doc/library/stdtypes.rst:1611
msgid ""
"When formatting a number with the ``n`` type, the function sets "
"temporarily the ``LC_CTYPE`` locale to the ``LC_NUMERIC`` locale in some "
"cases."
msgstr ""
"숫자를 ``n`` 형식으로 포매팅할 때, 이 함수는 어떤 경우에 일시적으로 ``LC_CTYPE`` 로케일을 "
"``LC_NUMERIC`` 로케일로 설정합니다."

#: ../Doc/library/stdtypes.rst:1619
msgid ""
"Similar to ``str.format(**mapping)``, except that ``mapping`` is used "
"directly and not copied to a :class:`dict`.  This is useful if for "
"example ``mapping`` is a dict subclass:"
msgstr ""
"``str.format(**mapping)`` 과 비슷하지만, :class:`dict`\\로 복사되지 않고 ``mapping`` 을"
" 직접 사용합니다. 예를 들어 ``mapping`` 이 dict 서브 클래스면 유용합니다:"

#: ../Doc/library/stdtypes.rst:1635
msgid ""
"Like :meth:`~str.find`, but raise :exc:`ValueError` when the substring is"
" not found."
msgstr ":meth:`~str.find` 과 비슷하지만, 서브 스트링을 찾을 수 없는 경우 :exc:`ValueError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:1641
msgid ""
"Return true if all characters in the string are alphanumeric and there is"
" at least one character, false otherwise.  A character ``c`` is "
"alphanumeric if one of the following returns ``True``: ``c.isalpha()``, "
"``c.isdecimal()``, ``c.isdigit()``, or ``c.isnumeric()``."
msgstr ""
"문자열 내의 모든 문자가 알파벳과 숫자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. "
"문자 ``c`` 는 다음 중 하나가 ``True`` 를 반환하면 알파벳이거나 숫자입니다: ``c.isalpha()``, "
"``c.isdecimal()``, ``c.isdigit()``, ``c.isnumeric()``."

#: ../Doc/library/stdtypes.rst:1649
msgid ""
"Return true if all characters in the string are alphabetic and there is "
"at least one character, false otherwise.  Alphabetic characters are those"
" characters defined in the Unicode character database as \"Letter\", "
"i.e., those with general category property being one of \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", or \"Lo\".  Note that this is different from the "
"\"Alphabetic\" property defined in the Unicode Standard."
msgstr ""
"문자열 내의 모든 문자가 알파벳이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 알파벳 "
"문자는 유니코드 문자 데이터베이스에서 \"Letter\"로 정의된 문자입니다. 즉, 일반 범주 속성이 \"Lm\", \"Lt\", "
"\"Lu\", \"Ll\", \"Lo\" 중 하나인 문자입니다. 이것은 유니코드 표준에서 정의된 \"Alphabetic\" 속성과 "
"다름에 주의하십시오."

#: ../Doc/library/stdtypes.rst:1658
msgid ""
"Return true if the string is empty or all characters in the string are "
"ASCII, false otherwise. ASCII characters have code points in the range "
"U+0000-U+007F."
msgstr ""

#: ../Doc/library/stdtypes.rst:1667
msgid ""
"Return true if all characters in the string are decimal characters and "
"there is at least one character, false otherwise. Decimal characters are "
"those that can be used to form numbers in base 10, e.g. U+0660, ARABIC-"
"INDIC DIGIT ZERO.  Formally a decimal character is a character in the "
"Unicode General Category \"Nd\"."
msgstr ""
"문자열 내의 모든 문자가 십진수 문자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. "
"십진수 문자는 십진법으로 숫자를 구성할 때 사용될 수 있는 문자들입니다. 예를 들어, U+0660, ARABIC-INDIC "
"DIGIT ZERO. 형식적으로 십진수 문자는 유니코드 일반 범주 \"Nd\" 에 속하는 문자입니다."

#: ../Doc/library/stdtypes.rst:1677
msgid ""
"Return true if all characters in the string are digits and there is at "
"least one character, false otherwise.  Digits include decimal characters "
"and digits that need special handling, such as the compatibility "
"superscript digits. This covers digits which cannot be used to form "
"numbers in base 10, like the Kharosthi numbers.  Formally, a digit is a "
"character that has the property value Numeric_Type=Digit or "
"Numeric_Type=Decimal."
msgstr ""
"문자열 내의 모든 문자가 디짓이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 디짓에는 "
"십진수 문자와 호환성 위 첨자 숫자와 같은 특수 처리가 필요한 숫자가 포함됩니다. 여기에는 카로슈티 숫자처럼 십진법으로 숫자를 "
"구성할 때 사용될 수 없는 것들이 포함됩니다. 형식적으로, 디짓은 속성값이 Numeric_Type=Digit 또는 "
"Numeric_Type=Decimal인 문자입니다."

#: ../Doc/library/stdtypes.rst:1687
msgid ""
"Return true if the string is a valid identifier according to the language"
" definition, section :ref:`identifiers`."
msgstr "문자열이 섹션 section :ref:`identifiers` 의 언어 정의에 따른 유효한 식별자면 참을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1690
msgid ""
"Use :func:`keyword.iskeyword` to test for reserved identifiers such as "
":keyword:`def` and :keyword:`class`."
msgstr ""
":keyword:`def` 나 :keyword:`class`\\와 같은 예약 식별자를 검사하려면 "
":func:`keyword.iskeyword` 를 사용하십시오."

#: ../Doc/library/stdtypes.rst:1695
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"문자열 내의 모든 케이스 문자가 [4]_ 소문자이고, 적어도 하나의 케이스 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 "
"거짓을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1701
msgid ""
"Return true if all characters in the string are numeric characters, and "
"there is at least one character, false otherwise. Numeric characters "
"include digit characters, and all characters that have the Unicode "
"numeric value property, e.g. U+2155, VULGAR FRACTION ONE FIFTH.  "
"Formally, numeric characters are those with the property value "
"Numeric_Type=Digit, Numeric_Type=Decimal or Numeric_Type=Numeric."
msgstr ""
"문자열 내의 모든 문자가 숫자이고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 숫자는 "
"디짓과 유니코드 숫자 값 속성을 갖는 모든 문자를 포함합니다. 예를 들어, U+2155, VULGAR FRACTION ONE "
"FIFTH. 형식적으로, 숫자는 속성 값이 Numeric_Type=Digit, Numeric_Type=Decimal, "
"Numeric_Type=Numeric인 문자입니다."

#: ../Doc/library/stdtypes.rst:1711
msgid ""
"Return true if all characters in the string are printable or the string "
"is empty, false otherwise.  Nonprintable characters are those characters "
"defined in the Unicode character database as \"Other\" or \"Separator\", "
"excepting the ASCII space (0x20) which is considered printable.  (Note "
"that printable characters in this context are those which should not be "
"escaped when :func:`repr` is invoked on a string.  It has no bearing on "
"the handling of strings written to :data:`sys.stdout` or "
":data:`sys.stderr`.)"
msgstr ""
"문자열 내의 모든 문자가 인쇄할 수 있거나 문자열이 비어있으면 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 인쇄할 수 없는 "
"문자는 유니코드 문자 데이터베이스에 \"Other\" 또는 \"Separator\"로 정의된 문자입니다. ASCII 스페이스 "
"(0x20) 는 예외인데, 인쇄 가능한 것으로 간주합니다. (이 문맥에서, 인쇄 가능한 문자는 문자열에 :func:`repr` 을 "
"호출했을 때 이스케이프 되지 않아야 하는 것들입니다. :data:`sys.stdout` 또는 :data:`sys.stderr` 로 "
"출력되는 문자열의 처리에 영향을 주지 않습니다.)"

#: ../Doc/library/stdtypes.rst:1722
msgid ""
"Return true if there are only whitespace characters in the string and "
"there is at least one character, false otherwise.  Whitespace characters"
"  are those characters defined in the Unicode character database as "
"\"Other\" or \"Separator\" and those with bidirectional property being "
"one of \"WS\", \"B\", or \"S\"."
msgstr ""
"문자열 내에 공백 문자만 있고, 적어도 하나의 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 거짓을 돌려줍니다. 공백 문자는 "
"유니코드 문자 데이터베이스에서 \"Other\" 나 \"Separator\"로 정의되고 양방향 속성이 \"WS\", \"B\", "
"\"S\" 중 하나인 문자입니다."

#: ../Doc/library/stdtypes.rst:1729
msgid ""
"Return true if the string is a titlecased string and there is at least "
"one character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false "
"otherwise."
msgstr ""
"문자열이 제목 케이스 문자열이고 하나 이상의 문자가 있는 경우 참을 돌려줍니다. 예를 들어 대문자 앞에는 케이스 없는 문자만 올 수"
" 있고 소문자는 케이스 문자 뒤에만 올 수 있습니다. 그렇지 않은 경우는 거짓을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1736
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr ""
"문자열 내의 모든 케이스 문자가 [4]_ 대문자이고, 적어도 하나의 케이스 문자가 존재하는 경우 참을 돌려주고, 그렇지 않으면 "
"거짓을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1742
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. "
"A :exc:`TypeError` will be raised if there are any non-string values in "
"*iterable*, including :class:`bytes` objects.  The separator between "
"elements is the string providing this method."
msgstr ""
"*iterable* 의 문자열들을 이어 붙인 문자열을 돌려줍니다. *iterable* 에 :class:`bytes` 객체나 기타 "
"문자열이 아닌 값이 있으면 :exc:`TypeError` 를 일으킵니다. 요소들 사이의 구분자는 이 메서드를 제공하는 문자열입니다."

#: ../Doc/library/stdtypes.rst:1750
msgid ""
"Return the string left justified in a string of length *width*. Padding "
"is done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to "
"``len(s)``."
msgstr ""
"왼쪽으로 정렬된 문자열을 길이 *width* 인 문자열로 돌려줍니다. 지정된 *fillchar* (기본값은 ASCII 스페이스)을 "
"사용하여 채웁니다. *width* 가 ``len(s)`` 보다 작거나 같은 경우 원래 문자열이 반환됩니다."

#: ../Doc/library/stdtypes.rst:1757
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted "
"to lowercase."
msgstr "모든 케이스 문자 [4]_ 가 소문자로 변환된 문자열의 복사본을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1760
msgid ""
"The lowercasing algorithm used is described in section 3.13 of the "
"Unicode Standard."
msgstr "사용되는 소문자 변환 알고리즘은 유니코드 표준의 섹션 3.13에 설명되어 있습니다."

#: ../Doc/library/stdtypes.rst:1766
msgid ""
"Return a copy of the string with leading characters removed.  The *chars*"
" argument is a string specifying the set of characters to be removed.  If"
" omitted or ``None``, the *chars* argument defaults to removing "
"whitespace.  The *chars* argument is not a prefix; rather, all "
"combinations of its values are stripped::"
msgstr ""
"선행 문자가 제거된 문자열의 복사본을 돌려줍니다. *chars* 인자는 제거할 문자 집합을 지정하는 문자열입니다. 생략되거나 "
"``None`` 이라면, *chars* 인자의 기본값은 공백을 제거하도록 합니다. *chars* 인자는 접두사가 아닙니다; 모든 값"
" 조합이 제거됩니다::"

#: ../Doc/library/stdtypes.rst:1779
msgid ""
"This static method returns a translation table usable for "
":meth:`str.translate`."
msgstr "이 정적 메서드는 :meth:`str.translate` 에 사용할 수 있는 변환표를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1781
msgid ""
"If there is only one argument, it must be a dictionary mapping Unicode "
"ordinals (integers) or characters (strings of length 1) to Unicode "
"ordinals, strings (of arbitrary lengths) or ``None``.  Character keys "
"will then be converted to ordinals."
msgstr ""
"인자가 하나만 있으면 유니코드 포인트 (정수) 또는 문자 (길이가 1인 문자열)를 유니코드 포인트, 문자열 (임의 길이) 또는 "
"``None`` 으로 매핑하는 딕셔너리여야 합니다. 문자 키는 유니코드 포인트로 변환됩니다."

#: ../Doc/library/stdtypes.rst:1786
msgid ""
"If there are two arguments, they must be strings of equal length, and in "
"the resulting dictionary, each character in x will be mapped to the "
"character at the same position in y.  If there is a third argument, it "
"must be a string, whose characters will be mapped to ``None`` in the "
"result."
msgstr ""
"인자가 두 개면 길이가 같은 문자열이어야 하며, 결과 딕셔너리에서, x의 각 문자는 y의 같은 위치에 있는 문자로 대응됩니다. 세 "
"번째의 인자가 있는 경우, 문자열이어야 하는데 각 문자가 ``None`` 으로 대응되는 결과를 줍니다."

#: ../Doc/library/stdtypes.rst:1794
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the "
"part after the separator.  If the separator is not found, return a "
"3-tuple containing the string itself, followed by two empty strings."
msgstr ""
"*sep* 가 처음 나타나는 위치에서 문자열을 나누고, 구분자 앞에 있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 "
"3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 문자열 자신과 그 뒤를 따르는 두 개의 빈 문자열로 구성된 3-튜플을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1802
msgid ""
"Return a copy of the string with all occurrences of substring *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"모든 서브 스트링 *old* 가 *new* 로 치환된 문자열의 복사본을 돌려줍니다. 선택적 인자 *count* 가 주어지면, 앞의 "
"*count* 개만 치환됩니다."

#: ../Doc/library/stdtypes.rst:1809
msgid ""
"Return the highest index in the string where substring *sub* is found, "
"such that *sub* is contained within ``s[start:end]``.  Optional arguments"
" *start* and *end* are interpreted as in slice notation.  Return ``-1`` "
"on failure."
msgstr ""
"서브 스트링 *sub* 가 ``s[start:end]`` 내에 등장하는 가장 큰 문자열의 인덱스를 돌려줍니다. 선택적 인자 "
"*start* 와 *end* 는 슬라이스 표기법으로 해석됩니다. 실패하면 ``-1`` 을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1816
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* "
"is not found."
msgstr ""
":meth:`rfind`\\와 비슷하지만, 서브 스트링 *sub* 를 찾을 수 없는 경우 :exc:`ValueError` 를 "
"일으킵니다."

#: ../Doc/library/stdtypes.rst:1822
msgid ""
"Return the string right justified in a string of length *width*. Padding "
"is done using the specified *fillchar* (default is an ASCII space). The "
"original string is returned if *width* is less than or equal to "
"``len(s)``."
msgstr ""
"오른쪽으로 정렬된 문자열을 길이 *width* 인 문자열로 돌려줍니다. 지정된 *fillchar* (기본값은 ASCII 스페이스)을"
" 사용하여 채웁니다. *width* 가 ``len(s)`` 보다 작거나 같은 경우 원래 문자열이 반환됩니다."

#: ../Doc/library/stdtypes.rst:1829
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the "
"part after the separator.  If the separator is not found, return a "
"3-tuple containing two empty strings, followed by the string itself."
msgstr ""
"*sep* 가 마지막으로 나타나는 위치에서 문자열을 나누고, 구분자 앞에 있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 "
"구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 두 개의 빈 문자열과 그 뒤를 따르는 문자열 자신으로 구성된 3-튜플을 "
"돌려줍니다."

#: ../Doc/library/stdtypes.rst:1837
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, "
":meth:`rsplit` behaves like :meth:`split` which is described in detail "
"below."
msgstr ""
"*sep* 를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 돌려줍니다. *maxsplit* 이 주어지면 가장 오른쪽에서"
" 최대 *maxsplit* 번의 분할이 수행됩니다. *sep* 이 지정되지 않거나 ``None`` 이면, 구분자로 모든 공백 문자가"
" 사용됩니다. 오른쪽에서 분리하는 것을 제외하면, :meth:`rsplit`\\는 아래에서 자세히 설명될 "
":meth:`split`\\처럼 동작합니다."

#: ../Doc/library/stdtypes.rst:1846
msgid ""
"Return a copy of the string with trailing characters removed.  The "
"*chars* argument is a string specifying the set of characters to be "
"removed.  If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace.  The *chars* argument is not a suffix; rather, all "
"combinations of its values are stripped::"
msgstr ""
"후행 문자가 제거된 문자열의 복사본을 돌려줍니다. *chars* 인자는 제거할 문자 집합을 지정하는 문자열입니다. 생략되거나 "
"``None`` 이라면, *chars* 인자의 기본값은 공백을 제거하도록 합니다. *chars* 인자는 접미사가 아닙니다; 모든 값"
" 조합이 제거됩니다::"

#: ../Doc/library/stdtypes.rst:1859
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done "
"(thus, the list will have at most ``maxsplit+1`` elements).  If "
"*maxsplit* is not specified or ``-1``, then there is no limit on the "
"number of splits (all possible splits are made)."
msgstr ""
"*sep* 를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 돌려줍니다. *maxsplit* 이 주어지면 최대 "
"*maxsplit* 번의 분할이 수행됩니다 (따라서, 리스트는 최대 ``maxsplit+1`` 개의 요소를 가지게 됩니다). "
"*maxsplit* 이 지정되지 않았거나 ``-1`` 이라면 분할 수에 제한이 없습니다 (가능한 모든 분할이 만들어집니다)."

#: ../Doc/library/stdtypes.rst:1865
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and "
"are deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` "
"returns ``['1', '', '2']``).  The *sep* argument may consist of multiple "
"characters (for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', "
"'3']``). Splitting an empty string with a specified separator returns "
"``['']``."
msgstr ""
"*sep* 이 주어지면, 연속된 구분자는 묶이지 않고 빈 문자열을 구분하는 것으로 간주합니다 (예를 들어, "
"``'1,,2'.split(',')`` 는 ``['1', '', '2']`` 를 돌려줍니다). *sep* 인자는 여러 문자로 구성될"
" 수 있습니다 (예를 들어, ``'1<>2<>3'.split('<>')`` 는 ``['1', '2', '3']`` 를 돌려줍니다)."
" 지정된 구분자로 빈 문자열을 나누면 ``['']`` 를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1871 ../Doc/library/stdtypes.rst:1887
#: ../Doc/library/stdtypes.rst:1939 ../Doc/library/stdtypes.rst:2007
#: ../Doc/library/stdtypes.rst:2071 ../Doc/library/stdtypes.rst:2822
#: ../Doc/library/stdtypes.rst:2838 ../Doc/library/stdtypes.rst:2929
#: ../Doc/library/stdtypes.rst:2945 ../Doc/library/stdtypes.rst:2970
#: ../Doc/library/stdtypes.rst:2984 ../Doc/library/stdtypes.rst:3012
#: ../Doc/library/stdtypes.rst:3026 ../Doc/library/stdtypes.rst:3044
#: ../Doc/library/stdtypes.rst:3071 ../Doc/library/stdtypes.rst:3094
#: ../Doc/library/stdtypes.rst:3121 ../Doc/library/stdtypes.rst:3163
#: ../Doc/library/stdtypes.rst:3187
msgid "For example::"
msgstr "예를 들면::"

#: ../Doc/library/stdtypes.rst:1880
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm"
" is applied: runs of consecutive whitespace are regarded as a single "
"separator, and the result will contain no empty strings at the start or "
"end if the string has leading or trailing whitespace.  Consequently, "
"splitting an empty string or a string consisting of just whitespace with "
"a ``None`` separator returns ``[]``."
msgstr ""
"*sep* 이 지정되지 않거나 ``None`` 이면, 다른 분할 알고리즘이 적용됩니다: 연속된 공백 문자는 단일한 구분자로 "
"간주하고, 문자열이 선행이나 후행 공백을 포함해도 결과는 시작과 끝에 빈 문자열을 포함하지 않습니다. 결과적으로, 빈 문자열이나 "
"공백만으로 구성된 문자열을 ``None`` 구분자로 나누면 ``[]`` 를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:1902
msgid ""
"Return a list of the lines in the string, breaking at line boundaries.  "
"Line breaks are not included in the resulting list unless *keepends* is "
"given and true."
msgstr ""
"줄 경계에서 나눈 문자열의 줄 리스트를 돌려줍니다. *keepends* 가 참으로 주어지지 않는 한 결과 리스트에 줄 바꿈은 "
"포함되지 않습니다."

#: ../Doc/library/stdtypes.rst:1906
msgid ""
"This method splits on the following line boundaries.  In particular, the "
"boundaries are a superset of :term:`universal newlines`."
msgstr ""
"이 메서드는 다음 줄 경계에서 나눕니다. 특히, 경계는 :term:`유니버설 줄 넘김 <universal newlines>` 을 "
"포함합니다."

#: ../Doc/library/stdtypes.rst:1910
msgid "Representation"
msgstr "표현"

#: ../Doc/library/stdtypes.rst:1910
msgid "Description"
msgstr "설명"

#: ../Doc/library/stdtypes.rst:1912
msgid "``\\n``"
msgstr "``\\n``"

#: ../Doc/library/stdtypes.rst:1912
msgid "Line Feed"
msgstr "줄 넘김"

#: ../Doc/library/stdtypes.rst:1914
msgid "``\\r``"
msgstr "``\\r``"

#: ../Doc/library/stdtypes.rst:1914
msgid "Carriage Return"
msgstr "캐리지 리턴"

#: ../Doc/library/stdtypes.rst:1916
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../Doc/library/stdtypes.rst:1916
msgid "Carriage Return + Line Feed"
msgstr "캐리지 리턴 + 줄 넘김"

#: ../Doc/library/stdtypes.rst:1918
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` 또는 ``\\x0b``"

#: ../Doc/library/stdtypes.rst:1918
msgid "Line Tabulation"
msgstr "수직 탭"

#: ../Doc/library/stdtypes.rst:1920
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` 또는 ``\\x0c``"

#: ../Doc/library/stdtypes.rst:1920
msgid "Form Feed"
msgstr "폼 피드"

#: ../Doc/library/stdtypes.rst:1922
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../Doc/library/stdtypes.rst:1922
msgid "File Separator"
msgstr "파일 구분자"

#: ../Doc/library/stdtypes.rst:1924
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../Doc/library/stdtypes.rst:1924
msgid "Group Separator"
msgstr "그룹 구분자"

#: ../Doc/library/stdtypes.rst:1926
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../Doc/library/stdtypes.rst:1926
msgid "Record Separator"
msgstr "레코드 구분자"

#: ../Doc/library/stdtypes.rst:1928
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../Doc/library/stdtypes.rst:1928
msgid "Next Line (C1 Control Code)"
msgstr "다음 줄 (C1 제어 코드)"

#: ../Doc/library/stdtypes.rst:1930
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../Doc/library/stdtypes.rst:1930
msgid "Line Separator"
msgstr "줄 구분자"

#: ../Doc/library/stdtypes.rst:1932
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../Doc/library/stdtypes.rst:1932
msgid "Paragraph Separator"
msgstr "문단 구분자"

#: ../Doc/library/stdtypes.rst:1937
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` 와 ``\\f`` 를 줄 경계 목록에 추가했습니다."

#: ../Doc/library/stdtypes.rst:1946
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line "
"break does not result in an extra line::"
msgstr ""
"구분자 문자열 *sep* 이 주어졌을 때 :meth:`~str.split` 와 달리, 이 메서드는 빈 문자열에 대해서 빈 리스트를 "
"돌려주고, 마지막 줄 바꿈은 새 줄을 만들지 않습니다::"

#: ../Doc/library/stdtypes.rst:1955
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "비교해 보면, ``split('\\n')`` 는 이렇게 됩니다::"

#: ../Doc/library/stdtypes.rst:1965
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"문자열이 지정된 *prefix* 로 시작하면 ``True`` 를 돌려주고, 그렇지 않으면 ``False`` 를 돌려줍니다. "
"*prefix* 는 찾고자 하는 접두사들의 튜플이 될 수도 있습니다. 선택적 *start* 가 제공되면 그 위치에서 검사를 "
"시작합니다. 선택적 *end* 를 사용하면 해당 위치에서 비교를 중단합니다."

#: ../Doc/library/stdtypes.rst:1973
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of "
"characters to be removed. If omitted or ``None``, the *chars* argument "
"defaults to removing whitespace. The *chars* argument is not a prefix or "
"suffix; rather, all combinations of its values are stripped::"
msgstr ""
"선행과 후행 문자가 제거된 문자열의 복사본을 돌려줍니다. *chars* 인자는 제거할 문자 집합을 지정하는 문자열입니다. 생략되거나"
" ``None`` 이라면, *chars* 인자의 기본값은 공백을 제거하도록 합니다. *chars* 인자는 접두사나 접미사가 "
"아닙니다; 모든 값 조합이 제거됩니다::"

#: ../Doc/library/stdtypes.rst:1984
msgid ""
"The outermost leading and trailing *chars* argument values are stripped "
"from the string. Characters are removed from the leading end until "
"reaching a string character that is not contained in the set of "
"characters in *chars*. A similar action takes place on the trailing end. "
"For example::"
msgstr ""
"가장 바깥쪽의 선행 또는 후행 *chars* 인자 값들이 문자열에서 제거됩니다. 문자는 *chars* 에 있는 문자 집합에 포함되지"
" 않은 문자에 도달할 때까지 맨 앞에서 제거됩니다. 끝에서도 유사한 동작이 수행됩니다. 예를 들면::"

#: ../Doc/library/stdtypes.rst:1997
msgid ""
"Return a copy of the string with uppercase characters converted to "
"lowercase and vice versa. Note that it is not necessarily true that "
"``s.swapcase().swapcase() == s``."
msgstr ""
"대문자를 소문자로, 그 반대로 마찬가지로 변환 한 문자열의 복사본을 돌려줍니다. ``s.swapcase().swapcase() =="
" s`` 가 반드시 성립하지 않음에 주의하십시오."

#: ../Doc/library/stdtypes.rst:2004
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr "단어가 대문자로 시작하고 나머지 문자는 소문자가 되도록 문자열의 제목 케이스 버전을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2012 ../Doc/library/stdtypes.rst:3131
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but"
" it means that apostrophes in contractions and possessives form word "
"boundaries, which may not be the desired result::"
msgstr ""
"이 알고리즘은 단어를 글자들의 연속으로 보는 간단한 언어 독립적 정의를 사용합니다. 이 정의는 여러 상황에서 작동하지만, 축약과 "
"소유의 아포스트로피가 단어 경계를 형성한다는 것을 의미하고, 이는 원하는 결과가 아닐 수도 있습니다::"

#: ../Doc/library/stdtypes.rst:2020 ../Doc/library/stdtypes.rst:3139
msgid ""
"A workaround for apostrophes can be constructed using regular "
"expressions::"
msgstr "정규식을 사용하여 아포스트로피에 대한 해결 방법을 구성할 수 있습니다::"

#: ../Doc/library/stdtypes.rst:2035
msgid ""
"Return a copy of the string in which each character has been mapped "
"through the given translation table.  The table must be an object that "
"implements indexing via :meth:`__getitem__`, typically a :term:`mapping` "
"or :term:`sequence`.  When indexed by a Unicode ordinal (an integer), the"
" table object can do any of the following: return a Unicode ordinal or a "
"string, to map the character to one or more other characters; return "
"``None``, to delete the character from the return string; or raise a "
":exc:`LookupError` exception, to map the character to itself."
msgstr ""
"각 문자를 지정된 변환표를 사용해 매핑한 문자열의 복사본을 돌려줍니다. table은 :meth:`__getitem__` 을 통한 "
"인덱싱을 구현하는 객체여야 하는데, 보통 :term:`매핑 <mapping>` 이나 :term:`시퀀스 <sequence>` "
"입니다. 유니코드 포인트 (정수)로 인덱싱할 때, table 객체는 다음 중 하나를 수행할 수 있습니다: 그 문자를 하나 이상의 "
"다른 문자들로 매핑하기 위해 유니코드 포인트나 문자열을 돌려줍니다; 결과 문자열에서 그 문자를 제거하기 위해 ``None`` 을 "
"돌려줍니다; 그 문자를 자기 자신으로 매핑하기 위해 :exc:`LookupError` 예외를 일으킵니다."

#: ../Doc/library/stdtypes.rst:2044
msgid ""
"You can use :meth:`str.maketrans` to create a translation map from "
"character-to-character mappings in different formats."
msgstr ":meth:`str.maketrans` 를 사용하여 다른 형식의 문자 대 문자 매핑으로 부터 변환 맵을 만들 수 있습니다."

#: ../Doc/library/stdtypes.rst:2047
msgid ""
"See also the :mod:`codecs` module for a more flexible approach to custom "
"character mappings."
msgstr "커스텀 문자 매핑에 대한 보다 유연한 접근법은 :mod:`codecs` 모듈을 참고하십시오."

#: ../Doc/library/stdtypes.rst:2053
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted "
"to uppercase.  Note that ``str.upper().isupper()`` might be ``False`` if "
"``s`` contains uncased characters or if the Unicode category of the "
"resulting character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\""
" (Letter, titlecase)."
msgstr ""
"모든 케이스 문자 [4]_ 가 대문자로 변환된 문자열의 복사본을 돌려줍니다. ``s`` 가 케이스 없는 문자를 포함하거나 결과 "
"문자의 유니코드 범주가 \"Lu\" (Letter, 대문자) 가 아닌 경우, 예를 들어 \"Lt\" (Letter, 제목 케이스),"
" ``str.upper().isupper()`` 가 ``False`` 일 수 있음에 주의하십시오."

#: ../Doc/library/stdtypes.rst:2059
msgid ""
"The uppercasing algorithm used is described in section 3.13 of the "
"Unicode Standard."
msgstr "사용되는 대문자 변환 알고리즘은 유니코드 표준의 섹션 3.13에 설명되어 있습니다."

#: ../Doc/library/stdtypes.rst:2065
msgid ""
"Return a copy of the string left filled with ASCII ``'0'`` digits to make"
" a string of length *width*. A leading sign prefix (``'+'``/``'-'``) is "
"handled by inserting the padding *after* the sign character rather than "
"before. The original string is returned if *width* is less than or equal "
"to ``len(s)``."
msgstr ""
"길이가 *width* 인 문자열을 만들기 위해 ASCII ``'0'`` 문자를 왼쪽에 채운 문자열의 복사본을 돌려줍니다. 선행 부호"
" 접두어(``'+'``/``'-'``)는 부호 문자의 앞이 아니라 *뒤* 에 채워 넣는 것으로 처리됩니다. *width* 가 "
"``len(s)`` 보다 작거나 같은 경우 원래 문자열을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2083
msgid "``printf``-style String Formatting"
msgstr "``printf`` 스타일 문자열 포매팅"

#: ../Doc/library/stdtypes.rst:2097
#, fuzzy
msgid ""
"The formatting operations described here exhibit a variety of quirks that"
" lead to a number of common errors (such as failing to display tuples and"
" dictionaries correctly).  Using the newer :ref:`formatted string "
"literals <f-strings>`, the :meth:`str.format` interface, or "
":ref:`template strings <template-strings>` may help avoid these errors.  "
"Each of these alternatives provides their own trade-offs and benefits of "
"simplicity, flexibility, and/or extensibility."
msgstr ""
"여기에 설명된 포맷 연산은 여러 가지 일반적인 오류를 (예를 들어 튜플과 딕셔너리를 올바르게 표시하지 못하는 것) 유발하는 다양한 "
"문제점들이 있습니다. 새 :ref:`포맷 문자열 리터럴 <f-strings>` 나 :meth:`str.format` 인터페이스를 "
"사용하면 이러한 오류를 피할 수 있습니다. 이 대안들은 또한 텍스트 포매팅에 더욱 강력하고 유연하며 확장 가능한 접근법을 "
"제공합니다."

#: ../Doc/library/stdtypes.rst:2105
msgid ""
"String objects have one unique built-in operation: the ``%`` operator "
"(modulo). This is also known as the string *formatting* or "
"*interpolation* operator. Given ``format % values`` (where *format* is a "
"string), ``%`` conversion specifications in *format* are replaced with "
"zero or more elements of *values*. The effect is similar to using the "
":c:func:`sprintf` in the C language."
msgstr ""
"문자열 객체는 한가지 고유한 내장 연산을 갖고 있습니다: ``%`` 연산자 (모듈로). 이것은 문자열 *포매팅* 또는 *치환* "
"연산자라고도 합니다. ``format % values`` 가 주어질 때 (*format* 은 문자열입니다), *format* 내부의"
" ``%`` 변환 명세는 0개 이상의 *values​​* 의 요소로 대체됩니다. 이 효과는 C 언어에서 "
":c:func:`sprintf`\\를 사용하는 것과 비슷합니다."

#: ../Doc/library/stdtypes.rst:2111
msgid ""
"If *format* requires a single argument, *values* may be a single non-"
"tuple object. [5]_  Otherwise, *values* must be a tuple with exactly the "
"number of items specified by the format string, or a single mapping "
"object (for example, a dictionary)."
msgstr ""
"*format* 이 하나의 인자를 요구하면, *values​​* 는 하나의 비 튜플 객체 일 수 있습니다. [5]_ 그렇지 않으면,"
" *values​​* 는 format 문자열이 지정하는 항목의 수와 같은 튜플이거나 단일 매핑 객체 (예를 들어, 딕셔너리) 이어야"
" 합니다."

#: ../Doc/library/stdtypes.rst:2116 ../Doc/library/stdtypes.rst:3238
msgid ""
"A conversion specifier contains two or more characters and has the "
"following components, which must occur in this order:"
msgstr "변환 명세는 두 개 이상의 문자를 포함하며 다음과 같은 구성 요소들을 포함하는데, 반드시 이 순서대로 나와야 합니다:"

#: ../Doc/library/stdtypes.rst:2119 ../Doc/library/stdtypes.rst:3241
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "``'%'`` 문자: 명세의 시작을 나타냅니다."

#: ../Doc/library/stdtypes.rst:2121 ../Doc/library/stdtypes.rst:3243
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of "
"characters (for example, ``(somename)``)."
msgstr "매핑 키 (선택 사항): 괄호로 둘러싸인 문자들의 시퀀스로 구성됩니다 (예를 들어, ``(somename)``)."

#: ../Doc/library/stdtypes.rst:2124 ../Doc/library/stdtypes.rst:3246
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr "변환 플래그 (선택 사항): 일부 변환 유형의 결과에 영향을 줍니다."

#: ../Doc/library/stdtypes.rst:2127 ../Doc/library/stdtypes.rst:3249
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), "
"the actual width is read from the next element of the tuple in *values*, "
"and the object to convert comes after the minimum field width and "
"optional precision."
msgstr ""
"최소 필드 폭 (선택 사항): ``'*'`` (애스터리스크) 로 지정하면, 실제 폭은 *values* 튜플의 다음 요소에서 읽히고,"
" 변환할 객체는 최소 필드 폭과 선택적 정밀도 뒤에 옵니다."

#: ../Doc/library/stdtypes.rst:2131 ../Doc/library/stdtypes.rst:3253
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision."
"  If specified as ``'*'`` (an asterisk), the actual precision is read "
"from the next element of the tuple in *values*, and the value to convert "
"comes after the precision."
msgstr ""
"정밀도 (선택 사항): ``'.'`` (점) 다음에 정밀도가 옵니다. ``'*'`` (애스터리스크) 로 지정하면, 실제 정밀도는 "
"*values* 튜플의 다음 요소에서 읽히고, 변환할 값은 정밀도 뒤에 옵니다."

#: ../Doc/library/stdtypes.rst:2136 ../Doc/library/stdtypes.rst:3258
msgid "Length modifier (optional)."
msgstr "길이 수정자 (선택 사항)."

#: ../Doc/library/stdtypes.rst:2138 ../Doc/library/stdtypes.rst:3260
msgid "Conversion type."
msgstr "변환 유형."

#: ../Doc/library/stdtypes.rst:2140
msgid ""
"When the right argument is a dictionary (or other mapping type), then the"
" formats in the string *must* include a parenthesised mapping key into "
"that dictionary inserted immediately after the ``'%'`` character. The "
"mapping key selects the value to be formatted from the mapping.  For "
"example:"
msgstr ""
"오른쪽 인자가 딕셔너리 (또는 다른 매핑 형) 인 경우, 문자열에 있는 변환 명세는 *반드시* ``'%'`` 문자 바로 뒤에 그 "
"딕셔너리의 매핑 키를 괄호로 둘러싼 형태로 포함해야 합니다. 매핑 키는 포맷할 값을 매핑으로 부터 선택합니다. 예를 들어:"

#: ../Doc/library/stdtypes.rst:2149 ../Doc/library/stdtypes.rst:3271
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they "
"require a sequential parameter list)."
msgstr "이 경우 ``*`` 지정자를 사용할 수 없습니다 (순차적인 파라미터 목록이 필요하기 때문입니다)."

#: ../Doc/library/stdtypes.rst:2152 ../Doc/library/stdtypes.rst:3274
msgid "The conversion flag characters are:"
msgstr "변환 플래그 문자는 다음과 같습니다:"

#: ../Doc/library/stdtypes.rst:2155 ../Doc/library/stdtypes.rst:3277
msgid "Flag"
msgstr "플래그"

#: ../Doc/library/stdtypes.rst:2157 ../Doc/library/stdtypes.rst:3279
msgid "``'#'``"
msgstr "``'#'``"

#: ../Doc/library/stdtypes.rst:2157 ../Doc/library/stdtypes.rst:3279
msgid ""
"The value conversion will use the \"alternate form\" (where defined "
"below)."
msgstr "값 변환에 \"대체 형식\" (아래에 정의되어있습니다) 을 사용합니다."

#: ../Doc/library/stdtypes.rst:2160 ../Doc/library/stdtypes.rst:3282
msgid "``'0'``"
msgstr "``'0'``"

#: ../Doc/library/stdtypes.rst:2160 ../Doc/library/stdtypes.rst:3282
msgid "The conversion will be zero padded for numeric values."
msgstr "변환은 숫자 값의 경우 0으로 채웁니다."

#: ../Doc/library/stdtypes.rst:2162 ../Doc/library/stdtypes.rst:3284
msgid "``'-'``"
msgstr "``'-'``"

#: ../Doc/library/stdtypes.rst:2162 ../Doc/library/stdtypes.rst:3284
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if"
" both are given)."
msgstr "변환된 값은 왼쪽으로 정렬됩니다 (둘 다 주어지면 ``'0'`` 변환보다 우선 합니다)."

#: ../Doc/library/stdtypes.rst:2165 ../Doc/library/stdtypes.rst:3287
msgid "``' '``"
msgstr "``' '``"

#: ../Doc/library/stdtypes.rst:2165 ../Doc/library/stdtypes.rst:3287
msgid ""
"(a space) A blank should be left before a positive number (or empty "
"string) produced by a signed conversion."
msgstr "(스페이스) 부호 있는 변환 때문에 만들어진 양수 앞에 빈칸을 남겨둡니다 (음수면 빈 문자열입니다)."

#: ../Doc/library/stdtypes.rst:2168 ../Doc/library/stdtypes.rst:3290
msgid "``'+'``"
msgstr "``'+'``"

#: ../Doc/library/stdtypes.rst:2168 ../Doc/library/stdtypes.rst:3290
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion "
"(overrides a \"space\" flag)."
msgstr "부호 문자 (``'+'`` or ``'-'``) 가 변환 앞에 놓입니다 (``' '`` 플래그에 우선합니다)."

#: ../Doc/library/stdtypes.rst:2172 ../Doc/library/stdtypes.rst:3294
#, python-format
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored"
" as it is not necessary for Python -- so e.g. ``%ld`` is identical to "
"``%d``."
msgstr ""
"길이 수정자 (``h``, ``l``, ``L``) 를 제공할 수는 있지만, 파이썬에서 필요하지 않기 때문에 무시됩니다 -- 예를 "
"들어 ``%ld`` 는 ``%d`` 와 같습니다."

#: ../Doc/library/stdtypes.rst:2175 ../Doc/library/stdtypes.rst:3297
msgid "The conversion types are:"
msgstr "변환 유형은 다음과 같습니다:"

#: ../Doc/library/stdtypes.rst:2178 ../Doc/library/stdtypes.rst:3300
msgid "Conversion"
msgstr "변환"

#: ../Doc/library/stdtypes.rst:2180 ../Doc/library/stdtypes.rst:3302
msgid "``'d'``"
msgstr "``'d'``"

#: ../Doc/library/stdtypes.rst:2180 ../Doc/library/stdtypes.rst:2182
#: ../Doc/library/stdtypes.rst:3302 ../Doc/library/stdtypes.rst:3304
msgid "Signed integer decimal."
msgstr "부호 있는 정수 십진 표기."

#: ../Doc/library/stdtypes.rst:2182 ../Doc/library/stdtypes.rst:3304
msgid "``'i'``"
msgstr "``'i'``"

#: ../Doc/library/stdtypes.rst:2184 ../Doc/library/stdtypes.rst:3306
msgid "``'o'``"
msgstr "``'o'``"

#: ../Doc/library/stdtypes.rst:2184 ../Doc/library/stdtypes.rst:3306
msgid "Signed octal value."
msgstr "부호 있는 8진수 값."

#: ../Doc/library/stdtypes.rst:2186 ../Doc/library/stdtypes.rst:3308
msgid "``'u'``"
msgstr "``'u'``"

#: ../Doc/library/stdtypes.rst:2186 ../Doc/library/stdtypes.rst:3308
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "쓸데없는 유형 -- ``'d'`` 와 같습니다."

#: ../Doc/library/stdtypes.rst:2188 ../Doc/library/stdtypes.rst:3310
msgid "``'x'``"
msgstr "``'x'``"

#: ../Doc/library/stdtypes.rst:2188 ../Doc/library/stdtypes.rst:3310
msgid "Signed hexadecimal (lowercase)."
msgstr "부호 있는 16진수 (소문자)."

#: ../Doc/library/stdtypes.rst:2190 ../Doc/library/stdtypes.rst:3312
msgid "``'X'``"
msgstr "``'X'``"

#: ../Doc/library/stdtypes.rst:2190 ../Doc/library/stdtypes.rst:3312
msgid "Signed hexadecimal (uppercase)."
msgstr "부호 있는 16진수 (대문자)."

#: ../Doc/library/stdtypes.rst:2192 ../Doc/library/stdtypes.rst:3314
msgid "``'e'``"
msgstr "``'e'``"

#: ../Doc/library/stdtypes.rst:2192 ../Doc/library/stdtypes.rst:3314
msgid "Floating point exponential format (lowercase)."
msgstr "부동 소수점 지수 형식 (소문자)."

#: ../Doc/library/stdtypes.rst:2194 ../Doc/library/stdtypes.rst:3316
msgid "``'E'``"
msgstr "``'E'``"

#: ../Doc/library/stdtypes.rst:2194 ../Doc/library/stdtypes.rst:3316
msgid "Floating point exponential format (uppercase)."
msgstr "부동 소수점 지수 형식 (대문자)."

#: ../Doc/library/stdtypes.rst:2196 ../Doc/library/stdtypes.rst:3318
msgid "``'f'``"
msgstr "``'f'``"

#: ../Doc/library/stdtypes.rst:2196 ../Doc/library/stdtypes.rst:2198
#: ../Doc/library/stdtypes.rst:3318 ../Doc/library/stdtypes.rst:3320
msgid "Floating point decimal format."
msgstr "부동 소수점 십진수 형식."

#: ../Doc/library/stdtypes.rst:2198 ../Doc/library/stdtypes.rst:3320
msgid "``'F'``"
msgstr "``'F'``"

#: ../Doc/library/stdtypes.rst:2200 ../Doc/library/stdtypes.rst:3322
msgid "``'g'``"
msgstr "``'g'``"

#: ../Doc/library/stdtypes.rst:2200 ../Doc/library/stdtypes.rst:3322
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is "
"less than -4 or not less than precision, decimal format otherwise."
msgstr ""
"부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 소문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 "
"사용합니다."

#: ../Doc/library/stdtypes.rst:2204 ../Doc/library/stdtypes.rst:3326
msgid "``'G'``"
msgstr "``'G'``"

#: ../Doc/library/stdtypes.rst:2204 ../Doc/library/stdtypes.rst:3326
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is "
"less than -4 or not less than precision, decimal format otherwise."
msgstr ""
"부동 소수점 형식. 지수가 -4보다 작거나 정밀도 보다 작지 않으면 대문자 지수형식을 사용하고, 그렇지 않으면 십진수 형식을 "
"사용합니다."

#: ../Doc/library/stdtypes.rst:2208 ../Doc/library/stdtypes.rst:3330
msgid "``'c'``"
msgstr "``'c'``"

#: ../Doc/library/stdtypes.rst:2208
msgid "Single character (accepts integer or single character string)."
msgstr "단일 문자 (정수 또는 길이 1인 문자열을 허용합니다)."

#: ../Doc/library/stdtypes.rst:2211 ../Doc/library/stdtypes.rst:3343
msgid "``'r'``"
msgstr "``'r'``"

#: ../Doc/library/stdtypes.rst:2211
msgid "String (converts any Python object using :func:`repr`)."
msgstr "문자열 (:func:`repr`\\을 사용하여 파이썬 객체를 변환합니다)."

#: ../Doc/library/stdtypes.rst:2214 ../Doc/library/stdtypes.rst:3337
msgid "``'s'``"
msgstr "``'s'``"

#: ../Doc/library/stdtypes.rst:2214
msgid "String (converts any Python object using :func:`str`)."
msgstr "문자열 (:func:`str` 을 사용하여 파이썬 객체를 변환합니다)."

#: ../Doc/library/stdtypes.rst:2217 ../Doc/library/stdtypes.rst:3340
msgid "``'a'``"
msgstr "``'a'``"

#: ../Doc/library/stdtypes.rst:2217
msgid "String (converts any Python object using :func:`ascii`)."
msgstr "문자열 (:func:`ascii` 를 사용하여 파이썬 객체를 변환합니다)."

#: ../Doc/library/stdtypes.rst:2220 ../Doc/library/stdtypes.rst:3346
msgid "``'%'``"
msgstr "``'%'``"

#: ../Doc/library/stdtypes.rst:2220 ../Doc/library/stdtypes.rst:3346
msgid "No argument is converted, results in a ``'%'`` character in the result."
msgstr "인자는 변환되지 않고, 결과에 ``'%'`` 문자가 표시됩니다."

#: ../Doc/library/stdtypes.rst:2227 ../Doc/library/stdtypes.rst:3353
msgid ""
"The alternate form causes a leading octal specifier (``'0o'``) to be "
"inserted before the first digit."
msgstr "대체 형식은 첫 번째 숫자 앞에 선행 8진수 지정자 (``'0o'``)를 삽입합니다."

#: ../Doc/library/stdtypes.rst:2231 ../Doc/library/stdtypes.rst:3357
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the"
" first digit."
msgstr ""
"대체 형식은 첫 번째 숫자 앞에 선행 ``'0x'`` 또는 ``'0X'`` (``'x'`` 나 ``'X'`` 유형 중 어느 것을 "
"사용하느냐에 따라 달라집니다) 를 삽입합니다."

#: ../Doc/library/stdtypes.rst:2235 ../Doc/library/stdtypes.rst:3361
msgid ""
"The alternate form causes the result to always contain a decimal point, "
"even if no digits follow it."
msgstr "대체 형식은 그 뒤에 숫자가 나오지 않더라도 항상 소수점을 포함합니다."

#: ../Doc/library/stdtypes.rst:2238 ../Doc/library/stdtypes.rst:3364
msgid ""
"The precision determines the number of digits after the decimal point and"
" defaults to 6."
msgstr "정밀도는 소수점 이하 자릿수를 결정하며 기본값은 6입니다."

#: ../Doc/library/stdtypes.rst:2242 ../Doc/library/stdtypes.rst:3368
msgid ""
"The alternate form causes the result to always contain a decimal point, "
"and trailing zeroes are not removed as they would otherwise be."
msgstr "대체 형식은 결과에 항상 소수점을 포함하고 뒤에 오는 0은 제거되지 않습니다."

#: ../Doc/library/stdtypes.rst:2245 ../Doc/library/stdtypes.rst:3371
msgid ""
"The precision determines the number of significant digits before and "
"after the decimal point and defaults to 6."
msgstr "정밀도는 소수점 앞뒤의 유효 자릿수를 결정하며 기본값은 6입니다."

#: ../Doc/library/stdtypes.rst:2249 ../Doc/library/stdtypes.rst:3375
msgid "If precision is ``N``, the output is truncated to ``N`` characters."
msgstr "정밀도가 ``N`` 이라면, 출력은 ``N`` 문자로 잘립니다."

#: ../Doc/library/stdtypes.rst:2252 ../Doc/library/stdtypes.rst:3384
msgid "See :pep:`237`."
msgstr ":pep:`237`\\을 참조하세요."

#: ../Doc/library/stdtypes.rst:2254
#, python-format
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr "파이썬 문자열은 명시적인 길이를 가지고 있으므로, ``%s`` 변환은 문자열의 끝이 ``'\\0'`` 이라고 가정하지 않습니다."

#: ../Doc/library/stdtypes.rst:2259
#, python-format
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr "절댓값이 1e50 을 넘는 숫자에 대한 ``%f`` 변환은 더는 ``%g`` 변환으로 대체되지 않습니다."

#: ../Doc/library/stdtypes.rst:2270
msgid ""
"Binary Sequence Types --- :class:`bytes`, :class:`bytearray`, "
":class:`memoryview`"
msgstr "바이너리 시퀀스 형 --- :class:`bytes`, :class:`bytearray`, :class:`memoryview`"

#: ../Doc/library/stdtypes.rst:2278
msgid ""
"The core built-in types for manipulating binary data are :class:`bytes` "
"and :class:`bytearray`. They are supported by :class:`memoryview` which "
"uses the :ref:`buffer protocol <bufferobjects>` to access the memory of "
"other binary objects without needing to make a copy."
msgstr ""
"바이너리 데이터를 조작하기 위한 핵심 내장형은 :class:`bytes` 와 :class:`bytearray` 입니다. 이것들은 "
":class:`memoryview` 에 의해 지원되는데, 다른 바이너리 객체들의 메모리에 복사 없이 접근하기 위해 :ref:`버퍼 "
"프로토콜 <bufferobjects>` 을 사용합니다."

#: ../Doc/library/stdtypes.rst:2283
msgid ""
"The :mod:`array` module supports efficient storage of basic data types "
"like 32-bit integers and IEEE754 double-precision floating values."
msgstr ":mod:`array` 모듈은 32-비트 정수와 IEEE754 배정도 부동 소수점 같은 기본 데이터형의 효율적인 저장을 지원합니다."

#: ../Doc/library/stdtypes.rst:2289
msgid "Bytes Objects"
msgstr "바이트열 객체"

#: ../Doc/library/stdtypes.rst:2293
msgid ""
"Bytes objects are immutable sequences of single bytes. Since many major "
"binary protocols are based on the ASCII text encoding, bytes objects "
"offer several methods that are only valid when working with ASCII "
"compatible data and are closely related to string objects in a variety of"
" other ways."
msgstr ""
"바이트열 객체는 단일 바이트들의 불변 시퀀스입니다. 많은 주요 바이너리 프로토콜이 ASCII 텍스트 인코딩을 기반으로 하므로, "
"바이트열 객체는 ASCII 호환 데이터로 작업 할 때만 유효한 여러 가지 메서드를 제공하며 다양한 다른 방법으로 문자열 객체와 "
"밀접한 관련이 있습니다."

#: ../Doc/library/stdtypes.rst:2300
msgid ""
"Firstly, the syntax for bytes literals is largely the same as that for "
"string literals, except that a ``b`` prefix is added:"
msgstr "첫째로, 바이트열 리터럴의 문법은 문자열 리터럴과 거의 같지만 ``b`` 접두사가 추가된다는 점이 다릅니다.:"

#: ../Doc/library/stdtypes.rst:2303
msgid "Single quotes: ``b'still allows embedded \"double\" quotes'``"
msgstr "작은따옴표: ``b'still allows embedded \"double\" quotes'``"

#: ../Doc/library/stdtypes.rst:2304
msgid "Double quotes: ``b\"still allows embedded 'single' quotes\"``."
msgstr "큰따옴표: ``b\"still allows embedded 'single' quotes\"``."

#: ../Doc/library/stdtypes.rst:2305
msgid ""
"Triple quoted: ``b'''3 single quotes'''``, ``b\"\"\"3 double "
"quotes\"\"\"``"
msgstr "삼중 따옴표: ``b'''3 single quotes'''``, ``b\"\"\"3 double quotes\"\"\"``"

#: ../Doc/library/stdtypes.rst:2307
msgid ""
"Only ASCII characters are permitted in bytes literals (regardless of the "
"declared source code encoding). Any binary values over 127 must be "
"entered into bytes literals using the appropriate escape sequence."
msgstr ""
"바이트열 리터럴에는 ASCII 문자만 허용됩니다 (선언된 소스 코드 인코딩과 관계없습니다). 127 보다 큰 바이너리 값은 적절한 "
"이스케이프 시퀀스를 사용하여 바이트열 리터럴에 입력해야 합니다."

#: ../Doc/library/stdtypes.rst:2311
msgid ""
"As with string literals, bytes literals may also use a ``r`` prefix to "
"disable processing of escape sequences. See :ref:`strings` for more about"
" the various forms of bytes literal, including supported escape "
"sequences."
msgstr ""
"문자열 리터럴의 경우와 마찬가지로 바이트열 리터럴은 이스케이프 시퀀스 처리를 비활성화하기 위해 ``r`` 접두사를 사용할 수도 "
"있습니다. 지원되는 이스케이프 시퀀스를 포함하여 바이트열 리터럴의 다양한 형식에 대한 자세한 내용은 :ref:`strings` 을 "
"참조하십시오."

#: ../Doc/library/stdtypes.rst:2315
msgid ""
"While bytes literals and representations are based on ASCII text, bytes "
"objects actually behave like immutable sequences of integers, with each "
"value in the sequence restricted such that ``0 <= x < 256`` (attempts to "
"violate this restriction will trigger :exc:`ValueError`. This is done "
"deliberately to emphasise that while many binary formats include ASCII "
"based elements and can be usefully manipulated with some text-oriented "
"algorithms, this is not generally the case for arbitrary binary data "
"(blindly applying text processing algorithms to binary data formats that "
"are not ASCII compatible will usually lead to data corruption)."
msgstr ""
"바이트열 리터럴과 그 표현은 ASCII 텍스트를 기반으로 하지만, 바이트열 객체는 실제로는 정수의 불변 시퀀스처럼 동작하고, "
"시퀀스의 각 값은 ``0 <= x < 256`` 이 되도록 제한됩니다 (이 제한을 위반하려고 시도하면 "
":exc:`ValueError` 를 일으킵니다). 이것은 많은 바이너리 형식이 ASCII 기반 요소를 포함하고 일부 텍스트 지향 "
"알고리즘으로 유용하게 조작될 수 있지만, 임의의 바이너리 데이터에 일반적으로 적용될 수는 없음을 강조하기 위한 것입니다 (텍스트 "
"처리 알고리즘을 맹목적으로 ASCII 호환이 아닌 바이너리 데이터 형식에 적용하면 대개 데이터 손상으로 이어집니다)."

#: ../Doc/library/stdtypes.rst:2325
msgid ""
"In addition to the literal forms, bytes objects can be created in a "
"number of other ways:"
msgstr "리터럴 형식 외에도, 바이트열 객체는 여러 가지 다른 방법으로 만들 수 있습니다.:"

#: ../Doc/library/stdtypes.rst:2328
msgid "A zero-filled bytes object of a specified length: ``bytes(10)``"
msgstr "지정된 길이의 0으로 채워진 바이트열 객체: ``bytes(10)``"

#: ../Doc/library/stdtypes.rst:2329
msgid "From an iterable of integers: ``bytes(range(20))``"
msgstr "정수의 이터러블로부터: ``bytes(range(20))``"

#: ../Doc/library/stdtypes.rst:2330
msgid "Copying existing binary data via the buffer protocol:  ``bytes(obj)``"
msgstr "버퍼 프로토콜을 통해 기존 바이너리 데이터 복사: ``bytes(obj)``"

#: ../Doc/library/stdtypes.rst:2332
msgid "Also see the :ref:`bytes <func-bytes>` built-in."
msgstr "내장 :ref:`bytes <func-bytes>` 도 참조하세요."

#: ../Doc/library/stdtypes.rst:2334
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary "
"data. Accordingly, the bytes type has an additional class method to read "
"data in that format:"
msgstr ""
"2개의 16진수는 정확히 하나의 바이트에 대응하기 때문에 16진수는 바이너리 데이터를 설명하는 데 일반적으로 사용되는 형식입니다. "
"따라서, 바이트열 형은 그 형식의 데이터를 읽는 추가의 클래스 메서드를 갖습니다:"

#: ../Doc/library/stdtypes.rst:2340
msgid ""
"This :class:`bytes` class method returns a bytes object, decoding the "
"given string object.  The string must contain two hexadecimal digits per "
"byte, with ASCII whitespace being ignored."
msgstr ""
"이 :class:`bytes` 클래스 메서드는 주어진 문자열 객체를 디코딩해서 바이트열 객체를 돌려줍니다. 문자열은 바이트 당 두 "
"개의 16진수가 포함되어야 하며 ASCII 공백은 무시됩니다."

#: ../Doc/library/stdtypes.rst:2347
msgid ""
":meth:`bytes.fromhex` now skips all ASCII whitespace in the string, not "
"just spaces."
msgstr ""

#: ../Doc/library/stdtypes.rst:2351
msgid ""
"A reverse conversion function exists to transform a bytes object into its"
" hexadecimal representation."
msgstr "바이트열 객체를 16진수 표현으로 변환하기 위한 역변환 함수가 있습니다."

#: ../Doc/library/stdtypes.rst:2356 ../Doc/library/stdtypes.rst:2432
msgid ""
"Return a string object containing two hexadecimal digits for each byte in"
" the instance."
msgstr "인스턴스의 바이트마다 2 자릿수의 16진수로 표현한 문자열 객체를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2364
msgid ""
"Since bytes objects are sequences of integers (akin to a tuple), for a "
"bytes object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will be a"
" bytes object of length 1.  (This contrasts with text strings, where both"
" indexing and slicing will produce a string of length 1)"
msgstr ""
"바이트열 객체는 정수의 시퀀스(튜플과 유사)이기 때문에, 바이트열 객체 *b* 에 대해서, ``b[0]`` 는 정수가 됩니다. "
"반면, ``b[0:1]`` 는 길이 1인 바이트열 객체가 됩니다. (이것은 인덱싱과 슬라이싱 모두 길이 1인 문자열을 생성하는 "
"텍스트 문자열과 대조됩니다)"

#: ../Doc/library/stdtypes.rst:2369
msgid ""
"The representation of bytes objects uses the literal format (``b'...'``) "
"since it is often more useful than e.g. ``bytes([46, 46, 46])``.  You can"
" always convert a bytes object into a list of integers using ``list(b)``."
msgstr ""
"바이트열 객체의 표현은 리터럴 형식 (``b'...'``) 을 사용하는데, 종종 ``bytes([46, 46, 46])`` 보다 "
"유용하기 때문입니다. ``list(b)`` 를 사용하면 바이트열 객체를 항상 정수 리스트로 변환할 수 있습니다."

#: ../Doc/library/stdtypes.rst:2374
msgid ""
"For Python 2.x users: In the Python 2.x series, a variety of implicit "
"conversions between 8-bit strings (the closest thing 2.x offers to a "
"built-in binary data type) and Unicode strings were permitted. This was a"
" backwards compatibility workaround to account for the fact that Python "
"originally only supported 8-bit text, and Unicode text was a later "
"addition. In Python 3.x, those implicit conversions are gone - "
"conversions between 8-bit binary data and Unicode text must be explicit, "
"and bytes and string objects will always compare unequal."
msgstr ""
"파이썬 2.x 사용자에게: 파이썬 2.x 시리즈에서는 8-비트 문자열(2.x가 내장 바이너리 데이터형에 제공하는 가장 가까운 것)과"
" 유니코드 문자열 간의 다양한 묵시적 변환이 허용되었습니다. 이는 파이썬이 원래 8-비트 텍스트만 지원했으며 유니코드 텍스트는 "
"나중에 추가된 사실을 반영하는 하위 호환성 해결책입니다. 파이썬 3.x 에서, 이러한 묵시적 변환은 사라졌습니다 - 8-비트 "
"바이너리 데이터와 유니코드 텍스트 간의 변환은 반드시 명시적이어야 하며 바이트열과 문자열 객체는 항상 다르다고 비교됩니다."

#: ../Doc/library/stdtypes.rst:2387
msgid "Bytearray Objects"
msgstr "바이트 배열 객체"

#: ../Doc/library/stdtypes.rst:2391
msgid ""
":class:`bytearray` objects are a mutable counterpart to :class:`bytes` "
"objects."
msgstr ":class:`bytearray` 객체는 :class:`bytes` 객체의 가변형입니다."

#: ../Doc/library/stdtypes.rst:2396
msgid ""
"There is no dedicated literal syntax for bytearray objects, instead they "
"are always created by calling the constructor:"
msgstr "바이트 배열 객체에 대한 전용 리터럴 문법은 없으며 항상 생성자를 호출하여 만듭니다:"

#: ../Doc/library/stdtypes.rst:2399
msgid "Creating an empty instance: ``bytearray()``"
msgstr "빈 인스턴스 만들기: ``bytearray()``"

#: ../Doc/library/stdtypes.rst:2400
msgid "Creating a zero-filled instance with a given length: ``bytearray(10)``"
msgstr "주어진 길이의 0으로 채워진 인스턴스 만들기: ``bytearray(10)``"

#: ../Doc/library/stdtypes.rst:2401
msgid "From an iterable of integers: ``bytearray(range(20))``"
msgstr "정수의 이터러블로부터: ``bytearray(range(20))``"

#: ../Doc/library/stdtypes.rst:2402
msgid ""
"Copying existing binary data via the buffer protocol:  "
"``bytearray(b'Hi!')``"
msgstr "버퍼 프로토콜을 통해 기존 바이너리 데이터 복사: ``bytearray(b'Hi!')``"

#: ../Doc/library/stdtypes.rst:2404
msgid ""
"As bytearray objects are mutable, they support the :ref:`mutable "
"<typesseq-mutable>` sequence operations in addition to the common bytes "
"and bytearray operations described in :ref:`bytes-methods`."
msgstr ""
"바이트 배열 객체는 가변이기 때문에, :ref:`bytes-methods` 에 설명되어있는 공통 바이트열과 바이트 배열 연산에 "
"더해, :ref:`가변 <typesseq-mutable>` 시퀀스 연산도 지원합니다."

#: ../Doc/library/stdtypes.rst:2408
msgid "Also see the :ref:`bytearray <func-bytearray>` built-in."
msgstr "내장 :ref:`bytearray <func-bytearray>` 도 참조하세요."

#: ../Doc/library/stdtypes.rst:2410
msgid ""
"Since 2 hexadecimal digits correspond precisely to a single byte, "
"hexadecimal numbers are a commonly used format for describing binary "
"data. Accordingly, the bytearray type has an additional class method to "
"read data in that format:"
msgstr ""
"2개의 16진수는 정확히 하나의 바이트에 대응하기 때문에 16진수는 바이너리 데이터를 설명하는 데 일반적으로 사용되는 형식입니다. "
"따라서, 바이트 배열형은 그 형식의 데이터를 읽는 추가의 클래스 메서드를 갖습니다:"

#: ../Doc/library/stdtypes.rst:2416
msgid ""
"This :class:`bytearray` class method returns bytearray object, decoding "
"the given string object.  The string must contain two hexadecimal digits "
"per byte, with ASCII whitespace being ignored."
msgstr ""
"이 :class:`bytearray` 클래스 메서드는 주어진 문자열 객체를 디코딩해서 바이트 배열 객체를 돌려줍니다. 문자열은 "
"바이트 당 두 개의 16진수가 포함되어야 하며 ASCII 공백은 무시됩니다."

#: ../Doc/library/stdtypes.rst:2423
msgid ""
":meth:`bytearray.fromhex` now skips all ASCII whitespace in the string, "
"not just spaces."
msgstr ""

#: ../Doc/library/stdtypes.rst:2427
msgid ""
"A reverse conversion function exists to transform a bytearray object into"
" its hexadecimal representation."
msgstr "바이트 배열 객체를 16진수 표현으로 변환하기 위한 역변환 함수가 있습니다."

#: ../Doc/library/stdtypes.rst:2440
msgid ""
"Since bytearray objects are sequences of integers (akin to a list), for a"
" bytearray object *b*, ``b[0]`` will be an integer, while ``b[0:1]`` will"
" be a bytearray object of length 1.  (This contrasts with text strings, "
"where both indexing and slicing will produce a string of length 1)"
msgstr ""
"바이트 배열 객체는 정수의 시퀀스(리스트와 유사)이기 때문에, 바이트 배열 객체 *b* 에 대해서, ``b[0]`` 는 정수가 "
"됩니다. 반면, ``b[0:1]`` 는 길이 1인 바이트 배열 객체가 됩니다. (이것은 인덱싱과 슬라이싱 모두 길이 1인 문자열을 "
"생성하는 텍스트 문자열과 대조됩니다)"

#: ../Doc/library/stdtypes.rst:2445
msgid ""
"The representation of bytearray objects uses the bytes literal format "
"(``bytearray(b'...')``) since it is often more useful than e.g. "
"``bytearray([46, 46, 46])``.  You can always convert a bytearray object "
"into a list of integers using ``list(b)``."
msgstr ""
"바이트 배열 객체의 표현은 바이트열 리터럴 형식 (``bytearray(b'...')``) 을 사용하는데, 종종 "
"``bytearray([46, 46, 46])`` 보다 유용하기 때문입니다. ``list(b)`` 를 사용하면 바이트 배열 객체를 "
"항상 정수 리스트로 변환할 수 있습니다."

#: ../Doc/library/stdtypes.rst:2454
msgid "Bytes and Bytearray Operations"
msgstr "바이트열 과 바이트 배열 연산"

#: ../Doc/library/stdtypes.rst:2459
msgid ""
"Both bytes and bytearray objects support the :ref:`common <typesseq-"
"common>` sequence operations. They interoperate not just with operands of"
" the same type, but with any :term:`bytes-like object`. Due to this "
"flexibility, they can be freely mixed in operations without causing "
"errors. However, the return type of the result may depend on the order of"
" operands."
msgstr ""
"바이트열와 바이트 배열 객체는 :ref:`공통 <typesseq-common>` 시퀀스 연산을 지원합니다. 이것들은 같은 형의 "
"피연산자뿐만 아니라 모든 :term:`bytes-like object`\\와 상호 운용됩니다. 이러한 유연성으로 인해, 오류 없이 "
"작업을 자유롭게 혼합할 수 있습니다. 그러나, 결과의 반환형은 피연산자의 순서에 따라 달라질 수 있습니다."

#: ../Doc/library/stdtypes.rst:2467
msgid ""
"The methods on bytes and bytearray objects don't accept strings as their "
"arguments, just as the methods on strings don't accept bytes as their "
"arguments.  For example, you have to write::"
msgstr ""
"바이트열 및 바이트 배열 객체의 메서드는 인자로 문자열을 받아들이지 않습니다, 문자열의 메서드가 바이트열을 인자로 허용하지 않는 "
"것과 마찬가지입니다. 예를 들어, 다음과 같이 작성해야 합니다::"

#: ../Doc/library/stdtypes.rst:2474
msgid "and::"
msgstr "그리고::"

#: ../Doc/library/stdtypes.rst:2479
msgid ""
"Some bytes and bytearray operations assume the use of ASCII compatible "
"binary formats, and hence should be avoided when working with arbitrary "
"binary data. These restrictions are covered below."
msgstr ""
"일부 바이트열 및 바이트 배열 연산은 ASCII 호환 바이너리 형식을 가정하므로, 임의의 바이너리 데이터로 작업 할 때는 피해야 "
"합니다. 이러한 제한 사항은 아래에서 다룹니다."

#: ../Doc/library/stdtypes.rst:2484
msgid ""
"Using these ASCII based operations to manipulate binary data that is not "
"stored in an ASCII based format may lead to data corruption."
msgstr ""
"이러한 ASCII 기반 연산을 사용하여 ASCII 기반 형식으로 저장되지 않은 바이너리 데이터를 조작하면 데이터가 손상될 수 "
"있습니다."

#: ../Doc/library/stdtypes.rst:2487
msgid ""
"The following methods on bytes and bytearray objects can be used with "
"arbitrary binary data."
msgstr "바이트열 및 바이트 배열 객체에 대한 다음 메서드는 임의의 바이너리 데이터와 함께 사용할 수 있습니다."

#: ../Doc/library/stdtypes.rst:2493
msgid ""
"Return the number of non-overlapping occurrences of subsequence *sub* in "
"the range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"범위 [*start*, *end*] 에서 서브 시퀀스 *sub* 가 중첩되지 않고 등장하는 횟수를 돌려줍니다. 선택적 인자 "
"*start* 와 *end* 는 슬라이스 표기법으로 해석됩니다."

#: ../Doc/library/stdtypes.rst:2497 ../Doc/library/stdtypes.rst:2544
#: ../Doc/library/stdtypes.rst:2566 ../Doc/library/stdtypes.rst:2632
#: ../Doc/library/stdtypes.rst:2645
msgid ""
"The subsequence to search for may be any :term:`bytes-like object` or an "
"integer in the range 0 to 255."
msgstr "검색할 서브 시퀀스는 임의의 :term:`bytes-like object` 또는 0에서 255 사이의 정수일 수 있습니다."

#: ../Doc/library/stdtypes.rst:2500 ../Doc/library/stdtypes.rst:2556
#: ../Doc/library/stdtypes.rst:2569 ../Doc/library/stdtypes.rst:2635
#: ../Doc/library/stdtypes.rst:2648
msgid "Also accept an integer in the range 0 to 255 as the subsequence."
msgstr "서브 시퀀스로 0에서 255 사이의 정수도 허용합니다."

#: ../Doc/library/stdtypes.rst:2507
msgid ""
"Return a string decoded from the given bytes.  Default encoding is "
"``'utf-8'``. *errors* may be given to set a different error handling "
"scheme.  The default for *errors* is ``'strict'``, meaning that encoding "
"errors raise a :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'`` and any other name registered via "
":func:`codecs.register_error`, see section :ref:`error-handlers`. For a "
"list of possible encodings, see section :ref:`standard-encodings`."
msgstr ""
"주어진 바이트열로부터 디코딩된 문자열을 돌려줍니다. 기본 인코딩은 ``'utf-8'`` 입니다. *errors* 는 다른 오류 처리"
" 방식을 설정하기 위해 제공될 수 있습니다. *errors* 의 기본값은 ``'strict'`` 인데, 인코딩 오류가 있으면 "
":exc:`UnicodeError` 를 일으키라는 뜻입니다. 다른 가능한 값은 ``'ignore'``, ``'replace'`` 와"
" :func:`codecs.register_error` 를 통해 등록된 다른 이름들입니다. :ref:`error-"
"handlers`\\를 보세요. 가능한 인코딩의 목록을 보려면 :ref:`standard-encodings` 섹션을 참조하십시오."

#: ../Doc/library/stdtypes.rst:2517
msgid ""
"Passing the *encoding* argument to :class:`str` allows decoding any :term"
":`bytes-like object` directly, without needing to make a temporary bytes "
"or bytearray object."
msgstr ""
"*encoding* 인자를 :class:`str` 에 전달하면 임시 바이트열이나 바이트 배열 객체를 만들 필요 없이 임의의 "
":term:`bytes-like object` 를 직접 디코딩할 수 있습니다."

#: ../Doc/library/stdtypes.rst:2521
msgid "Added support for keyword arguments."
msgstr "키워드 인자 지원이 추가되었습니다."

#: ../Doc/library/stdtypes.rst:2528
msgid ""
"Return ``True`` if the binary data ends with the specified *suffix*, "
"otherwise return ``False``.  *suffix* can also be a tuple of suffixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"바이너리 데이터가 지정된 *suffix* 로 끝나면 ``True`` 를 돌려주고, 그렇지 않으면 ``False`` 를 돌려줍니다. "
"*suffix* 는 찾고자 하는 접미사들의 튜플이 될 수도 있습니다. 선택적 *start* 가 제공되면 그 위치에서 검사를 "
"시작합니다. 선택적 *end* 를 사용하면 해당 위치에서 비교를 중단합니다."

#: ../Doc/library/stdtypes.rst:2533
msgid "The suffix(es) to search for may be any :term:`bytes-like object`."
msgstr "검색할 접미사(들)는 임의의 :term:`bytes-like object` 일 수 있습니다."

#: ../Doc/library/stdtypes.rst:2539
msgid ""
"Return the lowest index in the data where the subsequence *sub* is found,"
" such that *sub* is contained in the slice ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation.  Return"
" ``-1`` if *sub* is not found."
msgstr ""
"서브 시퀀스 *sub* 가 슬라이스 ``s[start:end]`` 내에 등장하는 가장 작은 데이터의 인덱스를 돌려줍니다. 선택적 "
"인자 *start* 와 *end* 는 슬라이스 표기법으로 해석됩니다. *sub* 가 없으면 ``-1`` 을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2549
msgid ""
"The :meth:`~bytes.find` method should be used only if you need to know "
"the position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""
":meth:`~bytes.find` 메서드는 *sub* 의 위치를 ​​알아야 할 경우에만 사용해야 합니다. *sub* 가 서브 "
"시퀀스인지 여부를 확인하려면 :keyword:`in` 연산자를 사용하십시오::"

#: ../Doc/library/stdtypes.rst:2563
msgid ""
"Like :meth:`~bytes.find`, but raise :exc:`ValueError` when the "
"subsequence is not found."
msgstr ":meth:`~bytes.find` 과 비슷하지만, 서브 시퀀스를 찾을 수 없는 경우 :exc:`ValueError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:2576
msgid ""
"Return a bytes or bytearray object which is the concatenation of the "
"binary data sequences in *iterable*.  A :exc:`TypeError` will be raised "
"if there are any values in *iterable* that are not :term:`bytes-like "
"objects <bytes-like object>`, including :class:`str` objects.  The "
"separator between elements is the contents of the bytes or bytearray "
"object providing this method."
msgstr ""
"*iterable* 의 바이너리 데이터 시퀀스들을 이어 붙이기 한 바이트열 또는 바이트 배열 객체를 돌려줍니다. *iterable*"
" 에 :class:`str` 객체나 기타 :term:`bytes-like object` 가 아닌 값이 있으면 "
":exc:`TypeError` 를 일으킵니다. 요소들 사이의 구분자는 이 메서드를 제공하는 바이트열 이나 바이트 배열 객체입니다."

#: ../Doc/library/stdtypes.rst:2587
msgid ""
"This static method returns a translation table usable for "
":meth:`bytes.translate` that will map each character in *from* into the "
"character at the same position in *to*; *from* and *to* must both be "
":term:`bytes-like objects <bytes-like object>` and have the same length."
msgstr ""
"이 정적 메서드는 :meth:`bytes.translate` 에 사용할 수 있는 변환표를 돌려주는데, *from* 에 있는 문자를 "
"*to* 의 같은 위치에 있는 문자로 매핑합니다; *from* 과 *to* 는 모두 :term:`bytes-like object` "
"여야 하고 길이가 같아야 합니다."

#: ../Doc/library/stdtypes.rst:2598
msgid ""
"Split the sequence at the first occurrence of *sep*, and return a 3-tuple"
" containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not"
" found, return a 3-tuple containing a copy of the original sequence, "
"followed by two empty bytes or bytearray objects."
msgstr ""
"*sep* 가 처음 나타나는 위치에서 시퀀스를 나누고, 구분자 앞에 있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 "
"3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 원래 시퀀스의 복사본과 그 뒤를 따르는 두 개의 빈 바이트열 또는 바이트 배열 "
"객체로 구성된 3-튜플을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2605 ../Doc/library/stdtypes.rst:2662
msgid "The separator to search for may be any :term:`bytes-like object`."
msgstr "검색할 구분자는 임의의 :term:`bytes-like object` 일 수 있습니다."

#: ../Doc/library/stdtypes.rst:2611
msgid ""
"Return a copy of the sequence with all occurrences of subsequence *old* "
"replaced by *new*.  If the optional argument *count* is given, only the "
"first *count* occurrences are replaced."
msgstr ""
"모든 서브 시퀀스 *old* 가 *new* 로 치환된 시퀀스의 복사본을 돌려줍니다. 선택적 인자 *count* 가 주어지면, 앞의 "
"*count* 개만 치환됩니다."

#: ../Doc/library/stdtypes.rst:2615
msgid ""
"The subsequence to search for and its replacement may be any :term"
":`bytes-like object`."
msgstr "검색할 서브 시퀀스와 그 대체물은 임의의 :term:`bytes-like object` 일 수 있습니다."

#: ../Doc/library/stdtypes.rst:2620 ../Doc/library/stdtypes.rst:2713
#: ../Doc/library/stdtypes.rst:2727 ../Doc/library/stdtypes.rst:2751
#: ../Doc/library/stdtypes.rst:2765 ../Doc/library/stdtypes.rst:2800
#: ../Doc/library/stdtypes.rst:2870 ../Doc/library/stdtypes.rst:2888
#: ../Doc/library/stdtypes.rst:2916 ../Doc/library/stdtypes.rst:3055
#: ../Doc/library/stdtypes.rst:3110 ../Doc/library/stdtypes.rst:3153
#: ../Doc/library/stdtypes.rst:3174 ../Doc/library/stdtypes.rst:3196
#: ../Doc/library/stdtypes.rst:3388
msgid ""
"The bytearray version of this method does *not* operate in place - it "
"always produces a new object, even if no changes were made."
msgstr "이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* - 변경되지 않는 경우조차 항상 새 객체를 만듭니다."

#: ../Doc/library/stdtypes.rst:2627
msgid ""
"Return the highest index in the sequence where the subsequence *sub* is "
"found, such that *sub* is contained within ``s[start:end]``.  Optional "
"arguments *start* and *end* are interpreted as in slice notation. Return "
"``-1`` on failure."
msgstr ""
"서브 시퀀스 *sub* 가 ``s[start:end]`` 내에 등장하는 가장 큰 시퀀스의 인덱스를 돌려줍니다. 선택적 인자 "
"*start* 와 *end* 는 슬라이스 표기법으로 해석됩니다. 실패하면 ``-1`` 을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2642
msgid ""
"Like :meth:`~bytes.rfind` but raises :exc:`ValueError` when the "
"subsequence *sub* is not found."
msgstr ""
":meth:`~bytes.rfind` 와 비슷하지만, 서브 시퀀스 *sub* 를 찾을 수 없는 경우 :exc:`ValueError`"
" 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:2655
msgid ""
"Split the sequence at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself or its "
"bytearray copy, and the part after the separator. If the separator is not"
" found, return a 3-tuple containing a copy of the original sequence, "
"followed by two empty bytes or bytearray objects."
msgstr ""
"*sep* 가 마지막으로 나타나는 위치에서 시퀀스를 나누고, 구분자 앞에 있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 "
"구성된 3-튜플을 돌려줍니다. 구분자가 발견되지 않으면, 두 개의 빈 바이트열 또는 바이트 배열 객체와 그 뒤를 따르는 원래 "
"시퀀스의 복사본으로 구성된 3-튜플을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2668
msgid ""
"Return ``True`` if the binary data starts with the specified *prefix*, "
"otherwise return ``False``.  *prefix* can also be a tuple of prefixes to "
"look for.  With optional *start*, test beginning at that position.  With "
"optional *end*, stop comparing at that position."
msgstr ""
"바이너리 데이터가 지정된 *prefix* 로 시작하면 ``True`` 를 돌려주고, 그렇지 않으면 ``False`` 를 돌려줍니다."
" *prefix* 는 찾고자 하는 접두사들의 튜플이 될 수도 있습니다. 선택적 *start* 가 제공되면 그 위치에서 검사를 "
"시작합니다. 선택적 *end* 를 사용하면 해당 위치에서 비교를 중단합니다."

#: ../Doc/library/stdtypes.rst:2673
msgid "The prefix(es) to search for may be any :term:`bytes-like object`."
msgstr "검색할 접두사(들)는 임의의 :term:`bytes-like object` 일 수 있습니다."

#: ../Doc/library/stdtypes.rst:2679
msgid ""
"Return a copy of the bytes or bytearray object where all bytes occurring "
"in the optional argument *delete* are removed, and the remaining bytes "
"have been mapped through the given translation table, which must be a "
"bytes object of length 256."
msgstr ""
"생략 가능한 인자 *delete* 의 모든 바이트를 제거하고, 나머지 바이트들을 주어진 변환표로 매핑한 바이트열이나 바이트 배열 "
"객체의 복사본을 돌려줍니다. table은 길이 256인 바이트열 객체이어야 합니다."

#: ../Doc/library/stdtypes.rst:2684
msgid ""
"You can use the :func:`bytes.maketrans` method to create a translation "
"table."
msgstr ":func:`bytes.maketrans` 메서드를 사용하여 변환표를 만들 수 있습니다."

#: ../Doc/library/stdtypes.rst:2687
msgid ""
"Set the *table* argument to ``None`` for translations that only delete "
"characters::"
msgstr "문자를 지우기만 하는 변환에는 *table* 인자를 ``None`` 으로 설정하십시오::"

#: ../Doc/library/stdtypes.rst:2693
msgid "*delete* is now supported as a keyword argument."
msgstr "이제 *delete* 는 키워드 인자로 지원됩니다."

#: ../Doc/library/stdtypes.rst:2697
msgid ""
"The following methods on bytes and bytearray objects have default "
"behaviours that assume the use of ASCII compatible binary formats, but "
"can still be used with arbitrary binary data by passing appropriate "
"arguments. Note that all of the bytearray methods in this section do "
"*not* operate in place, and instead produce new objects."
msgstr ""
"바이트열 및 바이트 배열 객체에 대한 다음 메서드는 ASCII 호환 바이너리 형식의 사용을 가정하는 기본 동작을 갖지만, 적절한 "
"인자를 전달하여 임의의 바이너리 데이터와 함께 사용할 수 있습니다. 이 섹션의 바이트 배열 메서드는 모두 제자리에서 작동하지 않고 "
"대신 새로운 객체를 생성함에 주의하십시오."

#: ../Doc/library/stdtypes.rst:2706
msgid ""
"Return a copy of the object centered in a sequence of length *width*. "
"Padding is done using the specified *fillbyte* (default is an ASCII "
"space). For :class:`bytes` objects, the original sequence is returned if "
"*width* is less than or equal to ``len(s)``."
msgstr ""
"길이 *width* 인 시퀀스의 가운데에 정렬한 객체의 복사본을 돌려줍니다. 지정된 *fillbyte* (기본값은 ASCII "
"스페이스)를 사용하여 채웁니다. :class:`bytes` 객체의 경우, *width* 가 ``len(s)`` 보다 작거나 같은 "
"경우 원래 시퀀스가 반환됩니다."

#: ../Doc/library/stdtypes.rst:2720
msgid ""
"Return a copy of the object left justified in a sequence of length "
"*width*. Padding is done using the specified *fillbyte* (default is an "
"ASCII space). For :class:`bytes` objects, the original sequence is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"왼쪽으로 정렬된 객체의 복사본을 길이 *width* 인 시퀀스로 돌려줍니다. 지정된 *fillbyte* (기본값은 ASCII "
"스페이스)을 사용하여 채웁니다. :class:`bytes` 객체의 경우, *width* 가 ``len(s)`` 보다 작거나 같은 "
"경우 원래 시퀀스가 반환됩니다."

#: ../Doc/library/stdtypes.rst:2734
msgid ""
"Return a copy of the sequence with specified leading bytes removed.  The "
"*chars* argument is a binary sequence specifying the set of byte values "
"to be removed - the name refers to the fact this method is usually used "
"with ASCII characters.  If omitted or ``None``, the *chars* argument "
"defaults to removing ASCII whitespace.  The *chars* argument is not a "
"prefix; rather, all combinations of its values are stripped::"
msgstr ""
"선행 바이트가 제거된 시퀀스의 복사본을 돌려줍니다. *chars* 인자는 제거할 바이트 집합을 지정하는 바이너리 시퀀스입니다 - "
"이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 ``None`` 이라면, *chars* 인자의 "
"기본값은 ASCII 공백을 제거하도록 합니다. *chars* 인자는 접두사가 아닙니다; 모든 값 조합이 제거됩니다::"

#: ../Doc/library/stdtypes.rst:2746 ../Doc/library/stdtypes.rst:2795
#: ../Doc/library/stdtypes.rst:2865
msgid ""
"The binary sequence of byte values to remove may be any :term:`bytes-like"
" object`."
msgstr "제거할 바이트 값의 바이너리 시퀀스는 임의의 :term:`bytes-like object` 일 수 있습니다."

#: ../Doc/library/stdtypes.rst:2758
msgid ""
"Return a copy of the object right justified in a sequence of length "
"*width*. Padding is done using the specified *fillbyte* (default is an "
"ASCII space). For :class:`bytes` objects, the original sequence is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""
"오른쪽으로 정렬된 객체의 복사본을 길이 *width* 인 시퀀스로 돌려줍니다. 지정된 *fillbyte* (기본값은 ASCII "
"스페이스)를 사용하여 채웁니다. :class:`bytes` 객체의 경우, *width* 가 ``len(s)`` 보다 작거나 같은 "
"경우 원래 시퀀스가 반환됩니다."

#: ../Doc/library/stdtypes.rst:2772
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep*"
" as the delimiter string. If *maxsplit* is given, at most *maxsplit* "
"splits are done, the *rightmost* ones.  If *sep* is not specified or "
"``None``, any subsequence consisting solely of ASCII whitespace is a "
"separator. Except for splitting from the right, :meth:`rsplit` behaves "
"like :meth:`split` which is described in detail below."
msgstr ""
"*sep* 을 구분자 시퀀스로 사용하여 바이너리 시퀀스를 같은 형의 서브 시퀀스로 나눕니다. *maxsplit* 이 주어지면 가장 "
"오른쪽에서 최대 *maxsplit* 번의 분할이 수행됩니다. *sep* 이 지정되지 않거나 ``None`` 이면, ASCII 공백 "
"문자만으로 이루어진 모든 서브 시퀀스는 구분자입니다. 오른쪽에서 분리하는 것을 제외하면, :meth:`rsplit`\\는 아래에서 "
"자세히 설명될 :meth:`split`\\처럼 동작합니다."

#: ../Doc/library/stdtypes.rst:2783
msgid ""
"Return a copy of the sequence with specified trailing bytes removed.  The"
" *chars* argument is a binary sequence specifying the set of byte values "
"to be removed - the name refers to the fact this method is usually used "
"with ASCII characters.  If omitted or ``None``, the *chars* argument "
"defaults to removing ASCII whitespace.  The *chars* argument is not a "
"suffix; rather, all combinations of its values are stripped::"
msgstr ""
"지정된 후행 바이트가 제거된 시퀀스의 복사본을 돌려줍니다. *chars* 인자는 제거할 바이트 집합을 지정하는 바이너리 시퀀스입니다"
" - 이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 ``None`` 이라면, *chars* "
"인자의 기본값은 ASCII 공백을 제거하도록 합니다. *chars* 인자는 접미사가 아닙니다; 모든 값 조합이 제거됩니다::"

#: ../Doc/library/stdtypes.rst:2807
msgid ""
"Split the binary sequence into subsequences of the same type, using *sep*"
" as the delimiter string. If *maxsplit* is given and non-negative, at "
"most *maxsplit* splits are done (thus, the list will have at most "
"``maxsplit+1`` elements).  If *maxsplit* is not specified or is ``-1``, "
"then there is no limit on the number of splits (all possible splits are "
"made)."
msgstr ""
"*sep* 를 구분자 시퀀스로 사용하여 바이너리 시퀀스를 같은 형의 서브 시퀀스로 나눕니다. *maxsplit* 이 지정되고 음수가"
" 아닌 경우, 최대 *maxsplit* 분할이 수행됩니다 (따라서, 리스트는 최대 ``maxsplit+1`` 개의 요소를 가지게 "
"됩니다). *maxsplit* 이 지정되지 않았거나 ``-1`` 이라면 분할 수에 제한이 없습니다 (가능한 모든 분할이 "
"만들어집니다)."

#: ../Doc/library/stdtypes.rst:2813
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and "
"are deemed to delimit empty subsequences (for example, "
"``b'1,,2'.split(b',')`` returns ``[b'1', b'', b'2']``).  The *sep* "
"argument may consist of a multibyte sequence (for example, "
"``b'1<>2<>3'.split(b'<>')`` returns ``[b'1', b'2', b'3']``). Splitting an"
" empty sequence with a specified separator returns ``[b'']`` or "
"``[bytearray(b'')]`` depending on the type of object being split.  The "
"*sep* argument may be any :term:`bytes-like object`."
msgstr ""
"*sep* 이 주어지면, 연속된 구분자는 묶이지 않고 빈 서브 시퀀스를 구분하는 것으로 간주합니다 (예를 들어, "
"``b'1,,2'.split(b',')`` 는 ``[b'1', b'', b'2']`` 를 돌려줍니다). *sep* 인자는 멀티바이트"
" 시퀀스로 구성될 수 있습니다 (예를 들어, ``b'1<>2<>3'.split(b'<>')`` 는 ``[b'1', b'2', "
"b'3']`` 를 돌려줍니다). 지정된 구분자로 빈 시퀀스를 나누면, 나누는 객체의 형에 따라 ``[b'']`` 나 "
"``[bytearray(b'')]`` 를 돌려줍니다. *sep* 인자는 임의의 :term:`bytes-like object` 일 수"
" 있습니다."

#: ../Doc/library/stdtypes.rst:2831
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm"
" is applied: runs of consecutive ASCII whitespace are regarded as a "
"single separator, and the result will contain no empty strings at the "
"start or end if the sequence has leading or trailing whitespace.  "
"Consequently, splitting an empty sequence or a sequence consisting solely"
" of ASCII whitespace without a specified separator returns ``[]``."
msgstr ""
"*sep* 이 지정되지 않거나 ``None`` 이면, 다른 분할 알고리즘이 적용됩니다: 연속된 ASCII 공백 문자는 단일한 "
"구분자로 간주하고, 시퀀스가 선행이나 후행 공백을 포함해도 결과는 시작과 끝에 빈 시퀀스를 포함하지 않습니다. 결과적으로, 빈 "
"시퀀스나 ASCII 공백만으로 구성된 시퀀스를 ``None`` 구분자로 나누면 ``[]`` 를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2852
msgid ""
"Return a copy of the sequence with specified leading and trailing bytes "
"removed. The *chars* argument is a binary sequence specifying the set of "
"byte values to be removed - the name refers to the fact this method is "
"usually used with ASCII characters.  If omitted or ``None``, the *chars* "
"argument defaults to removing ASCII whitespace. The *chars* argument is "
"not a prefix or suffix; rather, all combinations of its values are "
"stripped::"
msgstr ""
"선행과 후행 바이트가 제거된 시퀀스의 복사본을 돌려줍니다. *chars* 인자는 제거할 바이트 집합을 지정하는 바이너리 시퀀스입니다"
" - 이름은 이 메서드가 보통 ASCII 문자와 사용된다는 사실을 반영합니다. 생략되거나 ``None`` 이라면, *chars* "
"인자의 기본값은 ASCII 공백을 제거하도록 합니다. *chars* 인자는 접두사나 접미사가 아닙니다; 모든 값 조합이 "
"제거됩니다::"

#: ../Doc/library/stdtypes.rst:2874
msgid ""
"The following methods on bytes and bytearray objects assume the use of "
"ASCII compatible binary formats and should not be applied to arbitrary "
"binary data. Note that all of the bytearray methods in this section do "
"*not* operate in place, and instead produce new objects."
msgstr ""
"바이트열 및 바이트 배열 객체에 대한 다음 메서드는 ASCII 호환 바이너리 형식의 사용을 가정하며 임의의 바이너리 데이터에 "
"적용하면 안 됩니다. 이 섹션의 바이트 배열 메서드는 모두 제자리에서 작동하지 *않고* 대신 새로운 객체를 생성합니다."

#: ../Doc/library/stdtypes.rst:2882
msgid ""
"Return a copy of the sequence with each byte interpreted as an ASCII "
"character, and the first byte capitalized and the rest lowercased. Non-"
"ASCII byte values are passed through unchanged."
msgstr ""
"각 바이트가 ASCII 문자로 해석되고 첫 번째 바이트는 대문자로, 나머지는 소문자로 만든 시퀀스의 복사본을 돌려줍니다. ASCII"
" 바이트가 아닌 값들은 변경되지 않고 전달됩니다."

#: ../Doc/library/stdtypes.rst:2895
msgid ""
"Return a copy of the sequence where all ASCII tab characters are replaced"
" by one or more ASCII spaces, depending on the current column and the "
"given tab size.  Tab positions occur every *tabsize* bytes (default is 8,"
" giving tab positions at columns 0, 8, 16 and so on).  To expand the "
"sequence, the current column is set to zero and the sequence is examined "
"byte by byte.  If the byte is an ASCII tab character (``b'\\t'``), one or"
" more space characters are inserted in the result until the current "
"column is equal to the next tab position. (The tab character itself is "
"not copied.)  If the current byte is an ASCII newline (``b'\\n'``) or "
"carriage return (``b'\\r'``), it is copied and the current column is "
"reset to zero.  Any other byte value is copied unchanged and the current "
"column is incremented by one regardless of how the byte value is "
"represented when printed::"
msgstr ""
"모든 ASCII 탭 문자들을 현재의 열과 주어진 탭 크기에 따라 하나나 그 이상의 ASCII 스페이스로 치환한 시퀀스의 복사본을 "
"돌려줍니다. 탭 위치는 *tabsize* 바이트마다 발생합니다 (기본값은 8이고, 열 0, 8, 16 등에 탭 위치를 지정합니다)."
" 시퀀스를 확장하기 위해 현재 열이 0으로 설정되고 시퀀스를 바이트 단위로 검사합니다. 바이트가 ASCII 탭 문자 "
"(``b'\\t'``) 이면, 현재 열이 다음 탭 위치와 같아질 때까지 하나 이상의 스페이스 문자가 삽입됩니다. (탭 문자 자체는 "
"복사되지 않습니다.) 현재 바이트가 ASCII 개행 문자 (``b'\\n'``) 또는 캐리지 리턴 (``b'\\r'``) 이면 "
"복사되고 현재 열은 0으로 재설정됩니다. 다른 바이트는 변경되지 않고 복사되고 현재 열은 인쇄할 때 바이트가 어떻게 표시되는지에 "
"관계없이 1씩 증가합니다."

#: ../Doc/library/stdtypes.rst:2923
msgid ""
"Return true if all bytes in the sequence are alphabetical ASCII "
"characters or ASCII decimal digits and the sequence is not empty, false "
"otherwise. Alphabetic ASCII characters are those byte values in the "
"sequence ``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``. "
"ASCII decimal digits are those byte values in the sequence "
"``b'0123456789'``."
msgstr ""
"시퀀스의 모든 바이트가 알파벳 ASCII 문자 또는 ASCII 십진수이고 시퀀스가 ​​비어 있지 않으면 참을 돌려주고 그렇지 않으면"
" 거짓을 돌려줍니다. 알파벳 ASCII 문자는, 시퀀스 "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` 에 있는 바이트 "
"값입니다. ASCII 십진수는 시퀀스 ``b'0123456789'`` 에 있는 바이트 값입니다."

#: ../Doc/library/stdtypes.rst:2940
msgid ""
"Return true if all bytes in the sequence are alphabetic ASCII characters "
"and the sequence is not empty, false otherwise.  Alphabetic ASCII "
"characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"시퀀스의 모든 바이트가 알파벳 ASCII 문자이고 시퀀스가 ​​비어 있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. "
"알파벳 ASCII 문자는, 시퀀스 "
"``b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`` 에 있는 바이트 "
"값입니다."

#: ../Doc/library/stdtypes.rst:2956
msgid ""
"Return true if the sequence is empty or all bytes in the sequence are "
"ASCII, false otherwise. ASCII bytes are in the range 0-0x7F."
msgstr ""

#: ../Doc/library/stdtypes.rst:2966
msgid ""
"Return true if all bytes in the sequence are ASCII decimal digits and the"
" sequence is not empty, false otherwise. ASCII decimal digits are those "
"byte values in the sequence ``b'0123456789'``."
msgstr ""
"시퀀스의 모든 바이트가 ASCII 십진수이며 시퀀스가 ​​비어 있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. "
"ASCII 십진수는 시퀀스 ``b'0123456789'`` 에 있는 바이트 값입니다."

#: ../Doc/library/stdtypes.rst:2981
msgid ""
"Return true if there is at least one lowercase ASCII character in the "
"sequence and no uppercase ASCII characters, false otherwise."
msgstr "시퀀스에 적어도 하나의 ASCII 소문자가 있고, ASCII 대문자가 없으면 참을, 그렇지 않으면 거짓을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:2991 ../Doc/library/stdtypes.rst:3033
#: ../Doc/library/stdtypes.rst:3049 ../Doc/library/stdtypes.rst:3099
#: ../Doc/library/stdtypes.rst:3168
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those "
"byte values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``."
msgstr ""
"ASCII 소문자는 시퀀스 ``b'abcdefghijklmnopqrstuvwxyz'`` 에 있는 바이트 값입니다. ASCII "
"대문자는, 시퀀스 ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` 에 있는 바이트 값입니다."

#: ../Doc/library/stdtypes.rst:2999
msgid ""
"Return true if all bytes in the sequence are ASCII whitespace and the "
"sequence is not empty, false otherwise.  ASCII whitespace characters are "
"those byte values in the sequence ``b' \\t\\n\\r\\x0b\\f'`` (space, tab, "
"newline, carriage return, vertical tab, form feed)."
msgstr ""
"시퀀스의 모든 바이트가 ASCII 공백이고, 시퀀스가 ​​비어 있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. "
"ASCII 공백 문자는 시퀀스 ``b' \\t\\n\\r\\x0b\\f'``\\(스페이스, 탭, 줄 바꿈, 캐리지 리턴, 수직 탭,"
" 폼 피드)에 있는 바이트 값입니다."

#: ../Doc/library/stdtypes.rst:3008
msgid ""
"Return true if the sequence is ASCII titlecase and the sequence is not "
"empty, false otherwise. See :meth:`bytes.title` for more details on the "
"definition of \"titlecase\"."
msgstr ""
"시퀀스가 ASCII 제목 케이스고 시퀀스가 비어있지 않으면 참을 돌려주고 그렇지 않으면 거짓을 돌려줍니다. \"제목 케이스\" 의 "
"정의에 대한 자세한 내용은 :meth:`bytes.title` 을 참조하십시오."

#: ../Doc/library/stdtypes.rst:3023
msgid ""
"Return true if there is at least one uppercase alphabetic ASCII character"
" in the sequence and no lowercase ASCII characters, false otherwise."
msgstr "시퀀스에 적어도 하나의 ASCII 대문자가 있고, ASCII 소문자가 없으면 참을, 그렇지 않으면 거짓을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3041
msgid ""
"Return a copy of the sequence with all the uppercase ASCII characters "
"converted to their corresponding lowercase counterpart."
msgstr "모든 ASCII 대문자를 해당 소문자로 변환한 시퀀스의 복사본을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3066
msgid ""
"Return a list of the lines in the binary sequence, breaking at ASCII line"
" boundaries. This method uses the :term:`universal newlines` approach to "
"splitting lines. Line breaks are not included in the resulting list "
"unless *keepends* is given and true."
msgstr ""
"ASCII 줄 경계에서 나눈 바이너리 시퀀스의 줄 리스트를 돌려줍니다. 이 메서드는 줄을 나누는데 :term:`universal "
"newlines` 접근법을 사용합니다. *keepends* 가 참으로 주어지지 않는 한 결과 리스트에 줄 바꿈은 포함되지 않습니다."

#: ../Doc/library/stdtypes.rst:3078
msgid ""
"Unlike :meth:`~bytes.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line "
"break does not result in an extra line::"
msgstr ""
"구분자 시퀀스 *sep* 이 주어졌을 때 :meth:`~bytes.split` 와 달리, 이 메서드는 빈 시퀀스에 대해서 빈 "
"리스트를 돌려주고, 마지막 줄 바꿈은 새 줄을 만들지 않습니다::"

#: ../Doc/library/stdtypes.rst:3091
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart and vice-versa."
msgstr "모든 ASCII 소문자를 해당 대문자로, 그 반대도 마찬가지로 변환한 시퀀스의 복사본을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3103
msgid ""
"Unlike :func:`str.swapcase()`, it is always the case that "
"``bin.swapcase().swapcase() == bin`` for the binary versions. Case "
"conversions are symmetrical in ASCII, even though that is not generally "
"true for arbitrary Unicode code points."
msgstr ""
":func:`str.swapcase()` 와는 달리 바이너리 버전의 경우 항상 ``bin.swapcase().swapcase() "
"== bin`` 이 성립합니다. 임의의 유니코드 포인트에서 일반적으로 성립하지는 않지만, ASCII에서 케이스 변환은 대칭적입니다."

#: ../Doc/library/stdtypes.rst:3117
msgid ""
"Return a titlecased version of the binary sequence where words start with"
" an uppercase ASCII character and the remaining characters are lowercase."
" Uncased byte values are left unmodified."
msgstr ""
"단어가 ASCII 대문자로 시작하고 나머지 문자들은 소문자인 제목 케이스 버전의 바이너리 시퀀스를 돌려줍니다. 케이스 없는 바이트 "
"값은 수정되지 않은 상태로 남습니다."

#: ../Doc/library/stdtypes.rst:3126
msgid ""
"Lowercase ASCII characters are those byte values in the sequence "
"``b'abcdefghijklmnopqrstuvwxyz'``. Uppercase ASCII characters are those "
"byte values in the sequence ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'``. All other "
"byte values are uncased."
msgstr ""
"ASCII 소문자는 시퀀스 ``b'abcdefghijklmnopqrstuvwxyz'`` 에 있는 바이트 값입니다. ASCII "
"대문자는 시퀀스 ``b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`` 에 있는 바이트 값입니다. 다른 모든 바이트 값은 "
"케이스가 없습니다."

#: ../Doc/library/stdtypes.rst:3160
msgid ""
"Return a copy of the sequence with all the lowercase ASCII characters "
"converted to their corresponding uppercase counterpart."
msgstr "모든 ASCII 소문자를 해당 대문자로 변환한 시퀀스의 복사본을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3181
msgid ""
"Return a copy of the sequence left filled with ASCII ``b'0'`` digits to "
"make a sequence of length *width*. A leading sign prefix (``b'+'``/ "
"``b'-'`` is handled by inserting the padding *after* the sign character "
"rather than before. For :class:`bytes` objects, the original sequence is "
"returned if *width* is less than or equal to ``len(seq)``."
msgstr ""
"길이가 *width* 인 시퀀스를 만들기 위해 ASCII ``b'0'`` 문자를 왼쪽에 채운 시퀀스의 복사본을 돌려줍니다. 선행 "
"부호 접두어(``b'+'``/``b'-'``)는 부호 문자의 앞이 아니라 *뒤* 에 채우는 것으로 처리됩니다. "
":class:`bytes` 객체의 경우, *width* 가 ``len(s)`` 보다 작거나 같은 경우 원래 시퀀스를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3203
msgid "``printf``-style Bytes Formatting"
msgstr "``printf`` 스타일 바이너리 포매팅"

#: ../Doc/library/stdtypes.rst:3221
msgid ""
"The formatting operations described here exhibit a variety of quirks that"
" lead to a number of common errors (such as failing to display tuples and"
" dictionaries correctly).  If the value being printed may be a tuple or "
"dictionary, wrap it in a tuple."
msgstr ""
"여기에 설명된 포맷 연산은 여러 가지 일반적인 오류를 (예를 들어 튜플과 딕셔너리를 올바르게 표시하지 못하는 것) 유발하는 다양한 "
"문제점들이 있습니다. 인쇄될 값이 튜플 또는 딕셔너리일 경우 튜플로 감싸야 합니다."

#: ../Doc/library/stdtypes.rst:3226
msgid ""
"Bytes objects (``bytes``/``bytearray``) have one unique built-in "
"operation: the ``%`` operator (modulo). This is also known as the bytes "
"*formatting* or *interpolation* operator. Given ``format % values`` "
"(where *format* is a bytes object), ``%`` conversion specifications in "
"*format* are replaced with zero or more elements of *values*. The effect "
"is similar to using the :c:func:`sprintf` in the C language."
msgstr ""
"바이너리 시퀀스 객체는 한가지 고유한 내장 연산을 갖고 있습니다: ``%`` 연산자 (모듈로). 이것은 바이너리 *포매팅* 또는 "
"*치환* 연산자라고도 합니다. ``format % values`` 가 주어질 때 (*format* 은 바이너리 시퀀스입니다), "
"*format* 내부의 ``%`` 변환 명세는 0개 이상의 *values​​* 의 요소로 대체됩니다. 이 효과는 C 언어에서 "
":c:func:`sprintf`\\를 사용하는 것과 비슷합니다."

#: ../Doc/library/stdtypes.rst:3233
msgid ""
"If *format* requires a single argument, *values* may be a single non-"
"tuple object. [5]_  Otherwise, *values* must be a tuple with exactly the "
"number of items specified by the format bytes object, or a single mapping"
" object (for example, a dictionary)."
msgstr ""
"*format* 이 하나의 인자를 요구하면, *values​​* 는 하나의 비 튜플 객체 일 수 있습니다. [5]_ 그렇지 않으면,"
" *values​​* 는 format 바이너리 시퀀스 객체가 지정하는 항목의 수와 같은 튜플이거나 단일 매핑 객체 (예를 들어, "
"딕셔너리) 여야 합니다."

#: ../Doc/library/stdtypes.rst:3262
msgid ""
"When the right argument is a dictionary (or other mapping type), then the"
" formats in the bytes object *must* include a parenthesised mapping key "
"into that dictionary inserted immediately after the ``'%'`` character. "
"The mapping key selects the value to be formatted from the mapping.  For "
"example:"
msgstr ""
"오른쪽 인자가 딕셔너리 (또는 다른 매핑 형) 인 경우, 바이너리 시퀀스 객체에 있는 변환 명세는 *반드시* ``'%'`` 문자 "
"바로 뒤에 그 딕셔너리의 매핑 키를 괄호로 둘러싼 형태로 포함해야 합니다. 매핑 키는 포맷할 값을 매핑으로 부터 선택합니다. 예를 "
"들어:"

#: ../Doc/library/stdtypes.rst:3330
msgid "Single byte (accepts integer or single byte objects)."
msgstr "단일 바이트 (정수 또는 길이 1인 바이너리 시퀀스를 허용합니다)."

#: ../Doc/library/stdtypes.rst:3333
msgid "``'b'``"
msgstr "```b```"

#: ../Doc/library/stdtypes.rst:3333
msgid ""
"Bytes (any object that follows the :ref:`buffer protocol <bufferobjects>`"
" or has :meth:`__bytes__`)."
msgstr ""
"바이너리 시퀀스 ( :ref:`버퍼 프로토콜 <bufferobjects>` 을 따르거나 :meth:`__bytes__` 가 있는 "
"모든 객체)."

#: ../Doc/library/stdtypes.rst:3337
msgid ""
"``'s'`` is an alias for ``'b'`` and should only be used for Python2/3 "
"code bases."
msgstr "``'s'`` 는 ``'b'`` 의 별칭이고 파이썬 2/3에서만 사용되어야 합니다."

#: ../Doc/library/stdtypes.rst:3340
msgid ""
"Bytes (converts any Python object using "
"``repr(obj).encode('ascii','backslashreplace)``)."
msgstr ""
"바이트열 (``repr(obj).encode('ascii','backslashreplace)`` 를 사용하여 모든 파이썬 객체를 "
"변환합니다)."

#: ../Doc/library/stdtypes.rst:3343
msgid ""
"``'r'`` is an alias for ``'a'`` and should only be used for Python2/3 "
"code bases."
msgstr "``'r'`` 는 ``'a'`` 의 별칭이고 파이썬 2/3에서만 사용되어야 합니다."

#: ../Doc/library/stdtypes.rst:3343
msgid "\\(7)"
msgstr "\\(7)"

#: ../Doc/library/stdtypes.rst:3378
#, python-format
msgid "``b'%s'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%s'`` 는 폐지되었습니다. 하지만 3.x 시리즈에서는 제거되지 않습니다."

#: ../Doc/library/stdtypes.rst:3381
#, python-format
msgid "``b'%r'`` is deprecated, but will not be removed during the 3.x series."
msgstr "``b'%r'`` 는 폐지되었습니다. 하지만 3.x 시리즈에서는 제거되지 않습니다."

#: ../Doc/library/stdtypes.rst:3391
msgid ":pep:`461`."
msgstr ":pep:`461`."

#: ../Doc/library/stdtypes.rst:3397
msgid "Memory Views"
msgstr "메모리 뷰"

#: ../Doc/library/stdtypes.rst:3399
msgid ""
":class:`memoryview` objects allow Python code to access the internal data"
" of an object that supports the :ref:`buffer protocol <bufferobjects>` "
"without copying."
msgstr ""
":class:`memoryview` 객체는 파이썬 코드가 :ref:`버퍼 프로토콜 <bufferobjects>` 을 지원하는 객체의"
" 내부 데이터에 복사 없이 접근할 수 있게 합니다."

#: ../Doc/library/stdtypes.rst:3405
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support "
"the buffer protocol.  Built-in objects that support the buffer protocol "
"include :class:`bytes` and :class:`bytearray`."
msgstr ""
"*obj* 를 참조하는 :class:`memoryview` 를 만듭니다. *obj* 는 버퍼 프로토콜을 지원해야 합니다. 버퍼 "
"프로토콜을 지원하는 내장 객체에는 :class:`bytes` 와 :class:`bytearray` 가 있습니다."

#: ../Doc/library/stdtypes.rst:3409
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic"
" memory unit handled by the originating object *obj*.  For many simple "
"types such as :class:`bytes` and :class:`bytearray`, an element is a "
"single byte, but other types such as :class:`array.array` may have bigger"
" elements."
msgstr ""
"A :class:`memoryview` 는 *요소* 라는 개념을 갖는데, 원래 객체 *obj* 에 의해 처리되는 원자 적 메모리 "
"단위입니다. :class:`bytes` 와 :class:`bytearray` 와 같은 많은 간단한 형의 경우 요소는 하나의 "
"바이트이지만, :class:`array.array` 와 같은 다른 형들은 더 큰 요소를 가질 수 있습니다."

#: ../Doc/library/stdtypes.rst:3415
msgid ""
"``len(view)`` is equal to the length of :class:`~memoryview.tolist`. If "
"``view.ndim = 0``, the length is 1. If ``view.ndim = 1``, the length is "
"equal to the number of elements in the view. For higher dimensions, the "
"length is equal to the length of the nested list representation of the "
"view. The :class:`~memoryview.itemsize` attribute will give you the "
"number of bytes in a single element."
msgstr ""
"``len(view)`` 는 :class:`~memoryview.tolist` 의 길이와 같습니다. ``view.ndim = 0``"
" 이면 길이는 1입니다. ``view.ndim = 1`` 이면 길이는 뷰에 있는 요소의 개수와 같습니다. 고차원의 경우, 길이는 "
"뷰의 중첩된 리스트 표현의 길이와 같습니다. :class:`~memoryview.itemsize` 어트리뷰트는 단일 요소의 바이트 "
"수를 알려줍니다."

#: ../Doc/library/stdtypes.rst:3422
msgid ""
"A :class:`memoryview` supports slicing and indexing to expose its data. "
"One-dimensional slicing will result in a subview::"
msgstr ":class:`memoryview` 는 슬라이싱과 인덱싱을 지원하여 데이터를 노출합니다. 일차원 슬라이스는 서브 뷰를 만듭니다::"

#: ../Doc/library/stdtypes.rst:3435
msgid ""
"If :class:`~memoryview.format` is one of the native format specifiers "
"from the :mod:`struct` module, indexing with an integer or a tuple of "
"integers is also supported and returns a single *element* with the "
"correct type.  One-dimensional memoryviews can be indexed with an integer"
" or a one-integer tuple.  Multi-dimensional memoryviews can be indexed "
"with tuples of exactly *ndim* integers where *ndim* is the number of "
"dimensions.  Zero-dimensional memoryviews can be indexed with the empty "
"tuple."
msgstr ""
":class:`~memoryview.format` 이 :mod:`struct` 모듈의 네이티브 형식 지정자 중 하나인 경우, 정수 "
"또는 정수의 튜플을 사용하는 인덱싱도 지원되며 올바른 형으로 하나의 요소를 돌려줍니다. 일차원 메모리 뷰는 정수 또는 하나의 정수를"
" 갖는 튜플로 인덱싱 할 수 있습니다. 다차원 메모리 뷰는 정확히 *ndim* 개의 정수를 갖는 튜플로 인덱싱할 수 있습니다. "
"여기서 *ndim* 은 차원 수입니다. 영차원 메모리 뷰는 빈 튜플로 인덱싱할 수 있습니다."

#: ../Doc/library/stdtypes.rst:3444
msgid "Here is an example with a non-byte format::"
msgstr "다음은 바이트가 아닌 형식의 예입니다::"

#: ../Doc/library/stdtypes.rst:3456
msgid ""
"If the underlying object is writable, the memoryview supports one-"
"dimensional slice assignment. Resizing is not allowed::"
msgstr "하부 객체가 쓰기 가능하면, 메모리 뷰는 일차원 슬라이스 대입을 지원합니다. 크기 변경은 허용되지 않습니다::"

#: ../Doc/library/stdtypes.rst:3477
msgid ""
"One-dimensional memoryviews of hashable (read-only) types with formats "
"'B', 'b' or 'c' are also hashable. The hash is defined as ``hash(m) == "
"hash(m.tobytes())``::"
msgstr ""
"'B', 'b' 'c' 형식의 해시 가능 (읽기 전용) 형의 일차원 메모리 뷰는 역시 해시 가능합니다. 해시는 ``hash(m) "
"== hash(m.tobytes())`` 로 정의됩니다::"

#: ../Doc/library/stdtypes.rst:3489
msgid ""
"One-dimensional memoryviews can now be sliced. One-dimensional "
"memoryviews with formats 'B', 'b' or 'c' are now hashable."
msgstr "이제 일차원 메모리 뷰를 슬라이스할 수 있습니다. 이제 형식이 'B', 'b', 'c' 인 일차원 메모리 뷰는 해시 가능합니다."

#: ../Doc/library/stdtypes.rst:3493
msgid ""
"memoryview is now registered automatically with "
":class:`collections.abc.Sequence`"
msgstr "이제 메모리 뷰는 자동으로 :class:`collections.abc.Sequence` 로 등록됩니다"

#: ../Doc/library/stdtypes.rst:3497
msgid "memoryviews can now be indexed with tuple of integers."
msgstr "이제 메모리 뷰는 정수의 튜플로 인덱싱될 수 있습니다."

#: ../Doc/library/stdtypes.rst:3500
msgid ":class:`memoryview` has several methods:"
msgstr ":class:`memoryview` 는 몇 가지 메서드를 가지고 있습니다:"

#: ../Doc/library/stdtypes.rst:3504
msgid ""
"A memoryview and a :pep:`3118` exporter are equal if their shapes are "
"equivalent and if all corresponding values are equal when the operands' "
"respective format codes are interpreted using :mod:`struct` syntax."
msgstr ""
"메모리 뷰와 :pep:`3118` 제공자(exporter)는 다음과 같은 조건을 만족할 때 같다고 비교됩니다: 모양이 동등하고 "
"피연산자의 각 형식 코드가 :mod:`struct` 문법을 사용하여 해석될 때 모든 해당 값이 같다."

#: ../Doc/library/stdtypes.rst:3508
msgid ""
"For the subset of :mod:`struct` format strings currently supported by "
":meth:`tolist`, ``v`` and ``w`` are equal if ``v.tolist() == "
"w.tolist()``::"
msgstr ""
"현재 :meth:`tolist` 가 지원하는 :mod:`struct` 형식 문자열의 부분 집합의 경우, ``v.tolist() =="
" w.tolist()`` 면 ``v`` 와 ``w`` 는 같습니다::"

#: ../Doc/library/stdtypes.rst:3527
msgid ""
"If either format string is not supported by the :mod:`struct` module, "
"then the objects will always compare as unequal (even if the format "
"strings and buffer contents are identical)::"
msgstr ""
"형식 문자열이 :mod:`struct` 모듈에서 지원되지 않으면 객체는 항상 같지 않다고 비교됩니다 (형식 문자열과 버퍼 내용이 "
"같더라도 그렇습니다)::"

#: ../Doc/library/stdtypes.rst:3543
msgid ""
"Note that, as with floating point numbers, ``v is w`` does *not* imply "
"``v == w`` for memoryview objects."
msgstr ""
"부동 소수점 숫자와 마찬가지로, 메모리 뷰 객체의 경우 ``v is w`` 일 때도 ``v == w`` 가 성립하지 *않을* 수 "
"있습니다."

#: ../Doc/library/stdtypes.rst:3546
msgid ""
"Previous versions compared the raw memory disregarding the item format "
"and the logical array structure."
msgstr "이전 버전에서는 항목 형식과 논리 배열 구조를 무시하고 원시 메모리를 비교했습니다."

#: ../Doc/library/stdtypes.rst:3552
msgid ""
"Return the data in the buffer as a bytestring.  This is equivalent to "
"calling the :class:`bytes` constructor on the memoryview. ::"
msgstr "버퍼의 데이터를 바이트열로 돌려줍니다. 이는 메모리 뷰에 :class:`bytes` 생성자를 호출하는 것과 동등합니다. ::"

#: ../Doc/library/stdtypes.rst:3561
msgid ""
"For non-contiguous arrays the result is equal to the flattened list "
"representation with all elements converted to bytes. :meth:`tobytes` "
"supports all format strings, including those that are not in "
":mod:`struct` module syntax."
msgstr ""
"불연속 배열의 경우 결과는 모든 요소를 바이트로 변환하여 평평한 리스트로 만든 것과 같습니다. :meth:`tobytes` 는 "
":mod:`struct` 모듈 문법에 없는 것을 포함하여 모든 형식 문자열을 지원합니다."

#: ../Doc/library/stdtypes.rst:3568
msgid ""
"Return a string object containing two hexadecimal digits for each byte in"
" the buffer. ::"
msgstr "버퍼 내의 각 바이트를 두 개의 16진수로 표현한 문자열 객체를 돌려줍니다. ::"

#: ../Doc/library/stdtypes.rst:3579
msgid "Return the data in the buffer as a list of elements. ::"
msgstr "버퍼 내의 데이터를 요소들의 리스트로 돌려줍니다. ::"

#: ../Doc/library/stdtypes.rst:3589
msgid ""
":meth:`tolist` now supports all single character native formats in "
":mod:`struct` module syntax as well as multi-dimensional representations."
msgstr ":meth:`tolist` 는 이제 :mod:`struct` 모듈 문법의 모든 단일 문자 네이티브 형식과 다차원 표현을 지원합니다."

#: ../Doc/library/stdtypes.rst:3596
msgid ""
"Release the underlying buffer exposed by the memoryview object.  Many "
"objects take special actions when a view is held on them (for example, a "
":class:`bytearray` would temporarily forbid resizing); therefore, calling"
" release() is handy to remove these restrictions (and free any dangling "
"resources) as soon as possible."
msgstr ""
"메모리 뷰 객체에 의해 노출된 하부 버퍼를 해제합니다. 많은 객체는 뷰가 그 객체에 연결될 때 특별한 조처를 합니다 (예를 들어, "
":class:`bytearray` 는 일시적으로 크기 조절을 금지합니다); 따라서, release()를 호출하면 가능한 한 빨리 이"
" 제한 사항을 제거하고 붙잡힌 자원을 해제할 수 있습니다."

#: ../Doc/library/stdtypes.rst:3602
msgid ""
"After this method has been called, any further operation on the view "
"raises a :class:`ValueError` (except :meth:`release()` itself which can "
"be called multiple times)::"
msgstr ""
"이 메서드가 호출된 후, 뷰에 대한 더 이상의 연산은 :class:`ValueError` 를 일으킵니다 (여러 번 호출 될 수 있는"
" :meth:`release()` 자신은 예외입니다)::"

#: ../Doc/library/stdtypes.rst:3613
msgid ""
"The context management protocol can be used for a similar effect, using "
"the ``with`` statement::"
msgstr "``with`` 문을 사용한 컨텍스트 관리 프로토콜은 비슷한 효과를 낼 수 있습니다::"

#: ../Doc/library/stdtypes.rst:3629
msgid ""
"Cast a memoryview to a new format or shape. *shape* defaults to "
"``[byte_length//new_itemsize]``, which means that the result view will be"
" one-dimensional. The return value is a new memoryview, but the buffer "
"itself is not copied. Supported casts are 1D -> C-:term:`contiguous` and "
"C-contiguous -> 1D."
msgstr ""
"메모리 뷰를 새로운 형식이나 모양으로 캐스팅합니다. *shape* 의 기본값은 "
"``[byte_length//new_itemsize]`` 인데, 결과 뷰가 일차원이 된다는 의미입니다. 반환 값은 새로운 메모리 "
"뷰이지만 버퍼 자체는 복사되지 않습니다. 지원되는 캐스팅은 1D -> C-:term:`연속 <contiguous>` 과 C-연속 "
"-> 1D입니다."

#: ../Doc/library/stdtypes.rst:3635
msgid ""
"The destination format is restricted to a single element native format in"
" :mod:`struct` syntax. One of the formats must be a byte format ('B', 'b'"
" or 'c'). The byte length of the result must be the same as the original "
"length."
msgstr ""
"목적 형식은 :mod:`struct` 문법의 단일 요소 네이티브 형식으로 제한됩니다. 형식 중 하나는 바이트 형식('B', 'b',"
" 'c')이어야 합니다. 결과의 바이트 길이는 원래 길이와 같아야 합니다."

#: ../Doc/library/stdtypes.rst:3640
msgid "Cast 1D/long to 1D/unsigned bytes::"
msgstr "1D/long 을 1D/unsigned bytes 로 캐스트::"

#: ../Doc/library/stdtypes.rst:3663
msgid "Cast 1D/unsigned bytes to 1D/char::"
msgstr "1D/unsigned bytes 를 1D/char 로 캐스트::"

#: ../Doc/library/stdtypes.rst:3676
msgid "Cast 1D/bytes to 3D/ints to 1D/signed char::"
msgstr "1D/bytes 를 3D/ints 로 캐스트 한 후 다시 1D/signed char 로 캐스트::"

#: ../Doc/library/stdtypes.rst:3702
msgid "Cast 1D/unsigned char to 2D/unsigned long::"
msgstr "1D/unsigned char 를 2D/unsigned long 으로 캐스트::"

#: ../Doc/library/stdtypes.rst:3716
msgid "The source format is no longer restricted when casting to a byte view."
msgstr "바이트 형식으로 변환할 때 소스 형식이 더는 제한되지 않습니다."

#: ../Doc/library/stdtypes.rst:3719
msgid "There are also several readonly attributes available:"
msgstr "몇 가지 읽기 전용 어트리뷰트도 사용할 수 있습니다:"

#: ../Doc/library/stdtypes.rst:3723
msgid "The underlying object of the memoryview::"
msgstr "메모리 뷰의 하부 객체::"

#: ../Doc/library/stdtypes.rst:3734
msgid ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. This is the "
"amount of space in bytes that the array would use in a contiguous "
"representation. It is not necessarily equal to len(m)::"
msgstr ""
"``nbytes == product(shape) * itemsize == len(m.tobytes())``. 배열이 연속적일 때 "
"차지하게 될 바이트 수입니다. 꼭 len(m) 과 같을 필요는 없습니다::"

#: ../Doc/library/stdtypes.rst:3753
msgid "Multi-dimensional arrays::"
msgstr "다차원 배열::"

#: ../Doc/library/stdtypes.rst:3770
msgid "A bool indicating whether the memory is read only."
msgstr "메모리가 읽기 전용인지 여부를 나타내는 논리값."

#: ../Doc/library/stdtypes.rst:3774
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view. A memoryview can be created from exporters with "
"arbitrary format strings, but some methods (e.g. :meth:`tolist`) are "
"restricted to native single element formats."
msgstr ""
"뷰의 각 요소에 대한 형식(:mod:`struct` 모듈 스타일)을 포함하는 문자열입니다. 메모리 뷰는 제공자로부터 임의의 형식 "
"문자열로 만들어질 수 있지만, 일부 메서드(예, :meth:`tolist`)는 원시 네이티브 단일 요소 형식으로 제한됩니다."

#: ../Doc/library/stdtypes.rst:3779
msgid ""
"format ``'B'`` is now handled according to the struct module syntax. This"
" means that ``memoryview(b'abc')[0] == b'abc'[0] == 97``."
msgstr ""
"``'B'`` 형식은 이제 struct 모듈 문법에 따라 처리됩니다. 이것은 ``memoryview(b'abc')[0] == "
"b'abc'[0] == 97`` 이 됨을 의미합니다."

#: ../Doc/library/stdtypes.rst:3785
msgid "The size in bytes of each element of the memoryview::"
msgstr "메모리 뷰 각 요소의 크기 (바이트)::"

#: ../Doc/library/stdtypes.rst:3798
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array "
"the memory represents."
msgstr "메모리가 나타내는 다차원 배열의 차원 수를 나타내는 정수."

#: ../Doc/library/stdtypes.rst:3803
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr "N-차원 배열로서의 메모리의 모양을 가리키는, 길이 :attr:`ndim` 인 정수의 튜플입니다."

#: ../Doc/library/stdtypes.rst:3806 ../Doc/library/stdtypes.rst:3814
msgid "An empty tuple instead of ``None`` when ndim = 0."
msgstr "ndim = 0 일 때 ``None`` 대신 빈 튜플을 제공합니다."

#: ../Doc/library/stdtypes.rst:3811
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes "
"to access each element for each dimension of the array."
msgstr "배열의 각 차원에 대해 각 요소를 참조하는데 필요한 바이트 수를 제공하는, 길이 :attr:`ndim` 인 정수의 튜플입니다."

#: ../Doc/library/stdtypes.rst:3819
msgid "Used internally for PIL-style arrays. The value is informational only."
msgstr "PIL 스타일 배열에 내부적으로 사용됩니다. 값은 정보 제공용입니다."

#: ../Doc/library/stdtypes.rst:3823
msgid "A bool indicating whether the memory is C-:term:`contiguous`."
msgstr "메모리가 C-:term:`연속 <contiguous>` 인지를 나타내는 논리값."

#: ../Doc/library/stdtypes.rst:3829
msgid "A bool indicating whether the memory is Fortran :term:`contiguous`."
msgstr "메모리가 포트란 :term:`연속 <contiguous>` 인지를 나타내는 논리값."

#: ../Doc/library/stdtypes.rst:3835
msgid "A bool indicating whether the memory is :term:`contiguous`."
msgstr "메모리가 :term:`연속 <contiguous>` 인지를 나타내는 논리값."

#: ../Doc/library/stdtypes.rst:3843
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "집합 형 --- :class:`set`, :class:`frozenset`"

#: ../Doc/library/stdtypes.rst:3847
msgid ""
"A :dfn:`set` object is an unordered collection of distinct "
":term:`hashable` objects. Common uses include membership testing, "
"removing duplicates from a sequence, and computing mathematical "
"operations such as intersection, union, difference, and symmetric "
"difference. (For other containers see the built-in :class:`dict`, "
":class:`list`, and :class:`tuple` classes, and the :mod:`collections` "
"module.)"
msgstr ""
":dfn:`집합 (set)` 객체는 서로 다른 :term:`해시 가능 <hashable>` 객체의 순서 없는 컬렉션입니다. 일반적인"
" 용도는 멤버십 검사, 시퀀스에서 중복 제거와 교집합, 합집합, 차집합, 대칭 차집합과 같은 수학 연산을 계산하는 것입니다. (다른"
" 컨테이너들은 내장 :class:`dict`, :class:`list`, :class:`tuple` 클래스 및 "
":mod:`collections` 모듈을 참조하십시오.)"

#: ../Doc/library/stdtypes.rst:3854
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and "
"``for x in set``.  Being an unordered collection, sets do not record "
"element position or order of insertion.  Accordingly, sets do not support"
" indexing, slicing, or other sequence-like behavior."
msgstr ""
"다른 컬렉션과 마찬가지로, 집합은 ``x in set``,``len(set)``, ``for x in set`` 을 지원합니다. "
"순서가 없는 컬렉션이므로, 집합은 원소의 위치나 삽입 순서를 기록하지 않습니다. 따라서 집합은 인덱싱, 슬라이싱 또는 기타 시퀀스와"
" 유사한 동작을 지원하지 않습니다."

#: ../Doc/library/stdtypes.rst:3859
msgid ""
"There are currently two built-in set types, :class:`set` and "
":class:`frozenset`. The :class:`set` type is mutable --- the contents can"
" be changed using methods like :meth:`~set.add` and :meth:`~set.remove`."
"  Since it is mutable, it has no hash value and cannot be used as either "
"a dictionary key or as an element of another set.  The :class:`frozenset`"
" type is immutable and :term:`hashable` --- its contents cannot be "
"altered after it is created; it can therefore be used as a dictionary key"
" or as an element of another set."
msgstr ""
"현재 두 가지 내장형이 있습니다, :class:`set`\\과 :class:`frozenset`. :class:`set` 형은 "
"가변입니다 --- 내용을 :meth:`~set.add` 나 :meth:`~set.remove` 와 같은 메서드를 사용하여 변경할 수"
" 있습니다. 가변이기 때문에, 해시값이 없으며 딕셔너리 키 또는 다른 집합의 원소로 사용할 수 없습니다. "
":class:`frozenset` 형은 불변이고 :term:`해시 가능 <hashable>` 합니다 --- 만들어진 후에는 내용을 "
"바꿀 수 없습니다; 따라서 딕셔너리 키 또는 다른 집합의 원소로 사용할 수 있습니다."

#: ../Doc/library/stdtypes.rst:3867
msgid ""
"Non-empty sets (not frozensets) can be created by placing a comma-"
"separated list of elements within braces, for example: ``{'jack', "
"'sjoerd'}``, in addition to the :class:`set` constructor."
msgstr ""
"비어 있지 않은 set은 (frozenset 은 아닙니다) :class:`set` 생성자뿐만 아니라 중괄호 안에 쉼표로 구분된 원소"
" 목록을 넣어서 만들 수 있습니다, 예를 들어: ``{'jack', 'sjoerd'}``."

#: ../Doc/library/stdtypes.rst:3871
msgid "The constructors for both classes work the same:"
msgstr "두 클래스의 생성자는 같게 작동합니다:"

#: ../Doc/library/stdtypes.rst:3876
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To "
"represent sets of sets, the inner sets must be :class:`frozenset` "
"objects.  If *iterable* is not specified, a new empty set is returned."
msgstr ""
"*iterable* 에서 요소를 취하는 새 set 또는 frozenset 객체를 돌려줍니다. 집합의 원소는 반드시 :term:`해시"
" 가능 <hashable>` 해야 합니다. 집합의 집합을 표현하려면, 포함되는 집합은 반드시 :class:`frozenset` "
"객체여야 합니다. *iterable* 을 지정하지 않으면 새 빈 집합을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3882
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ":class:`set`\\과 :class:`frozenset` 의 인스턴스는 다음과 같은 연산을 제공합니다:"

#: ../Doc/library/stdtypes.rst:3887
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "집합 *s* 의 원소 수(*s* 의 크기)를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3891
msgid "Test *x* for membership in *s*."
msgstr "*s* 에 대해 *x* 의 멤버십을 검사합니다."

#: ../Doc/library/stdtypes.rst:3895
msgid "Test *x* for non-membership in *s*."
msgstr "*s* 에 대해 *x* 의 비 멤버십을 검사합니다."

#: ../Doc/library/stdtypes.rst:3899
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets "
"are disjoint if and only if their intersection is the empty set."
msgstr ""
"집합이 *other* 와 공통 원소를 갖지 않는 경우 ``True`` 을 돌려줍니다. 집합은 교집합이 공집합일 때, 그리고 그때만 "
"서로소(disjoint)라고 합니다."

#: ../Doc/library/stdtypes.rst:3905
msgid "Test whether every element in the set is in *other*."
msgstr "집합의 모든 원소가 *other* 에 포함되는지 검사합니다."

#: ../Doc/library/stdtypes.rst:3909
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= "
"other and set != other``."
msgstr "집합이 *other* 의 진부분집합인지 검사합니다, 즉, ``set <= other and set != other``."

#: ../Doc/library/stdtypes.rst:3915
msgid "Test whether every element in *other* is in the set."
msgstr "*other* 의 모든 원소가 집합에 포함되는지 검사합니다."

#: ../Doc/library/stdtypes.rst:3919
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr "집합이 *other* 의 진상위집합인지 검사합니다, 즉, ``set >= other and set != other``."

#: ../Doc/library/stdtypes.rst:3925
msgid "Return a new set with elements from the set and all others."
msgstr "집합과 모든 others에 있는 원소들로 구성된 새 집합을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3930
msgid "Return a new set with elements common to the set and all others."
msgstr "집합과 모든 others의 공통 원소들로 구성된 새 집합을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3935
msgid "Return a new set with elements in the set that are not in the others."
msgstr "집합에는 포함되었으나 others에는 포함되지 않은 원소들로 구성된 새 집합을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3940
msgid "Return a new set with elements in either the set or *other* but not both."
msgstr "집합이나 other에 포함되어 있으나 둘 모두에 포함되지는 않은 원소들로 구성된 새 집합을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3944
msgid "Return a new set with a shallow copy of *s*."
msgstr "*s* 의 얕은 복사본인 새 집합을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:3947
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, "
":meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, "
"and :meth:`issuperset` methods will accept any iterable as an argument.  "
"In contrast, their operator based counterparts require their arguments to"
" be sets.  This precludes error-prone constructions like ``set('abc') & "
"'cbs'`` in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"참고로, 연산자가 아닌 버전의 :meth:`union`, :meth:`intersection`, :meth:`difference`,"
" :meth:`symmetric_difference`, :meth:`issubset`, :meth:`issuperset` 메서드는 "
"임의의 이터러블을 인자로 받아들입니다. 대조적으로, 연산자를 기반으로 하는 대응 연산들은 인자가 집합일 것을 요구합니다. 이것은 "
"오류가 발생하기 쉬운 ``set('abc') & 'cbs'`` 와 같은 구성을 배제하고 더 읽기 쉬운 "
"``set('abc').intersection('cbs')`` 를 선호합니다."

#: ../Doc/library/stdtypes.rst:3954
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. "
"Two sets are equal if and only if every element of each set is contained "
"in the other (each is a subset of the other). A set is less than another "
"set if and only if the first set is a proper subset of the second set (is"
" a subset, but is not equal). A set is greater than another set if and "
"only if the first set is a proper superset of the second set (is a "
"superset, but is not equal)."
msgstr ""
":class:`set`\\과 :class:`frozenset` 모두 집합 간의 비교를 지원합니다. 두 집합은 각 집합의 모든 원소가"
" 다른 집합에 포함되어있는 경우에만 같습니다 (서로 다른 집합의 부분집합입니다). 집합이 다른 집합의 진부분집합(부분집합이지만 "
"같지는 않은 경우)일 때만 첫 번째 집합이 두 번째 집합보다 작습니다. 집합이 다른 집합의 진상위집합(상위집합이지만 같지는 않은 "
"경우)일 때만 첫 번째 집합이 두 번째 집합보다 큽니다."

#: ../Doc/library/stdtypes.rst:3961
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset`"
" based on their members.  For example, ``set('abc') == frozenset('abc')``"
" returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
":class:`set` 의 인스턴스는 그 원소를 기반으로 :class:`frozenset` 의 인스턴스와 비교됩니다. 예를 들어, "
"``set('abc') == frozenset('abc')`` 는 ``True`` 를 돌려주고 ``set('abc') in "
"set([frozenset('abc')])`` 도 마찬가지입니다."

#: ../Doc/library/stdtypes.rst:3965
msgid ""
"The subset and equality comparisons do not generalize to a total ordering"
" function.  For example, any two nonempty disjoint sets are not equal and"
" are not subsets of each other, so *all* of the following return "
"``False``: ``a<b``, ``a==b``, or ``a>b``."
msgstr ""
"부분 집합 및 동등 비교는 전 순서(total ordering) 함수로 일반화되지 않습니다. 예를 들어, 비어 있지 않은 두 개의 "
"서로소인 집합은 같지 않고 서로의 부분 집합이 아닙니다, 그래서 다음은 *모두* ``False`` 를 돌려줍니다: ``a<b``, "
"``a==b``, ``a>b``."

#: ../Doc/library/stdtypes.rst:3970
msgid ""
"Since sets only define partial ordering (subset relationships), the "
"output of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"집합은 부분 순서(부분 집합 관계)만 정의하기 때문에, 집합의 리스트에 대한 :meth:`list.sort` 메서드의 결과는 "
"정의되지 않습니다."

#: ../Doc/library/stdtypes.rst:3973
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr "딕셔너리 키처럼, 집합의 원소는 반드시 :term:`해시 가능 <hashable>` 해야 합니다."

#: ../Doc/library/stdtypes.rst:3975
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset`"
" return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
":class:`set` 인스턴스와 :class:`frozenset` 을 혼합 한 이항 연산은 첫 번째 피연산자의 형을 돌려줍니다. "
"예를 들어: ``frozenset('ab') | set('bc')`` 는 :class:`frozenset` 의 인스턴스를 "
"돌려줍니다."

#: ../Doc/library/stdtypes.rst:3979
msgid ""
"The following table lists operations available for :class:`set` that do "
"not apply to immutable instances of :class:`frozenset`:"
msgstr ""
"다음 표는 :class:`frozenset` 의 불변 인스턴스에는 적용되지 않고 :class:`set` 에서만 사용할 수 있는 "
"연산들을 나열합니다:"

#: ../Doc/library/stdtypes.rst:3985
msgid "Update the set, adding elements from all others."
msgstr "집합을 갱신해서, 모든 others의 원소들을 더합니다."

#: ../Doc/library/stdtypes.rst:3990
msgid "Update the set, keeping only elements found in it and all others."
msgstr "집합을 갱신해서, 그 집합과 others에 공통으로 포함된 원소들만 남깁니다."

#: ../Doc/library/stdtypes.rst:3995
msgid "Update the set, removing elements found in others."
msgstr "집합을 갱신해서, others에 있는 원소들을 제거합니다."

#: ../Doc/library/stdtypes.rst:4000
msgid ""
"Update the set, keeping only elements found in either set, but not in "
"both."
msgstr "집합을 갱신해서, 두 집합의 어느 한 곳에만 포함된 원소들만 남깁니다."

#: ../Doc/library/stdtypes.rst:4004
msgid "Add element *elem* to the set."
msgstr "원소 *elem* 을 집합에 추가합니다."

#: ../Doc/library/stdtypes.rst:4008
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is "
"not contained in the set."
msgstr "원소 *elem* 을 집합에서 제거합니다. *elem* 가 집합에 포함되어 있지 않으면 :exc:`KeyError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:4013
msgid "Remove element *elem* from the set if it is present."
msgstr "원소 *elem* 이 집합에 포함되어 있으면 제거합니다."

#: ../Doc/library/stdtypes.rst:4017
msgid ""
"Remove and return an arbitrary element from the set.  Raises "
":exc:`KeyError` if the set is empty."
msgstr "집합으로부터 임의의 원소를 제거해 돌려줍니다. 집합이 비어있는 경우 :exc:`KeyError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:4022
msgid "Remove all elements from the set."
msgstr "집합의 모든 원소를 제거합니다."

#: ../Doc/library/stdtypes.rst:4025
msgid ""
"Note, the non-operator versions of the :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, and "
":meth:`symmetric_difference_update` methods will accept any iterable as "
"an argument."
msgstr ""
"참고로, :meth:`update`, :meth:`intersection_update`, "
":meth:`difference_update`, :meth:`symmetric_difference_update` 메서드의 비 연산자"
" 버전은 임의의 이터러블을 인자로 받아들입니다."

#: ../Doc/library/stdtypes.rst:4030
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, "
"and :meth:`discard` methods may be a set.  To support searching for an "
"equivalent frozenset, a temporary one is created from *elem*."
msgstr ""
"참고로, :meth:`__contains__`, :meth:`remove`, :meth:`discard` 메서드로 제공되는 "
"*elem* 인자는 set 일 수 있습니다. 동등한 frozenset 검색을 지원하기 위해, *elem* 으로 임시 "
"frozenset 을 만듭니다."

#: ../Doc/library/stdtypes.rst:4038
msgid "Mapping Types --- :class:`dict`"
msgstr "매핑 형 --- :class:`dict`"

#: ../Doc/library/stdtypes.rst:4048
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary "
"objects. Mappings are mutable objects.  There is currently only one "
"standard mapping type, the :dfn:`dictionary`.  (For other containers see "
"the built-in :class:`list`, :class:`set`, and :class:`tuple` classes, and"
" the :mod:`collections` module.)"
msgstr ""
":term:`매핑 <mapping>` 객체는 :term:`해시 가능 <hashable>` 값을 임의의 객체에 대응합니다. 매핑은 "
"가변 객체입니다. 현재 오직 하나의 표준 매핑 형이 있습니다, :dfn:`딕셔너리 (dictionary)`. (다른 컨테이너들은 "
"내장 :class:`list`, :class:`set`, :class:`tuple` 클래스 및 :mod:`collections` "
"모듈을 참조하십시오.)"

#: ../Doc/library/stdtypes.rst:4054
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not "
":term:`hashable`, that is, values containing lists, dictionaries or other"
" mutable types (that are compared by value rather than by object "
"identity) may not be used as keys.  Numeric types used for keys obey the "
"normal rules for numeric comparison: if two numbers compare equal (such "
"as ``1`` and ``1.0``) then they can be used interchangeably to index the "
"same dictionary entry.  (Note however, that since computers store "
"floating-point numbers as approximations it is usually unwise to use them"
" as dictionary keys.)"
msgstr ""
"딕셔너리의 키는 *거의* 임의의 값입니다. :term:`해시 가능 <hashable>` 하지 않은 값들, 즉, 리스트, 딕셔너리 "
"또는 다른 가변형 (객체 아이덴티티 대신 값으로 비교됩니다) 은 키로 사용할 수 없습니다. 키에 사용되는 숫자 형은 숫자 비교를 "
"위한 일반적인 규칙을 따릅니다: 두 숫자가 같다고 비교되는 경우 (``1`` 과 ``1.0`` 처럼) 같은 딕셔너리 항목을 "
"인덱싱하는데 서로 교환하여 사용할 수 있습니다. (그러나 컴퓨터는 부동 소수점 숫자를 근삿값으로 저장하므로 이것들을 딕셔너리 키로 "
"사용하는 것은 현명하지 않습니다.)"

#: ../Doc/library/stdtypes.rst:4063
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': "
"4127}`` or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` "
"constructor."
msgstr ""
"딕셔너리는 :class:`dict` 생성자뿐만 아니라 중괄호 안에 쉼표로 구분된 ``key: value`` 쌍을 나열해서 만들 수 "
"있습니다, 예를 들어: ``{'jack': 4098, 'sjoerd': 4127}`` 또는 ``{4098: 'jack', 4127:"
" 'sjoerd'}``."

#: ../Doc/library/stdtypes.rst:4071
msgid ""
"Return a new dictionary initialized from an optional positional argument "
"and a possibly empty set of keyword arguments."
msgstr "선택적 위치 인자와 (비어있을 수 있는) 키워드 인자들의 집합으로부터 초기화된 새 딕셔너리를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4074
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, "
"the positional argument must be an :term:`iterable` object.  Each item in"
" the iterable must itself be an iterable with exactly two objects.  The "
"first object of each item becomes a key in the new dictionary, and the "
"second object the corresponding value.  If a key occurs more than once, "
"the last value for that key becomes the corresponding value in the new "
"dictionary."
msgstr ""
"위치 인자가 제공되지 않으면 빈 딕셔너리가 만들어집니다. 위치 인자가 지정되고 매핑 객체인 경우, 매핑 객체와 같은 키-값 쌍을 "
"갖는 딕셔너리가 만들어집니다. 그렇지 않으면, 위치 인자는 :term:`이터러블 <iterable>` 객체여야 합니다. 이터러블의 "
"각 항목은 그 자체로 정확하게 두 개의 객체가 있는 이터러블이어야 합니다. 각 항목의 첫 번째 객체는 새 딕셔너리의 키가 되고, 두"
" ​​번째 객체는 해당 값이 됩니다. 키가 두 번 이상 나타나면, 그 키의 마지막 값이 새 딕셔너리의 해당 값이 됩니다."

#: ../Doc/library/stdtypes.rst:4084
msgid ""
"If keyword arguments are given, the keyword arguments and their values "
"are added to the dictionary created from the positional argument.  If a "
"key being added is already present, the value from the keyword argument "
"replaces the value from the positional argument."
msgstr ""
"키워드 인자가 제공되면, 키워드 인자와 해당 값이 위치 인자로부터 만들어진 딕셔너리에 추가됩니다. 추가되는 키가 이미 존재하면, "
"키워드 인자에서 온 값이 위치 인자에게서 온 값을 대체합니다."

#: ../Doc/library/stdtypes.rst:4089
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"예를 들어, 다음 예제는 모두 ``{\"one\": 1, \"two\": 2, \"three\": 3}`` 와 같은 딕셔너리를 "
"돌려줍니다::"

#: ../Doc/library/stdtypes.rst:4100
msgid ""
"Providing keyword arguments as in the first example only works for keys "
"that are valid Python identifiers.  Otherwise, any valid keys can be "
"used."
msgstr ""
"첫 번째 예제에서와같이 키워드 인자는 유효한 파이썬 식별자인 키에 대해서만 작동합니다. 그 외의 경우는 모든 유효한 키를 사용할 수"
" 있습니다."

#: ../Doc/library/stdtypes.rst:4104
msgid ""
"These are the operations that dictionaries support (and therefore, custom"
" mapping types should support too):"
msgstr "이것들은 딕셔너리가 지원하는 연산들입니다 (그러므로, 사용자 정의 매핑 형도 지원해야 합니다):"

#: ../Doc/library/stdtypes.rst:4109
msgid "Return the number of items in the dictionary *d*."
msgstr "딕셔너리 *d* 에 있는 항목의 수를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4113
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key*"
" is not in the map."
msgstr "키 *key* 인 *d* 의 항목을 돌려줍니다. *key* 가 매핑에 없는 경우 :exc:`KeyError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:4118
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is "
"not present, the ``d[key]`` operation calls that method with the key "
"*key* as argument.  The ``d[key]`` operation then returns or raises "
"whatever is returned or raised by the ``__missing__(key)`` call. No other"
" operations or methods invoke :meth:`__missing__`. If :meth:`__missing__`"
" is not defined, :exc:`KeyError` is raised. :meth:`__missing__` must be a"
" method; it cannot be an instance variable::"
msgstr ""
"dict 의 서브 클래스가 method :meth:`__missing__` 을 정의하고 *key* 가 존재하지 않는다면, "
"``d[key]`` 연산은 키 *key* 를 인자로 하여 그 메서드를 호출합니다. 그런 다음 ``d[key]`` 연산은 "
"``__missing__(key)`` 호출이 반환한 값이나 일으킨 예외를 그대로 반환하거나 일으킵니다. 다른 연산이나 메서드는 "
":meth:`__missing__` 을 호출하지 않습니다. :meth:`__missing__` 이 정의되어 있지 않으면 "
":exc:`KeyError` 를 일으킵니다. :meth:`__missing__` 은 메서드 여야 합니다; 인스턴스 변수가 될 수 "
"없습니다::"

#: ../Doc/library/stdtypes.rst:4136
msgid ""
"The example above shows part of the implementation of "
":class:`collections.Counter`.  A different ``__missing__`` method is used"
" by :class:`collections.defaultdict`."
msgstr ""
"위의 예는 :class:`collections.Counter` 구현 일부를 보여줍니다. 다른 ``__missing__`` 메서드가 "
":class:`collections.defaultdict` 에서 사용됩니다."

#: ../Doc/library/stdtypes.rst:4142
msgid "Set ``d[key]`` to *value*."
msgstr "``d[key]`` 를 *value* 로 설정합니다."

#: ../Doc/library/stdtypes.rst:4146
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in "
"the map."
msgstr "*d* 에서 ``d[key]`` 를 제거합니다. *key* 가 매핑에 없는 경우 :exc:`KeyError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:4151
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "*d* 에 키 *key* 가 있으면 ``True`` 를, 그렇지 않으면 ``False`` 를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4155
msgid "Equivalent to ``not key in d``."
msgstr "``not key in d`` 와 동등합니다."

#: ../Doc/library/stdtypes.rst:4159
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut "
"for ``iter(d.keys())``."
msgstr "딕셔너리의 키에 대한 이터레이터를 돌려줍니다. 이것은 ``iter(d.keys())`` 의 단축입니다."

#: ../Doc/library/stdtypes.rst:4164
msgid "Remove all items from the dictionary."
msgstr "딕셔너리에서 모든 항목을 제거합니다."

#: ../Doc/library/stdtypes.rst:4168
msgid "Return a shallow copy of the dictionary."
msgstr "딕셔너리의 얕은 복사본을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4172
msgid "Create a new dictionary with keys from *seq* and values set to *value*."
msgstr "*seq* 가 제공하는 값들을 키로 사용하고 모든 값을 *value* 로 설정한 새 딕셔러리를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4174
msgid ""
":meth:`fromkeys` is a class method that returns a new dictionary. *value*"
" defaults to ``None``."
msgstr ":meth:`fromkeys` 는 새로운 딕셔너리를 돌려주는 클래스 메서드입니다. *value* 의 기본값은 ``None`` 입니다."

#: ../Doc/library/stdtypes.rst:4179
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*."
" If *default* is not given, it defaults to ``None``, so that this method "
"never raises a :exc:`KeyError`."
msgstr ""
"*key* 가 딕셔너리에 있는 경우 *key* 에 대응하는 값을 돌려주고, 그렇지 않으면 *default* 를 돌려줍니다. "
"*default* 가 주어지지 않으면 기본값 ``None`` 이 사용됩니다. 그래서 이 메서드는 절대로 :exc:`KeyError`"
" 를 일으키지 않습니다."

#: ../Doc/library/stdtypes.rst:4185
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs). See"
" the :ref:`documentation of view objects <dict-views>`."
msgstr ""
"딕셔너리 항목들(``(key, value)`` 쌍들)의 새 뷰를 돌려줍니다. :ref:`뷰 객체의 도큐멘테이션 <dict-"
"views>` 을 참조하세요."

#: ../Doc/library/stdtypes.rst:4190
msgid ""
"Return a new view of the dictionary's keys.  See the :ref:`documentation "
"of view objects <dict-views>`."
msgstr "딕셔너리 키들의 새 뷰를 돌려줍니다. :ref:`뷰 객체의 도큐멘테이션 <dict-views>` 을 참조하세요."

#: ../Doc/library/stdtypes.rst:4195
msgid ""
"If *key* is in the dictionary, remove it and return its value, else "
"return *default*.  If *default* is not given and *key* is not in the "
"dictionary, a :exc:`KeyError` is raised."
msgstr ""
"*key* 가 딕셔너리에 있으면 제거하고 그 값을 돌려줍니다. 그렇지 않으면 *default* 를 돌려줍니다. *default* 가"
" 주어지지 않고 *key* 가 딕셔너리에 없으면 :exc:`KeyError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:4201
msgid "Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr "딕셔너리에서 임의의 ``(key, value)`` 쌍을 제거하고 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4203
msgid ""
":meth:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling "
":meth:`popitem` raises a :exc:`KeyError`."
msgstr ""
":meth:`popitem` 은 집합 알고리즘에서 종종 사용되듯이 딕셔너리를 파괴적으로 이터레이션 하는 데 유용합니다. 딕셔너리가 "
"비어 있으면 :meth:`popitem` 호출은 :exc:`KeyError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:4209
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* "
"with a value of *default* and return *default*.  *default* defaults to "
"``None``."
msgstr ""
"*key* 가 딕셔너리에 있으면 해당 값을 돌려줍니다. 그렇지 않으면, *default* 값을 갖는 *key* 를 삽입한 후 "
"*default* 를 돌려줍니다. *default* 의 기본값은 ``None`` 입니다."

#: ../Doc/library/stdtypes.rst:4215
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr "*other* 가 제공하는 키/값 쌍으로 사전을 갱신합니다. 기존 키는 덮어씁니다. ``None`` 을 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4218
msgid ""
":meth:`update` accepts either another dictionary object or an iterable of"
" key/value pairs (as tuples or other iterables of length two).  If "
"keyword arguments are specified, the dictionary is then updated with "
"those key/value pairs: ``d.update(red=1, blue=2)``."
msgstr ""
":meth:`update` 는 다른 딕셔너리 객체 나 키/값 쌍(길이 2인 튜플이나 다른 이터러블)을 주는 이터레이터를 모두 "
"받아들입니다. 키워드 인자가 지정되면, 딕셔너리는 그 키/값 쌍으로 갱신됩니다: ``d.update(red=1, blue=2)``."

#: ../Doc/library/stdtypes.rst:4225
msgid ""
"Return a new view of the dictionary's values.  See the "
":ref:`documentation of view objects <dict-views>`."
msgstr "딕셔너리 값들의 새 뷰를 돌려줍니다. :ref:`뷰 객체의 도큐멘테이션 <dict-views>` 을 참조하세요."

#: ../Doc/library/stdtypes.rst:4228
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs. Order comparisons ('<', '<=', '>=', '>') raise "
":exc:`TypeError`."
msgstr ""
"딕셔너리는 같은 ``(key, value)`` 쌍들을 가질 때, 그리고 그때만 같다고 비교됩니다. 순서 비교('<', '<=', "
"'>=', '>')는 :exc:`TypeError` 를 일으킵니다."

#: ../Doc/library/stdtypes.rst:4233
msgid ""
":class:`types.MappingProxyType` can be used to create a read-only view of"
" a :class:`dict`."
msgstr ""
":class:`types.MappingProxyType` 를 :class:`dict` 의 읽기 전용 뷰를 만드는 데 사용할 수 "
"있습니다."

#: ../Doc/library/stdtypes.rst:4240
msgid "Dictionary view objects"
msgstr "딕셔너리 뷰 객체"

#: ../Doc/library/stdtypes.rst:4242
msgid ""
"The objects returned by :meth:`dict.keys`, :meth:`dict.values` and "
":meth:`dict.items` are *view objects*.  They provide a dynamic view on "
"the dictionary's entries, which means that when the dictionary changes, "
"the view reflects these changes."
msgstr ""
":meth:`dict.keys`, :meth:`dict.values`, :meth:`dict.items` 가 돌려주는 객체는 *뷰 "
"객체* 입니다. 딕셔너리의 항목들에 대한 동적 뷰를 제공합니다. 즉, 딕셔너리가 변경되면 뷰는 이러한 변경 사항을 반영합니다."

#: ../Doc/library/stdtypes.rst:4247
msgid ""
"Dictionary views can be iterated over to yield their respective data, and"
" support membership tests:"
msgstr "딕셔너리 뷰는 이터레이션을 통해 각각의 데이터를 산출할 수 있고, 멤버십 검사를 지원합니다:"

#: ../Doc/library/stdtypes.rst:4252
msgid "Return the number of entries in the dictionary."
msgstr "딕셔너리에 있는 항목 수를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4256
msgid ""
"Return an iterator over the keys, values or items (represented as tuples "
"of ``(key, value)``) in the dictionary."
msgstr "딕셔너리에서 키, 값, 항목(``(key, value)`` 튜플로 표현됩니다)에 대한 이터레이터를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4259
msgid ""
"Keys and values are iterated over in insertion order. This allows the "
"creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = "
"zip(d.values(), d.keys())``.  Another way to create the same list is "
"``pairs = [(v, k) for (k, v) in d.items()]``."
msgstr ""

#: ../Doc/library/stdtypes.rst:4264
msgid ""
"Iterating views while adding or deleting entries in the dictionary may "
"raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"딕셔너리에 항목을 추가하거나 삭제하는 동안 뷰를 이터레이션 하면 :exc:`RuntimeError` 를 일으키거나 모든 항목을 "
"이터레이션 하지 못할 수 있습니다."

#: ../Doc/library/stdtypes.rst:4267
msgid "Dict order is guaranteed to be insertion order."
msgstr ""

#: ../Doc/library/stdtypes.rst:4272
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"*x* 가 하부 딕셔너리의 키, 갑, 항목에 있는 경우 ``True`` 를 돌려줍니다 (마지막의 경우 *x* 는 ``(key, "
"value)`` 튜플이어야 합니다)."

#: ../Doc/library/stdtypes.rst:4276
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If "
"all values are hashable, so that ``(key, value)`` pairs are unique and "
"hashable, then the items view is also set-like.  (Values views are not "
"treated as set-like since the entries are generally not unique.)  For "
"set-like views, all of the operations defined for the abstract base class"
" :class:`collections.abc.Set` are available (for example, ``==``, ``<``, "
"or ``^``)."
msgstr ""
"키 뷰는 항목이 고유하고 해시 가능하므로 집합과 유사합니다. 모든 값이 해시 가능해서 ``(key, value)`` 쌍들이 고유하고"
" 해시 가능하다면, 항목 뷰 역시 집합과 유사합니다. (값 뷰는 항목이 일반적으로 고유하지 않기 때문에 집합과 같이 취급되지 "
"않습니다.) 집합과 유사한 뷰의 경우 추상 베이스 클래스 :class:`collections.abc.Set` 에 정의된 모든 연산을"
" 사용할 수 있습니다 (예를 들어, ``==``, ``<``, ``^``)."

#: ../Doc/library/stdtypes.rst:4283
msgid "An example of dictionary view usage::"
msgstr "딕셔너리 뷰 사용의 예::"

#: ../Doc/library/stdtypes.rst:4318
msgid "Context Manager Types"
msgstr "컨텍스트 관리자 형"

#: ../Doc/library/stdtypes.rst:4325
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime "
"context defined by a context manager.  This is implemented using a pair "
"of methods that allow user-defined classes to define a runtime context "
"that is entered before the statement body is executed and exited when the"
" statement ends:"
msgstr ""
"파이썬의 :keyword:`with` 문은 컨텍스트 관리자가 정의한 실행 시간 컨텍스트 개념을 지원합니다. 이는 한 쌍의 메서드를 "
"사용해서 구현되는데, 사용자 정의 클래스가 문장 바디가 실행되기 전에 진입하고, 문장이 끝날 때 탈출하는 실행 시간 컨텍스트를 "
"정의할 수 있게 합니다:"

#: ../Doc/library/stdtypes.rst:4333
msgid ""
"Enter the runtime context and return either this object or another object"
" related to the runtime context. The value returned by this method is "
"bound to the identifier in the :keyword:`as` clause of :keyword:`with` "
"statements using this context manager."
msgstr ""
"실행시간 컨텍스트에 진입하고 이 객체 자신이나 실행 시간 컨텍스트와 관련된 다른 객체를 돌려줍니다. 이 메서드가 돌려주는 값은, 이"
" 컨텍스트 관리자를 사용하는 :keyword:`with` 문의 :keyword:`as` 절의 식별자에 연결됩니다."

#: ../Doc/library/stdtypes.rst:4338
msgid ""
"An example of a context manager that returns itself is a :term:`file "
"object`. File objects return themselves from __enter__() to allow "
":func:`open` to be used as the context expression in a :keyword:`with` "
"statement."
msgstr ""
"자신을 돌려주는 컨텍스트 관리자의 예는 :term:`파일 객체 <file object>` 입니다. 파일 객체는 __enter__()"
" 에서 자기 자신을 돌려주는데 :keyword:`with` 문의 컨텍스트 표현식으로 :func:`open` 을 사용할 수 있도록 "
"하기 위함입니다."

#: ../Doc/library/stdtypes.rst:4342
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return"
" the copy. This allows changes to be made to the current decimal context "
"in the body of the :keyword:`with` statement without affecting code "
"outside the :keyword:`with` statement."
msgstr ""
"관련 객체를 돌려주는 컨텍스트 관리자의 예는 :func:`decimal.localcontext` 가 돌려주는 것입니다. 이 "
"관리자들은 활성 십진 소수 컨텍스트를 원래 십진 소수 컨텍스트의 복사본으로 설정한 다음 복사본을 돌려줍니다. 이것은 "
":keyword:`with` 문 바깥의 코드에 영향을 주지 않으면서 :keyword:`with` 문 바디에 있는 현재 십진 소수 "
"컨텍스트를 변경할 수 있게 합니다."

#: ../Doc/library/stdtypes.rst:4352
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred "
"while executing the body of the :keyword:`with` statement, the arguments "
"contain the exception type, value and traceback information. Otherwise, "
"all three arguments are ``None``."
msgstr ""
"실행 시간 컨텍스트를 탈출하고 발생한 예외를 막아야 하는지를 가리키는 논리 플래그를 돌려줍니다. :keyword:`with` 문의 "
"바디를 실행하는 동안 예외가 발생하면, 인자에 예외 형, 값 및 추적 정보가 포함됩니다. 그렇지 않으면, 세 가지 인자 모두 "
"``None`` 입니다."

#: ../Doc/library/stdtypes.rst:4357
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`with` statement. Otherwise "
"the exception continues propagating after this method has finished "
"executing. Exceptions that occur during execution of this method will "
"replace any exception that occurred in the body of the :keyword:`with` "
"statement."
msgstr ""
"이 메서드에서 참 값을 돌려주면 :keyword:`with` 문이 예외를 막고 :keyword:`with` 문 바로 뒤에 오는 "
"문장에서 계속 실행됩니다. 그 이외의 경우, 이 메서드의 실행이 완료된 후에 예외는 계속 퍼집니다. 이 메서드의 실행 중에 발생하는"
" 예외는 :keyword:`with` 문의 바디에서 발생한 모든 예외를 대체합니다."

#: ../Doc/library/stdtypes.rst:4364
msgid ""
"The exception passed in should never be reraised explicitly - instead, "
"this method should return a false value to indicate that the method "
"completed successfully and does not want to suppress the raised "
"exception. This allows context management code to easily detect whether "
"or not an :meth:`__exit__` method has actually failed."
msgstr ""
"전달 된 예외를 명시적으로 다시 일으켜서는 안 됩니다 - 대신, 이 메서드가 성공적으로 완료되었으며 발생 된 예외를 막지 않겠다는 "
"의미의 거짓을 돌려주어야 합니다. 이렇게 하면 컨텍스트 관리 코드가 :meth:`__exit__` 메서드가 실제로 실패했는지를 쉽게"
" 감지할 수 있습니다."

#: ../Doc/library/stdtypes.rst:4370
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types"
" are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"파이썬은 쉬운 스레드 동기화, 파일이나 다른 객체의 신속한 닫기, 그리고 활성 십진 소수 산술 컨텍스트의 보다 간단한 조작을 "
"지원하기 위해 몇 가지 컨텍스트 관리자를 정의합니다. 컨텍스트 관리 프로토콜의 구현을 넘어 구체적인 형은 특별히 취급되지 않습니다."
" 몇 가지 예제는 :mod:`contextlib` 모듈을 보십시오."

#: ../Doc/library/stdtypes.rst:4376
msgid ""
"Python's :term:`generator`\\s and the :class:`contextlib.contextmanager` "
"decorator provide a convenient way to implement these protocols.  If a "
"generator function is decorated with the "
":class:`contextlib.contextmanager` decorator, it will return a context "
"manager implementing the necessary :meth:`__enter__` and :meth:`__exit__`"
" methods, rather than the iterator produced by an undecorated generator "
"function."
msgstr ""
"파이썬의 :term:`제너레이터 <generator>`\\s들과 :class:`contextlib.contextmanager` "
"데코레이터는 이 프로토콜을 구현하는 편리한 방법을 제공합니다. 제너레이터 함수가 "
":class:`contextlib.contextmanager` 데코레이터로 데코레이팅 되면, 데코레이팅 되지 않은 제너레이터 함수가"
" 만드는 이터레이터 대신에 필요한 :meth:`__enter__` 와 :meth:`__exit__` 메서드를 구현하는 컨텍스트 "
"관리자를 돌려줍니다."

#: ../Doc/library/stdtypes.rst:4383
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting"
" to define these methods must provide them as a normal Python accessible "
"method. Compared to the overhead of setting up the runtime context, the "
"overhead of a single class dictionary lookup is negligible."
msgstr ""
"파이썬/C API의 파이썬 객체에 대한 형 구조체에는 이러한 메서드들을 위해 준비된 슬롯이 없다는 점에 유의하십시오. 이러한 "
"메서드를 정의하고자 하는 확장형은 일반적인 파이썬 액세스가 가능한 메서드로 제공해야 합니다. 실행 시간 컨텍스트를 설정하는 "
"오버헤드와 비교할 때 한 번의 클래스 딕셔너리 조회의 오버헤드는 무시할 수 있습니다."

#: ../Doc/library/stdtypes.rst:4393
msgid "Other Built-in Types"
msgstr "기타 내장형"

#: ../Doc/library/stdtypes.rst:4395
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr "인터프리터는 여러 가지 다른 객체를 지원합니다. 이것들 대부분은 한두 가지 연산만 지원합니다."

#: ../Doc/library/stdtypes.rst:4402
msgid "Modules"
msgstr "모듈"

#: ../Doc/library/stdtypes.rst:4404
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the "
":keyword:`import` statement is not, strictly speaking, an operation on a "
"module object; ``import foo`` does not require a module object named "
"*foo* to exist, rather it requires an (external) *definition* for a "
"module named *foo* somewhere.)"
msgstr ""
"모듈에 대한 유일한 특별한 연산은 어트리뷰트 액세스입니다: ``m.name``. 여기서 *m* 은 모듈이고 *name* 은 *m* "
"의 심볼 테이블에 정의된 이름에 액세스합니다. 모듈 어트리뷰트는 대입할 수 있습니다. (:keyword:`import` 문은 엄밀히"
" 말하면 모듈 객체에 대한 연산이 아닙니다; ``import foo`` 는 *foo* 라는 이름의 모듈 객체가 존재할 것을 요구하지"
" 않고, 어딘가에 있는 *foo* 라는 이름의 (외부) *정의* 를 요구합니다."

#: ../Doc/library/stdtypes.rst:4411
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is "
"the dictionary containing the module's symbol table. Modifying this "
"dictionary will actually change the module's symbol table, but direct "
"assignment to the :attr:`~object.__dict__` attribute is not possible (you"
" can write ``m.__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, "
"but you can't write ``m.__dict__ = {}``).  Modifying "
":attr:`~object.__dict__` directly is not recommended."
msgstr ""
"모든 모듈의 특수 어트리뷰트는 :attr:`~object.__dict__` 입니다. 이것은 모듈의 심볼 테이블을 저장하는 "
"딕셔너리입니다. 이 딕셔너리를 수정하면 모듈의 심볼 테이블이 실제로 변경되지만, :attr:`~object.__dict__` "
"어트리뷰트에 대한 직접 대입은 불가능합니다 (``m.__dict__['a'] = 1`` 라고 쓸 수 있고, ``m.a`` 가 "
"``1`` 이 되지만, ``m.__dict__ = {}`` 라고 쓸 수는 없습니다). :attr:`~object.__dict__` "
"의 직접적인 수정은 추천하지 않습니다."

#: ../Doc/library/stdtypes.rst:4419
msgid ""
"Modules built into the interpreter are written like this: ``<module 'sys'"
" (built-in)>``.  If loaded from a file, they are written as ``<module "
"'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"인터프리터에 내장된 모듈은 다음과 같이 쓰입니다: ``<module 'sys' (built-in)>``. 파일에서 로드되면, "
"``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>`` 처럼 쓰입니다."

#: ../Doc/library/stdtypes.rst:4427
msgid "Classes and Class Instances"
msgstr "클래스와 클래스 인스턴스"

#: ../Doc/library/stdtypes.rst:4429
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "여기에 대해서는 :ref:`objects`\\와 :ref:`class`\\를 참조하세요."

#: ../Doc/library/stdtypes.rst:4435
msgid "Functions"
msgstr "함수"

#: ../Doc/library/stdtypes.rst:4437
msgid ""
"Function objects are created by function definitions.  The only operation"
" on a function object is to call it: ``func(argument-list)``."
msgstr ""
"함수 객체는 함수 정의로 만들어집니다. 함수 객체에 대한 유일한 연산은 호출하는 것입니다: ``func(argument-"
"list)``."

#: ../Doc/library/stdtypes.rst:4440
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different "
"object types."
msgstr ""
"함수 객체에는 내장 함수와 사용자 정의 함수라는 두 가지 종류가 있습니다. 두 함수 모두 같은 연산(함수 호출)을 지원하지만, "
"구현이 다르므로 서로 다른 객체 형입니다."

#: ../Doc/library/stdtypes.rst:4444
msgid "See :ref:`function` for more information."
msgstr "자세한 정보는 :ref:`function`\\을 보십시오."

#: ../Doc/library/stdtypes.rst:4450
msgid "Methods"
msgstr "메서드"

#: ../Doc/library/stdtypes.rst:4454
msgid ""
"Methods are functions that are called using the attribute notation. There"
" are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types "
"that support them."
msgstr ""
"메서드는 어트리뷰트 표기법을 사용하여 호출되는 함수입니다. 두 가지 종류가 있습니다: 내장 메서드(리스트의 "
":meth:`append` 같은 것들)와 클래스 인스턴스 메서드. 내장 메서드는 이를 지원하는 형에서 설명됩니다."

#: ../Doc/library/stdtypes.rst:4459
msgid ""
"If you access a method (a function defined in a class namespace) through "
"an instance, you get a special object: a :dfn:`bound method` (also called"
" :dfn:`instance method`) object. When called, it will add the ``self`` "
"argument to the argument list.  Bound methods have two special read-only "
"attributes: ``m.__self__`` is the object on which the method operates, "
"and ``m.__func__`` is the function implementing the method.  Calling "
"``m(arg-1, arg-2, ..., arg-n)`` is completely equivalent to calling "
"``m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)``."
msgstr ""
"인스턴스를 통해 메서드(클래스 이름 공간에 정의 된 함수)에 액세스하면, 특별한 객체인 :dfn:`연결된 메서드 (bound "
"method)` (:dfn:`인스턴스 메서드 (instance method)` 라고도 부릅니다) 객체를 얻게 됩니다. 호출되면 인자"
" 목록에 ``self`` 인자를 추가합니다. 연결된 메서드는 두 가지 특수한 읽기 전용 어트리뷰트를 가지고 있습니다: "
"``m.__self__`` 는 메서드가 작동하는 객체이고, ``m.__func__`` 는 메서드를 구현하는 함수입니다. "
"``m(arg-1, arg-2, ..., arg-n)`` 을 호출하는 것은 ``m.__func__(m.__self__, arg-1,"
" arg-2, ..., arg-n)`` 를 호출하는 것과 완전히 같습니다."

#: ../Doc/library/stdtypes.rst:4468
msgid ""
"Like function objects, bound method objects support getting arbitrary "
"attributes.  However, since method attributes are actually stored on the "
"underlying function object (``meth.__func__``), setting method attributes"
" on bound methods is disallowed.  Attempting to set an attribute on a "
"method results in an :exc:`AttributeError` being raised.  In order to set"
" a method attribute, you need to explicitly set it on the underlying "
"function object::"
msgstr ""
"함수 객체와 같이, 연결된 메서드 객체는 임의 어트리뷰트를 읽는 것을 지원합니다. 그러나 메서드 어트리뷰트는 실제로 하부 함수 "
"객체(``meth.__func__``)에 저장되기 때문에, 연결된 메서드에 메서드 어트리뷰트를 설정하는 것은 허용되지 않습니다. "
"메서드 어트리뷰트를 설정하려고 하면 :exc:`AttributeError` 를 일으킵니다. 메서드 어트리뷰트를 설정하려면, "
"명시적으로 하부 함수 객체에 설정해야 합니다::"

#: ../Doc/library/stdtypes.rst:4488 ../Doc/library/stdtypes.rst:4516
msgid "See :ref:`types` for more information."
msgstr "자세한 정보는 :ref:`types`\\를 보십시오."

#: ../Doc/library/stdtypes.rst:4496
msgid "Code Objects"
msgstr "코드 객체"

#: ../Doc/library/stdtypes.rst:4502
msgid ""
"Code objects are used by the implementation to represent \"pseudo-"
"compiled\" executable Python code such as a function body. They differ "
"from function objects because they don't contain a reference to their "
"global execution environment.  Code objects are returned by the built-in "
":func:`compile` function and can be extracted from function objects "
"through their :attr:`__code__` attribute. See also the :mod:`code` "
"module."
msgstr ""
"코드 객체는 함수 바디와 같은 \"의사 컴파일된\" 실행 가능한 파이썬 코드를 표현하기 위해 구현에서 사용됩니다. 전역 실행 환경에"
" 대한 참조가 없으므로 함수 객체와 다릅니다. 코드 객체는 내장 :func:`compile` 함수가 돌려주고, 함수 객체들로부터 "
":attr:`__code__` 어트리뷰트를 통해 추출할 수 있습니다. :mod:`code` 모듈도 참고하십시오."

#: ../Doc/library/stdtypes.rst:4513
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :func:`exec` or :func:`eval`  built-in functions."
msgstr ""
"코드 객체는 :func:`exec` 또는 :func:`eval` 내장 함수에 (소스 문자열 대신) 전달하여 실행하거나 값을 구할 수"
" 있습니다."

#: ../Doc/library/stdtypes.rst:4522
msgid "Type Objects"
msgstr "형 객체"

#: ../Doc/library/stdtypes.rst:4528
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for "
"all standard built-in types."
msgstr ""
"형 객체는 다양한 객체 형을 나타냅니다. 객체의 형은 내장 함수 :func:`type`\\으로 액세스할 수 있습니다. 형에는 특별한"
" 연산이 없습니다. 표준 모듈 :mod:`types` 는 모든 표준 내장형의 이름을 정의합니다."

#: ../Doc/library/stdtypes.rst:4533
msgid "Types are written like this: ``<class 'int'>``."
msgstr "형은 다음과 같이 쓰입니다: ``<class 'int'>``."

#: ../Doc/library/stdtypes.rst:4539
msgid "The Null Object"
msgstr "널 객체"

#: ../Doc/library/stdtypes.rst:4541
msgid ""
"This object is returned by functions that don't explicitly return a "
"value.  It supports no special operations.  There is exactly one null "
"object, named ``None`` (a built-in name).  ``type(None)()`` produces the "
"same singleton."
msgstr ""
"이 객체는 명시적으로 값을 돌려주지 않는 함수에 의해 반환됩니다. 특별한 연산을 지원하지 않습니다. 정확하게 하나의 널 객체가 "
"있으며, 이름은 ``None``(내장 이름)입니다. ``type(None)()`` 은 같은 싱글톤을 만듭니다."

#: ../Doc/library/stdtypes.rst:4545
msgid "It is written as ``None``."
msgstr "``None`` 이라고 쓰입니다."

#: ../Doc/library/stdtypes.rst:4551
msgid "The Ellipsis Object"
msgstr "Ellipsis 객체"

#: ../Doc/library/stdtypes.rst:4553
msgid ""
"This object is commonly used by slicing (see :ref:`slicings`).  It "
"supports no special operations.  There is exactly one ellipsis object, "
"named :const:`Ellipsis` (a built-in name).  ``type(Ellipsis)()`` produces"
" the :const:`Ellipsis` singleton."
msgstr ""
"이 객체는 일반적으로 슬라이싱에 사용됩니다 (:ref:`slicings` 를 참조하세요). 특별한 연산을 지원하지 않습니다. "
"정확하게 하나의 Ellipsis 객체가 있으며, 이름은 :const:`Ellipsis`(내장 이름)입니다. "
"``type(Ellipsis)()`` 는 :const:`Ellipsis` 싱글톤을 만듭니다."

#: ../Doc/library/stdtypes.rst:4558
msgid "It is written as ``Ellipsis`` or ``...``."
msgstr "``Ellipsis`` 나 ``...`` 로 쓰입니다."

#: ../Doc/library/stdtypes.rst:4564
msgid "The NotImplemented Object"
msgstr "NotImplemented 객체"

#: ../Doc/library/stdtypes.rst:4566
msgid ""
"This object is returned from comparisons and binary operations when they "
"are asked to operate on types they don't support. See :ref:`comparisons` "
"for more information.  There is exactly one ``NotImplemented`` object. "
"``type(NotImplemented)()`` produces the singleton instance."
msgstr ""
"이 객체는 비교와 이항 연산이 지원하지 않는 형에 대한 요청을 받았을 때 돌려줍니다. 자세한 정보는 "
":ref:`comparisons`\\를 보십시오. 정확하게 하나의 ``NotImplemented`` 객체가 있습니다. "
"``type(NotImplemented)()`` 는 싱글톤 인스턴스를 만듭니다."

#: ../Doc/library/stdtypes.rst:4571
msgid "It is written as ``NotImplemented``."
msgstr "``NotImplemented`` 로 쓰입니다."

#: ../Doc/library/stdtypes.rst:4577
msgid "Boolean Values"
msgstr "논리값"

#: ../Doc/library/stdtypes.rst:4579
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They"
" are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as"
" the argument to an arithmetic operator), they behave like the integers 0"
" and 1, respectively. The built-in function :func:`bool` can be used to "
"convert any value to a Boolean, if the value can be interpreted as a "
"truth value (see section :ref:`truth` above)."
msgstr ""
"논리값은 두 개의 상수 객체인 ``False`` 와 ``True`` 입니다. 이것들은 논리값을 나타내기 위해 사용됩니다 (하지만 "
"다른 값도 거짓 또는 참으로 간주 될 수 있습니다). 숫자 컨텍스트(예를 들어, 산술 연산자의 인자로 사용될 때)에서는 각각 정수 "
"0과 1처럼 작동합니다. 내장 함수 :func:`bool` 은 값이 논리값으로 해석될 수 있는 경우 모든 값을 논리값으로 변환하는 "
"데 사용할 수 있습니다 (위의 :ref:`truth` 절을 참조하세요)."

#: ../Doc/library/stdtypes.rst:4592
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "각각 ``False`` 과 ``True`` 로 쓰입니다."

#: ../Doc/library/stdtypes.rst:4598
msgid "Internal Objects"
msgstr "내부 객체"

#: ../Doc/library/stdtypes.rst:4600
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects,"
" traceback objects, and slice objects."
msgstr ""
"여기에 관한 정보는 :ref:`types`\\를 참조하십시오. 스택 프레임 객체, 트레이스백 객체 및 슬라이스 객체에 관해 "
"설명합니다."

#: ../Doc/library/stdtypes.rst:4607
msgid "Special Attributes"
msgstr "특수 어트리뷰트"

#: ../Doc/library/stdtypes.rst:4609
msgid ""
"The implementation adds a few special read-only attributes to several "
"object types, where they are relevant.  Some of these are not reported by"
" the :func:`dir` built-in function."
msgstr ""
"관련성이 있을 때, 구현은 몇 가지 객체 유형에 몇 가지 특수 읽기 전용 어트리뷰트를 추가합니다. 이 중 일부는 "
":func:`dir` 내장 함수에 의해 보고되지 않습니다."

#: ../Doc/library/stdtypes.rst:4616
msgid ""
"A dictionary or other mapping object used to store an object's (writable)"
" attributes."
msgstr "객체의 (쓰기 가능한) 어트리뷰트를 저장하는 데 사용되는 딕셔너리나 또는 기타 매핑 객체."

#: ../Doc/library/stdtypes.rst:4622
msgid "The class to which a class instance belongs."
msgstr "클래스 인스턴스가 속한 클래스."

#: ../Doc/library/stdtypes.rst:4627
msgid "The tuple of base classes of a class object."
msgstr "클래스 객체의 베이스 클래스들의 튜플."

#: ../Doc/library/stdtypes.rst:4632
msgid ""
"The name of the class, function, method, descriptor, or generator "
"instance."
msgstr "클래스, 함수, 메서드, 디스크립터 또는 제너레이터 인스턴스의 이름."

#: ../Doc/library/stdtypes.rst:4638
msgid ""
"The :term:`qualified name` of the class, function, method, descriptor, or"
" generator instance."
msgstr "클래스, 함수, 메서드, 디스크립터 또는 제너레이터 인스턴스의 :term:`정규화된 이름 <qualified name>`."

#: ../Doc/library/stdtypes.rst:4646
msgid ""
"This attribute is a tuple of classes that are considered when looking for"
" base classes during method resolution."
msgstr "이 어트리뷰트는 메서드 결정 중에 베이스 클래스를 찾을 때 고려되는 클래스들의 튜플입니다."

#: ../Doc/library/stdtypes.rst:4652
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation,"
" and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"이 메서드는 인스턴스의 메서드 결정 순서를 사용자 정의하기 위해 메타 클래스가 재정의할 수 있습니다. 클래스 인스턴스를 만들 때 "
"호출되며 그 결과는 :attr:`~class.__mro__` 에 저장됩니다."

#: ../Doc/library/stdtypes.rst:4659
msgid ""
"Each class keeps a list of weak references to its immediate subclasses.  "
"This method returns a list of all those references still alive. Example::"
msgstr ""
"각 클래스는 직계 서브 클래스에 대한 약한 참조의 리스트를 유지합니다. 이 메서드는 아직 살아있는 모든 참조의 리스트를 돌려줍니다."
" 예::"

#: ../Doc/library/stdtypes.rst:4668
msgid "Footnotes"
msgstr "각주"

#: ../Doc/library/stdtypes.rst:4669
msgid ""
"Additional information on these special methods may be found in the "
"Python Reference Manual (:ref:`customization`)."
msgstr "이 특수 메서드에 대한 추가 정보는 파이썬 레퍼런스 설명서(:ref:`customization`)에서 찾을 수 있습니다."

#: ../Doc/library/stdtypes.rst:4672
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, "
"2.0]``, and similarly for tuples."
msgstr "결과적으로, 리스트 ``[1, 2]`` 는 ``[1.0, 2.0]`` 과 같다고 취급되고, 튜플도 마찬가지입니다."

#: ../Doc/library/stdtypes.rst:4675
msgid "They must have since the parser can't tell the type of the operands."
msgstr "파서가 피연산자 유형을 알 수 없으므로 그럴 수밖에 없습니다."

#: ../Doc/library/stdtypes.rst:4677
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" "
"(Letter, titlecase)."
msgstr ""
"케이스 문자는 일반 범주 속성이 \"Lu\" (Letter, 대문자), \"Ll\" (Letter, 소문자), \"Lt\" "
"(Letter, 제목 문자) 중 한 가지인 경우입니다."

#: ../Doc/library/stdtypes.rst:4680
msgid ""
"To format only a tuple you should therefore provide a singleton tuple "
"whose only element is the tuple to be formatted."
msgstr "그래서, 튜플만을 포매팅하려면 포맷할 튜플 하나만을 포함하는 1-튜플을 제공해야 합니다."

#~ msgid ""
#~ "Keys and values are iterated over "
#~ "in an arbitrary order which is "
#~ "non-random, varies across Python "
#~ "implementations, and depends on the "
#~ "dictionary's history of insertions and "
#~ "deletions. If keys, values and items "
#~ "views are iterated over with no "
#~ "intervening modifications to the dictionary,"
#~ " the order of items will directly "
#~ "correspond.  This allows the creation of"
#~ " ``(value, key)`` pairs using :func:`zip`:"
#~ " ``pairs = zip(d.values(), d.keys())``.  "
#~ "Another way to create the same "
#~ "list is ``pairs = [(v, k) for "
#~ "(k, v) in d.items()]``."
#~ msgstr ""
#~ "키와 값은 무작위는 아니지만, 임의의 순서(파이썬 구현에"
#~ " 따라 달라집니다)로 이터레이션 되고, 딕셔너리의 삽입 "
#~ "및 삭제 이력에 따라 달라집니다. 키, 값 및"
#~ " 항목 뷰를 이터레이션 하는 도중에 딕셔너리를 수정하지"
#~ " 않으면, 항목들의 순서는 모두 일치합니다. 이 때문에"
#~ " :func:`zip`\\을 사용해서 ``(value, key)`` 쌍을"
#~ " 만들 수 있습니다: ``pairs = zip(d.values(),"
#~ " d.keys())``. 같은 리스트를 만드는 다른 방법은 "
#~ "``pairs = [(v, k) for (k, v) "
#~ "in d.items()]`` 입니다."

