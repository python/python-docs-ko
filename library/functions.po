# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-30 09:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/functions.rst:5 ../Doc/library/functions.rst:11
msgid "Built-in Functions"
msgstr "내장 함수"

#: ../Doc/library/functions.rst:7
msgid ""
"The Python interpreter has a number of functions and types built into it "
"that are always available.  They are listed here in alphabetical order."
msgstr "파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형이 내장되어 있습니다. 여기에서 알파벳 순으로 나열합니다."

#: ../Doc/library/functions.rst:13
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../Doc/library/functions.rst:13
msgid ":func:`delattr`"
msgstr ":func:`delattr`"

#: ../Doc/library/functions.rst:13
msgid ":func:`hash`"
msgstr ":func:`hash`"

#: ../Doc/library/functions.rst:13
msgid "|func-memoryview|_"
msgstr "|func-memoryview|_"

#: ../Doc/library/functions.rst:13
msgid "|func-set|_"
msgstr "|func-set|_"

#: ../Doc/library/functions.rst:14
msgid ":func:`all`"
msgstr ":func:`all`"

#: ../Doc/library/functions.rst:14
msgid "|func-dict|_"
msgstr "|func-dict|_"

#: ../Doc/library/functions.rst:14
msgid ":func:`help`"
msgstr ":func:`help`"

#: ../Doc/library/functions.rst:14
msgid ":func:`min`"
msgstr ":func:`min`"

#: ../Doc/library/functions.rst:14
msgid ":func:`setattr`"
msgstr ":func:`setattr`"

#: ../Doc/library/functions.rst:15
msgid ":func:`any`"
msgstr ":func:`any`"

#: ../Doc/library/functions.rst:15
msgid ":func:`dir`"
msgstr ":func:`dir`"

#: ../Doc/library/functions.rst:15
msgid ":func:`hex`"
msgstr ":func:`hex`"

#: ../Doc/library/functions.rst:15
msgid ":func:`next`"
msgstr ":func:`next`"

#: ../Doc/library/functions.rst:15
msgid ":func:`slice`"
msgstr ":func:`slice`"

#: ../Doc/library/functions.rst:16
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../Doc/library/functions.rst:16
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../Doc/library/functions.rst:16
msgid ":func:`id`"
msgstr ":func:`id`"

#: ../Doc/library/functions.rst:16
msgid ":func:`object`"
msgstr ":func:`object`"

#: ../Doc/library/functions.rst:16
msgid ":func:`sorted`"
msgstr ":func:`sorted`"

#: ../Doc/library/functions.rst:17
msgid ":func:`bin`"
msgstr ":func:`bin`"

#: ../Doc/library/functions.rst:17
msgid ":func:`enumerate`"
msgstr ":func:`enumerate`"

#: ../Doc/library/functions.rst:17
msgid ":func:`input`"
msgstr ":func:`input`"

#: ../Doc/library/functions.rst:17
msgid ":func:`oct`"
msgstr ":func:`oct`"

#: ../Doc/library/functions.rst:17
msgid ":func:`staticmethod`"
msgstr ":func:`staticmethod`"

#: ../Doc/library/functions.rst:18
msgid ":func:`bool`"
msgstr ":func:`bool`"

#: ../Doc/library/functions.rst:18
msgid ":func:`eval`"
msgstr ":func:`eval`"

#: ../Doc/library/functions.rst:18
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../Doc/library/functions.rst:18
msgid ":func:`open`"
msgstr ":func:`open`"

#: ../Doc/library/functions.rst:18
msgid "|func-str|_"
msgstr "|func-str|_"

#: ../Doc/library/functions.rst:19
msgid ":func:`breakpoint`"
msgstr ":func:`breakpoint`"

#: ../Doc/library/functions.rst:19
msgid ":func:`exec`"
msgstr ":func:`exec`"

#: ../Doc/library/functions.rst:19
msgid ":func:`isinstance`"
msgstr ":func:`isinstance`"

#: ../Doc/library/functions.rst:19
msgid ":func:`ord`"
msgstr ":func:`ord`"

#: ../Doc/library/functions.rst:19
msgid ":func:`sum`"
msgstr ":func:`sum`"

#: ../Doc/library/functions.rst:20
msgid "|func-bytearray|_"
msgstr "|func-bytearray|_"

#: ../Doc/library/functions.rst:20
msgid ":func:`filter`"
msgstr ":func:`filter`"

#: ../Doc/library/functions.rst:20
msgid ":func:`issubclass`"
msgstr ":func:`issubclass`"

#: ../Doc/library/functions.rst:20
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../Doc/library/functions.rst:20
msgid ":func:`super`"
msgstr ":func:`super`"

#: ../Doc/library/functions.rst:21
msgid "|func-bytes|_"
msgstr "|func-bytes|_"

#: ../Doc/library/functions.rst:21
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../Doc/library/functions.rst:21
msgid ":func:`iter`"
msgstr ":func:`iter`"

#: ../Doc/library/functions.rst:21
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../Doc/library/functions.rst:21
msgid "|func-tuple|_"
msgstr "|func-tuple|_"

#: ../Doc/library/functions.rst:22
msgid ":func:`callable`"
msgstr ":func:`callable`"

#: ../Doc/library/functions.rst:22
msgid ":func:`format`"
msgstr ":func:`format`"

#: ../Doc/library/functions.rst:22
msgid ":func:`len`"
msgstr ":func:`len`"

#: ../Doc/library/functions.rst:22
msgid ":func:`property`"
msgstr ":func:`property`"

#: ../Doc/library/functions.rst:22
msgid ":func:`type`"
msgstr ":func:`type`"

#: ../Doc/library/functions.rst:23
msgid ":func:`chr`"
msgstr ":func:`chr`"

#: ../Doc/library/functions.rst:23
msgid "|func-frozenset|_"
msgstr "|func-frozenset|_"

#: ../Doc/library/functions.rst:23
msgid "|func-list|_"
msgstr "|func-list|_"

#: ../Doc/library/functions.rst:23
msgid "|func-range|_"
msgstr "|func-range|_"

#: ../Doc/library/functions.rst:23
msgid ":func:`vars`"
msgstr ":func:`vars`"

#: ../Doc/library/functions.rst:24
msgid ":func:`classmethod`"
msgstr ":func:`classmethod`"

#: ../Doc/library/functions.rst:24
msgid ":func:`getattr`"
msgstr ":func:`getattr`"

#: ../Doc/library/functions.rst:24
msgid ":func:`locals`"
msgstr ":func:`locals`"

#: ../Doc/library/functions.rst:24
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../Doc/library/functions.rst:24
msgid ":func:`zip`"
msgstr ":func:`zip`"

#: ../Doc/library/functions.rst:25
msgid ":func:`compile`"
msgstr ":func:`compile`"

#: ../Doc/library/functions.rst:25
msgid ":func:`globals`"
msgstr ":func:`globals`"

#: ../Doc/library/functions.rst:25
msgid ":func:`map`"
msgstr ":func:`map`"

#: ../Doc/library/functions.rst:25
msgid ":func:`reversed`"
msgstr ":func:`reversed`"

#: ../Doc/library/functions.rst:25
msgid ":func:`__import__`"
msgstr ":func:`__import__`"

#: ../Doc/library/functions.rst:26
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../Doc/library/functions.rst:26
msgid ":func:`hasattr`"
msgstr ":func:`hasattr`"

#: ../Doc/library/functions.rst:26
msgid ":func:`max`"
msgstr ":func:`max`"

#: ../Doc/library/functions.rst:26
msgid ":func:`round`"
msgstr ":func:`round`"

#: ../Doc/library/functions.rst:45
msgid ""
"Return the absolute value of a number.  The argument may be an integer or"
" a floating point number.  If the argument is a complex number, its "
"magnitude is returned."
msgstr "숫자의 절댓값을 돌려줍니다. 인자는 정수 또는 실수입니다. 인자가 복소수면 그 크기가 반환됩니다."

#: ../Doc/library/functions.rst:52
msgid ""
"Return ``True`` if all elements of the *iterable* are true (or if the "
"iterable is empty).  Equivalent to::"
msgstr ""
"*iterable* 의 모든 요소가 참이면 (또는 iterable 이 비어있으면) ``True`` 를 돌려줍니다. 다음과 "
"동등합니다::"

#: ../Doc/library/functions.rst:64
msgid ""
"Return ``True`` if any element of the *iterable* is true.  If the "
"iterable is empty, return ``False``.  Equivalent to::"
msgstr ""
"*iterable* 의 요소 중 어느 하나라도 참이면 ``True`` 를 돌려줍니다. iterable이 비어 있으면 "
"``False`` 를 돌려줍니다. 다음과 동등합니다::"

#: ../Doc/library/functions.rst:76
msgid ""
"As :func:`repr`, return a string containing a printable representation of"
" an object, but escape the non-ASCII characters in the string returned by"
" :func:`repr` using ``\\x``, ``\\u`` or ``\\U`` escapes.  This generates "
"a string similar to that returned by :func:`repr` in Python 2."
msgstr ""
":func:`repr` 처럼, 객체의 인쇄 가능한 표현을 포함하는 문자열을 반환하지만, ``\\x`` 나 ``\\u`` 또는 "
"``\\U`` 이스케이프를 사용하여 :func:`repr` 이 돌려주는 문자열에 포함된 비 ASCII 문자를 이스케이프 합니다. "
"이것은 파이썬 2의 :func:`repr` 이 돌려주는 것과 비슷한 문자열을 만듭니다."

#: ../Doc/library/functions.rst:84
msgid ""
"Convert an integer number to a binary string prefixed with \"0b\". The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`__index__` method that returns an "
"integer. Some examples:"
msgstr ""
"정수를 \"0b\" 가 앞에 붙은 이진 문자열로 변환합니다. 결과는 올바른 파이썬 표현식입니다. *x* 가 파이썬 "
":class:`int` 객체가 아니라면, 정수를 돌려주는 :meth:`__index__` 메서드를 정의해야 합니다. 몇 가지 예를 "
"들면:"

#: ../Doc/library/functions.rst:94
msgid ""
"If prefix \"0b\" is desired or not, you can use either of the following "
"ways."
msgstr "접두어 \"0b\" 가 필요할 수도, 필요 없을 수도 있다면, 다음 방법의 하나를 사용할 수 있습니다."

#: ../Doc/library/functions.rst:101 ../Doc/library/functions.rst:692
#: ../Doc/library/functions.rst:947
msgid "See also :func:`format` for more information."
msgstr "자세한 내용은 :func:`format`\\을 보세요."

#: ../Doc/library/functions.rst:106
msgid ""
"Return a Boolean value, i.e. one of ``True`` or ``False``.  *x* is "
"converted using the standard :ref:`truth testing procedure <truth>`.  If "
"*x* is false or omitted, this returns ``False``; otherwise it returns "
"``True``.  The :class:`bool` class is a subclass of :class:`int` (see "
":ref:`typesnumeric`). It cannot be subclassed further.  Its only "
"instances are ``False`` and ``True`` (see :ref:`bltin-boolean-values`)."
msgstr ""
"논리값, 즉 ``True`` 또는 ``False`` 중 하나를 돌려줍니다. *x* 표준 :ref:`논리값 검사 절차 <truth>`"
" 를 사용하여 변환됩니다. *x* 가 거짓이거나 생략되면 ``False`` 를 돌려줍니다. 그렇지 않으면``True`` 를 "
"돌려줍니다. :class:`bool` 클래스는 :class:`int` (:ref:`typesnumeric` 참조)의 서브 "
"클래스입니다. 서브 클래스를 더 만들 수 없습니다. 이것의 유일한 인스턴스는 ``False`` 와``True`` 입니다 (:ref"
":`bltin-boolean-values`\\를 보세요)."

#: ../Doc/library/functions.rst:118
msgid ""
"This function drops you into the debugger at the call site.  "
"Specifically, it calls :func:`sys.breakpointhook`, passing ``args`` and "
"``kws`` straight through.  By default, ``sys.breakpointhook()`` calls "
":func:`pdb.set_trace()` expecting no arguments.  In this case, it is "
"purely a convenience function so you don't have to explicitly import "
":mod:`pdb` or type as much code to enter the debugger.  However, "
":func:`sys.breakpointhook` can be set to some other function and "
":func:`breakpoint` will automatically call that, allowing you to drop "
"into the debugger of choice."
msgstr ""
"이 함수는 호출 지점에서 디버거로 진입하게 만듭니다. 특히 :func:`sys.breakpointhook` 을 호출하고 ``args`` "
"와 ``kws`` 를 그대로 전달합니다. 기본적으로, ``sys.breakpointhook()`` 은 인자를 기대하지 않고 "
":func:`pdb.set_trace()`\\를 호출합니다. 이 경우, 이것은 순전히 편의 기능이므로 :mod:`pdb`\\를 "
"명시적으로 임포트하거나 디버거에 들어가기 위해 많은 코드를 입력할 필요가 없습니다. 그러나, "
":func:`sys.breakpointhook` 은 다른 함수로 설정될 수 있고, :func:`breakpoint` 는 그것을 자동으로 "
"호출하여, 선택한 디버거에 들어갈 수 있도록 합니다."

#: ../Doc/library/functions.rst:134
msgid ""
"Return a new array of bytes.  The :class:`bytearray` class is a mutable "
"sequence of integers in the range 0 <= x < 256.  It has most of the usual"
" methods of mutable sequences, described in :ref:`typesseq-mutable`, as "
"well as most methods that the :class:`bytes` type has, see :ref:`bytes-"
"methods`."
msgstr ""
"새로운 바이트 배열을 돌려줍니다. :class:`bytearray` 클래스는 0 <= x < 256 범위에 있는 정수의 가변 "
"시퀀스입니다. :class:`bytes` 형이 가진 대부분의 메서드뿐만 아니라 (:ref:`bytes-methods` 를 보세요),"
" :ref:`typesseq-mutable` 에 기술된 가변 시퀀스의 일반적인 메서드 대부분을 갖고 있습니다."

#: ../Doc/library/functions.rst:139
msgid ""
"The optional *source* parameter can be used to initialize the array in a "
"few different ways:"
msgstr "선택적 *source* 매개변수는 몇 가지 다른 방법으로 배열을 초기화하는 데 사용할 수 있습니다:"

#: ../Doc/library/functions.rst:142
msgid ""
"If it is a *string*, you must also give the *encoding* (and optionally, "
"*errors*) parameters; :func:`bytearray` then converts the string to bytes"
" using :meth:`str.encode`."
msgstr ""
"*문자열* 이면, 반드시 *encoding* 매개변수도 제공해야 합니다 (그리고 선택적으로 *errors* 도); 그러면 "
":func:`bytearray` 는 :meth:`str.encode` 를 사용하여 문자열을 바이트로 변환합니다."

#: ../Doc/library/functions.rst:146
msgid ""
"If it is an *integer*, the array will have that size and will be "
"initialized with null bytes."
msgstr "*정수* 면, 배열은 그 크기를 갖고, 널 바이트로 초기화됩니다."

#: ../Doc/library/functions.rst:149
msgid ""
"If it is an object conforming to the *buffer* interface, a read-only "
"buffer of the object will be used to initialize the bytes array."
msgstr "*버퍼(buffer)* 인터페이스를 제공하는 객체면, 객체의 읽기 전용 버퍼가 바이트 배열을 초기화하는 데 사용됩니다."

#: ../Doc/library/functions.rst:152
msgid ""
"If it is an *iterable*, it must be an iterable of integers in the range "
"``0 <= x < 256``, which are used as the initial contents of the array."
msgstr ""
"*이터러블* 이면, 범위 ``0 <= x < 256`` 의 정수를 제공하는 이터러블이어야 하고, 그 값들이 배열의 초기 내용물로 "
"사용됩니다."

#: ../Doc/library/functions.rst:155
msgid "Without an argument, an array of size 0 is created."
msgstr "인자가 없으면 크기 0의 배열이 만들어집니다."

#: ../Doc/library/functions.rst:157
msgid "See also :ref:`binaryseq` and :ref:`typebytearray`."
msgstr ":ref:`binaryseq`\\와 :ref:`typebytearray` 도 보세요."

#: ../Doc/library/functions.rst:164
msgid ""
"Return a new \"bytes\" object, which is an immutable sequence of integers"
" in the range ``0 <= x < 256``.  :class:`bytes` is an immutable version "
"of :class:`bytearray` -- it has the same non-mutating methods and the "
"same indexing and slicing behavior."
msgstr ""
"새로운 \"바이트열\" 객체를 돌려줍니다. 이 객체는 ``0 <= x < 256`` 범위에 있는 정수의 불변 시퀀스입니다. "
":class:`bytes` 는 :class:`bytearray` 의 불변 버전입니다 -- 같은 불변 메서드와 같은 인덱싱 및 "
"슬라이싱 동작을 갖습니다."

#: ../Doc/library/functions.rst:169
msgid ""
"Accordingly, constructor arguments are interpreted as for "
":func:`bytearray`."
msgstr "따라서 생성자 인자는 :func:`bytearray` 와 같이 해석됩니다."

#: ../Doc/library/functions.rst:171
msgid "Bytes objects can also be created with literals, see :ref:`strings`."
msgstr "바이트열 객체는 리터럴을 사용하여 만들 수도 있습니다 (:ref:`strings` 를 보세요)."

#: ../Doc/library/functions.rst:173
msgid "See also :ref:`binaryseq`, :ref:`typebytes`, and :ref:`bytes-methods`."
msgstr ":ref:`binaryseq`, :ref:`typebytes` 및 :ref:`bytes-methods` 도 보세요."

#: ../Doc/library/functions.rst:178
msgid ""
"Return :const:`True` if the *object* argument appears callable, "
":const:`False` if not.  If this returns true, it is still possible that a"
" call fails, but if it is false, calling *object* will never succeed. "
"Note that classes are callable (calling a class returns a new instance); "
"instances are callable if their class has a :meth:`__call__` method."
msgstr ""
"*object* 인자가 콜러블인 것처럼 보이면 :const:`True`\\를, 그렇지 않으면 :const:`False` 를 "
"돌려줍니다. 이것이 참을 돌려줘도 여전히 호출이 실패할 가능성이 있지만, 거짓일 때 *object* 를 호출하면 반드시 실패합니다."
" 클래스가 콜러블 이라는 것에 유의하세요 (클래스를 호출하면 새 인스턴스를 돌려줍니다); 클래스에 :meth:`__call__` "
"메서드가 있으면 인스턴스도 콜러블입니다."

#: ../Doc/library/functions.rst:184
msgid ""
"This function was first removed in Python 3.0 and then brought back in "
"Python 3.2."
msgstr "이 함수는 파이썬 3.0에서 먼저 제거된 다음 파이썬 3.2에서 다시 도입했습니다."

#: ../Doc/library/functions.rst:191
msgid ""
"Return the string representing a character whose Unicode code point is "
"the integer *i*.  For example, ``chr(97)`` returns the string ``'a'``, "
"while ``chr(8364)`` returns the string ``'€'``. This is the inverse of "
":func:`ord`."
msgstr ""
"유니코드 코드 포인트가 정수 *i* 인 문자를 나타내는 문자열을 돌려줍니다. 예를 들어, ``chr(97)`` 은 문자열 "
"``'a'`` 를 돌려주고, ``chr(8364)`` 는 문자열 ``'€'`` 를 돌려줍니다. 이 것은 :func:`ord` 의 "
"반대입니다."

#: ../Doc/library/functions.rst:195
msgid ""
"The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in"
" base 16).  :exc:`ValueError` will be raised if *i* is outside that "
"range."
msgstr ""
"인자의 유효 범위는 0에서 1,114,111(16진수로 0x10FFFF)까지입니다. *i* 가 이 범위 밖에 있을 때 "
":exc:`ValueError` 가 발생합니다."

#: ../Doc/library/functions.rst:201
msgid "Transform a method into a class method."
msgstr "메서드를 클래스 메서드로 변환합니다."

#: ../Doc/library/functions.rst:203
msgid ""
"A class method receives the class as implicit first argument, just like "
"an instance method receives the instance. To declare a class method, use "
"this idiom::"
msgstr ""
"인스턴스 메서드가 인스턴스를 받는 것처럼, 클래스 메서드는 클래스를 묵시적인 첫 번째 인자로 받습니다. 클래스 메서드를 선언하려면 "
"이 관용구를 사용합니다::"

#: ../Doc/library/functions.rst:211
msgid ""
"The ``@classmethod`` form is a function :term:`decorator` -- see the "
"description of function definitions in :ref:`function` for details."
msgstr ""
"``@classmethod`` 형식은 함수 :term:`데코레이터 <decorator>` 입니다 -- 자세한 내용은 "
":ref:`function` 에 있는 함수 정의에 대한 설명을 보세요."

#: ../Doc/library/functions.rst:214
msgid ""
"It can be called either on the class (such as ``C.f()``) or on an "
"instance (such as ``C().f()``).  The instance is ignored except for its "
"class. If a class method is called for a derived class, the derived class"
" object is passed as the implied first argument."
msgstr ""
"클래스 (``C.f()`` 처럼) 또는 인스턴스 (``C().f()`` 처럼) 를 통해 호출할 수 있습니다. 인스턴스는 클래스만 "
"참조하고 무시됩니다. 파생 클래스에 대해 클래스 메서드가 호출되면, 파생 클래스 객체가 묵시적인 첫 번째 인자로 전달됩니다."

#: ../Doc/library/functions.rst:219
msgid ""
"Class methods are different than C++ or Java static methods. If you want "
"those, see :func:`staticmethod` in this section."
msgstr ""
"클래스 메서드는 C++ 또는 자바의 정적 메서드와 다릅니다. 그것들을 원하면, 이 섹션의 :func:`staticmethod` 를 "
"보세요."

#: ../Doc/library/functions.rst:222
msgid ""
"For more information on class methods, consult the documentation on the "
"standard type hierarchy in :ref:`types`."
msgstr "클래스 메서드에 대한 더 자세한 정보를 원하면, :ref:`types` 에 있는 표준 형 계층에 대한 설명서를 참고하세요."

#: ../Doc/library/functions.rst:228
msgid ""
"Compile the *source* into a code or AST object.  Code objects can be "
"executed by :func:`exec` or :func:`eval`.  *source* can either be a "
"normal string, a byte string, or an AST object.  Refer to the :mod:`ast` "
"module documentation for information on how to work with AST objects."
msgstr ""
"*source* 를 코드 또는 AST 객체로 컴파일합니다. 코드 객체는 :func:`exec` 또는 :func:`eval` 로 "
"실행할 수 있습니다. *source* 는 일반 문자열, 바이트열 또는 AST 객체 일 수 있습니다. AST 객체로 작업하는 방법에 "
"대한 정보는 :mod:`ast` 모듈 문서를 참조하세요."

#: ../Doc/library/functions.rst:233
msgid ""
"The *filename* argument should give the file from which the code was "
"read; pass some recognizable value if it wasn't read from a file "
"(``'<string>'`` is commonly used)."
msgstr ""
"*filename* 인자는 코드를 읽은 파일을 제공해야 합니다; 파일에서 읽지 않으면 인식 가능한 값을 전달합니다 "
"(``'<string>'`` 이 일반적으로 사용됩니다)."

#: ../Doc/library/functions.rst:237
msgid ""
"The *mode* argument specifies what kind of code must be compiled; it can "
"be ``'exec'`` if *source* consists of a sequence of statements, "
"``'eval'`` if it consists of a single expression, or ``'single'`` if it "
"consists of a single interactive statement (in the latter case, "
"expression statements that evaluate to something other than ``None`` will"
" be printed)."
msgstr ""
"*mode* 인자는 컴파일해야 하는 코드 종류를 지정합니다; *source* 가 문장의 시퀀스로 구성되어 있다면 ``exec``, "
"단일 표현식으로 구성되어 있다면 ``'eval'``, 단일 대화형 문장으로 구성되면 ``'single'`` 이 될 수 있습니다 "
"(마지막의 경우 ``None`` 이외의 값으로 구해지는 표현식 문은 인쇄됩니다)."

#: ../Doc/library/functions.rst:243
msgid ""
"The optional arguments *flags* and *dont_inherit* control which future "
"statements (see :pep:`236`) affect the compilation of *source*.  If "
"neither is present (or both are zero) the code is compiled with those "
"future statements that are in effect in the code that is calling "
":func:`compile`.  If the *flags* argument is given and *dont_inherit* is "
"not (or is zero) then the future statements specified by the *flags* "
"argument are used in addition to those that would be used anyway. If "
"*dont_inherit* is a non-zero integer then the *flags* argument is it -- "
"the future statements in effect around the call to compile are ignored."
msgstr ""
"선택적 인자 *flags* 와 *dont_inherit* 는 어떤 퓨처 문(:pep:`236` 참조)이 *source* 의 컴파일에"
" 영향을 미칠지 제어합니다. 둘 다 제공되지 않는 경우 (또는 둘 다 0의 경우), 코드는 :func:`compile` 을 호출하는"
" 코드에 적용되고 있는 퓨처 문으로 컴파일됩니다. *flags* 인자가 주어지고, *dont_inherit* 가 없으면 (또는 0)"
" 원래 사용될 것에 더해 *flags* 인자로 지정된 퓨처 문이 사용됩니다. *dont_inherit* 가 0이 아닌 정수면 "
"*flags* 인자가 사용됩니다 -- compile을 호출하는 코드에 적용되는 퓨처 문은 무시됩니다."

#: ../Doc/library/functions.rst:253
msgid ""
"Future statements are specified by bits which can be bitwise ORed "
"together to specify multiple statements.  The bitfield required to "
"specify a given feature can be found as the "
":attr:`~__future__._Feature.compiler_flag` attribute on the "
":class:`~__future__._Feature` instance in the :mod:`__future__` module."
msgstr ""
"퓨처 문은 여러 개의 문장을 지정하기 위해 비트 OR 될 수 있는 비트에 의해 지정됩니다. 주어진 기능을 지정하는 데 필요한 비트 "
"필드는 :mod:`__future__` 모듈의 :class:`~__future__._Feature` 인스턴스에서 "
":attr:`~__future__._Feature.compiler_flag` 어트리뷰트로 찾을 수 있습니다."

#: ../Doc/library/functions.rst:258
msgid ""
"The argument *optimize* specifies the optimization level of the compiler;"
" the default value of ``-1`` selects the optimization level of the "
"interpreter as given by :option:`-O` options.  Explicit levels are ``0`` "
"(no optimization; ``__debug__`` is true), ``1`` (asserts are removed, "
"``__debug__`` is false) or ``2`` (docstrings are removed too)."
msgstr ""
"인자 *optimize* 는 컴파일러의 최적화 수준을 지정합니다; 기본값 ``-1`` 은 :option:`-O` 옵션에 의해 주어진"
" 인터프리터의 최적화 수준을 선택합니다. 명시적 수준은 ``0`` (최적화 없음, ``__debug__`` 이 참입니다), "
"``1`` (assert가 제거됩니다, ``__debug__`` 이 거짓입니다) 또는 ``2`` 다 (독스트링도 제거됩니다)."

#: ../Doc/library/functions.rst:264
msgid ""
"This function raises :exc:`SyntaxError` if the compiled source is "
"invalid, and :exc:`ValueError` if the source contains null bytes."
msgstr ""
"이 함수는 컴파일된 소스가 올바르지 않으면 :exc:`SyntaxError` 를 일으키고, 소스에 널 바이트가 들어있는 경우 "
":exc:`ValueError` 를 일으킵니다."

#: ../Doc/library/functions.rst:267
msgid ""
"If you want to parse Python code into its AST representation, see "
":func:`ast.parse`."
msgstr "파이썬 코드를 AST 표현으로 파싱하려면, :func:`ast.parse` 를 보세요."

#: ../Doc/library/functions.rst:272
msgid ""
"When compiling a string with multi-line code in ``'single'`` or "
"``'eval'`` mode, input must be terminated by at least one newline "
"character.  This is to facilitate detection of incomplete and complete "
"statements in the :mod:`code` module."
msgstr ""
"``'single'`` 또는 ``'eval'`` mode로 여러 줄 코드를 가진 문자열을 컴파일할 때, 적어도 하나의 개행 문자로 "
"입력을 끝내야 합니다. 이것은 :mod:`code` 모듈에서 문장이 불완전한지 완전한지를 쉽게 탐지하게 하기 위함입니다."

#: ../Doc/library/functions.rst:279
msgid ""
"It is possible to crash the Python interpreter with a sufficiently "
"large/complex string when compiling to an AST object due to stack depth "
"limitations in Python's AST compiler."
msgstr ""
"파이썬의 AST 컴파일러에서 스택 깊이 제한으로 인해, AST 객체로 컴파일할 때 충분히 크고 복잡한 문자열로 파이썬 인터프리터가 "
"크래시를 일으키도록 만들 수 있습니다."

#: ../Doc/library/functions.rst:283
msgid ""
"Allowed use of Windows and Mac newlines.  Also input in ``'exec'`` mode "
"does not have to end in a newline anymore.  Added the *optimize* "
"parameter."
msgstr ""
"윈도우 및 맥의 줄 바꿈을 사용할 수 있습니다. 또한, 이제는 ``'exec'`` mode에서 입력이 줄 넘김 문자로 끝나지 않아도"
" 됩니다. *optimize* 매개변수가 추가되었습니다."

#: ../Doc/library/functions.rst:287
msgid ""
"Previously, :exc:`TypeError` was raised when null bytes were encountered "
"in *source*."
msgstr "이전에는, *source* 에서 널 바이트가 발견될 때 :exc:`TypeError` 가 발생했습니다."

#: ../Doc/library/functions.rst:294
msgid ""
"Return a complex number with the value *real* + *imag*\\*1j or convert a "
"string or number to a complex number.  If the first parameter is a "
"string, it will be interpreted as a complex number and the function must "
"be called without a second parameter.  The second parameter can never be "
"a string. Each argument may be any numeric type (including complex).  If "
"*imag* is omitted, it defaults to zero and the constructor serves as a "
"numeric conversion like :class:`int` and :class:`float`.  If both "
"arguments are omitted, returns ``0j``."
msgstr ""
"*real* + *imag*\\*1j 값을 가진 복소수를 돌려주거나 문자열 또는 숫자를 복소수로 변환합니다. 첫 번째 매개변수가 "
"문자열이면 복소수로 해석되며, 두 번째 매개변수 없이 함수를 호출해야 합니다. 두 번째 매개변수는 결코 문자열 일 수 없습니다. 각"
" 인자는 모든 (복소수를 포함한) 숫자 형이 될 수 있습니다. *imag* 가 생략되면 기본값은 0이고, 생성자는 "
":class:`int` 와 :class:`float`\\와 같은 숫자 변환으로 사용됩니다. 두 인자가 모두 생략되면 ``0j`` 를"
" 돌려줍니다."

#: ../Doc/library/functions.rst:305
msgid ""
"When converting from a string, the string must not contain whitespace "
"around the central ``+`` or ``-`` operator.  For example, "
"``complex('1+2j')`` is fine, but ``complex('1 + 2j')`` raises "
":exc:`ValueError`."
msgstr ""
"문자열을 변환할 때, 문자열은 중앙의 ``+`` 또는 ``-`` 연산자 주위에 공백을 포함해서는 안 됩니다. 예를 들어, "
"``complex('1+2j')`` 는 괜찮지만 ``complex('1 + 2j')`` 는 :exc:`ValueError` 를 "
"일으킵니다."

#: ../Doc/library/functions.rst:310
msgid "The complex type is described in :ref:`typesnumeric`."
msgstr "복소수 형은 :ref:`typesnumeric` 에서 설명합니다."

#: ../Doc/library/functions.rst:312 ../Doc/library/functions.rst:575
#: ../Doc/library/functions.rst:760
msgid "Grouping digits with underscores as in code literals is allowed."
msgstr "코드 리터럴 처럼 숫자를 밑줄로 그룹화할 수 있습니다."

#: ../Doc/library/functions.rst:318
msgid ""
"This is a relative of :func:`setattr`.  The arguments are an object and a"
" string.  The string must be the name of one of the object's attributes."
"  The function deletes the named attribute, provided the object allows "
"it.  For example, ``delattr(x, 'foobar')`` is equivalent to ``del "
"x.foobar``."
msgstr ""
"이것은 :func:`setattr` 의 친척뻘입니다. 인자는 객체와 문자열입니다. 문자열은 객체의 어트리뷰트 중 하나의 이름이어야 "
"합니다. 이 함수는 객체가 허용하는 경우 명명된 어트리뷰트를 삭제합니다. 예를 들어, ``delattr(x, 'foobar')`` "
"는 ``del x.foobar`` 와 동등합니다."

#: ../Doc/library/functions.rst:330
msgid ""
"Create a new dictionary.  The :class:`dict` object is the dictionary "
"class. See :class:`dict` and :ref:`typesmapping` for documentation about "
"this class."
msgstr ""
"새 딕셔너리를 만듭니다. :class:`dict` 객체는 딕셔너리 클래스입니다. 이 클래스에 대한 설명서는 "
":class:`dict` 및 :ref:`typesmapping` 을 보세요."

#: ../Doc/library/functions.rst:333
msgid ""
"For other containers see the built-in :class:`list`, :class:`set`, and "
":class:`tuple` classes, as well as the :mod:`collections` module."
msgstr ""
"다른 컨테이너의 경우 :class:`list`, :class:`set` 및 :class:`tuple` 클래스와 "
":mod:`collections` 모듈을 보세요."

#: ../Doc/library/functions.rst:339
msgid ""
"Without arguments, return the list of names in the current local scope.  "
"With an argument, attempt to return a list of valid attributes for that "
"object."
msgstr ""
"인자가 없으면, 현재 지역 스코프에 있는 이름들의 리스트를 돌려줍니다. 인자가 있으면, 해당 객체에 유효한 어트리뷰트들의 리스트를 "
"돌려주려고 시도합니다."

#: ../Doc/library/functions.rst:342
msgid ""
"If the object has a method named :meth:`__dir__`, this method will be "
"called and must return the list of attributes. This allows objects that "
"implement a custom :func:`__getattr__` or :func:`__getattribute__` "
"function to customize the way :func:`dir` reports their attributes."
msgstr ""
"객체에 :meth:`__dir__` 메서드가 있으면, 이 메서드가 호출되는데, 반드시 어트리뷰트 리스트를 돌려줘야 합니다. 이렇게 "
"하면 커스텀 :func:`__getattr__` 또는 :func:`__getattribute__` 함수를 구현하는 객체가 "
":func:`dir` 이 어트리뷰트들을 보고하는 방법을 커스터마이즈할 수 있습니다."

#: ../Doc/library/functions.rst:347
msgid ""
"If the object does not provide :meth:`__dir__`, the function tries its "
"best to gather information from the object's :attr:`~object.__dict__` "
"attribute, if defined, and from its type object.  The resulting list is "
"not necessarily complete, and may be inaccurate when the object has a "
"custom :func:`__getattr__`."
msgstr ""
"객체가 :meth:`__dir__` 을 제공하지 않으면, 함수는 (정의되었다면) 객체의 :attr:`~object.__ "
"dict__` 어트리뷰트와 형 객체로부터 정보를 수집하기 위해 최선을 다합니다. 결과로 얻어지는 리스트는 반드시 완전하지는 않으며,"
" 객체가 커스텀 :func:`__getattr__` 을 가질 때 부정확할 수도 있습니다."

#: ../Doc/library/functions.rst:352
msgid ""
"The default :func:`dir` mechanism behaves differently with different "
"types of objects, as it attempts to produce the most relevant, rather "
"than complete, information:"
msgstr ""
"기본 :func:`dir` 메커니즘은 다른 형의 객체에 대해서 다르게 동작하는데, 완전한 정보보다는 가장 적절한 정보를 만들려고 "
"시도하기 때문입니다:"

#: ../Doc/library/functions.rst:356
msgid ""
"If the object is a module object, the list contains the names of the "
"module's attributes."
msgstr "객체가 모듈 객체면, 리스트에는 모듈 어트리뷰트의 이름이 포함됩니다."

#: ../Doc/library/functions.rst:359
msgid ""
"If the object is a type or class object, the list contains the names of "
"its attributes, and recursively of the attributes of its bases."
msgstr "객체가 형 또는 클래스 객체면, 리스트에는 그것의 어트리뷰트 이름과 베이스의 어트리뷰트 이름들이 재귀적으로 포함됩니다."

#: ../Doc/library/functions.rst:362
msgid ""
"Otherwise, the list contains the object's attributes' names, the names of"
" its class's attributes, and recursively of the attributes of its class's"
" base classes."
msgstr ""
"그 밖의 경우, 리스트에는 객체의 어트리뷰트 이름, 해당 클래스의 어트리뷰트 이름 및 해당 클래스의 베이스 클래스들의 어트리뷰트 "
"이름을 재귀적으로 포함합니다."

#: ../Doc/library/functions.rst:366
msgid "The resulting list is sorted alphabetically.  For example:"
msgstr "결과 리스트는 알파벳 순으로 정렬됩니다. 예를 들어:"

#: ../Doc/library/functions.rst:385
msgid ""
"Because :func:`dir` is supplied primarily as a convenience for use at an "
"interactive prompt, it tries to supply an interesting set of names more "
"than it tries to supply a rigorously or consistently defined set of "
"names, and its detailed behavior may change across releases.  For "
"example, metaclass attributes are not in the result list when the "
"argument is a class."
msgstr ""
":func:`dir` 은 주로 대화형 프롬프트에서의 사용 편의를 위해 제공되기 때문에, 엄격하거나 일관되게 정의된 이름 집합을 "
"제공하기보다 흥미로운 이름 집합을 제공하려고 시도하며, 상세한 동작은 배포마다 변경될 수 있습니다. 예를 들어, 인자가 클래스면 "
"메타 클래스 어트리뷰트는 결과 리스트에 없습니다."

#: ../Doc/library/functions.rst:395
msgid ""
"Take two (non complex) numbers as arguments and return a pair of numbers "
"consisting of their quotient and remainder when using integer division.  "
"With mixed operand types, the rules for binary arithmetic operators "
"apply.  For integers, the result is the same as ``(a // b, a % b)``. For "
"floating point numbers the result is ``(q, a % b)``, where *q* is usually"
" ``math.floor(a / b)`` but may be 1 less than that.  In any case ``q * b "
"+ a % b`` is very close to *a*, if ``a % b`` is non-zero it has the same "
"sign as *b*, and ``0 <= abs(a % b) < abs(b)``."
msgstr ""
"두 개의 (복소수가 아닌) 숫자를 인자로 취하고 정수 나누기를 사용할 때의 몫과 나머지로 구성된 한 쌍의 숫자를 돌려줍니다. 두 "
"인자의 형이 다른 경우, 이 항 산술 연산자에 대한 규칙이 적용됩니다. 정수의 경우, 결과는 ``(a // b, a % b)`` 와"
" 같습니다. 부동 소수점 숫자의 경우 결과는 ``(q, a % b)`` 인데, *q* 는 보통 ``math.floor(a / "
"b)`` 이지만, 이보다 1작을 수 있습니다. 어떤 경우건 ``q * b + a % b`` 는 *a* 에 매우 가깝습니다. ``a "
"% b`` 는 0이 아닐 때 *b* 와 같은 부호를 가지며, ``0 <= abs(a % b) < abs(b)`` 가 성립합니다."

#: ../Doc/library/functions.rst:407
msgid ""
"Return an enumerate object. *iterable* must be a sequence, an "
":term:`iterator`, or some other object which supports iteration. The "
":meth:`~iterator.__next__` method of the iterator returned by "
":func:`enumerate` returns a tuple containing a count (from *start* which "
"defaults to 0) and the values obtained from iterating over *iterable*."
msgstr ""
"열거 객체를 돌려줍니다. *iterable* 은 시퀀스, :term:`이터레이터 <iterator>` 또는 이터레이션을 지원하는 "
"다른 객체여야 합니다. :func:`enumerate` 에 의해 반환된 이터레이터의 :meth:`~iterator.__next__`"
" 메서드는 카운트 (기본값 0을 갖는 *start* 부터)와 *iterable* 을 이터레이션 해서 얻어지는 값을 포함하는 튜플을 "
"돌려줍니다."

#: ../Doc/library/functions.rst:419
msgid "Equivalent to::"
msgstr "다음과 동등합니다::"

#: ../Doc/library/functions.rst:430
msgid ""
"The arguments are a string and optional globals and locals.  If provided,"
" *globals* must be a dictionary.  If provided, *locals* can be any "
"mapping object."
msgstr ""
"인자는 문자열 및 선택적 globals 및 locals다. 제공된 경우, *globals* 는 딕셔너리여야 합니다. 제공되는 경우,"
" *locals* 는 모든 매핑 객체가 될 수 있습니다."

#: ../Doc/library/functions.rst:434
msgid ""
"The *expression* argument is parsed and evaluated as a Python expression "
"(technically speaking, a condition list) using the *globals* and *locals*"
" dictionaries as global and local namespace.  If the *globals* dictionary"
" is present and lacks '__builtins__', the current globals are copied into"
" *globals* before *expression* is parsed.  This means that *expression* "
"normally has full access to the standard :mod:`builtins` module and "
"restricted environments are propagated.  If the *locals* dictionary is "
"omitted it defaults to the *globals* dictionary.  If both dictionaries "
"are omitted, the expression is executed in the environment where "
":func:`eval` is called.  The return value is the result of the evaluated "
"expression. Syntax errors are reported as exceptions.  Example:"
msgstr ""
"*expression* 인자는 전역 및 지역 이름 공간으로 *globals* 및 *locals* 딕셔너리를 사용하여 파이썬 "
"표현식(기술적으로 말하면, 조건 목록)으로 파싱 되고 값이 구해집니다. *globals* 사전이 제공되고 '__builtins__'"
" 가 없으면 *expression* 가 파싱 되기 전에 현재 전역 변수가 *globals* 에 복사됩니다. 이는 "
"*expression* 이 일반적으로 표준 :mod:`builtins` 모듈에 대한 모든 액세스 권한을 가지며 제한된 환경이 "
"전파됨을 뜻합니다. *locals* 딕셔너리를 생략하면 기본적으로 *globals* 딕셔너리가 사용됩니다. 두 딕셔너리가 모두 "
"생략되면, 표현식은 :func:`eval` 이 호출되는 환경에서 실행됩니다. 반환 값은 계산된 표현식의 결과입니다. 문법 에러는 "
"예외로 보고됩니다. 예:"

#: ../Doc/library/functions.rst:449
msgid ""
"This function can also be used to execute arbitrary code objects (such as"
" those created by :func:`compile`).  In this case pass a code object "
"instead of a string.  If the code object has been compiled with "
"``'exec'`` as the *mode* argument, :func:`eval`\\'s return value will be "
"``None``."
msgstr ""
"이 함수는 임의의 코드 객체 (:func:`compile`\\로 만든 것과 같은)를 실행하는 데에도 사용할 수 있습니다. 이 경우 "
"문자열 대신 코드 객체를 전달합니다. 코드 객체가 mode 인자 ``'exec'`` 로 컴파일되었다면, :func:`eval` 의 "
"반환 값은 ``None`` 입니다."

#: ../Doc/library/functions.rst:454
msgid ""
"Hints: dynamic execution of statements is supported by the :func:`exec` "
"function.  The :func:`globals` and :func:`locals` functions returns the "
"current global and local dictionary, respectively, which may be useful to"
" pass around for use by :func:`eval` or :func:`exec`."
msgstr ""
"힌트: 문장의 동적 실행은 :func:`exec` 함수에 의해 지원됩니다. :func:`globals`\\와 "
":func:`locals` 함수는 각각 현재의 전역과 지역 딕셔너리를 반환하는데, :func:`eval` 또는 "
":func:`exec` 에 전달하는 데 유용합니다."

#: ../Doc/library/functions.rst:459
msgid ""
"See :func:`ast.literal_eval` for a function that can safely evaluate "
"strings with expressions containing only literals."
msgstr "리터럴 만 포함 된 표현식의 값을 안전하게 구할 수 있는 함수 :func:`ast.literal_eval` 를 보세요."

#: ../Doc/library/functions.rst:466
msgid ""
"This function supports dynamic execution of Python code. *object* must be"
" either a string or a code object.  If it is a string, the string is "
"parsed as a suite of Python statements which is then executed (unless a "
"syntax error occurs). [#]_ If it is a code object, it is simply executed."
"  In all cases, the code that's executed is expected to be valid as file "
"input (see the section \"File input\" in the Reference Manual). Be aware "
"that the :keyword:`return` and :keyword:`yield` statements may not be "
"used outside of function definitions even within the context of code "
"passed to the :func:`exec` function. The return value is ``None``."
msgstr ""
"이 함수는 파이썬 코드의 동적 실행을 지원합니다. *object* 는 문자열 또는 코드 객체여야 합니다. 문자열이면 문자열은 파이썬"
" 문장들의 스위트로 파싱된 후 (문법 에러가 발생하지 않는 한) 실행됩니다. [#]_ 코드 객체면, 단순히 실행됩니다. 모든 "
"경우에, 실행되는 코드는 파일 입력으로 올바를 것이 기대됩니다 (레퍼런스 설명서의 \"파일 입력\" 섹션을 보세요). "
":keyword:`return`\\과 :keyword:`yield` 문은 :func:`exec` 함수에 전달 된 코드 문맥 "
"안에서조차도 함수 정의 밖에서 사용될 수 없음에 유의하세요. 반환 값은 ``None`` 입니다."

#: ../Doc/library/functions.rst:476
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in "
"the current scope.  If only *globals* is provided, it must be a "
"dictionary, which will be used for both the global and the local "
"variables.  If *globals* and *locals* are given, they are used for the "
"global and local variables, respectively.  If provided, *locals* can be "
"any mapping object.  Remember that at module level, globals and locals "
"are the same dictionary. If exec gets two separate objects as *globals* "
"and *locals*, the code will be executed as if it were embedded in a class"
" definition."
msgstr ""
"모든 경우에, 선택적 부분을 생략하면, 현재 스코프에서 코드가 실행됩니다. *globals* 만 제공된 경우, 사전이어야 하며, "
"전역과 지역 변수 모두에 사용됩니다. *globals* 및 *locals* 가 주어지면, 전역과 지역 변수에 각각 사용됩니다. "
"제공되는 경우, *locals* 는 모든 매핑 객체가 될 수 있습니다. 모듈 수준에서, 전역과 지역은 같은 딕셔너리임을 기억하세요."
" exec 가 *globals* 와 *locals* 로 별도의 객체를 받으면, 코드는 클래스 정의에 포함된 것처럼 실행됩니다."

#: ../Doc/library/functions.rst:485
msgid ""
"If the *globals* dictionary does not contain a value for the key "
"``__builtins__``, a reference to the dictionary of the built-in module "
":mod:`builtins` is inserted under that key.  That way you can control "
"what builtins are available to the executed code by inserting your own "
"``__builtins__`` dictionary into *globals* before passing it to "
":func:`exec`."
msgstr ""
"*globals* 딕셔너리가 ``__builtins__`` 를 키로 하는 값을 갖고 있지 않으면, 그 키로 내장 모듈 "
":mod:`builtins` 에 대한 참조가 삽입됩니다. 이런 식으로 :func:`exec` 에 전달하기 전에 *globals* 에"
" 여러분 자신의 ``__builtins__`` 딕셔너리를 삽입함으로써, 실행되는 코드에 어떤 내장 객체들이 제공될지를 제어할 수 "
"있습니다."

#: ../Doc/library/functions.rst:493
msgid ""
"The built-in functions :func:`globals` and :func:`locals` return the "
"current global and local dictionary, respectively, which may be useful to"
" pass around for use as the second and third argument to :func:`exec`."
msgstr ""
"내장 함수 :func:`globals`\\와 :func:`locals` 는 각각 현재 전역 및 지역 딕셔너리를 돌려주는데, "
":func:`exec` 로 전달되는 두 번째 및 세 번째 인자로 사용하는 데 유용합니다."

#: ../Doc/library/functions.rst:499
msgid ""
"The default *locals* act as described for function :func:`locals` below: "
"modifications to the default *locals* dictionary should not be attempted."
" Pass an explicit *locals* dictionary if you need to see effects of the "
"code on *locals* after function :func:`exec` returns."
msgstr ""
"기본 *locals* 는 아래 함수 :func:`locals` 에 설명된 대로 작동합니다: 기본 *locals* 사전에 대해 수정이"
" 시도되어서는 안 됩니다. 함수 :func:`exec` 가 돌아온 후에 *locals* 에 코드가 만든 효과를 보려면 명시적으로 "
"*locals* 딕셔너리를 전달해야 합니다."

#: ../Doc/library/functions.rst:507
msgid ""
"Construct an iterator from those elements of *iterable* for which "
"*function* returns true.  *iterable* may be either a sequence, a "
"container which supports iteration, or an iterator.  If *function* is "
"``None``, the identity function is assumed, that is, all elements of "
"*iterable* that are false are removed."
msgstr ""
"*function* 이 참을 돌려주는 *iterable* 의 요소들로 이터레이터를 구축합니다. *iterable* 은 시퀀스, "
"이터레이션을 지원하는 컨테이너 또는 이터레이터 일 수 있습니다. *function* 이 ``None`` 이면, 항등함수가 "
"가정됩니다, 즉, 거짓인 *iterable* 의 모든 요소가 제거됩니다."

#: ../Doc/library/functions.rst:513
msgid ""
"Note that ``filter(function, iterable)`` is equivalent to the generator "
"expression ``(item for item in iterable if function(item))`` if function "
"is not ``None`` and ``(item for item in iterable if item)`` if function "
"is ``None``."
msgstr ""
"``filter(function, iterable)`` 는 function이 ``None`` 이 아닐 때 제너레이터 표현식 "
"``(item for item in iterable if function(item))`` 과, ``None`` 일 때 ``(item"
" for item in iterable if item)`` 와 동등함에 유의하세요."

#: ../Doc/library/functions.rst:518
msgid ""
"See :func:`itertools.filterfalse` for the complementary function that "
"returns elements of *iterable* for which *function* returns false."
msgstr ""
"*function* 이 거짓을 돌려주는 *iterable* 의 요소들을 돌려주는 상보적인 함수는 "
":func:`itertools.filterfalse` 를 보세요."

#: ../Doc/library/functions.rst:528
msgid "Return a floating point number constructed from a number or string *x*."
msgstr "숫자 또는 문자열 *x* 로 부터 실수를 만들어 돌려줍니다."

#: ../Doc/library/functions.rst:530
msgid ""
"If the argument is a string, it should contain a decimal number, "
"optionally preceded by a sign, and optionally embedded in whitespace.  "
"The optional sign may be ``'+'`` or ``'-'``; a ``'+'`` sign has no effect"
" on the value produced.  The argument may also be a string representing a"
" NaN (not-a-number), or a positive or negative infinity.  More precisely,"
" the input must conform to the following grammar after leading and "
"trailing whitespace characters are removed:"
msgstr ""
"인자가 문자열이면, 십진수를 포함해야 하고, 선택적으로 부호가 앞에 오며 선택적으로 공백으로 둘러싸일 수 있습니다. 선택적 부호는 "
"``'+'`` 또는 ``'-'`` 일 수 있습니다; ``'+'`` 부호는 생성되는 값에 아무런 영향을 주지 않습니다. 인자는 NaN"
" (not-a-number) 또는 양 또는 음의 무한대를 나타내는 문자열 일 수도 있습니다. 더욱 정확하게, 입력은 앞과 뒤의 공백"
" 문자를 제거한 후 다음 문법을 따라야 합니다:"

#: ../Doc/library/functions.rst:545
msgid ""
"Here ``floatnumber`` is the form of a Python floating-point literal, "
"described in :ref:`floating`.  Case is not significant, so, for example, "
"\"inf\", \"Inf\", \"INFINITY\" and \"iNfINity\" are all acceptable "
"spellings for positive infinity."
msgstr ""
"여기서 ``floatnumber`` 는 :ref:`floating` 에 설명된 파이썬 실수 리터럴의 형식입니다. 대/소문자는 "
"중요하지 않아서, 예를 들면, \"inf\", \"Inf\", \"INFINITY\" 및 \"iNfINity\"는 모두 양의 "
"무한대에 대해 허용되는 철자입니다."

#: ../Doc/library/functions.rst:550
msgid ""
"Otherwise, if the argument is an integer or a floating point number, a "
"floating point number with the same value (within Python's floating point"
" precision) is returned.  If the argument is outside the range of a "
"Python float, an :exc:`OverflowError` will be raised."
msgstr ""
"그렇지 않으면, 인자가 정수 또는 실수면 (파이썬의 부동 소수점 정밀도 내에서) 같은 값을 가진 실수가 반환됩니다. 인자가 파이썬 "
"float 범위를 벗어나면, :exc:`OverflowError` 가 발생합니다."

#: ../Doc/library/functions.rst:555
msgid ""
"For a general Python object ``x``, ``float(x)`` delegates to "
"``x.__float__()``."
msgstr "일반적인 파이썬 객체 ``x`` 의 경우, ``float (x)`` 는 ``x .__ float __ ()`` 로 위임합니다."

#: ../Doc/library/functions.rst:558
msgid "If no argument is given, ``0.0`` is returned."
msgstr "인자가 주어지지 않으면, ``0.0`` 을 돌려줍니다."

#: ../Doc/library/functions.rst:560
msgid "Examples::"
msgstr "예::"

#: ../Doc/library/functions.rst:573
msgid "The float type is described in :ref:`typesnumeric`."
msgstr "float 형은 :ref:`typesnumeric` 에 설명되어 있습니다."

#: ../Doc/library/functions.rst:585
msgid ""
"Convert a *value* to a \"formatted\" representation, as controlled by "
"*format_spec*.  The interpretation of *format_spec* will depend on the "
"type of the *value* argument, however there is a standard formatting "
"syntax that is used by most built-in types: :ref:`formatspec`."
msgstr ""
"*format_spec* 의 제어에 따라, *value* 를 \"포맷된\" 표현으로 변환합니다. *format_spec* 의 해석은"
" *value* 인자의 형에 의존하지만, 대부분의 내장형에 의해 사용되는 표준 포매팅 문법이 있습니다: "
":ref:`formatspec`."

#: ../Doc/library/functions.rst:590
msgid ""
"The default *format_spec* is an empty string which usually gives the same"
" effect as calling :func:`str(value) <str>`."
msgstr ""
"기본 *format_spec* 은 빈 문자열이며 일반적으로 :func:`str(value) <str>` 를 호출하는 것과 같은 "
"효과를 줍니다."

#: ../Doc/library/functions.rst:593
msgid ""
"A call to ``format(value, format_spec)`` is translated to "
"``type(value).__format__(value, format_spec)`` which bypasses the "
"instance dictionary when searching for the value's :meth:`__format__` "
"method.  A :exc:`TypeError` exception is raised if the method search "
"reaches :mod:`object` and the *format_spec* is non-empty, or if either "
"the *format_spec* or the return value are not strings."
msgstr ""
"``format(value, format_spec)`` 에 대한 호출은 ``type(value).__format__(value, "
"format_spec)`` 로 번역되는데, value의 :meth:`__format__` 메서드를 검색할 때 인스턴스 딕셔너리를 "
"건너뜁니다. 메서드 검색이 :mod:`object` 에 도달하고 *format_spec* 이 비어 있지 않거나, "
"*format_spec* 또는 반환 값이 문자열이 아닌 경우 :exc:`TypeError` 예외가 발생합니다."

#: ../Doc/library/functions.rst:600
msgid ""
"``object().__format__(format_spec)`` raises :exc:`TypeError` if "
"*format_spec* is not an empty string."
msgstr ""
"``object().__format__(format_spec)`` 은 *format_spec* 이 빈 문자열이 아닌 경우 "
":exc:`TypeError` 를 일으킵니다."

#: ../Doc/library/functions.rst:609
msgid ""
"Return a new :class:`frozenset` object, optionally with elements taken "
"from *iterable*.  ``frozenset`` is a built-in class.  See "
":class:`frozenset` and :ref:`types-set` for documentation about this "
"class."
msgstr ""
"새 :class:`frozenset` 객체를 돌려주는데, 선택적으로 *iterable* 에서 가져온 요소를 포함합니다. "
"``frozenset`` 은 내장 클래스입니다. 이 클래스에 대한 설명서는 :class:`frozenset` 과 :ref"
":`types-set`\\을 보세요."

#: ../Doc/library/functions.rst:613
msgid ""
"For other containers see the built-in :class:`set`, :class:`list`, "
":class:`tuple`, and :class:`dict` classes, as well as the "
":mod:`collections` module."
msgstr ""
"다른 컨테이너의 경우 :class:`set`, :class:`list`, :class:`tuple` 및 :class:`dict` "
"클래스와 :mod:`collections` 모듈을 보세요."

#: ../Doc/library/functions.rst:620
msgid ""
"Return the value of the named attribute of *object*.  *name* must be a "
"string. If the string is the name of one of the object's attributes, the "
"result is the value of that attribute.  For example, ``getattr(x, "
"'foobar')`` is equivalent to ``x.foobar``.  If the named attribute does "
"not exist, *default* is returned if provided, otherwise "
":exc:`AttributeError` is raised."
msgstr ""
"주어진 이름의 *object* 어트리뷰트를 돌려줍니다. *name* 은 문자열이어야 합니다. 문자열이 객체의 어트리뷰트 중 하나의 "
"이름이면, 결과는 그 어트리뷰트의 값입니다. 예를 들어, ``getattr(x, 'foobar')`` 는 ``x.foobar`` 와"
" 동등합니다. 명명된 어트리뷰트가 없으면, *default* 가 제공되는 경우 그 값이 반환되고, 그렇지 않으면 "
":exc:`AttributeError` 가 발생합니다."

#: ../Doc/library/functions.rst:629
msgid ""
"Return a dictionary representing the current global symbol table. This is"
" always the dictionary of the current module (inside a function or "
"method, this is the module where it is defined, not the module from which"
" it is called)."
msgstr ""
"현재 전역 심볼 테이블을 나타내는 딕셔너리를 돌려줍니다. 이것은 항상 현재 모듈의 딕셔너리입니다 (함수 또는 메서드 내에서, 이 "
"모듈은 그것들을 호출하는 모듈이 아니라, 그것들이 정의된 모듈입니다)."

#: ../Doc/library/functions.rst:636
msgid ""
"The arguments are an object and a string.  The result is ``True`` if the "
"string is the name of one of the object's attributes, ``False`` if not. "
"(This is implemented by calling ``getattr(object, name)`` and seeing "
"whether it raises an :exc:`AttributeError` or not.)"
msgstr ""
"인자는 객체와 문자열입니다. 문자열이 객체의 속성 중 하나의 이름이면 결과는``True` 이고, 그렇지 않으면 ``False`` 가"
" 됩니다. (이것은 ``getattr(object, name)`` 을 호출하고 :exc:`AttributeError` 를 "
"발생시키는지를 보는 식으로 구현됩니다.)"

#: ../Doc/library/functions.rst:644
msgid ""
"Return the hash value of the object (if it has one).  Hash values are "
"integers.  They are used to quickly compare dictionary keys during a "
"dictionary lookup.  Numeric values that compare equal have the same hash "
"value (even if they are of different types, as is the case for 1 and "
"1.0)."
msgstr ""
"객체의 해시값을 돌려줍니다 (해시가 있는 경우). 해시값은 정수다. 딕셔너리 조회 중에 딕셔너리 키를 빨리 비교하는 데 사용됩니다."
" 같다고 비교되는 숫자 값은 같은 해시값을 갖습니다 (1과 1.0의 경우와 같이 형이 다른 경우조차도 그렇습니다)."

#: ../Doc/library/functions.rst:651
msgid ""
"For objects with custom :meth:`__hash__` methods, note that :func:`hash` "
"truncates the return value based on the bit width of the host machine. "
"See :meth:`__hash__` for details."
msgstr ""
"커스텀 :meth:`__hash__` 메서드를 가진 객체의 경우, :func:`hash` 는 호스트 기계의 비트 폭을 기준으로 반환"
" 값을 잘라 버리는 것에 주의하세요. 자세한 내용은 :meth:`__hash__` 를 보세요."

#: ../Doc/library/functions.rst:657
msgid ""
"Invoke the built-in help system.  (This function is intended for "
"interactive use.)  If no argument is given, the interactive help system "
"starts on the interpreter console.  If the argument is a string, then the"
" string is looked up as the name of a module, function, class, method, "
"keyword, or documentation topic, and a help page is printed on the "
"console.  If the argument is any other kind of object, a help page on the"
" object is generated."
msgstr ""
"내장 도움말 시스템을 호출합니다. (이 함수는 대화형 사용을 위한 것입니다.) 인자가 제공되지 않으면, 인터프리터 콘솔에서 대화형 "
"도움말 시스템이 시작됩니다. 인자가 문자열이면 문자열은 모듈, 함수, 클래스, 메서드, 키워드 또는 설명서 주제의 이름으로 "
"조회되고, 도움말 페이지가 콘솔에 인쇄됩니다. 인자가 다른 종류의 객체면, 객체에 대한 도움말 페이지가 만들어집니다."

#: ../Doc/library/functions.rst:664
msgid ""
"This function is added to the built-in namespace by the :mod:`site` "
"module."
msgstr "이 함수는 :mod:`site` 모듈에 의해 내장 이름 공간에 추가됩니다."

#: ../Doc/library/functions.rst:666
msgid ""
"Changes to :mod:`pydoc` and :mod:`inspect` mean that the reported "
"signatures for callables are now more comprehensive and consistent."
msgstr ""
":mod:`pydoc` 과 :mod:`inspect` 의 변경 사항은 콜러블의 시그니처가 이제 더 포괄적이고 일관성이 있음을 "
"의미합니다."

#: ../Doc/library/functions.rst:673
msgid ""
"Convert an integer number to a lowercase hexadecimal string prefixed with"
" \"0x\". If *x* is not a Python :class:`int` object, it has to define an "
":meth:`__index__` method that returns an integer. Some examples:"
msgstr ""
"정수를 \"0x\" 접두사가 붙은 소문자 16진수 문자열로 변환합니다. *x* 가 파이썬 :class:`int` 객체가 아니면, "
"정수를 돌려주는 :meth:`__index__` 메서드를 정의해야 합니다. 몇 가지 예:"

#: ../Doc/library/functions.rst:682
msgid ""
"If you want to convert an integer number to an uppercase or lower "
"hexadecimal string with prefix or not, you can use either of the "
"following ways:"
msgstr "정수를 대문자 또는 소문자 16진수로, 접두사가 있거나 없는 형태로 변환하려면 다음 방법의 하나를 사용할 수 있습니다:"

#: ../Doc/library/functions.rst:694
msgid ""
"See also :func:`int` for converting a hexadecimal string to an integer "
"using a base of 16."
msgstr "16진수 문자열을 진수 16을 사용해서 정수로 변환하려면 :func:`int` 도 보세요."

#: ../Doc/library/functions.rst:699
msgid ""
"To obtain a hexadecimal string representation for a float, use the "
":meth:`float.hex` method."
msgstr "float에 대한 16진수 문자열 표현을 얻으려면, :meth:`float.hex` 메서드를 사용하세요."

#: ../Doc/library/functions.rst:705
msgid ""
"Return the \"identity\" of an object.  This is an integer which is "
"guaranteed to be unique and constant for this object during its lifetime."
" Two objects with non-overlapping lifetimes may have the same :func:`id` "
"value."
msgstr ""
"객체의 \"아이덴티티\"를 돌려준다. 이것은 객체의 수명 동안 유일하고 바뀌지 않음이 보장되는 정수입니다. 수명이 겹치지 않는 두 "
"개의 객체는 같은 :func:`id` 값을 가질 수 있습니다."

#: ../Doc/library/functions.rst:715
msgid ""
"If the *prompt* argument is present, it is written to standard output "
"without a trailing newline.  The function then reads a line from input, "
"converts it to a string (stripping a trailing newline), and returns that."
"  When EOF is read, :exc:`EOFError` is raised.  Example::"
msgstr ""
"*prompt* 인자가 있으면, 끝에 개행 문자를 붙이지 않고 표준 출력에 씁니다. 그런 다음 함수는 입력에서 한 줄을 읽고, "
"문자열로 변환해서 (줄 끝의 줄 바꿈 문자를 제거한다) 돌려줍니다. EOF를 읽으면 :exc:`EOFError` 를 일으킵니다. "
"예::"

#: ../Doc/library/functions.rst:725
msgid ""
"If the :mod:`readline` module was loaded, then :func:`input` will use it "
"to provide elaborate line editing and history features."
msgstr ""
":mod:`readline` 모듈이 로드되었다면, :func:`input` 은 그것을 사용하여 정교한 줄 편집과 히스토리 기능을 "
"제공합니다."

#: ../Doc/library/functions.rst:732
msgid ""
"Return an integer object constructed from a number or string *x*, or "
"return ``0`` if no arguments are given.  If *x* defines :meth:`__int__`, "
"``int(x)`` returns ``x.__int__()``.  If *x* defines :meth:`__trunc__`, it"
" returns ``x.__trunc__()``. For floating point numbers, this truncates "
"towards zero."
msgstr ""
"숫자 나 문자열 *x* 로 부터 만들어진 정수 객체를 돌려줍니다. 인자가 주어지지 않으면 ``0`` 을 돌려줍니다. *x* 가 "
":meth:`__int__` 를 정의하면, ``int(x)`` 는 ``x.__int__()`` 를 돌려줍니다. *x* 가 "
":meth:`__trunc__` 를 정의하면, ``x.__trunc__()`` 를 돌려줍니다. 실수의 경우 이 함수는 0 향해 "
"자릅니다."

#: ../Doc/library/functions.rst:738
msgid ""
"If *x* is not a number or if *base* is given, then *x* must be a string, "
":class:`bytes`, or :class:`bytearray` instance representing an "
":ref:`integer literal <integers>` in radix *base*.  Optionally, the "
"literal can be preceded by ``+`` or ``-`` (with no space in between) and "
"surrounded by whitespace.  A base-n literal consists of the digits 0 to "
"n-1, with ``a`` to ``z`` (or ``A`` to ``Z``) having values 10 to 35.  The"
" default *base* is 10. The allowed values are 0 and 2--36. Base-2, -8, "
"and -16 literals can be optionally prefixed with ``0b``/``0B``, "
"``0o``/``0O``, or ``0x``/``0X``, as with integer literals in code.  Base "
"0 means to interpret exactly as a code literal, so that the actual base "
"is 2, 8, 10, or 16, and so that ``int('010', 0)`` is not legal, while "
"``int('010')`` is, as well as ``int('010', 8)``."
msgstr ""
"*x* 가 숫자가 아니거나 *base* 가 주어지면, *x* 는 문자열, :class:`bytes`, 또는 "
":class:`bytearray` 인스턴스여야 하는데, 진수 *base* 의 :ref:`integer literal "
"<integers>` 을 나타내야 합니다. 선택적으로, 리터럴은 (사이에 공백 없이) ``+`` 또는 ``-`` 를 앞에 붙일 수 "
"있고, 앞뒤로 공백에 둘러싸일 수 있습니다. 진수-n 리터럴은 0에서 n-1까지의 숫자로 구성되며, ``a`` 에서 ``z`` "
"(또는 ``A`` 에서 ``Z``) 가 10에서 35 사이의 값을 가집니다. 기본 *base* 는 10입니다. 허용되는 값은 0과 "
"2--36입니다. 코드에서의 리터럴 처럼, 진수-2, -8 및 -16 리터럴에는 선택적으로 ``0b``/``0B``, "
"``0o``/``0O`` 또는 ``0x``/``0X`` 접두사가 붙을 수 있습니다. base 0은 코드 리터럴과 똑같이 해석하라는 "
"뜻이기 때문에, 실제 진수는 2, 8, 10 또는 16이고, 그래서 ``int('010', 0)`` 는 올바르지 않지만 "
"``int('010', 8)`` 뿐만 아니라 ``int('010')`` 도 올바릅니다."

#: ../Doc/library/functions.rst:751
msgid "The integer type is described in :ref:`typesnumeric`."
msgstr "정수 형은 :ref:`typesnumeric` 에 설명되어 있습니다."

#: ../Doc/library/functions.rst:753
msgid ""
"If *base* is not an instance of :class:`int` and the *base* object has a "
":meth:`base.__index__ <object.__index__>` method, that method is called "
"to obtain an integer for the base.  Previous versions used "
":meth:`base.__int__ <object.__int__>` instead of :meth:`base.__index__ "
"<object.__index__>`."
msgstr ""
"*base* 가 :class:`int` 의 인스턴스가 아니고 *base* 객체가 :meth:`base.__index__ "
"<object.__index__>` 메서드를 가지면, 그 진수로 쓸 정수를 얻기 위해 그 메서드를 호출합니다. 예전 버전에서는 "
":meth:`base.__index__ <object.__index__>` 대신에 :meth:`base.__int__ "
"<object.__int__>` 가 사용되었습니다."

#: ../Doc/library/functions.rst:766
msgid ""
"Return true if the *object* argument is an instance of the *classinfo* "
"argument, or of a (direct, indirect or :term:`virtual <abstract base "
"class>`) subclass thereof.  If *object* is not an object of the given "
"type, the function always returns false. If *classinfo* is a tuple of "
"type objects (or recursively, other such tuples), return true if *object*"
" is an instance of any of the types. If *classinfo* is not a type or "
"tuple of types and such tuples, a :exc:`TypeError` exception is raised."
msgstr ""
"*object* 인자가 *classinfo* 인자 또는 그것의 (직접, 간접 혹은 :term:`가상 <abstract base "
"class>`) 서브 클래스의 인스턴스면 참을 돌려줍니다. *object* 가 주어진 형의 객체가 아니면, 함수는 항상 거짓을 "
"돌려줍니다. *classinfo* 가 형 객체들의 튜플 (또는 재귀적으로 이런 종류의 튜플이 중첩된 튜플) 이면, *object* "
"가 그 형 중 어느 하나의 인스턴스일 때 참을 돌려줍니다. *classinfo* 가 형이나, 형들의 튜플이나, 이런 튜플들의 튜플이"
" 아니면, :exc:`TypeError` 예외를 일으킵니다."

#: ../Doc/library/functions.rst:778
msgid ""
"Return true if *class* is a subclass (direct, indirect or :term:`virtual "
"<abstract base class>`) of *classinfo*.  A class is considered a subclass"
" of itself. *classinfo* may be a tuple of class objects, in which case "
"every entry in *classinfo* will be checked. In any other case, a "
":exc:`TypeError` exception is raised."
msgstr ""
"*class* 가 *classinfo* 의 서브 클래스 (직접, 간접 또는 :term:`가상 <abstract base "
"class>`)면 참을 돌려줍니다. 클래스는 그 자체의 서브 클래스로 간주합니다. *classinfo* 는 클래스 객체의 튜플 일 "
"수 있습니다. 이 경우 *classinfo* 의 모든 항목이 검사됩니다. 다른 모든 경우에는, :exc:`TypeError` 예외가"
" 발생합니다."

#: ../Doc/library/functions.rst:787
msgid ""
"Return an :term:`iterator` object.  The first argument is interpreted "
"very differently depending on the presence of the second argument. "
"Without a second argument, *object* must be a collection object which "
"supports the iteration protocol (the :meth:`__iter__` method), or it must"
" support the sequence protocol (the :meth:`__getitem__` method with "
"integer arguments starting at ``0``).  If it does not support either of "
"those protocols, :exc:`TypeError` is raised. If the second argument, "
"*sentinel*, is given, then *object* must be a callable object.  The "
"iterator created in this case will call *object* with no arguments for "
"each call to its :meth:`~iterator.__next__` method; if the value returned"
" is equal to *sentinel*, :exc:`StopIteration` will be raised, otherwise "
"the value will be returned."
msgstr ""
":term:`이터레이터 <iterator>` 객체를 돌려줍니다. 첫 번째 인자는 두 번째 인자의 존재 여부에 따라 매우 다르게 "
"해석됩니다. 두 번째 인자가 없으면, *object* 는 이터레이션 프로토콜 (:meth:`__iter__` 메서드)을 지원하는 "
"컬렉션 객체이거나 시퀀스 프로토콜 (0에서 시작하는 정수 인자를 받는 :meth:`__getitem__` 메서드)을 지원해야 "
"합니다. 이러한 프로토콜 중 아무것도 지원하지 않으면 :exc:`TypeError` 가 일어납니다. 두 번째 인자 "
"*sentinel* 이 주어지면, *object* 는 콜러블이어야 합니다. 이 경우 만들어지는 이터레이터는 "
":meth:`~iterator.__next__` 메서드가 호출될 때마다 인자 없이 *object* 를 호출합니다; 반환된 값이 "
"*sentinel* 과 같으면, :exc:`StopIteration` 을 일으키고, 그렇지 않으면 값을 돌려줍니다."

#: ../Doc/library/functions.rst:800
msgid "See also :ref:`typeiter`."
msgstr ":ref:`typeiter` 도 보세요."

#: ../Doc/library/functions.rst:802
msgid ""
"One useful application of the second form of :func:`iter` is to read "
"lines of a file until a certain line is reached.  The following example "
"reads a file until the :meth:`~io.TextIOBase.readline` method returns an "
"empty string::"
msgstr ""
"두 번째 형태의 :func:`iter` 의 유용한 응용은 특정 줄에 도달할 때까지 파일의 줄을 읽는 것입니다. 다음의 예는 "
":meth:`~io.TextIOBase.readline` 메서드가 빈 문자열을 돌려줄 때까지 파일을 읽습니다::"

#: ../Doc/library/functions.rst:813
msgid ""
"Return the length (the number of items) of an object.  The argument may "
"be a sequence (such as a string, bytes, tuple, list, or range) or a "
"collection (such as a dictionary, set, or frozen set)."
msgstr ""
"객체의 길이 (항목 수)를 돌려줍니다. 인자는 시퀀스 (문자열, 바이트열, 튜플, 리스트 또는 range 같은) 또는 컬렉션 "
"(딕셔너리, 집합 또는 불변 집합 같은) 일 수 있습니다."

#: ../Doc/library/functions.rst:822
msgid ""
"Rather than being a function, :class:`list` is actually a mutable "
"sequence type, as documented in :ref:`typesseq-list` and :ref:`typesseq`."
msgstr ""
"함수이기보다, :ref:`typesseq-list` 와 :ref:`typesseq` 에 문서화 된 것처럼, :class:`list`"
" 는 실제로는 가변 시퀀스 형입니다."

#: ../Doc/library/functions.rst:828
msgid ""
"Update and return a dictionary representing the current local symbol "
"table. Free variables are returned by :func:`locals` when it is called in"
" function blocks, but not in class blocks."
msgstr ""
"현재 지역 심볼 테이블을 나타내는 딕셔너리를 갱신하고 돌려줍니다. :func:`locals` 이 함수 블록에서 호출될 때 자유 "
"변수를 돌려주지만, 클래스 블록에서 호출할 때는 그렇지 않습니다."

#: ../Doc/library/functions.rst:833
msgid ""
"The contents of this dictionary should not be modified; changes may not "
"affect the values of local and free variables used by the interpreter."
msgstr ""
"이 딕셔너리의 내용은 수정해서는 안 됩니다. 변경 사항은 인터프리터가 사용하는 지역 및 자유 변수의 값에 영향을 미치지 않을 수 "
"있습니다."

#: ../Doc/library/functions.rst:838
msgid ""
"Return an iterator that applies *function* to every item of *iterable*, "
"yielding the results.  If additional *iterable* arguments are passed, "
"*function* must take that many arguments and is applied to the items from"
" all iterables in parallel.  With multiple iterables, the iterator stops "
"when the shortest iterable is exhausted.  For cases where the function "
"inputs are already arranged into argument tuples, see "
":func:`itertools.starmap`\\."
msgstr ""
"*iterable* 의 모든 항목에 *function* 을 적용한 후 그 결과를 돌려주는 이터레이터를 돌려줍니다. 추가 "
"*iterable* 인자가 전달되면, *function* 은 그 수 만큼의 인자를 받아들여야 하고 모든 이터러블에서 병렬로 제공되는"
" 항목들에 적용됩니다. 다중 이터러블의 경우, 이터레이터는 가장 짧은 이터러블이 모두 소모되면 멈춥니다. 함수 입력이 이미 인자 "
"튜플로 배치된 경우에는, :func:`itertools.starmap` 를 보세요."

#: ../Doc/library/functions.rst:849
msgid ""
"Return the largest item in an iterable or the largest of two or more "
"arguments."
msgstr "iterable 에서 가장 큰 항목이나 두 개 이상의 인자 중 가장 큰 것을 돌려줍니다."

#: ../Doc/library/functions.rst:852
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`."
" The largest item in the iterable is returned.  If two or more positional"
" arguments are provided, the largest of the positional arguments is "
"returned."
msgstr ""
"하나의 위치 인자가 제공되면, 그것은 :term:`이터러블 <iterable>` 이어야 합니다. iterable에서 가장 큰 항목을"
" 돌려줍니다. 두 개 이상의 위치 인자가 제공되면, 위치 인자 중 가장 큰 것을 돌려줍니다."

#: ../Doc/library/functions.rst:857 ../Doc/library/functions.rst:891
msgid ""
"There are two optional keyword-only arguments. The *key* argument "
"specifies a one-argument ordering function like that used for "
":meth:`list.sort`. The *default* argument specifies an object to return "
"if the provided iterable is empty. If the iterable is empty and *default*"
" is not provided, a :exc:`ValueError` is raised."
msgstr ""
"선택적 키워드-전용 인자가 두 개 있습니다. *key* 인자는 :meth:`list.sort` 에 사용되는 것처럼 단일 인자 순서 "
"함수를 지정합니다. *default* 인자는 제공된 iterable이 비어있는 경우 돌려줄 객체를 지정합니다. iterable이 "
"비어 있고 *default* 가 제공되지 않으면 :exc:`ValueError` 가 발생합니다."

#: ../Doc/library/functions.rst:863
msgid ""
"If multiple items are maximal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving "
"tools such as ``sorted(iterable, key=keyfunc, reverse=True)[0]`` and "
"``heapq.nlargest(1, iterable, key=keyfunc)``."
msgstr ""
"여러 항목이 최댓값이면, 함수는 처음 만난 항목을 돌려줍니다. 이것은 ``sorted(iterable, key=keyfunc, "
"reverse=True)[0]`` 와 ``heapq.nlargest(1, iterable, key=keyfunc)`` 같은 다른 "
"정렬 안정성 보존 도구와 일관성을 유지합니다."

#: ../Doc/library/functions.rst:868 ../Doc/library/functions.rst:902
msgid "The *default* keyword-only argument."
msgstr "*default* 키워드-전용 인자."

#: ../Doc/library/functions.rst:876
msgid ""
"Return a \"memory view\" object created from the given argument.  See "
":ref:`typememoryview` for more information."
msgstr "지정된 인자로부터 만들어진 \"메모리 뷰\" 객체를 돌려줍니다. 자세한 정보는 :ref:`typememoryview` 를 보세요."

#: ../Doc/library/functions.rst:883
msgid ""
"Return the smallest item in an iterable or the smallest of two or more "
"arguments."
msgstr "iterable 에서 가장 작은 항목이나 두 개 이상의 인자 중 가장 작은 것을 돌려줍니다."

#: ../Doc/library/functions.rst:886
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`."
" The smallest item in the iterable is returned.  If two or more "
"positional arguments are provided, the smallest of the positional "
"arguments is returned."
msgstr ""
"하나의 위치 인자가 제공되면, 그것은 :term:`이터러블 <iterable>` 이어야 합니다. iterable에서 가장 작은 "
"항목을 돌려줍니다. 두 개 이상의 위치 인자가 제공되면, 위치 인자 중 가장 작은 것을 돌려줍니다."

#: ../Doc/library/functions.rst:897
msgid ""
"If multiple items are minimal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving "
"tools such as ``sorted(iterable, key=keyfunc)[0]`` and "
"``heapq.nsmallest(1, iterable, key=keyfunc)``."
msgstr ""
"여러 항목이 최솟값이면, 함수는 처음 만난 항목을 돌려줍니다. 이것은 ``sorted(iterable, "
"key=keyfunc)[0]`` 와 ``heapq.nsmallest(1, iterable, key=keyfunc)`` 같은 다른 "
"정렬 안정성 보존 도구와 일관성을 유지합니다."

#: ../Doc/library/functions.rst:908
msgid ""
"Retrieve the next item from the *iterator* by calling its "
":meth:`~iterator.__next__` method.  If *default* is given, it is returned"
" if the iterator is exhausted, otherwise :exc:`StopIteration` is raised."
msgstr ""
":meth:`~iterator.__next__` 메서드를 호출하여 *iterator* 에서 다음 항목을 꺼냅니다. *default*"
" 가 주어지면, iterator가 고갈될 때 돌려주고, 그렇지 않으면 :exc:`StopIteration` 을 일으킵니다."

#: ../Doc/library/functions.rst:915
msgid ""
"Return a new featureless object.  :class:`object` is a base for all "
"classes. It has the methods that are common to all instances of Python "
"classes.  This function does not accept any arguments."
msgstr ""
"새 기능 없는 객체를 돌려줍니다. :class:`object` 는 모든 클래스의 베이스 클래스입니다. 모든 파이썬 클래스의 "
"인스턴스에 공통적인 메서드를 가지고 있습니다. 이 함수는 인자를 받아들이지 않습니다."

#: ../Doc/library/functions.rst:921
msgid ""
":class:`object` does *not* have a :attr:`~object.__dict__`, so you can't "
"assign arbitrary attributes to an instance of the :class:`object` class."
msgstr ""
":class:`object` 는 :attr:`~object.__dict__` 을 가지지 *않습니다*. 그래서, "
":class:`object` 클래스의 인스턴스에 임의의 어트리뷰트를 대입할 수 없습니다."

#: ../Doc/library/functions.rst:927
msgid ""
"Convert an integer number to an octal string prefixed with \"0o\".  The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`__index__` method that returns an "
"integer. For example:"
msgstr ""
"정수를 \"0o\"로 시작하는 8진수 문자열로 변환합니다. 결과는 올바른 파이썬 표현식입니다. *x* 가 파이썬 "
":class:`int` 객체가 아니면, 정수를 돌려주는 :meth:`__index__` 메서드를 정의해야 합니다. 예를 들어:"

#: ../Doc/library/functions.rst:937
msgid ""
"If you want to convert an integer number to octal string either with "
"prefix \"0o\" or not, you can use either of the following ways."
msgstr "정수를 접두사 \"0o\"가 있거나 없는 형태의 8진수 문자열로 변환하려면, 다음 방법의 하나를 사용할 수 있습니다."

#: ../Doc/library/functions.rst:954
msgid ""
"Open *file* and return a corresponding :term:`file object`.  If the file "
"cannot be opened, an :exc:`OSError` is raised."
msgstr ""
"*file* 을 열고 해당 :term:`파일 객체 <file object>` 를 돌려줍니다. 파일을 열 수 없으면, "
":exc:`OSError` 가 발생합니다."

#: ../Doc/library/functions.rst:957
msgid ""
"*file* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current working directory) of the file to be opened or an"
" integer file descriptor of the file to be wrapped.  (If a file "
"descriptor is given, it is closed when the returned I/O object is closed,"
" unless *closefd* is set to ``False``.)"
msgstr ""
"*file* 은 열 파일의 경로명(절대 혹은 현재 작업 디렉터리에 상대적인)을 주는 :term:`경로류 객체 <path-like "
"object>` 거나, 감쌀 파일의 정수 파일 디스크립터입니다. (파일 디스크립터가 주어지면, *closefd* 가 "
"``False`` 가 아닌 한, 반환된 I/O 객체가 닫힐 때 닫힙니다.)"

#: ../Doc/library/functions.rst:963
msgid ""
"*mode* is an optional string that specifies the mode in which the file is"
" opened.  It defaults to ``'r'`` which means open for reading in text "
"mode. Other common values are ``'w'`` for writing (truncating the file if"
" it already exists), ``'x'`` for exclusive creation and ``'a'`` for "
"appending (which on *some* Unix systems, means that *all* writes append "
"to the end of the file regardless of the current seek position).  In text"
" mode, if *encoding* is not specified the encoding used is platform "
"dependent: ``locale.getpreferredencoding(False)`` is called to get the "
"current locale encoding. (For reading and writing raw bytes use binary "
"mode and leave *encoding* unspecified.)  The available modes are:"
msgstr ""
"*mode* 는 파일이 열리는 모드를 지정하는 선택적 문자열입니다. 기본값은 ``'r'`` 인데, 텍스트 모드로 읽기 위해 여는 "
"것을 뜻합니다. 다른 일반적인 값은 쓰기 위한 ``'w'`` (파일이 이미 존재하는 경우 파일을 자릅니다), 독점적 파일 만들기를 "
"위한 ``'x'`` 및 덧붙이기를 위한 ``'a'`` (*일부* 유닉스 시스템에서, 현재 위치와 관계없이 *모든* 쓰기가 파일의 "
"끝에 덧붙여짐을 뜻합니다) 입니다. 텍스트 모드에서, *encoding* 을 지정하지 않으면 사용되는 인코딩은 플랫폼에 따라 "
"다릅니다: 현재 로케일 인코딩을 얻기 위해 ``locale.getpreferredencoding(False)`` 가 호출됩니다. "
"(날 바이트열을 읽고 쓰려면 바이너리 모드를 사용하고 *encoding* 을 지정하지 않습니다.) 사용 가능한 모드는 다음과 "
"같습니다:"

#: ../Doc/library/functions.rst:975
msgid "Character"
msgstr "문자"

#: ../Doc/library/functions.rst:975
msgid "Meaning"
msgstr "의미"

#: ../Doc/library/functions.rst:977
msgid "``'r'``"
msgstr "``'r'``"

#: ../Doc/library/functions.rst:977
msgid "open for reading (default)"
msgstr "읽기용으로 엽니다 (기본값)"

#: ../Doc/library/functions.rst:978
msgid "``'w'``"
msgstr "``'w'``"

#: ../Doc/library/functions.rst:978
msgid "open for writing, truncating the file first"
msgstr "쓰기용으로 엽니다, 파일을 먼저 자릅니다."

#: ../Doc/library/functions.rst:979
msgid "``'x'``"
msgstr "``'x'``"

#: ../Doc/library/functions.rst:979
msgid "open for exclusive creation, failing if the file already exists"
msgstr "독점적인 파일 만들기용으로 엽니다, 이미 존재하는 경우에는 실패합니다."

#: ../Doc/library/functions.rst:980
msgid "``'a'``"
msgstr "``'a'``"

#: ../Doc/library/functions.rst:980
msgid "open for writing, appending to the end of the file if it exists"
msgstr "쓰기용으로 엽니다, 파일이 존재하는 경우는 파일의 끝에 덧붙입니다"

#: ../Doc/library/functions.rst:981
msgid "``'b'``"
msgstr "``'b'``"

#: ../Doc/library/functions.rst:981
msgid "binary mode"
msgstr "바이너리 모드"

#: ../Doc/library/functions.rst:982
msgid "``'t'``"
msgstr "``'t'``"

#: ../Doc/library/functions.rst:982
msgid "text mode (default)"
msgstr "텍스트 모드 (기본값)"

#: ../Doc/library/functions.rst:983
msgid "``'+'``"
msgstr "``'+'``"

#: ../Doc/library/functions.rst:983
msgid "open a disk file for updating (reading and writing)"
msgstr "갱신(읽기 및 쓰기)용으로 디스크 파일을 엽니다"

#: ../Doc/library/functions.rst:984
msgid "``'U'``"
msgstr "``'U'``"

#: ../Doc/library/functions.rst:984
msgid ":term:`universal newlines` mode (deprecated)"
msgstr ":term:`유니버설 줄 넘김 <universal newlines>` 모드 (디프리케이트 되었습니다)"

#: ../Doc/library/functions.rst:987
msgid ""
"The default mode is ``'r'`` (open for reading text, synonym of ``'rt'``)."
" For binary read-write access, the mode ``'w+b'`` opens and truncates the"
" file to 0 bytes.  ``'r+b'`` opens the file without truncation."
msgstr ""
"기본 모드는 ``'r'`` 입니다 (텍스트를 읽는 용으로 엽니다, ``'rt'`` 의 동의어). 바이너리 읽기-쓰기 액세스의 "
"경우는, 모드 ``'w+b'`` 는 파일을 열면서 0바이트로 자릅니다. ``'r+b'`` 는 자르지 않고 파일을 엽니다."

#: ../Doc/library/functions.rst:991
msgid ""
"As mentioned in the :ref:`io-overview`, Python distinguishes between "
"binary and text I/O.  Files opened in binary mode (including ``'b'`` in "
"the *mode* argument) return contents as :class:`bytes` objects without "
"any decoding.  In text mode (the default, or when ``'t'`` is included in "
"the *mode* argument), the contents of the file are returned as "
":class:`str`, the bytes having been first decoded using a platform-"
"dependent encoding or using the specified *encoding* if given."
msgstr ""
":ref:`io-overview` 에서 언급했듯이, 파이썬은 바이너리와 텍스트 I/O를 구별합니다. 바이너리 모드 (*mode* "
"인자에 ``'b'`` 를 포함합니다)로 열린 파일은 내용을 디코딩 없이 :class:`bytes` 객체로 돌려줍니다. 텍스트 모드 "
"(기본값, 또는 *mode* 인자에 ``'t'`` 가 포함될 때)에서는, 파일의 내용이 :class:`str`\\로 반환되는데, "
"바이트 열이 플랫폼 의존적인 인코딩이나 주어진 *encoding* 을 사용해서 먼저 디코드 됩니다."

#: ../Doc/library/functions.rst:1001
msgid ""
"Python doesn't depend on the underlying operating system's notion of text"
" files; all the processing is done by Python itself, and is therefore "
"platform-independent."
msgstr "파이썬은 하위 운영 체제의 텍스트 파일 개념에 의존하지 않습니다. 모든 처리는 파이썬 자체에 의해 수행되므로 플랫폼에 독립적입니다."

#: ../Doc/library/functions.rst:1005
msgid ""
"*buffering* is an optional integer used to set the buffering policy.  "
"Pass 0 to switch buffering off (only allowed in binary mode), 1 to select"
" line buffering (only usable in text mode), and an integer > 1 to "
"indicate the size in bytes of a fixed-size chunk buffer.  When no "
"*buffering* argument is given, the default buffering policy works as "
"follows:"
msgstr ""
"*buffering* 은 버퍼링 정책을 설정하는 데 사용되는 선택적 정수입니다. 버퍼링을 끄려면 (바이너리 모드에서만 허용) 0을 "
"전달하고, 줄 버퍼링 (텍스트 모드에서만 사용 가능)을 선택하려면 1을, 고정 크기 청크 버퍼를 선택하려면 그 크기를 바이트 단위로"
" 표시한 정수 > 1을 전달합니다. *buffering* 인자가 제공되지 않을 때, 기본 버퍼링 정책은 다음과 같이 작동합니다:"

#: ../Doc/library/functions.rst:1011
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is"
" chosen using a heuristic trying to determine the underlying device's "
"\"block size\" and falling back on :attr:`io.DEFAULT_BUFFER_SIZE`.  On "
"many systems, the buffer will typically be 4096 or 8192 bytes long."
msgstr ""
"바이너리 파일은 고정 크기 청크로 버퍼링 됩니다. 버퍼의 크기는 하부 장치의 \"블록 크기\"를 파악하려고 시도하는 경험적인 방법을"
" 사용해서 선택되고 :attr:`io.DEFAULT_BUFFER_SIZE`\\로 폴 백 됩니다. 많은 시스템에서, 버퍼는 일반적으로"
" 4096 또는 8192바이트 길이입니다."

#: ../Doc/library/functions.rst:1016
msgid ""
"\"Interactive\" text files (files for which :meth:`~io.IOBase.isatty` "
"returns ``True``) use line buffering.  Other text files use the policy "
"described above for binary files."
msgstr ""
"\"대화형\" 텍스트 파일 (:meth:`~io.IOBase.isatty` 가 ``True`` 를 돌려주는 파일)은 줄 버퍼링을 "
"사용합니다. 다른 텍스트 파일은 바이너리 파일에 대해 위에서 설명한 정책을 사용합니다."

#: ../Doc/library/functions.rst:1020
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file."
" This should only be used in text mode.  The default encoding is platform"
" dependent (whatever :func:`locale.getpreferredencoding` returns), but "
"any :term:`text encoding` supported by Python can be used.  See the "
":mod:`codecs` module for the list of supported encodings."
msgstr ""
"*encoding* 은 파일을 디코딩하거나 인코딩하는 데 사용되는 인코딩의 이름입니다. 텍스트 모드에서만 사용해야 합니다. 기본 "
"인코딩은 플랫폼에 따라 다르지만 (:func:`locale.getpreferredencoding` 이 돌려주는 값), 파이썬에서 "
"지원하는 :term:`텍스트 인코딩 <text encoding>` 은 모두 사용할 수 있습니다. 지원되는 인코딩 목록은 "
":mod:`codecs` 모듈을 보면 됩니다."

#: ../Doc/library/functions.rst:1027
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode. A variety of"
" standard error handlers are available (listed under :ref:`error-"
"handlers`), though any error handling name that has been registered with "
":func:`codecs.register_error` is also valid.  The standard names include:"
msgstr ""
"*errors* 는 인코딩 및 디코딩 에러를 처리하는 방법을 지정하는 선택적 문자열입니다. 바이너리 모드에서는 사용할 수 없습니다."
" 다양한 표준 에러 처리기가 제공됩니다 (:ref:`error-handlers` 에 나열됩니다). 하지만, "
":func:`codecs.register_error`\\로 등록된 에러 처리기 이름 역시 사용할 수 있습니다. 표준 이름은 다음과 "
"같습니다:"

#: ../Doc/library/functions.rst:1035
msgid ""
"``'strict'`` to raise a :exc:`ValueError` exception if there is an "
"encoding error.  The default value of ``None`` has the same effect."
msgstr ""
"``'strict'`` 는 인코딩 에러가 있는 경우 :exc:`ValueError` 예외를 발생시킵니다. 기본값 ``None`` 은"
" 같은 효과를 냅니다."

#: ../Doc/library/functions.rst:1039
msgid ""
"``'ignore'`` ignores errors.  Note that ignoring encoding errors can lead"
" to data loss."
msgstr "``'ignore'`` 는 에러를 무시합니다. 인코딩 에러를 무시하면 데이터가 손실될 수 있음에 주의하세요."

#: ../Doc/library/functions.rst:1042
msgid ""
"``'replace'`` causes a replacement marker (such as ``'?'``) to be "
"inserted where there is malformed data."
msgstr "``'replace'`` 는 잘못된 데이터가 있는 자리에 대체 마커(``'?'`` 와 같은)를 삽입합니다."

#: ../Doc/library/functions.rst:1045
msgid ""
"``'surrogateescape'`` will represent any incorrect bytes as code points "
"in the Unicode Private Use Area ranging from U+DC80 to U+DCFF.  These "
"private code points will then be turned back into the same bytes when the"
" ``surrogateescape`` error handler is used when writing data.  This is "
"useful for processing files in an unknown encoding."
msgstr ""
"``'surrogateescape'`` 는 U+DC80에서 U+DCFF까지의 유니코드 개인 사용 영역의 코드 포인트로 잘못된 "
"바이트를 나타냅니다. 데이터를 쓸 때 ``surrogateescape`` 에러 처리기가 사용되면, 이 개인 코드 포인트들은 원래의 "
"바이트로 되돌아갑니다. 알 수 없는 인코딩의 파일을 처리할 때 유용합니다."

#: ../Doc/library/functions.rst:1052
msgid ""
"``'xmlcharrefreplace'`` is only supported when writing to a file. "
"Characters not supported by the encoding are replaced with the "
"appropriate XML character reference ``&#nnn;``."
msgstr ""
"``'xmlcharrefreplace'`` 는 파일에 쓸 때만 지원됩니다. 인코딩이 지원하지 않는 문자는 적절한 XML 문자 참조 "
"``&#nnn;`` 로 대체됩니다."

#: ../Doc/library/functions.rst:1056
msgid ""
"``'backslashreplace'`` replaces malformed data by Python's backslashed "
"escape sequences."
msgstr "``'backslashreplace'`` 는 잘못된 데이터를 파이썬의 역 슬래시 이스케이프 시퀀스로 대체합니다."

#: ../Doc/library/functions.rst:1059
msgid ""
"``'namereplace'`` (also only supported when writing) replaces unsupported"
" characters with ``\\N{...}`` escape sequences."
msgstr ""
"``'namereplace'`` (역시 파일에 쓸 때만 지원됩니다)는 지원되지 않는 문자를 ``\\N{...}`` 이스케이프 "
"시퀀스로 대체합니다."

#: ../Doc/library/functions.rst:1065
msgid ""
"*newline* controls how :term:`universal newlines` mode works (it only "
"applies to text mode).  It can be ``None``, ``''``, ``'\\n'``, ``'\\r'``,"
" and ``'\\r\\n'``.  It works as follows:"
msgstr ""
"*newline* 은 :term:`유니버설 줄 넘김 <universal newlines>` 모드가 작동하는 방식을 제어합니다 "
"(텍스트 모드에만 적용됩니다). ``None``, ``''``, ``'\\n'``, ``'\\r'`` 및 `` "
"``'\\r\\n'`` 일 수 있습니다. 다음과 같이 작동합니다:"

#: ../Doc/library/functions.rst:1069
msgid ""
"When reading input from the stream, if *newline* is ``None``, universal "
"newlines mode is enabled.  Lines in the input can end in ``'\\n'``, "
"``'\\r'``, or ``'\\r\\n'``, and these are translated into ``'\\n'`` "
"before being returned to the caller.  If it is ``''``, universal newlines"
" mode is enabled, but line endings are returned to the caller "
"untranslated.  If it has any of the other legal values, input lines are "
"only terminated by the given string, and the line ending is returned to "
"the caller untranslated."
msgstr ""
"스트림에서 입력을 읽을 때, *newline* 이 ``None`` 이면, 유니버설 줄 넘김 모드가 활성화됩니다. 입력에 있는 줄은 "
"``'\\n'``, ``'\\r'`` 또는 ``'\\r\\n'`` 로 끝날 수 있으며, 호출자에게 돌려주기 전에 모두 "
"``'\\n'`` 로 변환됩니다. 그것이 ``''`` 이면, 유니버설 줄 넘김 모드가 활성화되지만, 줄 끝은 변환되지 않은 채로 "
"호출자에게 반환됩니다. 다른 유효한 값이면, 입력 줄은 주어진 문자열로만 끝나며, 줄 끝은 변환되지 않은 채로 호출자에게 "
"돌려줍니다."

#: ../Doc/library/functions.rst:1077
msgid ""
"When writing output to the stream, if *newline* is ``None``, any "
"``'\\n'`` characters written are translated to the system default line "
"separator, :data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no "
"translation takes place.  If *newline* is any of the other legal values, "
"any ``'\\n'`` characters written are translated to the given string."
msgstr ""
"스트림에 출력을 쓸 때, *newline* 이 ``None`` 이면, 모든 ``'\\n'`` 문자는 시스템 기본 줄 구분자인 "
":data:`os.linesep` 로 변환됩니다. *newline* 이 ``''`` 또는 ``'\\n'`` 이면, 변환이 이루어지지"
" 않습니다. *newline* 이 다른 유효한 값이면, 쓰이는 모든 ``'\\n'`` 문자는 주어진 문자열로 변환됩니다."

#: ../Doc/library/functions.rst:1083
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename "
"was given, the underlying file descriptor will be kept open when the file"
" is closed.  If a filename is given *closefd* must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr ""
"*closefd* 가 ``False`` 이고 파일명 대신 파일 디스크립터가 주어지면, 파일이 닫힐 때 하위 파일 디스크립터가 "
"열려있게 됩니다. 파일명이 주어지면 *closefd* 는 ``True`` (기본값) 여야 합니다. 그렇지 않으면 에러가 발생합니다."

#: ../Doc/library/functions.rst:1088
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by "
"calling *opener* with (*file*, *flags*). *opener* must return an open "
"file descriptor (passing :mod:`os.open` as *opener* results in "
"functionality similar to passing ``None``)."
msgstr ""
"콜러블을 *opener* 로 전달하여 커스텀 오프너를 사용할 수 있습니다. 파일 객체를 위한 하위 파일 디스크립터는 *opener*"
" 를 (*file*, *flags*) 로 호출해서 얻습니다. *opener* 는 열린 파일 디스크립터를 반환해야 합니다 "
"(*opener* 에 :mod:`os.open` 을 전달하는 것은 ``None`` 을 전달하는 것과 비슷한 기능을 수행하게 "
"됩니다)."

#: ../Doc/library/functions.rst:1094
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "새로 만들어진 파일은 :ref:`상속 불가능 <fd_inheritance>` 합니다."

#: ../Doc/library/functions.rst:1096
msgid ""
"The following example uses the :ref:`dir_fd <dir_fd>` parameter of the "
":func:`os.open` function to open a file relative to a given directory::"
msgstr ""
"다음 예는 주어진 디렉터리에 상대적인 파일을 열기 위해 :func:`os.open` 함수의 :ref:`dir_fd <dir_fd>`"
" 매개변수를 사용합니다::"

#: ../Doc/library/functions.rst:1109
msgid ""
"The type of :term:`file object` returned by the :func:`open` function "
"depends on the mode.  When :func:`open` is used to open a file in a text "
"mode (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass "
"of :class:`io.TextIOBase` (specifically :class:`io.TextIOWrapper`).  When"
" used to open a file in a binary mode with buffering, the returned class "
"is a subclass of :class:`io.BufferedIOBase`.  The exact class varies: in "
"read binary mode, it returns an :class:`io.BufferedReader`; in write "
"binary and append binary modes, it returns an :class:`io.BufferedWriter`,"
" and in read/write mode, it returns an :class:`io.BufferedRandom`.  When "
"buffering is disabled, the raw stream, a subclass of "
":class:`io.RawIOBase`, :class:`io.FileIO`, is returned."
msgstr ""
":func:`open` 함수에 의해 반환된 :term:`파일 객체 <file object>` 의 형은 모드에 의존합니다. "
":func:`open` 이 텍스트 모드(``'w'``, ``'r'``, ``'wt'``, ``'rt'``, 등)로 파일을 여는 데 "
"사용되면, :class:`io.TextIOBase` 의 서브 클래스를 돌려줍니다 (구체적으로 "
":class:`io.TextIOWrapper`). 버퍼링과 함께 바이너리 모드로 파일을 여는 데 사용되는 경우, 반환되는 클래스는 "
":class:`io.BufferedIOBase` 의 서브 클래스입니다. 정확한 클래스는 다양합니다: 읽기 바이너리 모드에서는, "
":class:`io.BufferedReader` 를 돌려줍니다; 쓰기 바이너리와 덧붙이기 바이너리 모드에서는, "
":class:`io.BufferedWriter` 를 돌려주고, 읽기/쓰기 모드에서는, "
":class:`io.BufferedRandom` 을 돌려줍니다. 버퍼링을 끄면, 날 스트림, :class:`io.RawIOBase`"
" 의 서브 클래스, :class:`io.FileIO`, 을 돌려줍니다."

#: ../Doc/library/functions.rst:1130
msgid ""
"See also the file handling modules, such as, :mod:`fileinput`, :mod:`io` "
"(where :func:`open` is declared), :mod:`os`, :mod:`os.path`, "
":mod:`tempfile`, and :mod:`shutil`."
msgstr ""
":mod:`fileinput`, :mod:`io` (:func:`open` 이 선언된 곳), :mod:`os`, "
":mod:`os.path`, :mod:`tempfile`, 그리고 :mod:`shutil` 와 같은 파일 처리 모듈들도 보세요."

#: ../Doc/library/functions.rst:1137
msgid "The *opener* parameter was added."
msgstr "*opener* 매개변수가 추가되었습니다."

#: ../Doc/library/functions.rst:1138
msgid "The ``'x'`` mode was added."
msgstr "``'x'`` 모드가 추가되었습니다."

#: ../Doc/library/functions.rst:1139
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ":exc:`IOError` 를 일으켜왔습니다. 이제는 :exc:`OSError` 의 별칭입니다."

#: ../Doc/library/functions.rst:1140
msgid ""
":exc:`FileExistsError` is now raised if the file opened in exclusive "
"creation mode (``'x'``) already exists."
msgstr "독점적 파일 만들기 모드(``'x'``)로 여는 파일이 이미 존재하면, 이제 :exc:`FileExistsError` 를 일으킵니다."

#: ../Doc/library/functions.rst:1146
msgid "The file is now non-inheritable."
msgstr "파일은 이제 상속 불가능합니다."

#: ../Doc/library/functions.rst:1150
msgid "The ``'U'`` mode."
msgstr "``'U'`` 모드."

#: ../Doc/library/functions.rst:1155
msgid ""
"If the system call is interrupted and the signal handler does not raise "
"an exception, the function now retries the system call instead of raising"
" an :exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 이 함수는 이제 :exc:`InterruptedError` "
"예외를 일으키는 대신 시스템 호출을 재시도합니다 (이유는 :pep:`475` 를 보세요)."

#: ../Doc/library/functions.rst:1158
msgid "The ``'namereplace'`` error handler was added."
msgstr "``'namereplace'`` 오류 처리기가 추가되었습니다."

#: ../Doc/library/functions.rst:1163
msgid "Support added to accept objects implementing :class:`os.PathLike`."
msgstr ":class:`os.PathLike` 를 구현하는 객체를 받아들이도록 지원이 추가되었습니다."

#: ../Doc/library/functions.rst:1164
msgid ""
"On Windows, opening a console buffer may return a subclass of "
":class:`io.RawIOBase` other than :class:`io.FileIO`."
msgstr ""
"윈도우에서, 콘솔 버퍼를 열면 :class:`io.FileIO` 가 아닌 :class:`io.RawIOBase` 의 서브 클래스가 "
"반환될 수 있습니다."

#: ../Doc/library/functions.rst:1169
msgid ""
"Given a string representing one Unicode character, return an integer "
"representing the Unicode code point of that character.  For example, "
"``ord('a')`` returns the integer ``97`` and ``ord('€')`` (Euro sign) "
"returns ``8364``.  This is the inverse of :func:`chr`."
msgstr ""
"하나의 유니코드 문자를 나타내는 문자열이 주어지면 해당 문자의 유니코드 코드 포인트를 나타내는 정수를 돌려줍니다. 예를 들어, "
"``ord('a')`` 는 정수 ``97`` 을 반환하고 ``ord('€')`` (유로 기호)는 ``8364`` 를 반환합니다. "
"이것은 :func:`chr` 의 반대입니다."

#: ../Doc/library/functions.rst:1177
msgid ""
"Return *x* to the power *y*; if *z* is present, return *x* to the power "
"*y*, modulo *z* (computed more efficiently than ``pow(x, y) % z``). The "
"two-argument form ``pow(x, y)`` is equivalent to using the power "
"operator: ``x**y``."
msgstr ""
"*x* 의 *y* 거듭제곱을 돌려줍니다; *z* 가 있는 경우, *x* 의 *y* 거듭제곱의 모듈로 *z* 를 돌려줍니다 "
"(``pow(x, y) % z`` 보다 더 빠르게 계산됩니다). 두 개의 인자 형식인 ``pow (x, y)`` 는 거듭제곱 "
"연산자를 사용하는 것과 동등합니다: ``x ** y``."

#: ../Doc/library/functions.rst:1181
msgid ""
"The arguments must have numeric types.  With mixed operand types, the "
"coercion rules for binary arithmetic operators apply.  For :class:`int` "
"operands, the result has the same type as the operands (after coercion) "
"unless the second argument is negative; in that case, all arguments are "
"converted to float and a float result is delivered.  For example, "
"``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``.  If the "
"second argument is negative, the third argument must be omitted.  If *z* "
"is present, *x* and *y* must be of integer types, and *y* must be non-"
"negative."
msgstr ""
"인자는 숫자 형이어야 합니다. 피연산자들의 형이 다를 경우, 이 항 산술 연산자에 대한 코어션 규칙이 적용됩니다. "
":class:`int` 피연산자들의 경우, 결과는 두 번째 인자가 음수가 아닌 한 피연산자와 같은 형(코어션 후에)이 됩니다; 두 "
"번째 인자가 음수면 모든 인자가 float로 변환되고 float 결과가 전달됩니다. 예를 들어, ``10**2`` 는 ``100``"
" 을 반환하지만, ``10**-2``는 ``0.01`` 을 반환합니다. 두 번째 인자가 음수면 세 번째 인수는 생략해야 합니다. "
"*z* 가 있는 경우, *x* 및 *y* 는 정수형이어야 하고, *y* 는 음수가 아니어야 합니다."

#: ../Doc/library/functions.rst:1193
msgid ""
"Print *objects* to the text stream *file*, separated by *sep* and "
"followed by *end*.  *sep*, *end*, *file* and *flush*, if present, must be"
" given as keyword arguments."
msgstr ""
"*objects* 를 텍스트 스트림 *file* 로 인쇄하는데, *sep* 로 구분되고 *end* 를 뒤에 붙입니다. 있다면, "
"*sep*, *end*, *file* 및 *flush* 는 반드시 키워드 인자로 제공해야 합니다."

#: ../Doc/library/functions.rst:1197
msgid ""
"All non-keyword arguments are converted to strings like :func:`str` does "
"and written to the stream, separated by *sep* and followed by *end*.  "
"Both *sep* and *end* must be strings; they can also be ``None``, which "
"means to use the default values.  If no *objects* are given, "
":func:`print` will just write *end*."
msgstr ""
"모든 비 키워드 인자는 :func:`str` 이 하듯이 문자열로 변환된 후 스트림에 쓰이는데, *sep* 로 구분되고 *end* 를"
" 뒤에 붙입니다. *sep* 과 *end* 는 모두 문자열이어야 합니다; ``None`` 일 수도 있는데, 기본값을 사용한다는 "
"뜻입니다. *objects* 가 주어지지 않으면 :func:`print` 는 *end* 만 씁니다."

#: ../Doc/library/functions.rst:1203
msgid ""
"The *file* argument must be an object with a ``write(string)`` method; if"
" it is not present or ``None``, :data:`sys.stdout` will be used.  Since "
"printed arguments are converted to text strings, :func:`print` cannot be "
"used with binary mode file objects.  For these, use ``file.write(...)`` "
"instead."
msgstr ""
"*file* 인자는 ``write(string)`` 메서드를 가진 객체여야 합니다; 존재하지 않거나 ``None`` 이면, "
":data:`sys.stdout` 이 사용됩니다. 인쇄된 인자는 텍스트 문자열로 변환되기 때문에, :func:`print` 는 "
"바이너리 모드 파일 객체와 함께 사용할 수 없습니다. 이를 위해서는. 대신 ``file.write(...)`` 를 사용합니다."

#: ../Doc/library/functions.rst:1208
msgid ""
"Whether output is buffered is usually determined by *file*, but if the "
"*flush* keyword argument is true, the stream is forcibly flushed."
msgstr "출력의 버퍼링 여부는 일반적으로 *file* 에 의해 결정되지만, *flush* 키워드 인자가 참이면 스트림이 강제로 플러시 됩니다."

#: ../Doc/library/functions.rst:1211
msgid "Added the *flush* keyword argument."
msgstr "*flush* 키워드 인자가 추가되었습니다."

#: ../Doc/library/functions.rst:1217
msgid "Return a property attribute."
msgstr "프로퍼티 어트리뷰트를 돌려줍니다."

#: ../Doc/library/functions.rst:1219
msgid ""
"*fget* is a function for getting an attribute value.  *fset* is a "
"function for setting an attribute value. *fdel* is a function for "
"deleting an attribute value.  And *doc* creates a docstring for the "
"attribute."
msgstr ""
"*fget* 은 어트리뷰트 값을 얻는 함수입니다. *fset* 은 어트리뷰트 값을 설정하는 함수입니다. *fdel* 은 어트리뷰트 "
"값을 삭제하는 함수입니다. 그리고 *doc* 은 어트리뷰트의 독스트링을 만듭니다."

#: ../Doc/library/functions.rst:1223
msgid "A typical use is to define a managed attribute ``x``::"
msgstr "전형적인 사용은 관리되는 어트리뷰트 ``x`` 를 정의하는 것입니다::"

#: ../Doc/library/functions.rst:1240
msgid ""
"If *c* is an instance of *C*, ``c.x`` will invoke the getter, ``c.x = "
"value`` will invoke the setter and ``del c.x`` the deleter."
msgstr ""
"*c* 가 *C* 의 인스턴스면, ``c.x`` 는 게터(getter)를 호출하고, ``c.x = value`` 는 "
"세터(setter)를 호출하고, ``del c.x`` 는 딜리터(deleter)를 호출합니다."

#: ../Doc/library/functions.rst:1243
msgid ""
"If given, *doc* will be the docstring of the property attribute. "
"Otherwise, the property will copy *fget*'s docstring (if it exists).  "
"This makes it possible to create read-only properties easily using "
":func:`property` as a :term:`decorator`::"
msgstr ""
"주어진 경우, *doc* 은 프로퍼티 어트리뷰트의 독스트링이 됩니다. 그렇지 않으면, *fget* 의 독스트링(있는 경우)이 "
"복사됩니다. 이렇게 하면 :func:`property` 를 :term:`데코레이터 <decorator>` 로 사용하여 읽기 전용 "
"프로퍼티를 쉽게 만들 수 있습니다::"

#: ../Doc/library/functions.rst:1256
msgid ""
"The ``@property`` decorator turns the :meth:`voltage` method into a "
"\"getter\" for a read-only attribute with the same name, and it sets the "
"docstring for *voltage* to \"Get the current voltage.\""
msgstr ""
"``@property`` 데코레이터는 :meth:`voltage` 메서드를 같은 이름의 읽기 전용 어트리뷰트에 대한 \"게터\"로 "
"바꾸고, *voltage* 에 대한 독스트링을 \"Get the current voltage.\" 로 설정합니다."

#: ../Doc/library/functions.rst:1260
msgid ""
"A property object has :attr:`~property.getter`, :attr:`~property.setter`,"
" and :attr:`~property.deleter` methods usable as decorators that create a"
" copy of the property with the corresponding accessor function set to the"
" decorated function.  This is best explained with an example::"
msgstr ""
"프로퍼티 객체는 데코레이터로 사용할 수 있는 :attr:`~property.getter`, "
":attr:`~property.setter` 및 :attr:`~property.deleter` 메서드를 갖는데, 해당 접근자 함수를"
" 데코레이트 된 함수로 설정한 프로퍼티의 사본을 만듭니다. 이것은 예제로 가장 잘 설명됩니다::"

#: ../Doc/library/functions.rst:1282
msgid ""
"This code is exactly equivalent to the first example.  Be sure to give "
"the additional functions the same name as the original property (``x`` in"
" this case.)"
msgstr "이 코드는 첫 번째 예제와 정확히 동등합니다. 추가적인 함수들에 원래 프로퍼티(이 경우 ``x``)와 같은 이름을 사용해야 합니다."

#: ../Doc/library/functions.rst:1286
msgid ""
"The returned property object also has the attributes ``fget``, ``fset``, "
"and ``fdel`` corresponding to the constructor arguments."
msgstr "반환된 프로퍼티 객체는 생성자 인자에 해당하는 ``fget``, ``fset`` 및 ``fdel`` 어트리뷰트를 가집니다."

#: ../Doc/library/functions.rst:1289
msgid "The docstrings of property objects are now writeable."
msgstr "이제 프로퍼티 개체의 독스트링이 쓰기 가능합니다."

#: ../Doc/library/functions.rst:1298
msgid ""
"Rather than being a function, :class:`range` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-range` and "
":ref:`typesseq`."
msgstr ""
"함수라기보다, :class:`range` 는 실제로는 :ref:`typesseq-range` 와 :ref:`typesseq` 에 "
"설명된 대로 불변 시퀀스 형입니다."

#: ../Doc/library/functions.rst:1304
msgid ""
"Return a string containing a printable representation of an object.  For "
"many types, this function makes an attempt to return a string that would "
"yield an object with the same value when passed to :func:`eval`, "
"otherwise the representation is a string enclosed in angle brackets that "
"contains the name of the type of the object together with additional "
"information often including the name and address of the object.  A class "
"can control what this function returns for its instances by defining a "
":meth:`__repr__` method."
msgstr ""
"객체의 인쇄 가능한 표현을 포함한 문자열을 돌려줍니다. 많은 형에서, 이 함수는 :func:`eval` 에 전달 될 때 같은 값을 "
"가진 객체를 생성하는 문자열을 반환하려고 시도합니다, 그렇지 않으면 표현은 객체의 형의 이름과 종종 객체의 이름과 주소를 포함하는 "
"추가의 정보를 화살괄호로 묶은 문자열입니다. 클래스는 :meth:`__repr__` 메서드를 정의하여 이 함수가 인스턴스에 대해 "
"돌려주는 것을 제어할 수 있습니다."

#: ../Doc/library/functions.rst:1315
msgid ""
"Return a reverse :term:`iterator`.  *seq* must be an object which has a "
":meth:`__reversed__` method or supports the sequence protocol (the "
":meth:`__len__` method and the :meth:`__getitem__` method with integer "
"arguments starting at ``0``)."
msgstr ""
"역 :term:`이터레이터 <iterator>` 를 돌려줍니다. *seq* 는 :meth:`__reversed__` 메서드를 "
"가졌거나 시퀀스 프로토콜(:meth:`__len__` 메서드와 ``0`` 에서 시작하는 정수 인자를 받는 "
":meth:`__getitem__` 메서드)을 지원하는 객체여야 합니다."

#: ../Doc/library/functions.rst:1323
msgid ""
"Return *number* rounded to *ndigits* precision after the decimal point.  "
"If *ndigits* is omitted or is ``None``, it returns the nearest integer to"
" its input."
msgstr ""
"*number* 를 소수점 다음에 *ndigits* 정밀도로 반올림한 값을 돌려줍니다. *ndigits* 가 생략되거나 "
"``None`` 이면, 입력에 가장 가까운 정수를 돌려줍니다."

#: ../Doc/library/functions.rst:1327
msgid ""
"For the built-in types supporting :func:`round`, values are rounded to "
"the closest multiple of 10 to the power minus *ndigits*; if two multiples"
" are equally close, rounding is done toward the even choice (so, for "
"example, both ``round(0.5)`` and ``round(-0.5)`` are ``0``, and "
"``round(1.5)`` is ``2``).  Any integer value is valid for *ndigits* "
"(positive, zero, or negative).  The return value is an integer if "
"*ndigits* is omitted or ``None``. Otherwise the return value has the same"
" type as *number*."
msgstr ""
":func:`round` 를 지원하는 내장형의 경우, 값은 10의 *-ndigits* 거듭제곱의 가장 가까운 배수로 반올림됩니다; "
"두 배수가 똑같이 가깝다면, 반올림은 짝수를 선택합니다 (예를 들어, ``round(0.5)`` 와 ``round(-0.5)`` 는"
" 모두 ``0`` 이고, ``round(1.5)`` 는 ``2`` 입니다). 모든 정숫값은 *ndigits* 에 유효합니다 (양수,"
" 0 또는 음수). *ndigits* 가 생략되거나 ``None`` 이면, 반환 값은 정수입니다. 그렇지 않으면 반환 값은 "
"*number* 와 같은 형입니다."

#: ../Doc/library/functions.rst:1336
msgid ""
"For a general Python object ``number``, ``round`` delegates to "
"``number.__round__``."
msgstr "일반적인 파이썬 객체 ``number`` 의 경우, ``round`` 는 ``number.__round__`` 에 위임합니다."

#: ../Doc/library/functions.rst:1341
msgid ""
"The behavior of :func:`round` for floats can be surprising: for example, "
"``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``. This"
" is not a bug: it's a result of the fact that most decimal fractions "
"can't be represented exactly as a float.  See :ref:`tut-fp-issues` for "
"more information."
msgstr ""
"float에 대한 :func:`round` 의 동작은 예상과 다를 수 있습니다: 예를 들어, ``round(2.675, 2)`` 는"
" ``2.68`` 대신에 ``2.67`` 을 제공합니다. 이것은 버그가 아닙니다: 대부분의 십진 소수가 float로 정확히 표현될 "
"수 없다는 사실로부터 오는 결과입니다. 자세한 정보는 :ref:`tut-fp-issues` 를 보세요."

#: ../Doc/library/functions.rst:1352
msgid ""
"Return a new :class:`set` object, optionally with elements taken from "
"*iterable*.  ``set`` is a built-in class.  See :class:`set` and :ref"
":`types-set` for documentation about this class."
msgstr ""
"새 :class:`set` 객체를 돌려줍니다. 선택적으로 *iterable* 에서 가져온 요소를 갖습니다. ``set`` 은 내장 "
"클래스입니다. 이 클래스에 대한 설명서는 :class:`set` 및 :ref:`types-set` 을 보세요."

#: ../Doc/library/functions.rst:1356
msgid ""
"For other containers see the built-in :class:`frozenset`, :class:`list`, "
":class:`tuple`, and :class:`dict` classes, as well as the "
":mod:`collections` module."
msgstr ""
"다른 컨테이너의 경우 내장 :class:`frozenset`, :class:`list`, :class:`tuple` 및 "
":class:`dict` 클래스와 :mod:`collections` 모듈을 보세요."

#: ../Doc/library/functions.rst:1363
msgid ""
"This is the counterpart of :func:`getattr`.  The arguments are an object,"
" a string and an arbitrary value.  The string may name an existing "
"attribute or a new attribute.  The function assigns the value to the "
"attribute, provided the object allows it.  For example, ``setattr(x, "
"'foobar', 123)`` is equivalent to ``x.foobar = 123``."
msgstr ""
"이것은 :func:`getattr` 과 한 쌍입니다. 인자는 객체, 문자열 및 임의의 값입니다. 문자열은 기존 어트리뷰트 또는 새 "
"어트리뷰트의 이름을 지정할 수 있습니다. 이 함수는 객체가 허용하는 경우 값을 어트리뷰트에 대입합니다. 예를 들어, "
"``setattr(x, 'foobar', 123)`` 는 ``x.foobar = 123`` 과 동등합니다."

#: ../Doc/library/functions.rst:1375
msgid ""
"Return a :term:`slice` object representing the set of indices specified "
"by ``range(start, stop, step)``.  The *start* and *step* arguments "
"default to ``None``.  Slice objects have read-only data attributes "
":attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice.step` which "
"merely return the argument values (or their default).  They have no other"
" explicit functionality; however they are used by Numerical Python and "
"other third party extensions. Slice objects are also generated when "
"extended indexing syntax is used.  For example: ``a[start:stop:step]`` or"
" ``a[start:stop, i]``.  See :func:`itertools.islice` for an alternate "
"version that returns an iterator."
msgstr ""
"``range(start, stop, step)`` 에 의해 지정된 인덱스 세트를 나타내는 :term:`슬라이스 <slice>` "
"객체를 돌려줍니다. *start* 및 *step* 인자의 기본값은 ``None`` 입니다. 슬라이스 객체는 단지 인자 값 (또는 "
"기본값)을 돌려주는 :attr:`~slice.start`, :attr:`~slice.stop` 및 "
":attr:`~slice.step` 의 읽기 전용 데이터 어트리뷰트를 갖습니다. 다른 명시적 기능은 없습니다; 그러나 "
"Numerical Python과 다른 제삼자 확장이 사용합니다. 슬라이스 객체는 확장 인덱싱 문법을 사용할 때도 만들어집니다. 예를"
" 들어: ``a[start:stop:step]`` 또는 ``a[start:stop, i]``. 이터레이터를 돌려주는 대안 버전은 "
":func:`itertools.islice` 를 보세요."

#: ../Doc/library/functions.rst:1388
msgid "Return a new sorted list from the items in *iterable*."
msgstr "*iterable* 의 항목들로 새 정렬된 리스트를 돌려줍니다."

#: ../Doc/library/functions.rst:1390
msgid "Has two optional arguments which must be specified as keyword arguments."
msgstr "키워드 인자로만 지정해야 하는 두 개의 선택적 인자가 있습니다."

#: ../Doc/library/functions.rst:1392
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element: ``key=str.lower``.  The default "
"value is ``None`` (compare the elements directly)."
msgstr ""
"*key* 는 하나의 인자를 받는 함수를 지정하는데, 각 리스트 요소들로부터 비교 키를 추출하는 데 사용됩니다: ``key = "
"str.lower``. 기본값은 ``None`` 입니다 (요소를 직접 비교합니다)."

#: ../Doc/library/functions.rst:1396
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements"
" are sorted as if each comparison were reversed."
msgstr "*reverse* 는 논리값입니다. ``True`` 로 설정되면, 각 비교가 뒤집힌 것처럼 리스트 요소들이 정렬됩니다."

#: ../Doc/library/functions.rst:1399
msgid ""
"Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function "
"to a *key* function."
msgstr "예전 스타일의 *cmp* 함수를 *key* 함수로 변환하려면 :func:`functools.cmp_to_key` 를 사용하세요."

#: ../Doc/library/functions.rst:1402
msgid ""
"The built-in :func:`sorted` function is guaranteed to be stable. A sort "
"is stable if it guarantees not to change the relative order of elements "
"that compare equal --- this is helpful for sorting in multiple passes "
"(for example, sort by department, then by salary grade)."
msgstr ""
"내장 :func:`sorted` 함수는 안정적(stable)임이 보장됩니다. 정렬은 같다고 비교되는 요소의 상대적 순서를 변경하지 "
"않으면 안정적입니다 --- 이는 여러 번 정렬할 때 유용합니다 (예를 들어, 부서별로 정렬한 후에 급여 등급별로 정렬하기)."

#: ../Doc/library/functions.rst:1407
msgid ""
"For sorting examples and a brief sorting tutorial, see "
":ref:`sortinghowto`."
msgstr "정렬 예제와 간단한 정렬 자습서는 :ref:`sortinghowto` 를 보세요."

#: ../Doc/library/functions.rst:1411
msgid "Transform a method into a static method."
msgstr "메서드를 정적 메서드로 변환합니다."

#: ../Doc/library/functions.rst:1413
msgid ""
"A static method does not receive an implicit first argument. To declare a"
" static method, use this idiom::"
msgstr "정적 메서드는 묵시적인 첫 번째 인자를 받지 않습니다. 정적 메서드를 선언하려면, 이 관용구를 사용하세요::"

#: ../Doc/library/functions.rst:1420
msgid ""
"The ``@staticmethod`` form is a function :term:`decorator` -- see the "
"description of function definitions in :ref:`function` for details."
msgstr ""
"``@staticmethod`` 형식은 함수 :term:`데코레이터 <decorator>` 입니다 -- 자세한 내용은 "
":ref:`function` 의 함수 정의에 대한 설명을 보세요."

#: ../Doc/library/functions.rst:1423
msgid ""
"It can be called either on the class (such as ``C.f()``) or on an "
"instance (such as ``C().f()``).  The instance is ignored except for its "
"class."
msgstr ""
"클래스 (``C.f()`` 처럼) 또는 인스턴스 (``C().f()`` 처럼)에 대해 호출할 수 있습니다. 인스턴스는 해당 클래스만"
" 참조하고 무시합니다."

#: ../Doc/library/functions.rst:1426
msgid ""
"Static methods in Python are similar to those found in Java or C++. Also "
"see :func:`classmethod` for a variant that is useful for creating "
"alternate class constructors."
msgstr ""
"파이썬의 정적 메서드는 자바 또는 C++ 에서 발견되는 정적 메서드와 비슷합니다. 대체 클래스 생성자를 만드는 데 유용한 변형을 "
"보려면 :func:`classmethod` 도 보세요."

#: ../Doc/library/functions.rst:1430
msgid ""
"Like all decorators, it is also possible to call ``staticmethod`` as a "
"regular function and do something with its result.  This is needed in "
"some cases where you need a reference to a function from a class body and"
" you want to avoid the automatic transformation to instance method.  For "
"these cases, use this idiom::"
msgstr ""
"모든 데코레이터와 마찬가지로, ``staticmethod`` 를 정규 함수로 호출하여 그 결과로 어떤 일을 할 수도 있습니다. "
"이것은 클래스 바디에서 함수에 대한 참조가 필요하고 인스턴스 메서드로 자동 변환되는 것을 피하고자 할 때 필요합니다. 이 경우 다음"
" 관용구를 사용하세요::"

#: ../Doc/library/functions.rst:1439
msgid ""
"For more information on static methods, consult the documentation on the "
"standard type hierarchy in :ref:`types`."
msgstr "정적 메서드에 대한 더 자세한 정보는, :ref:`types` 에 있는 표준 타입 계층에 대한 설명서를 참조하세요."

#: ../Doc/library/functions.rst:1451
msgid "Return a :class:`str` version of *object*.  See :func:`str` for details."
msgstr "*object* 의 :class:`str` 버전을 돌려줍니다. 자세한 내용은 :func:`str` 을 보세요."

#: ../Doc/library/functions.rst:1453
msgid ""
"``str`` is the built-in string :term:`class`.  For general information "
"about strings, see :ref:`textseq`."
msgstr ""
"``str`` 은 내장 문자열 :term:`클래스 <class>` 입니다. 문자열에 대한 일반적인 정보는 :ref:`textseq`"
" 를 보세요."

#: ../Doc/library/functions.rst:1459
msgid ""
"Sums *start* and the items of an *iterable* from left to right and "
"returns the total.  *start* defaults to ``0``. The *iterable*'s items are"
" normally numbers, and the start value is not allowed to be a string."
msgstr ""
"*start* 및 *iterable* 의 항목들을 왼쪽에서 오른쪽으로 합하고 합계를 돌려줍니다. *start* 의 기본값은 "
"``0`` 입니다. *iterable* 의 항목은 일반적으로 숫자며 시작 값은 문자열이 될 수 없습니다."

#: ../Doc/library/functions.rst:1463
msgid ""
"For some use cases, there are good alternatives to :func:`sum`. The "
"preferred, fast way to concatenate a sequence of strings is by calling "
"``''.join(sequence)``.  To add floating point values with extended "
"precision, see :func:`math.fsum`\\.  To concatenate a series of "
"iterables, consider using :func:`itertools.chain`."
msgstr ""
"어떤 경우에는 :func:`sum` 에 대한 좋은 대안이 있습니다. 문자열의 시퀀스를 연결하는 가장 선호되고 빠른 방법은 "
"``''.join(sequence)`` 를 호출하는 것입니다. 확장된 정밀도로 부동 소수점 값을 더하려면 "
":func:`math.fsum` 를 보세요. 일련의 이터러블들을 연결하려면 :func:`itertools.chain` 를 "
"고려해보세요."

#: ../Doc/library/functions.rst:1471
msgid ""
"Return a proxy object that delegates method calls to a parent or sibling "
"class of *type*.  This is useful for accessing inherited methods that "
"have been overridden in a class. The search order is same as that used by"
" :func:`getattr` except that the *type* itself is skipped."
msgstr ""
"메서드 호출을 *type* 의 부모나 형제 클래스에 위임하는 프락시 객체를 돌려줍니다. 이는 클래스에서 재정의된 상속 된 메서드를 "
"액세스할 때 유용합니다. 검색 순서는 *type* 자체를 건너뛰는 것을 제외하면, :func:`getattr` 에 의해 사용된 "
"순서와 같습니다."

#: ../Doc/library/functions.rst:1476
msgid ""
"The :attr:`~class.__mro__` attribute of the *type* lists the method "
"resolution search order used by both :func:`getattr` and :func:`super`.  "
"The attribute is dynamic and can change whenever the inheritance "
"hierarchy is updated."
msgstr ""
"*type* 의 :attr:`~class.__mro__` 어트리뷰트는 메서드 결정 검색 순서를 나열하는데 "
":func:`getattr` 과 :func:`super` 에서 사용됩니다. 이 어트리뷰트는 동적이며 상속 계층 구조가 변경될 때마다"
" 바뀔 수 있습니다."

#: ../Doc/library/functions.rst:1481
msgid ""
"If the second argument is omitted, the super object returned is unbound."
"  If the second argument is an object, ``isinstance(obj, type)`` must be "
"true.  If the second argument is a type, ``issubclass(type2, type)`` must"
" be true (this is useful for classmethods)."
msgstr ""
"두 번째 인자가 생략되면, 반환되는 슈퍼 객체는 연결되지 않았습니다(unbound). 두 번째 인자가 객체면, "
"``isinstance(obj, type)`` 는 참이어야 합니다. 두 번째 인자가 형이면, ``issubclass(type2, "
"type)`` 는 참이어야 합니다 (이것은 클래스 메서드에 유용합니다)."

#: ../Doc/library/functions.rst:1486
msgid ""
"There are two typical use cases for *super*.  In a class hierarchy with "
"single inheritance, *super* can be used to refer to parent classes "
"without naming them explicitly, thus making the code more maintainable.  "
"This use closely parallels the use of *super* in other programming "
"languages."
msgstr ""
"*super* 에는 두 가지 일반적인 사용 사례가 있습니다. 단일 상속 클래스 계층 구조에서는, *super* 를 사용하여 "
"명시적으로 이름을 지정하지 않고 부모 클래스를 참조할 수 있으므로, 코드를 더 유지 관리하기 쉽게 만들 수 있습니다. 이 사용은 "
"다른 프로그래밍 언어에서 *super* 를 쓰는 것과 매우 유사합니다."

#: ../Doc/library/functions.rst:1491
msgid ""
"The second use case is to support cooperative multiple inheritance in a "
"dynamic execution environment.  This use case is unique to Python and is "
"not found in statically compiled languages or languages that only support"
" single inheritance.  This makes it possible to implement \"diamond "
"diagrams\" where multiple base classes implement the same method.  Good "
"design dictates that this method have the same calling signature in every"
" case (because the order of calls is determined at runtime, because that "
"order adapts to changes in the class hierarchy, and because that order "
"can include sibling classes that are unknown prior to runtime)."
msgstr ""
"두 번째 사용 사례는 동적 실행 환경에서 협력적 다중 상속을 지원하는 것입니다. 이 사례는 파이썬에 고유하며 정적으로 컴파일되는 "
"언어 또는 단일 상속만 지원하는 언어에서는 찾을 수 없습니다. 이것은 여러 베이스 클래스가 같은 메서드를 구현하는 \"다이아몬드 "
"다이어그램\"을 구현할 수 있게 합니다. 좋은 설계는 모든 경우에 이 메서드가 같은 호출 시그니처를 갖도록 하는 것입니다 (호출 "
"순서는 실행 시간에 결정되기 때문에, 그 순서가 클래스 계층 구조의 변경에 적응하기 때문에, 그리고 그 순서가 실행 시간 전에 미리"
" 알려지지 않은 형제 클래스를 포함할 수 있으므로)."

#: ../Doc/library/functions.rst:1501
msgid "For both use cases, a typical superclass call looks like this::"
msgstr "두 경우 모두, 일반적인 슈퍼 클래스 호출은 이런 식입니다::"

#: ../Doc/library/functions.rst:1508
msgid ""
"Note that :func:`super` is implemented as part of the binding process for"
" explicit dotted attribute lookups such as ``super().__getitem__(name)``."
" It does so by implementing its own :meth:`__getattribute__` method for "
"searching classes in a predictable order that supports cooperative "
"multiple inheritance. Accordingly, :func:`super` is undefined for "
"implicit lookups using statements or operators such as ``super()[name]``."
msgstr ""
":func:`super` 는 ``super().__getitem__(name)`` 과 같은 명시적인 점으로 구분된 어트리뷰트 조회를"
" 위한 연결 절차의 일부로 구현됨에 주의하세요. 이것은 협력적인 다중 상속을 지원하는 예측 가능한 순서로 클래스를 검색하기 위해 "
"자체 :meth:`__getattribute__` 메서드를 구현함으로써 그렇게 합니다. 따라서, :func:`super` 는 "
"``super()[name]`` 과같이 문장이나 연산자를 사용하는 묵시적 조회에 대해서는 정의되지 않았습니다."

#: ../Doc/library/functions.rst:1515
msgid ""
"Also note that, aside from the zero argument form, :func:`super` is not "
"limited to use inside methods.  The two argument form specifies the "
"arguments exactly and makes the appropriate references.  The zero "
"argument form only works inside a class definition, as the compiler fills"
" in the necessary details to correctly retrieve the class being defined, "
"as well as accessing the current instance for ordinary methods."
msgstr ""
"또한, 인자가 없는 형식을 제외하고는, :func:`super` 는 메서드 내부에서만 사용하도록 제한되지 않는다는 점에 유의하세요."
" 두 개의 인자 형식은 인자를 정확하게 지정하고 적절한 참조를 만듭니다. 인자가 없는 형식은 클래스 정의 내에서만 작동하는데, "
"컴파일러가 정의되고 있는 클래스를 올바르게 가져오고 일반 메서드에서 현재 인스턴스에 액세스하는 데 필요한 세부 정보를 채우기 "
"때문입니다."

#: ../Doc/library/functions.rst:1522
msgid ""
"For practical suggestions on how to design cooperative classes using "
":func:`super`, see `guide to using super() "
"<https://rhettinger.wordpress.com/2011/05/26/super-considered-super/>`_."
msgstr ""
":func:`super`\\를 사용하여 협력적 클래스를 설계하는 방법에 대한 실용적인 제안은 `super() 사용 안내 "
"<https://rhettinger.wordpress.com/2011/05/26/super-considered-super/>`_ 를"
" 보세요."

#: ../Doc/library/functions.rst:1531
msgid ""
"Rather than being a function, :class:`tuple` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-tuple` and "
":ref:`typesseq`."
msgstr ""
"함수이기보다, :class:`tuple` 은 실제로 :ref:`typesseq-tuple` 과 :ref:`typesseq` 에 "
"문서화 된 것처럼 불변 시퀀스 형입니다."

#: ../Doc/library/functions.rst:1540
msgid ""
"With one argument, return the type of an *object*.  The return value is a"
" type object and generally the same object as returned by "
":attr:`object.__class__ <instance.__class__>`."
msgstr ""
"인자 하나의 경우, *object* 의 형을 돌려줍니다. 반환 값은 형 객체며 일반적으로 :attr:`object.__class__"
" <instance.__class__>` 가 돌려주는 것과 같은 객체입니다."

#: ../Doc/library/functions.rst:1544
msgid ""
"The :func:`isinstance` built-in function is recommended for testing the "
"type of an object, because it takes subclasses into account."
msgstr "객체의 형을 검사하는 데는 :func:`isinstance` 내장 함수가 권장되는데, 서브 클래스를 고려하기 때문입니다."

#: ../Doc/library/functions.rst:1548
msgid ""
"With three arguments, return a new type object.  This is essentially a "
"dynamic form of the :keyword:`class` statement. The *name* string is the "
"class name and becomes the :attr:`~definition.__name__` attribute; the "
"*bases* tuple itemizes the base classes and becomes the "
":attr:`~class.__bases__` attribute; and the *dict* dictionary is the "
"namespace containing definitions for class body and is copied to a "
"standard dictionary to become the :attr:`~object.__dict__` attribute.  "
"For example, the following two statements create identical :class:`type` "
"objects:"
msgstr ""
"세 개의 인자를 주는 경우, 새 형 객체를 돌려줍니다. 이것은 본래 :keyword:`class` 문의 동적인 형태입니다. "
"*name* 문자열은 클래스 이름이고 :attr:`~definition.__name__` 어트리뷰트가 됩니다; *bases* 튜플은"
" 베이스 클래스들을 항목화하고 :attr:`~class.__bases__` 어트리뷰트가 됩니다; *dict* 딕셔너리는 클래스 "
"바디의 정의들이 들어있는 이름 공간이며 :attr:`~object.__dict__` 어트리뷰트가 되도록 표준 딕셔너리에 복사됩니다."
" 예를 들어, 다음 두 문장은 같은 :class:`type` 객체를 만듭니다:"

#: ../Doc/library/functions.rst:1562
msgid "See also :ref:`bltin-type-objects`."
msgstr ":ref:`bltin-type-objects`\\를 보세요."

#: ../Doc/library/functions.rst:1564
msgid ""
"Subclasses of :class:`type` which don't override ``type.__new__`` may no "
"longer use the one-argument form to get the type of an object."
msgstr ""
"``type.__new__`` 를 재정의하지 않는 :class:`type` 의 서브 클래스는 이제 객체의 형을 얻기 위해 하나의 "
"인자 형식을 사용할 수 없습니다."

#: ../Doc/library/functions.rst:1570
msgid ""
"Return the :attr:`~object.__dict__` attribute for a module, class, "
"instance, or any other object with a :attr:`~object.__dict__` attribute."
msgstr ""
"모듈, 클래스, 인스턴스 또는 :attr:`~object.__dict__` 어트리뷰트가 있는 다른 객체의 "
":attr:`~object.__dict__` 어트리뷰트를 돌려줍니다."

#: ../Doc/library/functions.rst:1573
msgid ""
"Objects such as modules and instances have an updateable "
":attr:`~object.__dict__` attribute; however, other objects may have write"
" restrictions on their :attr:`~object.__dict__` attributes (for example, "
"classes use a :class:`types.MappingProxyType` to prevent direct "
"dictionary updates)."
msgstr ""
"모듈 및 인스턴스와 같은 객체는 업데이트 가능한 :attr:`~object.__dict__` 어트리뷰트를 갖습니다; 그러나, 다른 "
"객체는 :attr:`~object.__dict__` 어트리뷰트에 쓰기 제한을 가질 수 있습니다 (예를 들어, 클래스는 직접적인 "
"딕셔너리 갱신을 방지하기 위해 :class:`types.MappingProxyType` 를 사용합니다)."

#: ../Doc/library/functions.rst:1578
msgid ""
"Without an argument, :func:`vars` acts like :func:`locals`.  Note, the "
"locals dictionary is only useful for reads since updates to the locals "
"dictionary are ignored."
msgstr ""
"인자가 없으면, :func:`vars` 는 :func:`locals` 처럼 동작합니다. locals 딕셔너리에 대한 변경이 무시되기"
" 때문에 locals 딕셔너리는 읽기에만 유용하다는 것에 주의하세요."

#: ../Doc/library/functions.rst:1585
msgid "Make an iterator that aggregates elements from each of the iterables."
msgstr "각 iterables 의 요소들을 모으는 이터레이터를 만듭니다."

#: ../Doc/library/functions.rst:1587
msgid ""
"Returns an iterator of tuples, where the *i*-th tuple contains the *i*-th"
" element from each of the argument sequences or iterables.  The iterator "
"stops when the shortest input iterable is exhausted. With a single "
"iterable argument, it returns an iterator of 1-tuples.  With no "
"arguments, it returns an empty iterator.  Equivalent to::"
msgstr ""
"튜플의 이터레이터를 돌려주는데, *i* 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 *i* 번째 요소를 포함합니다. "
"이터레이터는 가장 짧은 입력 이터러블이 모두 소모되면 멈춥니다. 하나의 이터러블 인자를 사용하면, 1-튜플의 이터레이터를 "
"돌려줍니다. 인자가 없으면, 빈 이터레이터를 돌려줍니다. 다음과 동등합니다::"

#: ../Doc/library/functions.rst:1606
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups"
" using ``zip(*[iter(s)]*n)``.  This repeats the *same* iterator ``n`` "
"times so that each output tuple has the result of ``n`` calls to the "
"iterator. This has the effect of dividing the input into n-length chunks."
msgstr ""
"iterables 를 왼쪽에서 오른쪽으로 값을 구하는 순서가 보장됩니다. 이것은 ``zip(*[iter(s)]*n)`` 을 사용하여"
" 데이터 시리즈를 길이 n인 그룹으로 클러스터링하는 관용구를 가능하게 만듭니다. 이것은 *같은* 이터레이터를 ``n`` 번 "
"반복해서, 각 출력 튜플이 이터레이터를 ``n`` 번 호출한 결과를 갖게 됩니다. 입력을 길이 n인 묶음으로 나누는 효과를 줍니다."

#: ../Doc/library/functions.rst:1612
msgid ""
":func:`zip` should only be used with unequal length inputs when you don't"
" care about trailing, unmatched values from the longer iterables.  If "
"those values are important, use :func:`itertools.zip_longest` instead."
msgstr ""
":func:`zip` 에 길이가 같지 않은 입력들을 제공하는 것은, 끝부분에서 매치되지 않고 남는 더 긴 이터러블들의 값들에 신경 "
"쓰지 않는 경우로 제한해야 합니다. 그 값들이 중요하다면, 대신 :func:`itertools.zip_longest` 를 "
"사용하세요."

#: ../Doc/library/functions.rst:1616
msgid ""
":func:`zip` in conjunction with the ``*`` operator can be used to unzip a"
" list::"
msgstr ":func:`zip`\\을 ``*`` 연산자와 함께 쓰면 리스트를 unzip 할 수 있습니다::"

#: ../Doc/library/functions.rst:1637
msgid ""
"This is an advanced function that is not needed in everyday Python "
"programming, unlike :func:`importlib.import_module`."
msgstr ""
"이것은 :func:`importlib.import_module` 과 달리 일상적인 파이썬 프로그래밍에서는 필요하지 않은 고급 "
"함수입니다."

#: ../Doc/library/functions.rst:1640
msgid ""
"This function is invoked by the :keyword:`import` statement.  It can be "
"replaced (by importing the :mod:`builtins` module and assigning to "
"``builtins.__import__``) in order to change semantics of the "
":keyword:`import` statement, but doing so is **strongly** discouraged as "
"it is usually simpler to use import hooks (see :pep:`302`) to attain the "
"same goals and does not cause issues with code which assumes the default "
"import implementation is in use.  Direct use of :func:`__import__` is "
"also discouraged in favor of :func:`importlib.import_module`."
msgstr ""
"이 함수는 :keyword:`import` 문에 의해 호출됩니다. :keyword:`import` 문의 의미를 변경하기 위해 대체할"
" 수 있습니다 (:mod:`builtins` 모듈을 임포트하고 ``builtins .__ import__`` 에 대입합니다). "
"그러나 그렇게 하지 말 것을 **강하게** 권고하는데, 보통 같은 목적을 달성하는데 임포트 훅(:pep:`302` 를 보세요)을 "
"사용하는 것이 더 간단하고 기본 임포트 구현이 사용될 것이라고 가정하는 코드들과 문제를 일으키지 않기 때문입니다. "
":func:`__import__` 의 직접 사용 역시 피하고 :func:`importlib.import_module` 을 사용할 "
"것을 권합니다."

#: ../Doc/library/functions.rst:1649
msgid ""
"The function imports the module *name*, potentially using the given "
"*globals* and *locals* to determine how to interpret the name in a "
"package context. The *fromlist* gives the names of objects or submodules "
"that should be imported from the module given by *name*.  The standard "
"implementation does not use its *locals* argument at all, and uses its "
"*globals* only to determine the package context of the :keyword:`import` "
"statement."
msgstr ""
"함수는 모듈 *name* 을 임포트 하는데, 잠재적으로 패키지 문맥에서 이름을 해석하는 방법을 결정하는데 주어진 *globals* "
"와 *locals* 를 사용합니다. *fromlist* 는 *name* 에 의해 주어진 모듈로부터 임포트 되어야 하는 객체 또는 "
"서브 모듈의 이름을 제공합니다. 표준 구현은 *locals* 인자를 전혀 사용하지 않고, :keyword:`import` 문의 "
"패키지 문맥을 결정할 때만 *globals* 를 사용합니다."

#: ../Doc/library/functions.rst:1656
msgid ""
"*level* specifies whether to use absolute or relative imports. ``0`` (the"
" default) means only perform absolute imports.  Positive values for "
"*level* indicate the number of parent directories to search relative to "
"the directory of the module calling :func:`__import__` (see :pep:`328` "
"for the details)."
msgstr ""
"*level* 은 절대 또는 상대 임포트를 사용할지를 지정합니다. ``0`` (기본값)은 오직 절대 임포트를 수행한다는 것을 "
"의미합니다. 양수 값 *level* 은 :func:`__import__` 를 호출하는 모듈 디렉터리에 상대적으로 검색할 상위 "
"디렉터리들의 개수를 가리킵니다 (자세한 내용은 :pep:`328`\\을 보세요)."

#: ../Doc/library/functions.rst:1662
msgid ""
"When the *name* variable is of the form ``package.module``, normally, the"
" top-level package (the name up till the first dot) is returned, *not* "
"the module named by *name*.  However, when a non-empty *fromlist* "
"argument is given, the module named by *name* is returned."
msgstr ""
"*name* 변수가 ``package.module`` 형식일 때, 일반적으로 *name* 에 의해 명명된 모듈이 *아니라*, 최상위"
" 패키지(첫 번째 점까지의 이름)가 반환됩니다. 그러나 비어 있지 않은 *fromlist* 인자가 주어지면 *name* 에 의해 "
"명명된 모듈이 반환됩니다."

#: ../Doc/library/functions.rst:1667
msgid ""
"For example, the statement ``import spam`` results in bytecode resembling"
" the following code::"
msgstr "예를 들어, 문장 ``import spam`` 은 다음 코드를 닮은 바이트 코드를 생성합니다::"

#: ../Doc/library/functions.rst:1672
msgid "The statement ``import spam.ham`` results in this call::"
msgstr "문장 ``import spam.ham`` 은 이런 호출로 이어집니다::"

#: ../Doc/library/functions.rst:1676
msgid ""
"Note how :func:`__import__` returns the toplevel module here because this"
" is the object that is bound to a name by the :keyword:`import` "
"statement."
msgstr ""
"여기에서 :func:`__import__` 가 최상위 모듈을 돌려주는 것에 주목하세요. 이것이 :keyword:`import` 문에"
" 의해 이름에 연결되는 객체이기 때문입니다."

#: ../Doc/library/functions.rst:1679
msgid ""
"On the other hand, the statement ``from spam.ham import eggs, sausage as "
"saus`` results in ::"
msgstr "반면에, 문장 ``from spam.ham import eggs, sausage as saus`` 는 이런 결과를 줍니다::"

#: ../Doc/library/functions.rst:1686
msgid ""
"Here, the ``spam.ham`` module is returned from :func:`__import__`.  From "
"this object, the names to import are retrieved and assigned to their "
"respective names."
msgstr ""
"여기서 ``spam.ham`` 모듈이 :func:`__import__` 에서 반환됩니다. 이 객체로부터, 임포트할 이름들을 가져온 "
"후 해당 이름들로 대입됩니다."

#: ../Doc/library/functions.rst:1690
msgid ""
"If you simply want to import a module (potentially within a package) by "
"name, use :func:`importlib.import_module`."
msgstr ""
"단순히 이름으로 모듈을 임포트 하기 원한다면 (잠재적으로 패키지 내에서), :func:`importlib.import_module`"
" 을 사용하세요."

#: ../Doc/library/functions.rst:1693
msgid ""
"Negative values for *level* are no longer supported (which also changes "
"the default value to 0)."
msgstr "음수 *level* 은 더 지원되지 않습니다 (기본값도 0으로 변경합니다)."

#: ../Doc/library/functions.rst:1699
msgid "Footnotes"
msgstr "각주"

#: ../Doc/library/functions.rst:1700
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. "
"If you are reading the code from a file, make sure to use newline "
"conversion mode to convert Windows or Mac-style newlines."
msgstr ""
"파서는 유닉스 스타일의 줄 종료 규칙만 받아들이는 것에 주의하세요. 파일에서 코드를 읽는 경우, 줄 넘김 변환 모드를 사용해서 "
"윈도우나 맥 스타일 줄 넘김을 변환해야 합니다."

