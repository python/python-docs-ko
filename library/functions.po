# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-23 11:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/functions.rst:5 ../Doc/library/functions.rst:11
msgid "Built-in Functions"
msgstr "내장 함수"

#: ../Doc/library/functions.rst:7
msgid ""
"The Python interpreter has a number of functions and types built into it "
"that are always available.  They are listed here in alphabetical order."
msgstr "파이썬 인터프리터에는 항상 사용할 수 있는 많은 함수와 형이 내장되어 있다. 여기에서 알파벳 순으로 나열한다."

#: ../Doc/library/functions.rst:13
msgid ":func:`abs`"
msgstr ":func:`abs`"

#: ../Doc/library/functions.rst:13
msgid "|func-dict|_"
msgstr "|func-dict|_"

#: ../Doc/library/functions.rst:13
msgid ":func:`help`"
msgstr ":func:`help`"

#: ../Doc/library/functions.rst:13
msgid ":func:`min`"
msgstr ":func:`min`"

#: ../Doc/library/functions.rst:13
msgid ":func:`setattr`"
msgstr ":func:`setattr`"

#: ../Doc/library/functions.rst:14
msgid ":func:`all`"
msgstr ":func:`all`"

#: ../Doc/library/functions.rst:14
msgid ":func:`dir`"
msgstr ":func:`dir`"

#: ../Doc/library/functions.rst:14
msgid ":func:`hex`"
msgstr ":func:`hex`"

#: ../Doc/library/functions.rst:14
msgid ":func:`next`"
msgstr ":func:`next`"

#: ../Doc/library/functions.rst:14
msgid ":func:`slice`"
msgstr ":func:`slice`"

#: ../Doc/library/functions.rst:15
msgid ":func:`any`"
msgstr ":func:`any`"

#: ../Doc/library/functions.rst:15
msgid ":func:`divmod`"
msgstr ":func:`divmod`"

#: ../Doc/library/functions.rst:15
msgid ":func:`id`"
msgstr ":func:`id`"

#: ../Doc/library/functions.rst:15
msgid ":func:`object`"
msgstr ":func:`object`"

#: ../Doc/library/functions.rst:15
msgid ":func:`sorted`"
msgstr ":func:`sorted`"

#: ../Doc/library/functions.rst:16
msgid ":func:`ascii`"
msgstr ":func:`ascii`"

#: ../Doc/library/functions.rst:16
msgid ":func:`enumerate`"
msgstr ":func:`enumerate`"

#: ../Doc/library/functions.rst:16
msgid ":func:`input`"
msgstr ":func:`input`"

#: ../Doc/library/functions.rst:16
msgid ":func:`oct`"
msgstr ":func:`oct`"

#: ../Doc/library/functions.rst:16
msgid ":func:`staticmethod`"
msgstr ":func:`staticmethod`"

#: ../Doc/library/functions.rst:17
msgid ":func:`bin`"
msgstr ":func:`bin`"

#: ../Doc/library/functions.rst:17
msgid ":func:`eval`"
msgstr ":func:`eval`"

#: ../Doc/library/functions.rst:17
msgid ":func:`int`"
msgstr ":func:`int`"

#: ../Doc/library/functions.rst:17
msgid ":func:`open`"
msgstr ":func:`open`"

#: ../Doc/library/functions.rst:17
msgid "|func-str|_"
msgstr "|func-str|_"

#: ../Doc/library/functions.rst:18
msgid ":func:`bool`"
msgstr ":func:`bool`"

#: ../Doc/library/functions.rst:18
msgid ":func:`exec`"
msgstr ":func:`exec`"

#: ../Doc/library/functions.rst:18
msgid ":func:`isinstance`"
msgstr ":func:`isinstance`"

#: ../Doc/library/functions.rst:18
msgid ":func:`ord`"
msgstr ":func:`ord`"

#: ../Doc/library/functions.rst:18
msgid ":func:`sum`"
msgstr ":func:`sum`"

#: ../Doc/library/functions.rst:19
msgid "|func-bytearray|_"
msgstr "|func-bytearray|_"

#: ../Doc/library/functions.rst:19
msgid ":func:`filter`"
msgstr ":func:`filter`"

#: ../Doc/library/functions.rst:19
msgid ":func:`issubclass`"
msgstr ":func:`issubclass`"

#: ../Doc/library/functions.rst:19
msgid ":func:`pow`"
msgstr ":func:`pow`"

#: ../Doc/library/functions.rst:19
msgid ":func:`super`"
msgstr ":func:`super`"

#: ../Doc/library/functions.rst:20
msgid "|func-bytes|_"
msgstr "|func-bytes|_"

#: ../Doc/library/functions.rst:20
msgid ":func:`float`"
msgstr ":func:`float`"

#: ../Doc/library/functions.rst:20
msgid ":func:`iter`"
msgstr ":func:`iter`"

#: ../Doc/library/functions.rst:20
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../Doc/library/functions.rst:20
msgid "|func-tuple|_"
msgstr "|func-tuple|_"

#: ../Doc/library/functions.rst:21
msgid ":func:`callable`"
msgstr ":func:`callable`"

#: ../Doc/library/functions.rst:21
msgid ":func:`format`"
msgstr ":func:`format`"

#: ../Doc/library/functions.rst:21
msgid ":func:`len`"
msgstr ":func:`len`"

#: ../Doc/library/functions.rst:21
msgid ":func:`property`"
msgstr ":func:`property`"

#: ../Doc/library/functions.rst:21
msgid ":func:`type`"
msgstr ":func:`type`"

#: ../Doc/library/functions.rst:22
msgid ":func:`chr`"
msgstr ":func:`chr`"

#: ../Doc/library/functions.rst:22
msgid "|func-frozenset|_"
msgstr "|func-frozenset|_"

#: ../Doc/library/functions.rst:22
msgid "|func-list|_"
msgstr "|func-list|_"

#: ../Doc/library/functions.rst:22
msgid "|func-range|_"
msgstr "|func-range|_"

#: ../Doc/library/functions.rst:22
msgid ":func:`vars`"
msgstr ":func:`vars`"

#: ../Doc/library/functions.rst:23
msgid ":func:`classmethod`"
msgstr ":func:`classmethod`"

#: ../Doc/library/functions.rst:23
msgid ":func:`getattr`"
msgstr ":func:`getattr`"

#: ../Doc/library/functions.rst:23
msgid ":func:`locals`"
msgstr ":func:`locals`"

#: ../Doc/library/functions.rst:23
msgid ":func:`repr`"
msgstr ":func:`repr`"

#: ../Doc/library/functions.rst:23
msgid ":func:`zip`"
msgstr ":func:`zip`"

#: ../Doc/library/functions.rst:24
msgid ":func:`compile`"
msgstr ":func:`compile`"

#: ../Doc/library/functions.rst:24
msgid ":func:`globals`"
msgstr ":func:`globals`"

#: ../Doc/library/functions.rst:24
msgid ":func:`map`"
msgstr ":func:`map`"

#: ../Doc/library/functions.rst:24
msgid ":func:`reversed`"
msgstr ":func:`reversed`"

#: ../Doc/library/functions.rst:24
msgid ":func:`__import__`"
msgstr ":func:`__import__`"

#: ../Doc/library/functions.rst:25
msgid ":func:`complex`"
msgstr ":func:`complex`"

#: ../Doc/library/functions.rst:25
msgid ":func:`hasattr`"
msgstr ":func:`hasattr`"

#: ../Doc/library/functions.rst:25
msgid ":func:`max`"
msgstr ":func:`max`"

#: ../Doc/library/functions.rst:25
msgid ":func:`round`"
msgstr ":func:`round`"

#: ../Doc/library/functions.rst:26
msgid ":func:`delattr`"
msgstr ":func:`delattr`"

#: ../Doc/library/functions.rst:26
msgid ":func:`hash`"
msgstr ":func:`hash`"

#: ../Doc/library/functions.rst:26
msgid "|func-memoryview|_"
msgstr "|func-memoryview|_"

#: ../Doc/library/functions.rst:26
msgid "|func-set|_"
msgstr "|func-set|_"

#: ../Doc/library/functions.rst:45
msgid ""
"Return the absolute value of a number.  The argument may be an integer or"
" a floating point number.  If the argument is a complex number, its "
"magnitude is returned."
msgstr "숫자의 절댓값을 돌려준다. 인자는 정수 또는 실수다. 인자가 복소수면 그 크기가 반환된다."

#: ../Doc/library/functions.rst:52
msgid ""
"Return ``True`` if all elements of the *iterable* are true (or if the "
"iterable is empty).  Equivalent to::"
msgstr ""
"*iterable* 의 모든 요소가 참이면 (또는 iterable 이 비어있으면) ``True`` 를 돌려준다. 다음과 동등하다::"

#: ../Doc/library/functions.rst:64
msgid ""
"Return ``True`` if any element of the *iterable* is true.  If the "
"iterable is empty, return ``False``.  Equivalent to::"
msgstr ""
"*iterable* 의 요소 중 어느 하나라도 참이면 ``True`` 를 돌려준다. iterable이 비어 있으면 ``False`` 를 "
"돌려준다. 다음과 동등하다::"

#: ../Doc/library/functions.rst:76
msgid ""
"As :func:`repr`, return a string containing a printable representation of"
" an object, but escape the non-ASCII characters in the string returned by"
" :func:`repr` using ``\\x``, ``\\u`` or ``\\U`` escapes.  This generates "
"a string similar to that returned by :func:`repr` in Python 2."
msgstr ""
":func:`repr` 처럼, 객체의 인쇄 가능한 표현을 포함하는 문자열을 반환하지만, ``\\x`` 나 ``\\u`` 또는 "
"``\\U`` 이스케이프를 사용하여 :func:`repr` 이 돌려주는 문자열에 포함된 비 ASCII 문자를 이스케이프 한다. 이것은 "
"파이썬 2의 :func:`repr` 이 돌려주는 것과 비슷한 문자열을 만든다."

#: ../Doc/library/functions.rst:84
msgid ""
"Convert an integer number to a binary string prefixed with \"0b\". The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`__index__` method that returns an "
"integer. Some examples:"
msgstr ""
"정수를 \"0b\" 가 앞에 붙은 이진 문자열로 변환한다. 결과는 올바른 파이썬 표현식이다. *x* 가 파이썬 :class:`int` "
"객체가 아니라면, 정수를 돌려주는 :meth:`__index__` 메서드를 정의해야 한다. 몇 가지 예를 들면:"

#: ../Doc/library/functions.rst:94
msgid ""
"If prefix \"0b\" is desired or not, you can use either of the following "
"ways."
msgstr "접두어 \"0b\" 가 필요할 수도, 필요 없을 수도 있다면, 다음 방법의 하나를 사용할 수 있다."

#: ../Doc/library/functions.rst:101 ../Doc/library/functions.rst:672
#: ../Doc/library/functions.rst:926
msgid "See also :func:`format` for more information."
msgstr "자세한 내용은 :func:`format` 을 보면 된다."

#: ../Doc/library/functions.rst:106
msgid ""
"Return a Boolean value, i.e. one of ``True`` or ``False``.  *x* is "
"converted using the standard :ref:`truth testing procedure <truth>`.  If "
"*x* is false or omitted, this returns ``False``; otherwise it returns "
"``True``.  The :class:`bool` class is a subclass of :class:`int` (see "
":ref:`typesnumeric`). It cannot be subclassed further.  Its only "
"instances are ``False`` and ``True`` (see :ref:`bltin-boolean-values`)."
msgstr ""
"논리값, 즉 ``True`` 또는 ``False`` 중 하나를 돌려준다. *x* 표준 :ref:`논리값 검사 절차 <truth>` 를 "
"사용하여 변환된다. *x* 가 거짓이거나 생략되면 ``False`` 를 돌려준다. 그렇지 않으면``True`` 를 돌려준다. "
":class:`bool` 클래스는 :class:`int` (:ref:`typesnumeric` 참조)의 서브 클래스다. 서브 클래스를 더"
" 만들 수 없다. 이것의 유일한 인스턴스는 ``False`` 와``True`` 다 (:ref:`bltin-boolean-values` "
"참조)."

#: ../Doc/library/functions.rst:120
msgid ""
"Return a new array of bytes.  The :class:`bytearray` class is a mutable "
"sequence of integers in the range 0 <= x < 256.  It has most of the usual"
" methods of mutable sequences, described in :ref:`typesseq-mutable`, as "
"well as most methods that the :class:`bytes` type has, see :ref:`bytes-"
"methods`."
msgstr ""
"새로운 바이트 배열을 돌려준다. :class:`bytearray` 클래스는 0 <= x < 256 범위에 있는 정수의 가변 시퀀스다. "
":class:`bytes` 형이 가진 대부분의 메서드뿐만 아니라 (:ref:`bytes-methods` 참조), "
":ref:`typesseq-mutable` 에 기술된 가변 시퀀스의 일반적인 메서드 대부분을 갖고 있다."

#: ../Doc/library/functions.rst:125
msgid ""
"The optional *source* parameter can be used to initialize the array in a "
"few different ways:"
msgstr "선택적 *source* 파라미터는 몇 가지 다른 방법으로 배열을 초기화하는 데 사용할 수 있다:"

#: ../Doc/library/functions.rst:128
msgid ""
"If it is a *string*, you must also give the *encoding* (and optionally, "
"*errors*) parameters; :func:`bytearray` then converts the string to bytes"
" using :meth:`str.encode`."
msgstr ""
"*문자열* 이면, 반드시 *encoding* 파라미터도 제공해야 한다 (그리고 선택적으로 *errors* 도); 그러면 "
":func:`bytearray` 는 :meth:`str.encode` 를 사용하여 문자열을 바이트로 변환한다."

#: ../Doc/library/functions.rst:132
msgid ""
"If it is an *integer*, the array will have that size and will be "
"initialized with null bytes."
msgstr "*정수* 면, 배열은 그 크기를 갖고, 널 바이트로 초기화된다."

#: ../Doc/library/functions.rst:135
msgid ""
"If it is an object conforming to the *buffer* interface, a read-only "
"buffer of the object will be used to initialize the bytes array."
msgstr "*버퍼(buffer)* 인터페이스를 제공하는 객체면, 객체의 읽기 전용 버퍼가 바이트 배열을 초기화하는 데 사용된다."

#: ../Doc/library/functions.rst:138
msgid ""
"If it is an *iterable*, it must be an iterable of integers in the range "
"``0 <= x < 256``, which are used as the initial contents of the array."
msgstr ""
"*이터러블* 이면, 범위 ``0 <= x < 256`` 의 정수를 제공하는 이터러블이어야 하고, 그 값들이 배열의 초기 내용물로 "
"사용된다."

#: ../Doc/library/functions.rst:141
msgid "Without an argument, an array of size 0 is created."
msgstr "인자가 없으면 크기 0의 배열이 만들어진다."

#: ../Doc/library/functions.rst:143
msgid "See also :ref:`binaryseq` and :ref:`typebytearray`."
msgstr ":ref:`binaryseq` 와 :ref:`typebytearray` 를 참고하라."

#: ../Doc/library/functions.rst:150
msgid ""
"Return a new \"bytes\" object, which is an immutable sequence of integers"
" in the range ``0 <= x < 256``.  :class:`bytes` is an immutable version "
"of :class:`bytearray` -- it has the same non-mutating methods and the "
"same indexing and slicing behavior."
msgstr ""
"새로운 \"바이트열\" 객체를 돌려준다. 이 객체는 ``0 <= x < 256`` 범위에 있는 정수의 불변 시퀀스다. "
":class:`bytes` 는 :class:`bytearray` 의 불변 버전이다 -- 같은 불변 메서드와 같은 인덱싱 및 슬라이싱 "
"동작을 갖는다."

#: ../Doc/library/functions.rst:155
msgid ""
"Accordingly, constructor arguments are interpreted as for "
":func:`bytearray`."
msgstr "따라서 생성자 인자는 :func:`bytearray` 와 같이 해석된다."

#: ../Doc/library/functions.rst:157
msgid "Bytes objects can also be created with literals, see :ref:`strings`."
msgstr "바이트열 객체는 리터럴을 사용하여 만들 수도 있다 (:ref:`strings` 참조)."

#: ../Doc/library/functions.rst:159
msgid "See also :ref:`binaryseq`, :ref:`typebytes`, and :ref:`bytes-methods`."
msgstr ":ref:`binaryseq`, :ref:`typebytes` 및 :ref:`bytes-methods` 를 참고하라."

#: ../Doc/library/functions.rst:164
msgid ""
"Return :const:`True` if the *object* argument appears callable, "
":const:`False` if not.  If this returns true, it is still possible that a"
" call fails, but if it is false, calling *object* will never succeed. "
"Note that classes are callable (calling a class returns a new instance); "
"instances are callable if their class has a :meth:`__call__` method."
msgstr ""
"*object* 인자가 콜러블인 것처럼 보이면 :const:`True` 를, 그렇지 않으면 :const:`False` 를 돌려준다. "
"이것이 참을 돌려줘도 여전히 호출이 실패할 가능성이 있지만, 거짓일 때 *object* 를 호출하면 반드시 실패한다. 클래스가 콜러블 "
"이라는 것에 유의해야 한다 (클래스를 호출하면 새 인스턴스를 돌려준다); 클래스에 :meth:`__call__` 메서드가 있으면 "
"인스턴스도 콜러블이다."

#: ../Doc/library/functions.rst:170
msgid ""
"This function was first removed in Python 3.0 and then brought back in "
"Python 3.2."
msgstr "이 함수는 파이썬 3.0에서 먼저 제거된 다음 파이썬 3.2에서 다시 도입했다."

#: ../Doc/library/functions.rst:177
msgid ""
"Return the string representing a character whose Unicode code point is "
"the integer *i*.  For example, ``chr(97)`` returns the string ``'a'``, "
"while ``chr(8364)`` returns the string ``'€'``. This is the inverse of "
":func:`ord`."
msgstr ""
"유니코드 코드 포인트가 정수 *i* 인 문자를 나타내는 문자열을 돌려준다. 예를 들어, ``chr(97)`` 은 문자열 ``'a'`` 를"
" 돌려주고, ``chr(8364)`` 는 문자열 ``'€'`` 를 돌려준다. 이 것은 :func:`ord` 의 반대다."

#: ../Doc/library/functions.rst:181
msgid ""
"The valid range for the argument is from 0 through 1,114,111 (0x10FFFF in"
" base 16).  :exc:`ValueError` will be raised if *i* is outside that "
"range."
msgstr ""
"인자의 유효 범위는 0에서 1,114,111(16진수로 0x10FFFF)까지다. *i* 가 이 범위 밖에 있을 때 "
":exc:`ValueError` 가 발생한다."

#: ../Doc/library/functions.rst:187
msgid "Transform a method into a class method."
msgstr "메서드를 클래스 메서드로 변환한다."

#: ../Doc/library/functions.rst:189
msgid ""
"A class method receives the class as implicit first argument, just like "
"an instance method receives the instance. To declare a class method, use "
"this idiom::"
msgstr ""
"인스턴스 메서드가 인스턴스를 받는 것처럼, 클래스 메서드는 클래스를 묵시적인 첫 번째 인자로 받는다. 클래스 메서드를 선언하려면 이 "
"관용구를 사용한다::"

#: ../Doc/library/functions.rst:197
msgid ""
"The ``@classmethod`` form is a function :term:`decorator` -- see the "
"description of function definitions in :ref:`function` for details."
msgstr ""
"``@classmethod`` 형식은 함수 :term:`데코레이터 <decorator>` 다 -- 자세한 내용은 "
":ref:`function` 에 있는 함수 정의에 대한 설명을 보면 된다."

#: ../Doc/library/functions.rst:200
msgid ""
"It can be called either on the class (such as ``C.f()``) or on an "
"instance (such as ``C().f()``).  The instance is ignored except for its "
"class. If a class method is called for a derived class, the derived class"
" object is passed as the implied first argument."
msgstr ""
"클래스 (``C.f()`` 처럼) 또는 인스턴스 (``C().f()`` 처럼) 를 통해 호출할 수 있다. 인스턴스는 클래스만 참조하고 "
"무시된다. 파생 클래스에 대해 클래스 메서드가 호출되면, 파생 클래스 객체가 묵시적인 첫 번째 인자로 전달된다."

#: ../Doc/library/functions.rst:205
msgid ""
"Class methods are different than C++ or Java static methods. If you want "
"those, see :func:`staticmethod` in this section."
msgstr ""
"클래스 메서드는 C++ 또는 자바의 정적 메서드와 다르다. 그것들을 원하면, 이 섹션의 :func:`staticmethod` 를 보기 "
"바란다."

#: ../Doc/library/functions.rst:208
msgid ""
"For more information on class methods, consult the documentation on the "
"standard type hierarchy in :ref:`types`."
msgstr ""
"클래스 메서드에 대한 더 자세한 정보를 원하면, :ref:`types` 에 있는 표준 형 계층에 대한 도큐멘테이션을 참고하기 바란다."

#: ../Doc/library/functions.rst:214
msgid ""
"Compile the *source* into a code or AST object.  Code objects can be "
"executed by :func:`exec` or :func:`eval`.  *source* can either be a "
"normal string, a byte string, or an AST object.  Refer to the :mod:`ast` "
"module documentation for information on how to work with AST objects."
msgstr ""
"*source* 를 코드 또는 AST 객체로 컴파일한다. 코드 객체는 :func:`exec` 또는 :func:`eval` 로 실행할 수 "
"있다. *source* 는 일반 문자열, 바이트열 또는 AST 객체 일 수 있다. AST 객체로 작업하는 방법에 대한 정보는 "
":mod:`ast` 모듈 문서를 참조하면 된다."

#: ../Doc/library/functions.rst:219
msgid ""
"The *filename* argument should give the file from which the code was "
"read; pass some recognizable value if it wasn't read from a file "
"(``'<string>'`` is commonly used)."
msgstr ""
"*filename* 인자는 코드를 읽은 파일을 제공해야 한다; 파일에서 읽지 않으면 인식 가능한 값을 전달한다 "
"(``'<string>'`` 이 일반적으로 사용된다)."

#: ../Doc/library/functions.rst:223
msgid ""
"The *mode* argument specifies what kind of code must be compiled; it can "
"be ``'exec'`` if *source* consists of a sequence of statements, "
"``'eval'`` if it consists of a single expression, or ``'single'`` if it "
"consists of a single interactive statement (in the latter case, "
"expression statements that evaluate to something other than ``None`` will"
" be printed)."
msgstr ""
"*mode* 인자는 컴파일해야 하는 코드 종류를 지정한다; *source* 가 문장의 시퀀스로 구성되어 있다면 ``exec``, 단일 "
"표현식으로 구성되어 있다면 ``'eval'``, 단일 대화형 문장으로 구성되면 ``'single'`` 이 될 수 있다 (마지막의 경우 "
"``None`` 이외의 값으로 구해지는 표현식 문은 인쇄된다)."

#: ../Doc/library/functions.rst:229
msgid ""
"The optional arguments *flags* and *dont_inherit* control which future "
"statements (see :pep:`236`) affect the compilation of *source*.  If "
"neither is present (or both are zero) the code is compiled with those "
"future statements that are in effect in the code that is calling "
":func:`compile`.  If the *flags* argument is given and *dont_inherit* is "
"not (or is zero) then the future statements specified by the *flags* "
"argument are used in addition to those that would be used anyway. If "
"*dont_inherit* is a non-zero integer then the *flags* argument is it -- "
"the future statements in effect around the call to compile are ignored."
msgstr ""
"선택적 인자 *flags* 와 *dont_inherit* 는 어떤 퓨처 문(:pep:`236` 참조)이 *source* 의 컴파일에 "
"영향을 미칠지 제어한다. 둘 다 제공되지 않는 경우 (또는 둘 다 0의 경우), 코드는 :func:`compile` 을 호출하는 코드에 "
"적용되고 있는 퓨처 문으로 컴파일된다. *flags* 인자가 주어지고, *dont_inherit* 가 없으면 (또는 0) 원래 사용될 "
"것에 더해 *flags* 인자로 지정된 퓨처 문이 사용된다. *dont_inherit* 가 0이 아닌 정수면 *flags* 인자가 "
"사용된다 -- compile을 호출하는 코드에 적용되는 퓨처 문은 무시된다."

#: ../Doc/library/functions.rst:239
msgid ""
"Future statements are specified by bits which can be bitwise ORed "
"together to specify multiple statements.  The bitfield required to "
"specify a given feature can be found as the "
":attr:`~__future__._Feature.compiler_flag` attribute on the "
":class:`~__future__._Feature` instance in the :mod:`__future__` module."
msgstr ""
"퓨처 문은 여러 개의 문장을 지정하기 위해 비트 OR 될 수 있는 비트에 의해 지정된다. 주어진 기능을 지정하는 데 필요한 비트 필드는 "
":mod:`__future__` 모듈의 :class:`~__future__._Feature` 인스턴스에서 "
":attr:`~__future__._Feature.compiler_flag` 어트리뷰트로 찾을 수 있다."

#: ../Doc/library/functions.rst:244
msgid ""
"The argument *optimize* specifies the optimization level of the compiler;"
" the default value of ``-1`` selects the optimization level of the "
"interpreter as given by :option:`-O` options.  Explicit levels are ``0`` "
"(no optimization; ``__debug__`` is true), ``1`` (asserts are removed, "
"``__debug__`` is false) or ``2`` (docstrings are removed too)."
msgstr ""
"인자 *optimize* 는 컴파일러의 최적화 수준을 지정한다; 기본값 ``-1`` 은 :option:`-O` 옵션에 의해 주어진 "
"인터프리터의 최적화 수준을 선택한다. 명시적 수준은 ``0`` (최적화 없음, ``__debug__`` 이 참이다), ``1`` "
"(assert가 제거된다, ``__debug__`` 이 거짓이다) 또는 ``2`` 다 (독스트링도 제거된다)."

#: ../Doc/library/functions.rst:250
msgid ""
"This function raises :exc:`SyntaxError` if the compiled source is "
"invalid, and :exc:`ValueError` if the source contains null bytes."
msgstr ""
"이 함수는 컴파일된 소스가 올바르지 않으면 :exc:`SyntaxError` 를 일으키고, 소스에 널 바이트가 들어있는 경우 "
":exc:`ValueError` 를 일으킨다."

#: ../Doc/library/functions.rst:253
msgid ""
"If you want to parse Python code into its AST representation, see "
":func:`ast.parse`."
msgstr "파이썬 코드를 AST 표현으로 파싱하려면, :func:`ast.parse` 를 참조하면 된다."

#: ../Doc/library/functions.rst:258
msgid ""
"When compiling a string with multi-line code in ``'single'`` or "
"``'eval'`` mode, input must be terminated by at least one newline "
"character.  This is to facilitate detection of incomplete and complete "
"statements in the :mod:`code` module."
msgstr ""
"``'single'`` 또는 ``'eval'`` mode로 여러 줄 코드를 가진 문자열을 컴파일할 때, 적어도 하나의 개행 문자로 입력을"
" 끝내야 한다. 이것은 :mod:`code` 모듈에서 문장이 불완전한지 완전한지를 쉽게 탐지하게 하기 위함이다."

#: ../Doc/library/functions.rst:263
msgid ""
"Allowed use of Windows and Mac newlines.  Also input in ``'exec'`` mode "
"does not have to end in a newline anymore.  Added the *optimize* "
"parameter."
msgstr ""
"윈도우 및 맥의 줄 바꿈을 사용할 수 있다. 또한, 이제는 ``'exec'`` mode에서 입력이 줄 넘김 문자로 끝나지 않아도 된다. "
"*optimize* 파라미터가 추가되었다."

#: ../Doc/library/functions.rst:267
msgid ""
"Previously, :exc:`TypeError` was raised when null bytes were encountered "
"in *source*."
msgstr "이전에는, *source* 에서 널 바이트가 발견될 때 :exc:`TypeError` 가 발생했다."

#: ../Doc/library/functions.rst:274
msgid ""
"Return a complex number with the value *real* + *imag*\\*1j or convert a "
"string or number to a complex number.  If the first parameter is a "
"string, it will be interpreted as a complex number and the function must "
"be called without a second parameter.  The second parameter can never be "
"a string. Each argument may be any numeric type (including complex).  If "
"*imag* is omitted, it defaults to zero and the constructor serves as a "
"numeric conversion like :class:`int` and :class:`float`.  If both "
"arguments are omitted, returns ``0j``."
msgstr ""
"*real* + *imag*\\*1j 값을 가진 복소수를 돌려주거나 문자열 또는 숫자를 복소수로 변환한다. 첫 번째 파라미터가 문자열이면"
" 복소수로 해석되며, 두 번째 파라미터 없이 함수를 호출해야 한다. 두 번째 파라미터는 결코 문자열 일 수 없다. 각 인자는 모든 "
"(복소수를 포함한) 숫자 형이 될 수 있다. *imag* 가 생략되면 기본값은 0이고, 생성자는 :class:`int` 와 "
":class:`float` 와 같은 숫자 변환으로 사용된다. 두 인자가 모두 생략되면 ``0j`` 를 돌려준다."

#: ../Doc/library/functions.rst:285
msgid ""
"When converting from a string, the string must not contain whitespace "
"around the central ``+`` or ``-`` operator.  For example, "
"``complex('1+2j')`` is fine, but ``complex('1 + 2j')`` raises "
":exc:`ValueError`."
msgstr ""
"문자열을 변환할 때, 문자열은 중앙의 ``+`` 또는 ``-`` 연산자 주위에 공백을 포함해서는 안 된다. 예를 들어, "
"``complex('1+2j')`` 는 괜찮지만 ``complex('1 + 2j')`` 는 :exc:`ValueError` 를 일으킨다."

#: ../Doc/library/functions.rst:290
msgid "The complex type is described in :ref:`typesnumeric`."
msgstr "복소수 형은 :ref:`typesnumeric` 에서 설명한다."

#: ../Doc/library/functions.rst:292 ../Doc/library/functions.rst:555
#: ../Doc/library/functions.rst:739
msgid "Grouping digits with underscores as in code literals is allowed."
msgstr "코드 리터럴 처럼 숫자를 밑줄로 그룹화할 수 있다."

#: ../Doc/library/functions.rst:298
msgid ""
"This is a relative of :func:`setattr`.  The arguments are an object and a"
" string.  The string must be the name of one of the object's attributes."
"  The function deletes the named attribute, provided the object allows "
"it.  For example, ``delattr(x, 'foobar')`` is equivalent to ``del "
"x.foobar``."
msgstr ""
"이것은 :func:`setattr` 의 친척뻘이다. 인자는 객체와 문자열이다. 문자열은 객체의 어트리뷰트 중 하나의 이름이어야 한다. 이"
" 함수는 객체가 허용하는 경우 명명된 어트리뷰트를 삭제한다. 예를 들어, ``delattr(x, 'foobar')`` 는 ``del "
"x.foobar`` 와 동등하다."

#: ../Doc/library/functions.rst:310
msgid ""
"Create a new dictionary.  The :class:`dict` object is the dictionary "
"class. See :class:`dict` and :ref:`typesmapping` for documentation about "
"this class."
msgstr ""
"새 딕셔너리를 만든다. :class:`dict` 객체는 딕셔너리 클래스다. 이 클래스에 대한 도큐멘테이션은 :class:`dict` 및 "
":ref:`typesmapping` 을 참조하면 된다."

#: ../Doc/library/functions.rst:313
msgid ""
"For other containers see the built-in :class:`list`, :class:`set`, and "
":class:`tuple` classes, as well as the :mod:`collections` module."
msgstr ""
"다른 컨테이너의 경우 :class:`list`, :class:`set` 및 :class:`tuple` 클래스와 "
":mod:`collections` 모듈을 참조하기 바란다."

#: ../Doc/library/functions.rst:319
msgid ""
"Without arguments, return the list of names in the current local scope.  "
"With an argument, attempt to return a list of valid attributes for that "
"object."
msgstr ""
"인자가 없으면, 현재 지역 스코프에 있는 이름들의 리스트를 돌려준다. 인자가 있으면, 해당 객체에 유효한 어트리뷰트들의 리스트를 "
"돌려주려고 시도한다."

#: ../Doc/library/functions.rst:322
msgid ""
"If the object has a method named :meth:`__dir__`, this method will be "
"called and must return the list of attributes. This allows objects that "
"implement a custom :func:`__getattr__` or :func:`__getattribute__` "
"function to customize the way :func:`dir` reports their attributes."
msgstr ""
"객체에 :meth:`__dir__` 메서드가 있으면, 이 메서드가 호출되는데, 반드시 어트리뷰트 리스트를 돌려줘야 한다. 이렇게 하면 "
"커스텀 :func:`__getattr__` 또는 :func:`__getattribute__` 함수를 구현하는 객체가 :func:`dir`"
" 이 어트리뷰트들을 보고하는 방법을 커스터마이즈할 수 있다."

#: ../Doc/library/functions.rst:327
msgid ""
"If the object does not provide :meth:`__dir__`, the function tries its "
"best to gather information from the object's :attr:`~object.__dict__` "
"attribute, if defined, and from its type object.  The resulting list is "
"not necessarily complete, and may be inaccurate when the object has a "
"custom :func:`__getattr__`."
msgstr ""
"객체가 :meth:`__dir__` 을 제공하지 않으면, 함수는 (정의되었다면) 객체의 :attr:`~object.__ dict__` "
"어트리뷰트와 형 객체로부터 정보를 수집하기 위해 최선을 다한다. 결과로 얻어지는 리스트는 반드시 완전하지는 않으며, 객체가 커스텀 "
":func:`__getattr__` 을 가질 때 부정확할 수도 있다."

#: ../Doc/library/functions.rst:332
msgid ""
"The default :func:`dir` mechanism behaves differently with different "
"types of objects, as it attempts to produce the most relevant, rather "
"than complete, information:"
msgstr ""
"기본 :func:`dir` 메커니즘은 다른 형의 객체에 대해서 다르게 동작하는데, 완전한 정보보다는 가장 적절한 정보를 만들려고 시도하기"
" 때문이다:"

#: ../Doc/library/functions.rst:336
msgid ""
"If the object is a module object, the list contains the names of the "
"module's attributes."
msgstr "객체가 모듈 객체면, 리스트에는 모듈 어트리뷰트의 이름이 포함된다."

#: ../Doc/library/functions.rst:339
msgid ""
"If the object is a type or class object, the list contains the names of "
"its attributes, and recursively of the attributes of its bases."
msgstr "객체가 형 또는 클래스 객체면, 리스트에는 그것의 어트리뷰트 이름과 베이스의 어트리뷰트 이름들이 재귀적으로 포함된다."

#: ../Doc/library/functions.rst:342
msgid ""
"Otherwise, the list contains the object's attributes' names, the names of"
" its class's attributes, and recursively of the attributes of its class's"
" base classes."
msgstr ""
"그 밖의 경우, 리스트에는 객체의 어트리뷰트 이름, 해당 클래스의 어트리뷰트 이름 및 해당 클래스의 베이스 클래스들의 어트리뷰트 이름을 "
"재귀적으로 포함한다."

#: ../Doc/library/functions.rst:346
msgid "The resulting list is sorted alphabetically.  For example:"
msgstr "결과 리스트는 알파벳 순으로 정렬된다. 예를 들어:"

#: ../Doc/library/functions.rst:365
msgid ""
"Because :func:`dir` is supplied primarily as a convenience for use at an "
"interactive prompt, it tries to supply an interesting set of names more "
"than it tries to supply a rigorously or consistently defined set of "
"names, and its detailed behavior may change across releases.  For "
"example, metaclass attributes are not in the result list when the "
"argument is a class."
msgstr ""
":func:`dir` 은 주로 대화형 프롬프트에서의 사용 편의를 위해 제공되기 때문에, 엄격하거나 일관되게 정의된 이름 집합을 "
"제공하기보다 흥미로운 이름 집합을 제공하려고 시도하며, 상세한 동작은 배포마다 변경될 수 있다. 예를 들어, 인자가 클래스면 메타 클래스"
" 어트리뷰트는 결과 리스트에 없다."

#: ../Doc/library/functions.rst:375
msgid ""
"Take two (non complex) numbers as arguments and return a pair of numbers "
"consisting of their quotient and remainder when using integer division.  "
"With mixed operand types, the rules for binary arithmetic operators "
"apply.  For integers, the result is the same as ``(a // b, a % b)``. For "
"floating point numbers the result is ``(q, a % b)``, where *q* is usually"
" ``math.floor(a / b)`` but may be 1 less than that.  In any case ``q * b "
"+ a % b`` is very close to *a*, if ``a % b`` is non-zero it has the same "
"sign as *b*, and ``0 <= abs(a % b) < abs(b)``."
msgstr ""
"두 개의 (복소수가 아닌) 숫자를 인자로 취하고 정수 나누기를 사용할 때의 몫과 나머지로 구성된 한 쌍의 숫자를 돌려준다. 두 인자의 "
"형이 다른 경우, 이 항 산술 연산자에 대한 규칙이 적용된다. 정수의 경우, 결과는 ``(a // b, a % b)`` 와 같다. 부동 "
"소수점 숫자의 경우 결과는 ``(q, a % b)`` 인데, *q* 는 보통 ``math.floor(a / b)`` 이지만, 이보다 "
"1작을 수 있다. 어떤 경우건 ``q * b + a % b`` 는 *a* 에 매우 가깝다. ``a % b`` 는 0이 아닐 때 *b* 와"
" 같은 부호를 가지며, ``0 <= abs(a % b) < abs(b)`` 가 성립한다."

#: ../Doc/library/functions.rst:387
msgid ""
"Return an enumerate object. *iterable* must be a sequence, an "
":term:`iterator`, or some other object which supports iteration. The "
":meth:`~iterator.__next__` method of the iterator returned by "
":func:`enumerate` returns a tuple containing a count (from *start* which "
"defaults to 0) and the values obtained from iterating over *iterable*."
msgstr ""
"열거 객체를 돌려준다. *iterable* 은 시퀀스, :term:`이터레이터 <iterator>` 또는 이터레이션을 지원하는 다른 "
"객체여야 한다. :func:`enumerate` 에 의해 반환된 이터레이터의 :meth:`~iterator.__next__` 메서드는 "
"카운트 (기본값 0을 갖는 *start* 부터)와 *iterable* 을 이터레이션 해서 얻어지는 값을 포함하는 튜플을 돌려준다."

#: ../Doc/library/functions.rst:399
msgid "Equivalent to::"
msgstr "다음과 동등하다::"

#: ../Doc/library/functions.rst:410
msgid ""
"The arguments are a string and optional globals and locals.  If provided,"
" *globals* must be a dictionary.  If provided, *locals* can be any "
"mapping object."
msgstr ""
"인자는 문자열 및 선택적 globals 및 locals다. 제공된 경우, *globals* 는 딕셔너리여야 한다. 제공되는 경우, "
"*locals* 는 모든 매핑 객체가 될 수 있다."

#: ../Doc/library/functions.rst:414
msgid ""
"The *expression* argument is parsed and evaluated as a Python expression "
"(technically speaking, a condition list) using the *globals* and *locals*"
" dictionaries as global and local namespace.  If the *globals* dictionary"
" is present and lacks '__builtins__', the current globals are copied into"
" *globals* before *expression* is parsed.  This means that *expression* "
"normally has full access to the standard :mod:`builtins` module and "
"restricted environments are propagated.  If the *locals* dictionary is "
"omitted it defaults to the *globals* dictionary.  If both dictionaries "
"are omitted, the expression is executed in the environment where "
":func:`eval` is called.  The return value is the result of the evaluated "
"expression. Syntax errors are reported as exceptions.  Example:"
msgstr ""
"*expression* 인자는 전역 및 지역 이름 공간으로 *globals* 및 *locals* 딕셔너리를 사용하여 파이썬 "
"표현식(기술적으로 말하면, 조건 목록)으로 파싱 되고 값이 구해진다. *globals* 사전이 제공되고 '__builtins__' 가 "
"없으면 *expression* 가 파싱 되기 전에 현재 전역 변수가 *globals* 에 복사된다. 이는 *expression* 이 "
"일반적으로 표준 :mod:`builtins` 모듈에 대한 모든 액세스 권한을 가지며 제한된 환경이 전파됨을 뜻한다. *locals* "
"딕셔너리를 생략하면 기본적으로 *globals* 딕셔너리가 사용된다. 두 딕셔너리가 모두 생략되면, 표현식은 :func:`eval` 이 "
"호출되는 환경에서 실행된다. 반환 값은 계산된 표현식의 결과다. 문법 에러는 예외로 보고된다. 예:"

#: ../Doc/library/functions.rst:429
msgid ""
"This function can also be used to execute arbitrary code objects (such as"
" those created by :func:`compile`).  In this case pass a code object "
"instead of a string.  If the code object has been compiled with "
"``'exec'`` as the *mode* argument, :func:`eval`\\'s return value will be "
"``None``."
msgstr ""
"이 함수는 임의의 코드 객체 (:func:`compile` 로 만든 것과 같은)를 실행하는 데에도 사용할 수 있다. 이 경우 문자열 대신"
" 코드 객체를 전달한다. 코드 객체가 mode 인자 ``'exec'`` 로 컴파일되었다면, :func:`eval` 의 반환 값은 "
"``None`` 이다."

#: ../Doc/library/functions.rst:434
msgid ""
"Hints: dynamic execution of statements is supported by the :func:`exec` "
"function.  The :func:`globals` and :func:`locals` functions returns the "
"current global and local dictionary, respectively, which may be useful to"
" pass around for use by :func:`eval` or :func:`exec`."
msgstr ""
"힌트: 문장의 동적 실행은 :func:`exec` 함수에 의해 지원된다. :func:`globals` 와 :func:`locals` "
"함수는 각각 현재의 전역과 지역 딕셔너리를 반환하는데, :func:`eval` 또는 :func:`exec` 에 전달하는 데 유용하다."

#: ../Doc/library/functions.rst:439
msgid ""
"See :func:`ast.literal_eval` for a function that can safely evaluate "
"strings with expressions containing only literals."
msgstr "리터럴 만 포함 된 표현식의 값을 안전하게 구할 수 있는 함수 :func:`ast.literal_eval` 를 보기 바란다."

#: ../Doc/library/functions.rst:446
msgid ""
"This function supports dynamic execution of Python code. *object* must be"
" either a string or a code object.  If it is a string, the string is "
"parsed as a suite of Python statements which is then executed (unless a "
"syntax error occurs). [#]_ If it is a code object, it is simply executed."
"  In all cases, the code that's executed is expected to be valid as file "
"input (see the section \"File input\" in the Reference Manual). Be aware "
"that the :keyword:`return` and :keyword:`yield` statements may not be "
"used outside of function definitions even within the context of code "
"passed to the :func:`exec` function. The return value is ``None``."
msgstr ""
"이 함수는 파이썬 코드의 동적 실행을 지원한다. *object* 는 문자열 또는 코드 객체여야 한다. 문자열이면 문자열은 파이썬 문장들의"
" 스위트로 파싱된 후 (문법 에러가 발생하지 않는 한) 실행된다. [#]_ 코드 객체면, 단순히 실행된다. 모든 경우에, 실행되는 코드는"
" 파일 입력으로 올바를 것이 기대된다 (레퍼런스 설명서의 \"파일 입력\" 섹션 참조). :keyword:`return` 과 "
":keyword:`yield` 문은 :func:`exec` 함수에 전달 된 코드 문맥 안에서조차도 함수 정의 밖에서 사용될 수 없음에 "
"유의해야 한다. 반환 값은 ``None`` 이다."

#: ../Doc/library/functions.rst:456
msgid ""
"In all cases, if the optional parts are omitted, the code is executed in "
"the current scope.  If only *globals* is provided, it must be a "
"dictionary, which will be used for both the global and the local "
"variables.  If *globals* and *locals* are given, they are used for the "
"global and local variables, respectively.  If provided, *locals* can be "
"any mapping object.  Remember that at module level, globals and locals "
"are the same dictionary. If exec gets two separate objects as *globals* "
"and *locals*, the code will be executed as if it were embedded in a class"
" definition."
msgstr ""
"모든 경우에, 선택적 부분을 생략하면, 현재 스코프에서 코드가 실행된다. *globals* 만 제공된 경우, 사전이어야 하며, 전역과 "
"지역 변수 모두에 사용된다. *globals* 및 *locals* 가 주어지면, 전역과 지역 변수에 각각 사용된다. 제공되는 경우, "
"*locals* 는 모든 매핑 객체가 될 수 있다. 모듈 수준에서, 전역과 지역은 같은 딕셔너리임을 기억해야 한다. exec 가 "
"*globals* 와 *locals* 로 별도의 객체를 받으면, 코드는 클래스 정의에 포함된 것처럼 실행된다."

#: ../Doc/library/functions.rst:465
msgid ""
"If the *globals* dictionary does not contain a value for the key "
"``__builtins__``, a reference to the dictionary of the built-in module "
":mod:`builtins` is inserted under that key.  That way you can control "
"what builtins are available to the executed code by inserting your own "
"``__builtins__`` dictionary into *globals* before passing it to "
":func:`exec`."
msgstr ""
"*globals* 딕셔너리가 ``__builtins__`` 를 키로 하는 값을 갖고 있지 않으면, 그 키로 내장 모듈 "
":mod:`builtins` 에 대한 참조가 삽입된다. 이런 식으로 :func:`exec` 에 전달하기 전에 *globals* 에 여러분"
" 자신의 ``__builtins__`` 딕셔너리를 삽입함으로써, 실행되는 코드에 어떤 내장 객체들이 제공될지를 제어할 수 있다."

#: ../Doc/library/functions.rst:473
msgid ""
"The built-in functions :func:`globals` and :func:`locals` return the "
"current global and local dictionary, respectively, which may be useful to"
" pass around for use as the second and third argument to :func:`exec`."
msgstr ""
"내장 함수 :func:`globals` 와 :func:`locals` 는 각각 현재 전역 및 지역 딕셔너리를 돌려주는데, "
":func:`exec` 로 전달되는 두 번째 및 세 번째 인자로 사용하는 데 유용하다."

#: ../Doc/library/functions.rst:479
msgid ""
"The default *locals* act as described for function :func:`locals` below: "
"modifications to the default *locals* dictionary should not be attempted."
" Pass an explicit *locals* dictionary if you need to see effects of the "
"code on *locals* after function :func:`exec` returns."
msgstr ""
"기본 *locals* 는 아래 함수 :func:`locals` 에 설명된 대로 작동한다: 기본 *locals* 사전에 대해 수정이 "
"시도되어서는 안 된다. 함수 :func:`exec` 가 돌아온 후에 *locals* 에 코드가 만든 효과를 보려면 명시적으로 "
"*locals* 딕셔너리를 전달해야 한다."

#: ../Doc/library/functions.rst:487
msgid ""
"Construct an iterator from those elements of *iterable* for which "
"*function* returns true.  *iterable* may be either a sequence, a "
"container which supports iteration, or an iterator.  If *function* is "
"``None``, the identity function is assumed, that is, all elements of "
"*iterable* that are false are removed."
msgstr ""
"*function* 이 참을 돌려주는 *iterable* 의 요소들로 이터레이터를 구축한다. *iterable* 은 시퀀스, 이터레이션을"
" 지원하는 컨테이너 또는 이터레이터 일 수 있다. *function* 이 ``None`` 이면, 항등함수가 가정된다, 즉, 거짓인 "
"*iterable* 의 모든 요소가 제거된다."

#: ../Doc/library/functions.rst:493
msgid ""
"Note that ``filter(function, iterable)`` is equivalent to the generator "
"expression ``(item for item in iterable if function(item))`` if function "
"is not ``None`` and ``(item for item in iterable if item)`` if function "
"is ``None``."
msgstr ""
"``filter(function, iterable)`` 는 function이 ``None`` 이 아닐 때 제너레이터 표현식 ``(item"
" for item in iterable if function(item))`` 과, ``None`` 일 때 ``(item for item "
"in iterable if item)`` 와 동등함에 유의하라."

#: ../Doc/library/functions.rst:498
msgid ""
"See :func:`itertools.filterfalse` for the complementary function that "
"returns elements of *iterable* for which *function* returns false."
msgstr ""
"*function* 이 거짓을 돌려주는 *iterable* 의 요소들을 돌려주는 상보적인 함수는 "
":func:`itertools.filterfalse` 를 참조하라."

#: ../Doc/library/functions.rst:508
msgid "Return a floating point number constructed from a number or string *x*."
msgstr "숫자 또는 문자열 *x* 로 부터 실수를 만들어 돌려준다."

#: ../Doc/library/functions.rst:510
msgid ""
"If the argument is a string, it should contain a decimal number, "
"optionally preceded by a sign, and optionally embedded in whitespace.  "
"The optional sign may be ``'+'`` or ``'-'``; a ``'+'`` sign has no effect"
" on the value produced.  The argument may also be a string representing a"
" NaN (not-a-number), or a positive or negative infinity.  More precisely,"
" the input must conform to the following grammar after leading and "
"trailing whitespace characters are removed:"
msgstr ""
"인수가 문자열이면, 십진수를 포함해야 하고, 선택적으로 부호가 앞에 오며 선택적으로 공백으로 둘러싸일 수 있다. 선택적 부호는 "
"``'+'`` 또는 ``'-'`` 일 수 있다; ``'+'`` 부호는 생성되는 값에 아무런 영향을 주지 않는다. 인자는 NaN (not-"
"a-number) 또는 양 또는 음의 무한대를 나타내는 문자열 일 수도 있다. 더욱 정확하게, 입력은 앞과 뒤의 공백 문자를 제거한 후 "
"다음 문법을 따라야 한다:"

#: ../Doc/library/functions.rst:525
msgid ""
"Here ``floatnumber`` is the form of a Python floating-point literal, "
"described in :ref:`floating`.  Case is not significant, so, for example, "
"\"inf\", \"Inf\", \"INFINITY\" and \"iNfINity\" are all acceptable "
"spellings for positive infinity."
msgstr ""
"여기서 ``floatnumber`` 는 :ref:`floating` 에 설명된 파이썬 실수 리터럴의 형식이다. 대/소문자는 중요하지 "
"않아서, 예를 들면, \"inf\", \"Inf\", \"INFINITY\" 및 \"iNfINity\"는 모두 양의 무한대에 대해 "
"허용되는 철자다."

#: ../Doc/library/functions.rst:530
msgid ""
"Otherwise, if the argument is an integer or a floating point number, a "
"floating point number with the same value (within Python's floating point"
" precision) is returned.  If the argument is outside the range of a "
"Python float, an :exc:`OverflowError` will be raised."
msgstr ""
"그렇지 않으면, 인자가 정수 또는 실수면 (파이썬의 부동 소수점 정밀도 내에서) 같은 값을 가진 실수가 반환된다. 인자가 파이썬 "
"float 범위를 벗어나면, :exc:`OverflowError` 가 발생한다."

#: ../Doc/library/functions.rst:535
msgid ""
"For a general Python object ``x``, ``float(x)`` delegates to "
"``x.__float__()``."
msgstr "일반적인 파이썬 객체 ``x`` 의 경우, ``float (x)`` 는 ``x .__ float __ ()`` 로 위임한다."

#: ../Doc/library/functions.rst:538
msgid "If no argument is given, ``0.0`` is returned."
msgstr "인자가 주어지지 않으면, ``0.0`` 을 돌려준다."

#: ../Doc/library/functions.rst:540
msgid "Examples::"
msgstr "예::"

#: ../Doc/library/functions.rst:553
msgid "The float type is described in :ref:`typesnumeric`."
msgstr "float 형은 :ref:`typesnumeric` 에 설명되어 있다."

#: ../Doc/library/functions.rst:565
msgid ""
"Convert a *value* to a \"formatted\" representation, as controlled by "
"*format_spec*.  The interpretation of *format_spec* will depend on the "
"type of the *value* argument, however there is a standard formatting "
"syntax that is used by most built-in types: :ref:`formatspec`."
msgstr ""
"*format_spec* 의 제어에 따라, *value* 를 \"포맷된\" 표현으로 변환한다. *format_spec* 의 해석은 "
"*value* 인자의 형에 의존하지만, 대부분의 내장형에 의해 사용되는 표준 포매팅 문법이 있다: :ref:`formatspec`."

#: ../Doc/library/functions.rst:570
msgid ""
"The default *format_spec* is an empty string which usually gives the same"
" effect as calling :func:`str(value) <str>`."
msgstr ""
"기본 *format_spec* 은 빈 문자열이며 일반적으로 :func:`str(value) <str>` 를 호출하는 것과 같은 효과를 "
"준다."

#: ../Doc/library/functions.rst:573
msgid ""
"A call to ``format(value, format_spec)`` is translated to "
"``type(value).__format__(value, format_spec)`` which bypasses the "
"instance dictionary when searching for the value's :meth:`__format__` "
"method.  A :exc:`TypeError` exception is raised if the method search "
"reaches :mod:`object` and the *format_spec* is non-empty, or if either "
"the *format_spec* or the return value are not strings."
msgstr ""
"``format(value, format_spec)`` 에 대한 호출은 ``type(value).__format__(value, "
"format_spec)`` 로 번역되는데, value의 :meth:`__format__` 메서드를 검색할 때 인스턴스 딕셔너리를 "
"건너뛴다. 메서드 검색이 :mod:`object` 에 도달하고 *format_spec* 이 비어 있지 않거나, *format_spec* "
"또는 반환 값이 문자열이 아닌 경우 :exc:`TypeError` 예외가 발생한다."

#: ../Doc/library/functions.rst:580
msgid ""
"``object().__format__(format_spec)`` raises :exc:`TypeError` if "
"*format_spec* is not an empty string."
msgstr ""
"``object().__format__(format_spec)`` 은 *format_spec* 이 빈 문자열이 아닌 경우 "
":exc:`TypeError` 를 일으킨다."

#: ../Doc/library/functions.rst:589
msgid ""
"Return a new :class:`frozenset` object, optionally with elements taken "
"from *iterable*.  ``frozenset`` is a built-in class.  See "
":class:`frozenset` and :ref:`types-set` for documentation about this "
"class."
msgstr ""
"새 :class:`frozenset` 객체를 돌려주는데, 선택적으로 *iterable* 에서 가져온 요소를 포함한다. "
"``frozenset`` 은 내장 클래스다. 이 클래스에 대한 도큐멘테이션은 :class:`frozenset` 과 :ref:`types-"
"set` 을 참조하면 된다."

#: ../Doc/library/functions.rst:593
msgid ""
"For other containers see the built-in :class:`set`, :class:`list`, "
":class:`tuple`, and :class:`dict` classes, as well as the "
":mod:`collections` module."
msgstr ""
"다른 컨테이너의 경우 :class:`set`, :class:`list`, :class:`tuple` 및 :class:`dict` 클래스와"
" :mod:`collections` 모듈을 참조하기 바란다."

#: ../Doc/library/functions.rst:600
msgid ""
"Return the value of the named attribute of *object*.  *name* must be a "
"string. If the string is the name of one of the object's attributes, the "
"result is the value of that attribute.  For example, ``getattr(x, "
"'foobar')`` is equivalent to ``x.foobar``.  If the named attribute does "
"not exist, *default* is returned if provided, otherwise "
":exc:`AttributeError` is raised."
msgstr ""
"주어진 이름의 *object* 어트리뷰트를 돌려준다. *name* 은 문자열이어야 한다. 문자열이 객체의 어트리뷰트 중 하나의 이름이면,"
" 결과는 그 어트리뷰트의 값이다. 예를 들어, ``getattr(x, 'foobar')`` 는 ``x.foobar`` 와 동등하다. "
"명명된 어트리뷰트가 없으면, *default* 가 제공되는 경우 그 값이 반환되고, 그렇지 않으면 :exc:`AttributeError`"
" 가 발생한다."

#: ../Doc/library/functions.rst:609
msgid ""
"Return a dictionary representing the current global symbol table. This is"
" always the dictionary of the current module (inside a function or "
"method, this is the module where it is defined, not the module from which"
" it is called)."
msgstr ""
"현재 전역 심볼 테이블을 나타내는 딕셔너리를 돌려준다. 이것은 항상 현재 모듈의 딕셔너리다 (함수 또는 메서드 내에서, 이 모듈은 "
"그것들을 호출하는 모듈이 아니라, 그것들이 정의된 모듈이다)."

#: ../Doc/library/functions.rst:616
msgid ""
"The arguments are an object and a string.  The result is ``True`` if the "
"string is the name of one of the object's attributes, ``False`` if not. "
"(This is implemented by calling ``getattr(object, name)`` and seeing "
"whether it raises an :exc:`AttributeError` or not.)"
msgstr ""
"인자는 객체와 문자열이다. 문자열이 객체의 속성 중 하나의 이름이면 결과는``True` 이고, 그렇지 않으면 ``False`` 가 된다."
" (이것은 ``getattr(object, name)`` 을 호출하고 :exc:`AttributeError` 를 발생시키는지를 보는 "
"식으로 구현된다.)"

#: ../Doc/library/functions.rst:624
msgid ""
"Return the hash value of the object (if it has one).  Hash values are "
"integers.  They are used to quickly compare dictionary keys during a "
"dictionary lookup.  Numeric values that compare equal have the same hash "
"value (even if they are of different types, as is the case for 1 and "
"1.0)."
msgstr ""
"객체의 해시값을 돌려준다 (해시가 있는 경우). 해시값은 정수다. 딕셔너리 조회 중에 딕셔너리 키를 빨리 비교하는 데 사용된다. 같다고 "
"비교되는 숫자 값은 같은 해시값을 갖는다 (1과 1.0의 경우와 같이 형이 다른 경우조차도 그렇다)."

#: ../Doc/library/functions.rst:631
msgid ""
"For objects with custom :meth:`__hash__` methods, note that :func:`hash` "
"truncates the return value based on the bit width of the host machine. "
"See :meth:`__hash__` for details."
msgstr ""
"커스텀 :meth:`__hash__` 메서드를 가진 객체의 경우, :func:`hash` 는 호스트 기계의 비트 폭을 기준으로 반환 값을"
" 잘라 버리는 것에 주의해야 한다. 자세한 내용은 :meth:`__hash__` 을 참조하라."

#: ../Doc/library/functions.rst:637
msgid ""
"Invoke the built-in help system.  (This function is intended for "
"interactive use.)  If no argument is given, the interactive help system "
"starts on the interpreter console.  If the argument is a string, then the"
" string is looked up as the name of a module, function, class, method, "
"keyword, or documentation topic, and a help page is printed on the "
"console.  If the argument is any other kind of object, a help page on the"
" object is generated."
msgstr ""
"내장 도움말 시스템을 호출한다. (이 함수는 대화형 사용을 위한 것이다.) 인자가 제공되지 않으면, 인터프리터 콘솔에서 대화형 도움말 "
"시스템이 시작된다. 인자가 문자열이면 문자열은 모듈, 함수, 클래스, 메서드, 키워드 또는 도큐멘테이션 주제의 이름으로 조회되고, 도움말"
" 페이지가 콘솔에 인쇄된다. 인자가 다른 종류의 객체면, 객체에 대한 도움말 페이지가 만들어진다."

#: ../Doc/library/functions.rst:644
msgid ""
"This function is added to the built-in namespace by the :mod:`site` "
"module."
msgstr "이 함수는 :mod:`site` 모듈에 의해 내장 이름 공간에 추가된다."

#: ../Doc/library/functions.rst:646
msgid ""
"Changes to :mod:`pydoc` and :mod:`inspect` mean that the reported "
"signatures for callables are now more comprehensive and consistent."
msgstr ""
":mod:`pydoc` 과 :mod:`inspect` 의 변경 사항은 콜러블의 시그니처가 이제 더 포괄적이고 일관성이 있음을 의미한다."

#: ../Doc/library/functions.rst:653
msgid ""
"Convert an integer number to a lowercase hexadecimal string prefixed with"
" \"0x\". If x is not a Python :class:`int` object, it has to define an "
"__index__() method that returns an integer. Some examples:"
msgstr ""
"정수를 \"0x\" 접두사가 붙은 소문자 16진수 문자열로 변환한다. x가 파이썬 :class:`int` 객체가 아니면, 정수를 돌려주는"
" __index __() 메서드를 정의해야 한다. 몇 가지 예:"

#: ../Doc/library/functions.rst:662
msgid ""
"If you want to convert an integer number to an uppercase or lower "
"hexadecimal string with prefix or not, you can use either of the "
"following ways:"
msgstr "정수를 대문자 또는 소문자 16진수로, 접두사가 있거나 없는 형태로 변환하려면 다음 방법의 하나를 사용할 수 있다:"

#: ../Doc/library/functions.rst:674
msgid ""
"See also :func:`int` for converting a hexadecimal string to an integer "
"using a base of 16."
msgstr "16진수 문자열을 진수 16을 사용해서 정수로 변환하려면 :func:`int` 도 참조하라."

#: ../Doc/library/functions.rst:679
msgid ""
"To obtain a hexadecimal string representation for a float, use the "
":meth:`float.hex` method."
msgstr "float에 대한 16진수 문자열 표현을 얻으려면, :meth:`float.hex` 메서드를 사용한다."

#: ../Doc/library/functions.rst:685
msgid ""
"Return the \"identity\" of an object.  This is an integer which is "
"guaranteed to be unique and constant for this object during its lifetime."
" Two objects with non-overlapping lifetimes may have the same :func:`id` "
"value."
msgstr ""
"객체의 \"아이덴티티\"를 돌려준다. 이것은 객체의 수명 동안 유일하고 바뀌지 않음이 보장되는 정수다. 수명이 겹치지 않는 두 개의 "
"객체는 같은 :func:`id` 값을 가질 수 있다."

#: ../Doc/library/functions.rst:695
msgid ""
"If the *prompt* argument is present, it is written to standard output "
"without a trailing newline.  The function then reads a line from input, "
"converts it to a string (stripping a trailing newline), and returns that."
"  When EOF is read, :exc:`EOFError` is raised.  Example::"
msgstr ""
"*prompt* 인자가 있으면, 끝에 개행 문자를 붙이지 않고 표준 출력에 쓴다. 그런 다음 함수는 입력에서 한 줄을 읽고, 문자열로 "
"변환해서 (줄 끝의 줄 바꿈 문자를 제거한다) 돌려준다. EOF를 읽으면 :exc:`EOFError` 를 일으킨다. 예::"

#: ../Doc/library/functions.rst:705
msgid ""
"If the :mod:`readline` module was loaded, then :func:`input` will use it "
"to provide elaborate line editing and history features."
msgstr ""
":mod:`readline` 모듈이 로드되었다면, :func:`input` 은 그것을 사용하여 정교한 줄 편집과 히스토리 기능을 "
"제공한다."

#: ../Doc/library/functions.rst:712
msgid ""
"Return an integer object constructed from a number or string *x*, or "
"return ``0`` if no arguments are given.  If *x* is a number, return "
":meth:`x.__int__() <object.__int__>`.  For floating point numbers, this "
"truncates towards zero."
msgstr ""
"숫자 나 문자열 *x* 로 부터 만들어진 정수 객체를 돌려준다. 인자가 주어지지 않으면 ``0`` 을 돌려준다. *x* 가 숫자면, "
":meth:`x.__int__() <object.__int__>` 를 돌려준다. 실수의 경우 이 함수는 0 향해 자른다."

#: ../Doc/library/functions.rst:717
msgid ""
"If *x* is not a number or if *base* is given, then *x* must be a string, "
":class:`bytes`, or :class:`bytearray` instance representing an "
":ref:`integer literal <integers>` in radix *base*.  Optionally, the "
"literal can be preceded by ``+`` or ``-`` (with no space in between) and "
"surrounded by whitespace.  A base-n literal consists of the digits 0 to "
"n-1, with ``a`` to ``z`` (or ``A`` to ``Z``) having values 10 to 35.  The"
" default *base* is 10. The allowed values are 0 and 2--36. Base-2, -8, "
"and -16 literals can be optionally prefixed with ``0b``/``0B``, "
"``0o``/``0O``, or ``0x``/``0X``, as with integer literals in code.  Base "
"0 means to interpret exactly as a code literal, so that the actual base "
"is 2, 8, 10, or 16, and so that ``int('010', 0)`` is not legal, while "
"``int('010')`` is, as well as ``int('010', 8)``."
msgstr ""
"*x* 가 숫자가 아니거나 *base* 가 주어지면, *x* 는 문자열, :class:`bytes`, 또는 "
":class:`bytearray` 인스턴스여야 하는데, 진수 *base* 의 :ref:`integer literal <integers>`"
" 을 나타내야 한다. 선택적으로, 리터럴은 (사이에 공백 없이) ``+`` 또는 ``-`` 를 앞에 붙일 수 있고, 앞뒤로 공백에 "
"둘러싸일 수 있다. 진수-n 리터럴은 0에서 n-1까지의 숫자로 구성되며, ``a`` 에서 ``z`` (또는 ``A`` 에서 ``Z``)"
" 가 10에서 35 사이의 값을 가진다. 기본 *base* 는 10이다. 허용되는 값은 0과 2--36이다. 코드에서의 리터럴 처럼, "
"진수-2, -8 및 -16 리터럴에는 선택적으로 ``0b``/``0B``, ``0o``/``0O`` 또는 ``0x``/``0X`` "
"접두사가 붙을 수 있다. base 0은 코드 리터럴과 똑같이 해석하라는 뜻이기 때문에, 실제 진수는 2, 8, 10 또는 16이고, "
"그래서 ``int('010', 0)`` 는 올바르지 않지만 ``int('010', 8)`` 뿐만 아니라 ``int('010')`` 도 "
"올바르다."

#: ../Doc/library/functions.rst:730
msgid "The integer type is described in :ref:`typesnumeric`."
msgstr "정수 형은 :ref:`typesnumeric` 에 설명되어 있다."

#: ../Doc/library/functions.rst:732
msgid ""
"If *base* is not an instance of :class:`int` and the *base* object has a "
":meth:`base.__index__ <object.__index__>` method, that method is called "
"to obtain an integer for the base.  Previous versions used "
":meth:`base.__int__ <object.__int__>` instead of :meth:`base.__index__ "
"<object.__index__>`."
msgstr ""
"*base* 가 :class:`int` 의 인스턴스가 아니고 *base* 객체가 :meth:`base.__index__ "
"<object.__index__>` 메서드를 가지면, 그 진수로 쓸 정수를 얻기 위해 그 메서드를 호출한다. 예전 버전에서는 "
":meth:`base.__index__ <object.__index__>` 대신에 :meth:`base.__int__ "
"<object.__int__>` 가 사용되었다."

#: ../Doc/library/functions.rst:745
msgid ""
"Return true if the *object* argument is an instance of the *classinfo* "
"argument, or of a (direct, indirect or :term:`virtual <abstract base "
"class>`) subclass thereof.  If *object* is not an object of the given "
"type, the function always returns false. If *classinfo* is a tuple of "
"type objects (or recursively, other such tuples), return true if *object*"
" is an instance of any of the types. If *classinfo* is not a type or "
"tuple of types and such tuples, a :exc:`TypeError` exception is raised."
msgstr ""
"*object* 인자가 *classinfo* 인자 또는 그것의 (직접, 간접 혹은 :term:`가상 <abstract base "
"class>`) 서브 클래스의 인스턴스면 참을 돌려준다. *object* 가 주어진 형의 객체가 아니면, 함수는 항상 거짓을 돌려준다. "
"*classinfo* 가 형 객체들의 튜플 (또는 재귀적으로 이런 종류의 튜플이 중첩된 튜플) 이면, *object* 가 그 형 중 어느"
" 하나의 인스턴스일 때 참을 돌려준다. *classinfo* 가 형이나, 형들의 튜플이나, 이런 튜플들의 튜플이 아니면, "
":exc:`TypeError` 예외를 일으킨다."

#: ../Doc/library/functions.rst:757
msgid ""
"Return true if *class* is a subclass (direct, indirect or :term:`virtual "
"<abstract base class>`) of *classinfo*.  A class is considered a subclass"
" of itself. *classinfo* may be a tuple of class objects, in which case "
"every entry in *classinfo* will be checked. In any other case, a "
":exc:`TypeError` exception is raised."
msgstr ""
"*class* 가 *classinfo* 의 서브 클래스 (직접, 간접 또는 :term:`가상 <abstract base class>`)면"
" 참을 돌려준다. 클래스는 그 자체의 서브 클래스로 간주한다. *classinfo* 는 클래스 객체의 튜플 일 수 있다. 이 경우 "
"*classinfo* 의 모든 항목이 검사된다. 다른 모든 경우에는, :exc:`TypeError` 예외가 발생한다."

#: ../Doc/library/functions.rst:766
msgid ""
"Return an :term:`iterator` object.  The first argument is interpreted "
"very differently depending on the presence of the second argument. "
"Without a second argument, *object* must be a collection object which "
"supports the iteration protocol (the :meth:`__iter__` method), or it must"
" support the sequence protocol (the :meth:`__getitem__` method with "
"integer arguments starting at ``0``).  If it does not support either of "
"those protocols, :exc:`TypeError` is raised. If the second argument, "
"*sentinel*, is given, then *object* must be a callable object.  The "
"iterator created in this case will call *object* with no arguments for "
"each call to its :meth:`~iterator.__next__` method; if the value returned"
" is equal to *sentinel*, :exc:`StopIteration` will be raised, otherwise "
"the value will be returned."
msgstr ""
":term:`이터레이터 <iterator>` 객체를 돌려준다. 첫 번째 인자는 두 번째 인자의 존재 여부에 따라 매우 다르게 해석된다. "
"두 번째 인자가 없으면, *object* 는 이터레이션 프로토콜 (:meth:`__iter__` 메서드)을 지원하는 컬렉션 객체이거나 "
"시퀀스 프로토콜 (0에서 시작하는 정수 인자를 받는 :meth:`__getitem__` 메서드)을 지원해야 한다. 이러한 프로토콜 중 "
"아무것도 지원하지 않으면 :exc:`TypeError` 가 일어난다. 두 번째 인자 *sentinel* 이 주어지면, *object* 는"
" 콜러블이어야 한다. 이 경우 만들어지는 이터레이터는 :meth:`~iterator.__next__` 메서드가 호출될 때마다 인자 없이 "
"*object* 를 호출한다; 반환된 값이 *sentinel* 과 같으면, :exc:`StopIteration` 을 일으키고, 그렇지 "
"않으면 값을 돌려준다."

#: ../Doc/library/functions.rst:779
msgid "See also :ref:`typeiter`."
msgstr ":ref:`typeiter` 도 참조하라."

#: ../Doc/library/functions.rst:781
msgid ""
"One useful application of the second form of :func:`iter` is to read "
"lines of a file until a certain line is reached.  The following example "
"reads a file until the :meth:`~io.TextIOBase.readline` method returns an "
"empty string::"
msgstr ""
"두 번째 형태의 :func:`iter` 의 유용한 응용은 특정 줄에 도달할 때까지 파일의 줄을 읽는 것이다. 다음의 예는 "
":meth:`~io.TextIOBase.readline` 메서드가 빈 문자열을 돌려줄 때까지 파일을 읽는다::"

#: ../Doc/library/functions.rst:792
msgid ""
"Return the length (the number of items) of an object.  The argument may "
"be a sequence (such as a string, bytes, tuple, list, or range) or a "
"collection (such as a dictionary, set, or frozen set)."
msgstr ""
"객체의 길이 (항목 수)를 돌려준다. 인자는 시퀀스 (문자열, 바이트열, 튜플, 리스트 또는 range 같은) 또는 컬렉션 (딕셔너리, "
"집합 또는 불변 집합 같은) 일 수 있다."

#: ../Doc/library/functions.rst:801
msgid ""
"Rather than being a function, :class:`list` is actually a mutable "
"sequence type, as documented in :ref:`typesseq-list` and :ref:`typesseq`."
msgstr ""
"함수이기보다, :ref:`typesseq-list` 와 :ref:`typesseq` 에 문서화 된 것처럼, :class:`list` 는 "
"실제로는 가변 시퀀스 형이다."

#: ../Doc/library/functions.rst:807
msgid ""
"Update and return a dictionary representing the current local symbol "
"table. Free variables are returned by :func:`locals` when it is called in"
" function blocks, but not in class blocks."
msgstr ""
"현재 지역 심볼 테이블을 나타내는 딕셔너리를 갱신하고 돌려준다. :func:`locals` 이 함수 블록에서 호출될 때 자유 변수를 "
"돌려주지만, 클래스 블록에서 호출할 때는 그렇지 않다."

#: ../Doc/library/functions.rst:812
msgid ""
"The contents of this dictionary should not be modified; changes may not "
"affect the values of local and free variables used by the interpreter."
msgstr ""
"이 딕셔너리의 내용은 수정해서는 안 된다. 변경 사항은 인터프리터가 사용하는 지역 및 자유 변수의 값에 영향을 미치지 않을 수 있다."

#: ../Doc/library/functions.rst:817
msgid ""
"Return an iterator that applies *function* to every item of *iterable*, "
"yielding the results.  If additional *iterable* arguments are passed, "
"*function* must take that many arguments and is applied to the items from"
" all iterables in parallel.  With multiple iterables, the iterator stops "
"when the shortest iterable is exhausted.  For cases where the function "
"inputs are already arranged into argument tuples, see "
":func:`itertools.starmap`\\."
msgstr ""
"*iterable* 의 모든 항목에 *function* 을 적용한 후 그 결과를 돌려주는 이터레이터를 돌려준다. 추가 *iterable*"
" 인자가 전달되면, *function* 은 그 수 만큼의 인자를 받아들여야 하고 모든 이터러블에서 병렬로 제공되는 항목들에 적용된다. "
"다중 이터러블의 경우, 이터레이터는 가장 짧은 이터러블이 모두 소모되면 멈춘다. 함수 입력이 이미 인자 튜플로 배치된 경우에는, "
":func:`itertools.starmap` 를 참조한다."

#: ../Doc/library/functions.rst:828
msgid ""
"Return the largest item in an iterable or the largest of two or more "
"arguments."
msgstr "iterable 에서 가장 큰 항목이나 두 개 이상의 인자 중 가장 큰 것을 돌려준다."

#: ../Doc/library/functions.rst:831
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`."
" The largest item in the iterable is returned.  If two or more positional"
" arguments are provided, the largest of the positional arguments is "
"returned."
msgstr ""
"하나의 위치 인자가 제공되면, 그것은 :term:`이터러블 <iterable>` 이어야 한다. iterable에서 가장 큰 항목을 "
"돌려준다. 두 개 이상의 위치 인자가 제공되면, 위치 인자 중 가장 큰 것을 돌려준다."

#: ../Doc/library/functions.rst:836 ../Doc/library/functions.rst:870
msgid ""
"There are two optional keyword-only arguments. The *key* argument "
"specifies a one-argument ordering function like that used for "
":meth:`list.sort`. The *default* argument specifies an object to return "
"if the provided iterable is empty. If the iterable is empty and *default*"
" is not provided, a :exc:`ValueError` is raised."
msgstr ""
"선택적 키워드-전용 인자가 두 개 있다. *key* 인자는 :meth:`list.sort` 에 사용되는 것처럼 단일 인자 순서 함수를 "
"지정한다. *default* 인자는 제공된 iterable이 비어있는 경우 돌려줄 객체를 지정한다. iterable이 비어 있고 "
"*default* 가 제공되지 않으면 :exc:`ValueError` 가 발생한다."

#: ../Doc/library/functions.rst:842
msgid ""
"If multiple items are maximal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving "
"tools such as ``sorted(iterable, key=keyfunc, reverse=True)[0]`` and "
"``heapq.nlargest(1, iterable, key=keyfunc)``."
msgstr ""
"여러 항목이 최댓값이면, 함수는 처음 만난 항목을 돌려준다. 이것은 ``sorted(iterable, key=keyfunc, "
"reverse=True)[0]`` 와 ``heapq.nlargest(1, iterable, key=keyfunc)`` 같은 다른 정렬 "
"안정성 보존 도구와 일관성을 유지한다."

#: ../Doc/library/functions.rst:847 ../Doc/library/functions.rst:881
msgid "The *default* keyword-only argument."
msgstr "*default* 키워드-전용 인자."

#: ../Doc/library/functions.rst:855
msgid ""
"Return a \"memory view\" object created from the given argument.  See "
":ref:`typememoryview` for more information."
msgstr ""
"지정된 인자로부터 만들어진 \"메모리 뷰\" 객체를 돌려준다. 자세한 정보는 :ref:`typememoryview` 를 보기 바란다."

#: ../Doc/library/functions.rst:862
msgid ""
"Return the smallest item in an iterable or the smallest of two or more "
"arguments."
msgstr "iterable 에서 가장 작은 항목이나 두 개 이상의 인자 중 가장 작은 것을 돌려준다."

#: ../Doc/library/functions.rst:865
msgid ""
"If one positional argument is provided, it should be an :term:`iterable`."
" The smallest item in the iterable is returned.  If two or more "
"positional arguments are provided, the smallest of the positional "
"arguments is returned."
msgstr ""
"하나의 위치 인자가 제공되면, 그것은 :term:`이터러블 <iterable>` 이어야 한다. iterable에서 가장 작은 항목을 "
"돌려준다. 두 개 이상의 위치 인자가 제공되면, 위치 인자 중 가장 작은 것을 돌려준다."

#: ../Doc/library/functions.rst:876
msgid ""
"If multiple items are minimal, the function returns the first one "
"encountered.  This is consistent with other sort-stability preserving "
"tools such as ``sorted(iterable, key=keyfunc)[0]`` and "
"``heapq.nsmallest(1, iterable, key=keyfunc)``."
msgstr ""
"여러 항목이 최솟값이면, 함수는 처음 만난 항목을 돌려준다. 이것은 ``sorted(iterable, key=keyfunc)[0]`` 와"
" ``heapq.nsmallest(1, iterable, key=keyfunc)`` 같은 다른 정렬 안정성 보존 도구와 일관성을 "
"유지한다."

#: ../Doc/library/functions.rst:887
msgid ""
"Retrieve the next item from the *iterator* by calling its "
":meth:`~iterator.__next__` method.  If *default* is given, it is returned"
" if the iterator is exhausted, otherwise :exc:`StopIteration` is raised."
msgstr ""
":meth:`~iterator.__next__` 메서드를 호출하여 *iterator* 에서 다음 항목을 꺼낸다. *default* 가 "
"주어지면, iterator가 고갈될 때 돌려주고, 그렇지 않으면 :exc:`StopIteration` 을 일으킨다."

#: ../Doc/library/functions.rst:894
msgid ""
"Return a new featureless object.  :class:`object` is a base for all "
"classes. It has the methods that are common to all instances of Python "
"classes.  This function does not accept any arguments."
msgstr ""
"새 기능 없는 객체를 돌려준다. :class:`object` 는 모든 클래스의 베이스 클래스다. 모든 파이썬 클래스의 인스턴스에 공통적인"
" 메서드를 가지고 있다. 이 함수는 인자를 받아들이지 않는다."

#: ../Doc/library/functions.rst:900
msgid ""
":class:`object` does *not* have a :attr:`~object.__dict__`, so you can't "
"assign arbitrary attributes to an instance of the :class:`object` class."
msgstr ""
":class:`object` 는 :attr:`~object.__dict__` 을 가지지 *않는다*. 그래서, :class:`object`"
" 클래스의 인스턴스에 임의의 어트리뷰트를 대입할 수 없다."

#: ../Doc/library/functions.rst:906
msgid ""
"Convert an integer number to an octal string prefixed with \"0o\".  The "
"result is a valid Python expression. If *x* is not a Python :class:`int` "
"object, it has to define an :meth:`__index__` method that returns an "
"integer. For example:"
msgstr ""
"정수를 \"0o\"로 시작하는 8진수 문자열로 변환한다. 결과는 올바른 파이썬 표현식이다. *x* 가 파이썬 :class:`int` "
"객체가 아니면, 정수를 돌려주는 :meth:`__index__` 메서드를 정의해야 한다. 예를 들어:"

#: ../Doc/library/functions.rst:916
msgid ""
"If you want to convert an integer number to octal string either with "
"prefix \"0o\" or not, you can use either of the following ways."
msgstr "정수를 접두사 \"0o\"가 있거나 없는 형태의 8진수 문자열로 변환하려면, 다음 방법의 하나를 사용할 수 있다."

#: ../Doc/library/functions.rst:933
msgid ""
"Open *file* and return a corresponding :term:`file object`.  If the file "
"cannot be opened, an :exc:`OSError` is raised."
msgstr ""
"*file* 을 열고 해당 :term:`파일 객체 <file object>` 를 돌려준다. 파일을 열 수 없으면, "
":exc:`OSError` 가 발생한다."

#: ../Doc/library/functions.rst:936
msgid ""
"*file* is a :term:`path-like object` giving the pathname (absolute or "
"relative to the current working directory) of the file to be opened or an"
" integer file descriptor of the file to be wrapped.  (If a file "
"descriptor is given, it is closed when the returned I/O object is closed,"
" unless *closefd* is set to ``False``.)"
msgstr ""
"*file* 은 열 파일의 경로명(절대 혹은 현재 작업 디렉터리에 상대적인)을 주는 :term:`경로류 객체 <path-like "
"object>` 거나, 감쌀 파일의 정수 파일 디스크립터다. (파일 디스크립터가 주어지면, *closefd* 가 ``False`` 가 "
"아닌 한, 반환된 I/O 객체가 닫힐 때 닫힌다.)"

#: ../Doc/library/functions.rst:942
msgid ""
"*mode* is an optional string that specifies the mode in which the file is"
" opened.  It defaults to ``'r'`` which means open for reading in text "
"mode. Other common values are ``'w'`` for writing (truncating the file if"
" it already exists), ``'x'`` for exclusive creation and ``'a'`` for "
"appending (which on *some* Unix systems, means that *all* writes append "
"to the end of the file regardless of the current seek position).  In text"
" mode, if *encoding* is not specified the encoding used is platform "
"dependent: ``locale.getpreferredencoding(False)`` is called to get the "
"current locale encoding. (For reading and writing raw bytes use binary "
"mode and leave *encoding* unspecified.)  The available modes are:"
msgstr ""
"*mode* 는 파일이 열리는 모드를 지정하는 선택적 문자열이다. 기본값은 ``'r'`` 인데, 텍스트 모드로 읽기 위해 여는 것을 "
"뜻한다. 다른 일반적인 값은 쓰기 위한 ``'w'`` (파일이 이미 존재하는 경우 파일을 자른다), 독점적 파일 만들기를 위한 "
"``'x'`` 및 덧붙이기를 위한 ``'a'`` (*일부* 유닉스 시스템에서, 현재 위치와 관계없이 *모든* 쓰기가 파일의 끝에 "
"덧붙여짐을 뜻한다) 다. 텍스트 모드에서, *encoding* 을 지정하지 않으면 사용되는 인코딩은 플랫폼에 따라 다르다: 현재 로케일 "
"인코딩을 얻기 위해 ``locale.getpreferredencoding(False)`` 가 호출된다. (날 바이트열을 읽고 쓰려면 "
"바이너리 모드를 사용하고 *encoding* 을 지정하지 않는다.) 사용 가능한 모드는 다음과 같다:"

#: ../Doc/library/functions.rst:954
msgid "Character"
msgstr "문자"

#: ../Doc/library/functions.rst:954
msgid "Meaning"
msgstr "의미"

#: ../Doc/library/functions.rst:956
msgid "``'r'``"
msgstr "``'r'``"

#: ../Doc/library/functions.rst:956
msgid "open for reading (default)"
msgstr "읽기용으로 연다 (기본값)"

#: ../Doc/library/functions.rst:957
msgid "``'w'``"
msgstr "``'w'``"

#: ../Doc/library/functions.rst:957
msgid "open for writing, truncating the file first"
msgstr "쓰기용으로 연다, 파일을 먼저 자른다."

#: ../Doc/library/functions.rst:958
msgid "``'x'``"
msgstr "``'x'``"

#: ../Doc/library/functions.rst:958
msgid "open for exclusive creation, failing if the file already exists"
msgstr "독점적인 파일 만들기용으로 연다, 이미 존재하는 경우에는 실패한다."

#: ../Doc/library/functions.rst:959
msgid "``'a'``"
msgstr "``'a'``"

#: ../Doc/library/functions.rst:959
msgid "open for writing, appending to the end of the file if it exists"
msgstr "쓰기용으로 연다, 파일이 존재하는 경우는 파일의 끝에 덧붙인다"

#: ../Doc/library/functions.rst:960
msgid "``'b'``"
msgstr "``'b'``"

#: ../Doc/library/functions.rst:960
msgid "binary mode"
msgstr "바이너리 모드"

#: ../Doc/library/functions.rst:961
msgid "``'t'``"
msgstr "``'t'``"

#: ../Doc/library/functions.rst:961
msgid "text mode (default)"
msgstr "텍스트 모드 (기본값)"

#: ../Doc/library/functions.rst:962
msgid "``'+'``"
msgstr "``'+'``"

#: ../Doc/library/functions.rst:962
msgid "open a disk file for updating (reading and writing)"
msgstr "갱신(읽기 및 쓰기)용으로 디스크 파일을 연다"

#: ../Doc/library/functions.rst:963
msgid "``'U'``"
msgstr "``'U'``"

#: ../Doc/library/functions.rst:963
msgid ":term:`universal newlines` mode (deprecated)"
msgstr ":term:`유니버설 줄 넘김 <universal newlines>` 모드 (디프리케이트 되었다)"

#: ../Doc/library/functions.rst:966
msgid ""
"The default mode is ``'r'`` (open for reading text, synonym of ``'rt'``)."
" For binary read-write access, the mode ``'w+b'`` opens and truncates the"
" file to 0 bytes.  ``'r+b'`` opens the file without truncation."
msgstr ""
"기본 모드는 ``'r'`` 이다 (텍스트를 읽는 용으로 연다, ``'rt'`` 의 동의어). 바이너리 읽기-쓰기 액세스의 경우는, 모드 "
"``'w+b'`` 는 파일을 열면서 0바이트로 자른다. ``'r+b'`` 는 자르지 않고 파일을 연다."

#: ../Doc/library/functions.rst:970
msgid ""
"As mentioned in the :ref:`io-overview`, Python distinguishes between "
"binary and text I/O.  Files opened in binary mode (including ``'b'`` in "
"the *mode* argument) return contents as :class:`bytes` objects without "
"any decoding.  In text mode (the default, or when ``'t'`` is included in "
"the *mode* argument), the contents of the file are returned as "
":class:`str`, the bytes having been first decoded using a platform-"
"dependent encoding or using the specified *encoding* if given."
msgstr ""
":ref:`io-overview` 에서 언급했듯이, 파이썬은 바이너리와 텍스트 I/O를 구별한다. 바이너리 모드 (*mode* 인자에 "
"``'b'`` 를 포함한다)로 열린 파일은 내용을 디코딩 없이 :class:`bytes` 객체로 돌려준다. 텍스트 모드 (기본값, 또는 "
"*mode* 인자에 ``'t'`` 가 포함될 때)에서는, 파일의 내용이 :class:`str` 로 반환되는데, 바이트 열이 플랫폼 "
"의존적인 인코딩이나 주어진 *encoding* 을 사용해서 먼저 디코드 된다."

#: ../Doc/library/functions.rst:980
msgid ""
"Python doesn't depend on the underlying operating system's notion of text"
" files; all the processing is done by Python itself, and is therefore "
"platform-independent."
msgstr ""
"파이썬은 하위 운영 체제의 텍스트 파일 개념에 의존하지 않는다. 모든 처리는 파이썬 자체에 의해 수행되므로 플랫폼에 독립적이다."

#: ../Doc/library/functions.rst:984
msgid ""
"*buffering* is an optional integer used to set the buffering policy.  "
"Pass 0 to switch buffering off (only allowed in binary mode), 1 to select"
" line buffering (only usable in text mode), and an integer > 1 to "
"indicate the size in bytes of a fixed-size chunk buffer.  When no "
"*buffering* argument is given, the default buffering policy works as "
"follows:"
msgstr ""
"*buffering* 은 버퍼링 정책을 설정하는 데 사용되는 선택적 정수다. 버퍼링을 끄려면 (바이너리 모드에서만 허용) 0을 전달하고,"
" 줄 버퍼링 (텍스트 모드에서만 사용 가능)을 선택하려면 1을, 고정 크기 청크 버퍼를 선택하려면 그 크기를 바이트 단위로 표시한 정수 "
"> 1을 전달한다. *buffering* 인자가 제공되지 않을 때, 기본 버퍼링 정책은 다음과 같이 작동한다:"

#: ../Doc/library/functions.rst:990
msgid ""
"Binary files are buffered in fixed-size chunks; the size of the buffer is"
" chosen using a heuristic trying to determine the underlying device's "
"\"block size\" and falling back on :attr:`io.DEFAULT_BUFFER_SIZE`.  On "
"many systems, the buffer will typically be 4096 or 8192 bytes long."
msgstr ""
"바이너리 파일은 고정 크기 청크로 버퍼링 된다. 버퍼의 크기는 하부 장치의 \"블록 크기\"를 파악하려고 시도하는 경험적인 방법을 "
"사용해서 선택되고 :attr:`io.DEFAULT_BUFFER_SIZE` 으로 폴백된다. 많은 시스템에서, 버퍼는 일반적으로 4096 "
"또는 8192바이트 길이다."

#: ../Doc/library/functions.rst:995
msgid ""
"\"Interactive\" text files (files for which :meth:`~io.IOBase.isatty` "
"returns ``True``) use line buffering.  Other text files use the policy "
"described above for binary files."
msgstr ""
"\"대화형\" 텍스트 파일 (:meth:`~io.IOBase.isatty` 가 ``True`` 를 돌려주는 파일)은 줄 버퍼링을 "
"사용한다. 다른 텍스트 파일은 바이너리 파일에 대해 위에서 설명한 정책을 사용한다."

#: ../Doc/library/functions.rst:999
msgid ""
"*encoding* is the name of the encoding used to decode or encode the file."
" This should only be used in text mode.  The default encoding is platform"
" dependent (whatever :func:`locale.getpreferredencoding` returns), but "
"any :term:`text encoding` supported by Python can be used.  See the "
":mod:`codecs` module for the list of supported encodings."
msgstr ""
"*encoding* 은 파일을 디코딩하거나 인코딩하는 데 사용되는 인코딩의 이름이다. 텍스트 모드에서만 사용해야 한다. 기본 인코딩은 "
"플랫폼에 따라 다르지만 (:func:`locale.getpreferredencoding` 이 돌려주는 값), 파이썬에서 지원하는 "
":term:`텍스트 인코딩 <text encoding>` 은 모두 사용할 수 있다. 지원되는 인코딩 목록은 :mod:`codecs` "
"모듈을 보면 된다."

#: ../Doc/library/functions.rst:1006
msgid ""
"*errors* is an optional string that specifies how encoding and decoding "
"errors are to be handled—this cannot be used in binary mode. A variety of"
" standard error handlers are available (listed under :ref:`error-"
"handlers`), though any error handling name that has been registered with "
":func:`codecs.register_error` is also valid.  The standard names include:"
msgstr ""
"*errors* 는 인코딩 및 디코딩 에러를 처리하는 방법을 지정하는 선택적 문자열이다. 바이너리 모드에서는 사용할 수 없다. 다양한 "
"표준 에러 처리기가 제공된다 (:ref:`error-handlers` 에 나열된다). 하지만, "
":func:`codecs.register_error` 로 등록된 에러 처리기 이름 역시 사용할 수 있다. 표준 이름은 다음과 같다:"

#: ../Doc/library/functions.rst:1014
msgid ""
"``'strict'`` to raise a :exc:`ValueError` exception if there is an "
"encoding error.  The default value of ``None`` has the same effect."
msgstr ""
"``'strict'`` 는 인코딩 에러가 있는 경우 :exc:`ValueError` 예외를 발생시킨다. 기본값 ``None`` 은 같은 "
"효과를 낸다."

#: ../Doc/library/functions.rst:1018
msgid ""
"``'ignore'`` ignores errors.  Note that ignoring encoding errors can lead"
" to data loss."
msgstr "``'ignore'`` 는 에러를 무시한다. 인코딩 에러를 무시하면 데이터가 손실될 수 있음에 주의해야 한다."

#: ../Doc/library/functions.rst:1021
msgid ""
"``'replace'`` causes a replacement marker (such as ``'?'``) to be "
"inserted where there is malformed data."
msgstr "``'replace'`` 는 잘못된 데이터가 있는 자리에 대체 마커(``'?'`` 와 같은)를 삽입한다."

#: ../Doc/library/functions.rst:1024
msgid ""
"``'surrogateescape'`` will represent any incorrect bytes as code points "
"in the Unicode Private Use Area ranging from U+DC80 to U+DCFF.  These "
"private code points will then be turned back into the same bytes when the"
" ``surrogateescape`` error handler is used when writing data.  This is "
"useful for processing files in an unknown encoding."
msgstr ""
"``'surrogateescape'`` 는 U+DC80에서 U+DCFF까지의 유니코드 개인 사용 영역의 코드 포인트로 잘못된 바이트를 "
"나타낸다. 데이터를 쓸 때 ``surrogateescape`` 에러 처리기가 사용되면, 이 개인 코드 포인트들은 원래의 바이트로 "
"되돌아간다. 알 수 없는 인코딩의 파일을 처리할 때 유용하다."

#: ../Doc/library/functions.rst:1031
msgid ""
"``'xmlcharrefreplace'`` is only supported when writing to a file. "
"Characters not supported by the encoding are replaced with the "
"appropriate XML character reference ``&#nnn;``."
msgstr ""
"``'xmlcharrefreplace'`` 는 파일에 쓸 때만 지원된다. 인코딩이 지원하지 않는 문자는 적절한 XML 문자 참조 "
"``&#nnn;`` 로 대체된다."

#: ../Doc/library/functions.rst:1035
msgid ""
"``'backslashreplace'`` replaces malformed data by Python's backslashed "
"escape sequences."
msgstr "``'backslashreplace'`` 는 잘못된 데이터를 파이썬의 역 슬래시 이스케이프 시퀀스로 대체한다."

#: ../Doc/library/functions.rst:1038
msgid ""
"``'namereplace'`` (also only supported when writing) replaces unsupported"
" characters with ``\\N{...}`` escape sequences."
msgstr ""
"``'namereplace'`` (역시 파일에 쓸 때만 지원된다)는 지원되지 않는 문자를 ``\\N{...}`` 이스케이프 시퀀스로 "
"대체한다."

#: ../Doc/library/functions.rst:1044
msgid ""
"*newline* controls how :term:`universal newlines` mode works (it only "
"applies to text mode).  It can be ``None``, ``''``, ``'\\n'``, ``'\\r'``,"
" and ``'\\r\\n'``.  It works as follows:"
msgstr ""
"*newline* 은 :term:`유니버설 줄 넘김 <universal newlines>` 모드가 작동하는 방식을 제어한다 (텍스트 "
"모드에만 적용된다). ``None``, ``''``, ``'\\n'``, ``'\\r'`` 및 `` ``'\\r\\n'`` 일 수 있다."
" 다음과 같이 작동한다:"

#: ../Doc/library/functions.rst:1048
msgid ""
"When reading input from the stream, if *newline* is ``None``, universal "
"newlines mode is enabled.  Lines in the input can end in ``'\\n'``, "
"``'\\r'``, or ``'\\r\\n'``, and these are translated into ``'\\n'`` "
"before being returned to the caller.  If it is ``''``, universal newlines"
" mode is enabled, but line endings are returned to the caller "
"untranslated.  If it has any of the other legal values, input lines are "
"only terminated by the given string, and the line ending is returned to "
"the caller untranslated."
msgstr ""
"스트림에서 입력을 읽을 때, *newline* 이 ``None`` 이면, 유니버설 줄 넘김 모드가 활성화된다. 입력에 있는 줄은 "
"``'\\n'``, ``'\\r'`` 또는 ``'\\r\\n'`` 로 끝날 수 있으며, 호출자에게 돌려주기 전에 모두 ``'\\n'`` "
"로 변환된다. 그것이 ``''`` 이면, 유니버설 줄 넘김 모드가 활성화되지만, 줄 끝은 변환되지 않은 채로 호출자에게 반환된다. 다른 "
"유효한 값이면, 입력 줄은 주어진 문자열로만 끝나며, 줄 끝은 변환되지 않은 채로 호출자에게 돌려준다."

#: ../Doc/library/functions.rst:1056
msgid ""
"When writing output to the stream, if *newline* is ``None``, any "
"``'\\n'`` characters written are translated to the system default line "
"separator, :data:`os.linesep`.  If *newline* is ``''`` or ``'\\n'``, no "
"translation takes place.  If *newline* is any of the other legal values, "
"any ``'\\n'`` characters written are translated to the given string."
msgstr ""
"스트림에 출력을 쓸 때, *newline* 이 ``None`` 이면, 모든 ``'\\n'`` 문자는 시스템 기본 줄 구분자인 "
":data:`os.linesep` 로 변환된다. *newline* 이 ``''`` 또는 ``'\\n'`` 이면, 변환이 이루어지지 "
"않는다. *newline* 이 다른 유효한 값이면, 쓰이는 모든 ``'\\n'`` 문자는 주어진 문자열로 변환된다."

#: ../Doc/library/functions.rst:1062
msgid ""
"If *closefd* is ``False`` and a file descriptor rather than a filename "
"was given, the underlying file descriptor will be kept open when the file"
" is closed.  If a filename is given *closefd* must be ``True`` (the "
"default) otherwise an error will be raised."
msgstr ""
"*closefd* 가 ``False`` 이고 파일명 대신 파일 디스크립터가 주어지면, 파일이 닫힐 때 하위 파일 디스크립터가 열려있게 "
"된다. 파일명이 주어지면 *closefd* 는 ``True`` (기본값) 여야 한다. 그렇지 않으면 에러가 발생한다."

#: ../Doc/library/functions.rst:1067
msgid ""
"A custom opener can be used by passing a callable as *opener*. The "
"underlying file descriptor for the file object is then obtained by "
"calling *opener* with (*file*, *flags*). *opener* must return an open "
"file descriptor (passing :mod:`os.open` as *opener* results in "
"functionality similar to passing ``None``)."
msgstr ""
"콜러블을 *opener* 로 전달하여 커스텀 오프너를 사용할 수 있다. 파일 객체를 위한 하위 파일 디스크립터는 *opener* 를 "
"(*file*, *flags*) 로 호출해서 얻는다. *opener* 는 열린 파일 디스크립터를 반환해야 한다 (*opener* 에 "
":mod:`os.open` 을 전달하는 것은 ``None`` 을 전달하는 것과 비슷한 기능을 수행하게 된다)."

#: ../Doc/library/functions.rst:1073
msgid "The newly created file is :ref:`non-inheritable <fd_inheritance>`."
msgstr "새로 만들어진 파일은 :ref:`상속 불가능 <fd_inheritance>` 하다."

#: ../Doc/library/functions.rst:1075
msgid ""
"The following example uses the :ref:`dir_fd <dir_fd>` parameter of the "
":func:`os.open` function to open a file relative to a given directory::"
msgstr ""
"다음 예는 주어진 디렉터리에 상대적인 파일을 열기 위해 :func:`os.open` 함수의 :ref:`dir_fd <dir_fd>` "
"파라미터를 사용한다::"

#: ../Doc/library/functions.rst:1088
msgid ""
"The type of :term:`file object` returned by the :func:`open` function "
"depends on the mode.  When :func:`open` is used to open a file in a text "
"mode (``'w'``, ``'r'``, ``'wt'``, ``'rt'``, etc.), it returns a subclass "
"of :class:`io.TextIOBase` (specifically :class:`io.TextIOWrapper`).  When"
" used to open a file in a binary mode with buffering, the returned class "
"is a subclass of :class:`io.BufferedIOBase`.  The exact class varies: in "
"read binary mode, it returns an :class:`io.BufferedReader`; in write "
"binary and append binary modes, it returns an :class:`io.BufferedWriter`,"
" and in read/write mode, it returns an :class:`io.BufferedRandom`.  When "
"buffering is disabled, the raw stream, a subclass of "
":class:`io.RawIOBase`, :class:`io.FileIO`, is returned."
msgstr ""
":func:`open` 함수에 의해 반환된 :term:`파일 객체 <file object>` 의 형은 모드에 의존한다. "
":func:`open` 이 텍스트 모드(``'w'``, ``'r'``, ``'wt'``, ``'rt'``, 등)로 파일을 여는 데 "
"사용되면, :class:`io.TextIOBase` 의 서브 클래스를 돌려준다 (구체적으로 "
":class:`io.TextIOWrapper`). 버퍼링과 함께 바이너리 모드로 파일을 여는 데 사용되는 경우, 반환되는 클래스는 "
":class:`io.BufferedIOBase` 의 서브 클래스다. 정확한 클래스는 다양하다: 읽기 바이너리 모드에서는, "
":class:`io.BufferedReader` 를 돌려준다; 쓰기 바이너리와 덧붙이기 바이너리 모드에서는, "
":class:`io.BufferedWriter` 를 돌려주고, 읽기/쓰기 모드에서는, :class:`io.BufferedRandom` 을"
" 돌려준다. 버퍼링을 끄면, 날 스트림, :class:`io.RawIOBase` 의 서브 클래스, :class:`io.FileIO`, 을"
" 돌려준다."

#: ../Doc/library/functions.rst:1109
msgid ""
"See also the file handling modules, such as, :mod:`fileinput`, :mod:`io` "
"(where :func:`open` is declared), :mod:`os`, :mod:`os.path`, "
":mod:`tempfile`, and :mod:`shutil`."
msgstr ""
":mod:`fileinput`, :mod:`io` (:func:`open` 이 선언된 곳), :mod:`os`, "
":mod:`os.path`, :mod:`tempfile`, 그리고 :mod:`shutil` 와 같은 파일 처리 모듈들도 보기 바란다."

#: ../Doc/library/functions.rst:1116
msgid "The *opener* parameter was added."
msgstr "*opener* 파라미터가 추가되었다."

#: ../Doc/library/functions.rst:1117
msgid "The ``'x'`` mode was added."
msgstr "``'x'`` 모드가 추가되었다."

#: ../Doc/library/functions.rst:1118
msgid ":exc:`IOError` used to be raised, it is now an alias of :exc:`OSError`."
msgstr ":exc:`IOError` 를 일으켜왔다. 이제는 :exc:`OSError` 의 별칭이다."

#: ../Doc/library/functions.rst:1119
msgid ""
":exc:`FileExistsError` is now raised if the file opened in exclusive "
"creation mode (``'x'``) already exists."
msgstr ""
"독점적 파일 만들기 모드(``'x'``)로 여는 파일이 이미 존재하면, 이제 :exc:`FileExistsError` 를 일으킨다."

#: ../Doc/library/functions.rst:1125
msgid "The file is now non-inheritable."
msgstr "파일은 이제 상속 불가능하다."

msgid ""
"Deprecated since version 3.4, will be removed in version 4.0: The 'U' "
"mode."
msgstr "버전 3.4에서 디프리케이트되었다, 버전 4.0에서 제거된다: 'U' 모드."

#: ../Doc/library/functions.rst:1129
msgid "The ``'U'`` mode."
msgstr "``'U'`` 모드."

#: ../Doc/library/functions.rst:1134
msgid ""
"If the system call is interrupted and the signal handler does not raise "
"an exception, the function now retries the system call instead of raising"
" an :exc:`InterruptedError` exception (see :pep:`475` for the rationale)."
msgstr ""
"시스템 호출이 인터럽트 되고 시그널 처리기가 예외를 발생시키지 않으면, 이 함수는 이제 :exc:`InterruptedError` 예외를"
" 일으키는 대신 시스템 호출을 재시도한다 (이유는 :pep:`475` 참조)."

#: ../Doc/library/functions.rst:1137
msgid "The ``'namereplace'`` error handler was added."
msgstr "``'namereplace'`` 오류 처리기가 추가되었다."

#: ../Doc/library/functions.rst:1142
msgid "Support added to accept objects implementing :class:`os.PathLike`."
msgstr ":class:`os.PathLike` 를 구현하는 객체를 받아들이도록 지원이 추가되었다."

#: ../Doc/library/functions.rst:1143
msgid ""
"On Windows, opening a console buffer may return a subclass of "
":class:`io.RawIOBase` other than :class:`io.FileIO`."
msgstr ""
"윈도우에서, 콘솔 버퍼를 열면 :class:`io.FileIO` 가 아닌 :class:`io.RawIOBase` 의 서브 클래스가 반환될"
" 수 있다."

#: ../Doc/library/functions.rst:1148
msgid ""
"Given a string representing one Unicode character, return an integer "
"representing the Unicode code point of that character.  For example, "
"``ord('a')`` returns the integer ``97`` and ``ord('€')`` (Euro sign) "
"returns ``8364``.  This is the inverse of :func:`chr`."
msgstr ""
"하나의 유니코드 문자를 나타내는 문자열이 주어지면 해당 문자의 유니코드 코드 포인트를 나타내는 정수를 돌려준다. 예를 들어, "
"``ord('a')`` 는 정수 ``97`` 을 반환하고 ``ord('€')`` (유로 기호)는 ``8364`` 를 반환한다. 이것은 "
":func:`chr` 의 반대다."

#: ../Doc/library/functions.rst:1156
msgid ""
"Return *x* to the power *y*; if *z* is present, return *x* to the power "
"*y*, modulo *z* (computed more efficiently than ``pow(x, y) % z``). The "
"two-argument form ``pow(x, y)`` is equivalent to using the power "
"operator: ``x**y``."
msgstr ""
"*x* 의 *y* 거듭제곱을 돌려준다; *z* 가 있는 경우, *x* 의 *y* 거듭제곱의 모듈로 *z* 를 돌려준다 (``pow(x, "
"y) % z`` 보다 더 빠르게 계산된다). 두 개의 인자 형식인 ``pow (x, y)`` 는 거듭제곱 연산자를 사용하는 것과 "
"동등하다: ``x ** y``."

#: ../Doc/library/functions.rst:1160
msgid ""
"The arguments must have numeric types.  With mixed operand types, the "
"coercion rules for binary arithmetic operators apply.  For :class:`int` "
"operands, the result has the same type as the operands (after coercion) "
"unless the second argument is negative; in that case, all arguments are "
"converted to float and a float result is delivered.  For example, "
"``10**2`` returns ``100``, but ``10**-2`` returns ``0.01``.  If the "
"second argument is negative, the third argument must be omitted.  If *z* "
"is present, *x* and *y* must be of integer types, and *y* must be non-"
"negative."
msgstr ""
"인자는 숫자 형이어야 한다. 피연산자들의 형이 다를 경우, 이 항 산술 연산자에 대한 코어션 규칙이 적용된다. :class:`int` "
"피연산자들의 경우, 결과는 두 번째 인자가 음수가 아닌 한 피연산자와 같은 형 (코어션 후에)이 된다; 두 번째 인자가 음수면 모든 "
"인자가 float로 변환되고 float 결과가 전달된다. 예를 들어, ``10**2`` 는 ``100`` 을 반환하지만, "
"``10**-2``는 ``0.01`` 을 반환한다. 두 번째 인자가 음수면 세 번째 인수는 생략해야 한다. *z* 가 있는 경우, *x*"
" 및 *y* 는 정수형이어야 하고, *y* 는 음수가 아니어야 한다."

#: ../Doc/library/functions.rst:1172
msgid ""
"Print *objects* to the text stream *file*, separated by *sep* and "
"followed by *end*.  *sep*, *end*, *file* and *flush*, if present, must be"
" given as keyword arguments."
msgstr ""
"*objects* 를 텍스트 스트림 *file* 로 인쇄하는데, *sep* 로 구분되고 *end* 를 뒤에 붙인다. 있다면, *sep*,"
" *end*, *file* 및 *flush* 는 반드시 키워드 인자로 제공해야 한다."

#: ../Doc/library/functions.rst:1176
msgid ""
"All non-keyword arguments are converted to strings like :func:`str` does "
"and written to the stream, separated by *sep* and followed by *end*.  "
"Both *sep* and *end* must be strings; they can also be ``None``, which "
"means to use the default values.  If no *objects* are given, "
":func:`print` will just write *end*."
msgstr ""
"모든 비 키워드 인자는 :func:`str` 이 하듯이 문자열로 변환된 후 스트림에 쓰이는데, *sep* 로 구분되고 *end* 를 뒤에"
" 붙인다. *sep* 과 *end* 는 모두 문자열이어야 한다; ``None`` 일 수도 있는데, 기본값을 사용한다는 뜻이다. "
"*objects* 가 주어지지 않으면 :func:`print` 는 *end* 만 쓴다."

#: ../Doc/library/functions.rst:1182
msgid ""
"The *file* argument must be an object with a ``write(string)`` method; if"
" it is not present or ``None``, :data:`sys.stdout` will be used.  Since "
"printed arguments are converted to text strings, :func:`print` cannot be "
"used with binary mode file objects.  For these, use ``file.write(...)`` "
"instead."
msgstr ""
"*file* 인자는 ``write(string)`` 메서드를 가진 객체여야 한다; 존재하지 않거나 ``None`` 이면, "
":data:`sys.stdout` 이 사용된다. 인쇄된 인자는 텍스트 문자열로 변환되기 때문에, :func:`print` 는 바이너리 "
"모드 파일 객체와 함께 사용할 수 없다. 이를 위해서는. 대신 ``file.write(...)`` 를 사용한다."

#: ../Doc/library/functions.rst:1187
msgid ""
"Whether output is buffered is usually determined by *file*, but if the "
"*flush* keyword argument is true, the stream is forcibly flushed."
msgstr ""
"출력의 버퍼링 여부는 일반적으로 *file* 에 의해 결정되지만, *flush* 키워드 인자가 참이면 스트림이 강제로 플러시 된다."

#: ../Doc/library/functions.rst:1190
msgid "Added the *flush* keyword argument."
msgstr "*flush* 키워드 인자가 추가되었다."

#: ../Doc/library/functions.rst:1196
msgid "Return a property attribute."
msgstr "프로퍼티 어트리뷰트를 돌려준다."

#: ../Doc/library/functions.rst:1198
msgid ""
"*fget* is a function for getting an attribute value.  *fset* is a "
"function for setting an attribute value. *fdel* is a function for "
"deleting an attribute value.  And *doc* creates a docstring for the "
"attribute."
msgstr ""
"*fget* 은 어트리뷰트 값을 얻는 함수다. *fset* 은 어트리뷰트 값을 설정하는 함수다. *fdel* 은 어트리뷰트 값을 삭제하는"
" 함수다. 그리고 *doc* 은 어트리뷰트의 독스트링을 만든다."

#: ../Doc/library/functions.rst:1202
msgid "A typical use is to define a managed attribute ``x``::"
msgstr "전형적인 사용은 관리되는 어트리뷰트 ``x`` 를 정의하는 것이다::"

#: ../Doc/library/functions.rst:1219
msgid ""
"If *c* is an instance of *C*, ``c.x`` will invoke the getter, ``c.x = "
"value`` will invoke the setter and ``del c.x`` the deleter."
msgstr ""
"*c* 가 *C* 의 인스턴스면, ``c.x`` 는 게터(getter)를 호출하고, ``cx = value`` 는 세터(setter)를 "
"호출하고, ``del c.x`` 는 딜리터(deleter)를 호출한다."

#: ../Doc/library/functions.rst:1222
msgid ""
"If given, *doc* will be the docstring of the property attribute. "
"Otherwise, the property will copy *fget*'s docstring (if it exists).  "
"This makes it possible to create read-only properties easily using "
":func:`property` as a :term:`decorator`::"
msgstr ""
"주어진 경우, *doc* 은 프로퍼티 어트리뷰트의 독스트링이 된다. 그렇지 않으면, *fget* 의 독스트링(있는 경우)이 복사된다. "
"이렇게 하면 :func:`property` 를 :term:`데코레이터 <decorator>` 로 사용하여 읽기 전용 프로퍼티를 쉽게 만들"
" 수 있다::"

#: ../Doc/library/functions.rst:1235
msgid ""
"The ``@property`` decorator turns the :meth:`voltage` method into a "
"\"getter\" for a read-only attribute with the same name, and it sets the "
"docstring for *voltage* to \"Get the current voltage.\""
msgstr ""
"``@property`` 데코레이터는 :meth:`voltage` 메서드를 같은 이름의 읽기 전용 어트리뷰트에 대한 \"게터\"로 "
"바꾸고, *voltage* 에 대한 독스트링을 \"Get the current voltage.\" 로 설정한다."

#: ../Doc/library/functions.rst:1239
msgid ""
"A property object has :attr:`~property.getter`, :attr:`~property.setter`,"
" and :attr:`~property.deleter` methods usable as decorators that create a"
" copy of the property with the corresponding accessor function set to the"
" decorated function.  This is best explained with an example::"
msgstr ""
"프로퍼티 객체는 데코레이터로 사용할 수 있는 :attr:`~property.getter`, :attr:`~property.setter` "
"및 :attr:`~property.deleter` 메서드를 갖는데, 해당 접근자 함수를 데코레이트 된 함수로 설정한 프로퍼티의 사본을 "
"만든다. 이것은 예제로 가장 잘 설명된다::"

#: ../Doc/library/functions.rst:1261
msgid ""
"This code is exactly equivalent to the first example.  Be sure to give "
"the additional functions the same name as the original property (``x`` in"
" this case.)"
msgstr ""
"이 코드는 첫 번째 예제와 정확히 동등하다. 추가적인 함수들에 원래 프로퍼티(이 경우 ``x``)와 같은 이름을 사용해야 한다."

#: ../Doc/library/functions.rst:1265
msgid ""
"The returned property object also has the attributes ``fget``, ``fset``, "
"and ``fdel`` corresponding to the constructor arguments."
msgstr "반환된 프로퍼티 객체는 생성자 인자에 해당하는 ``fget``, ``fset`` 및 ``fdel`` 어트리뷰트를 가진다."

#: ../Doc/library/functions.rst:1268
msgid "The docstrings of property objects are now writeable."
msgstr "이제 프로퍼티 개체의 독스트링이 쓰기 가능하다."

#: ../Doc/library/functions.rst:1277
msgid ""
"Rather than being a function, :class:`range` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-range` and "
":ref:`typesseq`."
msgstr ""
"함수라기보다, :class:`range` 는 실제로는 :ref:`typesseq-range` 와 :ref:`typesseq` 에 설명된 "
"대로 불변 시퀀스 형이다."

#: ../Doc/library/functions.rst:1283
msgid ""
"Return a string containing a printable representation of an object.  For "
"many types, this function makes an attempt to return a string that would "
"yield an object with the same value when passed to :func:`eval`, "
"otherwise the representation is a string enclosed in angle brackets that "
"contains the name of the type of the object together with additional "
"information often including the name and address of the object.  A class "
"can control what this function returns for its instances by defining a "
":meth:`__repr__` method."
msgstr ""
"객체의 인쇄 가능한 표현을 포함한 문자열을 돌려준다. 많은 형에서, 이 함수는 :func:`eval` 에 전달 될 때 같은 값을 가진 "
"객체를 생성하는 문자열을 반환하려고 시도한다, 그렇지 않으면 표현은 객체의 형의 이름과 종종 객체의 이름과 주소를 포함하는 추가의 정보를"
" 화살괄호로 묶은 문자열이다. 클래스는 :meth:`__repr__` 메서드를 정의하여 이 함수가 인스턴스에 대해 돌려주는 것을 제어할 "
"수 있다."

#: ../Doc/library/functions.rst:1294
msgid ""
"Return a reverse :term:`iterator`.  *seq* must be an object which has a "
":meth:`__reversed__` method or supports the sequence protocol (the "
":meth:`__len__` method and the :meth:`__getitem__` method with integer "
"arguments starting at ``0``)."
msgstr ""
"역 :term:`이터레이터 <iterator>` 를 돌려준다. *seq* 는 :meth:`__reversed__` 메서드를 가졌거나 "
"시퀀스 프로토콜(:meth:`__len__` 메서드와 ``0`` 에서 시작하는 정수 인자를 받는 :meth:`__getitem__` "
"메서드)을 지원하는 객체여야 한다."

#: ../Doc/library/functions.rst:1302
msgid ""
"Return *number* rounded to *ndigits* precision after the decimal point.  "
"If *ndigits* is omitted or is ``None``, it returns the nearest integer to"
" its input."
msgstr ""
"*number* 를 소수점 다음에 *ndigits* 정밀도로 반올림한 값을 돌려준다. *ndigits* 가 생략되거나 ``None`` "
"이면, 입력에 가장 가까운 정수를 돌려준다."

#: ../Doc/library/functions.rst:1306
msgid ""
"For the built-in types supporting :func:`round`, values are rounded to "
"the closest multiple of 10 to the power minus *ndigits*; if two multiples"
" are equally close, rounding is done toward the even choice (so, for "
"example, both ``round(0.5)`` and ``round(-0.5)`` are ``0``, and "
"``round(1.5)`` is ``2``).  Any integer value is valid for *ndigits* "
"(positive, zero, or negative).  The return value is an integer if called "
"with one argument, otherwise of the same type as *number*."
msgstr ""
":func:`round` 를 지원하는 내장형의 경우, 값은 10의 *-ndigits* 거듭제곱의 가장 가까운 배수로 반올림된다; 두 "
"배수가 똑같이 가깝다면, 반올림은 짝수를 선택한다 (예를 들어, ``round(0.5)`` 와 ``round(-0.5)`` 는 모두 "
"``0`` 이고, ``round(1.5)`` 는 ``2`` 다). 모든 정숫값은 *ndigits* 에 유효하다 (양수, 0 또는 음수)."
" 하나의 인자로 호출되면 반환 값은 정수이고, 그렇지 않으면 *number* 와 같은 형이다."

#: ../Doc/library/functions.rst:1314
msgid ""
"For a general Python object ``number``, ``round(number, ndigits)`` "
"delegates to ``number.__round__(ndigits)``."
msgstr ""
"일반적인 파이썬 객체 ``number`` 의 경우, ``round(number, ndigits)`` 는 "
"``number.__round__(ndigits)`` 에 위임한다."

#: ../Doc/library/functions.rst:1319
msgid ""
"The behavior of :func:`round` for floats can be surprising: for example, "
"``round(2.675, 2)`` gives ``2.67`` instead of the expected ``2.68``. This"
" is not a bug: it's a result of the fact that most decimal fractions "
"can't be represented exactly as a float.  See :ref:`tut-fp-issues` for "
"more information."
msgstr ""
"float에 대한 :func:`round` 의 동작은 예상과 다를 수 있다: 예를 들어, ``round(2.675, 2)`` 는 "
"``2.68`` 대신에 ``2.67`` 을 제공한다. 이것은 버그가 아니다: 대부분의 십진 소수가 float로 정확히 표현될 수 없다는 "
"사실로부터 오는 결과다. 자세한 정보는 :ref:`tut-fp-issues` 를 보기 바란다."

#: ../Doc/library/functions.rst:1330
msgid ""
"Return a new :class:`set` object, optionally with elements taken from "
"*iterable*.  ``set`` is a built-in class.  See :class:`set` and :ref"
":`types-set` for documentation about this class."
msgstr ""
"새 :class:`set` 객체를 돌려준다. 선택적으로 *iterable* 에서 가져온 요소를 갖는다. ``set`` 은 내장 클래스다."
" 이 클래스에 대한 도큐멘테이션은 :class:`set` 및 :ref:`types-set` 을 보기 바란다."

#: ../Doc/library/functions.rst:1334
msgid ""
"For other containers see the built-in :class:`frozenset`, :class:`list`, "
":class:`tuple`, and :class:`dict` classes, as well as the "
":mod:`collections` module."
msgstr ""
"다른 컨테이너의 경우 내장 :class:`frozenset`, :class:`list`, :class:`tuple` 및 "
":class:`dict` 클래스와 :mod:`collections` 모듈을 참조하라."

#: ../Doc/library/functions.rst:1341
msgid ""
"This is the counterpart of :func:`getattr`.  The arguments are an object,"
" a string and an arbitrary value.  The string may name an existing "
"attribute or a new attribute.  The function assigns the value to the "
"attribute, provided the object allows it.  For example, ``setattr(x, "
"'foobar', 123)`` is equivalent to ``x.foobar = 123``."
msgstr ""
"이것은 :func:`getattr` 과 한 쌍이다. 인자는 객체, 문자열 및 임의의 값이다. 문자열은 기존 어트리뷰트 또는 새 "
"어트리뷰트의 이름을 지정할 수 있다. 이 함수는 객체가 허용하는 경우 값을 어트리뷰트에 대입한다. 예를 들어, ``setattr(x, "
"'foobar', 123)`` 는 ``x.foobar = 123`` 과 동등하다."

#: ../Doc/library/functions.rst:1353
msgid ""
"Return a :term:`slice` object representing the set of indices specified "
"by ``range(start, stop, step)``.  The *start* and *step* arguments "
"default to ``None``.  Slice objects have read-only data attributes "
":attr:`~slice.start`, :attr:`~slice.stop` and :attr:`~slice.step` which "
"merely return the argument values (or their default).  They have no other"
" explicit functionality; however they are used by Numerical Python and "
"other third party extensions. Slice objects are also generated when "
"extended indexing syntax is used.  For example: ``a[start:stop:step]`` or"
" ``a[start:stop, i]``.  See :func:`itertools.islice` for an alternate "
"version that returns an iterator."
msgstr ""
"``range(start, stop, step)`` 에 의해 지정된 인덱스 세트를 나타내는 :term:`슬라이스 <slice>` 객체를 "
"돌려준다. *start* 및 *step* 인자의 기본값은 ``None`` 이다. 슬라이스 객체는 단지 인자 값 (또는 기본값)을 돌려주는"
" :attr:`~slice.start`, :attr:`~slice.stop` 및 :attr:`~slice.step` 의 읽기 전용 데이터"
" 어트리뷰트를 갖는다. 다른 명시적 기능은 없다; 그러나 Numerical Python과 다른 제삼자 확장이 사용한다. 슬라이스 객체는 "
"확장 인덱싱 문법을 사용할 때도 만들어진다. 예를 들어: ``a[start:stop:step]`` 또는 ``a[start:stop, "
"i]``. 이터레이터를 돌려주는 대안 버전은 :func:`itertools.islice` 를 보라."

#: ../Doc/library/functions.rst:1366
msgid "Return a new sorted list from the items in *iterable*."
msgstr "*iterable* 의 항목들로 새 정렬된 리스트를 돌려준다."

#: ../Doc/library/functions.rst:1368
msgid "Has two optional arguments which must be specified as keyword arguments."
msgstr "키워드 인자로만 지정해야 하는 두 개의 선택적 인자가 있다."

#: ../Doc/library/functions.rst:1370
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element: ``key=str.lower``.  The default "
"value is ``None`` (compare the elements directly)."
msgstr ""
"*key* 는 하나의 인자를 받는 함수를 지정하는데, 각 리스트 요소들로부터 비교 키를 추출하는 데 사용된다: ``key = "
"str.lower``. 기본값은 ``None`` 이다 (요소를 직접 비교한다)."

#: ../Doc/library/functions.rst:1374
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements"
" are sorted as if each comparison were reversed."
msgstr "*reverse* 는 논리값이다. ``True`` 로 설정되면, 각 비교가 뒤집힌 것처럼 리스트 요소들이 정렬된다."

#: ../Doc/library/functions.rst:1377
msgid ""
"Use :func:`functools.cmp_to_key` to convert an old-style *cmp* function "
"to a *key* function."
msgstr ""
"예전 스타일의 *cmp* 함수를 *key* 함수로 변환하려면 :func:`functools.cmp_to_key` 를 사용한다."

#: ../Doc/library/functions.rst:1380
msgid ""
"The built-in :func:`sorted` function is guaranteed to be stable. A sort "
"is stable if it guarantees not to change the relative order of elements "
"that compare equal --- this is helpful for sorting in multiple passes "
"(for example, sort by department, then by salary grade)."
msgstr ""
"내장 :func:`sorted` 함수는 안정적(stable)임이 보장된다. 정렬은 같다고 비교되는 요소의 상대적 순서를 변경하지 않으면 "
"안정적이다 --- 이는 여러 번 정렬할 때 유용하다 (예를 들어, 부서별로 정렬한 후에 급여 등급별로 정렬하기)."

#: ../Doc/library/functions.rst:1385
msgid ""
"For sorting examples and a brief sorting tutorial, see "
":ref:`sortinghowto`."
msgstr "정렬 예제와 간단한 정렬 자습서는 :ref:`sortinghowto` 를 참조하라."

#: ../Doc/library/functions.rst:1389
msgid "Transform a method into a static method."
msgstr "메서드를 정적 메서드로 변환한다."

#: ../Doc/library/functions.rst:1391
msgid ""
"A static method does not receive an implicit first argument. To declare a"
" static method, use this idiom::"
msgstr "정적 메서드는 묵시적인 첫 번째 인자를 받지 않는다. 정적 메서드를 선언하려면, 이 관용구를 사용한다::"

#: ../Doc/library/functions.rst:1398
msgid ""
"The ``@staticmethod`` form is a function :term:`decorator` -- see the "
"description of function definitions in :ref:`function` for details."
msgstr ""
"``@staticmethod`` 형식은 함수 :term:`데코레이터 <decorator>` 다 -- 자세한 내용은 "
":ref:`function` 의 함수 정의에 대한 설명을 보면 된다."

#: ../Doc/library/functions.rst:1401
msgid ""
"It can be called either on the class (such as ``C.f()``) or on an "
"instance (such as ``C().f()``).  The instance is ignored except for its "
"class."
msgstr ""
"클래스 (``C.f()`` 처럼) 또는 인스턴스 (``C().f()`` 처럼)에 대해 호출할 수 있다. 인스턴스는 해당 클래스만 참조하고"
" 무시한다."

#: ../Doc/library/functions.rst:1404
msgid ""
"Static methods in Python are similar to those found in Java or C++. Also "
"see :func:`classmethod` for a variant that is useful for creating "
"alternate class constructors."
msgstr ""
"파이썬의 정적 메서드는 자바 또는 C++ 에서 발견되는 정적 메서드와 비슷하다. 대체 클래스 생성자를 만드는 데 유용한 변형을 보려면 "
":func:`classmethod` 도 참조하라."

#: ../Doc/library/functions.rst:1408
msgid ""
"Like all decorators, it is also possible to call ``staticmethod`` as a "
"regular function and do something with its result.  This is needed in "
"some cases where you need a reference to a function from a class body and"
" you want to avoid the automatic transformation to instance method.  For "
"these cases, use this idiom:"
msgstr ""
"모든 데코레이터와 마찬가지로, ``staticmethod`` 를 정규 함수로 호출하여 그 결과로 어떤 일을 할 수도 있다. 이것은 클래스"
" 바디에서 함수에 대한 참조가 필요하고 인스턴스 메서드로 자동 변환되는 것을 피하고자 할 때 필요하다. 이 경우 다음 관용구를 사용한다:"

#: ../Doc/library/functions.rst:1415
msgid "class C:"
msgstr "class C:"

#: ../Doc/library/functions.rst:1415
msgid "builtin_open = staticmethod(open)"
msgstr "builtin_open = staticmethod(open)"

#: ../Doc/library/functions.rst:1417
msgid ""
"For more information on static methods, consult the documentation on the "
"standard type hierarchy in :ref:`types`."
msgstr "정적 메서드에 대한 더 자세한 정보는, :ref:`types` 에 있는 표준 타입 계층에 대한 도큐멘테이션을 참조하라."

#: ../Doc/library/functions.rst:1429
msgid "Return a :class:`str` version of *object*.  See :func:`str` for details."
msgstr "*object* 의 :class:`str` 버전을 돌려준다. 자세한 내용은 :func:`str` 을 참조하라."

#: ../Doc/library/functions.rst:1431
msgid ""
"``str`` is the built-in string :term:`class`.  For general information "
"about strings, see :ref:`textseq`."
msgstr ""
"``str`` 은 내장 문자열 :term:`클래스 <class>` 다. 문자열에 대한 일반적인 정보는 :ref:`textseq` 를 "
"참조하라."

#: ../Doc/library/functions.rst:1437
msgid ""
"Sums *start* and the items of an *iterable* from left to right and "
"returns the total.  *start* defaults to ``0``. The *iterable*'s items are"
" normally numbers, and the start value is not allowed to be a string."
msgstr ""
"*start* 및 *iterable* 의 항목들을 왼쪽에서 오른쪽으로 합하고 합계를 돌려준다. *start* 의 기본값은 ``0`` "
"이다. *iterable* 의 항목은 일반적으로 숫자며 시작 값은 문자열이 될 수 없다."

#: ../Doc/library/functions.rst:1441
msgid ""
"For some use cases, there are good alternatives to :func:`sum`. The "
"preferred, fast way to concatenate a sequence of strings is by calling "
"``''.join(sequence)``.  To add floating point values with extended "
"precision, see :func:`math.fsum`\\.  To concatenate a series of "
"iterables, consider using :func:`itertools.chain`."
msgstr ""
"어떤 경우에는 :func:`sum` 에 대한 좋은 대안이 있다. 문자열의 시퀀스를 연결하는 가장 선호되고 빠른 방법은 "
"``''.join(sequence)`` 를 호출하는 것이다. 확장된 정밀도로 부동 소수점 값을 더하려면 :func:`math.fsum` "
"를 참조하라. 일련의 이터러블들을 연결하려면 :func:`itertools.chain` 를 고려해보라."

#: ../Doc/library/functions.rst:1449
msgid ""
"Return a proxy object that delegates method calls to a parent or sibling "
"class of *type*.  This is useful for accessing inherited methods that "
"have been overridden in a class. The search order is same as that used by"
" :func:`getattr` except that the *type* itself is skipped."
msgstr ""
"메서드 호출을 *type* 의 부모나 형제 클래스에 위임하는 프락시 객체를 돌려준다. 이는 클래스에서 재정의된 상속 된 메서드를 액세스할"
" 때 유용하다. 검색 순서는 *type* 자체를 건너뛰는 것을 제외하면, :func:`getattr` 에 의해 사용된 순서와 같다."

#: ../Doc/library/functions.rst:1454
msgid ""
"The :attr:`~class.__mro__` attribute of the *type* lists the method "
"resolution search order used by both :func:`getattr` and :func:`super`.  "
"The attribute is dynamic and can change whenever the inheritance "
"hierarchy is updated."
msgstr ""
"*type* 의 :attr:`~class .__ mro__` 어트리뷰트는 메서드 결정 검색 순서를 나열하는데 :func:`getattr`"
" 과 :func:`super` 에서 사용된다. 이 어트리뷰트는 동적이며 상속 계층 구조가 변경될 때마다 바뀔 수 있다."

#: ../Doc/library/functions.rst:1459
msgid ""
"If the second argument is omitted, the super object returned is unbound."
"  If the second argument is an object, ``isinstance(obj, type)`` must be "
"true.  If the second argument is a type, ``issubclass(type2, type)`` must"
" be true (this is useful for classmethods)."
msgstr ""
"두 번째 인자가 생략되면, 반환되는 슈퍼 객체는 연결되지 않았다(unbound). 두 번째 인자가 객체면, "
"``isinstance(obj, type)`` 는 참이어야 한다. 두 번째 인자가 형이면, ``issubclass(type2, "
"type)`` 는 참이어야 한다 (이것은 클래스 메서드에 유용하다)."

#: ../Doc/library/functions.rst:1464
msgid ""
"There are two typical use cases for *super*.  In a class hierarchy with "
"single inheritance, *super* can be used to refer to parent classes "
"without naming them explicitly, thus making the code more maintainable.  "
"This use closely parallels the use of *super* in other programming "
"languages."
msgstr ""
"*super* 에는 두 가지 일반적인 사용 사례가 있다. 단일 상속 클래스 계층 구조에서는, *super* 를 사용하여 명시적으로 이름을"
" 지정하지 않고 부모 클래스를 참조할 수 있으므로, 코드를 더 유지 관리하기 쉽게 만들 수 있다. 이 사용은 다른 프로그래밍 언어에서 "
"*super* 를 쓰는 것과 매우 유사하다."

#: ../Doc/library/functions.rst:1469
msgid ""
"The second use case is to support cooperative multiple inheritance in a "
"dynamic execution environment.  This use case is unique to Python and is "
"not found in statically compiled languages or languages that only support"
" single inheritance.  This makes it possible to implement \"diamond "
"diagrams\" where multiple base classes implement the same method.  Good "
"design dictates that this method have the same calling signature in every"
" case (because the order of calls is determined at runtime, because that "
"order adapts to changes in the class hierarchy, and because that order "
"can include sibling classes that are unknown prior to runtime)."
msgstr ""
"두 번째 사용 사례는 동적 실행 환경에서 협력적 다중 상속을 지원하는 것이다. 이 사례는 파이썬에 고유하며 정적으로 컴파일되는 언어 또는"
" 단일 상속만 지원하는 언어에서는 찾을 수 없다. 이것은 여러 베이스 클래스가 같은 메서드를 구현하는 \"다이아몬드 다이어그램\"을 "
"구현할 수 있게 한다. 좋은 설계는 모든 경우에 이 메서드가 같은 호출 시그니처를 갖도록 하는 것이다 (호출 순서는 실행 시간에 결정되기"
" 때문에, 그 순서가 클래스 계층 구조의 변경에 적응하기 때문에, 그리고 그 순서가 실행 시간 전에 미리 알려지지 않은 형제 클래스를 "
"포함할 수 있으므로)."

#: ../Doc/library/functions.rst:1479
msgid "For both use cases, a typical superclass call looks like this::"
msgstr "두 경우 모두, 일반적인 슈퍼 클래스 호출은 이런 식이다::"

#: ../Doc/library/functions.rst:1486
msgid ""
"Note that :func:`super` is implemented as part of the binding process for"
" explicit dotted attribute lookups such as ``super().__getitem__(name)``."
" It does so by implementing its own :meth:`__getattribute__` method for "
"searching classes in a predictable order that supports cooperative "
"multiple inheritance. Accordingly, :func:`super` is undefined for "
"implicit lookups using statements or operators such as ``super()[name]``."
msgstr ""
":func:`super` 는 ``super().__getitem__(name)`` 과 같은 명시적인 점으로 구분된 어트리뷰트 조회를 위한"
" 연결 절차의 일부로 구현됨에 주의해야 한다. 이것은 협력적인 다중 상속을 지원하는 예측 가능한 순서로 클래스를 검색하기 위해 자체 "
":meth:`__getattribute__` 메서드를 구현함으로써 그렇게 한다. 따라서, :func:`super` 는 "
"``super()[name]`` 과같이 문장이나 연산자를 사용하는 묵시적 조회에 대해서는 정의되지 않았다."

#: ../Doc/library/functions.rst:1493
msgid ""
"Also note that, aside from the zero argument form, :func:`super` is not "
"limited to use inside methods.  The two argument form specifies the "
"arguments exactly and makes the appropriate references.  The zero "
"argument form only works inside a class definition, as the compiler fills"
" in the necessary details to correctly retrieve the class being defined, "
"as well as accessing the current instance for ordinary methods."
msgstr ""
"또한, 인자가 없는 형식을 제외하고는, :func:`super` 는 메서드 내부에서만 사용하도록 제한되지 않는다는 점에 유의해야 한다. "
"두 개의 인자 형식은 인자를 정확하게 지정하고 적절한 참조를 만든다. 인자가 없는 형식은 클래스 정의 내에서만 작동하는데, 컴파일러가 "
"정의되고 있는 클래스를 올바르게 가져오고 일반 메서드에서 현재 인스턴스에 액세스하는 데 필요한 세부 정보를 채우기 때문이다."

#: ../Doc/library/functions.rst:1500
msgid ""
"For practical suggestions on how to design cooperative classes using "
":func:`super`, see `guide to using super() "
"<https://rhettinger.wordpress.com/2011/05/26/super-considered-super/>`_."
msgstr ""
":func:`super` 를 사용하여 협력적 클래스를 설계하는 방법에 대한 실용적인 제안은 `super() 사용 안내 "
"<https://rhettinger.wordpress.com/2011/05/26/super-considered-super/>`_ 를 "
"보라."

#: ../Doc/library/functions.rst:1509
msgid ""
"Rather than being a function, :class:`tuple` is actually an immutable "
"sequence type, as documented in :ref:`typesseq-tuple` and "
":ref:`typesseq`."
msgstr ""
"함수이기보다, :class:`tuple` 은 실제로 :ref:`typesseq-tuple` 과 :ref:`typesseq` 에 문서화 된"
" 것처럼 불변 시퀀스 형이다."

#: ../Doc/library/functions.rst:151
msgid ""
"With one argument, return the type of an *object*.  The return value is a"
" type object and generally the same object as returned by "
":attr:`object.__class__ <instance.__class__>`."
msgstr ""
"인자 하나의 경우, *object* 의 형을 돌려준다. 반환 값은 형 객체며 일반적으로 :attr:`object.__class__ "
"<instance.__class__>` 가 돌려주는 것과 같은 객체다."

#: ../Doc/library/functions.rst:1522
msgid ""
"The :func:`isinstance` built-in function is recommended for testing the "
"type of an object, because it takes subclasses into account."
msgstr "객체의 형을 검사하는 데는 :func:`isinstance` 내장 함수가 권장되는데, 서브 클래스를 고려하기 때문이다."

#: ../Doc/library/functions.rst:1526
msgid ""
"With three arguments, return a new type object.  This is essentially a "
"dynamic form of the :keyword:`class` statement. The *name* string is the "
"class name and becomes the :attr:`~definition.__name__` attribute; the "
"*bases* tuple itemizes the base classes and becomes the "
":attr:`~class.__bases__` attribute; and the *dict* dictionary is the "
"namespace containing definitions for class body and is copied to a "
"standard dictionary to become the :attr:`~object.__dict__` attribute.  "
"For example, the following two statements create identical :class:`type` "
"objects:"
msgstr ""
"세 개의 인자를 주는 경우, 새 형 객체를 돌려준다. 이것은 본래 :keyword:`class` 문의 동적인 형태다. *name* "
"문자열은 클래스 이름이고 :attr:`~definition.__name__` 어트리뷰트가 된다; *bases* 튜플은 베이스 클래스들을 "
"항목화하고 :attr:`~class.__bases__` 어트리뷰트가 된다; *dict* 딕셔너리는 클래스 바디의 정의들이 들어있는 이름 "
"공간이며 :attr:`~object.__dict__` 어트리뷰트가 되도록 표준 딕셔너리에 복사된다. 예를 들어, 다음 두 문장은 같은 "
":class:`type` 객체를 만든다:"

#: ../Doc/library/functions.rst:1540
msgid "See also :ref:`bltin-type-objects`."
msgstr ":ref:`bltin-type-objects` 를 참조하라."

#: ../Doc/library/functions.rst:1542
msgid ""
"Subclasses of :class:`type` which don't override ``type.__new__`` may no "
"longer use the one-argument form to get the type of an object."
msgstr ""
"``type.__new__`` 를 재정의하지 않는 :class:`type` 의 서브 클래스는 이제 객체의 형을 얻기 위해 하나의 인자 "
"형식을 사용할 수 없다."

#: ../Doc/library/functions.rst:1548
msgid ""
"Return the :attr:`~object.__dict__` attribute for a module, class, "
"instance, or any other object with a :attr:`~object.__dict__` attribute."
msgstr ""
"모듈, 클래스, 인스턴스 또는 :attr:`~object.__dict__` 어트리뷰트가 있는 다른 객체의 "
":attr:`~object.__dict__` 어트리뷰트를 돌려준다."

#: ../Doc/library/functions.rst:1551
msgid ""
"Objects such as modules and instances have an updateable "
":attr:`~object.__dict__` attribute; however, other objects may have write"
" restrictions on their :attr:`~object.__dict__` attributes (for example, "
"classes use a :class:`types.MappingProxyType` to prevent direct "
"dictionary updates)."
msgstr ""
"모듈 및 인스턴스와 같은 객체는 업데이트 가능한 :attr:`~object.__dict__` 어트리뷰트를 갖는다; 그러나, 다른 객체는 "
":attr:`~object.__dict__` 어트리뷰트에 쓰기 제한을 가질 수 있다 (예를 들어, 클래스는 직접적인 딕셔너리 갱신을 "
"방지하기 위해 :class:`types.MappingProxyType` 를 사용한다)."

#: ../Doc/library/functions.rst:1556
msgid ""
"Without an argument, :func:`vars` acts like :func:`locals`.  Note, the "
"locals dictionary is only useful for reads since updates to the locals "
"dictionary are ignored."
msgstr ""
"인자가 없으면, :func:`vars` 는 :func:`locals` 처럼 동작한다. locals 딕셔너리에 대한 변경이 무시되기 때문에"
" locals 딕셔너리는 읽기에만 유용하다는 것에 주의해야 한다."

#: ../Doc/library/functions.rst:1563
msgid "Make an iterator that aggregates elements from each of the iterables."
msgstr "각 iterables 의 요소들을 모으는 이터레이터를 만든다."

#: ../Doc/library/functions.rst:1565
msgid ""
"Returns an iterator of tuples, where the *i*-th tuple contains the *i*-th"
" element from each of the argument sequences or iterables.  The iterator "
"stops when the shortest input iterable is exhausted. With a single "
"iterable argument, it returns an iterator of 1-tuples.  With no "
"arguments, it returns an empty iterator.  Equivalent to::"
msgstr ""
"튜플의 이터레이터를 돌려주는데, *i* 번째 튜플은 각 인자로 전달된 시퀀스나 이터러블의 *i* 번째 요소를 포함한다. 이터레이터는 가장"
" 짧은 입력 이터러블이 모두 소모되면 멈춘다. 하나의 이터러블 인자를 사용하면, 1-튜플의 이터레이터를 돌려준다. 인자가 없으면, 빈 "
"이터레이터를 돌려준다. 다음과 동등하다::"

#: ../Doc/library/functions.rst:1584
msgid ""
"The left-to-right evaluation order of the iterables is guaranteed. This "
"makes possible an idiom for clustering a data series into n-length groups"
" using ``zip(*[iter(s)]*n)``.  This repeats the *same* iterator ``n`` "
"times so that each output tuple has the result of ``n`` calls to the "
"iterator. This has the effect of dividing the input into n-length chunks."
msgstr ""
"iterables 를 왼쪽에서 오른쪽으로 값을 구하는 순서가 보장된다. 이것은 ``zip(*[iter(s)]*n)`` 을 사용하여 데이터"
" 시리즈를 길이 n인 그룹으로 클러스터링하는 관용구를 가능하게 만든다. 이것은 *같은* 이터레이터를 ``n`` 번 반복해서, 각 출력 "
"튜플이 이터레이터를 ``n`` 번 호출한 결과를 갖게 된다. 입력을 길이 n인 묶음으로 나누는 효과를 준다."

#: ../Doc/library/functions.rst:1590
msgid ""
":func:`zip` should only be used with unequal length inputs when you don't"
" care about trailing, unmatched values from the longer iterables.  If "
"those values are important, use :func:`itertools.zip_longest` instead."
msgstr ""
":func:`zip` 에 길이가 같지 않은 입력들을 제공하는 것은, 끝부분에서 매치되지 않고 남는 더 긴 이터러블들의 값들에 신경 쓰지 "
"않는 경우로 제한해야 한다. 그 값들이 중요하다면, 대신 :func:`itertools.zip_longest` 를 사용한다."

#: ../Doc/library/functions.rst:1594
msgid ""
":func:`zip` in conjunction with the ``*`` operator can be used to unzip a"
" list::"
msgstr ":func:`zip` 을 ``*`` 연산자와 함께 쓰면 리스트를 unzip 할 수 있다::"

#: ../Doc/library/functions.rst:1615
msgid ""
"This is an advanced function that is not needed in everyday Python "
"programming, unlike :func:`importlib.import_module`."
msgstr ""
"이것은 :func:`importlib.import_module` 과 달리 일상적인 파이썬 프로그래밍에서는 필요하지 않은 고급 함수다."

#: ../Doc/library/functions.rst:1618
msgid ""
"This function is invoked by the :keyword:`import` statement.  It can be "
"replaced (by importing the :mod:`builtins` module and assigning to "
"``builtins.__import__``) in order to change semantics of the "
":keyword:`import` statement, but doing so is **strongly** discouraged as "
"it is usually simpler to use import hooks (see :pep:`302`) to attain the "
"same goals and does not cause issues with code which assumes the default "
"import implementation is in use.  Direct use of :func:`__import__` is "
"also discouraged in favor of :func:`importlib.import_module`."
msgstr ""
"이 함수는 :keyword:`import` 문에 의해 호출된다. :keyword:`import` 문의 의미를 변경하기 위해 대체할 수 "
"있다 (:mod:`builtins` 모듈을 임포트하고 ``builtins .__ import__`` 에 대입한다). 그러나 그렇게 하지 "
"말 것을 **강하게** 권고하는데, 보통 같은 목적을 달성하는데 임포트 훅(:pep:`302` 참조)을 사용하는 것이 더 간단하고 기본 "
"임포트 구현이 사용될 것이라고 가정하는 코드들과 문제를 일으키지 않기 때문이다. :func:`__import__` 의 직접 사용 역시 "
"피하고 :func:`importlib.import_module` 을 사용할 것을 권한다."

#: ../Doc/library/functions.rst:1627
msgid ""
"The function imports the module *name*, potentially using the given "
"*globals* and *locals* to determine how to interpret the name in a "
"package context. The *fromlist* gives the names of objects or submodules "
"that should be imported from the module given by *name*.  The standard "
"implementation does not use its *locals* argument at all, and uses its "
"*globals* only to determine the package context of the :keyword:`import` "
"statement."
msgstr ""
"함수는 모듈 *name* 을 임포트하는데, 잠재적으로 패키지 문맥에서 이름을 해석하는 방법을 결정하는데 주어진 *globals* 와 "
"*locals* 를 사용한다. *fromlist* 는 *name* 에 의해 주어진 모듈로부터 임포트 되어야 하는 객체 또는 서브 모듈의 "
"이름을 제공한다. 표준 구현은 *locals* 인자를 전혀 사용하지 않고, :keyword:`import` 문의 패키지 문맥을 결정할 "
"때만 *globals* 를 사용한다."

#: ../Doc/library/functions.rst:1634
msgid ""
"*level* specifies whether to use absolute or relative imports. ``0`` (the"
" default) means only perform absolute imports.  Positive values for "
"*level* indicate the number of parent directories to search relative to "
"the directory of the module calling :func:`__import__` (see :pep:`328` "
"for the details)."
msgstr ""
"*level* 은 절대 또는 상대 임포트를 사용할지를 지정한다. ``0`` (기본값)은 오직 절대 임포트를 수행한다는 것을 의미한다. "
"양수 값 *level* 은 :func:`__import__` 를 호출하는 모듈 디렉터리에 상대적으로 검색할 상위 디렉터리들의 개수를 "
"가리킨다 (자세한 내용은 :pep:`328` 참조)."

#: ../Doc/library/functions.rst:1640
msgid ""
"When the *name* variable is of the form ``package.module``, normally, the"
" top-level package (the name up till the first dot) is returned, *not* "
"the module named by *name*.  However, when a non-empty *fromlist* "
"argument is given, the module named by *name* is returned."
msgstr ""
"*name* 변수가 ``package.module`` 형식일 때, 일반적으로 *name* 에 의해 명명된 모듈이 *아니라*, 최상위 "
"패키지(첫 번째 점까지의 이름)가 반환된다. 그러나 비어 있지 않은 *fromlist* 인자가 주어지면 *name* 에 의해 명명된 "
"모듈이 반환된다."

#: ../Doc/library/functions.rst:1645
msgid ""
"For example, the statement ``import spam`` results in bytecode resembling"
" the following code::"
msgstr "예를 들어, 문장 ``import spam`` 은 다음 코드를 닮은 바이트 코드를 생성한다::"

#: ../Doc/library/functions.rst:1650
msgid "The statement ``import spam.ham`` results in this call::"
msgstr "문장 ``import spam.ham`` 은 이런 호출로 이어진다::"

#: ../Doc/library/functions.rst:1654
msgid ""
"Note how :func:`__import__` returns the toplevel module here because this"
" is the object that is bound to a name by the :keyword:`import` "
"statement."
msgstr ""
"여기에서 :func:`__import__` 가 최상위 모듈을 돌려주는 것에 주목하라. 이것이 :keyword:`import` 문에 의해 "
"이름에 연결되는 객체이기 때문이다."

#: ../Doc/library/functions.rst:1657
msgid ""
"On the other hand, the statement ``from spam.ham import eggs, sausage as "
"saus`` results in ::"
msgstr ""
"반면에, 문장 ``from spam.ham import eggs, sausage as saus`` 는 라는 문장은 이런 결과를 준다::"

#: ../Doc/library/functions.rst:1664
msgid ""
"Here, the ``spam.ham`` module is returned from :func:`__import__`.  From "
"this object, the names to import are retrieved and assigned to their "
"respective names."
msgstr ""
"여기서 ``spam.ham`` 모듈이 :func:`__import__` 에서 반환된다. 이 객체로부터, 임포트할 이름들을 가져온 후 해당"
" 이름들로 대입된다."

#: ../Doc/library/functions.rst:1668
msgid ""
"If you simply want to import a module (potentially within a package) by "
"name, use :func:`importlib.import_module`."
msgstr ""
"단순히 이름으로 모듈을 임포트 하기 원한다면 (잠재적으로 패키지 내에서), :func:`importlib.import_module` 을 "
"사용한다."

#: ../Doc/library/functions.rst:1671
msgid ""
"Negative values for *level* are no longer supported (which also changes "
"the default value to 0)."
msgstr "음수 *level* 은 더 지원되지 않는다 (기본값도 0으로 변경한다)."

#: ../Doc/library/functions.rst:1677
msgid "Footnotes"
msgstr "각주"

#: ../Doc/library/functions.rst:1678
msgid ""
"Note that the parser only accepts the Unix-style end of line convention. "
"If you are reading the code from a file, make sure to use newline "
"conversion mode to convert Windows or Mac-style newlines."
msgstr ""
"파서는 유닉스 스타일의 줄 종료 규칙만 받아들이는 것에 주의해야 한다. 파일에서 코드를 읽는 경우, 줄 넘김 변환 모드를 사용해서 "
"윈도우나 맥 스타일 줄 넘김을 변환해야 한다."
