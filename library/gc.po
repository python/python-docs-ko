# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-05-30 09:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/gc.rst:2
msgid ":mod:`gc` --- Garbage Collector interface"
msgstr ":mod:`gc` --- 가비지 수거기 인터페이스"

#: ../Doc/library/gc.rst:12
msgid ""
"This module provides an interface to the optional garbage collector.  It "
"provides the ability to disable the collector, tune the collection "
"frequency, and set debugging options.  It also provides access to "
"unreachable objects that the collector found but cannot free.  Since the "
"collector supplements the reference counting already used in Python, you "
"can disable the collector if you are sure your program does not create "
"reference cycles.  Automatic collection can be disabled by calling "
"``gc.disable()``.  To debug a leaking program call "
"``gc.set_debug(gc.DEBUG_LEAK)``. Notice that this includes "
"``gc.DEBUG_SAVEALL``, causing garbage-collected objects to be saved in "
"gc.garbage for inspection."
msgstr ""
"이 모듈은 선택적인 가비지 수거기에 대한 인터페이스를 제공합니다. 수거기를 비활성화하고, 수거 빈도를 조정하며, 디버깅 옵션을 "
"설정하는 기능을 제공합니다. 또한 수거기가 발견했지만 해제할 수 없는 도달 불가능한 객체에 대한 액세스를 제공합니다. 수거기는 "
"파이썬에서 이미 사용된 참조 횟수 추적을 보충하므로, 프로그램이 참조 순환을 만들지 않는다고 확신한다면 수거기를 비활성화 할 수 "
"있습니다. ``gc.disable()``\\을 호출하여 자동 수거를 비활성화 할 수 있습니다. 누수가 발생하는 프로그램을 "
"디버그하려면, ``gc.set_debug(gc.DEBUG_LEAK)``\\을 호출하십시오. 이것은 "
"``gc.DEBUG_SAVEALL``\\을 포함하므로, 가비지 수거된 객체가 검사를 위해 gc.garbage에 저장되도록 함에 "
"유의하십시오."

#: ../Doc/library/gc.rst:23
msgid "The :mod:`gc` module provides the following functions:"
msgstr ":mod:`gc` 모듈은 다음 함수를 제공합니다:"

#: ../Doc/library/gc.rst:28
msgid "Enable automatic garbage collection."
msgstr "자동 가비지 수거를 활성화합니다."

#: ../Doc/library/gc.rst:33
msgid "Disable automatic garbage collection."
msgstr "자동 가비지 수거를 비활성화합니다."

#: ../Doc/library/gc.rst:38
msgid "Returns true if automatic collection is enabled."
msgstr "자동 수거가 활성화되었으면 참을 반환합니다."

#: ../Doc/library/gc.rst:43
msgid ""
"With no arguments, run a full collection.  The optional argument "
"*generation* may be an integer specifying which generation to collect "
"(from 0 to 2).  A :exc:`ValueError` is raised if the generation number  "
"is invalid. The number of unreachable objects found is returned."
msgstr ""
"인자가 없으면, 전체 수거를 실행합니다. 선택적 인자 *generation*\\은 어떤 세대를 수거할지 지정하는 정수(0에서 2)일"
" 수 있습니다. 세대 번호가 유효하지 않으면 :exc:`ValueError`\\가 발생합니다. 발견된 도달할 수 "
"없는(unreachable) 객체의 수가 반환됩니다."

#: ../Doc/library/gc.rst:48
msgid ""
"The free lists maintained for a number of built-in types are cleared "
"whenever a full collection or collection of the highest generation (2) is"
" run.  Not all items in some free lists may be freed due to the "
"particular implementation, in particular :class:`float`."
msgstr ""
"여러 내장형을 위해 유지되는 자유 목록(free list)은 전체 수거나 최고 세대(2)의 수거가 실행될 때마다 지워집니다. 특정 "
"구현(특히 :class:`float`)으로 인해, 일부 자유 목록에서 모든 항목이 해제되지는 않을 수 있습니다."

#: ../Doc/library/gc.rst:56
msgid ""
"Set the garbage collection debugging flags. Debugging information will be"
" written to ``sys.stderr``.  See below for a list of debugging flags "
"which can be combined using bit operations to control debugging."
msgstr ""
"가비지 수거 디버깅 플래그를 설정합니다. 디버깅 정보가 ``sys.stderr``\\에 기록됩니다. 디버깅을 제어하기 위해 비트 "
"연산을 사용하여 결합할 수 있는 디버깅 플래그 목록은 아래를 참조하십시오."

#: ../Doc/library/gc.rst:63
msgid "Return the debugging flags currently set."
msgstr "현재 설정된 디버깅 플래그를 반환합니다."

#: ../Doc/library/gc.rst:68
msgid ""
"Returns a list of all objects tracked by the collector, excluding the "
"list returned."
msgstr ""

#: ../Doc/library/gc.rst:74
msgid ""
"Return a list of three per-generation dictionaries containing collection "
"statistics since interpreter start.  The number of keys may change in the"
" future, but currently each dictionary will contain the following items:"
msgstr ""
"인터프리터가 시작된 이후의 수거 통계를 포함하는 세 개의 세대별 딕셔너리의 리스트를 반환합니다. 향후 키 수는 변경될 수 있지만, "
"현재 각 딕셔너리에는 다음과 같은 항목이 포함됩니다:"

#: ../Doc/library/gc.rst:79
msgid "``collections`` is the number of times this generation was collected;"
msgstr "``collections``\\는 이 세대가 수거된 횟수입니다."

#: ../Doc/library/gc.rst:81
msgid ""
"``collected`` is the total number of objects collected inside this "
"generation;"
msgstr "``collected``\\는 이 세대 내에서 수거된 총 객체 수입니다."

#: ../Doc/library/gc.rst:84
msgid ""
"``uncollectable`` is the total number of objects which were found to be "
"uncollectable (and were therefore moved to the :data:`garbage` list) "
"inside this generation."
msgstr ""
"``uncollectable``\\은 이 세대 내에서 수거할 수 없는 (따라서 :data:`garbage` 리스트로 이동된) 것으로"
" 확인된 총 객체 수입니다."

#: ../Doc/library/gc.rst:93
msgid ""
"Set the garbage collection thresholds (the collection frequency). Setting"
" *threshold0* to zero disables collection."
msgstr "가비지 수거 임곗값(수거 빈도)을 설정합니다. *threshold0*\\을 0으로 설정하면 수거가 비활성화됩니다."

#: ../Doc/library/gc.rst:96
msgid ""
"The GC classifies objects into three generations depending on how many "
"collection sweeps they have survived.  New objects are placed in the "
"youngest generation (generation ``0``).  If an object survives a "
"collection it is moved into the next older generation.  Since generation "
"``2`` is the oldest generation, objects in that generation remain there "
"after a collection.  In order to decide when to run, the collector keeps "
"track of the number object allocations and deallocations since the last "
"collection.  When the number of allocations minus the number of "
"deallocations exceeds *threshold0*, collection starts.  Initially only "
"generation ``0`` is examined.  If generation ``0`` has been examined more"
" than *threshold1* times since generation ``1`` has been examined, then "
"generation ``1`` is examined as well.  Similarly, *threshold2* controls "
"the number of collections of generation ``1`` before collecting "
"generation ``2``."
msgstr ""
"GC는 얼마나 많은 수거 스위프(sweep)에서 살아남았는지에 따라 객체를 세 가지 세대로 분류합니다. 새로운 객체는 가장 어린 "
"세대(``0``\\세대)에 배치됩니다. 객체가 수거에서 살아남으면 다음 세대로 이동합니다. ``2`` 가 가장 나이 든 세대이므로,"
" 이 세대의 객체는 수거 후에도 여기에 남아 있습니다. 언제 실행할지를 결정하기 위해, 수거기는 마지막 수거 이후의 객체 할당과 "
"할당 해제 수를 추적합니다. 할당 횟수에서 할당 해제 횟수를 뺀 값이 *threshold0*\\를 초과하면 수거가 시작됩니다. "
"처음에는 ``0``\\세대만 검사합니다. ``1`` 세대를 검사한 후로, ``0``\\세대를 *threshold1* 회를 초과하여 "
"검사했으면, ``1`` 세대도 검사됩니다. 마찬가지로, *threshold2*\\는 ``2``\\세대를 수거하기 전의 "
"``1``\\세대 수거 횟수를 제어합니다."

#: ../Doc/library/gc.rst:113
msgid ""
"Return the current collection  counts as a tuple of ``(count0, count1, "
"count2)``."
msgstr "현재 수거 횟수를 ``(count0, count1, count2)``\\의 튜플로 반환합니다."

#: ../Doc/library/gc.rst:119
msgid ""
"Return the current collection thresholds as a tuple of ``(threshold0, "
"threshold1, threshold2)``."
msgstr "현재 수거 임곗값을 ``(threshold0, threshold1, threshold2)``\\의 튜플로 반환합니다."

#: ../Doc/library/gc.rst:125
msgid ""
"Return the list of objects that directly refer to any of objs. This "
"function will only locate those containers which support garbage "
"collection; extension types which do refer to other objects but do not "
"support garbage collection will not be found."
msgstr ""
"objs에 있는 것을 직접 참조하는 객체의 리스트를 반환합니다. 이 함수는 가비지 수거를 지원하는 컨테이너만 찾습니다; 다른 객체를"
" 참조하지만, 가비지 수거를 지원하지 않는 확장형은 찾을 수 없습니다."

#: ../Doc/library/gc.rst:130
msgid ""
"Note that objects which have already been dereferenced, but which live in"
" cycles and have not yet been collected by the garbage collector can be "
"listed among the resulting referrers.  To get only currently live "
"objects, call :func:`collect` before calling :func:`get_referrers`."
msgstr ""
"이미 참조 해제되었지만, 순환에 참여해서 가비지 수거기에 의해 아직 수거되지 않은 객체는 결과 참조자(referrer)에 나열될 수"
" 있음에 유의하십시오. 현재 살아있는 객체만 가져오려면, :func:`get_referrers`\\를 호출하기 전에 "
":func:`collect`\\를 호출하십시오."

#: ../Doc/library/gc.rst:135
msgid ""
"Care must be taken when using objects returned by :func:`get_referrers` "
"because some of them could still be under construction and hence in a "
"temporarily invalid state. Avoid using :func:`get_referrers` for any "
"purpose other than debugging."
msgstr ""
":func:`get_referrers`\\에서 반환된 객체를 사용할 때는, 그중 일부는 아직 생성 중이라서 일시적으로 유효하지 않은"
" 상태일 수 있기 때문에 주의해야 합니다. 디버깅 이외의 목적으로 :func:`get_referrers`\\를 사용하지 마십시오."

#: ../Doc/library/gc.rst:143
msgid ""
"Return a list of objects directly referred to by any of the arguments. "
"The referents returned are those objects visited by the arguments' "
"C-level :c:member:`~PyTypeObject.tp_traverse` methods (if any), and may "
"not be all objects actually directly reachable.  "
":c:member:`~PyTypeObject.tp_traverse` methods are supported only by "
"objects that support garbage collection, and are only required to visit "
"objects that may be involved in a cycle.  So, for example, if an integer "
"is directly reachable from an argument, that integer object may or may "
"not appear in the result list."
msgstr ""
"인자로 제공된 객체가 직접 참조하는 객체의 리스트를 반환합니다. 반환된 피 참조자(referent)는 인자의 C 수준 "
":c:member:`~PyTypeObject.tp_traverse` 메서드(있다면)가 방문한 객체이며, 실제로 직접 도달할 수 있는"
" 모든 객체는 아닐 수 있습니다. :c:member:`~PyTypeObject.tp_traverse` 메서드는 가비지 수거를 "
"지원하는 객체에서만 지원되며, 순환에 참여하는 객체만 방문하면 됩니다. 그래서, 예를 들어, 인자에서 정수에 직접 도달 할 수 "
"있으면, 해당 정수 객체가 결과 목록에 나타날 수도 그렇지 않을 수도 있습니다."

#: ../Doc/library/gc.rst:154
msgid ""
"Returns ``True`` if the object is currently tracked by the garbage "
"collector, ``False`` otherwise.  As a general rule, instances of atomic "
"types aren't tracked and instances of non-atomic types (containers, user-"
"defined objects...) are.  However, some type-specific optimizations can "
"be present in order to suppress the garbage collector footprint of simple"
" instances (e.g. dicts containing only atomic keys and values)::"
msgstr ""
"가비지 수거기가 객체를 현재 추적하고 있으면 ``True``\\를, 그렇지 않으면 ``False``\\를 반환합니다. 일반적인 "
"규칙으로, 원자 형(atomic type)의 인스턴스는 추적하지 않고, 원자 형이 아닌 인스턴스(컨테이너, 사용자 정의 "
"객체...)는 추적합니다. 그러나 간단한 인스턴스의 가비지 수거기 크기를 줄이기 위해 일부 형별 최적화가 존재할 수 있습니다 (예를"
" 들어, 원자적 키와 값만 포함하는 딕셔너리)::"

#: ../Doc/library/gc.rst:179
msgid ""
"Freeze all the objects tracked by gc - move them to a permanent "
"generation and ignore all the future collections. This can be used before"
" a POSIX fork() call to make the gc copy-on-write friendly or to speed up"
" collection. Also collection before a POSIX fork() call may free pages "
"for future allocation which can cause copy-on-write too so it's advised "
"to disable gc in master process and freeze before fork and enable gc in "
"child process."
msgstr ""

#: ../Doc/library/gc.rst:191
msgid ""
"Unfreeze the objects in the permanent generation, put them back into the "
"oldest generation."
msgstr "영구 세대(permanent generation)의 객체를 고정 해제하고, 가장 나이 든 세대로 되돌립니다."

#: ../Doc/library/gc.rst:199
msgid "Return the number of objects in the permanent generation."
msgstr "영구 세대(permanent generation)에 있는 객체 수를 반환합니다."

#: ../Doc/library/gc.rst:204
msgid ""
"The following variables are provided for read-only access (you can mutate"
" the values but should not rebind them):"
msgstr "다음 변수가 전용 액세스로 제공됩니다 (값을 변경할 수는 있지만, 다시 연결해서는 안 됩니다):"

#: ../Doc/library/gc.rst:209
msgid ""
"A list of objects which the collector found to be unreachable but could "
"not be freed (uncollectable objects).  Starting with Python 3.4, this "
"list should be empty most of the time, except when using instances of C "
"extension types with a non-NULL ``tp_del`` slot."
msgstr ""
"수거기가 발견했지만 해제할 수 없는 도달 불가능한 객체의 리스트 (수거할 수 없는 객체). 파이썬 3.4부터, NULL이 아닌 "
"``tp_del`` 슬롯이 있는 C 확장형의 인스턴스를 사용할 때를 제외하고, 이 리스트는 대체로 비어 있어야 합니다."

#: ../Doc/library/gc.rst:214
msgid ""
"If :const:`DEBUG_SAVEALL` is set, then all unreachable objects will be "
"added to this list rather than freed."
msgstr ":const:`DEBUG_SAVEALL`\\이 설정되면, 도달할 수 없는 모든 객체가 해제되지 않고 이 목록에 추가됩니다."

#: ../Doc/library/gc.rst:217
msgid ""
"If this list is non-empty at :term:`interpreter shutdown`, a "
":exc:`ResourceWarning` is emitted, which is silent by default.  If "
":const:`DEBUG_UNCOLLECTABLE` is set, in addition all uncollectable "
"objects are printed."
msgstr ""
":term:`인터프리터 종료 <interpreter shutdown>` 시 이 목록이 비어 있지 않으면, "
":exc:`ResourceWarning`\\이 발생하는데, 기본적으로 조용(silent)합니다. "
":const:`DEBUG_UNCOLLECTABLE`\\이 설정되면, 추가로 모든 수거 할 수 없는 객체가 인쇄됩니다."

#: ../Doc/library/gc.rst:223
msgid ""
"Following :pep:`442`, objects with a :meth:`__del__` method don't end up "
"in :attr:`gc.garbage` anymore."
msgstr ""
":pep:`442`\\에 따라, :meth:`__del__` 메서드를 가진 객체는 더는 :attr:`gc.garbage`\\에 "
"들어가지 않습니다."

#: ../Doc/library/gc.rst:229
msgid ""
"A list of callbacks that will be invoked by the garbage collector before "
"and after collection.  The callbacks will be called with two arguments, "
"*phase* and *info*."
msgstr "수거 전후에 가비지 수거기가 호출할 콜백의 리스트입니다. 콜백은 두 인자로 호출됩니다, *phase*\\와 *info*."

#: ../Doc/library/gc.rst:233
msgid "*phase* can be one of two values:"
msgstr "*phase*\\는 다음 두 값 중 하나일 수 있습니다:"

#: ../Doc/library/gc.rst:235
msgid "\"start\": The garbage collection is about to start."
msgstr "\"start\": 가비지 수거를 시작하려고 합니다."

#: ../Doc/library/gc.rst:237
msgid "\"stop\": The garbage collection has finished."
msgstr "\"stop\": 가비지 수거가 완료되었습니다."

#: ../Doc/library/gc.rst:239
msgid ""
"*info* is a dict providing more information for the callback.  The "
"following keys are currently defined:"
msgstr "*info*\\는 콜백에 추가 정보를 제공하는 딕셔너리입니다. 현재 다음 키가 정의되어 있습니다:"

#: ../Doc/library/gc.rst:242
msgid "\"generation\": The oldest generation being collected."
msgstr "\"generation\": 수거되는 가장 나이 든 세대."

#: ../Doc/library/gc.rst:244
msgid ""
"\"collected\": When *phase* is \"stop\", the number of objects "
"successfully collected."
msgstr "\"collected\": *phase*\\가 \"stop\"일 때, 성공적으로 수거된 객체 수."

#: ../Doc/library/gc.rst:247
msgid ""
"\"uncollectable\": When *phase* is \"stop\", the number of objects that "
"could not be collected and were put in :data:`garbage`."
msgstr ""
"\"uncollectable\": *phase*\\가 \"stop\"일 때, 수거할 수 없어서 :data:`garbage`\\에 "
"들어간 객체 수."

#: ../Doc/library/gc.rst:250
msgid ""
"Applications can add their own callbacks to this list.  The primary use "
"cases are:"
msgstr "응용 프로그램은 이 리스트에 자체 콜백을 추가 할 수 있습니다. 주요 사용 사례는 다음과 같습니다:"

#: ../Doc/library/gc.rst:253
msgid ""
"Gathering statistics about garbage collection, such as how often various "
"generations are collected, and how long the collection takes."
msgstr "다양한 세대가 수거되는 빈도와 수거에 걸린 시간과 같은 가비지 수거에 대한 통계 수집."

#: ../Doc/library/gc.rst:257
msgid ""
"Allowing applications to identify and clear their own uncollectable types"
" when they appear in :data:`garbage`."
msgstr "응용 프로그램이 자신의 수거할 수 없는 형이 :data:`garbage`\\에 나타날 때 식별하고 지울 수 있도록 합니다."

#: ../Doc/library/gc.rst:263
msgid "The following constants are provided for use with :func:`set_debug`:"
msgstr ":func:`set_debug`\\와 함께 사용하기 위해 다음 상수가 제공됩니다:"

#: ../Doc/library/gc.rst:268
msgid ""
"Print statistics during collection.  This information can be useful when "
"tuning the collection frequency."
msgstr "수거 중 통계를 인쇄합니다. 이 정보는 수거 빈도를 조정할 때 유용 할 수 있습니다."

#: ../Doc/library/gc.rst:274
msgid "Print information on collectable objects found."
msgstr "발견된 수거 가능한 객체에 대한 정보를 인쇄합니다."

#: ../Doc/library/gc.rst:279
msgid ""
"Print information of uncollectable objects found (objects which are not "
"reachable but cannot be freed by the collector).  These objects will be "
"added to the ``garbage`` list."
msgstr ""
"발견된 수거 할 수 없는 객체에 대한 정보를 인쇄합니다 (도달 할 수 있지만, 수거기가 해제할 수 없는 객체). 이 객체는 "
"``garbage`` 리스트에 추가됩니다."

#: ../Doc/library/gc.rst:283
msgid ""
"Also print the contents of the :data:`garbage` list at :term:`interpreter"
" shutdown`, if it isn't empty."
msgstr ""
":term:`인터프리터 종료 <interpreter shutdown>` 시에 :data:`garbage` 리스트가 비어있지 않으면 "
"내용을 인쇄하기도 합니다."

#: ../Doc/library/gc.rst:289
msgid ""
"When set, all unreachable objects found will be appended to *garbage* "
"rather than being freed.  This can be useful for debugging a leaking "
"program."
msgstr ""
"설정하면, 발견된 모든 도달할 수 없는 객체를 해제하는 대신 *garbage*\\에 추가합니다. 누수가 있는 프로그램을 디버깅하는 "
"데 유용 할 수 있습니다."

#: ../Doc/library/gc.rst:295
msgid ""
"The debugging flags necessary for the collector to print information "
"about a leaking program (equal to ``DEBUG_COLLECTABLE | "
"DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL``)."
msgstr ""
"수거기가 누수가 있는 프로그램에 대한 정보를 인쇄하도록 하는 데 필요한 디버깅 플래그 (``DEBUG_COLLECTABLE | "
"DEBUG_UNCOLLECTABLE | DEBUG_SAVEALL``\\과 같습니다)."

