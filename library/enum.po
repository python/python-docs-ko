# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-08 08:18+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/enum.rst:2
msgid ":mod:`enum` --- Support for enumerations"
msgstr ":mod:`enum` --- 열거형 지원"

#: ../Doc/library/enum.rst:14
msgid "**Source code:** :source:`Lib/enum.py`"
msgstr "**소스 코드:** :source:`Lib/enum.py`"

#: ../Doc/library/enum.rst:18
msgid ""
"An enumeration is a set of symbolic names (members) bound to unique, "
"constant values.  Within an enumeration, the members can be compared by "
"identity, and the enumeration itself can be iterated over."
msgstr ""
"열거형(enumeration)은 고유한 상숫값에 연결된 기호 이름(멤버)의 집합입니다. 열거형 내에서, 멤버를 아이덴티티로 비교할 "
"수 있고, 열거형 자체는 이터레이트 될 수 있습니다."

#: ../Doc/library/enum.rst:22
msgid "Case of Enum Members"
msgstr "Enum 멤버의 케이스"

#: ../Doc/library/enum.rst:24
msgid ""
"Because Enums are used to represent constants we recommend using "
"UPPER_CASE names for enum members, and will be using that style in our "
"examples."
msgstr ""
"열거형은 상수를 나타내는 데 사용되기 때문에 열거형 멤버에 대해 대문자(UPPER_CASE) 이름을 사용하는 것이 좋으며, "
"예제에서는 이 스타일을 사용합니다."

#: ../Doc/library/enum.rst:30
msgid "Module Contents"
msgstr "모듈 내용"

#: ../Doc/library/enum.rst:32
msgid ""
"This module defines four enumeration classes that can be used to define "
"unique sets of names and values: :class:`Enum`, :class:`IntEnum`, "
":class:`Flag`, and :class:`IntFlag`.  It also defines one decorator, "
":func:`unique`, and one helper, :class:`auto`."
msgstr ""
"이 모듈은 고유한 이름 집합과 값을 정의하는 데 사용할 수 있는 네 가지 열거형 클래스를 정의합니다: :class:`Enum`, "
":class:`IntEnum`, :class:`Flag` 및 :class:`IntFlag`. 또한 하나의 데코레이터 "
":func:`unique`\\와 하나의 도우미 :class:`auto`\\를 정의합니다."

#: ../Doc/library/enum.rst:39
msgid ""
"Base class for creating enumerated constants.  See section `Functional "
"API`_ for an alternate construction syntax."
msgstr "열거형 상수를 만들기 위한 베이스 클래스. 대체 구성 문법은 `함수형 API <Functional API_>`_ 섹션을 참조하십시오."

#: ../Doc/library/enum.rst:44
msgid ""
"Base class for creating enumerated constants that are also subclasses of "
":class:`int`."
msgstr ":class:`int`\\의 서브 클래스이기도 한 열거형 상수를 만들기 위한 베이스 클래스."

#: ../Doc/library/enum.rst:49
msgid ""
"Base class for creating enumerated constants that can be combined using "
"the bitwise operators without losing their :class:`IntFlag` membership. "
":class:`IntFlag` members are also subclasses of :class:`int`."
msgstr ""
":class:`IntFlag` 멤버십을 잃지 않고 비트 연산자를 사용하여 결합할 수 있는 열거형 상수를 만들기 위한 베이스 클래스."
" :class:`IntFlag` 멤버도 :class:`int`\\의 서브 클래스입니다."

#: ../Doc/library/enum.rst:55
msgid ""
"Base class for creating enumerated constants that can be combined using "
"the bitwise operations without losing their :class:`Flag` membership."
msgstr ":class:`Flag` 멤버십을 잃지 않고 비트 연산을 사용하여 결합할 수 있는 열거형 상수를 만들기 위한 베이스 클래스."

#: ../Doc/library/enum.rst:61
msgid "Enum class decorator that ensures only one name is bound to any one value."
msgstr "한 값에 하나의 이름 만 연결되도록 하는 Enum 클래스 데코레이터."

#: ../Doc/library/enum.rst:65
msgid ""
"Instances are replaced with an appropriate value for Enum members.  By "
"default, the initial value starts at 1."
msgstr "인스턴스는 Enum 멤버에 적절한 값으로 바뀝니다. 기본적으로, 초깃값은 1부터 시작합니다."

#: ../Doc/library/enum.rst:67
msgid "``Flag``, ``IntFlag``, ``auto``"
msgstr "``Flag``, ``IntFlag``, ``auto``"

#: ../Doc/library/enum.rst:71
msgid "Creating an Enum"
msgstr "Enum 만들기"

#: ../Doc/library/enum.rst:73
msgid ""
"Enumerations are created using the :keyword:`class` syntax, which makes "
"them easy to read and write.  An alternative creation method is described"
" in `Functional API`_.  To define an enumeration, subclass :class:`Enum` "
"as follows::"
msgstr ""
"열거형은 :keyword:`class` 문법을 사용하여 작성되므로 쉽게 읽고 쓸 수 있습니다. 대체 작성 방법은 `함수형 API "
"<Functional API_>`_\\에 설명되어 있습니다. 열거형을 정의하려면, 다음과 같이 :class:`Enum`\\을 서브 "
"클래스 하십시오::"

#: ../Doc/library/enum.rst:85
msgid "Enum member values"
msgstr "Enum 멤버 값"

#: ../Doc/library/enum.rst:87
msgid ""
"Member values can be anything: :class:`int`, :class:`str`, etc..  If the "
"exact value is unimportant you may use :class:`auto` instances and an "
"appropriate value will be chosen for you.  Care must be taken if you mix "
":class:`auto` with other values."
msgstr ""
"멤버 값은 아무것이나 될 수 있습니다: :class:`int`, :class:`str` 등. 정확한 값이 중요하지 않다면, "
":class:`auto` 인스턴스를 사용할 수 있으며 적절한 값이 선택됩니다. :class:`auto`\\를 다른 값과 혼합 할 "
"경우 주의를 기울여야 합니다."

#: ../Doc/library/enum.rst:92
msgid "Nomenclature"
msgstr "명명법"

#: ../Doc/library/enum.rst:94
msgid "The class :class:`Color` is an *enumeration* (or *enum*)"
msgstr ":class:`Color` 클래스는 *열거형(enumeration)* (또는 *enum*) 입니다."

#: ../Doc/library/enum.rst:95
msgid ""
"The attributes :attr:`Color.RED`, :attr:`Color.GREEN`, etc., are "
"*enumeration members* (or *enum members*) and are functionally constants."
msgstr ""
":attr:`Color.RED`, :attr:`Color.GREEN` 등의 어트리뷰트는 *열거형 멤버(enumeration "
"members)*\\(또는 *enum members*)이며 기능상 상수입니다."

#: ../Doc/library/enum.rst:97
msgid ""
"The enum members have *names* and *values* (the name of :attr:`Color.RED`"
" is ``RED``, the value of :attr:`Color.BLUE` is ``3``, etc.)"
msgstr ""
"열거형 멤버에는 *이름(names)*\\과 *값(values)*\\이 있습니다 (:attr:`Color.RED`\\의 이름은 "
"``RED``, :attr:`Color.BLUE`\\의 값은 ``3``, 등)"

#: ../Doc/library/enum.rst:103
msgid ""
"Even though we use the :keyword:`class` syntax to create Enums, Enums are"
" not normal Python classes.  See `How are Enums different?`_ for more "
"details."
msgstr ""
":keyword:`class` 문법을 사용하여 Enum을 만들더라도, Enum은 일반적인 파이썬 클래스가 아닙니다. 자세한 내용은 "
"`열거형은 어떻게 다릅니까? <How are Enums different?_>`_ 를 참조하십시오."

#: ../Doc/library/enum.rst:107
msgid "Enumeration members have human readable string representations::"
msgstr "열거형 멤버는 사람이 읽을 수 있는 문자열 표현을 갖습니다::"

#: ../Doc/library/enum.rst:112
msgid "...while their ``repr`` has more information::"
msgstr "``repr``\\에는 더 자세한 정보가 있습니다::"

#: ../Doc/library/enum.rst:117
msgid "The *type* of an enumeration member is the enumeration it belongs to::"
msgstr "열거형 멤버의 *형*\\은 그것이 속한 열거형입니다::"

#: ../Doc/library/enum.rst:125
msgid "Enum members also have a property that contains just their item name::"
msgstr "Enum 멤버에는 항목 이름 만 포함하는 프로퍼티가 있습니다::"

#: ../Doc/library/enum.rst:130
msgid "Enumerations support iteration, in definition order::"
msgstr "열거형은 정의 순서로 이터레이션을 지원합니다::"

#: ../Doc/library/enum.rst:146
msgid ""
"Enumeration members are hashable, so they can be used in dictionaries and"
" sets::"
msgstr "열거형 멤버는 해시 가능하므로, 딕셔너리와 집합에 사용할 수 있습니다::"

#: ../Doc/library/enum.rst:156
msgid "Programmatic access to enumeration members and their attributes"
msgstr "열거형 멤버와 그들의 어트리뷰트에 프로그래밍 방식으로 액세스하기"

#: ../Doc/library/enum.rst:158
msgid ""
"Sometimes it's useful to access members in enumerations programmatically "
"(i.e. situations where ``Color.RED`` won't do because the exact color is "
"not known at program-writing time).  ``Enum`` allows such access::"
msgstr ""
"때로는 프로그래밍 방식으로 열거형의 멤버에 액세스하는 것이 유용합니다 (즉, 프로그램 작성 시간에 정확한 색상을 알 수 없어서 "
"``Color.RED``\\를 쓸 수 없는 상황). ``Enum``\\는 그런 액세스를 허용합니다::"

#: ../Doc/library/enum.rst:167
msgid "If you want to access enum members by *name*, use item access::"
msgstr "*이름(name)*\\으로 열거형 멤버에 액세스하려면, 항목 액세스를 사용하십시오::"

#: ../Doc/library/enum.rst:174
msgid "If you have an enum member and need its :attr:`name` or :attr:`value`::"
msgstr "열거형 멤버가 있고 :attr:`name`\\이나 :attr:`value`\\가 필요하면::"

#: ../Doc/library/enum.rst:184
msgid "Duplicating enum members and values"
msgstr "열거형 멤버와 값 중복하기"

#: ../Doc/library/enum.rst:186
msgid "Having two enum members with the same name is invalid::"
msgstr "이름이 같은 열거형 멤버가 두 개 있는 것은 유효하지 않습니다::"

#: ../Doc/library/enum.rst:196
msgid ""
"However, two enum members are allowed to have the same value.  Given two "
"members A and B with the same value (and A defined first), B is an alias "
"to A.  By-value lookup of the value of A and B will return A.  By-name "
"lookup of B will also return A::"
msgstr ""
"그러나, 두 열거형 멤버는 같은 값을 가질 수 있습니다. 같은 값을 가진 두 멤버 A와 B가 주어지면 (그리고 A가 먼저 "
"정의되면), B는 A의 별칭입니다. A와 B의 값을 통한 조회는 A를 반환합니다. B의 이름을 통한 조회도 A를 반환합니다::"

#: ../Doc/library/enum.rst:216
msgid ""
"Attempting to create a member with the same name as an already defined "
"attribute (another member, a method, etc.) or attempting to create an "
"attribute with the same name as a member is not allowed."
msgstr ""
"이미 정의된 어트리뷰트(다른 멤버, 메서드 등)와 같은 이름의 멤버를 만들려고 하거나 멤버와 같은 이름의 어트리뷰트를 만들려는 "
"시도는 허용되지 않습니다."

#: ../Doc/library/enum.rst:222
msgid "Ensuring unique enumeration values"
msgstr "고유한 열거형 값 보장하기"

#: ../Doc/library/enum.rst:224
msgid ""
"By default, enumerations allow multiple names as aliases for the same "
"value. When this behavior isn't desired, the following decorator can be "
"used to ensure each value is used only once in the enumeration:"
msgstr ""
"기본적으로, 열거형은 여러 이름을 같은 값에 대한 별칭으로 허용합니다. 이 동작이 바람직하지 않을 때, 다음 데코레이터를 사용하여 "
"각 값이 열거에서 한 번만 사용되도록 보장할 수 있습니다:"

#: ../Doc/library/enum.rst:230
msgid ""
"A :keyword:`class` decorator specifically for enumerations.  It searches "
"an enumeration's :attr:`__members__` gathering any aliases it finds; if "
"any are found :exc:`ValueError` is raised with the details::"
msgstr ""
"열거형 용 :keyword:`class` 데코레이터입니다. 열거형의 :attr:`__members__`\\를 검색하여 별칭을 "
"수집합니다; 발견되면 :exc:`ValueError`\\가 세부 정보와 함께 발생합니다::"

#: ../Doc/library/enum.rst:248
msgid "Using automatic values"
msgstr "자동 값 사용하기"

#: ../Doc/library/enum.rst:250
msgid "If the exact value is unimportant you can use :class:`auto`::"
msgstr "정확한 값이 중요하지 않으면, :class:`auto`\\를 사용할 수 있습니다::"

#: ../Doc/library/enum.rst:261
msgid ""
"The values are chosen by :func:`_generate_next_value_`, which can be "
"overridden::"
msgstr "값은 :func:`_generate_next_value_`\\에 의해 선택되는데, 재정의할 수 있습니다::"

#: ../Doc/library/enum.rst:279
#, fuzzy
msgid ""
"The goal of the default :meth:`_generate_next_value_` method is to "
"provide the next :class:`int` in sequence with the last :class:`int` "
"provided, but the way it does this is an implementation detail and may "
"change."
msgstr ""
"기본 :meth:`_generate_next_value_` 메서드의 목표는 제공된 마지막 :class:`int`\\와 연속되도록 "
"다음 :class:`int`\\를 제공하는 것이지만, 이를 수행하는 방법은 구현 세부 사항이며 변경될 수 있습니다."

#: ../Doc/library/enum.rst:285
msgid ""
"The :meth:`_generate_next_value_` method must be defined before any "
"members."
msgstr ":meth:`_generate_next_value_` 메서드는 다른 멤버보다 먼저 정의되어야 합니다."

#: ../Doc/library/enum.rst:288
msgid "Iteration"
msgstr "이터레이션"

#: ../Doc/library/enum.rst:290
msgid "Iterating over the members of an enum does not provide the aliases::"
msgstr "열거형 멤버를 이터레이트 해도 별칭은 제공되지 않습니다::"

#: ../Doc/library/enum.rst:295
msgid ""
"The special attribute ``__members__`` is a read-only ordered mapping of "
"names to members.  It includes all names defined in the enumeration, "
"including the aliases::"
msgstr ""
"특수 어트리뷰트 ``__members__``\\는 이름에서 멤버로의 읽기 전용 순서 있는 매핑입니다. 별칭을 포함하여, 열거형에 "
"정의된 모든 이름을 포함합니다::"

#: ../Doc/library/enum.rst:307
msgid ""
"The ``__members__`` attribute can be used for detailed programmatic "
"access to the enumeration members.  For example, finding all the "
"aliases::"
msgstr ""
"``__members__`` 어트리뷰트는 열거형 멤버에 대한 프로그래밍 방식의 자세한 액세스에 사용할 수 있습니다. 예를 들어, "
"모든 별칭 찾기::"

#: ../Doc/library/enum.rst:315
msgid "Comparisons"
msgstr "비교"

#: ../Doc/library/enum.rst:317
msgid "Enumeration members are compared by identity::"
msgstr "열거형 멤버는 아이덴티티로 비교됩니다::"

#: ../Doc/library/enum.rst:326
msgid ""
"Ordered comparisons between enumeration values are *not* supported.  Enum"
" members are not integers (but see `IntEnum`_ below)::"
msgstr ""
"열거형 값 사이의 순서 비교는 지원되지 *않습니다*. 열거형 멤버는 정수가 아닙니다 (그러나 아래의 `IntEnum`_\\을 "
"참조하십시오)::"

#: ../Doc/library/enum.rst:334
msgid "Equality comparisons are defined though::"
msgstr "동등 비교는 정의됩니다::"

#: ../Doc/library/enum.rst:343
msgid ""
"Comparisons against non-enumeration values will always compare not equal "
"(again, :class:`IntEnum` was explicitly designed to behave differently, "
"see below)::"
msgstr ""
"열거형 값이 아닌 값과의 비교는 항상 다르다고 비교됩니다 (다시, :class:`IntEnum`\\은 다르게 동작하도록 명시적으로 "
"설계되었습니다, 아래를 참조하십시오)::"

#: ../Doc/library/enum.rst:352
msgid "Allowed members and attributes of enumerations"
msgstr "열거형의 허용된 멤버와 어트리뷰트"

#: ../Doc/library/enum.rst:354
msgid ""
"The examples above use integers for enumeration values.  Using integers "
"is short and handy (and provided by default by the `Functional API`_), "
"but not strictly enforced.  In the vast majority of use-cases, one "
"doesn't care what the actual value of an enumeration is.  But if the "
"value *is* important, enumerations can have arbitrary values."
msgstr ""
"위의 예제는 열거형 값에 정수를 사용합니다. 정수 사용은 짧고 편리하지만 (`함수형 API <Functional "
"API_>`_\\에서 기본적으로 제공합니다), 엄격하게 강제하지는 않습니다. 대다수의 사용 사례에서, 열거의 실제 값이 무엇인지 "
"신경 쓰지 않습니다. 그러나 값이 *중요*\\하면, 열거형은 임의의 값을 가질 수 있습니다."

#: ../Doc/library/enum.rst:360
msgid ""
"Enumerations are Python classes, and can have methods and special methods"
" as usual.  If we have this enumeration::"
msgstr "열거형은 파이썬 클래스이며, 평소와 같이 메서드와 특수 메서드를 가질 수 있습니다. 이런 열거형이 있다고 합시다::"

#: ../Doc/library/enum.rst:380
msgid "Then::"
msgstr "그러면::"

#: ../Doc/library/enum.rst:389
msgid ""
"The rules for what is allowed are as follows: names that start and end "
"with a single underscore are reserved by enum and cannot be used; all "
"other attributes defined within an enumeration will become members of "
"this enumeration, with the exception of special methods (:meth:`__str__`,"
" :meth:`__add__`, etc.), descriptors (methods are also descriptors), and "
"variable names listed in :attr:`_ignore_`."
msgstr ""
"허용되는 규칙은 다음과 같습니다: 단일 밑줄로 시작하고 끝나는 이름은 enum이 예약하고 있고 사용할 수 없습니다; 열거형 내에 "
"정의된 다른 모든 어트리뷰트는 특수 메서드 (:meth:`__str__`, :meth:`__add__` 등), 디스크립터 (메서드도"
" 디스크립터입니다) 및 :attr:`_ignore_`\\에 나열된 변수 이름을 제외하고 이 열거의 멤버가 됩니다."

#: ../Doc/library/enum.rst:396
msgid ""
"Note:  if your enumeration defines :meth:`__new__` and/or "
":meth:`__init__` then any value(s) given to the enum member will be "
"passed into those methods. See `Planet`_ for an example."
msgstr ""
"참고: 열거형이 :meth:`__new__` 및/또는 :meth:`__init__`\\를 정의하면 열거형 멤버에 제공된 모든 값이 "
"해당 메서드에 전달됩니다. 예제는 `행성 <Planet_>`_\\을 참조하십시오."

#: ../Doc/library/enum.rst:402
msgid "Restricted Enum subclassing"
msgstr "제한된 Enum 서브 클래싱"

#: ../Doc/library/enum.rst:404
msgid ""
"A new :class:`Enum` class must have one base Enum class, up to one "
"concrete data type, and as many :class:`object`-based mixin classes as "
"needed.  The order of these base classes is::"
msgstr ""
"새로운 :class:`Enum` 클래스에는 하나의 베이스 Enum 클래스, 최대 하나의 구상 데이터형 및 필요한 만큼의 "
":class:`object` 기반 믹스인 클래스가 있어야 합니다. 이 베이스 클래스의 순서는 다음과 같습니다::"

#: ../Doc/library/enum.rst:411
msgid ""
"Also, subclassing an enumeration is allowed only if the enumeration does "
"not define any members.  So this is forbidden::"
msgstr "또한, 열거형의 서브 클래싱은 열거형이 멤버를 정의하지 않았을 때만 허용됩니다. 따라서 다음과 같은 것은 금지되어 있습니다::"

#: ../Doc/library/enum.rst:421
msgid "But this is allowed::"
msgstr "그러나 이것은 허용됩니다::"

#: ../Doc/library/enum.rst:432
msgid ""
"Allowing subclassing of enums that define members would lead to a "
"violation of some important invariants of types and instances.  On the "
"other hand, it makes sense to allow sharing some common behavior between "
"a group of enumerations. (See `OrderedEnum`_ for an example.)"
msgstr ""
"멤버를 정의하는 열거형의 서브 클래싱을 허용하면 형과 인스턴스의 중요한 불변성을 위반하게 됩니다. 반면에, 열거형 그룹 간에 "
"공통적인 동작을 공유하도록 허락하는 것은 말이 됩니다. (예는 `OrderedEnum`_\\을 참조하십시오.)"

#: ../Doc/library/enum.rst:439
msgid "Pickling"
msgstr "피클링"

#: ../Doc/library/enum.rst:441
msgid "Enumerations can be pickled and unpickled::"
msgstr "열거형은 피클링 되거나 역 피클링 될 수 있습니다::"

#: ../Doc/library/enum.rst:448
msgid ""
"The usual restrictions for pickling apply: picklable enums must be "
"defined in the top level of a module, since unpickling requires them to "
"be importable from that module."
msgstr ""
"피클링에 대한 일반적인 제한 사항이 적용됩니다: 역 피클링은 열거형을 모듈에서 임포트 할 수 있어야 하므로, 피클 가능한 열거형은 "
"모듈의 최상위 수준에서 정의해야 합니다."

#: ../Doc/library/enum.rst:454
msgid ""
"With pickle protocol version 4 it is possible to easily pickle enums "
"nested in other classes."
msgstr "피클 프로토콜 버전 4를 사용하면 다른 클래스에 중첩된 열거형을 쉽게 피클 할 수 있습니다."

#: ../Doc/library/enum.rst:457
msgid ""
"It is possible to modify how Enum members are pickled/unpickled by "
"defining :meth:`__reduce_ex__` in the enumeration class."
msgstr "열거형 클래스에 :meth:`__reduce_ex__`\\를 정의하여 Enum 멤버를 피클/역 피클 하는 방법을 수정할 수 있습니다."

#: ../Doc/library/enum.rst:462
msgid "Functional API"
msgstr "함수형 API"

#: ../Doc/library/enum.rst:464
msgid ""
"The :class:`Enum` class is callable, providing the following functional "
"API::"
msgstr ":class:`Enum` 클래스는 다음과 같은 함수형 API를 제공하는 콜러블입니다::"

#: ../Doc/library/enum.rst:476
msgid ""
"The semantics of this API resemble :class:`~collections.namedtuple`. The "
"first argument of the call to :class:`Enum` is the name of the "
"enumeration."
msgstr ""
"이 API의 의미는 :class:`~collections.namedtuple`\\과 유사합니다. :class:`Enum` 호출의 첫"
" 번째 인자는 열거형의 이름입니다."

#: ../Doc/library/enum.rst:479
msgid ""
"The second argument is the *source* of enumeration member names.  It can "
"be a whitespace-separated string of names, a sequence of names, a "
"sequence of 2-tuples with key/value pairs, or a mapping (e.g. dictionary)"
" of names to values.  The last two options enable assigning arbitrary "
"values to enumerations; the others auto-assign increasing integers "
"starting with 1 (use the ``start`` parameter to specify a different "
"starting value).  A new class derived from :class:`Enum` is returned.  In"
" other words, the above assignment to :class:`Animal` is equivalent to::"
msgstr ""
"두 번째 인자는 열거형 멤버 이름의 *소스*\\입니다. 공백으로 구분된 이름의 문자열, 이름의 시퀀스, 키/값 쌍 2-튜플의 시퀀스"
" 또는 이름에서 값으로의 매핑(예를 들어, 딕셔너리)일 수 있습니다. 마지막 두 옵션은 임의의 값을 열거형에 할당할 수 있게 "
"합니다; 나머지는 1부터 시작하여 증가하는 정수를 자동 할당합니다 ( 다른 시작 값을 지정하려면 ``start`` 매개 변수를 "
"사용하십시오). :class:`Enum`\\에서 파생된 새 클래스를 반환합니다. 즉, 위의 :class:`Animal` 대입은 "
"다음과 동등합니다::"

#: ../Doc/library/enum.rst:495
msgid ""
"The reason for defaulting to ``1`` as the starting number and not ``0`` "
"is that ``0`` is ``False`` in a boolean sense, but enum members all "
"evaluate to ``True``."
msgstr ""
"시작 번호로 ``0``\\이 아니라 ``1``\\을 기본값으로 설정하는 이유는 ``0``\\이 불리언 의미로 "
"``False``\\이지만 열거형 멤버는 모두 ``True``\\로 평가되기 때문입니다."

#: ../Doc/library/enum.rst:499
msgid ""
"Pickling enums created with the functional API can be tricky as frame "
"stack implementation details are used to try and figure out which module "
"the enumeration is being created in (e.g. it will fail if you use a "
"utility function in separate module, and also may not work on IronPython "
"or Jython). The solution is to specify the module name explicitly as "
"follows::"
msgstr ""
"함수형 API로 만든 열거형을 피클 하는 것은 까다로울 수 있는데, 프레임 스택 구현 세부 사항을 사용하여 열거형이 만들어지고 있는"
" 모듈을 파악하고 시도하기 때문입니다 (예를 들어, 별도의 모듈에 있는 유틸리티 함수를 사용하면 실패할 것이고. "
"IronPython이나 Jython에서는 작동하지 않을 수 있습니다). 해결책은 다음과 같이 모듈 이름을 명시적으로 지정하는 "
"것입니다::"

#: ../Doc/library/enum.rst:509
msgid ""
"If ``module`` is not supplied, and Enum cannot determine what it is, the "
"new Enum members will not be unpicklable; to keep errors closer to the "
"source, pickling will be disabled."
msgstr ""
"``module``\\이 제공되지 않고, Enum이 모듈을 판단할 수 없으면, 새 Enum 멤버는 역 피클 되지 않을 것입니다; "
"에러를 소스에 더 가깝게 유지하기 위해, 피클링이 비활성화됩니다."

#: ../Doc/library/enum.rst:513
msgid ""
"The new pickle protocol 4 also, in some circumstances, relies on "
":attr:`~definition.__qualname__` being set to the location where pickle "
"will be able to find the class.  For example, if the class was made "
"available in class SomeData in the global scope::"
msgstr ""
"새로운 피클 프로토콜 4는 일부 상황에서 :attr:`~definition.__qualname__`\\이 pickle이 클래스를 "
"찾을 수 있는 위치로 설정되는 것에 의존합니다. 예를 들어, 클래스가 전역 스코프의 SomeData 클래스 내에 만들어지면::"

#: ../Doc/library/enum.rst:520
msgid "The complete signature is::"
msgstr "완전한 서명은 다음과 같습니다::"

#: ../Doc/library/enum.rst
msgid "value"
msgstr "value"

#: ../Doc/library/enum.rst:524
msgid "What the new Enum class will record as its name."
msgstr "새 Enum 클래스가 자신의 이름으로 기록할 것."

#: ../Doc/library/enum.rst
msgid "names"
msgstr "names"

#: ../Doc/library/enum.rst:526
msgid ""
"The Enum members.  This can be a whitespace or comma separated string "
"(values will start at 1 unless otherwise specified)::"
msgstr "Enum 멤버. 공백이나 쉼표로 구분된 문자열일 수 있습니다 (지정하지 않는 한 값은 1부터 시작합니다)::"

#: ../Doc/library/enum.rst:531
msgid "or an iterator of names::"
msgstr "또는 이름의 이터레이터::"

#: ../Doc/library/enum.rst:535
msgid "or an iterator of (name, value) pairs::"
msgstr "또는 (이름, 값) 쌍의 이터레이터::"

#: ../Doc/library/enum.rst:539
msgid "or a mapping::"
msgstr "또는 매핑::"

#: ../Doc/library/enum.rst
msgid "module"
msgstr "module"

#: ../Doc/library/enum.rst:543
msgid "name of module where new Enum class can be found."
msgstr "새로운 Enum 클래스를 찾을 수 있는 모듈의 이름."

#: ../Doc/library/enum.rst
msgid "qualname"
msgstr "qualname"

#: ../Doc/library/enum.rst:545
msgid "where in module new Enum class can be found."
msgstr "모듈에서 새로운 Enum 클래스를 찾을 수 있는 곳."

#: ../Doc/library/enum.rst
msgid "type"
msgstr "type"

#: ../Doc/library/enum.rst:547
msgid "type to mix in to new Enum class."
msgstr "새로운 Enum 클래스와 혼합할 형."

#: ../Doc/library/enum.rst
msgid "start"
msgstr "start"

#: ../Doc/library/enum.rst:549
msgid "number to start counting at if only names are passed in."
msgstr "이름 만 전달될 때 세기 시작할 숫자."

#: ../Doc/library/enum.rst:551
msgid "The *start* parameter was added."
msgstr "*start* 매개 변수가 추가되었습니다."

#: ../Doc/library/enum.rst:556
msgid "Derived Enumerations"
msgstr "파생된 열거형"

#: ../Doc/library/enum.rst:559
msgid "IntEnum"
msgstr "IntEnum"

#: ../Doc/library/enum.rst:561
msgid ""
"The first variation of :class:`Enum` that is provided is also a subclass "
"of :class:`int`.  Members of an :class:`IntEnum` can be compared to "
"integers; by extension, integer enumerations of different types can also "
"be compared to each other::"
msgstr ""
"제공되는 첫 번째 :class:`Enum`\\의 변형은 :class:`int`\\의 서브 클래스이기도 합니다. "
":class:`IntEnum`\\의 멤버는 정수와 비교할 수 있습니다; 확장하여, 다른 정수 열거형도 서로 비교할 수 있습니다::"

#: ../Doc/library/enum.rst:582
msgid ""
"However, they still can't be compared to standard :class:`Enum` "
"enumerations::"
msgstr "그러나, 여전히 표준 :class:`Enum` 열거형과 비교할 수는 없습니다::"

#: ../Doc/library/enum.rst:595
msgid ":class:`IntEnum` values behave like integers in other ways you'd expect::"
msgstr ":class:`IntEnum` 값은 여러분이 기대하는 다른 방식으로 정수처럼 동작합니다::"

#: ../Doc/library/enum.rst:606
msgid "IntFlag"
msgstr "IntFlag"

#: ../Doc/library/enum.rst:608
msgid ""
"The next variation of :class:`Enum` provided, :class:`IntFlag`, is also "
"based on :class:`int`.  The difference being :class:`IntFlag` members can"
" be combined using the bitwise operators (&, \\|, ^, ~) and the result is"
" still an :class:`IntFlag` member.  However, as the name implies, "
":class:`IntFlag` members also subclass :class:`int` and can be used "
"wherever an :class:`int` is used.  Any operation on an :class:`IntFlag` "
"member besides the bit-wise operations will lose the :class:`IntFlag` "
"membership."
msgstr ""
"제공된 :class:`Enum`\\의 다음 변형인 :class:`IntFlag`\\도 :class:`int`\\를 기반으로 합니다."
" 차이점은, :class:`IntFlag` 멤버는 비트 연산자(&, \\|, ^, ~)를 사용하여 결합할 수 있으며 결과는 여전히 "
":class:`IntFlag` 멤버라는 것입니다. 그러나, 이름에서 알 수 있듯이, :class:`IntFlag` 멤버는 "
":class:`int`\\를 서브 클래스하고 :class:`int`\\가 사용되는 모든 곳에서 사용할 수 있습니다. 비트별 연산 "
"이외의 :class:`IntFlag` 멤버에 대한 모든 연산은 :class:`IntFlag` 멤버 자격을 잃게 만듭니다."

#: ../Doc/library/enum.rst:618
msgid "Sample :class:`IntFlag` class::"
msgstr "예제 :class:`IntFlag` 클래스::"

#: ../Doc/library/enum.rst:634
msgid "It is also possible to name the combinations::"
msgstr "조합의 이름을 지정할 수도 있습니다::"

#: ../Doc/library/enum.rst:646
msgid ""
"Another important difference between :class:`IntFlag` and :class:`Enum` "
"is that if no flags are set (the value is 0), its boolean evaluation is "
":data:`False`::"
msgstr ""
":class:`IntFlag`\\과 :class:`Enum`\\의 또 다른 중요한 차이점은 아무런 플래그도 설정되지 않으면 (값이 "
"0입니다) 불리언 평가가 :data:`False`\\가 된다는 것입니다::"

#: ../Doc/library/enum.rst:654
msgid ""
"Because :class:`IntFlag` members are also subclasses of :class:`int` they"
" can be combined with them::"
msgstr ":class:`IntFlag` 멤버도 :class:`int`\\의 서브 클래스이므로 정수와 결합할 수 있습니다::"

#: ../Doc/library/enum.rst:662
msgid "Flag"
msgstr "Flag"

#: ../Doc/library/enum.rst:664
msgid ""
"The last variation is :class:`Flag`.  Like :class:`IntFlag`, "
":class:`Flag` members can be combined using the bitwise operators (&, "
"\\|, ^, ~).  Unlike :class:`IntFlag`, they cannot be combined with, nor "
"compared against, any other :class:`Flag` enumeration, nor :class:`int`."
"  While it is possible to specify the values directly it is recommended "
"to use :class:`auto` as the value and let :class:`Flag` select an "
"appropriate value."
msgstr ""
"마지막 변형은 :class:`Flag`\\입니다. :class:`IntFlag`\\와 마찬가지로, :class:`Flag` 멤버는 "
"비트 연산자(&, \\|, ^, ~)를 사용하여 결합할 수 있습니다. :class:`IntFlag`\\와 달리, 다른 "
":class:`Flag` 열거형이나 :class:`int`\\와 결합하거나 비교할 수 없습니다. 값을 직접 지정할 수는 있지만, "
":class:`auto`\\를 값으로 사용하고 :class:`Flag`\\가 적절한 값을 선택하도록 하는 것이 좋습니다."

#: ../Doc/library/enum.rst:673
msgid ""
"Like :class:`IntFlag`, if a combination of :class:`Flag` members results "
"in no flags being set, the boolean evaluation is :data:`False`::"
msgstr ""
":class:`IntFlag`\\와 마찬가지로, :class:`Flag` 멤버의 조합이 아무런 플래그도 설정하지 않으면, 불리언 "
"평가는 :data:`False`\\입니다::"

#: ../Doc/library/enum.rst:687
msgid ""
"Individual flags should have values that are powers of two (1, 2, 4, 8, "
"...), while combinations of flags won't::"
msgstr "개별 플래그는 2의 거듭제곱 값(1, 2, 4, 8, ...)을 가져야 하지만, 플래그의 조합은 그렇지 않습니다::"

#: ../Doc/library/enum.rst:699
msgid ""
"Giving a name to the \"no flags set\" condition does not change its "
"boolean value::"
msgstr "\"플래그 설정 없음\" 조건에 이름을 부여해도 불리언 값은 변경되지 않습니다::"

#: ../Doc/library/enum.rst:715
msgid ""
"For the majority of new code, :class:`Enum` and :class:`Flag` are "
"strongly recommended, since :class:`IntEnum` and :class:`IntFlag` break "
"some semantic promises of an enumeration (by being comparable to "
"integers, and thus by transitivity to other unrelated enumerations).  "
":class:`IntEnum` and :class:`IntFlag` should be used only in cases where "
":class:`Enum` and :class:`Flag` will not do; for example, when integer "
"constants are replaced with enumerations, or for interoperability with "
"other systems."
msgstr ""
":class:`IntEnum`\\과 :class:`IntFlag`\\는 열거형에 대한 의미론적 약속을 깨뜨리기 때문에 (정수와 "
"비교할 수 있어서, 다른 관련되지 않은 열거형으로의 추이성(transitivity)으로 인해), 새로운 코드 대부분에는 "
":class:`Enum`\\과 :class:`Flag`\\를 강력히 권장합니다. :class:`IntEnum`\\과 "
":class:`IntFlag`\\는 :class:`Enum`\\과 :class:`Flag`\\가 동작하지 않는 경우에만 사용해야 "
"합니다; 예를 들어, 정수 상수가 열거형으로 대체되거나, 다른 시스템과의 상호 운용성을 위해."

#: ../Doc/library/enum.rst:725
msgid "Others"
msgstr "기타"

#: ../Doc/library/enum.rst:727
msgid ""
"While :class:`IntEnum` is part of the :mod:`enum` module, it would be "
"very simple to implement independently::"
msgstr ":class:`IntEnum`\\은 :mod:`enum` 모듈의 일부이지만, 독립적으로 구현하는 것은 매우 간단합니다::"

#: ../Doc/library/enum.rst:733
msgid ""
"This demonstrates how similar derived enumerations can be defined; for "
"example a :class:`StrEnum` that mixes in :class:`str` instead of "
":class:`int`."
msgstr ""
"이것은 유사한 파생된 열거형을 정의 할 수 있는 방법을 보여줍니다; 예를 들어 :class:`int` 대신 "
":class:`str`\\로 혼합되는 :class:`StrEnum`."

#: ../Doc/library/enum.rst:736
msgid "Some rules:"
msgstr "몇 가지 규칙:"

#: ../Doc/library/enum.rst:738
msgid ""
"When subclassing :class:`Enum`, mix-in types must appear before "
":class:`Enum` itself in the sequence of bases, as in the :class:`IntEnum`"
" example above."
msgstr ""
":class:`Enum`\\을 서브 클래싱 할 때, 위의 :class:`IntEnum` 예제에서처럼, 혼합(mix-in)형은 베이스"
" 시퀀스에서 :class:`Enum` 앞에 나타나야 합니다."

#: ../Doc/library/enum.rst:741
msgid ""
"While :class:`Enum` can have members of any type, once you mix in an "
"additional type, all the members must have values of that type, e.g. "
":class:`int` above.  This restriction does not apply to mix-ins which "
"only add methods and don't specify another type."
msgstr ""
":class:`Enum`\\은 모든 형의 멤버를 가질 수 있지만, 일단 추가 형을 혼합하면, 모든 멤버는 해당 형의 값을 가져야 "
"합니다, 예를 들어 위의 :class:`int`. 이 제한은 메서드만 추가할 뿐 다른 형을 지정하지 않는 믹스인에는 적용되지 "
"않습니다."

#: ../Doc/library/enum.rst:745
msgid ""
"When another data type is mixed in, the :attr:`value` attribute is *not "
"the same* as the enum member itself, although it is equivalent and will "
"compare equal."
msgstr ""
"다른 데이터형이 혼합될 때, :attr:`value` 어트리뷰트는 열거형 멤버 자체와 *같지 않지*\\만, 동등하고 같다고 "
"비교됩니다."

#: ../Doc/library/enum.rst:748
#, python-format
msgid ""
"%-style formatting:  `%s` and `%r` call the :class:`Enum` class's "
":meth:`__str__` and :meth:`__repr__` respectively; other codes (such as "
"`%i` or `%h` for IntEnum) treat the enum member as its mixed-in type."
msgstr ""
"%-스타일 포매팅: `%s` 와 `%r` 은 각각 :class:`Enum` 클래스의 :meth:`__str__`\\과 "
":meth:`__repr__`\\을 호출합니다; 다른 코드(가령 IntEnum의 경우 `%i` 나 `%h`)는 열거형 멤버를 "
"혼합형으로 취급합니다."

#: ../Doc/library/enum.rst:751
msgid ""
":ref:`Formatted string literals <f-strings>`, :meth:`str.format`, and "
":func:`format` will use the mixed-in type's :meth:`__format__` unless "
":meth:`__str__` or :meth:`__format__` is overridden in the subclass, in "
"which case the overridden methods or :class:`Enum` methods will be used. "
"Use the !s and !r format codes to force usage of the :class:`Enum` "
"class's :meth:`__str__` and :meth:`__repr__` methods."
msgstr ""
":ref:`포맷 문자열 리터럴 <f-strings>`, :meth:`str.format` 및 :func:`format`\\은 "
"혼합형의 :meth:`__format__`\\을 사용합니다. 하지만, 서브 클래스에서 :meth:`__str__`\\이나 "
":meth:`__format__`\\이 재정의되면, 재정의된 메서드나 :class:`Enum` 메소드가 사용됩니다. "
":class:`Enum` 클래스의 :meth:`__str__`\\과 :meth:`__repr__` 메서드의 사용을 강제하려면 !s "
"과 !r 포맷 코드를 사용하십시오."

#: ../Doc/library/enum.rst:759
msgid "When to use :meth:`__new__` vs. :meth:`__init__`"
msgstr ":meth:`__new__`\\나 :meth:`__init__`\\를 사용할 때"

#: ../Doc/library/enum.rst:761
msgid ""
":meth:`__new__` must be used whenever you want to customize the actual "
"value of the :class:`Enum` member.  Any other modifications may go in "
"either :meth:`__new__` or :meth:`__init__`, with :meth:`__init__` being "
"preferred."
msgstr ""
":class:`Enum` 멤버의 실제 값을 사용자 정의하려면 :meth:`__new__`\\를 사용해야 합니다. 다른 수정은 "
":meth:`__new__`\\나 :meth:`__init__`\\를 사용할 수 있지만, :meth:`__init__`\\가 "
"바람직합니다."

#: ../Doc/library/enum.rst:765
msgid ""
"For example, if you want to pass several items to the constructor, but "
"only want one of them to be the value::"
msgstr "예를 들어, 여러 항목을 생성자에 전달하고 싶지만, 그중 하나만 값이 되도록 하려면 다음과 같이 합니다::"

#: ../Doc/library/enum.rst:791
msgid "Interesting examples"
msgstr "흥미로운 예"

#: ../Doc/library/enum.rst:793
msgid ""
"While :class:`Enum`, :class:`IntEnum`, :class:`IntFlag`, and "
":class:`Flag` are expected to cover the majority of use-cases, they "
"cannot cover them all.  Here are recipes for some different types of "
"enumerations that can be used directly, or as examples for creating one's"
" own."
msgstr ""
":class:`Enum`, :class:`IntEnum`, :class:`IntFlag` 및 :class:`Flag`\\는 대부분의"
" 사용 사례를 포괄할 것으로 예상되지만, 모든 사용 사례를 포괄할 수는 없습니다. 다음은 직접 혹은 자신의 것을 만드는 예제로 "
"사용할 수 있는 여러 유형의 열거형에 대한 조리법입니다."

#: ../Doc/library/enum.rst:800
msgid "Omitting values"
msgstr "값 생략하기"

#: ../Doc/library/enum.rst:802
msgid ""
"In many use-cases one doesn't care what the actual value of an "
"enumeration is. There are several ways to define this type of simple "
"enumeration:"
msgstr "많은 사용 사례에서 열거형의 실제 값이 무엇인지 신경 쓰지 않습니다. 이런 유형의 간단한 열거형을 정의하는 몇 가지 방법이 있습니다:"

#: ../Doc/library/enum.rst:805
msgid "use instances of :class:`auto` for the value"
msgstr ":class:`auto`\\의 인스턴스를 값으로 사용합니다"

#: ../Doc/library/enum.rst:806
msgid "use instances of :class:`object` as the value"
msgstr ":class:`object` 인스턴스를 값으로 사용합니다"

#: ../Doc/library/enum.rst:807
msgid "use a descriptive string as the value"
msgstr "설명 문자열을 값으로 사용합니다"

#: ../Doc/library/enum.rst:808
msgid ""
"use a tuple as the value and a custom :meth:`__new__` to replace the "
"tuple with an :class:`int` value"
msgstr "튜플을 값으로 사용하고 사용자 정의 :meth:`__new__`\\를 사용하여 튜플을 :class:`int` 값으로 대체합니다"

#: ../Doc/library/enum.rst:811
msgid ""
"Using any of these methods signifies to the user that these values are "
"not important, and also enables one to add, remove, or reorder members "
"without having to renumber the remaining members."
msgstr ""
"이러한 방법의 하나를 사용하는 것은 사용자에게 이러한 값이 중요하지 않다고 알리고, 나머지 멤버의 번호를 다시 매길 필요 없이 "
"멤버를 추가, 제거 또는 재정렬 할 수 있도록 합니다."

#: ../Doc/library/enum.rst:815
msgid ""
"Whichever method you choose, you should provide a :meth:`repr` that also "
"hides the (unimportant) value::"
msgstr "어떤 방법을 선택하든, (중요하지 않은) 값을 숨기는 :meth:`repr`\\을 제공해야 합니다::"

#: ../Doc/library/enum.rst:825
msgid "Using :class:`auto`"
msgstr ":class:`auto` 사용하기"

#: ../Doc/library/enum.rst:827
msgid "Using :class:`auto` would look like::"
msgstr ":class:`auto`\\를 사용하면 이렇게 됩니다::"

#: ../Doc/library/enum.rst:839
msgid "Using :class:`object`"
msgstr ":class:`object` 사용하기"

#: ../Doc/library/enum.rst:841
msgid "Using :class:`object` would look like::"
msgstr ":class:`object`\\를 사용하면 이렇게 됩니다::"

#: ../Doc/library/enum.rst:853
msgid "Using a descriptive string"
msgstr "설명 문자열 사용하기"

#: ../Doc/library/enum.rst:855
msgid "Using a string as the value would look like::"
msgstr "문자열을 값으로 사용하면 이렇게 됩니다::"

#: ../Doc/library/enum.rst:869
msgid "Using a custom :meth:`__new__`"
msgstr "사용자 정의 :meth:`__new__` 사용하기"

#: ../Doc/library/enum.rst:871
msgid "Using an auto-numbering :meth:`__new__` would look like::"
msgstr "자동 번호 매기기 :meth:`__new__`\\를 사용하면 이렇게 됩니다::"

#: ../Doc/library/enum.rst:890
msgid ""
"To make a more general purpose ``AutoNumber``, add ``*args`` to the "
"signature::"
msgstr "더 범용의 ``AutoNumber``\\를 만들려면, 서명에 ``*args``\\를 추가합니다::"

#: ../Doc/library/enum.rst:900
msgid ""
"Then when you inherit from ``AutoNumber`` you can write your own "
"``__init__`` to handle any extra arguments::"
msgstr ""
"그런 다음 ``AutoNumber``\\에서 상속할 때 추가 인자를 처리하기 위해 자체 ``__init__``\\를 작성할 수 "
"있습니다::"

#: ../Doc/library/enum.rst:919
msgid ""
"The :meth:`__new__` method, if defined, is used during creation of the "
"Enum members; it is then replaced by Enum's :meth:`__new__` which is used"
" after class creation for lookup of existing members."
msgstr ""
"정의되면, :meth:`__new__` 메서드는 Enum 멤버 생성 중에 사용됩니다; 그런 다음 Enum의 "
":meth:`__new__`\\로 대체되는데, 이것이 클래스 생성 후에 기존 멤버를 조회하기 위해 사용됩니다."

#: ../Doc/library/enum.rst:925
msgid "OrderedEnum"
msgstr "OrderedEnum"

#: ../Doc/library/enum.rst:927
msgid ""
"An ordered enumeration that is not based on :class:`IntEnum` and so "
"maintains the normal :class:`Enum` invariants (such as not being "
"comparable to other enumerations)::"
msgstr ""
":class:`IntEnum`\\에 기반하지 않기 때문에 일반적인 :class:`Enum` 불변성(invariants) (가령 다른"
" 열거형과 비교할 수 없다는 성질) 을 유지하는 순서 있는 열거형::"

#: ../Doc/library/enum.rst:961
msgid "DuplicateFreeEnum"
msgstr "DuplicateFreeEnum"

#: ../Doc/library/enum.rst:963
msgid ""
"Raises an error if a duplicate member name is found instead of creating "
"an alias::"
msgstr "중복된 멤버 이름이 발견되면 별칭을 만드는 대신 에러를 발생시킵니다::"

#: ../Doc/library/enum.rst:988
msgid ""
"This is a useful example for subclassing Enum to add or change other "
"behaviors as well as disallowing aliases.  If the only desired change is "
"disallowing aliases, the :func:`unique` decorator can be used instead."
msgstr ""
"이것은 별칭을 허락하지 않는 것뿐 아니라 Enum을 서브 클래싱하여 다른 동작을 추가하거나 변경하는 유용한 예입니다. 원하는 변경이"
" 오직 별칭을 허용하지 않는 것이면, :func:`unique` 데코레이터를 대신 사용할 수 있습니다."

#: ../Doc/library/enum.rst:994
msgid "Planet"
msgstr "행성"

#: ../Doc/library/enum.rst:996
msgid ""
"If :meth:`__new__` or :meth:`__init__` is defined the value of the enum "
"member will be passed to those methods::"
msgstr ":meth:`__new__`\\나 :meth:`__init__`\\가 정의되면 열거형 멤버의 값이 해당 메서드로 전달됩니다::"

#: ../Doc/library/enum.rst:1024
msgid "TimePeriod"
msgstr "TimePeriod"

#: ../Doc/library/enum.rst:1026
msgid "An example to show the :attr:`_ignore_` attribute in use::"
msgstr ":attr:`_ignore_` 어트리뷰트의 사용을 보여주는 예::"

#: ../Doc/library/enum.rst:1043
msgid "How are Enums different?"
msgstr "열거형은 어떻게 다릅니까?"

#: ../Doc/library/enum.rst:1045
msgid ""
"Enums have a custom metaclass that affects many aspects of both derived "
"Enum classes and their instances (members)."
msgstr "열거형은 파생된 Enum 클래스와 그들의 인스턴스(멤버)의 여러 측면에 영향을 주는 사용자 정의 메타 클래스를 갖습니다."

#: ../Doc/library/enum.rst:1050
msgid "Enum Classes"
msgstr "열거형 클래스"

#: ../Doc/library/enum.rst:1052
msgid ""
"The :class:`EnumMeta` metaclass is responsible for providing the "
":meth:`__contains__`, :meth:`__dir__`, :meth:`__iter__` and other methods"
" that allow one to do things with an :class:`Enum` class that fail on a "
"typical class, such as `list(Color)` or `some_enum_var in Color`.  "
":class:`EnumMeta` is responsible for ensuring that various other methods "
"on the final :class:`Enum` class are correct (such as :meth:`__new__`, "
":meth:`__getnewargs__`, :meth:`__str__` and :meth:`__repr__`)."
msgstr ""
":class:`EnumMeta` 메타 클래스는 `list(Color)`\\나 `some_enum_var in Color`\\와 같은"
" 일반적인 클래스에서 실패하는 연산을 :class:`Enum` 클래스로 할 수 있도록 하는 :meth:`__contains__`, "
":meth:`__dir__`, :meth:`__iter__` 및 기타 메서드를 제공합니다. :class:`EnumMeta`\\는 "
"최종 :class:`Enum` 클래스의 다양한 다른 메서드(가령 :meth:`__new__`, "
":meth:`__getnewargs__`, :meth:`__str__` 및 :meth:`__repr__`)가 올바른지 확인합니다."

#: ../Doc/library/enum.rst:1062
msgid "Enum Members (aka instances)"
msgstr "열거형 멤버 (일명 인스턴스)"

#: ../Doc/library/enum.rst:1064
msgid ""
"The most interesting thing about Enum members is that they are "
"singletons. :class:`EnumMeta` creates them all while it is creating the "
":class:`Enum` class itself, and then puts a custom :meth:`__new__` in "
"place to ensure that no new ones are ever instantiated by returning only "
"the existing member instances."
msgstr ""
"Enum 멤버에 대한 가장 흥미로운 점은 싱글톤이라는 것입니다. :class:`EnumMeta`\\는 :class:`Enum` "
"클래스 자체를 만드는 동안 멤버를 모두 만든 다음, 사용자 정의 :meth:`__new__`\\를 넣어서 기존 멤버 인스턴스만 "
"반환하여 더는 새 인스턴스가 만들어지지 않도록 합니다."

#: ../Doc/library/enum.rst:1072
msgid "Finer Points"
msgstr "세부 사항"

#: ../Doc/library/enum.rst:1075
msgid "Supported ``__dunder__`` names"
msgstr "지원되는 ``__dunder__`` 이름"

#: ../Doc/library/enum.rst:1077
msgid ""
":attr:`__members__` is a read-only ordered mapping of "
"``member_name``:``member`` items.  It is only available on the class."
msgstr ""
":attr:`__members__`\\는 ``member_name``:``member`` 항목의 읽기 전용 순서 있는 매핑입니다. "
"클래스에서만 이용할 수 있습니다."

#: ../Doc/library/enum.rst:1080
msgid ""
":meth:`__new__`, if specified, must create and return the enum members; "
"it is also a very good idea to set the member's :attr:`_value_` "
"appropriately.  Once all the members are created it is no longer used."
msgstr ""
"지정된다면, :meth:`__new__`\\는 열거형 멤버를 만들고 반환해야 합니다; 멤버의 :attr:`_value_`\\를 "
"적절하게 설정하는 것도 좋습니다. 일단 모든 멤버가 만들어지면 더는 사용되지 않습니다."

#: ../Doc/library/enum.rst:1086
msgid "Supported ``_sunder_`` names"
msgstr "지원되는 ``_sunder_`` 이름"

#: ../Doc/library/enum.rst:1088
msgid "``_name_`` -- name of the member"
msgstr "``_name_`` -- 멤버의 이름"

#: ../Doc/library/enum.rst:1089
msgid "``_value_`` -- value of the member; can be set / modified in ``__new__``"
msgstr "``_value_`` -- 멤버의 값; ``__new__``\\에서 설정/수정할 수 있습니다"

#: ../Doc/library/enum.rst:1091
msgid ""
"``_missing_`` -- a lookup function used when a value is not found; may be"
" overridden"
msgstr "``_missing_`` -- 값을 찾을 수 없을 때 사용되는 조회 함수; 재정의할 수 있습니다"

#: ../Doc/library/enum.rst:1093
msgid ""
"``_ignore_`` -- a list of names, either as a :class:`list` or a "
":class:`str`, that will not be transformed into members, and will be "
"removed from the final class"
msgstr ""
"``_ignore_`` -- 멤버로 변환되지 않고 최종 클래스에서 제거될 :class:`list`\\나 :class:`str` 형의"
" 이름 목록"

#: ../Doc/library/enum.rst:1096
msgid ""
"``_order_`` -- used in Python 2/3 code to ensure member order is "
"consistent (class attribute, removed during class creation)"
msgstr ""
"``_order_`` -- 파이썬 2/3 코드에서 멤버 순서의 일관성을 유지하기 위해 사용됩니다 (클래스 생성 중 제거되는 클래스 "
"어트리뷰트)"

#: ../Doc/library/enum.rst:1098
msgid ""
"``_generate_next_value_`` -- used by the `Functional API`_ and by "
":class:`auto` to get an appropriate value for an enum member; may be "
"overridden"
msgstr ""
"``_generate_next_value_`` -- 열거형 멤버에 대한 적절한 값을 얻기 위해 `함수형 API <Functional"
" API_>`_\\와 :class:`auto`\\에서 사용합니다; 재정의할 수 있습니다"

#: ../Doc/library/enum.rst:1102
msgid "``_missing_``, ``_order_``, ``_generate_next_value_``"
msgstr "``_missing_``, ``_order_``, ``_generate_next_value_``"

#: ../Doc/library/enum.rst:1103
msgid "``_ignore_``"
msgstr "``_ignore_``"

#: ../Doc/library/enum.rst:1105
msgid ""
"To help keep Python 2 / Python 3 code in sync an :attr:`_order_` "
"attribute can be provided.  It will be checked against the actual order "
"of the enumeration and raise an error if the two do not match::"
msgstr ""
"파이썬 2 / 파이썬 3 코드를 동기화 상태로 유지하기 위해 :attr:`_order_` 어트리뷰트를 제공 할 수 있습니다. "
"열거형의 실제 순서와 비교하여 확인되며 일치하지 않으면 에러가 발생합니다::"

#: ../Doc/library/enum.rst:1121
msgid ""
"In Python 2 code the :attr:`_order_` attribute is necessary as definition"
" order is lost before it can be recorded."
msgstr "파이썬 2 코드에서는 정의 순서가 기록될 수 있기 전에 손실되기 때문에 :attr:`_order_` 어트리뷰트가 필요합니다."

#: ../Doc/library/enum.rst:1126
msgid "_Private__names"
msgstr ""

#: ../Doc/library/enum.rst:1128
msgid ""
"Private names will be normal attributes in Python 3.10 instead of either "
"an error or a member (depending on if the name ends with an underscore). "
"Using these names in 3.9 will issue a :exc:`DeprecationWarning`."
msgstr ""

#: ../Doc/library/enum.rst:1134
msgid "``Enum`` member type"
msgstr "``Enum`` 멤버 형"

#: ../Doc/library/enum.rst:1136
msgid ""
":class:`Enum` members are instances of their :class:`Enum` class, and are"
" normally accessed as ``EnumClass.member``.  Under certain circumstances "
"they can also be accessed as ``EnumClass.member.member``, but you should "
"never do this as that lookup may fail or, worse, return something besides"
" the :class:`Enum` member you are looking for (this is another good "
"reason to use all-uppercase names for members)::"
msgstr ""
":class:`Enum` 멤버는 :class:`Enum` 클래스의 인스턴스이며, 일반적으로 "
"``EnumClass.member``\\로 액세스 됩니다. 특정 상황에서는 ``EnumClass.member.member``\\로 "
"액세스 할 수 있지만, 조회가 실패하거나 더 나쁜 경우 찾고 있는 :class:`Enum` 멤버 이외의 것을 반환할 수 있기 때문에"
" 이 작업을 수행해서는 안 됩니다 (이것은 멤버에 모두 대문자로 구성된 이름을 사용하는 또 하나의 이유입니다)::"

#: ../Doc/library/enum.rst:1157
msgid "Boolean value of ``Enum`` classes and members"
msgstr "``Enum`` 클래스와 멤버의 불리언 값"

#: ../Doc/library/enum.rst:1159
msgid ""
":class:`Enum` members that are mixed with non-:class:`Enum` types (such "
"as :class:`int`, :class:`str`, etc.) are evaluated according to the "
"mixed-in type's rules; otherwise, all members evaluate as :data:`True`.  "
"To make your own Enum's boolean evaluation depend on the member's value "
"add the following to your class::"
msgstr ""
"비 :class:`Enum` 형(가령 :class:`int`, :class:`str` 등)과 혼합된 :class:`Enum` 멤버는"
" 혼합형의 규칙에 따라 평가됩니다; 그렇지 않으면, 모든 멤버가 :data:`True`\\로 평가됩니다. 여러분 자신의 Enum의 "
"불리언 평가를 멤버의 값에 따르게 하려면 클래스에 다음을 추가하십시오::"

#: ../Doc/library/enum.rst:1168
msgid ":class:`Enum` classes always evaluate as :data:`True`."
msgstr ":class:`Enum` 클래스는 항상 :data:`True`\\로 평가됩니다."

#: ../Doc/library/enum.rst:1172
msgid "``Enum`` classes with methods"
msgstr "메서드가 있는 ``Enum`` 클래스"

#: ../Doc/library/enum.rst:1174
msgid ""
"If you give your :class:`Enum` subclass extra methods, like the `Planet`_"
" class above, those methods will show up in a :func:`dir` of the member, "
"but not of the class::"
msgstr ""
":class:`Enum` 서브 클래스에 위의 `Planet`_ 클래스처럼 추가 메서드를 제공하면, 해당 메서드는 멤버의 "
":func:`dir`\\에 표시되지만, 클래스에서는 표시되지 않습니다::"

#: ../Doc/library/enum.rst:1185
msgid "Combining members of ``Flag``"
msgstr "``Flag`` 멤버를 결합하기"

#: ../Doc/library/enum.rst:1187
msgid ""
"If a combination of Flag members is not named, the :func:`repr` will "
"include all named flags and all named combinations of flags that are in "
"the value::"
msgstr ""
"Flag 멤버 조합의 이름이 지정되지 않으면, :func:`repr`\\은 모든 이름 지정된 플래그와 값에 있는 플래그의 모든 이름"
" 지정된 조합을 포함합니다::"

