# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-12-12 08:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/argparse.rst:2
msgid ""
":mod:`argparse` --- Parser for command-line options, arguments and sub-"
"commands"
msgstr ":mod:`argparse` --- 명령행 옵션, 인자와 부속 명령을 위한 파서"

#: ../Doc/library/argparse.rst:12
msgid "**Source code:** :source:`Lib/argparse.py`"
msgstr "**소스 코드:** :source:`Lib/argparse.py`"

msgid "Tutorial"
msgstr "자습서"

#: ../Doc/library/argparse.rst:18
msgid ""
"This page contains the API reference information. For a more gentle "
"introduction to Python command-line parsing, have a look at the "
":ref:`argparse tutorial <argparse-tutorial>`."
msgstr ""
"이 페이지는 API 레퍼런스 정보를 담고 있습니다. 파이썬 명령행 파싱에 대한 더 친절한 소개를 원하시면, "
":ref:`argparse 자습서 <argparse-tutorial>` 를 보십시오."

#: ../Doc/library/argparse.rst:22
msgid ""
"The :mod:`argparse` module makes it easy to write user-friendly command-"
"line interfaces. The program defines what arguments it requires, and "
":mod:`argparse` will figure out how to parse those out of "
":data:`sys.argv`.  The :mod:`argparse` module also automatically "
"generates help and usage messages and issues errors when users give the "
"program invalid arguments."
msgstr ""
":mod:`argparse` 모듈은 사용자 친화적인 명령행 인터페이스를 쉽게 작성하도록 합니다. 프로그램이 필요한 인자를 정의하면,"
" :mod:`argparse` 는 :data:`sys.argv` 를 어떻게 파싱할지 파악합니다. 또한 :mod:`argparse` "
"모듈은 도움말과 사용법 메시지를 자동 생성하고, 사용자가 프로그램에 잘못된 인자를 줄 때 에러를 발생시킵니다."

#: ../Doc/library/argparse.rst:30
msgid "Example"
msgstr "예"

#: ../Doc/library/argparse.rst:32
msgid ""
"The following code is a Python program that takes a list of integers and "
"produces either the sum or the max::"
msgstr "다음 코드는 정수 목록을 받아 합계 또는 최댓값을 출력하는 파이썬 프로그램입니다::"

#: ../Doc/library/argparse.rst:47
msgid ""
"Assuming the Python code above is saved into a file called ``prog.py``, "
"it can be run at the command line and provides useful help messages:"
msgstr ""
"위의 파이썬 코드가 ``prog.py`` 라는 파일에 저장되었다고 가정할 때, 명령행에서 실행되고 유용한 도움말 메시지를 제공할 수"
" 있습니다:"

#: ../Doc/library/argparse.rst:64
msgid ""
"When run with the appropriate arguments, it prints either the sum or the "
"max of the command-line integers:"
msgstr "적절한 인자로 실행하면 명령행 정수의 합계 또는 최댓값을 인쇄합니다.:"

#: ../Doc/library/argparse.rst:75
msgid "If invalid arguments are passed in, it will issue an error:"
msgstr "잘못된 인자가 전달되면 에러가 발생합니다:"

#: ../Doc/library/argparse.rst:83
msgid "The following sections walk you through this example."
msgstr "다음 절에서 이 예제를 자세히 살펴봅니다."

#: ../Doc/library/argparse.rst:87
msgid "Creating a parser"
msgstr "파서 만들기"

#: ../Doc/library/argparse.rst:89
msgid ""
"The first step in using the :mod:`argparse` is creating an "
":class:`ArgumentParser` object::"
msgstr ":mod:`argparse`\\를 사용하는 첫 번째 단계는 :class:`ArgumentParser` 객체를 생성하는 것입니다::"

#: ../Doc/library/argparse.rst:94
msgid ""
"The :class:`ArgumentParser` object will hold all the information "
"necessary to parse the command line into Python data types."
msgstr ":class:`ArgumentParser` 객체는 명령행을 파이썬 데이터형으로 파싱하는데 필요한 모든 정보를 담고 있습니다."

#: ../Doc/library/argparse.rst:99
msgid "Adding arguments"
msgstr "인자 추가하기"

#: ../Doc/library/argparse.rst:101
msgid ""
"Filling an :class:`ArgumentParser` with information about program "
"arguments is done by making calls to the "
":meth:`~ArgumentParser.add_argument` method. Generally, these calls tell "
"the :class:`ArgumentParser` how to take the strings on the command line "
"and turn them into objects.  This information is stored and used when "
":meth:`~ArgumentParser.parse_args` is called. For example::"
msgstr ""
":class:`ArgumentParser` 에 프로그램 인자에 대한 정보를 채우려면 "
":meth:`~ArgumentParser.add_argument` 메서드를 호출하면 됩니다. 일반적으로 이 호출은 "
":class:`ArgumentParser` 에게 명령행의 문자열을 객체로 변환하는 방법을 알려줍니다. 이 정보는 저장되고, "
":meth:`~ArgumentParser.parse_args` 가 호출될 때 사용됩니다. 예를 들면::"

#: ../Doc/library/argparse.rst:113
msgid ""
"Later, calling :meth:`~ArgumentParser.parse_args` will return an object "
"with two attributes, ``integers`` and ``accumulate``.  The ``integers`` "
"attribute will be a list of one or more ints, and the ``accumulate`` "
"attribute will be either the :func:`sum` function, if ``--sum`` was "
"specified at the command line, or the :func:`max` function if it was not."
msgstr ""
"나중에, :meth:`~ArgumentParser.parse_args` 를 호출하면 두 가지 어트리뷰트, ``integers`` 와"
" ``accumulate`` 를 가진 객체를 반환합니다. ``integers`` 어트리뷰트는 하나 이상의 int로 구성된 리스트가 "
"될 것이고, ``accumulate`` 어트리뷰트는 명령행에 ``--sum`` 가 지정되었을 경우 :func:`sum` 함수가 "
"되고, 그렇지 않으면 :func:`max` 함수가 될 것입니다."

#: ../Doc/library/argparse.rst:121
msgid "Parsing arguments"
msgstr "인자 파싱하기"

#: ../Doc/library/argparse.rst:123
msgid ""
":class:`ArgumentParser` parses arguments through the "
":meth:`~ArgumentParser.parse_args` method.  This will inspect the command"
" line, convert each argument to the appropriate type and then invoke the "
"appropriate action. In most cases, this means a simple :class:`Namespace`"
" object will be built up from attributes parsed out of the command line::"
msgstr ""
":class:`ArgumentParser` 는 :meth:`~ArgumentParser.parse_args` 메서드를 통해 인자를 "
"파싱합니다. 이 메서드는 명령행을 검사하고 각 인자를 적절한 형으로 변환 한 다음 적절한 액션을 호출합니다. 대부분은, 이것은 "
"간단한 :class:`Namespace` 객체가 명령행에서 파싱 된 어트리뷰트들로 만들어진다는 것을 뜻합니다::"

#: ../Doc/library/argparse.rst:132
msgid ""
"In a script, :meth:`~ArgumentParser.parse_args` will typically be called "
"with no arguments, and the :class:`ArgumentParser` will automatically "
"determine the command-line arguments from :data:`sys.argv`."
msgstr ""
"스크립트에서, :meth:`~ArgumentParser.parse_args` 는 일반적으로 인자 없이 호출되고, "
":class:`ArgumentParser` 는 :data:`sys.argv` 에서 자동으로 명령행 인자를 결정합니다."

#: ../Doc/library/argparse.rst:138
msgid "ArgumentParser objects"
msgstr "ArgumentParser 객체"

#: ../Doc/library/argparse.rst:147
msgid ""
"Create a new :class:`ArgumentParser` object. All parameters should be "
"passed as keyword arguments. Each parameter has its own more detailed "
"description below, but in short they are:"
msgstr ""
"새로운 :class:`ArgumentParser` 객체를 만듭니다. 모든 매개 변수는 키워드 인자로 전달되어야 합니다. 매개 "
"변수마다 아래에서 더 자세히 설명되지만, 요약하면 다음과 같습니다:"

#: ../Doc/library/argparse.rst:151
msgid "prog_ - The name of the program (default: ``sys.argv[0]``)"
msgstr "prog_ - 프로그램의 이름 (기본값: ``sys.argv[0]``)"

#: ../Doc/library/argparse.rst:153
msgid ""
"usage_ - The string describing the program usage (default: generated from"
" arguments added to parser)"
msgstr "usage_ - 프로그램 사용법을 설명하는 문자열 (기본값: 파서에 추가된 인자로부터 만들어지는 값)"

#: ../Doc/library/argparse.rst:156
msgid "description_ - Text to display before the argument help (default: none)"
msgstr "description_ - 인자 도움말 전에 표시할 텍스트 (기본값: none)"

#: ../Doc/library/argparse.rst:158
msgid "epilog_ - Text to display after the argument help (default: none)"
msgstr "epilog_ - 인자 도움말 후에 표시할 텍스트 (기본값: none)"

#: ../Doc/library/argparse.rst:160
msgid ""
"parents_ - A list of :class:`ArgumentParser` objects whose arguments "
"should also be included"
msgstr "parents_ - :class:`ArgumentParser` 객체들의 리스트이고, 이 들의 인자들도 포함된다"

#: ../Doc/library/argparse.rst:163
msgid "formatter_class_ - A class for customizing the help output"
msgstr "formatter_class_ - 도움말 출력을 사용자 정의하기 위한 클래스"

#: ../Doc/library/argparse.rst:165
msgid ""
"prefix_chars_ - The set of characters that prefix optional arguments "
"(default: '-')"
msgstr "prefix_chars_ - 선택 인자 앞에 붙는 문자 집합 (기본값: '-')."

#: ../Doc/library/argparse.rst:168
msgid ""
"fromfile_prefix_chars_ - The set of characters that prefix files from "
"which additional arguments should be read (default: ``None``)"
msgstr "fromfile_prefix_chars_ - 추가 인자를 읽어야 하는 파일 앞에 붙는 문자 집합 (기본값: ``None``)."

#: ../Doc/library/argparse.rst:171
msgid ""
"argument_default_ - The global default value for arguments (default: "
"``None``)"
msgstr "argument_default_ - 인자의 전역 기본값 (기본값: ``None``)"

#: ../Doc/library/argparse.rst:174
msgid ""
"conflict_handler_ - The strategy for resolving conflicting optionals "
"(usually unnecessary)"
msgstr "conflict_handler_ - 충돌하는 선택 사항을 해결하기 위한 전략 (일반적으로 불필요함)"

#: ../Doc/library/argparse.rst:177
msgid "add_help_ - Add a ``-h/--help`` option to the parser (default: ``True``)"
msgstr "add_help_ - 파서에 ``-h/--help`` 옵션을 추가합니다 (기본값: ``True``)"

#: ../Doc/library/argparse.rst:179
msgid ""
"allow_abbrev_ - Allows long options to be abbreviated if the abbreviation"
" is unambiguous. (default: ``True``)"
msgstr "allow_abbrev_ - 약어가 모호하지 않으면 긴 옵션을 축약할 수 있도록 합니다. (기본값: ``True``)"

#: ../Doc/library/argparse.rst:182
msgid ""
"exit_on_error_ - Determines whether or not ArgumentParser exits with "
"error info when an error occurs. (default: ``True``)"
msgstr ""
"exit_on_error_ - 에러가 발생했을 때 ArgumentParser가 에러 정보로 종료되는지를 결정합니다. (기본값: "
"``True``)"

#: ../Doc/library/argparse.rst:185
msgid "*allow_abbrev* parameter was added."
msgstr "*allow_abbrev* 매개 변수가 추가되었습니다."

#: ../Doc/library/argparse.rst:188
msgid ""
"In previous versions, *allow_abbrev* also disabled grouping of short "
"flags such as ``-vv`` to mean ``-v -v``."
msgstr ""
"이전 버전에서는, *allow_abbrev*\\는 ``-vv``\\가 ``-v -v``\\를 뜻하는 것과 같은 짧은 플래그의 "
"그룹화도 비활성화했습니다."

#: ../Doc/library/argparse.rst:192
msgid "*exit_on_error* parameter was added."
msgstr "*exit_on_error* 매개 변수가 추가되었습니다."

#: ../Doc/library/argparse.rst:195 ../Doc/library/argparse.rst:715
msgid "The following sections describe how each of these are used."
msgstr "다음 절에서는 이들 각각의 사용 방법에 관해 설명합니다."

#: ../Doc/library/argparse.rst:199
msgid "prog"
msgstr "prog"

#: ../Doc/library/argparse.rst:201
msgid ""
"By default, :class:`ArgumentParser` objects use ``sys.argv[0]`` to "
"determine how to display the name of the program in help messages.  This "
"default is almost always desirable because it will make the help messages"
" match how the program was invoked on the command line.  For example, "
"consider a file named ``myprogram.py`` with the following code::"
msgstr ""
"기본적으로, :class:`ArgumentParser` 객체는 ``sys.argv[0]`` 을 사용하여 도움말 메시지에 프로그램의 "
"이름을 표시하는 방법을 결정합니다. 이 기본값은 명령행에서 프로그램이 호출된 방법과 도움말 메시지를 일치시키기 때문에 거의 항상 "
"바람직합니다. 예를 들어, 다음 코드가 들어있는 ``myprogram.py`` 라는 파일을 생각해보십시오::"

#: ../Doc/library/argparse.rst:212
msgid ""
"The help for this program will display ``myprogram.py`` as the program "
"name (regardless of where the program was invoked from):"
msgstr "이 프로그램의 도움말은 (프로그램이 어디에서 호출되었는지에 관계없이) 프로그램 이름으로 ``myprogram.py`` 를 표시합니다:"

#: ../Doc/library/argparse.rst:231
msgid ""
"To change this default behavior, another value can be supplied using the "
"``prog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"이 기본 동작을 변경하려면, ``prog=`` 인자를 :class:`ArgumentParser` 에 사용하여 다른 값을 제공 할 수"
" 있습니다::"

#: ../Doc/library/argparse.rst:241
#, python-format
msgid ""
"Note that the program name, whether determined from ``sys.argv[0]`` or "
"from the ``prog=`` argument, is available to help messages using the "
"``%(prog)s`` format specifier."
msgstr ""
"프로그램 이름은 ``%(prog)s`` 포맷 지정자를 사용해서 도움말에 쓸 수 있습니다. ``sys.argv[0]`` 나 "
"``prog=`` 인자 중 어떤 것으로부터 결정되든 상관없습니다."

#: ../Doc/library/argparse.rst:258
msgid "usage"
msgstr "usage"

#: ../Doc/library/argparse.rst:260
msgid ""
"By default, :class:`ArgumentParser` calculates the usage message from the"
" arguments it contains::"
msgstr "기본적으로, :class:`ArgumentParser` 는 포함 된 인자로부터 사용법 메시지를 계산합니다::"

#: ../Doc/library/argparse.rst:276
msgid ""
"The default message can be overridden with the ``usage=`` keyword "
"argument::"
msgstr "기본 메시지는 ``usage=`` 키워드 인자로 재정의될 수 있습니다::"

#: ../Doc/library/argparse.rst:291
#, python-format
msgid ""
"The ``%(prog)s`` format specifier is available to fill in the program "
"name in your usage messages."
msgstr "``%(prog)s`` 포맷 지정자는 사용법 메시지에서 프로그램 이름을 채울 때 사용할 수 있습니다."

#: ../Doc/library/argparse.rst:296
msgid "description"
msgstr "description"

#: ../Doc/library/argparse.rst:298
msgid ""
"Most calls to the :class:`ArgumentParser` constructor will use the "
"``description=`` keyword argument.  This argument gives a brief "
"description of what the program does and how it works.  In help messages,"
" the description is displayed between the command-line usage string and "
"the help messages for the various arguments::"
msgstr ""
":class:`ArgumentParser` 생성자에 대한 대부분의 호출은 ``description=`` 키워드 인자를 사용할 "
"것입니다. 이 인자는 프로그램의 기능과 작동 방식에 대한 간략한 설명을 제공합니다. 도움말 메시지에서, 설명은 명령행 사용 문자열과"
" 다양한 인자에 대한 도움말 메시지 사이에 표시됩니다::"

#: ../Doc/library/argparse.rst:313
msgid ""
"By default, the description will be line-wrapped so that it fits within "
"the given space.  To change this behavior, see the formatter_class_ "
"argument."
msgstr "기본적으로, 설명은 주어진 공간에 맞도록 줄 바꿈 됩니다. 이 동작을 변경하려면 formatter_class_ 인자를 참조하십시오."

#: ../Doc/library/argparse.rst:318
msgid "epilog"
msgstr "epilog"

#: ../Doc/library/argparse.rst:320
msgid ""
"Some programs like to display additional description of the program after"
" the description of the arguments.  Such text can be specified using the "
"``epilog=`` argument to :class:`ArgumentParser`::"
msgstr ""
"일부 프로그램은 인자에 대한 설명 뒤에 프로그램에 대한 추가 설명을 표시하려고 합니다. 이러한 텍스트는 ``epilog=`` 에 "
"대한 인자를 :class:`ArgumentParser` 에 사용하여 지정할 수 있습니다::"

#: ../Doc/library/argparse.rst:337
msgid ""
"As with the description_ argument, the ``epilog=`` text is by default "
"line-wrapped, but this behavior can be adjusted with the formatter_class_"
" argument to :class:`ArgumentParser`."
msgstr ""
"description_ 인자와 마찬가지로, ``epilog=`` 텍스트가 기본적으로 줄 바꿈 됩니다만, 이 동작은 "
"formatter_class_ 인자를 :class:`ArgumentParser` 에 제공해서 조정할 수 있습니다."

#: ../Doc/library/argparse.rst:343
msgid "parents"
msgstr "parents"

#: ../Doc/library/argparse.rst:345
msgid ""
"Sometimes, several parsers share a common set of arguments. Rather than "
"repeating the definitions of these arguments, a single parser with all "
"the shared arguments and passed to ``parents=`` argument to "
":class:`ArgumentParser` can be used.  The ``parents=`` argument takes a "
"list of :class:`ArgumentParser` objects, collects all the positional and "
"optional actions from them, and adds these actions to the "
":class:`ArgumentParser` object being constructed::"
msgstr ""
"때로는 여러 파서가 공통 인자 집합을 공유하는 경우가 있습니다. 이러한 인자의 정의를 반복하는 대신, 모든 공유 인자를 갖는 파서를"
" :class:`ArgumentParser` 에 ``parents=`` 인자로 전달할 수 있습니다. ``parents=`` 인자는 "
":class:`ArgumentParser` 객체의 리스트를 취하여, 그것들로부터 모든 위치와 선택 액션을 수집해서 새로 만들어지는 "
":class:`ArgumentParser` 객체에 추가합니다::"

#: ../Doc/library/argparse.rst:365
msgid ""
"Note that most parent parsers will specify ``add_help=False``.  "
"Otherwise, the :class:`ArgumentParser` will see two ``-h/--help`` options"
" (one in the parent and one in the child) and raise an error."
msgstr ""
"대부분의 부모 파서는 ``add_help=False`` 를 지정합니다. 그렇지 않으면, :class:`ArgumentParser` "
"는 (하나는 부모에, 하나는 자식에 있는) 두 개의 ``-h/--help`` 옵션을 보게 될 것이고, 에러를 발생시킵니다."

#: ../Doc/library/argparse.rst:370
msgid ""
"You must fully initialize the parsers before passing them via "
"``parents=``. If you change the parent parsers after the child parser, "
"those changes will not be reflected in the child."
msgstr ""
"``parents=`` 를 통해 전달하기 전에 파서를 완전히 초기화해야 합니다. 자식 파서 다음에 부모 파서를 변경하면 자식에 "
"반영되지 않습니다."

#: ../Doc/library/argparse.rst:376
msgid "formatter_class"
msgstr "formatter_class"

#: ../Doc/library/argparse.rst:378
msgid ""
":class:`ArgumentParser` objects allow the help formatting to be "
"customized by specifying an alternate formatting class.  Currently, there"
" are four such classes:"
msgstr ""
":class:`ArgumentParser` 객체는 대체 포매팅 클래스를 지정함으로써 도움말 포매팅을 사용자 정의 할 수 있도록 "
"합니다. 현재 네 가지 클래스가 있습니다:"

#: ../Doc/library/argparse.rst:387
msgid ""
":class:`RawDescriptionHelpFormatter` and :class:`RawTextHelpFormatter` "
"give more control over how textual descriptions are displayed. By "
"default, :class:`ArgumentParser` objects line-wrap the description_ and "
"epilog_ texts in command-line help messages::"
msgstr ""
":class:`RawDescriptionHelpFormatter` 와 :class:`RawTextHelpFormatter` 는 "
"텍스트 설명이 표시되는 방법을 더 제어할 수 있도록 합니다. 기본적으로, :class:`ArgumentParser` 객체는 명령행 "
"도움말 메시지에서 description_ 및 epilog_ 텍스트를 줄 바꿈 합니다.::"

#: ../Doc/library/argparse.rst:412
msgid ""
"Passing :class:`RawDescriptionHelpFormatter` as ``formatter_class=`` "
"indicates that description_ and epilog_ are already correctly formatted "
"and should not be line-wrapped::"
msgstr ""
":class:`RawDescriptionHelpFormatter` 를 ``formatter_class=`` 로 전달하는 것은 "
"description_ 과 epilog_ 가 이미 올바르게 포맷되어 있어서 줄 바꿈 되어서는 안 된다는 것을 가리킵니다::"

#: ../Doc/library/argparse.rst:438
msgid ""
":class:`RawTextHelpFormatter` maintains whitespace for all sorts of help "
"text, including argument descriptions. However, multiple new lines are "
"replaced with one. If you wish to preserve multiple blank lines, add "
"spaces between the newlines."
msgstr ""
":class:`RawTextHelpFormatter` 는 인자 설명을 포함하여 모든 종류의 도움말 텍스트에 있는 공백을 유지합니다."
" 그러나 여러 개의 줄 넘김은 하나로 치환됩니다. 여러 개의 빈 줄을 유지하려면, 줄 바꿈 사이에 스페이스를 추가하십시오."

#: ../Doc/library/argparse.rst:443
msgid ""
":class:`ArgumentDefaultsHelpFormatter` automatically adds information "
"about default values to each of the argument help messages::"
msgstr ""
":class:`ArgumentDefaultsHelpFormatter` 는 기본값에 대한 정보를 각각의 인자 도움말 메시지에 자동으로"
" 추가합니다::"

#: ../Doc/library/argparse.rst:461
msgid ""
":class:`MetavarTypeHelpFormatter` uses the name of the type_ argument for"
" each argument as the display name for its values (rather than using the "
"dest_ as the regular formatter does)::"
msgstr ""
":class:`MetavarTypeHelpFormatter` 는 각 인자 값의 표시 이름으로 (일반 포매터처럼 dest_ 를 "
"사용하는 대신에) type_ 인자의 이름을 사용합니다::"

#: ../Doc/library/argparse.rst:482
msgid "prefix_chars"
msgstr "prefix_chars"

#: ../Doc/library/argparse.rst:484
msgid ""
"Most command-line options will use ``-`` as the prefix, e.g. "
"``-f/--foo``. Parsers that need to support different or additional prefix"
" characters, e.g. for options like ``+f`` or ``/foo``, may specify them "
"using the ``prefix_chars=`` argument to the ArgumentParser constructor::"
msgstr ""
"대부분의 명령행 옵션은 ``-f/--foo`` 처럼 ``-`` 를 접두어로 사용합니다. ``+f`` 나 ``/foo`` 같은 옵션과"
" 같이, 다른 접두어 문자를 지원해야 하는 파서는 ArgumentParser 생성자에 ``prefix_chars=`` 인자를 "
"사용하여 지정할 수 있습니다::"

#: ../Doc/library/argparse.rst:496
msgid ""
"The ``prefix_chars=`` argument defaults to ``'-'``. Supplying a set of "
"characters that does not include ``-`` will cause ``-f/--foo`` options to"
" be disallowed."
msgstr ""
"``prefix_chars=`` 인자의 기본값은 ``'-'`` 입니다. ``-`` 를 포함하지 않는 문자 집합을 제공하면 "
"``-f/--foo`` 옵션이 허용되지 않게 됩니다."

#: ../Doc/library/argparse.rst:502
msgid "fromfile_prefix_chars"
msgstr "fromfile_prefix_chars"

#: ../Doc/library/argparse.rst:504
msgid ""
"Sometimes, for example when dealing with a particularly long argument "
"lists, it may make sense to keep the list of arguments in a file rather "
"than typing it out at the command line.  If the "
"``fromfile_prefix_chars=`` argument is given to the "
":class:`ArgumentParser` constructor, then arguments that start with any "
"of the specified characters will be treated as files, and will be "
"replaced by the arguments they contain.  For example::"
msgstr ""
"때로는, 예를 들어 특히 긴 인자 목록을 다룰 때, 인자 목록을 명령행에 입력하는 대신 파일에 보관하는 것이 좋습니다. "
"``fromfile_prefix_chars=`` 인자가 :class:`ArgumentParser` 생성자에 주어지면, 지정된 문자로"
" 시작하는 인자는 파일로 간주하고 파일에 포함된 인자로 대체됩니다. 예를 들면::"

#: ../Doc/library/argparse.rst:518
msgid ""
"Arguments read from a file must by default be one per line (but see also "
":meth:`~ArgumentParser.convert_arg_line_to_args`) and are treated as if "
"they were in the same place as the original file referencing argument on "
"the command line.  So in the example above, the expression ``['-f', "
"'foo', '@args.txt']`` is considered equivalent to the expression ``['-f',"
" 'foo', '-f', 'bar']``."
msgstr ""
"파일에서 읽은 인자는 기본적으로 한 줄에 하나씩 있어야 하고 (하지만 "
":meth:`~ArgumentParser.convert_arg_line_to_args` 도 참조하십시오), 명령행에서 원래 파일을 "
"참조하는 인자와 같은 위치에 있는 것처럼 처리됩니다. 위의 예에서 표현식 ``['-f', 'foo', '@args.txt']`` 는"
" ``['-f', 'foo', '-f', 'bar']`` 와 동등하게 취급됩니다."

#: ../Doc/library/argparse.rst:524
msgid ""
"The ``fromfile_prefix_chars=`` argument defaults to ``None``, meaning "
"that arguments will never be treated as file references."
msgstr ""
"``fromfile_prefix_chars=`` 인자의 기본값은 ``None`` 입니다. 이것은 인자가 절대로 파일 참조로 취급되지"
" 않는다는 것을 의미합니다."

#: ../Doc/library/argparse.rst:529
msgid "argument_default"
msgstr "argument_default"

#: ../Doc/library/argparse.rst:531
msgid ""
"Generally, argument defaults are specified either by passing a default to"
" :meth:`~ArgumentParser.add_argument` or by calling the "
":meth:`~ArgumentParser.set_defaults` methods with a specific set of name-"
"value pairs.  Sometimes however, it may be useful to specify a single "
"parser-wide default for arguments.  This can be accomplished by passing "
"the ``argument_default=`` keyword argument to :class:`ArgumentParser`.  "
"For example, to globally suppress attribute creation on "
":meth:`~ArgumentParser.parse_args` calls, we supply "
"``argument_default=SUPPRESS``::"
msgstr ""
"일반적으로 인자의 기본값은 :meth:`~ArgumentParser.add_argument` 에 기본값을 전달하거나 특정 이름-값 "
"쌍 집합을 사용하여 :meth:`~ArgumentParser.set_defaults` 메서드를 호출하여 지정됩니다. 그러나 때로는,"
" 파서 전체에 적용되는 단일 기본값을 지정하는 것이 유용 할 수 있습니다. 이것은 ``argument_default=`` 키워드 "
"인자를 :class:`ArgumentParser` 에 전달함으로써 이루어질 수 있습니다. 예를 들어, "
":meth:`~ArgumentParser.parse_args` 호출에서 어트리뷰트 생성을 전역적으로 억제하려면, "
"``argument_default=SUPPRESS`` 를 제공합니다::"

#: ../Doc/library/argparse.rst:551
msgid "allow_abbrev"
msgstr "allow_abbrev"

#: ../Doc/library/argparse.rst:553
msgid ""
"Normally, when you pass an argument list to the "
":meth:`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, "
"it :ref:`recognizes abbreviations <prefix-matching>` of long options."
msgstr ""
"일반적으로 :class:`ArgumentParser` 의 :meth:`~ArgumentParser.parse_args` 메서드에 "
"인자 리스트를 건네주면 긴 옵션의 :ref:`약어를 인식합니다 <prefix-matching>`."

#: ../Doc/library/argparse.rst:557
msgid "This feature can be disabled by setting ``allow_abbrev`` to ``False``::"
msgstr "``allow_abbrev`` 를 ``False`` 로 설정하면 이 기능을 비활성화 할 수 있습니다::"

#: ../Doc/library/argparse.rst:570
msgid "conflict_handler"
msgstr "conflict_handler"

#: ../Doc/library/argparse.rst:572
msgid ""
":class:`ArgumentParser` objects do not allow two actions with the same "
"option string.  By default, :class:`ArgumentParser` objects raise an "
"exception if an attempt is made to create an argument with an option "
"string that is already in use::"
msgstr ""
":class:`ArgumentParser` 객체는 같은 옵션 문자열을 가진 두 개의 액션을 허용하지 않습니다. 기본적으로 "
":class:`ArgumentParser` 객체는 이미 사용 중인 옵션 문자열로 인자를 만들려고 시도하면 예외를 발생시킵니다 ::"

#: ../Doc/library/argparse.rst:584
msgid ""
"Sometimes (e.g. when using parents_) it may be useful to simply override "
"any older arguments with the same option string.  To get this behavior, "
"the value ``'resolve'`` can be supplied to the ``conflict_handler=`` "
"argument of :class:`ArgumentParser`::"
msgstr ""
"때로는 (예를 들어 parents_ 를 사용하는 경우) 같은 옵션 문자열을 갖는 예전의 인자들을 간단히 대체하는 것이 유용 할 수 "
"있습니다. 이 동작을 얻으려면, :class:`ArgumentParser` 의 ``conflict_handler=`` 인자에 "
"``'resolve'`` 값을 제공합니다::"

#: ../Doc/library/argparse.rst:600
msgid ""
"Note that :class:`ArgumentParser` objects only remove an action if all of"
" its option strings are overridden.  So, in the example above, the old "
"``-f/--foo`` action is retained as the ``-f`` action, because only the "
"``--foo`` option string was overridden."
msgstr ""
":class:`ArgumentParser` 객체는 모든 옵션 문자열이 재정의된 경우에만 액션을 제거합니다. 위의 예에서, 이전의 "
"``-f/--foo`` 액션은 ``--foo`` 옵션 문자열만 재정의되었기 때문에 ``-f`` 액션으로 유지됩니다."

#: ../Doc/library/argparse.rst:607
msgid "add_help"
msgstr "add_help"

#: ../Doc/library/argparse.rst:609
msgid ""
"By default, ArgumentParser objects add an option which simply displays "
"the parser's help message. For example, consider a file named "
"``myprogram.py`` containing the following code::"
msgstr ""
"기본적으로, ArgumentParser 객체는 파서의 도움말 메시지를 표시하는 옵션을 추가합니다. 예를 들어, 다음 코드를 포함하는"
" ``myprogram.py`` 파일을 생각해보십시오::"

#: ../Doc/library/argparse.rst:618
msgid ""
"If ``-h`` or ``--help`` is supplied at the command line, the "
"ArgumentParser help will be printed:"
msgstr "명령행에서 ``-h`` 또는 ``--help`` 가 제공되면, ArgumentParser 도움말이 출력됩니다 :"

#: ../Doc/library/argparse.rst:630
msgid ""
"Occasionally, it may be useful to disable the addition of this help "
"option. This can be achieved by passing ``False`` as the ``add_help=`` "
"argument to :class:`ArgumentParser`::"
msgstr ""
"때에 따라, 이 도움말 옵션을 추가하지 않도록 설정하는 것이 유용 할 수 있습니다. ``add_help=`` 인자를 "
"``False`` 로 :class:`ArgumentParser` 에 전달하면 됩니다::"

#: ../Doc/library/argparse.rst:642
msgid ""
"The help option is typically ``-h/--help``. The exception to this is if "
"the ``prefix_chars=`` is specified and does not include ``-``, in which "
"case ``-h`` and ``--help`` are not valid options.  In this case, the "
"first character in ``prefix_chars`` is used to prefix the help options::"
msgstr ""
"도움말 옵션은 일반적으로 ``-h/--help`` 입니다. 예외는 ``prefix_chars=`` 가 지정되고 ``-`` 을 "
"포함하지 않는 경우입니다. 이 경우 ``-h`` 와 ``--help`` 는 유효한 옵션이 아닙니다. 이 경우, "
"``prefix_chars`` 의 첫 번째 문자가 도움말 옵션 접두어로 사용됩니다::"

#: ../Doc/library/argparse.rst:657
msgid "exit_on_error"
msgstr "exit_on_error"

#: ../Doc/library/argparse.rst:659
msgid ""
"Normally, when you pass an invalid argument list to the "
":meth:`~ArgumentParser.parse_args` method of an :class:`ArgumentParser`, "
"it will exit with error info."
msgstr ""
"일반적으로, :class:`ArgumentParser` 의 :meth:`~ArgumentParser.parse_args` 메서드에 "
"잘못된 인자 리스트를 건네주면, 에러 정보와 함께 종료합니다."

#: ../Doc/library/argparse.rst:662
msgid ""
"If the user would like catch errors manually, the feature can be enable "
"by setting ``exit_on_error`` to ``False``::"
msgstr ""
"사용자가 수동으로 에러를 잡으려면, ``exit_on_error``\\를 ``False``\\로 설정하여 기능을 활성화 할 수 "
"있습니다::"

#: ../Doc/library/argparse.rst:679
msgid "The add_argument() method"
msgstr "add_argument() 메서드"

#: ../Doc/library/argparse.rst:685
msgid ""
"Define how a single command-line argument should be parsed.  Each "
"parameter has its own more detailed description below, but in short they "
"are:"
msgstr "단일 명령행 인자를 구문 분석하는 방법을 정의합니다. 매개 변수마다 아래에서 더 자세히 설명되지만, 요약하면 다음과 같습니다:"

#: ../Doc/library/argparse.rst:688
msgid ""
"`name or flags`_ - Either a name or a list of option strings, e.g. "
"``foo`` or ``-f, --foo``."
msgstr "`name or flags`_ - 옵션 문자열의 이름이나 리스트, 예를 들어 ``foo`` 또는 ``-f, --foo``."

#: ../Doc/library/argparse.rst:691
msgid ""
"action_ - The basic type of action to be taken when this argument is "
"encountered at the command line."
msgstr "action_ - 명령행에서 이 인자가 발견될 때 수행 할 액션의 기본형."

#: ../Doc/library/argparse.rst:694
msgid "nargs_ - The number of command-line arguments that should be consumed."
msgstr "nargs_ - 소비되어야 하는 명령행 인자의 수."

#: ../Doc/library/argparse.rst:696
msgid "const_ - A constant value required by some action_ and nargs_ selections."
msgstr "const_ - 일부 action_ 및 nargs_ 를 선택할 때 필요한 상숫값."

#: ../Doc/library/argparse.rst:698
#, fuzzy
msgid ""
"default_ - The value produced if the argument is absent from the command "
"line and if it is absent from the namespace object."
msgstr "default_ - 인자가 명령행에 없는 경우 생성되는 값."

#: ../Doc/library/argparse.rst:701
msgid "type_ - The type to which the command-line argument should be converted."
msgstr "type_ - 명령행 인자가 변환되어야 할 형."

#: ../Doc/library/argparse.rst:703
msgid "choices_ - A container of the allowable values for the argument."
msgstr "choices_ - 인자로 허용되는 값의 컨테이너."

#: ../Doc/library/argparse.rst:705
msgid ""
"required_ - Whether or not the command-line option may be omitted "
"(optionals only)."
msgstr "required_ - 명령행 옵션을 생략 할 수 있는지 아닌지 (선택적일 때만)."

#: ../Doc/library/argparse.rst:708
msgid "help_ - A brief description of what the argument does."
msgstr "help_ - 인자가 하는 일에 대한 간단한 설명."

#: ../Doc/library/argparse.rst:710
msgid "metavar_ - A name for the argument in usage messages."
msgstr "metavar_ - 사용 메시지에 사용되는 인자의 이름."

#: ../Doc/library/argparse.rst:712
msgid ""
"dest_ - The name of the attribute to be added to the object returned by "
":meth:`parse_args`."
msgstr "dest_ - :meth:`parse_args` 가 반환하는 객체에 추가될 어트리뷰트의 이름."

#: ../Doc/library/argparse.rst:719
msgid "name or flags"
msgstr "name or flags"

#: ../Doc/library/argparse.rst:721
msgid ""
"The :meth:`~ArgumentParser.add_argument` method must know whether an "
"optional argument, like ``-f`` or ``--foo``, or a positional argument, "
"like a list of filenames, is expected.  The first arguments passed to "
":meth:`~ArgumentParser.add_argument` must therefore be either a series of"
" flags, or a simple argument name.  For example, an optional argument "
"could be created like::"
msgstr ""
":meth:`~ArgumentParser.add_argument` 메서드는 ``-f`` 나 ``--foo`` 와 같은 선택 인자가 "
"필요한지, 파일 이름의 리스트와 같은 위치 인자가 필요한지 알아야 합니다. 따라서 "
":meth:`~ArgumentParser.add_argument` 에 전달되는 첫 번째 인자는 일련의 플래그이거나 간단한 인자 "
"이름이어야 합니다. 예를 들어 선택 인자는 이렇게 만들어질 수 있습니다::"

#: ../Doc/library/argparse.rst:730
msgid "while a positional argument could be created like::"
msgstr "반면에 위치 인자는 이렇게 만들어집니다::"

#: ../Doc/library/argparse.rst:734
msgid ""
"When :meth:`~ArgumentParser.parse_args` is called, optional arguments "
"will be identified by the ``-`` prefix, and the remaining arguments will "
"be assumed to be positional::"
msgstr ""
":meth:`~ArgumentParser.parse_args` 가 호출되면, 선택 인자는 ``-`` 접두사로 식별되고, 그 밖의 "
"인자는 위치 인자로 간주합니다::"

#: ../Doc/library/argparse.rst:751
msgid "action"
msgstr "action"

#: ../Doc/library/argparse.rst:753
msgid ""
":class:`ArgumentParser` objects associate command-line arguments with "
"actions.  These actions can do just about anything with the command-line "
"arguments associated with them, though most actions simply add an "
"attribute to the object returned by :meth:`~ArgumentParser.parse_args`.  "
"The ``action`` keyword argument specifies how the command-line arguments "
"should be handled. The supplied actions are:"
msgstr ""
":class:`ArgumentParser` 객체는 명령행 인자를 액션과 연관시킵니다. 대부분의 액션은 단순히 "
":meth:`~ArgumentParser.parse_args` 에 의해 반환된 객체에 어트리뷰트를 추가하기만 하지만, 액션은 관련된"
" 명령행 인자로 무엇이든 할 수 있습니다. ``action`` 키워드 인자는 명령행 인자의 처리 방법을 지정합니다. 제공되는 액션은"
" 다음과 같습니다:"

#: ../Doc/library/argparse.rst:759
msgid ""
"``'store'`` - This just stores the argument's value.  This is the default"
" action. For example::"
msgstr "``'store'`` - 인자 값을 저장합니다. 이것이 기본 액션입니다. 예를 들면::"

#: ../Doc/library/argparse.rst:767
msgid ""
"``'store_const'`` - This stores the value specified by the const_ keyword"
" argument.  The ``'store_const'`` action is most commonly used with "
"optional arguments that specify some sort of flag.  For example::"
msgstr ""
"``'store_const'`` - const_ 키워드 인자에 의해 지정된 값을 저장합니다. ``'store_const'`` 액션은"
" 어떤 종류의 플래그를 지정하는 선택 인자와 함께 사용하는 것이 가장 일반적입니다. 예를 들면::"

#: ../Doc/library/argparse.rst:776
msgid ""
"``'store_true'`` and ``'store_false'`` - These are special cases of "
"``'store_const'`` used for storing the values ``True`` and ``False`` "
"respectively.  In addition, they create default values of ``False`` and "
"``True`` respectively.  For example::"
msgstr ""
"``'store_true'`` 와 ``'store_false'`` - 각각 ``True`` 와 ``False`` 값을 저장하는 "
"``'store_const'`` 의 특별한 경우입니다. 또한, 각각 기본값 ``False`` 와 ``True`` 를 생성합니다. "
"예를 들면::"

#: ../Doc/library/argparse.rst:788
msgid ""
"``'append'`` - This stores a list, and appends each argument value to the"
" list.  This is useful to allow an option to be specified multiple times."
" Example usage::"
msgstr ""
"``'append'`` - 리스트를 저장하고 각 인자 값을 리스트에 추가합니다. 옵션을 여러 번 지정할 수 있도록 하는 데 "
"유용합니다. 사용 예::"

#: ../Doc/library/argparse.rst:797
msgid ""
"``'append_const'`` - This stores a list, and appends the value specified "
"by the const_ keyword argument to the list.  (Note that the const_ "
"keyword argument defaults to ``None``.)  The ``'append_const'`` action is"
" typically useful when multiple arguments need to store constants to the "
"same list. For example::"
msgstr ""
"``'append_const'`` - 리스트를 저장하고 const_ 키워드 인자로 지정된 값을 리스트에 추가합니다. (const_ "
"키워드의 기본값은 ``None`` 입니다.) ``'append_const'`` 액션은 여러 개의 인자가 같은 리스트에 상수를 "
"저장해야 할 때 유용합니다. 예를 들면::"

#: ../Doc/library/argparse.rst:809
msgid ""
"``'count'`` - This counts the number of times a keyword argument occurs. "
"For example, this is useful for increasing verbosity levels::"
msgstr "``'count'`` - 키워드 인자가 등장한 횟수를 계산합니다. 예를 들어, 상세도를 높이는 데 유용합니다::"

#: ../Doc/library/argparse.rst:817
msgid "Note, the *default* will be ``None`` unless explicitly set to *0*."
msgstr "참고, 명시적으로 *0*\\으로 설정되지 않으면 *default*\\는 ``None``\\이 됩니다."

#: ../Doc/library/argparse.rst:819
msgid ""
"``'help'`` - This prints a complete help message for all the options in "
"the current parser and then exits. By default a help action is "
"automatically added to the parser. See :class:`ArgumentParser` for "
"details of how the output is created."
msgstr ""
"``'help'`` - 현재 파서의 모든 옵션에 대한 완전한 도움말 메시지를 출력하고 종료합니다. 기본적으로 help 액션은 "
"자동으로 파서에 추가됩니다. 출력이 만들어지는 방법에 대한 자세한 내용은 :class:`ArgumentParser` 를 보세요."

#: ../Doc/library/argparse.rst:824
msgid ""
"``'version'`` - This expects a ``version=`` keyword argument in the "
":meth:`~ArgumentParser.add_argument` call, and prints version information"
" and exits when invoked::"
msgstr ""
"``'version'`` - :meth:`~ArgumentParser.add_argument` 호출에서 ``version=`` "
"키워드 인자를 기대하고, 호출되면 버전 정보를 출력하고 종료합니다::"

#: ../Doc/library/argparse.rst:834
msgid ""
"``'extend'`` - This stores a list, and extends each argument value to the"
" list. Example usage::"
msgstr "``'append'`` - 리스트를 저장하고 각 인자 값으로 리스트를 확장합니다. 사용 예::"

#: ../Doc/library/argparse.rst:845
msgid ""
"You may also specify an arbitrary action by passing an Action subclass or"
" other object that implements the same interface. The "
"``BooleanOptionalAction`` is available in ``argparse`` and adds support "
"for boolean actions such as ``--foo`` and ``--no-foo``::"
msgstr ""
"Action 서브 클래스나 같은 인터페이스를 구현하는 다른 객체를 전달하여 임의의 액션을 지정할 수도 있습니다. "
"``BooleanOptionalAction``\\은 ``argparse``\\에서 사용할 수 있으며 ``--foo``\\와 "
"``--no-foo``\\와 같은 불리언 액션에 대한 지원을 추가합니다::"

#: ../Doc/library/argparse.rst:856
msgid ""
"The recommended way to create a custom action is to extend "
":class:`Action`, overriding the ``__call__`` method and optionally the "
"``__init__`` and ``format_usage`` methods."
msgstr ""
"사용자 정의 액션을 만드는 권장하는 방법은 :class:`Action` 을 확장하여 ``__call__`` 메서드와 선택적으로 "
"``__init__``\\와 ``format_usage`` 메서드를 재정의하는 것입니다."

#: ../Doc/library/argparse.rst:860
msgid "An example of a custom action::"
msgstr "사용자 정의 액션의 예::"

#: ../Doc/library/argparse.rst:880
msgid "For more details, see :class:`Action`."
msgstr "자세한 내용은 :class:`Action` 을 참조하십시오."

#: ../Doc/library/argparse.rst:883
msgid "nargs"
msgstr "nargs"

#: ../Doc/library/argparse.rst:885
msgid ""
"ArgumentParser objects usually associate a single command-line argument "
"with a single action to be taken.  The ``nargs`` keyword argument "
"associates a different number of command-line arguments with a single "
"action.  The supported values are:"
msgstr ""
"ArgumentParser 객체는 일반적으로 하나의 명령행 인자를 하나의 액션과 결합합니다. ``nargs`` 키워드 인자는 다른 "
"수의 명령행 인자를 하나의 액션으로 연결합니다. 지원되는 값은 다음과 같습니다:"

#: ../Doc/library/argparse.rst:890
msgid ""
"``N`` (an integer).  ``N`` arguments from the command line will be "
"gathered together into a list.  For example::"
msgstr "``N`` (정수). 명령행에서 ``N`` 개의 인자를 함께 모아서 리스트에 넣습니다. 예를 들면::"

#: ../Doc/library/argparse.rst:899
msgid ""
"Note that ``nargs=1`` produces a list of one item.  This is different "
"from the default, in which the item is produced by itself."
msgstr "``nargs=1`` 은 하나의 항목을 갖는 리스트를 생성합니다. 이는 항목 그대로 생성되는 기본값과 다릅니다."

#: ../Doc/library/argparse.rst:904
msgid ""
"``'?'``. One argument will be consumed from the command line if possible,"
" and produced as a single item.  If no command-line argument is present, "
"the value from default_ will be produced.  Note that for optional "
"arguments, there is an additional case - the option string is present but"
" not followed by a command-line argument.  In this case the value from "
"const_ will be produced.  Some examples to illustrate this::"
msgstr ""
"``'?'``. 가능하다면 한 인자가 명령행에서 소비되고 단일 항목으로 생성됩니다. 명령행 인자가 없으면 default_ 의 값이 "
"생성됩니다. 선택 인자의 경우 추가적인 경우가 있습니다 - 옵션 문자열은 있지만, 명령행 인자가 따라붙지 않는 경우입니다. 이 경우"
" const_ 의 값이 생성됩니다. 이것을 보여주기 위해 몇 가지 예를 듭니다::"

#: ../Doc/library/argparse.rst:921
msgid ""
"One of the more common uses of ``nargs='?'`` is to allow optional input "
"and output files::"
msgstr "``nargs='?'`` 의 흔한 사용법 중 하나는 선택적 입출력 파일을 허용하는 것입니다::"

#: ../Doc/library/argparse.rst:938
msgid ""
"``'*'``.  All command-line arguments present are gathered into a list.  "
"Note that it generally doesn't make much sense to have more than one "
"positional argument with ``nargs='*'``, but multiple optional arguments "
"with ``nargs='*'`` is possible.  For example::"
msgstr ""
"``'*'``. 모든 명령행 인자를 리스트로 수집합니다. 일반적으로 두 개 이상의 위치 인자에 대해 ``nargs='*'`` 를 "
"사용하는 것은 별로 의미가 없지만, ``nargs='*'`` 를 갖는 여러 개의 선택 인자는 가능합니다. 예를 들면::"

#: ../Doc/library/argparse.rst:952
msgid ""
"``'+'``. Just like ``'*'``, all command-line args present are gathered "
"into a list.  Additionally, an error message will be generated if there "
"wasn't at least one command-line argument present.  For example::"
msgstr ""
"``'+'``. ``'*'`` 와 같이, 존재하는 모든 명령행 인자를 리스트로 모읍니다. 또한, 적어도 하나의 명령행 인자가 "
"제공되지 않으면 에러 메시지가 만들어집니다. 예를 들면::"

#: ../Doc/library/argparse.rst:964
msgid ""
"If the ``nargs`` keyword argument is not provided, the number of "
"arguments consumed is determined by the action_.  Generally this means a "
"single command-line argument will be consumed and a single item (not a "
"list) will be produced."
msgstr ""
"``nargs`` 키워드 인자가 제공되지 않으면, 소비되는 인자의 개수는 action_ 에 의해 결정됩니다. 일반적으로 이는 하나의"
" 명령행 인자가 소비되고 하나의 항목(리스트가 아닙니다)이 생성됨을 의미합니다."

#: ../Doc/library/argparse.rst:970
msgid "const"
msgstr "const"

#: ../Doc/library/argparse.rst:972
msgid ""
"The ``const`` argument of :meth:`~ArgumentParser.add_argument` is used to"
" hold constant values that are not read from the command line but are "
"required for the various :class:`ArgumentParser` actions.  The two most "
"common uses of it are:"
msgstr ""
":meth:`~ArgumentParser.add_argument` 의 ``const`` 인자는 명령행에서 읽지는 않지만 다양한 "
":class:`ArgumentParser` 액션에 필요한 상숫값을 저장하는 데 사용됩니다. 가장 흔한 두 가지 용도는 다음과 "
"같습니다:"

#: ../Doc/library/argparse.rst:976
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with "
"``action='store_const'`` or ``action='append_const'``.  These actions add"
" the ``const`` value to one of the attributes of the object returned by "
":meth:`~ArgumentParser.parse_args`. See the action_ description for "
"examples."
msgstr ""
":meth:`~ArgumentParser.add_argument` 가 ``action='store_const'`` 또는 "
"``action='append_const'`` 로 호출될 때. 이 액션은 "
":meth:`~ArgumentParser.parse_args` 에 의해 반환된 객체의 어트리뷰트 중 하나에 ``const`` 값을 "
"추가합니다. 예제는 action_ 설명을 참조하십시오."

#: ../Doc/library/argparse.rst:981
msgid ""
"When :meth:`~ArgumentParser.add_argument` is called with option strings "
"(like ``-f`` or ``--foo``) and ``nargs='?'``.  This creates an optional "
"argument that can be followed by zero or one command-line arguments. When"
" parsing the command line, if the option string is encountered with no "
"command-line argument following it, the value of ``const`` will be "
"assumed instead. See the nargs_ description for examples."
msgstr ""
":meth:`~ArgumentParser.add_argument` 가 옵션 문자열(``-f`` 또는 ``--foo`` 와 같은)과 "
"``nargs='?'`` 로 호출될 때. 이것은 0 또는 하나의 명령행 인자가 뒤따르는 선택 인자를 만듭니다. 명령행을 파싱할 때 "
"옵션 문자열 뒤에 명령행 인자가 없으면 ``const`` 값이 대신 가정됩니다. 예제는 nargs_ 설명을 참조하십시오."

#: ../Doc/library/argparse.rst:988
msgid ""
"With the ``'store_const'`` and ``'append_const'`` actions, the ``const`` "
"keyword argument must be given.  For other actions, it defaults to "
"``None``."
msgstr ""
"``'store_const'`` 와 ``'append_const'`` 액션을 사용할 때는 ``const`` 키워드 인자를 반드시 "
"주어야 합니다. 다른 액션의 경우, 기본값은 ``None`` 입니다."

#: ../Doc/library/argparse.rst:993
msgid "default"
msgstr "default"

#: ../Doc/library/argparse.rst:995
msgid ""
"All optional arguments and some positional arguments may be omitted at "
"the command line.  The ``default`` keyword argument of "
":meth:`~ArgumentParser.add_argument`, whose value defaults to ``None``, "
"specifies what value should be used if the command-line argument is not "
"present. For optional arguments, the ``default`` value is used when the "
"option string was not present at the command line::"
msgstr ""
"모든 선택 인자와 일부 위치 인자는 명령행에서 생략될 수 있습니다. "
":meth:`~ArgumentParser.add_argument` 의 ``default`` 키워드 인자는, 기본값은 ``None``"
" 입니다, 명령행 인자가 없을 때 어떤 값을 사용해야 하는지를 지정합니다. 선택 인자의 경우, 옵션 문자열이 명령행에 없을 때 "
"``default`` 값이 사용됩니다::"

#: ../Doc/library/argparse.rst:1009
msgid ""
"If the target namespace already has an attribute set, the action "
"*default* will not over write it::"
msgstr ""

#: ../Doc/library/argparse.rst:1017
msgid ""
"If the ``default`` value is a string, the parser parses the value as if "
"it were a command-line argument.  In particular, the parser applies any "
"type_ conversion argument, if provided, before setting the attribute on "
"the :class:`Namespace` return value.  Otherwise, the parser uses the "
"value as is::"
msgstr ""
"``default`` 값이 문자열이면, 파서는 마치 명령행 인자인 것처럼 파싱합니다. 특히, 파서는 "
":class:`Namespace` 반환 값에 어트리뷰트를 설정하기 전에, 제공된 모든 type_ 변환 인자를 적용합니다. 그렇지 "
"않은 경우, 파서는 값을 있는 그대로 사용합니다::"

#: ../Doc/library/argparse.rst:1028
msgid ""
"For positional arguments with nargs_ equal to ``?`` or ``*``, the "
"``default`` value is used when no command-line argument was present::"
msgstr "nargs_ 가 ``?`` 또는 ``*`` 인 위치 인자의 경우, 명령행 인자가 없을 때 ``default`` 값이 사용됩니다::"

#: ../Doc/library/argparse.rst:1039
msgid ""
"Providing ``default=argparse.SUPPRESS`` causes no attribute to be added "
"if the command-line argument was not present::"
msgstr "``default=argparse.SUPPRESS`` 를 지정하면 명령행 인자가 없는 경우 어트리뷰트가 추가되지 않습니다::"

#: ../Doc/library/argparse.rst:1051
msgid "type"
msgstr "type"

#: ../Doc/library/argparse.rst:1053
msgid ""
"By default, :class:`ArgumentParser` objects read command-line arguments "
"in as simple strings. However, quite often the command-line string should"
" instead be interpreted as another type, like a :class:`float` or "
":class:`int`.  The ``type`` keyword argument of "
":meth:`~ArgumentParser.add_argument` allows any necessary type-checking "
"and type conversions to be performed.  Common built-in types and "
"functions can be used directly as the value of the ``type`` argument::"
msgstr ""
"기본적으로 :class:`ArgumentParser` 객체는 명령행 인자를 간단한 문자열로 읽습니다. 그러나 꽤 자주 명령행 "
"문자열은 :class:`float` 또는 :class:`int`\\와 같은 다른 형으로 해석되어야 합니다. "
":meth:`~ArgumentParser.add_argument` 의 ``type`` 키워드 인자는 필요한 형 검사와 형 변환이 "
"수행되도록 합니다. 일반적인 내장형과 함수는 ``type`` 인자의 값으로 직접 사용될 수 있습니다::"

#: ../Doc/library/argparse.rst:1066
msgid ""
"See the section on the default_ keyword argument for information on when "
"the ``type`` argument is applied to default arguments."
msgstr "언제 ``type`` 인자가 기본 인자에 적용되는지에 대한 정보는 default_ 키워드 인자 절을 참조하십시오."

#: ../Doc/library/argparse.rst:1069
msgid ""
"To ease the use of various types of files, the argparse module provides "
"the factory FileType which takes the ``mode=``, ``bufsize=``, "
"``encoding=`` and ``errors=`` arguments of the :func:`open` function.  "
"For example, ``FileType('w')`` can be used to create a writable file::"
msgstr ""
"다양한 형태의 파일을 사용하기 쉽게 하려고, argparse 모듈은 :func:`open` 함수의 ``mode=``, "
"``bufsize=``, ``encoding=``, ``errors=`` 인자를 취하는 팩토리 FileType 을 제공합니다. 예를"
" 들어, ``FileType('w')`` 은 쓰기 가능한 파일을 만드는 데 사용할 수 있습니다 ::"

#: ../Doc/library/argparse.rst:1079
msgid ""
"``type=`` can take any callable that takes a single string argument and "
"returns the converted value::"
msgstr "``type=`` 는 단일 문자열 인자를 취하고 변환된 값을 돌려주는 모든 콜러블을 받아들입니다::"

#: ../Doc/library/argparse.rst:1098
msgid ""
"The choices_ keyword argument may be more convenient for type checkers "
"that simply check against a range of values::"
msgstr "단순히 값의 범위를 검사하는 형 검사기로는 choices_ 키워드 인자가 더 편리할 수 있습니다::"

#: ../Doc/library/argparse.rst:1109
msgid "See the choices_ section for more details."
msgstr "자세한 내용은 choices_ 섹션을 참조하십시오."

#: ../Doc/library/argparse.rst:1113
msgid "choices"
msgstr "choices"

#: ../Doc/library/argparse.rst:1115
msgid ""
"Some command-line arguments should be selected from a restricted set of "
"values. These can be handled by passing a container object as the "
"*choices* keyword argument to :meth:`~ArgumentParser.add_argument`.  When"
" the command line is parsed, argument values will be checked, and an "
"error message will be displayed if the argument was not one of the "
"acceptable values::"
msgstr ""
"일부 명령행 인자는 제한된 값 집합에서 선택되어야 합니다. :meth:`~ArgumentParser.add_argument` 에 "
"컨테이너 객체를 *choices* 키워드 인자로 전달하여 처리할 수 있습니다. 명령행을 파싱할 때, 인자의 값을 검사하고, 인자가 "
"받아들일 수 없는 값이 아닌 경우 에러 메시지가 표시됩니다::"

#: ../Doc/library/argparse.rst:1130
msgid ""
"Note that inclusion in the *choices* container is checked after any type_"
" conversions have been performed, so the type of the objects in the "
"*choices* container should match the type_ specified::"
msgstr ""
"*choices* 컨테이너에 포함되는지는 type_ 변환이 수행된 후에 검사하므로, *choices* 컨테이너에 있는 객체의 형은 "
"지정된 type_ 과 일치해야 합니다::"

#: ../Doc/library/argparse.rst:1142
#, fuzzy
msgid ""
"Any container can be passed as the *choices* value, so :class:`list` "
"objects, :class:`set` objects, and custom containers are all supported."
msgstr ""
"모든 컨테이너는 *choices* 값으로 전달될 수 있기 때문에, :class:`list` 객체, :class:`set` 객체, "
"사용자 정의 컨테이너 등이 모두 지원됩니다. 여기에는 :class:`enum.Enum`\\이 포함되며, 인자의 선택을 제한하는 데 "
"사용될 수 있습니다; 이전의 가위바위보 게임 예제를 재사용하면 다음과 같습니다::"

#: ../Doc/library/argparse.rst:1145
msgid ""
"Use of :class:`enum.Enum` is not recommended because it is difficult to "
"control its appearance in usage, help, and error messages."
msgstr ""

#: ../Doc/library/argparse.rst:1150
msgid "required"
msgstr "required"

#: ../Doc/library/argparse.rst:1152
msgid ""
"In general, the :mod:`argparse` module assumes that flags like ``-f`` and"
" ``--bar`` indicate *optional* arguments, which can always be omitted at "
"the command line. To make an option *required*, ``True`` can be specified"
" for the ``required=`` keyword argument to "
":meth:`~ArgumentParser.add_argument`::"
msgstr ""
"일반적으로 :mod:`argparse` 모듈은 ``-f`` 와 ``--bar`` 같은 플래그가 명령행에서 생략될 수 있는 *선택적*"
" 인자를 가리킨다고 가정합니다. 옵션을 *필수*\\로 만들기 위해, "
":meth:`~ArgumentParser.add_argument` 의 ``required=`` 키워드 인자에 ``True`` 를 "
"지정할 수 있습니다::"

#: ../Doc/library/argparse.rst:1165
msgid ""
"As the example shows, if an option is marked as ``required``, "
":meth:`~ArgumentParser.parse_args` will report an error if that option is"
" not present at the command line."
msgstr ""
"예에서 보듯이, 옵션이 ``required`` 로 표시되면, :meth:`~ArgumentParser.parse_args` 는 그 "
"옵션이 명령행에 없을 때 에러를 보고합니다."

#: ../Doc/library/argparse.rst:1171
msgid ""
"Required options are generally considered bad form because users expect "
"*options* to be *optional*, and thus they should be avoided when "
"possible."
msgstr "필수 옵션은 사용자가 *옵션* 이 *선택적* 일 것으로 기대하기 때문에 일반적으로 나쁜 형식으로 간주하므로 가능하면 피해야 합니다."

#: ../Doc/library/argparse.rst:1176
msgid "help"
msgstr "help"

#: ../Doc/library/argparse.rst:1178
msgid ""
"The ``help`` value is a string containing a brief description of the "
"argument. When a user requests help (usually by using ``-h`` or "
"``--help`` at the command line), these ``help`` descriptions will be "
"displayed with each argument::"
msgstr ""
"``help`` 값은 인자의 간단한 설명이 들어있는 문자열입니다. 사용자가 도움말을 요청하면 (보통 명령행에서 ``-h`` 또는 "
"``--help`` 를 사용합니다), ``help`` 설명이 각 인자와 함께 표시됩니다::"

#: ../Doc/library/argparse.rst:1198
#, python-format
msgid ""
"The ``help`` strings can include various format specifiers to avoid "
"repetition of things like the program name or the argument default_.  The"
" available specifiers include the program name, ``%(prog)s`` and most "
"keyword arguments to :meth:`~ArgumentParser.add_argument`, e.g. "
"``%(default)s``, ``%(type)s``, etc.::"
msgstr ""
"``help`` 문자열은 프로그램 이름이나 인자 default_ 와 같은 것들의 반복을 피하고자 다양한 포맷 지정자를 포함 할 수 "
"있습니다. 사용할 수 있는 지정자는 프로그램 이름, ``%(prog)s`` 와 "
":meth:`~ArgumentParser.add_argument` 의 대부분의 키워드 인자, ``%(default)s``, "
"``%(type)s`` 등을 포함합니다.::"

#: ../Doc/library/argparse.rst:1215
#, python-format
msgid ""
"As the help string supports %-formatting, if you want a literal ``%`` to "
"appear in the help string, you must escape it as ``%%``."
msgstr ""
"도움말 문자열이 %-포매팅을 지원하기 때문에, 도움말 문자열에 리터럴 ``%`` 을 표시하려면, ``%%`` 로 이스케이프 처리해야"
" 합니다."

#: ../Doc/library/argparse.rst:1218
msgid ""
":mod:`argparse` supports silencing the help entry for certain options, by"
" setting the ``help`` value to ``argparse.SUPPRESS``::"
msgstr ""
":mod:`argparse` 는 ``help`` 값을 ``argparse.SUPPRESS`` 로 설정함으로써 특정 옵션에 대한 "
"도움말 엔트리를 감추는 것을 지원합니다::"

#: ../Doc/library/argparse.rst:1231
msgid "metavar"
msgstr "metavar"

#: ../Doc/library/argparse.rst:1233
msgid ""
"When :class:`ArgumentParser` generates help messages, it needs some way "
"to refer to each expected argument.  By default, ArgumentParser objects "
"use the dest_ value as the \"name\" of each object.  By default, for "
"positional argument actions, the dest_ value is used directly, and for "
"optional argument actions, the dest_ value is uppercased.  So, a single "
"positional argument with ``dest='bar'`` will be referred to as ``bar``. A"
" single optional argument ``--foo`` that should be followed by a single "
"command-line argument will be referred to as ``FOO``.  An example::"
msgstr ""
":class:`ArgumentParser` 가 도움말 메시지를 생성할 때, 기대되는 각 인자를 가리킬 방법이 필요합니다. 기본적으로"
" ArgumentParser 객체는 dest_ 값을 각 객체의 \"이름\"으로 사용합니다. 기본적으로 위치 인자 액션의 경우 "
"dest_ 값이 직접 사용되고, 선택 인자 액션의 경우 dest_ 값의 대문자가 사용됩니다. 그래서, ``dest='bar'`` 인"
" 단일 위치 인자는 ``bar`` 로 지칭됩니다. 하나의 명령행 인자가 따라와야 하는 단일 선택 인자 ``--foo`` 는 "
"``FOO`` 라고 표시됩니다. 예::"

#: ../Doc/library/argparse.rst:1257
msgid "An alternative name can be specified with ``metavar``::"
msgstr "다른 이름은 ``metavar`` 로 지정할 수 있습니다::"

#: ../Doc/library/argparse.rst:1274
msgid ""
"Note that ``metavar`` only changes the *displayed* name - the name of the"
" attribute on the :meth:`~ArgumentParser.parse_args` object is still "
"determined by the dest_ value."
msgstr ""
"``metavar`` 는 *표시되는* 이름 만 변경합니다 - :meth:`~ArgumentParser.parse_args` 객체의 "
"어트리뷰트 이름은 여전히\\  dest_ 값에 의해 결정됩니다."

#: ../Doc/library/argparse.rst:1278
msgid ""
"Different values of ``nargs`` may cause the metavar to be used multiple "
"times. Providing a tuple to ``metavar`` specifies a different display for"
" each of the arguments::"
msgstr ""
"``nargs`` 값이 다르면 metavar 가 여러 번 사용될 수 있습니다. ``metavar`` 에 튜플을 제공하면 인자마다 "
"다른 디스플레이가 지정됩니다::"

#: ../Doc/library/argparse.rst:1295
msgid "dest"
msgstr "dest"

#: ../Doc/library/argparse.rst:1297
msgid ""
"Most :class:`ArgumentParser` actions add some value as an attribute of "
"the object returned by :meth:`~ArgumentParser.parse_args`.  The name of "
"this attribute is determined by the ``dest`` keyword argument of "
":meth:`~ArgumentParser.add_argument`.  For positional argument actions, "
"``dest`` is normally supplied as the first argument to "
":meth:`~ArgumentParser.add_argument`::"
msgstr ""
"대부분 :class:`ArgumentParser` 액션은 :meth:`~ArgumentParser.parse_args` 에 의해 "
"반환된 객체의 어트리뷰트로 어떤 값을 추가합니다. 이 어트리뷰트의 이름은 "
":meth:`~ArgumentParser.add_argument` 의 ``dest`` 키워드 인자에 의해 결정됩니다. 위치 인자 "
"액션의 경우, ``dest`` 는 일반적으로 :meth:`~ArgumentParser.add_argument` 에 첫 번째 인자로 "
"제공됩니다.::"

#: ../Doc/library/argparse.rst:1309
msgid ""
"For optional argument actions, the value of ``dest`` is normally inferred"
" from the option strings.  :class:`ArgumentParser` generates the value of"
" ``dest`` by taking the first long option string and stripping away the "
"initial ``--`` string.  If no long option strings were supplied, ``dest``"
" will be derived from the first short option string by stripping the "
"initial ``-`` character.  Any internal ``-`` characters will be converted"
" to ``_`` characters to make sure the string is a valid attribute name.  "
"The examples below illustrate this behavior::"
msgstr ""
"선택 인자 액션의 경우, ``dest`` 의 값은 보통 옵션 문자열에서 유추됩니다. :class:`ArgumentParser` 는 "
"첫 번째 긴 옵션 문자열을 취하고 앞의 ``--`` 문자열을 제거하여 ``dest`` 의 값을 만듭니다. 긴 옵션 문자열이 제공되지"
" 않았다면 ``dest`` 는 첫 번째 짧은 옵션 문자열에서 앞의 ``-`` 문자를 제거하여 만듭니다. 문자열이 항상 유효한 "
"어트리뷰트 이름이 되도록 만들기 위해 중간에 나오는 ``-`` 문자는 ``_`` 문자로 변환됩니다. 아래 예제는 이 동작을 "
"보여줍니다::"

#: ../Doc/library/argparse.rst:1326
msgid "``dest`` allows a custom attribute name to be provided::"
msgstr "``dest`` 는 사용자 정의 어트리뷰트 이름을 지정할 수 있게 합니다::"

#: ../Doc/library/argparse.rst:1334
msgid "Action classes"
msgstr "Action 클래스"

#: ../Doc/library/argparse.rst:1336
msgid ""
"Action classes implement the Action API, a callable which returns a "
"callable which processes arguments from the command-line. Any object "
"which follows this API may be passed as the ``action`` parameter to "
":meth:`add_argument`."
msgstr ""
"Action 클래스는 액션 API를 구현합니다. 액션 API는 명령행에서 인자를 처리하는 콜러블을 반환하는 콜러블 객체입니다. 이 "
"API를 따르는 모든 객체는 :meth:`add_argument` 의 ``action`` 매개 변수로 전달될 수 있습니다."

#: ../Doc/library/argparse.rst:1345
msgid ""
"Action objects are used by an ArgumentParser to represent the information"
" needed to parse a single argument from one or more strings from the "
"command line. The Action class must accept the two positional arguments "
"plus any keyword arguments passed to :meth:`ArgumentParser.add_argument` "
"except for the ``action`` itself."
msgstr ""
"Action 객체는 ArgumentParser에서 명령행의 하나 이상의 문자열에서 단일 인자를 파싱하는 데 필요한 정보를 나타내기 "
"위해 사용됩니다. Action 클래스는 두 개의 위치 인자와 :meth:`ArgumentParser.add_argument` 에 "
"전달된 ``action`` 자신을 제외한 모든 키워드 인자들을 받아들여야 합니다."

#: ../Doc/library/argparse.rst:1351
msgid ""
"Instances of Action (or return value of any callable to the ``action`` "
"parameter) should have attributes \"dest\", \"option_strings\", "
"\"default\", \"type\", \"required\", \"help\", etc. defined. The easiest "
"way to ensure these attributes are defined is to call "
"``Action.__init__``."
msgstr ""
"Action 인스턴스(또는 ``action`` 매개 변수로 전달된 콜러블의 반환 값)는 \"dest\", "
"\"option_strings\", \"default\", \"type\", \"required\", \"help\" 등의 "
"어트리뷰트가 정의되어야 합니다. 이러한 어트리뷰트를 정의하는 가장 쉬운 방법은 ``Action.__init__`` 를 호출하는 "
"것입니다."

#: ../Doc/library/argparse.rst:1356
msgid ""
"Action instances should be callable, so subclasses must override the "
"``__call__`` method, which should accept four parameters:"
msgstr ""
"Action 인스턴스는 콜러블이어야 하므로, 서브 클래스는 네 개의 매개 변수를 받아들이는 ``__call__`` 메서드를 "
"재정의해야 합니다:"

#: ../Doc/library/argparse.rst:1359
msgid "``parser`` - The ArgumentParser object which contains this action."
msgstr "``parser`` - 이 액션을 포함하는 ArgumentParser 객체."

#: ../Doc/library/argparse.rst:1361
msgid ""
"``namespace`` - The :class:`Namespace` object that will be returned by "
":meth:`~ArgumentParser.parse_args`.  Most actions add an attribute to "
"this object using :func:`setattr`."
msgstr ""
"``namespace`` - :meth:`~ArgumentParser.parse_args` 에 의해 반환될 "
":class:`Namespace` 객체. 대부분의 액션은 :func:`setattr` 을 사용하여 이 객체에 어트리뷰트를 "
"추가합니다."

#: ../Doc/library/argparse.rst:1365
msgid ""
"``values`` - The associated command-line arguments, with any type "
"conversions applied.  Type conversions are specified with the type_ "
"keyword argument to :meth:`~ArgumentParser.add_argument`."
msgstr ""
"``values`` - 형 변환이 적용된 연관된 명령행 인자. 형 변환은 "
":meth:`~ArgumentParser.add_argument` 에 전달된 type_ 키워드 인자로 지정됩니다."

#: ../Doc/library/argparse.rst:1369
msgid ""
"``option_string`` - The option string that was used to invoke this "
"action. The ``option_string`` argument is optional, and will be absent if"
" the action is associated with a positional argument."
msgstr ""
"``option_string`` - 이 액션을 호출하는 데 사용된 옵션 문자열. ``option_string`` 인자는 선택적이며,"
" 액션이 위치 인자와 관련되어 있으면 생략됩니다."

#: ../Doc/library/argparse.rst:1373
msgid ""
"The ``__call__`` method may perform arbitrary actions, but will typically"
" set attributes on the ``namespace`` based on ``dest`` and ``values``."
msgstr ""
"``__call__`` 메서드는 임의의 액션을 수행 할 수 있습니다만, 일반적으로 ``dest`` 와 ``values`` 에 "
"기반하여 ``namespace`` 에 어트리뷰트를 설정합니다."

#: ../Doc/library/argparse.rst:1376
msgid ""
"Action subclasses can define a ``format_usage`` method that takes no "
"argument and return a string which will be used when printing the usage "
"of the program. If such method is not provided, a sensible default will "
"be used."
msgstr ""
"Action 서브 클래스는 인자를 취하지 않고 프로그램 사용법을 인쇄할 때 사용될 문자열을 반환하는 ``format_usage`` "
"메서드를 정의할 수 있습니다. 이러한 메서드를 제공하지 않으면, 적절한 기본값이 사용됩니다."

#: ../Doc/library/argparse.rst:1381
msgid "The parse_args() method"
msgstr "parse_args() 메서드"

#: ../Doc/library/argparse.rst:1385
msgid ""
"Convert argument strings to objects and assign them as attributes of the "
"namespace.  Return the populated namespace."
msgstr "인자 문자열을 객체로 변환하고 namespace의 어트리뷰트로 설정합니다. 값들이 설정된 namespace를 돌려줍니다."

#: ../Doc/library/argparse.rst:1388
msgid ""
"Previous calls to :meth:`add_argument` determine exactly what objects are"
" created and how they are assigned. See the documentation for "
":meth:`add_argument` for details."
msgstr ""
"이전의 :meth:`add_argument` 호출이 어떤 객체를 만들고 어떤 식으로 대입할지를 결정합니다. 자세한 내용은 "
":meth:`add_argument` 설명서를 참조하십시오."

#: ../Doc/library/argparse.rst:1392
msgid ""
"args_ - List of strings to parse.  The default is taken from "
":data:`sys.argv`."
msgstr "args_ - 구문 분석할 문자열 리스트. 기본값은 :data:`sys.argv` 에서 취합니다."

#: ../Doc/library/argparse.rst:1395
msgid ""
"namespace_ - An object to take the attributes.  The default is a new "
"empty :class:`Namespace` object."
msgstr "namespace_ - 어트리뷰트가 대입될 객체. 기본값은 새로 만들어지는 빈 :class:`Namespace` 객체입니다."

#: ../Doc/library/argparse.rst:1400
msgid "Option value syntax"
msgstr "옵션값 문법"

#: ../Doc/library/argparse.rst:1402
msgid ""
"The :meth:`~ArgumentParser.parse_args` method supports several ways of "
"specifying the value of an option (if it takes one).  In the simplest "
"case, the option and its value are passed as two separate arguments::"
msgstr ""
":meth:`~ArgumentParser.parse_args` 메서드는 (취할 것이 있다면) 옵션의 값을 지정하는 몇 가지 방법을 "
"지원합니다. 가장 단순한 경우, 옵션과 그 값은 두 개의 독립적인 인자로 전달됩니다::"

#: ../Doc/library/argparse.rst:1414
msgid ""
"For long options (options with names longer than a single character), the"
" option and value can also be passed as a single command-line argument, "
"using ``=`` to separate them::"
msgstr ""
"긴 옵션(단일 문자보다 긴 이름을 가진 옵션)의 경우, 옵션과 값을 ``=`` 로 구분하여 단일 명령행 인자로 전달할 수도 "
"있습니다::"

#: ../Doc/library/argparse.rst:1421
msgid ""
"For short options (options only one character long), the option and its "
"value can be concatenated::"
msgstr "짧은 옵션(한 문자 길이의 옵션)의 경우, 옵션과 해당 값을 이어붙일 수 있습니다::"

#: ../Doc/library/argparse.rst:1427
msgid ""
"Several short options can be joined together, using only a single ``-`` "
"prefix, as long as only the last option (or none of them) requires a "
"value::"
msgstr ""
"여러 개의 짧은 옵션은 마지막 옵션만 값을 요구하는 한 (또는 그들 중 아무것도 값을 요구하지 않거나), 하나의 ``-`` 접두어를"
" 사용하여 함께 결합 할 수 있습니다::"

#: ../Doc/library/argparse.rst:1439
msgid "Invalid arguments"
msgstr "잘못된 인자"

#: ../Doc/library/argparse.rst:1441
msgid ""
"While parsing the command line, :meth:`~ArgumentParser.parse_args` checks"
" for a variety of errors, including ambiguous options, invalid types, "
"invalid options, wrong number of positional arguments, etc.  When it "
"encounters such an error, it exits and prints the error along with a "
"usage message::"
msgstr ""
"명령행을 파싱할 때, :meth:`~ArgumentParser.parse_args` 는 모호한 옵션, 유효하지 않은 형, 유효하지 "
"않은 옵션, 잘못된 위치 인자의 수 등을 포함한 다양한 에러를 검사합니다. 이런 에러가 발생하면, 사용 메시지와 함께 에러를 "
"인쇄합니다::"

#: ../Doc/library/argparse.rst:1467
msgid "Arguments containing ``-``"
msgstr "``-`` 를 포함하는 인자들"

#: ../Doc/library/argparse.rst:1469
msgid ""
"The :meth:`~ArgumentParser.parse_args` method attempts to give errors "
"whenever the user has clearly made a mistake, but some situations are "
"inherently ambiguous.  For example, the command-line argument ``-1`` "
"could either be an attempt to specify an option or an attempt to provide "
"a positional argument. The :meth:`~ArgumentParser.parse_args` method is "
"cautious here: positional arguments may only begin with ``-`` if they "
"look like negative numbers and there are no options in the parser that "
"look like negative numbers::"
msgstr ""
":meth:`~ArgumentParser.parse_args` 메서드는 사용자가 분명히 실수했을 때마다 에러를 주려고 하지만, 어떤"
" 상황은 본질에서 모호합니다. 예를 들어, 명령행 인자 ``-1`` 은 옵션을 지정하려는 시도이거나 위치 인자를 제공하려는 시도일 "
"수 있습니다. :meth:`~ArgumentParser.parse_args` 메서드는 이럴 때 신중합니다: 위치 인자는 음수처럼 "
"보이고 파서에 음수처럼 보이는 옵션이 없을 때만 ``-`` 로 시작할 수 있습니다::"

#: ../Doc/library/argparse.rst:1507
msgid ""
"If you have positional arguments that must begin with ``-`` and don't "
"look like negative numbers, you can insert the pseudo-argument ``'--'`` "
"which tells :meth:`~ArgumentParser.parse_args` that everything after that"
" is a positional argument::"
msgstr ""
"``-`` 로 시작해야 하고, 음수처럼 보이지 않는 위치 인자가 있는 경우, "
":meth:`~ArgumentParser.parse_args` 에 다음과 같은 의사 인자 ``'--'`` 를 삽입 할 수 있습니다."
" 그 이후의 모든 것은 위치 인자입니다::"

#: ../Doc/library/argparse.rst:1518
msgid "Argument abbreviations (prefix matching)"
msgstr "인자 약어 (접두사 일치)"

#: ../Doc/library/argparse.rst:1520
msgid ""
"The :meth:`~ArgumentParser.parse_args` method :ref:`by default "
"<allow_abbrev>` allows long options to be abbreviated to a prefix, if the"
" abbreviation is unambiguous (the prefix matches a unique option)::"
msgstr ""
":meth:`~ArgumentParser.parse_args` 메서드는 :ref:`기본적으로 <allow_abbrev>` 약어가 "
"모호하지 않으면 (접두사가 오직 하나의 옵션과 일치합니다) 긴 옵션을 접두사로 축약 할 수 있도록 합니다::"

#: ../Doc/library/argparse.rst:1535
msgid ""
"An error is produced for arguments that could produce more than one "
"options. This feature can be disabled by setting :ref:`allow_abbrev` to "
"``False``."
msgstr ""
"둘 이상의 옵션과 일치하는 인자는 에러를 일으킵니다. 이 기능은 :ref:`allow_abbrev`\\를 ``False`` 로 "
"설정함으로써 비활성화시킬 수 있습니다."

#: ../Doc/library/argparse.rst:1541
msgid "Beyond ``sys.argv``"
msgstr "``sys.argv`` 너머"

#: ../Doc/library/argparse.rst:1543
msgid ""
"Sometimes it may be useful to have an ArgumentParser parse arguments "
"other than those of :data:`sys.argv`.  This can be accomplished by "
"passing a list of strings to :meth:`~ArgumentParser.parse_args`.  This is"
" useful for testing at the interactive prompt::"
msgstr ""
"때로는 ArgumentParser가 :data:`sys.argv` 의 인자가 아닌 다른 인자를 파싱하는 것이 유용 할 수 있습니다."
" 문자열 리스트를 :meth:`~ArgumentParser.parse_args` 에 전달하면 됩니다. 대화식 프롬프트에서 테스트할 "
"때 유용합니다::"

#: ../Doc/library/argparse.rst:1563
msgid "The Namespace object"
msgstr "Namespace 객체"

#: ../Doc/library/argparse.rst:1567
msgid ""
"Simple class used by default by :meth:`~ArgumentParser.parse_args` to "
"create an object holding attributes and return it."
msgstr ""
":meth:`~ArgumentParser.parse_args` 가 어트리뷰트를 저장하고 반환할 객체를 만드는 데 기본적으로 사용하는"
" 간단한 클래스."

#: ../Doc/library/argparse.rst:1570
msgid ""
"This class is deliberately simple, just an :class:`object` subclass with "
"a readable string representation. If you prefer to have dict-like view of"
" the attributes, you can use the standard Python idiom, :func:`vars`::"
msgstr ""
"이 클래스는 의도적으로 단순한데, 단지 가독성 있는 문자열 표현을 갖는 :class:`object` 의 서브 클래스입니다. "
"어트리뷰트를 딕셔너리처럼 보기 원한다면, 표준 파이썬 관용구를 사용할 수 있습니다, :func:`vars`::"

#: ../Doc/library/argparse.rst:1580
msgid ""
"It may also be useful to have an :class:`ArgumentParser` assign "
"attributes to an already existing object, rather than a new "
":class:`Namespace` object.  This can be achieved by specifying the "
"``namespace=`` keyword argument::"
msgstr ""
":class:`ArgumentParser` 가 새 :class:`Namespace` 객체가 아니라 이미 존재하는 객체에 어트리뷰트를"
" 대입하는 것이 유용 할 수 있습니다. ``namespace=`` 키워드 인자를 지정하면 됩니다::"

#: ../Doc/library/argparse.rst:1596
msgid "Other utilities"
msgstr "기타 유틸리티"

#: ../Doc/library/argparse.rst:1599
msgid "Sub-commands"
msgstr "부속 명령"

#: ../Doc/library/argparse.rst:1606
msgid ""
"Many programs split up their functionality into a number of sub-commands,"
" for example, the ``svn`` program can invoke sub-commands like ``svn "
"checkout``, ``svn update``, and ``svn commit``.  Splitting up "
"functionality this way can be a particularly good idea when a program "
"performs several different functions which require different kinds of "
"command-line arguments. :class:`ArgumentParser` supports the creation of "
"such sub-commands with the :meth:`add_subparsers` method.  The "
":meth:`add_subparsers` method is normally called with no arguments and "
"returns a special action object.  This object has a single method, "
":meth:`~ArgumentParser.add_parser`, which takes a command name and any "
":class:`ArgumentParser` constructor arguments, and returns an "
":class:`ArgumentParser` object that can be modified as usual."
msgstr ""
"많은 프로그램은 그 기능을 여러 개의 부속 명령으로 나눕니다. 예를 들어, ``svn`` 프로그램은 ``svn checkout``,"
" ``svn update``, ``svn commit`` 과 같은 부속 명령을 호출 할 수 있습니다. 이런 식으로 기능을 나누는 "
"것은, 프로그램이 다른 명령행 인자를 요구하는 여러 가지 다른 기능을 수행할 때 특히 좋은 생각일 수 있습니다. "
":class:`ArgumentParser` 는 :meth:`add_subparsers` 메서드로 그러한 부속 명령의 생성을 "
"지원합니다. :meth:`add_subparsers` 메서드는 보통 인자 없이 호출되고 특별한 액션 객체를 돌려줍니다. 이 객체에는"
" :meth:`~ArgumentParser.add_parser`\\라는 하나의 메서드가 있습니다. 이 메서드는 명령 이름과 "
":class:`ArgumentParser` 생성자 인자를 받고 평소와 같이 수정할 수 있는 "
":class:`ArgumentParser` 객체를 반환합니다."

#: ../Doc/library/argparse.rst:1618
msgid "Description of parameters:"
msgstr "매개 변수 설명:"

#: ../Doc/library/argparse.rst:1620
msgid ""
"title - title for the sub-parser group in help output; by default "
"\"subcommands\" if description is provided, otherwise uses title for "
"positional arguments"
msgstr ""
"title - 도움말 출력의 부속 파서 그룹 제목; description이 제공되면 기본적으로 \"subcommands\", 그렇지"
" 않으면 위치 인자를 위한 제목을 사용합니다"

#: ../Doc/library/argparse.rst:1624
msgid ""
"description - description for the sub-parser group in help output, by "
"default ``None``"
msgstr "description - 도움말 출력의 부속 파서 그룹에 대한 설명. 기본값은 ``None`` 입니다."

#: ../Doc/library/argparse.rst:1627
msgid ""
"prog - usage information that will be displayed with sub-command help, by"
" default the name of the program and any positional arguments before the "
"subparser argument"
msgstr "prog - 부속 명령 도움말과 함께 표시될 사용 정보. 기본적으로 프로그램 이름 및 부속 파서 인자 앞에 오는 위치 인자"

#: ../Doc/library/argparse.rst:1631
msgid ""
"parser_class - class which will be used to create sub-parser instances, "
"by default the class of the current parser (e.g. ArgumentParser)"
msgstr ""
"parser_class - 부속 파서 인스턴스를 만들 때 사용할 클래스. 기본적으로, 현재 파서의 클래스 (예를 들어 "
"ArgumentParser)"

#: ../Doc/library/argparse.rst:1634
msgid ""
"action_ - the basic type of action to be taken when this argument is "
"encountered at the command line"
msgstr "action_ - 이 인자를 명령행에서 만날 때 수행 할 액션의 기본형"

#: ../Doc/library/argparse.rst:1637
msgid ""
"dest_ - name of the attribute under which sub-command name will be "
"stored; by default ``None`` and no value is stored"
msgstr "dest_ - 부속 명령 이름을 저장하는 어트리뷰트의 이름. 기본적으로 ``None`` 이며 값은 저장되지 않습니다."

#: ../Doc/library/argparse.rst:1640
msgid ""
"required_ - Whether or not a subcommand must be provided, by default "
"``False`` (added in 3.7)"
msgstr "required_ - 부속 명령이 꼭 제공되어야 하는지 아닌지, 기본값은 ``False`` (3.7에서 추가)"

#: ../Doc/library/argparse.rst:1643
msgid "help_ - help for sub-parser group in help output, by default ``None``"
msgstr "help_ - 도움말 출력의 부속 파서 그룹 도움말, 기본적으로 ``None``"

#: ../Doc/library/argparse.rst:1645
msgid ""
"metavar_ - string presenting available sub-commands in help; by default "
"it is ``None`` and presents sub-commands in form {cmd1, cmd2, ..}"
msgstr ""
"metavar_ - 도움말에서 사용 가능한 부속 명령을 표시하는 문자열. 기본적으로 ``None`` 이며 {cmd1, cmd2, "
"..} 형식으로 부속 명령을 표시합니다."

#: ../Doc/library/argparse.rst:1648
msgid "Some example usage::"
msgstr "몇 가지 사용 예::"

#: ../Doc/library/argparse.rst:1669
msgid ""
"Note that the object returned by :meth:`parse_args` will only contain "
"attributes for the main parser and the subparser that was selected by the"
" command line (and not any other subparsers).  So in the example above, "
"when the ``a`` command is specified, only the ``foo`` and ``bar`` "
"attributes are present, and when the ``b`` command is specified, only the"
" ``foo`` and ``baz`` attributes are present."
msgstr ""
":meth:`parse_args` 에 의해 반환된 객체는 주 파서와 명령행에 의해 선택된 부속 파서(다른 부속 파서는 아님)의 "
"어트리뷰트만을 포함한다는 것에 주의하십시오. 그래서 위의 예에서, ``a`` 명령이 지정되면 ``foo`` 와 ``bar`` "
"어트리뷰트 만 존재하고, ``b`` 명령이 지정되면 ``foo`` 와 ``baz`` 어트리뷰트만 존재합니다."

#: ../Doc/library/argparse.rst:1676
msgid ""
"Similarly, when a help message is requested from a subparser, only the "
"help for that particular parser will be printed.  The help message will "
"not include parent parser or sibling parser messages.  (A help message "
"for each subparser command, however, can be given by supplying the "
"``help=`` argument to :meth:`add_parser` as above.)"
msgstr ""
"마찬가지로, 도움말 메시지가 부속 파서에서 요청되면 해당 파서에 대한 도움말만 인쇄됩니다. 도움말 메시지에는 상위 파서나 형제 파서"
" 메시지는 포함되지 않습니다. (하지만 각 부속 파서 명령에 대한 도움말 메시지는 위와 같이 :meth:`add_parser` 에 "
"``help=`` 인자를 주어 지정할 수 있습니다.)"

#: ../Doc/library/argparse.rst:1712
msgid ""
"The :meth:`add_subparsers` method also supports ``title`` and "
"``description`` keyword arguments.  When either is present, the "
"subparser's commands will appear in their own group in the help output.  "
"For example::"
msgstr ""
":meth:`add_subparsers` 메서드는 또한 ``title`` 과 ``description`` 키워드 인자를 지원합니다."
" 둘 중 하나가 있으면 부속 파서의 명령이 도움말 출력에서 자체 그룹으로 나타납니다. 예를 들면::"

#: ../Doc/library/argparse.rst:1733
msgid ""
"Furthermore, ``add_parser`` supports an additional ``aliases`` argument, "
"which allows multiple strings to refer to the same subparser. This "
"example, like ``svn``, aliases ``co`` as a shorthand for ``checkout``::"
msgstr ""
"게다가, ``add_parser`` 는 ``aliases`` 인자를 추가로 지원하는데, 여러 개의 문자열이 같은 부속 파서를 참조 "
"할 수 있게 해줍니다. 이 예는 ``svn`` 와 마찬가지로 ``checkout`` 의 약자로 ``co`` 라는 별칭을 만듭니다::"

#: ../Doc/library/argparse.rst:1744
msgid ""
"One particularly effective way of handling sub-commands is to combine the"
" use of the :meth:`add_subparsers` method with calls to "
":meth:`set_defaults` so that each subparser knows which Python function "
"it should execute.  For example::"
msgstr ""
"부속 명령을 처리하는 특히 효과적인 방법의 하나는, :meth:`add_subparsers` 메서드를 "
":meth:`set_defaults` 호출과 결합하여, 각 부속 파서가 어떤 파이썬 함수를 실행해야 하는지 알 수 있도록 하는 "
"것입니다. 예를 들면::"

#: ../Doc/library/argparse.rst:1781
msgid ""
"This way, you can let :meth:`parse_args` do the job of calling the "
"appropriate function after argument parsing is complete.  Associating "
"functions with actions like this is typically the easiest way to handle "
"the different actions for each of your subparsers.  However, if it is "
"necessary to check the name of the subparser that was invoked, the "
"``dest`` keyword argument to the :meth:`add_subparsers` call will work::"
msgstr ""
"이렇게 하면 :meth:`parse_args` 가 파싱이 완료된 후 적절한 함수를 호출하게 할 수 있습니다. 이처럼 액션과 함수를 "
"연결하는 것이, 일반적으로 각 부속 파서가 서로 다른 액션을 처리하도록 하는 가장 쉬운 방법입니다. 그러나 호출된 부속 파서의 "
"이름을 확인해야 하는 경우 :meth:`add_subparsers` 호출에 ``dest`` 키워드 인자를 제공합니다::"

#: ../Doc/library/argparse.rst:1797
msgid "New *required* keyword argument."
msgstr "새로운 *required* 키워드 인자"

#: ../Doc/library/argparse.rst:1802
msgid "FileType objects"
msgstr "FileType 객체"

#: ../Doc/library/argparse.rst:1806
msgid ""
"The :class:`FileType` factory creates objects that can be passed to the "
"type argument of :meth:`ArgumentParser.add_argument`.  Arguments that "
"have :class:`FileType` objects as their type will open command-line "
"arguments as files with the requested modes, buffer sizes, encodings and "
"error handling (see the :func:`open` function for more details)::"
msgstr ""
":class:`FileType` 팩토리는 :meth:`ArgumentParser.add_argument` 의 type 인자로 전달될"
" 수 있는 객체를 만듭니다. type으로 :class:`FileType` 객체를 사용하는 인자는 명령행 인자를 요청된 모드, 버퍼 "
"크기, 인코딩 및 오류 처리의 파일로 엽니다 (자세한 내용은 :func:`open` 함수를 참조하세요)::"

#: ../Doc/library/argparse.rst:1818
msgid ""
"FileType objects understand the pseudo-argument ``'-'`` and automatically"
" convert this into ``sys.stdin`` for readable :class:`FileType` objects "
"and ``sys.stdout`` for writable :class:`FileType` objects::"
msgstr ""
"FileType 객체는 의사 인자 ``'-'`` 를 이해하고, 읽기 위한 :class:`FileType` 객체는 "
"``sys.stdin`` 으로, 쓰기 위한 :class:`FileType` 객체는 ``sys.stdout`` 으로 자동 "
"변환합니다::"

#: ../Doc/library/argparse.rst:1827
msgid "The *encodings* and *errors* keyword arguments."
msgstr "*encodings* 및 *errors* 키워드 인자"

#: ../Doc/library/argparse.rst:1832
msgid "Argument groups"
msgstr "인자 그룹"

#: ../Doc/library/argparse.rst:1836
msgid ""
"By default, :class:`ArgumentParser` groups command-line arguments into "
"\"positional arguments\" and \"optional arguments\" when displaying help "
"messages. When there is a better conceptual grouping of arguments than "
"this default one, appropriate groups can be created using the "
":meth:`add_argument_group` method::"
msgstr ""
"기본적으로 :class:`ArgumentParser` 는 도움말 메시지를 표시할 때 \"positional "
"arguments\"(위치 인자)와 \"optional arguments\"(선택 인자)로 명령행 인자를 그룹화합니다. 이 기본 "
"그룹보다 더 나은 개념적 인자 그룹이 있는 경우, :meth:`add_argument_group` 메서드를 사용하여 적절한 그룹을 "
"만들 수 있습니다.::"

#: ../Doc/library/argparse.rst:1853
msgid ""
"The :meth:`add_argument_group` method returns an argument group object "
"which has an :meth:`~ArgumentParser.add_argument` method just like a "
"regular :class:`ArgumentParser`.  When an argument is added to the group,"
" the parser treats it just like a normal argument, but displays the "
"argument in a separate group for help messages.  The "
":meth:`add_argument_group` method accepts *title* and *description* "
"arguments which can be used to customize this display::"
msgstr ""
":meth:`add_argument_group` 메서드는 :class:`ArgumentParser` 처럼 "
":meth:`~ArgumentParser.add_argument` 메서드를 가진 인자 그룹 객체를 반환합니다. 인자가 그룹에 추가될"
" 때, 파서는 일반 인자처럼 취급하지만, 도움말 메시지는 별도의 그룹에 인자를 표시합니다. "
":meth:`add_argument_group` 메서드는 이 표시를 사용자 정의하는데 사용할 수 있는 *title* 과 "
"*description* 인자를 받아들입니다::"

#: ../Doc/library/argparse.rst:1879
msgid ""
"Note that any arguments not in your user-defined groups will end up back "
"in the usual \"positional arguments\" and \"optional arguments\" "
"sections."
msgstr ""
"사용자 정의 그룹에 없는 인자는 일반적인 \"positional arguments\" 및 \"optional arguments\" "
"섹션으로 들어갑니다."

#: ../Doc/library/argparse.rst:1884
msgid "Mutual exclusion"
msgstr "상호 배제"

#: ../Doc/library/argparse.rst:1888
msgid ""
"Create a mutually exclusive group. :mod:`argparse` will make sure that "
"only one of the arguments in the mutually exclusive group was present on "
"the command line::"
msgstr ""
"상호 배타적인 그룹을 만듭니다. :mod:`argparse` 는 상호 배타적인 그룹에서 오직 하나의 인자만 명령행에 존재하는지 "
"확인합니다::"

#: ../Doc/library/argparse.rst:1904
msgid ""
"The :meth:`add_mutually_exclusive_group` method also accepts a *required*"
" argument, to indicate that at least one of the mutually exclusive "
"arguments is required::"
msgstr ""
":meth:`add_mutually_exclusive_group` 메서드는 상호 배타적 인자 중 적어도 하나가 필요하다는 것을 "
"나타내기 위한 *required* 인자도 받아들입니다::"

#: ../Doc/library/argparse.rst:1916
msgid ""
"Note that currently mutually exclusive argument groups do not support the"
" *title* and *description* arguments of "
":meth:`~ArgumentParser.add_argument_group`."
msgstr ""
"현재, 상호 배타적인 인자 그룹은 :meth:`~ArgumentParser.add_argument_group` 의 *title* 및"
" *description* 인자를 지원하지 않습니다."

#: ../Doc/library/argparse.rst:1922
msgid "Parser defaults"
msgstr "파서 기본값"

#: ../Doc/library/argparse.rst:1926
msgid ""
"Most of the time, the attributes of the object returned by "
":meth:`parse_args` will be fully determined by inspecting the command-"
"line arguments and the argument actions.  :meth:`set_defaults` allows "
"some additional attributes that are determined without any inspection of "
"the command line to be added::"
msgstr ""
"대부분은, :meth:`parse_args` 에 의해 반환된 객체의 어트리뷰트는 명령행 인자와 인자 액션을 검사하여 완전히 "
"결정됩니다. :meth:`set_defaults` 는 명령행을 검사하지 않고 결정되는 몇 가지 추가적인 어트리뷰트를 추가할 수 "
"있도록 합니다::"

#: ../Doc/library/argparse.rst:1938
msgid "Note that parser-level defaults always override argument-level defaults::"
msgstr "파서 수준의 기본값은 항상 인자 수준의 기본값보다 우선합니다::"

#: ../Doc/library/argparse.rst:1946
msgid ""
"Parser-level defaults can be particularly useful when working with "
"multiple parsers.  See the :meth:`~ArgumentParser.add_subparsers` method "
"for an example of this type."
msgstr ""
"파서 수준의 기본값은 여러 파서로 작업 할 때 특히 유용 할 수 있습니다. 이 유형의 예제는 "
":meth:`~ArgumentParser.add_subparsers` 메서드를 참조하십시오."

#: ../Doc/library/argparse.rst:1952
msgid ""
"Get the default value for a namespace attribute, as set by either "
":meth:`~ArgumentParser.add_argument` or by "
":meth:`~ArgumentParser.set_defaults`::"
msgstr ""
":meth:`~ArgumentParser.add_argument` 또는 "
":meth:`~ArgumentParser.set_defaults` 에 의해 설정된 이름 공간 어트리뷰트의 기본값을 가져옵니다::"

#: ../Doc/library/argparse.rst:1963
msgid "Printing help"
msgstr "도움말 인쇄"

#: ../Doc/library/argparse.rst:1965
msgid ""
"In most typical applications, :meth:`~ArgumentParser.parse_args` will "
"take care of formatting and printing any usage or error messages.  "
"However, several formatting methods are available:"
msgstr ""
"대부분의 일반적인 응용 프로그램에서 :meth:`~ArgumentParser.parse_args` 가 사용법이나 오류 메시지를 "
"포매팅하고 인쇄하는 것을 담당합니다. 그러나 여러 가지 포매팅 방법이 제공됩니다:"

#: ../Doc/library/argparse.rst:1971
msgid ""
"Print a brief description of how the :class:`ArgumentParser` should be "
"invoked on the command line.  If *file* is ``None``, :data:`sys.stdout` "
"is assumed."
msgstr ""
":class:`ArgumentParser` 가 어떻게 명령행에서 호출되어야 하는지에 대한 간단한 설명을 인쇄합니다. *file* 이"
" ``None`` 이면, :data:`sys.stdout` 이 가정됩니다."

#: ../Doc/library/argparse.rst:1977
msgid ""
"Print a help message, including the program usage and information about "
"the arguments registered with the :class:`ArgumentParser`.  If *file* is "
"``None``, :data:`sys.stdout` is assumed."
msgstr ""
"프로그램 사용법과 :class:`ArgumentParser` 에 등록된 인자에 대한 정보를 포함하는 도움말 메시지를 출력합니다. "
"*file* 이 ``None`` 이면, :data:`sys.stdout` 이 가정됩니다."

#: ../Doc/library/argparse.rst:1981
msgid ""
"There are also variants of these methods that simply return a string "
"instead of printing it:"
msgstr "인쇄하는 대신 단순히 문자열을 반환하는, 이러한 메서드의 변형도 있습니다:"

#: ../Doc/library/argparse.rst:1986
msgid ""
"Return a string containing a brief description of how the "
":class:`ArgumentParser` should be invoked on the command line."
msgstr ":class:`ArgumentParser` 가 어떻게 명령행에서 호출되어야 하는지에 대한 간단한 설명을 담은 문자열을 반환합니다."

#: ../Doc/library/argparse.rst:1991
msgid ""
"Return a string containing a help message, including the program usage "
"and information about the arguments registered with the "
":class:`ArgumentParser`."
msgstr ""
"프로그램 사용법과 :class:`ArgumentParser` 에 등록된 인자에 대한 정보를 포함하는 도움말 메시지를 담은 문자열을 "
"반환합니다."

#: ../Doc/library/argparse.rst:1996
msgid "Partial parsing"
msgstr "부분 파싱"

#: ../Doc/library/argparse.rst:2000
msgid ""
"Sometimes a script may only parse a few of the command-line arguments, "
"passing the remaining arguments on to another script or program. In these"
" cases, the :meth:`~ArgumentParser.parse_known_args` method can be "
"useful.  It works much like :meth:`~ArgumentParser.parse_args` except "
"that it does not produce an error when extra arguments are present.  "
"Instead, it returns a two item tuple containing the populated namespace "
"and the list of remaining argument strings."
msgstr ""
"때에 따라 스크립트는 명령행 인자 중 일부만 파싱하고 나머지 인자를 다른 스크립트 나 프로그램에 전달할 수 있습니다. 이 경우 "
":meth:`~ArgumentParser.parse_known_args` 메서드가 유용 할 수 있습니다. "
":meth:`~ArgumentParser.parse_args` 와 매우 유사하게 작동하는데, 여분의 인자가 있을 때 에러를 "
"발생시키지 않는 점이 다릅니다. 대신, 채워진 이름 공간과 여분의 인자 문자열 리스트를 포함하는 두 항목 튜플을 반환합니다."

#: ../Doc/library/argparse.rst:2016
msgid ""
":ref:`Prefix matching <prefix-matching>` rules apply to "
":meth:`parse_known_args`. The parser may consume an option even if it's "
"just a prefix of one of its known options, instead of leaving it in the "
"remaining arguments list."
msgstr ""
":ref:`접두사 일치 <prefix-matching>` 규칙은 :meth:`parse_known_args` 에 적용됩니다. 파서는"
" 알려진 옵션 중 하나의 접두사 일지라도 여분의 인자 목록에 남기지 않고 옵션을 소비할 수 있습니다."

#: ../Doc/library/argparse.rst:2023
msgid "Customizing file parsing"
msgstr "파일 파싱 사용자 정의"

#: ../Doc/library/argparse.rst:2027
msgid ""
"Arguments that are read from a file (see the *fromfile_prefix_chars* "
"keyword argument to the :class:`ArgumentParser` constructor) are read one"
" argument per line. :meth:`convert_arg_line_to_args` can be overridden "
"for fancier reading."
msgstr ""
"파일에서 읽은 인자는 (:class:`ArgumentParser` 생성자의 *fromfile_prefix_chars* 키워드 인자를"
" 참조하세요) 한 줄에 하나의 인자로 읽습니다. 이 동작을 변경하려면 :meth:`convert_arg_line_to_args` 를"
" 재정의합니다."

#: ../Doc/library/argparse.rst:2032
msgid ""
"This method takes a single argument *arg_line* which is a string read "
"from the argument file.  It returns a list of arguments parsed from this "
"string. The method is called once per line read from the argument file, "
"in order."
msgstr ""
"이 메서드는 하나의 인자 *arg_line* 를 받아들이는데, 인자 파일에서 읽어 들인 문자열입니다. 이 문자열에서 파싱된 인자 "
"리스트를 반환합니다. 메서드는 인자 파일에서 읽어 들이는 대로 한 줄에 한 번씩 순서대로 호출됩니다."

#: ../Doc/library/argparse.rst:2036
msgid ""
"A useful override of this method is one that treats each space-separated "
"word as an argument.  The following example demonstrates how to do this::"
msgstr ""
"이 메서드의 재정의하는 유용한 경우는 스페이스로 분리된 각 단어를 인자로 처리하는 것입니다. 다음 예제는 이렇게 하는 방법을 "
"보여줍니다::"

#: ../Doc/library/argparse.rst:2045
msgid "Exiting methods"
msgstr "종료 메서드"

#: ../Doc/library/argparse.rst:2049
msgid ""
"This method terminates the program, exiting with the specified *status* "
"and, if given, it prints a *message* before that. The user can override "
"this method to handle these steps differently::"
msgstr ""
"이 메서드는 지정된 *status* 상태 코드로 프로그램을 종료하고, *message* 가 주어지면 그 전에 인쇄합니다. 사용자는 "
"이 단계를 다르게 처리하기 위해 이 메서드를 재정의할 수 있습니다::"

#: ../Doc/library/argparse.rst:2061
msgid ""
"This method prints a usage message including the *message* to the "
"standard error and terminates the program with a status code of 2."
msgstr "이 메서드는 *message* 를 포함하는 사용법 메시지를 표준 에러에 인쇄하고, 상태 코드 2로 프로그램을 종료합니다."

#: ../Doc/library/argparse.rst:2066
msgid "Intermixed parsing"
msgstr "혼합 파싱"

#: ../Doc/library/argparse.rst:2071
msgid ""
"A number of Unix commands allow the user to intermix optional arguments "
"with positional arguments.  The "
":meth:`~ArgumentParser.parse_intermixed_args` and "
":meth:`~ArgumentParser.parse_known_intermixed_args` methods support this "
"parsing style."
msgstr ""
"많은 유닉스 명령은 사용자가 선택 인자와 위치 인자를 섞을 수 있도록 합니다. "
":meth:`~ArgumentParser.parse_intermixed_args` 와 "
":meth:`~ArgumentParser.parse_known_intermixed_args` 메서드는 이런 파싱 스타일을 "
"지원합니다."

#: ../Doc/library/argparse.rst:2076
msgid ""
"These parsers do not support all the argparse features, and will raise "
"exceptions if unsupported features are used.  In particular, subparsers, "
"``argparse.REMAINDER``, and mutually exclusive groups that include both "
"optionals and positionals are not supported."
msgstr ""
"이 파서들은 argparse 기능을 모두 지원하지는 않으며 지원되지 않는 기능이 사용되는 경우 예외를 발생시킵니다. 특히 부속 "
"파서, ``argparse.REMAINDER``, 그리고 옵션과 위치를 모두 포함하는 상호 배타적인 그룹은 지원되지 않습니다."

#: ../Doc/library/argparse.rst:2081
msgid ""
"The following example shows the difference between "
":meth:`~ArgumentParser.parse_known_args` and "
":meth:`~ArgumentParser.parse_intermixed_args`: the former returns ``['2',"
" '3']`` as unparsed arguments, while the latter collects all the "
"positionals into ``rest``.  ::"
msgstr ""
"다음 예제는 :meth:`~ArgumentParser.parse_known_args` 와 "
":meth:`~ArgumentParser.parse_intermixed_args` 의 차이점을 보여줍니다: 전자는 여분의 인자로 "
"``['2', '3']`` 을 반환하는 반면, 후자는 모든 위치 인자를 ``rest`` 로 모읍니다. ::"

#: ../Doc/library/argparse.rst:2096
msgid ""
":meth:`~ArgumentParser.parse_known_intermixed_args` returns a two item "
"tuple containing the populated namespace and the list of remaining "
"argument strings. :meth:`~ArgumentParser.parse_intermixed_args` raises an"
" error if there are any remaining unparsed argument strings."
msgstr ""
":meth:`~ArgumentParser.parse_known_intermixed_args` 는 채워진 이름 공간과 잔여 인자 "
"문자열의 리스트를 포함하는 두 항목 튜플을 반환합니다. "
":meth:`~ArgumentParser.parse_intermixed_args` 는 파싱되지 않은 인자 문자열이 남아 있으면 "
"에러를 발생시킵니다."

#: ../Doc/library/argparse.rst:2106
msgid "Upgrading optparse code"
msgstr "optparse 코드 업그레이드"

#: ../Doc/library/argparse.rst:2108
msgid ""
"Originally, the :mod:`argparse` module had attempted to maintain "
"compatibility with :mod:`optparse`.  However, :mod:`optparse` was "
"difficult to extend transparently, particularly with the changes required"
" to support the new ``nargs=`` specifiers and better usage messages.  "
"When most everything in :mod:`optparse` had either been copy-pasted over "
"or monkey-patched, it no longer seemed practical to try to maintain the "
"backwards compatibility."
msgstr ""
"원래, :mod:`argparse` 모듈은 :mod:`optparse` 와의 호환성을 유지하려고 시도했습니다. 그러나, "
":mod:`optparse` 는 투명하게 확장하기 어려운데, 특히 새로운 ``nargs=`` 지정자와 더 나은 사용법 메시지를 "
"지원하는 데 필요한 변경에서 그렇습니다. :mod:`optparse` 에 있는 대부분이 복사-붙여넣기 되었거나 몽키 패치되었을 때,"
" 더 하위 호환성을 유지하려고 노력하는 것이 실용적으로 보이지 않게 되었습니다."

#: ../Doc/library/argparse.rst:2115
msgid ""
"The :mod:`argparse` module improves on the standard library "
":mod:`optparse` module in a number of ways including:"
msgstr ":mod:`argparse` 모듈은 표준 라이브러리 :mod:`optparse` 모듈을 다음과 같은 여러 가지 방식으로 개선합니다:"

#: ../Doc/library/argparse.rst:2118
msgid "Handling positional arguments."
msgstr "위치 인자 처리."

#: ../Doc/library/argparse.rst:2119
msgid "Supporting sub-commands."
msgstr "부속 명령 지원."

#: ../Doc/library/argparse.rst:2120
msgid "Allowing alternative option prefixes like ``+`` and ``/``."
msgstr "``+`` 와 ``/`` 와 같은 다른 옵션 접두사 허용."

#: ../Doc/library/argparse.rst:2121
msgid "Handling zero-or-more and one-or-more style arguments."
msgstr "0개 이상 및 1개 이상 스타일의 인자 처리."

#: ../Doc/library/argparse.rst:2122
msgid "Producing more informative usage messages."
msgstr "더욱 유익한 사용법 메시지 생성."

#: ../Doc/library/argparse.rst:2123
msgid "Providing a much simpler interface for custom ``type`` and ``action``."
msgstr "사용자 정의 ``type`` 과 ``action`` 을 위한 훨씬 간단한 인터페이스 제공."

#: ../Doc/library/argparse.rst:2125
msgid "A partial upgrade path from :mod:`optparse` to :mod:`argparse`:"
msgstr ":mod:`optparse` 에서 :mod:`argparse` 로의 부분적인 업그레이드 경로:"

#: ../Doc/library/argparse.rst:2127
msgid ""
"Replace all :meth:`optparse.OptionParser.add_option` calls with "
":meth:`ArgumentParser.add_argument` calls."
msgstr ""
"모든 :meth:`optparse.OptionParser.add_option` 호출을 "
":meth:`ArgumentParser.add_argument` 호출로 대체하십시오."

#: ../Doc/library/argparse.rst:2130
msgid ""
"Replace ``(options, args) = parser.parse_args()`` with ``args = "
"parser.parse_args()`` and add additional "
":meth:`ArgumentParser.add_argument` calls for the positional arguments. "
"Keep in mind that what was previously called ``options``, now in the "
":mod:`argparse` context is called ``args``."
msgstr ""
"``(options, args) = parser.parse_args()`` 를 ``args = "
"parser.parse_args()`` 로 대체하고, 위치 인자에 대한 "
":meth:`ArgumentParser.add_argument` 호출을 추가하십시오. 이전에 ``options`` 라고 불렀던 것이"
" 이제 :mod:`argparse` 문맥에서 ``args`` 라는 것을 명심하십시오."

#: ../Doc/library/argparse.rst:2135
msgid ""
"Replace :meth:`optparse.OptionParser.disable_interspersed_args` by using "
":meth:`~ArgumentParser.parse_intermixed_args` instead of "
":meth:`~ArgumentParser.parse_args`."
msgstr ""
":meth:`optparse.OptionParser.disable_interspersed_args` 를 "
":meth:`~ArgumentParser.parse_args` 대신 "
":meth:`~ArgumentParser.parse_intermixed_args` 를 사용하여 대체하십시오."

#: ../Doc/library/argparse.rst:2139
msgid ""
"Replace callback actions and the ``callback_*`` keyword arguments with "
"``type`` or ``action`` arguments."
msgstr "콜백 액션과 ``callback_*`` 키워드 인자를 ``type`` 또는 ``action`` 인자로 대체하십시오."

#: ../Doc/library/argparse.rst:2142
msgid ""
"Replace string names for ``type`` keyword arguments with the "
"corresponding type objects (e.g. int, float, complex, etc)."
msgstr ""
"``type`` 키워드 인자를 위한 문자열 이름을 해당 type 객체(예를 들어, int, float, complex 등)로 "
"대체하십시오."

#: ../Doc/library/argparse.rst:2145
msgid ""
"Replace :class:`optparse.Values` with :class:`Namespace` and "
":exc:`optparse.OptionError` and :exc:`optparse.OptionValueError` with "
":exc:`ArgumentError`."
msgstr ""
":class:`optparse.Values` 를 :class:`Namespace` 로, "
":exc:`optparse.OptionError` 와 :exc:`optparse.OptionValueError` 를 "
":exc:`ArgumentError` 로 대체하십시오."

#: ../Doc/library/argparse.rst:2149
#, python-format
msgid ""
"Replace strings with implicit arguments such as ``%default`` or ``%prog``"
" with the standard Python syntax to use dictionaries to format strings, "
"that is, ``%(default)s`` and ``%(prog)s``."
msgstr ""
"``%default`` 나 ``%prog`` 와 같은 묵시적인 인자를 포함하는 문자열을, 문자열 포맷에 딕셔너리를 사용하는 표준 "
"파이썬 문법 대체하십시오, 즉 ``%(default)s`` 와 ``%(prog)s``."

#: ../Doc/library/argparse.rst:2153
msgid ""
"Replace the OptionParser constructor ``version`` argument with a call to "
"``parser.add_argument('--version', action='version', version='<the "
"version>')``."
msgstr ""
"OptionParser 생성자의 ``version`` 인자를 ``parser.add_argument('--version', "
"action='version', version='<the version>')`` 호출로 대체하십시오."

