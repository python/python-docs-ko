# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-19 18:31+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:2
msgid ":mod:`urllib.parse` --- Parse URLs into components"
msgstr ":mod:`urllib.parse` --- URL을 구성 요소로 구문 분석"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:7
msgid "**Source code:** :source:`Lib/urllib/parse.py`"
msgstr "**소스 코드:** :source:`Lib/urllib/parse.py`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:18
msgid ""
"This module defines a standard interface to break Uniform Resource "
"Locator (URL) strings up in components (addressing scheme, network "
"location, path etc.), to combine the components back into a URL string, "
"and to convert a \"relative URL\" to an absolute URL given a \"base "
"URL.\""
msgstr ""
"이 모듈은 URL(Uniform Resource Locator) 문자열을 구성 요소(주소 지정 체계, 네트워크 위치, 경로 등)로 "
"분리하고, 구성 요소를 다시 URL 문자열로 결합하고, \"상대 URL\"을 주어진 \"기본 URL\"에 따라 절대 URL로 "
"변환하는 표준 인터페이스를 정의합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:23
msgid ""
"The module has been designed to match the Internet RFC on Relative "
"Uniform Resource Locators. It supports the following URL schemes: "
"``file``, ``ftp``, ``gopher``, ``hdl``, ``http``, ``https``, ``imap``, "
"``mailto``, ``mms``, ``news``, ``nntp``, ``prospero``, ``rsync``, "
"``rtsp``, ``rtspu``, ``sftp``, ``shttp``, ``sip``, ``sips``, ``snews``, "
"``svn``, ``svn+ssh``, ``telnet``, ``wais``, ``ws``, ``wss``."
msgstr ""
"이 모듈은 상대 URL(Relative Uniform Resource Locators)의 인터넷 RFC와 일치하도록 설계되었습니다."
" 다음과 같은 URL 스킴을 지원합니다: ``file``, ``ftp``, ``gopher``, ``hdl``, ``http``, "
"``https``, ``imap``, ``mailto``, ``mms``, ``news``, ``nntp``, "
"``prospero``, ``rsync``, ``rtsp``, ``rtspu``, ``sftp``, ``shttp``, "
"``sip``, ``sips``, ``snews``, ``svn``, ``svn+ssh``, ``telnet``, ``wais``,"
" ``ws``, ``wss``."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:30
msgid ""
"The :mod:`urllib.parse` module defines functions that fall into two broad"
" categories: URL parsing and URL quoting. These are covered in detail in "
"the following sections."
msgstr ""
":mod:`urllib.parse` 모듈은 두 가지 넓은 범주에 속하는 함수들을 정의합니다: URL 구문 분석과 URL "
"인용(quoting). 이에 대해서는 다음 섹션에서 자세히 설명합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:35
msgid "URL Parsing"
msgstr "URL 구문 분석"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:37
msgid ""
"The URL parsing functions focus on splitting a URL string into its "
"components, or on combining URL components into a URL string."
msgstr "URL 구문 분석 함수는 URL 문자열을 구성 요소로 분할하거나 URL 구성 요소를 URL 문자열로 결합하는 데 중점을 둡니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:42
#, python-format
msgid ""
"Parse a URL into six components, returning a 6-item :term:`named tuple`."
"  This corresponds to the general structure of a URL: "
"``scheme://netloc/path;parameters?query#fragment``. Each tuple item is a "
"string, possibly empty. The components are not broken up in smaller parts"
" (for example, the network location is a single string), and % escapes "
"are not expanded. The delimiters as shown above are not part of the "
"result, except for a leading slash in the *path* component, which is "
"retained if present.  For example:"
msgstr ""
"URL을 6개의 구성 요소로 구문 분석하여, 6개 항목 :term:`네임드 튜플 <named tuple>`\\을 반환합니다. 이는 "
"URL의 일반적인 구조에 해당합니다: ``scheme://netloc/path;parameters?query#fragment``. "
"각 튜플 항목은 문자열이며 비어있을 수 있습니다. 구성 요소는 더 작은 부분으로 나뉘지 않으며 (예를 들어 네트워크 위치는 단일 "
"문자열입니다), % 이스케이프는 확장되지 않습니다. 위에 표시된 분리 문자는 *path* 구성 요소의 선행 슬래시를 제외하고는 "
"결과의 일부가 아니며 존재하면 유지됩니다. 예를 들면:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:63
msgid ""
"Following the syntax specifications in :rfc:`1808`, urlparse recognizes a"
" netloc only if it is properly introduced by '//'.  Otherwise the input "
"is presumed to be a relative URL and thus to start with a path component."
msgstr ""
":rfc:`1808`\\의 문법 명세에 따라, urlparse는 '//' 로 올바르게 도입되었을 때만 netloc을 인식합니다. "
"그렇지 않으면 입력은 상대 URL인 것으로 간주하고 path 구성 요소로 시작합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:82
msgid ""
"The *scheme* argument gives the default addressing scheme, to be used "
"only if the URL does not specify one.  It should be the same type (text "
"or bytes) as *urlstring*, except that the default value ``''`` is always "
"allowed, and is automatically converted to ``b''`` if appropriate."
msgstr ""
"*scheme* 인자는 URL이 지정하지 않은 경우에만 사용될 기본 주소 지정 체계를 제공합니다. 기본값 ``''``\\가 항상 "
"허용되고 필요하면 자동으로 ``b''``\\로 변환된다는 점을 제외하고, *urlstring*\\과 같은 형(텍스트나 "
"바이트열)이어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:87
msgid ""
"If the *allow_fragments* argument is false, fragment identifiers are not "
"recognized.  Instead, they are parsed as part of the path, parameters or "
"query component, and :attr:`fragment` is set to the empty string in the "
"return value."
msgstr ""
"*allow_fragments* 인자가 거짓이면, 프래그먼트 식별자는 인식되지 않습니다. 대신, path, parameters 또는"
" query 구성 요소의 일부로 구문 분석되고 :attr:`fragment`\\는 반환 값에서 빈 문자열로 설정됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:92
msgid ""
"The return value is a :term:`named tuple`, which means that its items can"
" be accessed by index or as named attributes, which are:"
msgstr ""
"반환 값은 :term:`네임드 튜플 <named tuple>`\\입니다. 즉, 다음과 같은 인덱스나 이름있는 어트리뷰트로 해당 "
"항목에 액세스 할 수 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:96
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:263
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:360
msgid "Attribute"
msgstr "어트리뷰트"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:96
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:263
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:360
msgid "Index"
msgstr "인덱스"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:96
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:263
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:360
msgid "Value"
msgstr "값"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:96
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:263
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:360
msgid "Value if not present"
msgstr "존재하지 않을 때의 값"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:98
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:265
msgid ":attr:`scheme`"
msgstr ":attr:`scheme`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:98
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:265
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:362
msgid "0"
msgstr "0"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:98
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:265
msgid "URL scheme specifier"
msgstr "URL 스킴 지정자"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:98
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:265
msgid "*scheme* parameter"
msgstr "*scheme* 매개 변수"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:100
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:267
msgid ":attr:`netloc`"
msgstr ":attr:`netloc`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:100
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:267
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:364
msgid "1"
msgstr "1"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:100
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:267
msgid "Network location part"
msgstr "네트워크 위치 부분"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:100
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:102
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:104
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:107
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:109
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:267
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:269
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:271
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:273
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:362
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:364
msgid "empty string"
msgstr "빈 문자열"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:102
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:269
msgid ":attr:`path`"
msgstr ":attr:`path`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:102
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:269
msgid "2"
msgstr "2"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:102
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:269
msgid "Hierarchical path"
msgstr "계층적 경로"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:104
msgid ":attr:`params`"
msgstr ":attr:`params`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:104
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:271
msgid "3"
msgstr "3"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:104
msgid "Parameters for last path element"
msgstr "마지막 경로 요소의 파라미터"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:107
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:271
msgid ":attr:`query`"
msgstr ":attr:`query`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:107
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:273
msgid "4"
msgstr "4"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:107
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:271
msgid "Query component"
msgstr "쿼리 구성 요소"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:109
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:273
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:364
msgid ":attr:`fragment`"
msgstr ":attr:`fragment`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:109
msgid "5"
msgstr "5"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:109
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:273
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:364
msgid "Fragment identifier"
msgstr "프래그먼트 식별자"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:111
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:275
msgid ":attr:`username`"
msgstr ":attr:`username`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:111
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:275
msgid "User name"
msgstr "사용자 이름"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:111
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:113
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:115
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:117
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:275
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:277
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:279
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:281
msgid ":const:`None`"
msgstr ":const:`None`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:113
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:277
msgid ":attr:`password`"
msgstr ":attr:`password`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:113
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:277
msgid "Password"
msgstr "비밀번호"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:115
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:279
msgid ":attr:`hostname`"
msgstr ":attr:`hostname`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:115
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:279
msgid "Host name (lower case)"
msgstr "호스트 이름 (소문자)"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:117
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:281
msgid ":attr:`port`"
msgstr ":attr:`port`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:117
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:281
msgid "Port number as integer, if present"
msgstr "존재하면, 정수로 표시되는 포트 번호"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:121
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:285
msgid ""
"Reading the :attr:`port` attribute will raise a :exc:`ValueError` if an "
"invalid port is specified in the URL.  See section :ref:`urlparse-result-"
"object` for more information on the result object."
msgstr ""
"URL에 잘못된 포트가 지정된 경우 :attr:`port` 어트리뷰트를 읽으면 :exc:`ValueError`\\가 발생합니다. "
"결과 객체에 대한 자세한 내용은 :ref:`urlparse-result-object` 섹션을 참조하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:125
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:289
msgid ""
"Unmatched square brackets in the :attr:`netloc` attribute will raise a "
":exc:`ValueError`."
msgstr ""
":attr:`netloc` 어트리뷰트에서 대괄호(square brackets)가 일치하지 않으면 "
":exc:`ValueError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:128
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:292
msgid ""
"Characters in the :attr:`netloc` attribute that decompose under NFKC "
"normalization (as used by the IDNA encoding) into any of ``/``, ``?``, "
"``#``, ``@``, or ``:`` will raise a :exc:`ValueError`. If the URL is "
"decomposed before parsing, no error will be raised."
msgstr ""
"(IDNA 인코딩에서 사용되는) NFKC 정규화에서 ``/``, ``?``, ``#``, ``@`` 또는 ``:`` 중 하나로 "
"분해(decompose)되는 :attr:`netloc` 어트리뷰트의 문자는 :exc:`ValueError`\\를 발생시킵니다. 구문"
" 분석하기 전에 URL이 분해(decompose)되면, 에러가 발생하지 않습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:133
msgid ""
"As is the case with all named tuples, the subclass has a few additional "
"methods and attributes that are particularly useful. One such method is "
":meth:`_replace`. The :meth:`_replace` method will return a new "
"ParseResult object replacing specified fields with new values."
msgstr ""
"모든 네임드 튜플의 경우와 마찬가지로, 서브 클래스는 특히 유용한 몇 가지 추가 메서드와 어트리뷰트를 갖습니다. 그러한 메서드 중 "
"하나는 :meth:`_replace`\\입니다. :meth:`_replace` 메서드는 지정된 필드를 새로운 값으로 대체한 새로운 "
"ParseResult 객체를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:151
msgid "Added IPv6 URL parsing capabilities."
msgstr "IPv6 URL 구문 분석 기능이 추가되었습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:154
msgid ""
"The fragment is now parsed for all URL schemes (unless *allow_fragment* "
"is false), in accordance with :rfc:`3986`.  Previously, a whitelist of "
"schemes that support fragments existed."
msgstr ""
":rfc:`3986`\\에 따라, 프래그먼트는 이제 모든 URL 스킴에 대해 구문 분석됩니다 (*allow_fragment*\\가 "
"거짓이 아니라면). 이전에는, 프래그먼트를 지원하는 스킴의 화이트리스트가 있었습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:159
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:297
msgid ""
"Out-of-range port numbers now raise :exc:`ValueError`, instead of "
"returning :const:`None`."
msgstr "범위를 벗어난 포트 번호는 이제 :const:`None`\\을 반환하는 대신 :exc:`ValueError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:163
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:301
msgid ""
"Characters that affect netloc parsing under NFKC normalization will now "
"raise :exc:`ValueError`."
msgstr "NFKC 정규화에서 netloc 구문 분석에 영향을 주는 문자는 이제 :exc:`ValueError`\\를 발생시킵니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:170
msgid ""
"Parse a query string given as a string argument (data of type "
":mimetype:`application/x-www-form-urlencoded`).  Data are returned as a "
"dictionary.  The dictionary keys are the unique query variable names and "
"the values are lists of values for each name."
msgstr ""
"문자열 인자(:mimetype:`application/x-www-form-urlencoded` 유형의 데이터)로 제공된 쿼리 "
"문자열을 구문 분석합니다. 데이터는 딕셔너리로 반환됩니다. 딕셔너리 키는 고유한 쿼리 변수 이름이고 값은 각 이름의 값 "
"리스트입니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:175
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:211
msgid ""
"The optional argument *keep_blank_values* is a flag indicating whether "
"blank values in percent-encoded queries should be treated as blank "
"strings. A true value indicates that blanks should be retained as  blank "
"strings.  The default false value indicates that blank values are to be "
"ignored and treated as if they were not included."
msgstr ""
"선택적 인자 *keep_blank_values*\\는 퍼센트 인코딩된 쿼리의 빈 값을 빈 문자열로 처리해야 하는지를 나타내는 "
"플래그입니다. 참값은 빈 값을 빈 문자열로 유지해야 함을 나타냅니다. 기본 거짓 값은 빈 값이 무시되고 포함되지 않은 것처럼 "
"처리됨을 나타냅니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:181
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:217
msgid ""
"The optional argument *strict_parsing* is a flag indicating what to do "
"with parsing errors.  If false (the default), errors are silently "
"ignored.  If true, errors raise a :exc:`ValueError` exception."
msgstr ""
"선택적 인자 *strict_parsing*\\은 구문 분석 에러 시 수행할 작업을 나타내는 플래그입니다. 거짓(기본값)이면, 에러가"
" 조용히 무시됩니다. 참이면, 에러는 :exc:`ValueError` 예외를 발생시킵니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:185
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:221
msgid ""
"The optional *encoding* and *errors* parameters specify how to decode "
"percent-encoded sequences into Unicode characters, as accepted by the "
":meth:`bytes.decode` method."
msgstr ""
"선택적 *encoding*\\과 *errors* 매개 변수는 :meth:`bytes.decode` 메서드에서 받아들이는 것처럼 "
"퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 지정합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:189
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:225
msgid ""
"The optional argument *max_num_fields* is the maximum number of fields to"
" read. If set, then throws a :exc:`ValueError` if there are more than "
"*max_num_fields* fields read."
msgstr ""
"선택적 인자 *max_num_fields*\\는 읽을 최대 필드 수입니다. 설정되면, *max_num_fields* 필드보다 많은 "
"것을 읽을 때 :exc:`ValueError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:193
msgid ""
"Use the :func:`urllib.parse.urlencode` function (with the ``doseq`` "
"parameter set to ``True``) to convert such dictionaries into query "
"strings."
msgstr ""
"이러한 딕셔너리를 쿼리 문자열로 변환하려면 :func:`urllib.parse.urlencode` 함수를 (``doseq`` 매개 "
"변수를 ``True``\\로 설정해서) 사용하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:198
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:232
msgid "Add *encoding* and *errors* parameters."
msgstr "*encoding*\\과 *errors* 매개 변수를 추가합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:201
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:235
msgid "Added *max_num_fields* parameter."
msgstr "*max_num_fields* 매개 변수를 추가했습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:207
msgid ""
"Parse a query string given as a string argument (data of type "
":mimetype:`application/x-www-form-urlencoded`).  Data are returned as a "
"list of name, value pairs."
msgstr ""
"문자열 인자(:mimetype:`application/x-www-form-urlencoded` 유형의 데이터)로 제공된 쿼리 "
"문자열을 구문 분석합니다. 데이터는 이름, 값 쌍의 리스트로 반환됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:229
msgid ""
"Use the :func:`urllib.parse.urlencode` function to convert such lists of "
"pairs into query strings."
msgstr "이러한 쌍의 리스트를 쿼리 문자열로 변환하려면 :func:`urllib.parse.urlencode` 함수를 사용하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:241
msgid ""
"Construct a URL from a tuple as returned by ``urlparse()``. The *parts* "
"argument can be any six-item iterable. This may result in a slightly "
"different, but equivalent URL, if the URL that was parsed originally had "
"unnecessary delimiters (for example, a ``?`` with an empty query; the RFC"
" states that these are equivalent)."
msgstr ""
"``urlparse()``\\에 의해 반환된 튜플에서 URL을 구성합니다. *parts* 인자는 임의의 6개 항목 이터러블일 수 "
"있습니다. 구문 분석된 원래 URL에 불필요한 구분자가 있는 경우 (예를 들어 비어있는 쿼리가 있는 ``?``; RFC는 이들이 "
"동등하다고 말합니다) 약간 다르지만 동등한 URL이 만들어질 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:250
msgid ""
"This is similar to :func:`urlparse`, but does not split the params from "
"the URL. This should generally be used instead of :func:`urlparse` if the"
" more recent URL syntax allowing parameters to be applied to each segment"
" of the *path* portion of the URL (see :rfc:`2396`) is wanted.  A "
"separate function is needed to separate the path segments and parameters."
"  This function returns a 5-item :term:`named tuple`::"
msgstr ""
"이것은 :func:`urlparse`\\와 유사하지만, URL에서 파라미터를 분할하지 않습니다. URL의 *path* 부분의 각 "
"세그먼트에 파라미터를 적용할 수 있는 최신 URL 문법(:rfc:`2396`\\을 참조하십시오)이 필요하면 일반적으로 "
":func:`urlparse` 대신 사용해야 합니다. 경로 세그먼트와 파라미터를 분리하려면 별도의 함수가 필요합니다. 이 함수는 "
"5개 항목 :term:`네임드 튜플 <named tuple>`\\을 반환합니다::"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:259
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:356
msgid ""
"The return value is a :term:`named tuple`, its items can be accessed by "
"index or as named attributes:"
msgstr ""
"반환 값은 :term:`네임드 튜플 <named tuple>`\\입니다, 항목은 인덱스나 이름 붙은 어트리뷰트로 액세스 할 수 "
"있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:308
msgid ""
"Combine the elements of a tuple as returned by :func:`urlsplit` into a "
"complete URL as a string. The *parts* argument can be any five-item "
"iterable. This may result in a slightly different, but equivalent URL, if"
" the URL that was parsed originally had unnecessary delimiters (for "
"example, a ? with an empty query; the RFC states that these are "
"equivalent)."
msgstr ""
":func:`urlsplit`\\에 의해 반환된 튜플 요소를 완전한 URL 문자열로 결합합니다. *parts* 인자는 임의의 5개 "
"항목 이터러블일 수 있습니다. 구문 분석된 원래 URL에 불필요한 구분자가 있는 경우 (예를 들어 비어있는 쿼리가 있는 ?; "
"RFC는 이들이 동등하다고 말합니다) 약간 다르지만 동등한 URL이 만들어질 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:317
msgid ""
"Construct a full (\"absolute\") URL by combining a \"base URL\" (*base*) "
"with another URL (*url*).  Informally, this uses components of the base "
"URL, in particular the addressing scheme, the network location and (part "
"of) the path, to provide missing components in the relative URL.  For "
"example:"
msgstr ""
"\"기본 URL\"(*base*)을 다른 URL(*url*)과 결합하여 전체 (\"절대\") URL을 구성합니다. 비형식적으로, "
"이것은 기본 URL의 구성 요소, 특히 주소 지정 체계, 네트워크 위치 및 경로(의 일부)를 사용하여 상대 URL에 누락된 구성 "
"요소를 제공합니다. 예를 들면:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:326
msgid ""
"The *allow_fragments* argument has the same meaning and default as for "
":func:`urlparse`."
msgstr "*allow_fragments* 인자는 :func:`urlparse`\\와 같은 의미와 기본값을 갖습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:331
msgid ""
"If *url* is an absolute URL (that is, starting with ``//`` or "
"``scheme://``), the *url*'s host name and/or scheme will be present in "
"the result.  For example:"
msgstr ""
"*url*\\이 절대 URL이면 (즉, ``//``\\나 ``scheme://``\\로 시작하면), *url*\\의 호스트 이름 "
"및/또는 스킴이 결과에 나타납니다. 예를 들면:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:340
msgid ""
"If you do not want that behavior, preprocess the *url* with "
":func:`urlsplit` and :func:`urlunsplit`, removing possible *scheme* and "
"*netloc* parts."
msgstr ""
"이런 동작을 원하지 않으면, *url*\\을 :func:`urlsplit`\\과 :func:`urlunsplit`\\으로 사전 "
"처리하여 가능한 *scheme*\\과 *netloc* 부분을 제거하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:346
msgid "Behaviour updated to match the semantics defined in :rfc:`3986`."
msgstr ":rfc:`3986`\\에 정의된 의미론과 일치하도록 동작이 갱신되었습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:351
msgid ""
"If *url* contains a fragment identifier, return a modified version of "
"*url* with no fragment identifier, and the fragment identifier as a "
"separate string.  If there is no fragment identifier in *url*, return "
"*url* unmodified and an empty string."
msgstr ""
"*url*\\에 프래그먼트 식별자가 포함되면, 프래그먼트 식별자 없는 *url*\\의 수정된 버전과 프래그먼트 식별자를 별도의 "
"문자열로 반환합니다. *url*\\에 프래그먼트 식별자가 없으면, 수정되지 않은 *url*\\과 빈 문자열을 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:362
msgid ":attr:`url`"
msgstr ":attr:`url`"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:362
msgid "URL with no fragment"
msgstr "프래그먼트 없는 URL"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:367
msgid ""
"See section :ref:`urlparse-result-object` for more information on the "
"result object."
msgstr "결과 객체에 대한 자세한 정보는 섹션 :ref:`urlparse-result-object`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:370
msgid "Result is a structured object rather than a simple 2-tuple."
msgstr "결과는 단순한 2-튜플이 아닌 구조화된 객체입니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:375
msgid ""
"Extract the url from a wrapped URL (that is, a string formatted as "
"``<URL:scheme://host/path>``, ``<scheme://host/path>``, "
"``URL:scheme://host/path`` or ``scheme://host/path``). If *url* is not a "
"wrapped URL, it is returned without changes."
msgstr ""
"래핑 된 URL(즉, ``<URL:scheme://host/path>``, ``<scheme://host/path>``, "
"``URL:scheme://host/path`` 또는 ``scheme://host/path`` 형식의 문자열)에서 URL을 "
"추출합니다. *url*\\이 래핑 된 URL이 아니면, 변경 없이 반환됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:383
msgid "Parsing ASCII Encoded Bytes"
msgstr "ASCII로 인코딩된 바이트열 구문 분석"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:385
msgid ""
"The URL parsing functions were originally designed to operate on "
"character strings only. In practice, it is useful to be able to "
"manipulate properly quoted and encoded URLs as sequences of ASCII bytes. "
"Accordingly, the URL parsing functions in this module all operate on "
":class:`bytes` and :class:`bytearray` objects in addition to :class:`str`"
" objects."
msgstr ""
"URL 구문 분석 함수는 원래 문자열에서만 작동하도록 설계되었습니다. 실제로는, 적절히 인용되고 인코딩된 URL을 ASCII 바이트"
" 시퀀스로 조작할 수 있으면 유용합니다. 따라서, 이 모듈의 URL 구문 분석 함수는 모두 :class:`str` 객체 외에 "
":class:`bytes`\\와 :class:`bytearray` 객체에서 작동합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:391
msgid ""
"If :class:`str` data is passed in, the result will also contain only "
":class:`str` data. If :class:`bytes` or :class:`bytearray` data is passed"
" in, the result will contain only :class:`bytes` data."
msgstr ""
":class:`str` 데이터가 전달되면, 결과에는 :class:`str` 데이터만 포함됩니다. :class:`bytes`\\나 "
":class:`bytearray` 데이터가 전달되면, 결과에는 :class:`bytes` 데이터만 포함됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:395
msgid ""
"Attempting to mix :class:`str` data with :class:`bytes` or "
":class:`bytearray` in a single function call will result in a "
":exc:`TypeError` being raised, while attempting to pass in non-ASCII byte"
" values will trigger :exc:`UnicodeDecodeError`."
msgstr ""
"단일 함수 호출에서 :class:`str` 데이터를 :class:`bytes`\\나 :class:`bytearray`\\와 "
"혼합하려고 시도하면 :exc:`TypeError`\\가 발생하는 반면, 비 ASCII 바이트 값을 전달하면 "
":exc:`UnicodeDecodeError`\\가 트리거 됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:400
msgid ""
"To support easier conversion of result objects between :class:`str` and "
":class:`bytes`, all return values from URL parsing functions provide "
"either an :meth:`encode` method (when the result contains :class:`str` "
"data) or a :meth:`decode` method (when the result contains :class:`bytes`"
" data). The signatures of these methods match those of the corresponding "
":class:`str` and :class:`bytes` methods (except that the default encoding"
" is ``'ascii'`` rather than ``'utf-8'``). Each produces a value of a "
"corresponding type that contains either :class:`bytes` data (for "
":meth:`encode` methods) or :class:`str` data (for :meth:`decode` "
"methods)."
msgstr ""
":class:`str`\\과 :class:`bytes` 간에 결과 객체를 쉽게 변환 할 수 있도록, URL 구문 분석 함수의 모든 "
"반환 값은 :meth:`encode` 메서드(결과에 :class:`str` 데이터가 포함될 때)나 :meth:`decode` "
"메서드(결과에 :class:`bytes` 데이터가 포함될 때)를 제공합니다. 이러한 메서드의 서명은 해당 "
":class:`str`\\와 :class:`bytes` 메서드의 서명과 일치합니다 (기본 인코딩이 ``'utf-8'``\\가 아니라"
" ``'ascii'``\\라는 점은 예외입니다). 각각은 :class:`bytes` 데이터(:meth:`encode` 메서드의 "
"경우)나 :class:`str` 데이터(:meth:`decode` 메서드의 경우)를 포함하는 해당 형의 값을 생성합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:411
msgid ""
"Applications that need to operate on potentially improperly quoted URLs "
"that may contain non-ASCII data will need to do their own decoding from "
"bytes to characters before invoking the URL parsing methods."
msgstr ""
"ASCII가 아닌 데이터를 포함할 수 있는 잘못 인용된 URL에서 작동할 가능성이 있는 응용 프로그램은 URL 구문 분석 메서드를 "
"호출하기 전에 바이트열에서 문자로 자체 디코딩을 수행할 필요가 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:415
msgid ""
"The behaviour described in this section applies only to the URL parsing "
"functions. The URL quoting functions use their own rules when producing "
"or consuming byte sequences as detailed in the documentation of the "
"individual URL quoting functions."
msgstr ""
"이 섹션에서 설명하는 동작은 URL 구문 분석 함수에만 적용됩니다. URL 인용 함수는 개별 URL 인용 함수의 설명서에 기술된 "
"대로 바이트 시퀀스를 생성하거나 소비할 때 자체 규칙을 사용합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:420
msgid "URL parsing functions now accept ASCII encoded byte sequences"
msgstr "URL 구문 분석 함수는 이제 ASCII 인코딩된 바이트 시퀀스를 받아들입니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:427
msgid "Structured Parse Results"
msgstr "구조화된 구문 분석 결과"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:429
msgid ""
"The result objects from the :func:`urlparse`, :func:`urlsplit`  and "
":func:`urldefrag` functions are subclasses of the :class:`tuple` type. "
"These subclasses add the attributes listed in the documentation for those"
" functions, the encoding and decoding support described in the previous "
"section, as well as an additional method:"
msgstr ""
":func:`urlparse`, :func:`urlsplit` 및 :func:`urldefrag` 함수의 결과 객체는 "
":class:`tuple` 형의 서브 클래스입니다. 이 서브 클래스는 해당 함수에 대한 설명서에 나열된 어트리뷰트, 이전 섹션에서 "
"설명한 인코딩과 디코딩 지원 및 추가 메서드를 추가합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:437
msgid ""
"Return the re-combined version of the original URL as a string. This may "
"differ from the original URL in that the scheme may be normalized to "
"lower case and empty components may be dropped. Specifically, empty "
"parameters, queries, and fragment identifiers will be removed."
msgstr ""
"원래 URL의 재결합된 버전을 문자열로 반환합니다. 스킴이 소문자로 정규화되고 빈 구성 요소가 삭제될 수 있다는 점에서 원래 "
"URL과 다를 수 있습니다. 특히, 빈 파라미터, 쿼리 및 프래그먼트 식별자가 제거됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:442
msgid ""
"For :func:`urldefrag` results, only empty fragment identifiers will be "
"removed. For :func:`urlsplit` and :func:`urlparse` results, all noted "
"changes will be made to the URL returned by this method."
msgstr ""
":func:`urldefrag` 결과의 경우, 빈 프래그먼트 식별자만 제거됩니다. :func:`urlsplit`\\과 "
":func:`urlparse` 결과의 경우, 이 메서드가 반환한 URL에 대해 언급된 모든 변경 사항이 적용됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:446
msgid ""
"The result of this method remains unchanged if passed back through the "
"original parsing function:"
msgstr "이 메서드의 결과는 원래 구문 분석 함수를 통해 다시 전달될 때 변경되지 않은 상태로 유지됩니다:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:459
msgid ""
"The following classes provide the implementations of the structured parse"
" results when operating on :class:`str` objects:"
msgstr "다음 클래스는 :class:`str` 객체에서 작동할 때 구조화된 구문 분석 결과의 구현을 제공합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:464
msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`str` "
"data. The :meth:`encode` method returns a :class:`DefragResultBytes` "
"instance."
msgstr ""
":class:`str` 데이터를 포함하는 :func:`urldefrag` 결과의 구상 클래스. :meth:`encode` 메서드는 "
":class:`DefragResultBytes` 인스턴스를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:472
msgid ""
"Concrete class for :func:`urlparse` results containing :class:`str` data."
" The :meth:`encode` method returns a :class:`ParseResultBytes` instance."
msgstr ""
":class:`str` 데이터를 포함하는 :func:`urlparse` 결과의 구상 클래스. :meth:`encode` 메서드는 "
":class:`ParseResultBytes` 인스턴스를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:478
msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`str` data."
" The :meth:`encode` method returns a :class:`SplitResultBytes` instance."
msgstr ""
":class:`str` 데이터를 포함하는 :func:`urlsplit` 결과의 구상 클래스. :meth:`encode` 메서드는 "
":class:`SplitResultBytes` 인스턴스를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:483
msgid ""
"The following classes provide the implementations of the parse results "
"when operating on :class:`bytes` or :class:`bytearray` objects:"
msgstr ""
"다음 클래스는 :class:`bytes`\\나 :class:`bytearray` 객체에서 작동할 때 구문 분석 결과의 구현을 "
"제공합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:488
msgid ""
"Concrete class for :func:`urldefrag` results containing :class:`bytes` "
"data. The :meth:`decode` method returns a :class:`DefragResult` instance."
msgstr ""
":class:`bytes` 데이터를 포함하는 :func:`urldefrag` 결과의 구상 클래스. :meth:`decode` "
"메서드는 :class:`DefragResult` 인스턴스를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:496
msgid ""
"Concrete class for :func:`urlparse` results containing :class:`bytes` "
"data. The :meth:`decode` method returns a :class:`ParseResult` instance."
msgstr ""
":class:`bytes` 데이터를 포함하는 :func:`urlparse` 결과의 구상 클래스. :meth:`decode` 메서드는"
" :class:`ParseResult` 인스턴스를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:504
msgid ""
"Concrete class for :func:`urlsplit` results containing :class:`bytes` "
"data. The :meth:`decode` method returns a :class:`SplitResult` instance."
msgstr ""
":class:`bytes` 데이터를 포함하는 :func:`urlsplit` 결과의 구상 클래스. :meth:`decode` 메서드는"
" :class:`SplitResult` 인스턴스를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:512
msgid "URL Quoting"
msgstr "URL 인용"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:514
msgid ""
"The URL quoting functions focus on taking program data and making it safe"
" for use as URL components by quoting special characters and "
"appropriately encoding non-ASCII text. They also support reversing these "
"operations to recreate the original data from the contents of a URL "
"component if that task isn't already covered by the URL parsing functions"
" above."
msgstr ""
"URL 인용(quoting) 함수는 특수 문자를 인용하고 비 ASCII 텍스트를 적절히 인코딩하여 프로그램 데이터를 취해서 URL "
"구성 요소로 안전하게 사용할 수 있도록 하는 데 중점을 둡니다. 또한 해당 작업이 위의 URL 구문 분석 함수로 처리되지 않는 경우"
" URL 구성 요소의 내용에서 원래 데이터를 다시 만들기 위해 이러한 작업을 뒤집는 것도 지원합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:522
#, python-format
msgid ""
"Replace special characters in *string* using the ``%xx`` escape. Letters,"
" digits, and the characters ``'_.-~'`` are never quoted. By default, this"
" function is intended for quoting the path section of URL. The optional "
"*safe* parameter specifies additional ASCII characters that should not be"
" quoted --- its default value is ``'/'``."
msgstr ""
"``%xx`` 이스케이프를 사용하여 *string*\\의 특수 문자를 치환합니다. 글자, 숫자 및 문자 ``'_.-~'``\\는 "
"절대 인용되지 않습니다. 기본적으로, 이 함수는 URL의 경로 섹션을 인용하기 위한 것입니다. 선택적 *safe* 매개 변수는 "
"인용해서는 안 되는 추가 ASCII 문자를 지정합니다 --- 기본값은 ``'/'``\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:528
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:598
msgid "*string* may be either a :class:`str` or a :class:`bytes`."
msgstr "*string*\\은 :class:`str`\\이나 :class:`bytes`\\일 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:530
msgid ""
"Moved from :rfc:`2396` to :rfc:`3986` for quoting URL strings. \"~\" is "
"now included in the set of unreserved characters."
msgstr ""
"URL 문자열 인용을 :rfc:`2396`\\에서 :rfc:`3986`\\으로 옮겼습니다. \"~\"는 이제 예약되지 않은 문자 "
"집합에 포함됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:534
msgid ""
"The optional *encoding* and *errors* parameters specify how to deal with "
"non-ASCII characters, as accepted by the :meth:`str.encode` method. "
"*encoding* defaults to ``'utf-8'``. *errors* defaults to ``'strict'``, "
"meaning unsupported characters raise a :class:`UnicodeEncodeError`. "
"*encoding* and *errors* must not be supplied if *string* is a "
":class:`bytes`, or a :class:`TypeError` is raised."
msgstr ""
"선택적 *encoding*\\과 *errors* 매개 변수는 :meth:`str.encode` 메서드에서 받아들이는 것처럼 비 "
"ASCII 문자를 처리하는 방법을 지정합니다. *encoding*\\의 기본값은 ``'utf-8'``\\입니다. "
"*errors*\\의 기본값은 ``'strict'``\\로, 지원되지 않는 문자는 "
":class:`UnicodeEncodeError`\\를 발생시킴을 의미합니다. *string*\\이 "
":class:`bytes`\\이면 *encoding*\\과 *errors*\\를 제공해서는 안 됩니다, 그렇지 않으면 "
":class:`TypeError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:542
msgid ""
"Note that ``quote(string, safe, encoding, errors)`` is equivalent to "
"``quote_from_bytes(string.encode(encoding, errors), safe)``."
msgstr ""
"``quote(string, safe, encoding, errors)``\\는 "
"``quote_from_bytes(string.encode(encoding, errors), safe)``\\와 동등함에 "
"유의하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:545
msgid "Example: ``quote('/El Niño/')`` yields ``'/El%20Ni%C3%B1o/'``."
msgstr "예: ``quote('/El Niño/')``\\는 ``'/El%20Ni%C3%B1o/'``\\를 산출합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:550
msgid ""
"Like :func:`quote`, but also replace spaces by plus signs, as required "
"for quoting HTML form values when building up a query string to go into a"
" URL. Plus signs in the original string are escaped unless they are "
"included in *safe*.  It also does not have *safe* default to ``'/'``."
msgstr ""
":func:`quote`\\와 유사하지만, URL로 이동하기 위한 쿼리 문자열을 만들 때 HTML 폼값을 인용하는 데 필요한 대로 "
"스페이스를 더하기 부호로 치환하기도 합니다. *safe*\\에 포함되지 않으면 원래 문자열의 더하기 부호가 이스케이프 됩니다. 또한"
" *safe*\\의 기본값은 ``'/'``\\가 아닙니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:555
#, python-format
msgid "Example: ``quote_plus('/El Niño/')`` yields ``'%2FEl+Ni%C3%B1o%2F'``."
msgstr "예: ``quote_plus('/El Niño/')``\\는 ``'%2FEl+Ni%C3%B1o%2F'``\\를 산출합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:560
msgid ""
"Like :func:`quote`, but accepts a :class:`bytes` object rather than a "
":class:`str`, and does not perform string-to-bytes encoding."
msgstr ""
":func:`quote`\\와 유사하지만, :class:`str` 대신 :class:`bytes` 객체를 받아들이고, 문자열을 "
"바이트열로 인코딩하지 않습니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:563
#, python-format
msgid "Example: ``quote_from_bytes(b'a&\\xef')`` yields ``'a%26%EF'``."
msgstr "예: ``quote_from_bytes(b'a&\\xef')``\\는 ``'a%26%EF'``\\를 산출합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:569
#, python-format
msgid ""
"Replace ``%xx`` escapes by their single-character equivalent. The "
"optional *encoding* and *errors* parameters specify how to decode "
"percent-encoded sequences into Unicode characters, as accepted by the "
":meth:`bytes.decode` method."
msgstr ""
"``%xx`` 이스케이프를 해당 단일 문자로 치환합니다. 선택적 *encoding*\\과 *errors* 매개 변수는 "
":meth:`bytes.decode` 메서드에서 받아들이는 것처럼 퍼센트 인코딩된 시퀀스를 유니코드 문자로 디코딩하는 방법을 "
"지정합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:574
#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:588
msgid "*string* must be a :class:`str`."
msgstr "*string*\\은 :class:`str`\\이어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:576
msgid ""
"*encoding* defaults to ``'utf-8'``. *errors* defaults to ``'replace'``, "
"meaning invalid sequences are replaced by a placeholder character."
msgstr ""
"*encoding*\\의 기본값은 ``'utf-8'``\\입니다. *errors*\\의 기본값은 ``'replace'``\\로, "
"유효하지 않은 시퀀스는 자리 표시자 문자(placeholder character)로 대체됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:580
msgid "Example: ``unquote('/El%20Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "예: ``unquote('/El%20Ni%C3%B1o/')``\\는 ``'/El Niño/'``\\를 산출합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:585
msgid ""
"Like :func:`unquote`, but also replace plus signs by spaces, as required "
"for unquoting HTML form values."
msgstr ""
":func:`unquote`\\와 유사하지만, HTML 폼값을 인용 해제할 때 요구되는 것처럼, 더하기 부호를 스페이스로 치환하기도"
" 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:590
msgid "Example: ``unquote_plus('/El+Ni%C3%B1o/')`` yields ``'/El Niño/'``."
msgstr "예: ``unquote_plus('/El+Ni%C3%B1o/')``\\는 ``'/El Niño/'``\\를 산출합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:595
#, python-format
msgid ""
"Replace ``%xx`` escapes by their single-octet equivalent, and return a "
":class:`bytes` object."
msgstr "``%xx`` 이스케이프를 해당 단일 옥텟(octet)으로 대체하고, :class:`bytes` 객체를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:600
msgid ""
"If it is a :class:`str`, unescaped non-ASCII characters in *string* are "
"encoded into UTF-8 bytes."
msgstr ":class:`str`\\이면, *string*\\의 이스케이프 되지 않은 비 ASCII 문자는 UTF-8 바이트열로 인코딩됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:603
#, python-format
msgid "Example: ``unquote_to_bytes('a%26%EF')`` yields ``b'a&\\xef'``."
msgstr "예: ``unquote_to_bytes('a%26%EF')``\\는 ``b'a&\\xef'``\\를 산출합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:609
msgid ""
"Convert a mapping object or a sequence of two-element tuples, which may "
"contain :class:`str` or :class:`bytes` objects, to a percent-encoded "
"ASCII text string.  If the resultant string is to be used as a *data* for"
" POST operation with the :func:`~urllib.request.urlopen` function, then "
"it should be encoded to bytes, otherwise it would result in a "
":exc:`TypeError`."
msgstr ""
":class:`str`\\이나 :class:`bytes` 객체를 포함할 수 있는 매핑 객체나 두 요소 튜플의 시퀀스를 퍼센트 "
"인코딩된 ASCII 텍스트 문자열로 변환합니다. 결과 문자열을 :func:`~urllib.request.urlopen` 함수를 "
"사용하여 POST 연산을 위한 *data*\\로 사용하려면, 바이트열로 인코딩해야 합니다, 그렇지 않으면 "
":exc:`TypeError`\\가 발생합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:616
#, python-format
msgid ""
"The resulting string is a series of ``key=value`` pairs separated by "
"``'&'`` characters, where both *key* and *value* are quoted using the "
"*quote_via* function.  By default, :func:`quote_plus` is used to quote "
"the values, which means spaces are quoted as a ``'+'`` character and '/' "
"characters are encoded as ``%2F``, which follows the standard for GET "
"requests (``application/x-www-form-urlencoded``).  An alternate function "
"that can be passed as *quote_via* is :func:`quote`, which will encode "
"spaces as ``%20`` and not encode '/' characters.  For maximum control of "
"what is quoted, use ``quote`` and specify a value for *safe*."
msgstr ""
"결과 문자열은 ``'&'`` 문자로 구분된 일련의 ``key=value`` 쌍이고, 여기서 *key*\\와 *value*\\는 "
"*quote_via* 함수를 사용하여 인용됩니다. 기본적으로, :func:`quote_plus`\\가 값을 인용하는 데 사용되는데,"
" 스페이스는 ``'+'`` 문자로 인용되고 '/' 문자는 ``%2F``\\로 인코딩되어 GET 요청 "
"표준(``application/x-www-form-urlencoded``)을 따름을 뜻합니다. *quote_via*\\로 전달될 수"
" 있는 대체 함수는 :func:`quote`\\이며, 스페이스를 ``%20``\\로 인코딩하고 '/' 문자를 인코딩하지 않습니다. "
"무엇을 인용할지를 최대한 제어하려면, ``quote``\\를 사용하고 *safe*\\의 값을 지정하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:626
msgid ""
"When a sequence of two-element tuples is used as the *query* argument, "
"the first element of each tuple is a key and the second is a value. The "
"value element in itself can be a sequence and in that case, if the "
"optional parameter *doseq* is evaluates to ``True``, individual "
"``key=value`` pairs separated by ``'&'`` are generated for each element "
"of the value sequence for the key.  The order of parameters in the "
"encoded string will match the order of parameter tuples in the sequence."
msgstr ""
"*query* 인자에 두 요소 튜플의 시퀀스가 사용될 때, 각 튜플의 첫 번째 요소는 키이고 두 번째 요소는 값입니다. 값 요소 "
"자체는 시퀀스일 수 있으며, 이 경우 선택적 매개 변수 *doseq*\\가 ``True``\\로 평가되면, ``'&'``\\로 "
"구분된 개별 ``key=value`` 쌍이 키에 대한 값 시퀀스의 각 요소에 대해 생성됩니다. 인코딩된 문자열의 파라미터 순서는 "
"시퀀스의 파라미터 튜플 순서와 일치합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:634
msgid ""
"The *safe*, *encoding*, and *errors* parameters are passed down to "
"*quote_via* (the *encoding* and *errors* parameters are only passed when "
"a query element is a :class:`str`)."
msgstr ""
"*safe*, *encoding* 및 *errors* 매개 변수는 *quote_via*\\로 전달됩니다 (*encoding*\\과 "
"*errors* 매개 변수는 쿼리 요소가 :class:`str`\\일 때만 전달됩니다)."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:638
msgid ""
"To reverse this encoding process, :func:`parse_qs` and :func:`parse_qsl` "
"are provided in this module to parse query strings into Python data "
"structures."
msgstr ""
"이 인코딩 프로세스를 뒤집기 위해, 쿼리 문자열을 파이썬 데이터 구조로 구문 분석하기 위해 이 모듈에서 "
":func:`parse_qs`\\와 :func:`parse_qsl`\\이 제공됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:641
msgid ""
"Refer to :ref:`urllib examples <urllib-examples>` to find out how "
"urlencode method can be used for generating query string for a URL or "
"data for POST."
msgstr ""
"urlencode 메서드를 사용하여 URL의 쿼리 문자열이나 POST의 데이터를 생성하는 방법을 알아보려면 :ref:`urllib "
"예제 <urllib-examples>`\\를 참조하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:644
msgid "Query parameter supports bytes and string objects."
msgstr "query 매개 변수는 바이트열과 문자열 객체를 지원합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:647
msgid "*quote_via* parameter."
msgstr "*quote_via* 매개 변수."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:657
msgid ":rfc:`3986` - Uniform Resource Identifiers"
msgstr ":rfc:`3986` - Uniform Resource Identifiers"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:654
msgid ""
"This is the current standard (STD66). Any changes to urllib.parse module "
"should conform to this. Certain deviations could be observed, which are "
"mostly for backward compatibility purposes and for certain de-facto "
"parsing requirements as commonly observed in major browsers."
msgstr ""
"이것이 현재 표준입니다 (STD66). urllib.parse 모듈에 대한 모든 변경 사항은 이를 준수해야 합니다. 특정 편차가 "
"관찰될 수 있는데, 이는 대부분 이전 버전과의 호환성과 주요 브라우저에서 일반적으로 관찰되는 사실상의 구문 분석 요구 사항을 위한 "
"것입니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:660
msgid ":rfc:`2732` - Format for Literal IPv6 Addresses in URL's."
msgstr ":rfc:`2732` - Format for Literal IPv6 Addresses in URL's."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:660
msgid "This specifies the parsing requirements of IPv6 URLs."
msgstr "IPv6 URL의 구문 분석 요구 사항을 지정합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:664
msgid ":rfc:`2396` - Uniform Resource Identifiers (URI): Generic Syntax"
msgstr ":rfc:`2396` - Uniform Resource Identifiers (URI): Generic Syntax"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:663
msgid ""
"Document describing the generic syntactic requirements for both Uniform "
"Resource Names (URNs) and Uniform Resource Locators (URLs)."
msgstr ""
"URN(Uniform Resource Names)과 URL(Uniform Resource Locator)에 대한 일반적인 문법 요구"
" 사항을 설명하는 문서."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:667
msgid ":rfc:`2368` - The mailto URL scheme."
msgstr ":rfc:`2368` - The mailto URL scheme."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:667
msgid "Parsing requirements for mailto URL schemes."
msgstr "mailto URL 스킴에 대한 구문 분석 요구 사항."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:672
msgid ":rfc:`1808` - Relative Uniform Resource Locators"
msgstr ":rfc:`1808` - Relative Uniform Resource Locators"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:670
msgid ""
"This Request For Comments includes the rules for joining an absolute and "
"a relative URL, including a fair number of \"Abnormal Examples\" which "
"govern the treatment of border cases."
msgstr ""
"이 RFC는 경계 사례의 처리를 정의하는 꽤 많은 수의 \"비정상적인 예\"를 포함하여, 절대와 상대 URL을 결합하는 규칙을 "
"포함합니다."

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:674
msgid ":rfc:`1738` - Uniform Resource Locators (URL)"
msgstr ":rfc:`1738` - Uniform Resource Locators (URL)"

#: /Users/flowdas/works/docs/python/src/Doc/library/urllib.parse.rst:675
msgid "This specifies the formal syntax and semantics of absolute URLs."
msgstr "절대 URL의 형식 문법과 의미를 지정합니다."

