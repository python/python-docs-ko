# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-03-26 14:46+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Changhyun An <88soldieron@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/library/pdb.rst:4
msgid ":mod:`pdb` --- The Python Debugger"
msgstr ":mod:`pdb` --- 파이썬 디버거"

#: ../Doc/library/pdb.rst:9
msgid "**Source code:** :source:`Lib/pdb.py`"
msgstr "**소스 코드:** :source:`Lib/pdb.py`"

#: ../Doc/library/pdb.rst:15
msgid ""
"The module :mod:`pdb` defines an interactive source code debugger for "
"Python programs.  It supports setting (conditional) breakpoints and "
"single stepping at the source line level, inspection of stack frames, "
"source code listing, and evaluation of arbitrary Python code in the "
"context of any stack frame.  It also supports post-mortem debugging and "
"can be called under program control."
msgstr ""
":mod:`pdb` 모듈은 파이썬 프로그램을 위한 대화형 소스 코드 디버거를 정의합니다. 소스 라인 단계의 "
"중단점(breakpoint) 및 단계 실행(single stepping) 설정, 스택 프레임 검사, 소스 코드 목록, 그리고 모든 "
"스택 프레임의 컨텍스트에서 임의의 파이썬 코드 평가를 지원합니다. 또한 포스트-모템(post-mortem) 디버깅을 지원하며, "
"프로그램 제어 하에서도 호출될 수 있습니다."

#: ../Doc/library/pdb.rst:26
msgid ""
"The debugger is extensible -- it is actually defined as the class "
":class:`Pdb`. This is currently undocumented but easily understood by "
"reading the source.  The extension interface uses the modules :mod:`bdb` "
"and :mod:`cmd`."
msgstr ""
"이 디버거는 확장이 가능합니다 -- 디버거는 실제로 :class:`Pdb` 클래스로 정의됩니다. 현재 문서화되어 있진 않지만, "
"소스를 읽어보시면 쉽게 이해하실 수 있습니다. 확장 인터페이스는 :mod:`bdb` 와 :mod:`cmd` 모듈을 활용합니다."

#: ../Doc/library/pdb.rst:30
msgid ""
"The debugger's prompt is ``(Pdb)``. Typical usage to run a program under "
"control of the debugger is::"
msgstr "디버거의 프롬프트는 ``(Pdb)`` 입니다. 디버거 제어하에 프로그램을 실행하는 일반적인 사용법은 다음과 같습니다::"

#: ../Doc/library/pdb.rst:44
msgid ""
"Tab-completion via the :mod:`readline` module is available for commands "
"and command arguments, e.g. the current global and local names are "
"offered as arguments of the ``p`` command."
msgstr ""
":mod:`readline` 모듈을 통한 탭-완성은 명령과 명령 인자에 사용할 수 있습니다, 예를 들면, 현재 전역 및 지역 "
"이름들은 ``p`` 명령의 인자로 제공됩니다."

#: ../Doc/library/pdb.rst:49
msgid ""
":file:`pdb.py` can also be invoked as a script to debug other scripts.  "
"For example::"
msgstr ":file:`pdb.py` 는 다른 스크립트를 디버그하기 위한 스크립트로 호출될 수 있습니다. 예를 들면::"

#: ../Doc/library/pdb.rst:54
msgid ""
"When invoked as a script, pdb will automatically enter post-mortem "
"debugging if the program being debugged exits abnormally.  After post-"
"mortem debugging (or after normal exit of the program), pdb will restart "
"the program.  Automatic restarting preserves pdb's state (such as "
"breakpoints) and in most cases is more useful than quitting the debugger "
"upon program's exit."
msgstr ""
"스크립트로 호출하는 경우, 디버깅 중인 프로그램이 비정상적으로 종료되면 pdb는 자동으로 포스트-모템(post-mortem) "
"디버깅을 시작합니다. 포스트-모템 디버깅이 끝나면 (또는 프로그램이 정상적으로 종료되면), pdb는 프로그램을 재시작합니다. 자동 "
"재시작은 중단점과 같은 pdb의 상태를 유지하고 대부분의 경우 프로그램 종료 시 디버거를 종료하는 것보다 유용합니다."

#: ../Doc/library/pdb.rst:60
msgid ""
":file:`pdb.py` now accepts a ``-c`` option that executes commands as if "
"given in a :file:`.pdbrc` file, see :ref:`debugger-commands`."
msgstr ""
":file:`pdb.py` 는 이제 :file:`.pdbrc` 파일에 주어진 것처럼 명령을 실행하는 ``-c`` 옵션을 받을 수 "
"있습니다, :ref:`debugger-commands` 을 확인해보세요."

#: ../Doc/library/pdb.rst:64
msgid ""
":file:`pdb.py` now accepts a ``-m`` option that execute modules similar "
"to the way ``python3 -m`` does. As with a script, the debugger will pause"
" execution just before the first line of the module."
msgstr ""
":file:`pdb.py` 는 이제 ``python3 -m``\\과 비슷한 모듈을 실행하는 ``-m`` 옵션을 받을 수 있습니다. "
"스크립트와 마찬가지로, 디버거는 모듈의 첫 번째 줄 바로 전에 실행을 일시정지합니다."

#: ../Doc/library/pdb.rst:70
msgid ""
"The typical usage to break into the debugger from a running program is to"
" insert ::"
msgstr "실행 중인 프로그램에서 디버거로 진입하는 일반적인 사용법은::"

#: ../Doc/library/pdb.rst:75
msgid ""
"at the location you want to break into the debugger.  You can then step "
"through the code following this statement, and continue running without "
"the debugger using the :pdbcmd:`continue` command."
msgstr ""
"위 코드를 디버거로 진입하고 싶은 구간에 추가하면 됩니다. 그런 다음 이 문장 뒤에 오는 코드를 단계별로 실행하고, "
":pdbcmd:`continue` 명령을 사용하여 디버거 없이 프로그램을 계속 실행할 수 있습니다."

#: ../Doc/library/pdb.rst:79
msgid ""
"The built-in :func:`breakpoint()`, when called with defaults, can be used"
" instead of ``import pdb; pdb.set_trace()``."
msgstr ""
"내장 :func:`breakpoint()`\\가, 기본값으로 호출될 때는, ``import pdb; "
"pdb.set_trace()``\\를 대신해서 사용할 수 있습니다."

#: ../Doc/library/pdb.rst:83
msgid "The typical usage to inspect a crashed program is::"
msgstr "에러가 발생하는 프로그램을 검사하는 일반적인 사용법은 다음과 같습니다::"

#: ../Doc/library/pdb.rst:101
msgid ""
"The module defines the following functions; each enters the debugger in a"
" slightly different way:"
msgstr "이 모듈은 다음과 같은 함수를 정의합니다; 각 함수는 조금 다른 방식으로 디버거로 진입합니다:"

#: ../Doc/library/pdb.rst:106
msgid ""
"Execute the *statement* (given as a string or a code object) under "
"debugger control.  The debugger prompt appears before any code is "
"executed; you can set breakpoints and type :pdbcmd:`continue`, or you can"
" step through the statement using :pdbcmd:`step` or :pdbcmd:`next` (all "
"these commands are explained below).  The optional *globals* and *locals*"
" arguments specify the environment in which the code is executed; by "
"default the dictionary of the module :mod:`__main__` is used.  (See the "
"explanation of the built-in :func:`exec` or :func:`eval` functions.)"
msgstr ""
"디버거 제어하에 *statement* (주어진 문자열 또는 코드 객체)를 실행합니다. 코드가 실행하기 전에 디버거 프롬프트가 "
"나타납니다; 중단점을 지정하고 :pdbcmd:`continue`\\를 입력하거나, :pdbcmd:`step` 또는 "
":pdbcmd:`next`\\를 통해 문장을 단계별로 살펴볼 수 있습니다. (이 모든 명령은 아래에 설명되어 있습니다.) 선택적 "
"인자 *globals* 와 *locals*\\는 코드가 실행되는 환경을 구체적으로 명시합니다; 기본적으로는 이 모듈의 딕셔너리 "
":mod:`__main__` 이 사용됩니다. (내장 함수 :func:`exec` 또는 :func:`eval` 에 대한 설명 참조.)"

#: ../Doc/library/pdb.rst:118
msgid ""
"Evaluate the *expression* (given as a string or a code object) under "
"debugger control.  When :func:`runeval` returns, it returns the value of "
"the expression.  Otherwise this function is similar to :func:`run`."
msgstr ""
"디버거 제어하에 문자열 또는 코드 객체로 주어진 *expression*\\을 평가합니다. :func:`runeval` 이 반환될 "
"때, 표현식의 값을 반환합니다. 그렇지 않으면 이 함수는 :func:`run`\\과 유사한 함수입니다."

#: ../Doc/library/pdb.rst:125
msgid ""
"Call the *function* (a function or method object, not a string) with the "
"given arguments.  When :func:`runcall` returns, it returns whatever the "
"function call returned.  The debugger prompt appears as soon as the "
"function is entered."
msgstr ""
"주어진 인자와 함께 *function* (문자열이 아닌, 함수 또는 메서드 객체)를 호출합니다. :func:`runcall` 이 "
"반환될 때, 함수 호출로 반환된 값을 반환합니다. 디버거 프롬프트는 함수에 진입하자마자 나타납니다."

#: ../Doc/library/pdb.rst:133
msgid ""
"Enter the debugger at the calling stack frame.  This is useful to hard-"
"code a breakpoint at a given point in a program, even if the code is not "
"otherwise being debugged (e.g. when an assertion fails).  If given, "
"*header* is printed to the console just before debugging begins."
msgstr ""
"호출하는 스택 프레임에서 디버거에 진입합니다. 코드가 디버그 되지 않는 경우 일지라도 (예를 들면, assertion이 실패하는 "
"경우), 프로그램의 특정 지점에 중단점을 하드 코딩할 때 유용하게 사용됩니다. *header* 값을 주면, 디버깅이 시작되기 바로 "
"전에 그 값이 콘솔에 출력됩니다."

#: ../Doc/library/pdb.rst:138
msgid "The keyword-only argument *header*."
msgstr "키워드 전용 인자 *header*."

#: ../Doc/library/pdb.rst:144
msgid ""
"Enter post-mortem debugging of the given *traceback* object.  If no "
"*traceback* is given, it uses the one of the exception that is currently "
"being handled (an exception must be being handled if the default is to be"
" used)."
msgstr ""
"주어진 *traceback* 객체의 포스트-모템(post-mortem) 디버깅으로 진입합니다. 만약 *traceback*\\이 "
"주어지지 않았다면, 현재 처리되고 있는 하나의 예외를 사용합니다. (기본값을 사용하는 경우 예외는 반드시 처리되고 있어야 합니다.)"

#: ../Doc/library/pdb.rst:152
msgid ""
"Enter post-mortem debugging of the traceback found in "
":data:`sys.last_traceback`."
msgstr ""
":data:`sys.last_traceback` 에서 찾은 traceback 의 포스트-모템(post-mortem) 디버깅으로 "
"진입합니다."

#: ../Doc/library/pdb.rst:156
msgid ""
"The ``run*`` functions and :func:`set_trace` are aliases for "
"instantiating the :class:`Pdb` class and calling the method of the same "
"name.  If you want to access further features, you have to do this "
"yourself:"
msgstr ""
"``run*`` 함수와 :func:`set_trace`\\는 :class:`Pdb` 클래스를 인스턴스 화하고 같은 이름의 메서드를 "
"호출하는 에일리어스(alias) 입니다. 더 많은 기능에 액세스하려면, 아래를 참고하여 직접 하셔야 합니다:"

#: ../Doc/library/pdb.rst:163
msgid ":class:`Pdb` is the debugger class."
msgstr ":class:`Pdb` 는 디버거 클래스입니다."

#: ../Doc/library/pdb.rst:165
msgid ""
"The *completekey*, *stdin* and *stdout* arguments are passed to the "
"underlying :class:`cmd.Cmd` class; see the description there."
msgstr ""
"*completekey*, *stdin* 그리고 *stdout* 인자는 내부 :class:`cmd.Cmd` 클래스로 전달됩니다; "
"자세한 설명은 해당 클래스에서 확인할 수 있습니다."

#: ../Doc/library/pdb.rst:168
msgid ""
"The *skip* argument, if given, must be an iterable of glob-style module "
"name patterns.  The debugger will not step into frames that originate in "
"a module that matches one of these patterns. [1]_"
msgstr ""
"*skip* 인자가 주어진다면, 반드시 글로브-스타일(glob-style) 모듈 이름 패턴의 이터러블(iterable) 이어야 "
"합니다. 디버거는 이 패턴 중 하나와 일치하는 모듈에서 시작되는 프레임 단계로 들어가지 않습니다. [1]_"

#: ../Doc/library/pdb.rst:172
msgid ""
"By default, Pdb sets a handler for the SIGINT signal (which is sent when "
"the user presses :kbd:`Ctrl-C` on the console) when you give a "
"``continue`` command. This allows you to break into the debugger again by"
" pressing :kbd:`Ctrl-C`.  If you want Pdb not to touch the SIGINT "
"handler, set *nosigint* to true."
msgstr ""
"기본적으로, Pdb는 사용자가 ``continue`` 명령을 내릴 때, SIGINT 신호(사용자가 콘솔에서 "
":kbd:`Ctrl-C`\\를 누를 때 전송되는 신호) 에 대한 핸들러를 설정합니다. 사용자는 :kbd:`Ctrl-C`\\를 눌러서"
" 디버거를 벗어날 수 있습니다. 만약 Pdb가 SIGINT 핸들러를 건드리지 않길 원한다면 *nosigint* 설정을 참으로 "
"변경하면 됩니다."

#: ../Doc/library/pdb.rst:177
msgid ""
"The *readrc* argument defaults to true and controls whether Pdb will load"
" .pdbrc files from the filesystem."
msgstr "*readrc* 인자는 기본적으로 참이고 Pdb가 파일 시스템으로부터 .pdbrc를 불러올지 여부를 제어합니다."

#: ../Doc/library/pdb.rst:180
msgid "Example call to enable tracing with *skip*::"
msgstr "*skip*\\으로 추적하기 위한 호출 예시::"

#: ../Doc/library/pdb.rst:184
msgid "The *skip* argument."
msgstr "*skip* 인자."

#: ../Doc/library/pdb.rst:187
msgid ""
"The *nosigint* argument.  Previously, a SIGINT handler was never set by "
"Pdb."
msgstr "*nosigint* 인자. 이전에는, Pdb가 SIGINT 핸들러를 설정하지 않았습니다."

#: ../Doc/library/pdb.rst:191
msgid "The *readrc* argument."
msgstr "*readrc* 인자."

#: ../Doc/library/pdb.rst:199
msgid "See the documentation for the functions explained above."
msgstr "위에 설명된 함수에 대한 설명서를 참조하시면 됩니다."

#: ../Doc/library/pdb.rst:205
msgid "Debugger Commands"
msgstr "디버거 명령들"

#: ../Doc/library/pdb.rst:207
msgid ""
"The commands recognized by the debugger are listed below.  Most commands "
"can be abbreviated to one or two letters as indicated; e.g. ``h(elp)`` "
"means that either ``h`` or ``help`` can be used to enter the help command"
" (but not ``he`` or ``hel``, nor ``H`` or ``Help`` or ``HELP``).  "
"Arguments to commands must be separated by whitespace (spaces or tabs).  "
"Optional arguments are enclosed in square brackets (``[]``) in the "
"command syntax; the square brackets must not be typed.  Alternatives in "
"the command syntax are separated by a vertical bar (``|``)."
msgstr ""
"디버거가 인식할 수 있는 명령이 아래 나열되어 있습니다. 대부분의 명령은 한두 문자로 단축될 수 있습니다; 예를 들면, "
"``h(elp)`` 는 ``h`` 또는 ``help``\\로 help 명령을 입력할 때 사용할 수 있습니다. (하지만 "
"``he``\\, ``hel``\\, ``H``\\, ``Help`` 또는 ``HELP``\\는 사용할 수 없습니다.) 인자는 "
"반드시 명령과 공백(스페이스나 탭)으로 분리되어야 합니다. 선택적 인자는 명령 문법에서 대괄호(``[]``)로 묶여있습니다; "
"대괄호는 입력하지 않습니다. 명령 문법에서 대체 가능한 인자는 세로 바(``|``)로 분리되어 있습니다."

#: ../Doc/library/pdb.rst:216
msgid ""
"Entering a blank line repeats the last command entered.  Exception: if "
"the last command was a :pdbcmd:`list` command, the next 11 lines are "
"listed."
msgstr ""
"빈 줄을 입력하면 마지막으로 입력된 명령이 반복됩니다. 예외: 만약 마지막 명령이 :pdbcmd:`list` 명령이면, 다음 "
"11줄이 나열됩니다."

#: ../Doc/library/pdb.rst:219
msgid ""
"Commands that the debugger doesn't recognize are assumed to be Python "
"statements and are executed in the context of the program being debugged."
"  Python statements can also be prefixed with an exclamation point "
"(``!``).  This is a powerful way to inspect the program being debugged; "
"it is even possible to change a variable or call a function.  When an "
"exception occurs in such a statement, the exception name is printed but "
"the debugger's state is not changed."
msgstr ""
"디버거가 인식하지 못하는 명령은 파이썬 문장으로 가정하고 디버깅 중인 프로그램의 컨텍스트에서 실행됩니다. 파이썬 문장 앞에 "
"느낌표(``!``\\)를 붙여 사용할 수도 있습니다. 이 방법은 디버깅 중인 프로그램을 검사하는 강력한 방법입니다. 변수를 "
"변경하거나 함수를 호출하는 것도 가능합니다. 이 문장에서 예외가 발생하면, 예외 명은 출력되지만 디버거의 상태는 변경되지 않습니다."

#: ../Doc/library/pdb.rst:227
msgid ""
"The debugger supports :ref:`aliases <debugger-aliases>`.  Aliases can "
"have parameters which allows one a certain level of adaptability to the "
"context under examination."
msgstr ""
"디버거는 :ref:`에일리어스 <debugger-aliases>`\\을 지원합니다. 에일리어스는 검사 중인 컨텍스트에서 특정 수준의"
" 적응성을 허용하는 매개변수를 가질 수 있습니다."

#: ../Doc/library/pdb.rst:231
msgid ""
"Multiple commands may be entered on a single line, separated by ``;;``.  "
"(A single ``;`` is not used as it is the separator for multiple commands "
"in a line that is passed to the Python parser.)  No intelligence is "
"applied to separating the commands; the input is split at the first "
"``;;`` pair, even if it is in the middle of a quoted string."
msgstr ""
"한 줄에 여러 명령은 ``;;`` 로 구분하여 입력할 수 있습니다. (단일 ``;`` 는 파이썬 파서로 전달되는 한 줄에서, 여러 "
"명령을 구분하기 위한 분리 기호이므로 사용되지 않습니다.) 명령을 똑똑하게 분리하진 못합니다; 입력의 맨 처음 ``;;`` 에서 "
"나뉘며, 따옴표로 묶인 문자열 중간에 있더라도 나눠집니다."

#: ../Doc/library/pdb.rst:241
msgid ""
"If a file :file:`.pdbrc` exists in the user's home directory or in the "
"current directory, it is read in and executed as if it had been typed at "
"the debugger prompt.  This is particularly useful for aliases.  If both "
"files exist, the one in the home directory is read first and aliases "
"defined there can be overridden by the local file."
msgstr ""
"만약 파일 :file:`.pdbrc` 가 사용자의 홈 디렉터리 또는 현재 디렉터리에 있으면, 디버거 프롬프트에서 입력된 것처럼 "
"읽히고 실행됩니다. 이것은 특히 에일리어스에 유용합니다. 만약 두 파일이 모두 존재하면, 홈 디렉터리에 있는 파일이 먼저 읽히고 "
"거기에 정의된 에일리어스는 로컬 파일에 의해 무시될 수 있습니다."

#: ../Doc/library/pdb.rst:247
msgid ""
":file:`.pdbrc` can now contain commands that continue debugging, such as "
":pdbcmd:`continue` or :pdbcmd:`next`.  Previously, these commands had no "
"effect."
msgstr ""
":file:`.pdbrc` 는 :pdbcmd:`continue`\\와 :pdbcmd:`next`\\같이 디버깅을 계속하는 명령을 "
"포함할 수 있습니다. 이전에는, 이런 명령이 효과가 없었습니다."

#: ../Doc/library/pdb.rst:255
msgid ""
"Without argument, print the list of available commands.  With a *command*"
" as argument, print help about that command.  ``help pdb`` displays the "
"full documentation (the docstring of the :mod:`pdb` module).  Since the "
"*command* argument must be an identifier, ``help exec`` must be entered "
"to get help on the ``!`` command."
msgstr ""
"인자가 없는 경우에는, 사용 가능한 명령 리스트를 출력합니다. *command* 인자가 주어진 경우에는, 해당 명령의 도움말을 "
"출력합니다. ``help pdb`` 는 전체 문서(:mod:`pdb` 모듈의 독스트링)를 표시합니다. *command* 인자는 "
"반드시 식별자이어야 하므로, ``!`` 명령의 도움말을 얻기 위해서 ``help exec`` 가 꼭 입력되어야 합니다."

#: ../Doc/library/pdb.rst:263
msgid ""
"Print a stack trace, with the most recent frame at the bottom.  An arrow "
"indicates the current frame, which determines the context of most "
"commands."
msgstr ""
"가장 최근 프레임을 맨 아래로 하는 스택 트레이스를 출력합니다. 화살표는 현재 프레임을 나타내며, 대부분의 명령의 컨텍스트를 명확히"
" 합니다."

#: ../Doc/library/pdb.rst:268
msgid ""
"Move the current frame *count* (default one) levels down in the stack "
"trace (to a newer frame)."
msgstr "스택 트레이스에서 현재 프레임을 *count* (기본 1) 단계 아래로 (새로운 프레임으로) 이동합니다."

#: ../Doc/library/pdb.rst:273
msgid ""
"Move the current frame *count* (default one) levels up in the stack trace"
" (to an older frame)."
msgstr "스택 트레이스에서 현재 프레임을 *count* (기본 1) 단계 위로 (이전 프레임으로) 이동합니다."

#: ../Doc/library/pdb.rst:278
msgid ""
"With a *lineno* argument, set a break there in the current file.  With a "
"*function* argument, set a break at the first executable statement within"
" that function.  The line number may be prefixed with a filename and a "
"colon, to specify a breakpoint in another file (probably one that hasn't "
"been loaded yet).  The file is searched on :data:`sys.path`.  Note that "
"each breakpoint is assigned a number to which all the other breakpoint "
"commands refer."
msgstr ""
"*lineno* 인자가 주어진 경우, 현재 파일의 해당 줄 번호에 브레이크를 설정합니다. *function* 인자가 주어진 경우, "
"함수 내에서 첫 번째 실행 가능한 문장에서 브레이크를 설정합니다. 줄 번호는 다른 파일 (아마도 아직 로드되지 않은 파일)에 "
"중단점을 지정하기 위해, 파일명과 콜론을 접두사로 사용할 수 있습니다. 파일은 :data:`sys.path` 에서 검색합니다. "
"주의할 점은 각 중단점에 번호가 지정되며, 다른 모든 중단점 명령이 그 번호를 참조하게 됩니다."

#: ../Doc/library/pdb.rst:285
msgid ""
"If a second argument is present, it is an expression which must evaluate "
"to true before the breakpoint is honored."
msgstr "두 번째 인자가 있는 경우, 중단점을 적용하기 전에 표현식이 반드시 참이어야 합니다."

#: ../Doc/library/pdb.rst:288
msgid ""
"Without argument, list all breaks, including for each breakpoint, the "
"number of times that breakpoint has been hit, the current ignore count, "
"and the associated condition if any."
msgstr ""
"인자가 없다면, 각 중단점, 중단점에 도달한 횟수, 현재까지 무시 횟수, 그리고 관련 조건(있는 경우)을 포함한 모든 중단지점을 "
"나열합니다."

#: ../Doc/library/pdb.rst:294
msgid ""
"Temporary breakpoint, which is removed automatically when it is first "
"hit. The arguments are the same as for :pdbcmd:`break`."
msgstr "한번 도달하면 제거되는 임시중단점입니다. 인자는 :pdbcmd:`break`\\과 동일합니다."

#: ../Doc/library/pdb.rst:299
msgid ""
"With a *filename:lineno* argument, clear all the breakpoints at this "
"line. With a space separated list of breakpoint numbers, clear those "
"breakpoints. Without argument, clear all breaks (but first ask "
"confirmation)."
msgstr ""
"*filename:lineno* 인자가 주어진 경우, 해당 줄에 있는 모든 중단점을 제거합니다. 공백으로 구분된 중단점 번호 배열이"
" 주어진 경우, 해당 중단점을 제거합니다. 인자가 없는 경우, 모든 중단지점을 재차 확인 후 제거합니다."

#: ../Doc/library/pdb.rst:305
msgid ""
"Disable the breakpoints given as a space separated list of breakpoint "
"numbers.  Disabling a breakpoint means it cannot cause the program to "
"stop execution, but unlike clearing a breakpoint, it remains in the list "
"of breakpoints and can be (re-)enabled."
msgstr ""
"공백으로 구분된 중단점 번호로 해당 중단점을 비활성화합니다. 중단점을 비활성화하는 것은 프로그램이 실행을 중단할 수 없다는 "
"것입니다, 하지만 중단점을 제거하는 것과는 달리, 중단점 목록에 남아있으며 (재-)활성화할 수 있습니다."

#: ../Doc/library/pdb.rst:312
msgid "Enable the breakpoints specified."
msgstr "지정된 중단점을 활성화합니다."

#: ../Doc/library/pdb.rst:316
msgid ""
"Set the ignore count for the given breakpoint number.  If count is "
"omitted, the ignore count is set to 0.  A breakpoint becomes active when "
"the ignore count is zero.  When non-zero, the count is decremented each "
"time the breakpoint is reached and the breakpoint is not disabled and any"
" associated condition evaluates to true."
msgstr ""
"해당 중단점 번호를 무시할 횟수를 설정합니다. 만약 횟수가 생략된 경우, 무시 횟수는 0으로 설정됩니다. 무시 횟수가 0일 때 "
"중단점이 활성화됩니다. 0이 아닐 때는, 중단점에 도달하고 중단점이 비활성화되지 않고 연관 조건이 참일 때마다 그 횟수가 "
"차감됩니다."

#: ../Doc/library/pdb.rst:324
msgid ""
"Set a new *condition* for the breakpoint, an expression which must "
"evaluate to true before the breakpoint is honored.  If *condition* is "
"absent, any existing condition is removed; i.e., the breakpoint is made "
"unconditional."
msgstr ""
"중단점에 새로운 *condition*\\을 설정합니다, 표현식이 참일 때만 중단점이 적용됩니다. 만약 *condition*\\이 "
"없다면, 설정되어있던 모든 조건이 제거됩니다; 즉, 중단점에 적용되어있던 조건이 없어집니다."

#: ../Doc/library/pdb.rst:330
msgid ""
"Specify a list of commands for breakpoint number *bpnumber*.  The "
"commands themselves appear on the following lines.  Type a line "
"containing just ``end`` to terminate the commands. An example::"
msgstr ""
"중단점 번호 *bpnumber* 에 대한 명령을 지정합니다. 명령 목록은 다음 줄에 나타나게 됩니다. 명령을 종료하려면 "
"``end``\\만 입력하면 됩니다. 예를 들면::"

#: ../Doc/library/pdb.rst:339
msgid ""
"To remove all commands from a breakpoint, type ``commands`` and follow it"
" immediately with ``end``; that is, give no commands."
msgstr ""
"중단점에 지정된 모든 명령을 제거하려면, ``commands`` 입력 후에 바로 ``end``\\를 입력하면 됩니다; 즉, 아무 "
"명령을 설정하지 않는 것입니다."

#: ../Doc/library/pdb.rst:342
msgid ""
"With no *bpnumber* argument, ``commands`` refers to the last breakpoint "
"set."
msgstr "*bpnumber* 인자가 주어지지 않으면, ``commands``\\는 마지막 중단점 묶음을 참조하게 됩니다."

msgid ""
"You can use breakpoint commands to start your program up again.  Simply "
"use the :pdbcmd:`continue` command, or :pdbcmd:`step`, or any other "
"command that resumes execution."
msgstr ""
"중단점 명령을 활용해서 프로그램을 다시 시작할 수도 있습니다. :pdbcmd:`continue` 명령이나, "
":pdbcmd:`step` 또는 실행을 재개하는 다른 명령을 사용하기만 하면 됩니다."

#: ../Doc/library/pdb.rst:348
msgid ""
"Specifying any command resuming execution (currently :pdbcmd:`continue`, "
":pdbcmd:`step`, :pdbcmd:`next`, :pdbcmd:`return`, :pdbcmd:`jump`, "
":pdbcmd:`quit` and their abbreviations) terminates the command list (as "
"if that command was immediately followed by end). This is because any "
"time you resume execution (even with a simple next or step), you may "
"encounter another breakpoint—which could have its own command list, "
"leading to ambiguities about which list to execute."
msgstr ""
"실행을 재개하는 아무 명령 (:pdbcmd:`continue`, :pdbcmd:`step`, :pdbcmd:`next`, "
":pdbcmd:`return`, :pdbcmd:`jump`, :pdbcmd:`quit` 및 해당 명령의 약어들)을 지정하는 것은 "
"(``end`` 명령을 붙인 것처럼) 해당 명령 목록을 끝내는 것입니다. 왜냐하면 실행을 재개할 때마다, 명령 목록을 가진 다른 "
"중단점을 맞이할 수 있고, 어떤 목록을 실행해야 할지 모르는 상황이 생기기 때문입니다."

#: ../Doc/library/pdb.rst:357
msgid ""
"If you use the 'silent' command in the command list, the usual message "
"about stopping at a breakpoint is not printed.  This may be desirable for"
" breakpoints that are to print a specific message and then continue.  If "
"none of the other commands print anything, you see no sign that the "
"breakpoint was reached."
msgstr ""
"만약 'slient' 명령을 사용하면, 중단점에서 멈출 때 나오는 메시지는 출력되지 않습니다. 특정 메시지를 출력하고 진행되는 "
"중단점에 바람직할 수 있습니다. 다만 그 어떤 명령도 출력하지 않는다면, 그 중단점에 도달했다는 것은 알 수 없습니다."

#: ../Doc/library/pdb.rst:364
msgid ""
"Execute the current line, stop at the first possible occasion (either in "
"a function that is called or on the next line in the current function)."
msgstr "현재 줄을 실행하고, 멈출 수 있는 가장 첫 번째 줄(호출되는 함수 또는 현재 함수의 다음 줄) 에서 멈춥니다. "

#: ../Doc/library/pdb.rst:369
msgid ""
"Continue execution until the next line in the current function is reached"
" or it returns.  (The difference between :pdbcmd:`next` and "
":pdbcmd:`step` is that :pdbcmd:`step` stops inside a called function, "
"while :pdbcmd:`next` executes called functions at (nearly) full speed, "
"only stopping at the next line in the current function.)"
msgstr ""
"현재 함수의 다음 줄에 도달하거나, 반환할 때까지 계속 실행합니다. :pdbcmd:`next`\\와 :pdbcmd:`step`\\의"
" 차이점은 :pdbcmd:`step`\\은 호출된 함수 안에서 멈추고, :pdbcmd:`next`\\는 호출된 함수를 재빠르게 "
"실행하고 현재 함수의 바로 다음 줄에서만 멈춥니다."

#: ../Doc/library/pdb.rst:377
msgid ""
"Without argument, continue execution until the line with a number greater"
" than the current one is reached."
msgstr "인자가 없는 경우에는, 현재 줄 번호보다 높은 줄 번호에 도달할 때까지 계속 실행합니다."

#: ../Doc/library/pdb.rst:380
msgid ""
"With a line number, continue execution until a line with a number greater"
" or equal to that is reached.  In both cases, also stop when the current "
"frame returns."
msgstr ""
"줄 번호가 주어진 경우에는, 해당 번호보다 크거나 같은 줄에 도달할 때까지 계속 실행합니다. 두 경우 모두 현재 프레임이 반환될 때"
" 멈춥니다."

#: ../Doc/library/pdb.rst:384
msgid "Allow giving an explicit line number."
msgstr "줄 번호를 명시적으로 줄 수 있도록 허용합니다."

#: ../Doc/library/pdb.rst:389
msgid "Continue execution until the current function returns."
msgstr "현재 함수가 반환될 때까지 계속 실행합니다."

#: ../Doc/library/pdb.rst:393
msgid "Continue execution, only stop when a breakpoint is encountered."
msgstr "중단점을 마주칠 때까지 계속 실행합니다."

#: ../Doc/library/pdb.rst:397
msgid ""
"Set the next line that will be executed.  Only available in the bottom-"
"most frame.  This lets you jump back and execute code again, or jump "
"forward to skip code that you don't want to run."
msgstr ""
"다음으로 실행될 줄을 설정할 수 있습니다. 프레임의 맨 마지막에서만 실행이 가능합니다. 이전 줄로 돌아가 코드를 재실행하거나, "
"실행을 원치 않는 코드를 건너뛸 수 있습니다."

#: ../Doc/library/pdb.rst:401
msgid ""
"It should be noted that not all jumps are allowed -- for instance it is "
"not possible to jump into the middle of a :keyword:`for` loop or out of a"
" :keyword:`finally` clause."
msgstr ""
"중요한 점은 이 명령은 언제나 실행할 수 있진 않습니다 -- :keyword:`for` 루프 내부로 들어가거나 "
":keyword:`finally` 절을 건너뛰는 것은 불가능합니다."

#: ../Doc/library/pdb.rst:407
msgid ""
"List source code for the current file.  Without arguments, list 11 lines "
"around the current line or continue the previous listing.  With ``.`` as "
"argument, list 11 lines around the current line.  With one argument, list"
" 11 lines around at that line.  With two arguments, list the given range;"
" if the second argument is less than the first, it is interpreted as a "
"count."
msgstr ""
"현재 파일의 소스 코드를 나열합니다. 인자가 없는 경우, 현재 줄 주위로 11줄을 나열하거나 이전 줄을 이어서 나열합니다. 인자로 "
"``.``\\을 입력한 경우, 현재 줄 주위로 11줄을 나열합니다. 한 인자만 주어진 경우, 해당 줄 주위로 11줄을 나열합니다. "
"두 인자가 주어진 경우, 두 인자 사이의 모든 줄을 나열합니다; 만약 두 번째 인자가 첫 번째 인자보다 작은 경우, 첫 번째 "
"인자로부터 나열하는 줄 수로 인식합니다."

#: ../Doc/library/pdb.rst:413
msgid ""
"The current line in the current frame is indicated by ``->``.  If an "
"exception is being debugged, the line where the exception was originally "
"raised or propagated is indicated by ``>>``, if it differs from the "
"current line."
msgstr ""
"현재 프레임에서 현재 위치는 ``->``\\로 표시됩니다. 예외를 디버깅할 때, 예외가 최초로 발생하거나 전파된 줄이 현재 줄과 "
"다른 경우에는 ``>>``\\로  표시됩니다."

#: ../Doc/library/pdb.rst:418
msgid "The ``>>`` marker."
msgstr "``>>``\\표시"

#: ../Doc/library/pdb.rst:423
msgid ""
"List all source code for the current function or frame.  Interesting "
"lines are marked as for :pdbcmd:`list`."
msgstr "현재 함수나 프레임의 소스 코드 전체를 나열합니다. 참고할만한 줄은 :pdbcmd:`list`\\처럼 표시됩니다."

#: ../Doc/library/pdb.rst:430
msgid "Print the argument list of the current function."
msgstr "현재 함수의 인자 목록을 출력합니다."

#: ../Doc/library/pdb.rst:434
msgid "Evaluate the *expression* in the current context and print its value."
msgstr "현재 컨텍스트에서 *expression*\\을 실행하고 값을 출력합니다."

#: ../Doc/library/pdb.rst:438
msgid ""
"``print()`` can also be used, but is not a debugger command --- this "
"executes the Python :func:`print` function."
msgstr ""
"디버거 명령은 아니지만, ``print()``\\도 사용될 수 있습니다 --- 이때는 파이썬의 :func:`print` 함수를 "
"실행하게 됩니다."

#: ../Doc/library/pdb.rst:444
msgid ""
"Like the :pdbcmd:`p` command, except the value of the expression is "
"pretty-printed using the :mod:`pprint` module."
msgstr ":pdbcmd:`p` 명령과 비슷하지만, 표현식의 값을 :mod:`pprint` 모듈을 활용하여 보기 좋은 형태로 출력합니다."

#: ../Doc/library/pdb.rst:449
msgid "Print the type of the *expression*."
msgstr "*expression*\\의 형(type)을 출력합니다."

#: ../Doc/library/pdb.rst:453
msgid "Try to get source code for the given object and display it."
msgstr "주어진 객체의 소스 코드를 가져와서 보여줍니다."

#: ../Doc/library/pdb.rst:459
msgid ""
"Display the value of the expression if it changed, each time execution "
"stops in the current frame."
msgstr "현재 프레임에서 실행이 중지될 때마다, 표현식의 값이 변경된 경우 표시합니다."

#: ../Doc/library/pdb.rst:462
msgid "Without expression, list all display expressions for the current frame."
msgstr "표현식이 주어지지 않은 경우, 현재 프레임에서 표시되는 모든 표현식을 나열합니다."

#: ../Doc/library/pdb.rst:468
msgid ""
"Do not display the expression any more in the current frame.  Without "
"expression, clear all display expressions for the current frame."
msgstr "현재 프레임에서 표현식을 더는 표시하지 않습니다. 표현식이 주어지지 않은 경우, 현재 프레임에서 표시되는 모든 표현식을 제거합니다."

#: ../Doc/library/pdb.rst:475
msgid ""
"Start an interactive interpreter (using the :mod:`code` module) whose "
"global namespace contains all the (global and local) names found in the "
"current scope."
msgstr ""
"현재 스코프에서 찾을 수 있는 모든 지역 또는 전역 이름을 담고 있는 전역 이름 공간을 가진 (:mod:`code` 모듈을 "
"활용하는) 대화형 인터프리터를 시작합니다."

#: ../Doc/library/pdb.rst:485
msgid ""
"Create an alias called *name* that executes *command*.  The command must "
"*not* be enclosed in quotes.  Replaceable parameters can be indicated by "
"``%1``, ``%2``, and so on, while ``%*`` is replaced by all the "
"parameters. If no command is given, the current alias for *name* is "
"shown. If no arguments are given, all aliases are listed."
msgstr ""
"*command*\\를 실행하는 *name*\\이라 불리는 에일리어스를 생성합니다. 명령은 따옴표로 감싸지 *않아도* 됩니다. "
"대체할 수 있는 파라미터는 ``%1``, ``%2`` 등으로 표시되지만, ``%*`` 는 모든 파라미터로 대체됩니다. 만약 명령이 "
"주어지지 않으면, 현재 *name*\\의 에일리어스가 표시됩니다. 만약 아무 인자가 주어지지 않으면, 모든 에일리어스가 나열됩니다."

#: ../Doc/library/pdb.rst:491
msgid ""
"Aliases may be nested and can contain anything that can be legally typed "
"at the pdb prompt.  Note that internal pdb commands *can* be overridden "
"by aliases.  Such a command is then hidden until the alias is removed.  "
"Aliasing is recursively applied to the first word of the command line; "
"all other words in the line are left alone."
msgstr ""
"에일리어스는 중첩될 수 있고 pdb 프롬프트 내에서 정당하게 입력할 수 있는 모든 것을 담을 수 있습니다. 주의할 점은 pdb 내부"
" 명령들이 에일리어스에 의해 오버라이드 *될 수 있습니다*. 그 명령은 에일리어스가 없어질 때까지 사용할 수 없게 됩니다. "
"에일리어싱은 명령 줄의 첫 번째 단어에 회귀적으로 적용됩니다; 나머지 단어들은 적용되지 않습니다."

#: ../Doc/library/pdb.rst:497
msgid ""
"As an example, here are two useful aliases (especially when placed in the"
" :file:`.pdbrc` file)::"
msgstr ":file:`.pdbrc`\\파일에 추가되면 특히 유용한 두 에일리어스 예시::"

#: ../Doc/library/pdb.rst:507
msgid "Delete the specified alias."
msgstr "지정된 에일리어스를 제거합니다."

#: ../Doc/library/pdb.rst:511
msgid ""
"Execute the (one-line) *statement* in the context of the current stack "
"frame. The exclamation point can be omitted unless the first word of the "
"statement resembles a debugger command.  To set a global variable, you "
"can prefix the assignment command with a :keyword:`global` statement on "
"the same line, e.g.::"
msgstr ""
"현재 스택 프레임의 컨텍스트에서 단일 *statement*\\를 실행합니다. 문장의 첫 단어가 디버거 명령이 아닌 경우, 느낌표는 "
"제외해도 됩니다. 전역 변수를 설정하려면 실행하려는 명령과 동일한 줄 맨 앞에 :keyword:`global`\\문장을 붙이면 "
"됩니다, 예를 들면::"

#: ../Doc/library/pdb.rst:523
msgid ""
"Restart the debugged Python program.  If an argument is supplied, it is "
"split with :mod:`shlex` and the result is used as the new "
":data:`sys.argv`. History, breakpoints, actions and debugger options are "
"preserved. :pdbcmd:`restart` is an alias for :pdbcmd:`run`."
msgstr ""
"디버그 된 파이썬 프로그램을 재시작합니다. 만약 인자가 주어진 경우, :mod:`shlex`\\으로 나뉘게 되고 결과는 새 "
":data:`sys.argv`\\로 사용됩니다. 이전 기록, 중단점, 행동 그리고 디버거 옵션은 유지됩니다. "
":pdbcmd:`restart`\\는 :pdbcmd:`run`\\의 에일리어스입니다."

#: ../Doc/library/pdb.rst:530
msgid "Quit from the debugger.  The program being executed is aborted."
msgstr "디버거를 종료합니다. 실행되고 있는 프로그램이 종료됩니다."

#: ../Doc/library/pdb.rst:534
msgid "Footnotes"
msgstr "각주"

#: ../Doc/library/pdb.rst:535
msgid ""
"Whether a frame is considered to originate in a certain module is "
"determined by the ``__name__`` in the frame globals."
msgstr "프레임이 특정 모듈에서 시작되는 것으로 간주하는지 여부는 프레임 전역에 있는 ``__name__``\\에 의해 결정됩니다."
