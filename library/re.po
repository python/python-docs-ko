# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 11:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/library/re.rst:2
msgid ":mod:`re` --- Regular expression operations"
msgstr ""

#: ../Doc/library/re.rst:10
msgid "**Source code:** :source:`Lib/re.py`"
msgstr ""

#: ../Doc/library/re.rst:14
msgid ""
"This module provides regular expression matching operations similar to "
"those found in Perl."
msgstr ""

#: ../Doc/library/re.rst:17
msgid ""
"Both patterns and strings to be searched can be Unicode strings "
"(:class:`str`) as well as 8-bit strings (:class:`bytes`). However, "
"Unicode strings and 8-bit strings cannot be mixed: that is, you cannot "
"match a Unicode string with a byte pattern or vice-versa; similarly, when"
" asking for a substitution, the replacement string must be of the same "
"type as both the pattern and the search string."
msgstr ""

#: ../Doc/library/re.rst:24
msgid ""
"Regular expressions use the backslash character (``'\\'``) to indicate "
"special forms or to allow special characters to be used without invoking "
"their special meaning.  This collides with Python's usage of the same "
"character for the same purpose in string literals; for example, to match "
"a literal backslash, one might have to write ``'\\\\\\\\'`` as the "
"pattern string, because the regular expression must be ``\\\\``, and each"
" backslash must be expressed as ``\\\\`` inside a regular Python string "
"literal."
msgstr ""

#: ../Doc/library/re.rst:33
msgid ""
"The solution is to use Python's raw string notation for regular "
"expression patterns; backslashes are not handled in any special way in a "
"string literal prefixed with ``'r'``.  So ``r\"\\n\"`` is a two-character"
" string containing ``'\\'`` and ``'n'``, while ``\"\\n\"`` is a one-"
"character string containing a newline.  Usually patterns will be "
"expressed in Python code using this raw string notation."
msgstr ""

#: ../Doc/library/re.rst:40
msgid ""
"It is important to note that most regular expression operations are "
"available as module-level functions and methods on :ref:`compiled regular"
" expressions <re-objects>`.  The functions are shortcuts that don't "
"require you to compile a regex object first, but miss some fine-tuning "
"parameters."
msgstr ""

#: ../Doc/library/re.rst:48
msgid ""
"The third-party `regex <https://pypi.org/project/regex/>`_ module, which "
"has an API compatible with the standard library :mod:`re` module, but "
"offers additional functionality and a more thorough Unicode support."
msgstr ""

#: ../Doc/library/re.rst:56
msgid "Regular Expression Syntax"
msgstr ""

#: ../Doc/library/re.rst:58
msgid ""
"A regular expression (or RE) specifies a set of strings that matches it; "
"the functions in this module let you check if a particular string matches"
" a given regular expression (or if a given regular expression matches a "
"particular string, which comes down to the same thing)."
msgstr ""

#: ../Doc/library/re.rst:63
msgid ""
"Regular expressions can be concatenated to form new regular expressions; "
"if *A* and *B* are both regular expressions, then *AB* is also a regular "
"expression. In general, if a string *p* matches *A* and another string "
"*q* matches *B*, the string *pq* will match AB.  This holds unless *A* or"
" *B* contain low precedence operations; boundary conditions between *A* "
"and *B*; or have numbered group references.  Thus, complex expressions "
"can easily be constructed from simpler primitive expressions like the "
"ones described here.  For details of the theory and implementation of "
"regular expressions, consult the Friedl book [Frie09]_, or almost any "
"textbook about compiler construction."
msgstr ""

#: ../Doc/library/re.rst:73
msgid ""
"A brief explanation of the format of regular expressions follows.  For "
"further information and a gentler presentation, consult the :ref:`regex-"
"howto`."
msgstr ""

#: ../Doc/library/re.rst:76
msgid ""
"Regular expressions can contain both special and ordinary characters. "
"Most ordinary characters, like ``'A'``, ``'a'``, or ``'0'``, are the "
"simplest regular expressions; they simply match themselves.  You can "
"concatenate ordinary characters, so ``last`` matches the string "
"``'last'``.  (In the rest of this section, we'll write RE's in ``this "
"special style``, usually without quotes, and strings to be matched ``'in "
"single quotes'``.)"
msgstr ""

#: ../Doc/library/re.rst:83
msgid ""
"Some characters, like ``'|'`` or ``'('``, are special. Special characters"
" either stand for classes of ordinary characters, or affect how the "
"regular expressions around them are interpreted."
msgstr ""

#: ../Doc/library/re.rst:87
msgid ""
"Repetition qualifiers (``*``, ``+``, ``?``, ``{m,n}``, etc) cannot be "
"directly nested. This avoids ambiguity with the non-greedy modifier "
"suffix ``?``, and with other modifiers in other implementations. To apply"
" a second repetition to an inner repetition, parentheses may be used. For"
" example, the expression ``(?:a{6})*`` matches any multiple of six "
"``'a'`` characters."
msgstr ""

#: ../Doc/library/re.rst:94
msgid "The special characters are:"
msgstr ""

#: ../Doc/library/re.rst:99 ../Doc/library/re.rst:1301
msgid "``.``"
msgstr ""

#: ../Doc/library/re.rst:97
msgid ""
"(Dot.)  In the default mode, this matches any character except a newline."
"  If the :const:`DOTALL` flag has been specified, this matches any "
"character including a newline."
msgstr ""

#: ../Doc/library/re.rst:103
msgid "``^``"
msgstr ""

#: ../Doc/library/re.rst:102
msgid ""
"(Caret.)  Matches the start of the string, and in :const:`MULTILINE` mode"
" also matches immediately after each newline."
msgstr ""

#: ../Doc/library/re.rst:112
msgid "``$``"
msgstr ""

#: ../Doc/library/re.rst:106
msgid ""
"Matches the end of the string or just before the newline at the end of "
"the string, and in :const:`MULTILINE` mode also matches before a newline."
"  ``foo`` matches both 'foo' and 'foobar', while the regular expression "
"``foo$`` matches only 'foo'.  More interestingly, searching for ``foo.$``"
" in ``'foo1\\nfoo2\\n'`` matches 'foo2' normally, but 'foo1' in "
":const:`MULTILINE` mode; searching for a single ``$`` in ``'foo\\n'`` "
"will find two (empty) matches: one just before the newline, and one at "
"the end of the string."
msgstr ""

#: ../Doc/library/re.rst:117
msgid "``*``"
msgstr ""

#: ../Doc/library/re.rst:115
msgid ""
"Causes the resulting RE to match 0 or more repetitions of the preceding "
"RE, as many repetitions as are possible.  ``ab*`` will match 'a', 'ab', "
"or 'a' followed by any number of 'b's."
msgstr ""

#: ../Doc/library/re.rst:122
msgid "``+``"
msgstr ""

#: ../Doc/library/re.rst:120
msgid ""
"Causes the resulting RE to match 1 or more repetitions of the preceding "
"RE. ``ab+`` will match 'a' followed by any non-zero number of 'b's; it "
"will not match just 'a'."
msgstr ""

#: ../Doc/library/re.rst:126
msgid "``?``"
msgstr ""

#: ../Doc/library/re.rst:125
msgid ""
"Causes the resulting RE to match 0 or 1 repetitions of the preceding RE. "
"``ab?`` will match either 'a' or 'ab'."
msgstr ""

#: ../Doc/library/re.rst:135
msgid "``*?``, ``+?``, ``??``"
msgstr ""

#: ../Doc/library/re.rst:129
msgid ""
"The ``'*'``, ``'+'``, and ``'?'`` qualifiers are all :dfn:`greedy`; they "
"match as much text as possible.  Sometimes this behaviour isn't desired; "
"if the RE ``<.*>`` is matched against ``'<a> b <c>'``, it will match the "
"entire string, and not just ``'<a>'``.  Adding ``?`` after the qualifier "
"makes it perform the match in :dfn:`non-greedy` or :dfn:`minimal` "
"fashion; as *few* characters as possible will be matched.  Using the RE "
"``<.*?>`` will match only ``'<a>'``."
msgstr ""

#: ../Doc/library/re.rst:140
msgid "``{m}``"
msgstr ""

#: ../Doc/library/re.rst:138
msgid ""
"Specifies that exactly *m* copies of the previous RE should be matched; "
"fewer matches cause the entire RE not to match.  For example, ``a{6}`` "
"will match exactly six ``'a'`` characters, but not five."
msgstr ""

#: ../Doc/library/re.rst:149
msgid "``{m,n}``"
msgstr ""

#: ../Doc/library/re.rst:143
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as many repetitions as possible.  For "
"example, ``a{3,5}`` will match from 3 to 5 ``'a'`` characters.  Omitting "
"*m* specifies a lower bound of zero,  and omitting *n* specifies an "
"infinite upper bound.  As an example, ``a{4,}b`` will match ``'aaaab'`` "
"or a thousand ``'a'`` characters followed by a ``'b'``, but not "
"``'aaab'``. The comma may not be omitted or the modifier would be "
"confused with the previously described form."
msgstr ""

#: ../Doc/library/re.rst:156
msgid "``{m,n}?``"
msgstr ""

#: ../Doc/library/re.rst:152
msgid ""
"Causes the resulting RE to match from *m* to *n* repetitions of the "
"preceding RE, attempting to match as *few* repetitions as possible.  This"
" is the non-greedy version of the previous qualifier.  For example, on "
"the 6-character string ``'aaaaaa'``, ``a{3,5}`` will match 5 ``'a'`` "
"characters, while ``a{3,5}?`` will only match 3 characters."
msgstr ""

#: ../Doc/library/re.rst:169
msgid "``\\``"
msgstr ""

#: ../Doc/library/re.rst:159
msgid ""
"Either escapes special characters (permitting you to match characters "
"like ``'*'``, ``'?'``, and so forth), or signals a special sequence; "
"special sequences are discussed below."
msgstr ""

#: ../Doc/library/re.rst:163
msgid ""
"If you're not using a raw string to express the pattern, remember that "
"Python also uses the backslash as an escape sequence in string literals; "
"if the escape sequence isn't recognized by Python's parser, the backslash"
" and subsequent character are included in the resulting string.  However,"
" if Python would recognize the resulting sequence, the backslash should "
"be repeated twice.  This is complicated and hard to understand, so it's "
"highly recommended that you use raw strings for all but the simplest "
"expressions."
msgstr ""

#: ../Doc/library/re.rst:215
msgid "``[]``"
msgstr ""

#: ../Doc/library/re.rst:172
msgid "Used to indicate a set of characters.  In a set:"
msgstr ""

#: ../Doc/library/re.rst:174
msgid ""
"Characters can be listed individually, e.g. ``[amk]`` will match ``'a'``,"
" ``'m'``, or ``'k'``."
msgstr ""

#: ../Doc/library/re.rst:177
msgid ""
"Ranges of characters can be indicated by giving two characters and "
"separating them by a ``'-'``, for example ``[a-z]`` will match any "
"lowercase ASCII letter, ``[0-5][0-9]`` will match all the two-digits "
"numbers from ``00`` to ``59``, and ``[0-9A-Fa-f]`` will match any "
"hexadecimal digit.  If ``-`` is escaped (e.g. ``[a\\-z]``) or if it's "
"placed as the first or last character (e.g. ``[-a]`` or ``[a-]``), it "
"will match a literal ``'-'``."
msgstr ""

#: ../Doc/library/re.rst:184
msgid ""
"Special characters lose their special meaning inside sets.  For example, "
"``[(+*)]`` will match any of the literal characters ``'('``, ``'+'``, "
"``'*'``, or ``')'``."
msgstr ""

#: ../Doc/library/re.rst:188
msgid ""
"Character classes such as ``\\w`` or ``\\S`` (defined below) are also "
"accepted inside a set, although the characters they match depends on "
"whether :const:`ASCII` or :const:`LOCALE` mode is in force."
msgstr ""

#: ../Doc/library/re.rst:192
msgid ""
"Characters that are not within a range can be matched by "
":dfn:`complementing` the set.  If the first character of the set is "
"``'^'``, all the characters that are *not* in the set will be matched.  "
"For example, ``[^5]`` will match any character except ``'5'``, and "
"``[^^]`` will match any character except ``'^'``.  ``^`` has no special "
"meaning if it's not the first character in the set."
msgstr ""

#: ../Doc/library/re.rst:199
msgid ""
"To match a literal ``']'`` inside a set, precede it with a backslash, or "
"place it at the beginning of the set.  For example, both ``[()[\\]{}]`` "
"and ``[]()[{}]`` will both match a parenthesis."
msgstr ""

#: ../Doc/library/re.rst:203
msgid ""
"Support of nested sets and set operations as in `Unicode Technical "
"Standard #18`_ might be added in the future.  This would change the "
"syntax, so to facilitate this change a :exc:`FutureWarning` will be "
"raised in ambiguous cases for the time being. That include sets starting "
"with a literal ``'['`` or containing literal character sequences "
"``'--'``, ``'&&'``, ``'~~'``, and ``'||'``.  To avoid a warning escape "
"them with a backslash."
msgstr ""

#: ../Doc/library/re.rst:213
msgid ""
":exc:`FutureWarning` is raised if a character set contains constructs "
"that will change semantically in the future."
msgstr ""

#: ../Doc/library/re.rst:226
msgid "``|``"
msgstr ""

#: ../Doc/library/re.rst:218
msgid ""
"``A|B``, where *A* and *B* can be arbitrary REs, creates a regular "
"expression that will match either *A* or *B*.  An arbitrary number of REs"
" can be separated by the ``'|'`` in this way.  This can be used inside "
"groups (see below) as well.  As the target string is scanned, REs "
"separated by ``'|'`` are tried from left to right. When one pattern "
"completely matches, that branch is accepted. This means that once *A* "
"matches, *B* will not be tested further, even if it would produce a "
"longer overall match.  In other words, the ``'|'`` operator is never "
"greedy.  To match a literal ``'|'``, use ``\\|``, or enclose it inside a "
"character class, as in ``[|]``."
msgstr ""

#: ../Doc/library/re.rst:233
msgid "``(...)``"
msgstr ""

#: ../Doc/library/re.rst:229
msgid ""
"Matches whatever regular expression is inside the parentheses, and "
"indicates the start and end of a group; the contents of a group can be "
"retrieved after a match has been performed, and can be matched later in "
"the string with the ``\\number`` special sequence, described below.  To "
"match the literals ``'('`` or ``')'``, use ``\\(`` or ``\\)``, or enclose"
" them inside a character class: ``[(]``, ``[)]``."
msgstr ""

#: ../Doc/library/re.rst:240
msgid "``(?...)``"
msgstr ""

#: ../Doc/library/re.rst:236
msgid ""
"This is an extension notation (a ``'?'`` following a ``'('`` is not "
"meaningful otherwise).  The first character after the ``'?'`` determines "
"what the meaning and further syntax of the construct is. Extensions "
"usually do not create a new group; ``(?P<name>...)`` is the only "
"exception to this rule. Following are the currently supported extensions."
msgstr ""

#: ../Doc/library/re.rst:254
msgid "``(?aiLmsux)``"
msgstr ""

#: ../Doc/library/re.rst:243
msgid ""
"(One or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``.)  The group matches the empty string; the "
"letters set the corresponding flags: :const:`re.A` (ASCII-only matching),"
" :const:`re.I` (ignore case), :const:`re.L` (locale dependent), "
":const:`re.M` (multi-line), :const:`re.S` (dot matches all), "
":const:`re.U` (Unicode matching), and :const:`re.X` (verbose), for the "
"entire regular expression. (The flags are described in :ref:`contents-of-"
"module-re`.) This is useful if you wish to include the flags as part of "
"the regular expression, instead of passing a *flag* argument to the "
":func:`re.compile` function.  Flags should be used first in the "
"expression string."
msgstr ""

#: ../Doc/library/re.rst:260
msgid "``(?:...)``"
msgstr ""

#: ../Doc/library/re.rst:257
msgid ""
"A non-capturing version of regular parentheses.  Matches whatever regular"
" expression is inside the parentheses, but the substring matched by the "
"group *cannot* be retrieved after performing a match or referenced later "
"in the pattern."
msgstr ""

#: ../Doc/library/re.rst:286
msgid "``(?aiLmsux-imsx:...)``"
msgstr ""

#: ../Doc/library/re.rst:263
msgid ""
"(Zero or more letters from the set ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
"``'s'``, ``'u'``, ``'x'``, optionally followed by ``'-'`` followed by one"
" or more letters from the ``'i'``, ``'m'``, ``'s'``, ``'x'``.) The "
"letters set or remove the corresponding flags: :const:`re.A` (ASCII-only "
"matching), :const:`re.I` (ignore case), :const:`re.L` (locale dependent),"
" :const:`re.M` (multi-line), :const:`re.S` (dot matches all), "
":const:`re.U` (Unicode matching), and :const:`re.X` (verbose), for the "
"part of the expression. (The flags are described in :ref:`contents-of-"
"module-re`.)"
msgstr ""

#: ../Doc/library/re.rst:273
msgid ""
"The letters ``'a'``, ``'L'`` and ``'u'`` are mutually exclusive when used"
" as inline flags, so they can't be combined or follow ``'-'``.  Instead, "
"when one of them appears in an inline group, it overrides the matching "
"mode in the enclosing group.  In Unicode patterns ``(?a:...)`` switches "
"to ASCII-only matching, and ``(?u:...)`` switches to Unicode matching "
"(default).  In byte pattern ``(?L:...)`` switches to locale depending "
"matching, and ``(?a:...)`` switches to ASCII-only matching (default). "
"This override is only in effect for the narrow inline group, and the "
"original matching mode is restored outside of the group."
msgstr ""

#: ../Doc/library/re.rst:285
msgid "The letters ``'a'``, ``'L'`` and ``'u'`` also can be used in a group."
msgstr ""

#: ../Doc/library/re.rst:311
msgid "``(?P<name>...)``"
msgstr ""

#: ../Doc/library/re.rst:289
msgid ""
"Similar to regular parentheses, but the substring matched by the group is"
" accessible via the symbolic group name *name*.  Group names must be "
"valid Python identifiers, and each group name must be defined only once "
"within a regular expression.  A symbolic group is also a numbered group, "
"just as if the group were not named."
msgstr ""

#: ../Doc/library/re.rst:295
msgid ""
"Named groups can be referenced in three contexts.  If the pattern is "
"``(?P<quote>['\"]).*?(?P=quote)`` (i.e. matching a string quoted with "
"either single or double quotes):"
msgstr ""

#: ../Doc/library/re.rst:300
msgid "Context of reference to group \"quote\""
msgstr ""

#: ../Doc/library/re.rst:300
msgid "Ways to reference it"
msgstr ""

#: ../Doc/library/re.rst:302
msgid "in the same pattern itself"
msgstr ""

#: ../Doc/library/re.rst:302
msgid "``(?P=quote)`` (as shown)"
msgstr ""

#: ../Doc/library/re.rst:303 ../Doc/library/re.rst:310
msgid "``\\1``"
msgstr ""

#: ../Doc/library/re.rst:305
msgid "when processing match object *m*"
msgstr ""

#: ../Doc/library/re.rst:305
msgid "``m.group('quote')``"
msgstr ""

#: ../Doc/library/re.rst:306
msgid "``m.end('quote')`` (etc.)"
msgstr ""

#: ../Doc/library/re.rst:308
msgid "in a string passed to the *repl* argument of ``re.sub()``"
msgstr ""

#: ../Doc/library/re.rst:308
msgid "``\\g<quote>``"
msgstr ""

#: ../Doc/library/re.rst:309
msgid "``\\g<1>``"
msgstr ""

#: ../Doc/library/re.rst:315
msgid "``(?P=name)``"
msgstr ""

#: ../Doc/library/re.rst:314
msgid ""
"A backreference to a named group; it matches whatever text was matched by"
" the earlier group named *name*."
msgstr ""

#: ../Doc/library/re.rst:318
msgid "``(?#...)``"
msgstr ""

#: ../Doc/library/re.rst:318
msgid "A comment; the contents of the parentheses are simply ignored."
msgstr ""

#: ../Doc/library/re.rst:323
msgid "``(?=...)``"
msgstr ""

#: ../Doc/library/re.rst:321
msgid ""
"Matches if ``...`` matches next, but doesn't consume any of the string.  "
"This is called a :dfn:`lookahead assertion`.  For example, ``Isaac "
"(?=Asimov)`` will match ``'Isaac '`` only if it's followed by "
"``'Asimov'``."
msgstr ""

#: ../Doc/library/re.rst:328
msgid "``(?!...)``"
msgstr ""

#: ../Doc/library/re.rst:326
msgid ""
"Matches if ``...`` doesn't match next.  This is a :dfn:`negative "
"lookahead assertion`. For example, ``Isaac (?!Asimov)`` will match "
"``'Isaac '`` only if it's *not* followed by ``'Asimov'``."
msgstr ""

#: ../Doc/library/re.rst:353
msgid "``(?<=...)``"
msgstr ""

#: ../Doc/library/re.rst:331
msgid ""
"Matches if the current position in the string is preceded by a match for "
"``...`` that ends at the current position.  This is called a "
":dfn:`positive lookbehind assertion`. ``(?<=abc)def`` will find a match "
"in ``'abcdef'``, since the lookbehind will back up 3 characters and check"
" if the contained pattern matches. The contained pattern must only match "
"strings of some fixed length, meaning that ``abc`` or ``a|b`` are "
"allowed, but ``a*`` and ``a{3,4}`` are not.  Note that patterns which "
"start with positive lookbehind assertions will not match at the beginning"
" of the string being searched; you will most likely want to use the "
":func:`search` function rather than the :func:`match` function:"
msgstr ""

#: ../Doc/library/re.rst:346
msgid "This example looks for a word following a hyphen:"
msgstr ""

#: ../Doc/library/re.rst:352
msgid "Added support for group references of fixed length."
msgstr ""

#: ../Doc/library/re.rst:360
msgid "``(?<!...)``"
msgstr ""

#: ../Doc/library/re.rst:356
msgid ""
"Matches if the current position in the string is not preceded by a match "
"for ``...``.  This is called a :dfn:`negative lookbehind assertion`.  "
"Similar to positive lookbehind assertions, the contained pattern must "
"only match strings of some fixed length.  Patterns which start with "
"negative lookbehind assertions may match at the beginning of the string "
"being searched."
msgstr ""

#: ../Doc/library/re.rst:369
msgid "``(?(id/name)yes-pattern|no-pattern)``"
msgstr ""

#: ../Doc/library/re.rst:363
msgid ""
"Will try to match with ``yes-pattern`` if the group with given *id* or "
"*name* exists, and with ``no-pattern`` if it doesn't. ``no-pattern`` is "
"optional and can be omitted. For example, "
"``(<)?(\\w+@\\w+(?:\\.\\w+)+)(?(1)>|$)`` is a poor email matching "
"pattern, which will match with ``'<user@host.com>'`` as well as "
"``'user@host.com'``, but not with ``'<user@host.com'`` nor "
"``'user@host.com>'``."
msgstr ""

#: ../Doc/library/re.rst:371
msgid ""
"The special sequences consist of ``'\\'`` and a character from the list "
"below. If the ordinary character is not an ASCII digit or an ASCII "
"letter, then the resulting RE will match the second character.  For "
"example, ``\\$`` matches the character ``'$'``."
msgstr ""

#: ../Doc/library/re.rst:384
msgid "``\\number``"
msgstr ""

#: ../Doc/library/re.rst:377
msgid ""
"Matches the contents of the group of the same number.  Groups are "
"numbered starting from 1.  For example, ``(.+) \\1`` matches ``'the "
"the'`` or ``'55 55'``, but not ``'thethe'`` (note the space after the "
"group).  This special sequence can only be used to match one of the first"
" 99 groups.  If the first digit of *number* is 0, or *number* is 3 octal "
"digits long, it will not be interpreted as a group match, but as the "
"character with octal value *number*. Inside the ``'['`` and ``']'`` of a "
"character class, all numeric escapes are treated as characters."
msgstr ""

#: ../Doc/library/re.rst:387
msgid "``\\A``"
msgstr ""

#: ../Doc/library/re.rst:387
msgid "Matches only at the start of the string."
msgstr ""

#: ../Doc/library/re.rst:401
msgid "``\\b``"
msgstr ""

#: ../Doc/library/re.rst:390
msgid ""
"Matches the empty string, but only at the beginning or end of a word. A "
"word is defined as a sequence of word characters.  Note that formally, "
"``\\b`` is defined as the boundary between a ``\\w`` and a ``\\W`` "
"character (or vice versa), or between ``\\w`` and the beginning/end of "
"the string. This means that ``r'\\bfoo\\b'`` matches ``'foo'``, "
"``'foo.'``, ``'(foo)'``, ``'bar foo baz'`` but not ``'foobar'`` or "
"``'foo3'``."
msgstr ""

#: ../Doc/library/re.rst:397
msgid ""
"By default Unicode alphanumerics are the ones used in Unicode patterns, "
"but this can be changed by using the :const:`ASCII` flag.  Word "
"boundaries are determined by the current locale if the :const:`LOCALE` "
"flag is used. Inside a character range, ``\\b`` represents the backspace "
"character, for compatibility with Python's string literals."
msgstr ""

#: ../Doc/library/re.rst:410
msgid "``\\B``"
msgstr ""

#: ../Doc/library/re.rst:404
msgid ""
"Matches the empty string, but only when it is *not* at the beginning or "
"end of a word.  This means that ``r'py\\B'`` matches ``'python'``, "
"``'py3'``, ``'py2'``, but not ``'py'``, ``'py.'``, or ``'py!'``. ``\\B`` "
"is just the opposite of ``\\b``, so word characters in Unicode patterns "
"are Unicode alphanumerics or the underscore, although this can be changed"
" by using the :const:`ASCII` flag.  Word boundaries are determined by the"
" current locale if the :const:`LOCALE` flag is used."
msgstr ""

#: ../Doc/library/re.rst:420
msgid "``\\d``"
msgstr ""

#: ../Doc/library/re.rst:417 ../Doc/library/re.rst:433
#: ../Doc/library/re.rst:449
msgid "For Unicode (str) patterns:"
msgstr ""

#: ../Doc/library/re.rst:414
msgid ""
"Matches any Unicode decimal digit (that is, any character in Unicode "
"character category [Nd]).  This includes ``[0-9]``, and also many other "
"digit characters.  If the :const:`ASCII` flag is used only ``[0-9]`` is "
"matched."
msgstr ""

#: ../Doc/library/re.rst:420 ../Doc/library/re.rst:437
#: ../Doc/library/re.rst:455
msgid "For 8-bit (bytes) patterns:"
msgstr ""

#: ../Doc/library/re.rst:420
msgid "Matches any decimal digit; this is equivalent to ``[0-9]``."
msgstr ""

#: ../Doc/library/re.rst:425
msgid "``\\D``"
msgstr ""

#: ../Doc/library/re.rst:423
msgid ""
"Matches any character which is not a decimal digit. This is the opposite "
"of ``\\d``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^0-9]``."
msgstr ""

#: ../Doc/library/re.rst:437
msgid "``\\s``"
msgstr ""

#: ../Doc/library/re.rst:429
msgid ""
"Matches Unicode whitespace characters (which includes ``[ "
"\\t\\n\\r\\f\\v]``, and also many other characters, for example the non-"
"breaking spaces mandated by typography rules in many languages). If the "
":const:`ASCII` flag is used, only ``[ \\t\\n\\r\\f\\v]`` is matched."
msgstr ""

#: ../Doc/library/re.rst:436
msgid ""
"Matches characters considered whitespace in the ASCII character set; this"
" is equivalent to ``[ \\t\\n\\r\\f\\v]``."
msgstr ""

#: ../Doc/library/re.rst:442
msgid "``\\S``"
msgstr ""

#: ../Doc/library/re.rst:440
msgid ""
"Matches any character which is not a whitespace character. This is the "
"opposite of ``\\s``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^ \\t\\n\\r\\f\\v]``."
msgstr ""

#: ../Doc/library/re.rst:455
msgid "``\\w``"
msgstr ""

#: ../Doc/library/re.rst:446
msgid ""
"Matches Unicode word characters; this includes most characters that can "
"be part of a word in any language, as well as numbers and the underscore."
" If the :const:`ASCII` flag is used, only ``[a-zA-Z0-9_]`` is matched."
msgstr ""

#: ../Doc/library/re.rst:452
msgid ""
"Matches characters considered alphanumeric in the ASCII character set; "
"this is equivalent to ``[a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is "
"used, matches characters considered alphanumeric in the current locale "
"and the underscore."
msgstr ""

#: ../Doc/library/re.rst:462
msgid "``\\W``"
msgstr ""

#: ../Doc/library/re.rst:458
msgid ""
"Matches any character which is not a word character. This is the opposite"
" of ``\\w``. If the :const:`ASCII` flag is used this becomes the "
"equivalent of ``[^a-zA-Z0-9_]``.  If the :const:`LOCALE` flag is used, "
"matches characters considered alphanumeric in the current locale and the "
"underscore."
msgstr ""

#: ../Doc/library/re.rst:465
msgid "``\\Z``"
msgstr ""

#: ../Doc/library/re.rst:465
msgid "Matches only at the end of the string."
msgstr ""

#: ../Doc/library/re.rst:467
msgid ""
"Most of the standard escapes supported by Python string literals are also"
" accepted by the regular expression parser::"
msgstr ""

#: ../Doc/library/re.rst:474
msgid ""
"(Note that ``\\b`` is used to represent word boundaries, and means "
"\"backspace\" only inside character classes.)"
msgstr ""

#: ../Doc/library/re.rst:477
msgid ""
"``'\\u'`` and ``'\\U'`` escape sequences are only recognized in Unicode "
"patterns.  In bytes patterns they are errors."
msgstr ""

#: ../Doc/library/re.rst:480
msgid ""
"Octal escapes are included in a limited form.  If the first digit is a 0,"
" or if there are three octal digits, it is considered an octal escape. "
"Otherwise, it is a group reference.  As for string literals, octal "
"escapes are always at most three digits in length."
msgstr ""

#: ../Doc/library/re.rst:485
msgid "The ``'\\u'`` and ``'\\U'`` escape sequences have been added."
msgstr ""

#: ../Doc/library/re.rst:488
msgid "Unknown escapes consisting of ``'\\'`` and an ASCII letter now are errors."
msgstr ""

#: ../Doc/library/re.rst:496
msgid "Module Contents"
msgstr ""

#: ../Doc/library/re.rst:498
msgid ""
"The module defines several functions, constants, and an exception. Some "
"of the functions are simplified versions of the full featured methods for"
" compiled regular expressions.  Most non-trivial applications always use "
"the compiled form."
msgstr ""

#: ../Doc/library/re.rst:503
msgid ""
"Flag constants are now instances of :class:`RegexFlag`, which is a "
"subclass of :class:`enum.IntFlag`."
msgstr ""

#: ../Doc/library/re.rst:509
msgid ""
"Compile a regular expression pattern into a :ref:`regular expression "
"object <re-objects>`, which can be used for matching using its "
":func:`~Pattern.match`, :func:`~Pattern.search` and other methods, "
"described below."
msgstr ""

#: ../Doc/library/re.rst:514
msgid ""
"The expression's behaviour can be modified by specifying a *flags* value."
" Values can be any of the following variables, combined using bitwise OR "
"(the ``|`` operator)."
msgstr ""

#: ../Doc/library/re.rst:518
msgid "The sequence ::"
msgstr ""

#: ../Doc/library/re.rst:523
msgid "is equivalent to ::"
msgstr ""

#: ../Doc/library/re.rst:527
msgid ""
"but using :func:`re.compile` and saving the resulting regular expression "
"object for reuse is more efficient when the expression will be used "
"several times in a single program."
msgstr ""

#: ../Doc/library/re.rst:533
msgid ""
"The compiled versions of the most recent patterns passed to "
":func:`re.compile` and the module-level matching functions are cached, so"
" programs that use only a few regular expressions at a time needn't worry"
" about compiling regular expressions."
msgstr ""

#: ../Doc/library/re.rst:542
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, ``\\d``, ``\\D``, ``\\s`` and "
"``\\S`` perform ASCII-only matching instead of full Unicode matching.  "
"This is only meaningful for Unicode patterns, and is ignored for byte "
"patterns. Corresponds to the inline flag ``(?a)``."
msgstr ""

#: ../Doc/library/re.rst:547
msgid ""
"Note that for backward compatibility, the :const:`re.U` flag still exists"
" (as well as its synonym :const:`re.UNICODE` and its embedded counterpart"
" ``(?u)``), but these are redundant in Python 3 since matches are Unicode"
" by default for strings (and Unicode matching isn't allowed for bytes)."
msgstr ""

#: ../Doc/library/re.rst:556
msgid ""
"Display debug information about compiled expression. No corresponding "
"inline flag."
msgstr ""

#: ../Doc/library/re.rst:563
msgid ""
"Perform case-insensitive matching; expressions like ``[A-Z]`` will also "
"match lowercase letters.  Full Unicode matching (such as ``Ü`` matching "
"``ü``) also works unless the :const:`re.ASCII` flag is used to disable "
"non-ASCII matches.  The current locale does not change the effect of this"
" flag unless the :const:`re.LOCALE` flag is also used. Corresponds to the"
" inline flag ``(?i)``."
msgstr ""

#: ../Doc/library/re.rst:570
msgid ""
"Note that when the Unicode patterns ``[a-z]`` or ``[A-Z]`` are used in "
"combination with the :const:`IGNORECASE` flag, they will match the 52 "
"ASCII letters and 4 additional non-ASCII letters: 'İ' (U+0130, Latin "
"capital letter I with dot above), 'ı' (U+0131, Latin small letter dotless"
" i), 'ſ' (U+017F, Latin small letter long s) and 'K' (U+212A, Kelvin "
"sign). If the :const:`ASCII` flag is used, only letters 'a' to 'z' and "
"'A' to 'Z' are matched."
msgstr ""

#: ../Doc/library/re.rst:581
msgid ""
"Make ``\\w``, ``\\W``, ``\\b``, ``\\B`` and case-insensitive matching "
"dependent on the current locale.  This flag can be used only with bytes "
"patterns.  The use of this flag is discouraged as the locale mechanism is"
" very unreliable, it only handles one \"culture\" at a time, and it only "
"works with 8-bit locales.  Unicode matching is already enabled by default"
" in Python 3 for Unicode (str) patterns, and it is able to handle "
"different locales/languages. Corresponds to the inline flag ``(?L)``."
msgstr ""

#: ../Doc/library/re.rst:590
msgid ""
":const:`re.LOCALE` can be used only with bytes patterns and is not "
"compatible with :const:`re.ASCII`."
msgstr ""

#: ../Doc/library/re.rst:594
msgid ""
"Compiled regular expression objects with the :const:`re.LOCALE` flag no "
"longer depend on the locale at compile time.  Only the locale at matching"
" time affects the result of matching."
msgstr ""

#: ../Doc/library/re.rst:603
msgid ""
"When specified, the pattern character ``'^'`` matches at the beginning of"
" the string and at the beginning of each line (immediately following each"
" newline); and the pattern character ``'$'`` matches at the end of the "
"string and at the end of each line (immediately preceding each newline)."
"  By default, ``'^'`` matches only at the beginning of the string, and "
"``'$'`` only at the end of the string and immediately before the newline "
"(if any) at the end of the string. Corresponds to the inline flag "
"``(?m)``."
msgstr ""

#: ../Doc/library/re.rst:615
msgid ""
"Make the ``'.'`` special character match any character at all, including "
"a newline; without this flag, ``'.'`` will match anything *except* a "
"newline. Corresponds to the inline flag ``(?s)``."
msgstr ""

#: ../Doc/library/re.rst:623
msgid ""
"This flag allows you to write regular expressions that look nicer and are"
" more readable by allowing you to visually separate logical sections of "
"the pattern and add comments. Whitespace within the pattern is ignored, "
"except when in a character class, or when preceded by an unescaped "
"backslash, or within tokens like ``*?``, ``(?:`` or ``(?P<...>``. When a "
"line contains a ``#`` that is not in a character class and is not "
"preceded by an unescaped backslash, all characters from the leftmost such"
" ``#`` through the end of the line are ignored."
msgstr ""

#: ../Doc/library/re.rst:632
msgid ""
"This means that the two following regular expression objects that match a"
" decimal number are functionally equal::"
msgstr ""

#: ../Doc/library/re.rst:640
msgid "Corresponds to the inline flag ``(?x)``."
msgstr ""

#: ../Doc/library/re.rst:645
msgid ""
"Scan through *string* looking for the first location where the regular "
"expression *pattern* produces a match, and return a corresponding "
":ref:`match object <match-objects>`.  Return ``None`` if no position in "
"the string matches the pattern; note that this is different from finding "
"a zero-length match at some point in the string."
msgstr ""

#: ../Doc/library/re.rst:654
msgid ""
"If zero or more characters at the beginning of *string* match the regular"
" expression *pattern*, return a corresponding :ref:`match object <match-"
"objects>`.  Return ``None`` if the string does not match the pattern; "
"note that this is different from a zero-length match."
msgstr ""

#: ../Doc/library/re.rst:659
msgid ""
"Note that even in :const:`MULTILINE` mode, :func:`re.match` will only "
"match at the beginning of the string and not at the beginning of each "
"line."
msgstr ""

#: ../Doc/library/re.rst:662
msgid ""
"If you want to locate a match anywhere in *string*, use :func:`search` "
"instead (see also :ref:`search-vs-match`)."
msgstr ""

#: ../Doc/library/re.rst:668
msgid ""
"If the whole *string* matches the regular expression *pattern*, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if "
"the string does not match the pattern; note that this is different from a"
" zero-length match."
msgstr ""

#: ../Doc/library/re.rst:678
msgid ""
"Split *string* by the occurrences of *pattern*.  If capturing parentheses"
" are used in *pattern*, then the text of all groups in the pattern are "
"also returned as part of the resulting list. If *maxsplit* is nonzero, at"
" most *maxsplit* splits occur, and the remainder of the string is "
"returned as the final element of the list. ::"
msgstr ""

#: ../Doc/library/re.rst:693
msgid ""
"If there are capturing groups in the separator and it matches at the "
"start of the string, the result will start with an empty string.  The "
"same holds for the end of the string::"
msgstr ""

#: ../Doc/library/re.rst:700
msgid ""
"That way, separator components are always found at the same relative "
"indices within the result list."
msgstr ""

#: ../Doc/library/re.rst:703
msgid ""
"Empty matches for the pattern split the string only when not adjacent to "
"a previous empty match."
msgstr ""

#: ../Doc/library/re.rst:713 ../Doc/library/re.rst:789
#: ../Doc/library/re.rst:812
msgid "Added the optional flags argument."
msgstr ""

#: ../Doc/library/re.rst:716
msgid "Added support of splitting on a pattern that could match an empty string."
msgstr ""

#: ../Doc/library/re.rst:722
msgid ""
"Return all non-overlapping matches of *pattern* in *string*, as a list of"
" strings.  The *string* is scanned left-to-right, and matches are "
"returned in the order found.  If one or more groups are present in the "
"pattern, return a list of groups; this will be a list of tuples if the "
"pattern has more than one group.  Empty matches are included in the "
"result."
msgstr ""

#: ../Doc/library/re.rst:728 ../Doc/library/re.rst:739
msgid "Non-empty matches can now start just after a previous empty match."
msgstr ""

#: ../Doc/library/re.rst:734
msgid ""
"Return an :term:`iterator` yielding :ref:`match objects <match-objects>` "
"over all non-overlapping matches for the RE *pattern* in *string*.  The "
"*string* is scanned left-to-right, and matches are returned in the order "
"found.  Empty matches are included in the result."
msgstr ""

#: ../Doc/library/re.rst:745
msgid ""
"Return the string obtained by replacing the leftmost non-overlapping "
"occurrences of *pattern* in *string* by the replacement *repl*.  If the "
"pattern isn't found, *string* is returned unchanged.  *repl* can be a "
"string or a function; if it is a string, any backslash escapes in it are "
"processed.  That is, ``\\n`` is converted to a single newline character, "
"``\\r`` is converted to a carriage return, and so forth.  Unknown escapes"
" such as ``\\&`` are left alone.  Backreferences, such as ``\\6``, are "
"replaced with the substring matched by group 6 in the pattern. For "
"example::"
msgstr ""

#: ../Doc/library/re.rst:759
msgid ""
"If *repl* is a function, it is called for every non-overlapping "
"occurrence of *pattern*.  The function takes a single :ref:`match object "
"<match-objects>` argument, and returns the replacement string.  For "
"example::"
msgstr ""

#: ../Doc/library/re.rst:771
msgid "The pattern may be a string or a :ref:`pattern object <re-objects>`."
msgstr ""

#: ../Doc/library/re.rst:773
msgid ""
"The optional argument *count* is the maximum number of pattern "
"occurrences to be replaced; *count* must be a non-negative integer.  If "
"omitted or zero, all occurrences will be replaced. Empty matches for the "
"pattern are replaced only when not adjacent to a previous empty match, so"
" ``sub('x*', '-', 'abxd')`` returns ``'-a-b--d-'``."
msgstr ""

#: ../Doc/library/re.rst:779
msgid ""
"In string-type *repl* arguments, in addition to the character escapes and"
" backreferences described above, ``\\g<name>`` will use the substring "
"matched by the group named ``name``, as defined by the ``(?P<name>...)`` "
"syntax. ``\\g<number>`` uses the corresponding group number; ``\\g<2>`` "
"is therefore equivalent to ``\\2``, but isn't ambiguous in a replacement "
"such as ``\\g<2>0``.  ``\\20`` would be interpreted as a reference to "
"group 20, not a reference to group 2 followed by the literal character "
"``'0'``.  The backreference ``\\g<0>`` substitutes in the entire "
"substring matched by the RE."
msgstr ""

#: ../Doc/library/re.rst:792 ../Doc/library/re.rst:815
#: ../Doc/library/re.rst:1044
msgid "Unmatched groups are replaced with an empty string."
msgstr ""

#: ../Doc/library/re.rst:795
msgid ""
"Unknown escapes in *pattern* consisting of ``'\\'`` and an ASCII letter "
"now are errors."
msgstr ""

#: ../Doc/library/re.rst:799
msgid ""
"Unknown escapes in *repl* consisting of ``'\\'`` and an ASCII letter now "
"are errors."
msgstr ""

#: ../Doc/library/re.rst:803
msgid ""
"Empty matches for the pattern are replaced when adjacent to a previous "
"non-empty match."
msgstr ""

#: ../Doc/library/re.rst:809
msgid ""
"Perform the same operation as :func:`sub`, but return a tuple "
"``(new_string, number_of_subs_made)``."
msgstr ""

#: ../Doc/library/re.rst:821
msgid ""
"Escape special characters in *pattern*. This is useful if you want to "
"match an arbitrary literal string that may have regular expression "
"metacharacters in it.  For example::"
msgstr ""

#: ../Doc/library/re.rst:836
msgid ""
"This functions must not be used for the replacement string in :func:`sub`"
" and :func:`subn`, only backslashes should be escaped.  For example::"
msgstr ""

#: ../Doc/library/re.rst:844
msgid "The ``'_'`` character is no longer escaped."
msgstr ""

#: ../Doc/library/re.rst:847
msgid ""
"Only characters that can have special meaning in a regular expression are"
" escaped."
msgstr ""

#: ../Doc/library/re.rst:854
msgid "Clear the regular expression cache."
msgstr ""

#: ../Doc/library/re.rst:859
msgid ""
"Exception raised when a string passed to one of the functions here is not"
" a valid regular expression (for example, it might contain unmatched "
"parentheses) or when some other error occurs during compilation or "
"matching.  It is never an error if a string contains no match for a "
"pattern.  The error instance has the following additional attributes:"
msgstr ""

#: ../Doc/library/re.rst:867
msgid "The unformatted error message."
msgstr ""

#: ../Doc/library/re.rst:871
msgid "The regular expression pattern."
msgstr ""

#: ../Doc/library/re.rst:875
msgid "The index in *pattern* where compilation failed (may be ``None``)."
msgstr ""

#: ../Doc/library/re.rst:879
msgid "The line corresponding to *pos* (may be ``None``)."
msgstr ""

#: ../Doc/library/re.rst:883
msgid "The column corresponding to *pos* (may be ``None``)."
msgstr ""

#: ../Doc/library/re.rst:885
msgid "Added additional attributes."
msgstr ""

#: ../Doc/library/re.rst:891
msgid "Regular Expression Objects"
msgstr ""

#: ../Doc/library/re.rst:893
msgid ""
"Compiled regular expression objects support the following methods and "
"attributes:"
msgstr ""

#: ../Doc/library/re.rst:898
msgid ""
"Scan through *string* looking for the first location where this regular "
"expression produces a match, and return a corresponding :ref:`match "
"object <match-objects>`.  Return ``None`` if no position in the string "
"matches the pattern; note that this is different from finding a zero-"
"length match at some point in the string."
msgstr ""

#: ../Doc/library/re.rst:904
msgid ""
"The optional second parameter *pos* gives an index in the string where "
"the search is to start; it defaults to ``0``.  This is not completely "
"equivalent to slicing the string; the ``'^'`` pattern character matches "
"at the real beginning of the string and at positions just after a "
"newline, but not necessarily at the index where the search is to start."
msgstr ""

#: ../Doc/library/re.rst:910
msgid ""
"The optional parameter *endpos* limits how far the string will be "
"searched; it will be as if the string is *endpos* characters long, so "
"only the characters from *pos* to ``endpos - 1`` will be searched for a "
"match.  If *endpos* is less than *pos*, no match will be found; "
"otherwise, if *rx* is a compiled regular expression object, "
"``rx.search(string, 0, 50)`` is equivalent to ``rx.search(string[:50], "
"0)``. ::"
msgstr ""

#: ../Doc/library/re.rst:925
msgid ""
"If zero or more characters at the *beginning* of *string* match this "
"regular expression, return a corresponding :ref:`match object <match-"
"objects>`. Return ``None`` if the string does not match the pattern; note"
" that this is different from a zero-length match."
msgstr ""

#: ../Doc/library/re.rst:930 ../Doc/library/re.rst:948
msgid ""
"The optional *pos* and *endpos* parameters have the same meaning as for "
"the :meth:`~Pattern.search` method. ::"
msgstr ""

#: ../Doc/library/re.rst:938
msgid ""
"If you want to locate a match anywhere in *string*, use "
":meth:`~Pattern.search` instead (see also :ref:`search-vs-match`)."
msgstr ""

#: ../Doc/library/re.rst:944
msgid ""
"If the whole *string* matches this regular expression, return a "
"corresponding :ref:`match object <match-objects>`.  Return ``None`` if "
"the string does not match the pattern; note that this is different from a"
" zero-length match."
msgstr ""

#: ../Doc/library/re.rst:962
msgid "Identical to the :func:`split` function, using the compiled pattern."
msgstr ""

#: ../Doc/library/re.rst:967
msgid ""
"Similar to the :func:`findall` function, using the compiled pattern, but "
"also accepts optional *pos* and *endpos* parameters that limit the search"
" region like for :meth:`search`."
msgstr ""

#: ../Doc/library/re.rst:974
msgid ""
"Similar to the :func:`finditer` function, using the compiled pattern, but"
" also accepts optional *pos* and *endpos* parameters that limit the "
"search region like for :meth:`search`."
msgstr ""

#: ../Doc/library/re.rst:981
msgid "Identical to the :func:`sub` function, using the compiled pattern."
msgstr ""

#: ../Doc/library/re.rst:986
msgid "Identical to the :func:`subn` function, using the compiled pattern."
msgstr ""

#: ../Doc/library/re.rst:991
msgid ""
"The regex matching flags.  This is a combination of the flags given to "
":func:`.compile`, any ``(?...)`` inline flags in the pattern, and "
"implicit flags such as :data:`UNICODE` if the pattern is a Unicode "
"string."
msgstr ""

#: ../Doc/library/re.rst:998
msgid "The number of capturing groups in the pattern."
msgstr ""

#: ../Doc/library/re.rst:1003
msgid ""
"A dictionary mapping any symbolic group names defined by ``(?P<id>)`` to "
"group numbers.  The dictionary is empty if no symbolic groups were used "
"in the pattern."
msgstr ""

#: ../Doc/library/re.rst:1010
msgid "The pattern string from which the pattern object was compiled."
msgstr ""

#: ../Doc/library/re.rst:1013
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Compiled "
"regular expression objects are considered atomic."
msgstr ""

#: ../Doc/library/re.rst:1021
msgid "Match Objects"
msgstr ""

#: ../Doc/library/re.rst:1023
msgid ""
"Match objects always have a boolean value of ``True``. Since "
":meth:`~Pattern.match` and :meth:`~Pattern.search` return ``None`` when "
"there is no match, you can test whether there was a match with a simple "
"``if`` statement::"
msgstr ""

#: ../Doc/library/re.rst:1032
msgid "Match objects support the following methods and attributes:"
msgstr ""

#: ../Doc/library/re.rst:1037
msgid ""
"Return the string obtained by doing backslash substitution on the "
"template string *template*, as done by the :meth:`~Pattern.sub` method. "
"Escapes such as ``\\n`` are converted to the appropriate characters, and "
"numeric backreferences (``\\1``, ``\\2``) and named backreferences "
"(``\\g<1>``, ``\\g<name>``) are replaced by the contents of the "
"corresponding group."
msgstr ""

#: ../Doc/library/re.rst:1049
msgid ""
"Returns one or more subgroups of the match.  If there is a single "
"argument, the result is a single string; if there are multiple arguments,"
" the result is a tuple with one item per argument. Without arguments, "
"*group1* defaults to zero (the whole match is returned). If a *groupN* "
"argument is zero, the corresponding return value is the entire matching "
"string; if it is in the inclusive range [1..99], it is the string "
"matching the corresponding parenthesized group.  If a group number is "
"negative or larger than the number of groups defined in the pattern, an "
":exc:`IndexError` exception is raised. If a group is contained in a part "
"of the pattern that did not match, the corresponding result is ``None``. "
"If a group is contained in a part of the pattern that matched multiple "
"times, the last match is returned. ::"
msgstr ""

#: ../Doc/library/re.rst:1071
msgid ""
"If the regular expression uses the ``(?P<name>...)`` syntax, the *groupN*"
" arguments may also be strings identifying groups by their group name.  "
"If a string argument is not used as a group name in the pattern, an "
":exc:`IndexError` exception is raised."
msgstr ""

#: ../Doc/library/re.rst:1076
msgid "A moderately complicated example::"
msgstr ""

#: ../Doc/library/re.rst:1084
msgid "Named groups can also be referred to by their index::"
msgstr ""

#: ../Doc/library/re.rst:1091
msgid "If a group matches multiple times, only the last match is accessible::"
msgstr ""

#: ../Doc/library/re.rst:1100
msgid ""
"This is identical to ``m.group(g)``.  This allows easier access to an "
"individual group from a match::"
msgstr ""

#: ../Doc/library/re.rst:1116
msgid ""
"Return a tuple containing all the subgroups of the match, from 1 up to "
"however many groups are in the pattern.  The *default* argument is used "
"for groups that did not participate in the match; it defaults to "
"``None``."
msgstr ""

#: ../Doc/library/re.rst:1120 ../Doc/library/re.rst:1345
msgid "For example::"
msgstr ""

#: ../Doc/library/re.rst:1126
msgid ""
"If we make the decimal place and everything after it optional, not all "
"groups might participate in the match.  These groups will default to "
"``None`` unless the *default* argument is given::"
msgstr ""

#: ../Doc/library/re.rst:1139
msgid ""
"Return a dictionary containing all the *named* subgroups of the match, "
"keyed by the subgroup name.  The *default* argument is used for groups "
"that did not participate in the match; it defaults to ``None``.  For "
"example::"
msgstr ""

#: ../Doc/library/re.rst:1151
msgid ""
"Return the indices of the start and end of the substring matched by "
"*group*; *group* defaults to zero (meaning the whole matched substring). "
"Return ``-1`` if *group* exists but did not contribute to the match.  For"
" a match object *m*, and a group *g* that did contribute to the match, "
"the substring matched by group *g* (equivalent to ``m.group(g)``) is ::"
msgstr ""

#: ../Doc/library/re.rst:1159
msgid ""
"Note that ``m.start(group)`` will equal ``m.end(group)`` if *group* "
"matched a null string.  For example, after ``m = re.search('b(c?)', "
"'cba')``, ``m.start(0)`` is 1, ``m.end(0)`` is 2, ``m.start(1)`` and "
"``m.end(1)`` are both 2, and ``m.start(2)`` raises an :exc:`IndexError` "
"exception."
msgstr ""

#: ../Doc/library/re.rst:1164
msgid "An example that will remove *remove_this* from email addresses::"
msgstr ""

#: ../Doc/library/re.rst:1174
msgid ""
"For a match *m*, return the 2-tuple ``(m.start(group), m.end(group))``. "
"Note that if *group* did not contribute to the match, this is ``(-1, "
"-1)``. *group* defaults to zero, the entire match."
msgstr ""

#: ../Doc/library/re.rst:1181
msgid ""
"The value of *pos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  "
"This is the index into the string at which the RE engine started looking "
"for a match."
msgstr ""

#: ../Doc/library/re.rst:1188
msgid ""
"The value of *endpos* which was passed to the :meth:`~Pattern.search` or "
":meth:`~Pattern.match` method of a :ref:`regex object <re-objects>`.  "
"This is the index into the string beyond which the RE engine will not go."
msgstr ""

#: ../Doc/library/re.rst:1195
msgid ""
"The integer index of the last matched capturing group, or ``None`` if no "
"group was matched at all. For example, the expressions ``(a)b``, "
"``((a)(b))``, and ``((ab))`` will have ``lastindex == 1`` if applied to "
"the string ``'ab'``, while the expression ``(a)(b)`` will have "
"``lastindex == 2``, if applied to the same string."
msgstr ""

#: ../Doc/library/re.rst:1204
msgid ""
"The name of the last matched capturing group, or ``None`` if the group "
"didn't have a name, or if no group was matched at all."
msgstr ""

#: ../Doc/library/re.rst:1210
msgid ""
"The :ref:`regular expression object <re-objects>` whose "
":meth:`~Pattern.match` or :meth:`~Pattern.search` method produced this "
"match instance."
msgstr ""

#: ../Doc/library/re.rst:1216
msgid "The string passed to :meth:`~Pattern.match` or :meth:`~Pattern.search`."
msgstr ""

#: ../Doc/library/re.rst:1219
msgid ""
"Added support of :func:`copy.copy` and :func:`copy.deepcopy`.  Match "
"objects are considered atomic."
msgstr ""

#: ../Doc/library/re.rst:1227
msgid "Regular Expression Examples"
msgstr ""

#: ../Doc/library/re.rst:1231
msgid "Checking for a Pair"
msgstr ""

#: ../Doc/library/re.rst:1233
msgid ""
"In this example, we'll use the following helper function to display match"
" objects a little more gracefully:"
msgstr ""

#: ../Doc/library/re.rst:1243
msgid ""
"Suppose you are writing a poker program where a player's hand is "
"represented as a 5-character string with each character representing a "
"card, \"a\" for ace, \"k\" for king, \"q\" for queen, \"j\" for jack, "
"\"t\" for 10, and \"2\" through \"9\" representing the card with that "
"value."
msgstr ""

#: ../Doc/library/re.rst:1248
msgid "To see if a given string is a valid hand, one could do the following::"
msgstr ""

#: ../Doc/library/re.rst:1258
msgid ""
"That last hand, ``\"727ak\"``, contained a pair, or two of the same "
"valued cards. To match this with a regular expression, one could use "
"backreferences as such::"
msgstr ""

#: ../Doc/library/re.rst:1268
msgid ""
"To find out what card the pair consists of, one could use the "
":meth:`~Match.group` method of the match object in the following manner:"
msgstr ""

#: ../Doc/library/re.rst:1288
msgid "Simulating scanf()"
msgstr ""

#: ../Doc/library/re.rst:1292
msgid ""
"Python does not currently have an equivalent to :c:func:`scanf`.  Regular"
" expressions are generally more powerful, though also more verbose, than "
":c:func:`scanf` format strings.  The table below offers some more-or-less"
" equivalent mappings between :c:func:`scanf` format tokens and regular "
"expressions."
msgstr ""

#: ../Doc/library/re.rst:1299
msgid ":c:func:`scanf` Token"
msgstr ""

#: ../Doc/library/re.rst:1299
msgid "Regular Expression"
msgstr ""

#: ../Doc/library/re.rst:1301
#, python-format
msgid "``%c``"
msgstr ""

#: ../Doc/library/re.rst:1303
#, python-format
msgid "``%5c``"
msgstr ""

#: ../Doc/library/re.rst:1303
msgid "``.{5}``"
msgstr ""

#: ../Doc/library/re.rst:1305
#, python-format
msgid "``%d``"
msgstr ""

#: ../Doc/library/re.rst:1305
msgid "``[-+]?\\d+``"
msgstr ""

#: ../Doc/library/re.rst:1307
#, python-format
msgid "``%e``, ``%E``, ``%f``, ``%g``"
msgstr ""

#: ../Doc/library/re.rst:1307
msgid "``[-+]?(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?``"
msgstr ""

#: ../Doc/library/re.rst:1309
#, python-format
msgid "``%i``"
msgstr ""

#: ../Doc/library/re.rst:1309
msgid "``[-+]?(0[xX][\\dA-Fa-f]+|0[0-7]*|\\d+)``"
msgstr ""

#: ../Doc/library/re.rst:1311
#, python-format
msgid "``%o``"
msgstr ""

#: ../Doc/library/re.rst:1311
msgid "``[-+]?[0-7]+``"
msgstr ""

#: ../Doc/library/re.rst:1313
#, python-format
msgid "``%s``"
msgstr ""

#: ../Doc/library/re.rst:1313
msgid "``\\S+``"
msgstr ""

#: ../Doc/library/re.rst:1315
#, python-format
msgid "``%u``"
msgstr ""

#: ../Doc/library/re.rst:1315
msgid "``\\d+``"
msgstr ""

#: ../Doc/library/re.rst:1317
#, python-format
msgid "``%x``, ``%X``"
msgstr ""

#: ../Doc/library/re.rst:1317
msgid "``[-+]?(0[xX])?[\\dA-Fa-f]+``"
msgstr ""

#: ../Doc/library/re.rst:1320
msgid "To extract the filename and numbers from a string like ::"
msgstr ""

#: ../Doc/library/re.rst:1324
msgid "you would use a :c:func:`scanf` format like ::"
msgstr ""

#: ../Doc/library/re.rst:1328
msgid "The equivalent regular expression would be ::"
msgstr ""

#: ../Doc/library/re.rst:1336
msgid "search() vs. match()"
msgstr ""

#: ../Doc/library/re.rst:1340
msgid ""
"Python offers two different primitive operations based on regular "
"expressions: :func:`re.match` checks for a match only at the beginning of"
" the string, while :func:`re.search` checks for a match anywhere in the "
"string (this is what Perl does by default)."
msgstr ""

#: ../Doc/library/re.rst:1351
msgid ""
"Regular expressions beginning with ``'^'`` can be used with "
":func:`search` to restrict the match at the beginning of the string::"
msgstr ""

#: ../Doc/library/re.rst:1359
msgid ""
"Note however that in :const:`MULTILINE` mode :func:`match` only matches "
"at the beginning of the string, whereas using :func:`search` with a "
"regular expression beginning with ``'^'`` will match at the beginning of "
"each line. ::"
msgstr ""

#: ../Doc/library/re.rst:1369
msgid "Making a Phonebook"
msgstr ""

#: ../Doc/library/re.rst:1371
msgid ""
":func:`split` splits a string into a list delimited by the passed "
"pattern.  The method is invaluable for converting textual data into data "
"structures that can be easily read and modified by Python as demonstrated"
" in the following example that creates a phonebook."
msgstr ""

#: ../Doc/library/re.rst:1376
msgid ""
"First, here is the input.  Normally it may come from a file, here we are "
"using triple-quoted string syntax::"
msgstr ""

#: ../Doc/library/re.rst:1387
msgid ""
"The entries are separated by one or more newlines. Now we convert the "
"string into a list with each nonempty line having its own entry:"
msgstr ""

#: ../Doc/library/re.rst:1400
msgid ""
"Finally, split each entry into a list with first name, last name, "
"telephone number, and address.  We use the ``maxsplit`` parameter of "
":func:`split` because the address has spaces, our splitting pattern, in "
"it:"
msgstr ""

#: ../Doc/library/re.rst:1413
msgid ""
"The ``:?`` pattern matches the colon after the last name, so that it does"
" not occur in the result list.  With a ``maxsplit`` of ``4``, we could "
"separate the house number from the street name:"
msgstr ""

#: ../Doc/library/re.rst:1428
msgid "Text Munging"
msgstr ""

#: ../Doc/library/re.rst:1430
msgid ""
":func:`sub` replaces every occurrence of a pattern with a string or the "
"result of a function.  This example demonstrates using :func:`sub` with a"
" function to \"munge\" text, or randomize the order of all the characters"
" in each word of a sentence except for the first and last characters::"
msgstr ""

#: ../Doc/library/re.rst:1447
msgid "Finding all Adverbs"
msgstr ""

#: ../Doc/library/re.rst:1449
msgid ""
":func:`findall` matches *all* occurrences of a pattern, not just the "
"first one as :func:`search` does.  For example, if a writer wanted to "
"find all of the adverbs in some text, they might use :func:`findall` in "
"the following manner::"
msgstr ""

#: ../Doc/library/re.rst:1460
msgid "Finding all Adverbs and their Positions"
msgstr ""

#: ../Doc/library/re.rst:1462
msgid ""
"If one wants more information about all matches of a pattern than the "
"matched text, :func:`finditer` is useful as it provides :ref:`match "
"objects <match-objects>` instead of strings.  Continuing with the "
"previous example, if a writer wanted to find all of the adverbs *and "
"their positions* in some text, they would use :func:`finditer` in the "
"following manner::"
msgstr ""

#: ../Doc/library/re.rst:1476
msgid "Raw String Notation"
msgstr ""

#: ../Doc/library/re.rst:1478
msgid ""
"Raw string notation (``r\"text\"``) keeps regular expressions sane.  "
"Without it, every backslash (``'\\'``) in a regular expression would have"
" to be prefixed with another one to escape it.  For example, the two "
"following lines of code are functionally identical::"
msgstr ""

#: ../Doc/library/re.rst:1488
msgid ""
"When one wants to match a literal backslash, it must be escaped in the "
"regular expression.  With raw string notation, this means ``r\"\\\\\"``."
"  Without raw string notation, one must use ``\"\\\\\\\\\"``, making the "
"following lines of code functionally identical::"
msgstr ""

#: ../Doc/library/re.rst:1500
msgid "Writing a Tokenizer"
msgstr ""

#: ../Doc/library/re.rst:1502
msgid ""
"A `tokenizer or scanner "
"<https://en.wikipedia.org/wiki/Lexical_analysis>`_ analyzes a string to "
"categorize groups of characters.  This is a useful first step in writing "
"a compiler or interpreter."
msgstr ""

#: ../Doc/library/re.rst:1506
msgid ""
"The text categories are specified with regular expressions.  The "
"technique is to combine those into a single master regular expression and"
" to loop over successive matches::"
msgstr ""

#: ../Doc/library/re.rst:1556
msgid "The tokenizer produces the following output::"
msgstr ""

#: ../Doc/library/re.rst:1579
msgid ""
"Friedl, Jeffrey. Mastering Regular Expressions. 3rd ed., O'Reilly Media, "
"2009. The third edition of the book no longer covers Python at all, but "
"the first edition covered writing good regular expression patterns in "
"great detail."
msgstr ""

#~ msgid ""
#~ "Both patterns and strings to be "
#~ "searched can be Unicode strings as "
#~ "well as 8-bit strings. However, Unicode"
#~ " strings and 8-bit strings cannot be"
#~ " mixed: that is, you cannot match "
#~ "a Unicode string with a byte "
#~ "pattern or vice-versa; similarly, when"
#~ " asking for a substitution, the "
#~ "replacement string must be of the "
#~ "same type as both the pattern and"
#~ " the search string."
#~ msgstr ""

#~ msgid ""
#~ "Some characters, like ``'|'`` or "
#~ "``'('``, are special. Special characters "
#~ "either stand for classes of ordinary "
#~ "characters, or affect how the regular"
#~ " expressions around them are interpreted."
#~ " Regular expression pattern strings may "
#~ "not contain null bytes, but can "
#~ "specify the null byte using a "
#~ "``\\number`` notation such as ``'\\x00'``."
#~ msgstr ""

#~ msgid "``'.'``"
#~ msgstr ""

#~ msgid "``'^'``"
#~ msgstr ""

#~ msgid "``'$'``"
#~ msgstr ""

#~ msgid "``'*'``"
#~ msgstr ""

#~ msgid "``'+'``"
#~ msgstr ""

#~ msgid "``'?'``"
#~ msgstr ""

#~ msgid ""
#~ "The ``'*'``, ``'+'``, and ``'?'`` "
#~ "qualifiers are all :dfn:`greedy`; they "
#~ "match as much text as possible.  "
#~ "Sometimes this behaviour isn't desired; "
#~ "if the RE ``<.*>`` is matched "
#~ "against ``<a> b <c>``, it will "
#~ "match the entire string, and not "
#~ "just ``<a>``.  Adding ``?`` after the"
#~ " qualifier makes it perform the match"
#~ " in :dfn:`non-greedy` or :dfn:`minimal` "
#~ "fashion; as *few* characters as possible"
#~ " will be matched.  Using the RE "
#~ "``<.*?>`` will match only ``<a>``."
#~ msgstr ""

#~ msgid ""
#~ "Causes the resulting RE to match "
#~ "from *m* to *n* repetitions of the"
#~ " preceding RE, attempting to match as"
#~ " many repetitions as possible.  For "
#~ "example, ``a{3,5}`` will match from 3"
#~ " to 5 ``'a'`` characters.  Omitting "
#~ "*m* specifies a lower bound of "
#~ "zero,  and omitting *n* specifies an "
#~ "infinite upper bound.  As an example,"
#~ " ``a{4,}b`` will match ``aaaab`` or a"
#~ " thousand ``'a'`` characters followed by"
#~ " a ``b``, but not ``aaab``. The "
#~ "comma may not be omitted or the"
#~ " modifier would be confused with the"
#~ " previously described form."
#~ msgstr ""

#~ msgid "``'\\'``"
#~ msgstr ""

#~ msgid ""
#~ "Ranges of characters can be indicated"
#~ " by giving two characters and "
#~ "separating them by a ``'-'``, for "
#~ "example ``[a-z]`` will match any "
#~ "lowercase ASCII letter, ``[0-5][0-9]`` will"
#~ " match all the two-digits numbers "
#~ "from ``00`` to ``59``, and ``[0-9A-"
#~ "Fa-f]`` will match any hexadecimal "
#~ "digit.  If ``-`` is escaped (e.g. "
#~ "``[a\\-z]``) or if it's placed as "
#~ "the first or last character (e.g. "
#~ "``[a-]``), it will match a literal "
#~ "``'-'``."
#~ msgstr ""

#~ msgid "``'|'``"
#~ msgstr ""

#~ msgid ""
#~ "``A|B``, where A and B can be "
#~ "arbitrary REs, creates a regular "
#~ "expression that will match either A "
#~ "or B.  An arbitrary number of REs"
#~ " can be separated by the ``'|'`` "
#~ "in this way.  This can be used "
#~ "inside groups (see below) as well.  "
#~ "As the target string is scanned, "
#~ "REs separated by ``'|'`` are tried "
#~ "from left to right. When one "
#~ "pattern completely matches, that branch "
#~ "is accepted. This means that once "
#~ "``A`` matches, ``B`` will not be "
#~ "tested further, even if it would "
#~ "produce a longer overall match.  In "
#~ "other words, the ``'|'`` operator is "
#~ "never greedy.  To match a literal "
#~ "``'|'``, use ``\\|``, or enclose it "
#~ "inside a character class, as in "
#~ "``[|]``."
#~ msgstr ""

#~ msgid ""
#~ "Matches whatever regular expression is "
#~ "inside the parentheses, and indicates "
#~ "the start and end of a group; "
#~ "the contents of a group can be "
#~ "retrieved after a match has been "
#~ "performed, and can be matched later "
#~ "in the string with the ``\\number`` "
#~ "special sequence, described below.  To "
#~ "match the literals ``'('`` or ``')'``,"
#~ " use ``\\(`` or ``\\)``, or enclose"
#~ " them inside a character class: ``[(]"
#~ " [)]``."
#~ msgstr ""

#~ msgid ""
#~ "(One or more letters from the set"
#~ " ``'a'``, ``'i'``, ``'L'``, ``'m'``, "
#~ "``'s'``, ``'u'``, ``'x'``.)  The group "
#~ "matches the empty string; the letters"
#~ " set the corresponding flags: :const:`re.A`"
#~ " (ASCII-only matching), :const:`re.I` "
#~ "(ignore case), :const:`re.L` (locale "
#~ "dependent), :const:`re.M` (multi-line), "
#~ ":const:`re.S` (dot matches all), and "
#~ ":const:`re.X` (verbose), for the entire "
#~ "regular expression. (The flags are "
#~ "described in :ref:`contents-of-module-"
#~ "re`.) This is useful if you wish"
#~ " to include the flags as part "
#~ "of the regular expression, instead of"
#~ " passing a *flag* argument to the "
#~ ":func:`re.compile` function.  Flags should be"
#~ " used first in the expression string."
#~ msgstr ""

#~ msgid "when processing match object ``m``"
#~ msgstr ""

#~ msgid "in a string passed to the ``repl`` argument of ``re.sub()``"
#~ msgstr ""

#~ msgid ""
#~ "Matches if ``...`` matches next, but "
#~ "doesn't consume any of the string.  "
#~ "This is called a lookahead assertion."
#~ "  For example, ``Isaac (?=Asimov)`` will"
#~ " match ``'Isaac '`` only if it's "
#~ "followed by ``'Asimov'``."
#~ msgstr ""

#~ msgid ""
#~ "Matches if ``...`` doesn't match next."
#~ "  This is a negative lookahead "
#~ "assertion. For example, ``Isaac (?!Asimov)``"
#~ " will match ``'Isaac '`` only if "
#~ "it's *not* followed by ``'Asimov'``."
#~ msgstr ""

#~ msgid ""
#~ "Matches if the current position in "
#~ "the string is preceded by a match"
#~ " for ``...`` that ends at the "
#~ "current position.  This is called a "
#~ ":dfn:`positive lookbehind assertion`. "
#~ "``(?<=abc)def`` will find a match in "
#~ "``abcdef``, since the lookbehind will "
#~ "back up 3 characters and check if"
#~ " the contained pattern matches. The "
#~ "contained pattern must only match "
#~ "strings of some fixed length, meaning"
#~ " that ``abc`` or ``a|b`` are allowed,"
#~ " but ``a*`` and ``a{3,4}`` are not."
#~ "  Note that patterns which start with"
#~ " positive lookbehind assertions will not"
#~ " match at the beginning of the "
#~ "string being searched; you will most "
#~ "likely want to use the :func:`search`"
#~ " function rather than the :func:`match` "
#~ "function:"
#~ msgstr ""

#~ msgid ""
#~ "Matches the empty string, but only "
#~ "at the beginning or end of a "
#~ "word. A word is defined as a "
#~ "sequence of Unicode alphanumeric or "
#~ "underscore characters, so the end of "
#~ "a word is indicated by whitespace "
#~ "or a non-alphanumeric, non-underscore"
#~ " Unicode character.  Note that formally,"
#~ " ``\\b`` is defined as the boundary"
#~ " between a ``\\w`` and a ``\\W`` "
#~ "character (or vice versa), or between"
#~ " ``\\w`` and the beginning/end of the"
#~ " string. This means that ``r'\\bfoo\\b'``"
#~ " matches ``'foo'``, ``'foo.'``, ``'(foo)'``, "
#~ "``'bar foo baz'`` but not ``'foobar'``"
#~ " or ``'foo3'``."
#~ msgstr ""

#~ msgid ""
#~ "By default Unicode alphanumerics are the"
#~ " ones used, but this can  be "
#~ "changed by using the :const:`ASCII` "
#~ "flag.  Inside a character range, ``\\b``"
#~ " represents the backspace character, for"
#~ " compatibility with Python's string "
#~ "literals."
#~ msgstr ""

#~ msgid ""
#~ "Matches the empty string, but only "
#~ "when it is *not* at the beginning"
#~ " or end of a word.  This means"
#~ " that ``r'py\\B'`` matches ``'python'``, "
#~ "``'py3'``, ``'py2'``, but not ``'py'``, "
#~ "``'py.'``, or ``'py!'``. ``\\B`` is just"
#~ " the opposite of ``\\b``, so word "
#~ "characters are Unicode alphanumerics or "
#~ "the underscore, although this can be "
#~ "changed by using the :const:`ASCII` "
#~ "flag."
#~ msgstr ""

#~ msgid ""
#~ "Matches any character which is not "
#~ "a Unicode decimal digit. This is "
#~ "the opposite of ``\\d``. If the "
#~ ":const:`ASCII` flag is used this becomes"
#~ " the equivalent of ``[^0-9]`` (but "
#~ "the flag affects the entire regular "
#~ "expression, so in such cases using "
#~ "an explicit ``[^0-9]`` may be a "
#~ "better choice)."
#~ msgstr ""

#~ msgid ""
#~ "Matches any character which is not "
#~ "a Unicode whitespace character. This is"
#~ " the opposite of ``\\s``. If the "
#~ ":const:`ASCII` flag is used this becomes"
#~ " the equivalent of ``[^ \\t\\n\\r\\f\\v]``"
#~ " (but the flag affects the entire "
#~ "regular expression, so in such cases "
#~ "using an explicit ``[^ \\t\\n\\r\\f\\v]`` "
#~ "may be a better choice)."
#~ msgstr ""

#~ msgid ""
#~ "Matches characters considered alphanumeric in"
#~ " the ASCII character set; this is "
#~ "equivalent to ``[a-zA-Z0-9_]``."
#~ msgstr ""

#~ msgid ""
#~ "Matches any character which is not "
#~ "a Unicode word character. This is "
#~ "the opposite of ``\\w``. If the "
#~ ":const:`ASCII` flag is used this becomes"
#~ " the equivalent of ``[^a-zA-Z0-9_]`` (but"
#~ " the flag affects the entire regular"
#~ " expression, so in such cases using"
#~ " an explicit ``[^a-zA-Z0-9_]`` may be "
#~ "a better choice)."
#~ msgstr ""

#~ msgid ""
#~ "``'\\u'`` and ``'\\U'`` escape sequences "
#~ "are only recognized in Unicode patterns."
#~ "  In bytes patterns they are not "
#~ "treated specially."
#~ msgstr ""

#~ msgid ""
#~ "Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, "
#~ "``\\d``, ``\\D``, ``\\s`` and ``\\S`` "
#~ "perform ASCII-only matching instead of"
#~ " full Unicode matching.  This is only"
#~ " meaningful for Unicode patterns, and "
#~ "is ignored for byte patterns."
#~ msgstr ""

#~ msgid "Display debug information about compiled expression."
#~ msgstr ""

#~ msgid ""
#~ "Perform case-insensitive matching; expressions"
#~ " like ``[A-Z]`` will also match "
#~ "lowercase letters.  The current locale "
#~ "does not change the effect of this"
#~ " flag.  Full Unicode matching (such "
#~ "as ``Ü`` matching ``ü``) also works "
#~ "unless the :const:`re.ASCII` flag is "
#~ "also used to disable non-ASCII "
#~ "matches."
#~ msgstr ""

#~ msgid ""
#~ "Make ``\\w``, ``\\W``, ``\\b``, ``\\B``, "
#~ "``\\s`` and ``\\S`` dependent on the "
#~ "current locale. The use of this "
#~ "flag is discouraged as the locale "
#~ "mechanism is very unreliable, and it "
#~ "only handles one \"culture\" at a "
#~ "time anyway; you should use Unicode "
#~ "matching instead, which is the default"
#~ " in Python 3 for Unicode (str) "
#~ "patterns. This flag can be used "
#~ "only with bytes patterns."
#~ msgstr ""

#~ msgid ""
#~ "When specified, the pattern character "
#~ "``'^'`` matches at the beginning of "
#~ "the string and at the beginning of"
#~ " each line (immediately following each "
#~ "newline); and the pattern character "
#~ "``'$'`` matches at the end of the"
#~ " string and at the end of each"
#~ " line (immediately preceding each newline)."
#~ "  By default, ``'^'`` matches only at"
#~ " the beginning of the string, and "
#~ "``'$'`` only at the end of the "
#~ "string and immediately before the "
#~ "newline (if any) at the end of "
#~ "the string."
#~ msgstr ""

#~ msgid ""
#~ "Make the ``'.'`` special character match"
#~ " any character at all, including a"
#~ " newline; without this flag, ``'.'`` "
#~ "will match anything *except* a newline."
#~ msgstr ""

#~ msgid ""
#~ "This flag allows you to write "
#~ "regular expressions that look nicer and"
#~ " are more readable by allowing you"
#~ " to visually separate logical sections "
#~ "of the pattern and add comments. "
#~ "Whitespace within the pattern is "
#~ "ignored, except when in a character "
#~ "class or when preceded by an "
#~ "unescaped backslash. When a line "
#~ "contains a ``#`` that is not in"
#~ " a character class and is not "
#~ "preceded by an unescaped backslash, all"
#~ " characters from the leftmost such "
#~ "``#`` through the end of the line"
#~ " are ignored."
#~ msgstr ""

#~ msgid ""
#~ "If there are capturing groups in "
#~ "the separator and it matches at "
#~ "the start of the string, the "
#~ "result will start with an empty "
#~ "string.  The same holds for the "
#~ "end of the string:"
#~ msgstr ""

#~ msgid ""
#~ ":func:`split` doesn't currently split a "
#~ "string on an empty pattern match. "
#~ "For example:"
#~ msgstr ""

#~ msgid ""
#~ "Return the string obtained by replacing"
#~ " the leftmost non-overlapping occurrences"
#~ " of *pattern* in *string* by the "
#~ "replacement *repl*.  If the pattern "
#~ "isn't found, *string* is returned "
#~ "unchanged.  *repl* can be a string "
#~ "or a function; if it is a "
#~ "string, any backslash escapes in it "
#~ "are processed.  That is, ``\\n`` is "
#~ "converted to a single newline character,"
#~ " ``\\r`` is converted to a carriage"
#~ " return, and so forth.  Unknown "
#~ "escapes such as ``\\&`` are left "
#~ "alone.  Backreferences, such as ``\\6``, "
#~ "are replaced with the substring matched"
#~ " by group 6 in the pattern. For"
#~ " example:"
#~ msgstr ""

#~ msgid ""
#~ "If *repl* is a function, it is "
#~ "called for every non-overlapping "
#~ "occurrence of *pattern*.  The function "
#~ "takes a single match object argument,"
#~ " and returns the replacement string.  "
#~ "For example:"
#~ msgstr ""

#~ msgid "The pattern may be a string or an RE object."
#~ msgstr ""

#~ msgid ""
#~ "The optional parameter *endpos* limits "
#~ "how far the string will be "
#~ "searched; it will be as if the "
#~ "string is *endpos* characters long, so"
#~ " only the characters from *pos* to"
#~ " ``endpos - 1`` will be searched "
#~ "for a match.  If *endpos* is less"
#~ " than *pos*, no match will be "
#~ "found; otherwise, if *rx* is a "
#~ "compiled regular expression object, "
#~ "``rx.search(string, 0, 50)`` is equivalent "
#~ "to ``rx.search(string[:50], 0)``."
#~ msgstr ""

#~ msgid ""
#~ "The optional *pos* and *endpos* "
#~ "parameters have the same meaning as "
#~ "for the :meth:`~regex.search` method."
#~ msgstr ""

#~ msgid ""
#~ "Similar to the :func:`findall` function, "
#~ "using the compiled pattern, but also "
#~ "accepts optional *pos* and *endpos* "
#~ "parameters that limit the search region"
#~ " like for :meth:`match`."
#~ msgstr ""

#~ msgid ""
#~ "Similar to the :func:`finditer` function, "
#~ "using the compiled pattern, but also "
#~ "accepts optional *pos* and *endpos* "
#~ "parameters that limit the search region"
#~ " like for :meth:`match`."
#~ msgstr ""

#~ msgid ""
#~ "Returns one or more subgroups of "
#~ "the match.  If there is a single"
#~ " argument, the result is a single "
#~ "string; if there are multiple arguments,"
#~ " the result is a tuple with one"
#~ " item per argument. Without arguments, "
#~ "*group1* defaults to zero (the whole "
#~ "match is returned). If a *groupN* "
#~ "argument is zero, the corresponding "
#~ "return value is the entire matching "
#~ "string; if it is in the inclusive"
#~ " range [1..99], it is the string "
#~ "matching the corresponding parenthesized "
#~ "group.  If a group number is "
#~ "negative or larger than the number "
#~ "of groups defined in the pattern, "
#~ "an :exc:`IndexError` exception is raised. "
#~ "If a group is contained in a "
#~ "part of the pattern that did not"
#~ " match, the corresponding result is "
#~ "``None``. If a group is contained "
#~ "in a part of the pattern that "
#~ "matched multiple times, the last match"
#~ " is returned."
#~ msgstr ""

#~ msgid "A moderately complicated example:"
#~ msgstr ""

#~ msgid "Named groups can also be referred to by their index:"
#~ msgstr ""

#~ msgid "If a group matches multiple times, only the last match is accessible:"
#~ msgstr ""

#~ msgid ""
#~ "This is identical to ``m.group(g)``.  "
#~ "This allows easier access to an "
#~ "individual group from a match:"
#~ msgstr ""

#~ msgid "For example:"
#~ msgstr ""

#~ msgid ""
#~ "If we make the decimal place and"
#~ " everything after it optional, not "
#~ "all groups might participate in the "
#~ "match.  These groups will default to "
#~ "``None`` unless the *default* argument "
#~ "is given:"
#~ msgstr ""

#~ msgid ""
#~ "Return a dictionary containing all the"
#~ " *named* subgroups of the match, "
#~ "keyed by the subgroup name.  The "
#~ "*default* argument is used for groups"
#~ " that did not participate in the "
#~ "match; it defaults to ``None``.  For "
#~ "example:"
#~ msgstr ""

#~ msgid "An example that will remove *remove_this* from email addresses:"
#~ msgstr ""

#~ msgid ""
#~ "The regular expression object whose "
#~ ":meth:`~regex.match` or :meth:`~regex.search` method"
#~ " produced this match instance."
#~ msgstr ""

#~ msgid "To see if a given string is a valid hand, one could do the following:"
#~ msgstr ""

#~ msgid ""
#~ "That last hand, ``\"727ak\"``, contained "
#~ "a pair, or two of the same "
#~ "valued cards. To match this with a"
#~ " regular expression, one could use "
#~ "backreferences as such:"
#~ msgstr ""

#~ msgid ""
#~ "Note however that in :const:`MULTILINE` "
#~ "mode :func:`match` only matches at the"
#~ " beginning of the string, whereas "
#~ "using :func:`search` with a regular "
#~ "expression beginning with ``'^'`` will "
#~ "match at the beginning of each "
#~ "line."
#~ msgstr ""

#~ msgid ""
#~ "First, here is the input.  Normally "
#~ "it may come from a file, here "
#~ "we are using triple-quoted string "
#~ "syntax:"
#~ msgstr ""

#~ msgid ""
#~ ":func:`findall` matches *all* occurrences of"
#~ " a pattern, not just the first "
#~ "one as :func:`search` does.  For "
#~ "example, if one was a writer and"
#~ " wanted to find all of the "
#~ "adverbs in some text, he or she"
#~ " might use :func:`findall` in the "
#~ "following manner:"
#~ msgstr ""

#~ msgid ""
#~ "If one wants more information about "
#~ "all matches of a pattern than the"
#~ " matched text, :func:`finditer` is useful"
#~ " as it provides :ref:`match objects "
#~ "<match-objects>` instead of strings.  "
#~ "Continuing with the previous example, if"
#~ " one was a writer who wanted to"
#~ " find all of the adverbs *and "
#~ "their positions* in some text, he "
#~ "or she would use :func:`finditer` in "
#~ "the following manner:"
#~ msgstr ""

#~ msgid ""
#~ "Raw string notation (``r\"text\"``) keeps "
#~ "regular expressions sane.  Without it, "
#~ "every backslash (``'\\'``) in a regular"
#~ " expression would have to be prefixed"
#~ " with another one to escape it.  "
#~ "For example, the two following lines "
#~ "of code are functionally identical:"
#~ msgstr ""

#~ msgid ""
#~ "When one wants to match a literal"
#~ " backslash, it must be escaped in "
#~ "the regular expression.  With raw string"
#~ " notation, this means ``r\"\\\\\"``.  "
#~ "Without raw string notation, one must"
#~ " use ``\"\\\\\\\\\"``, making the following"
#~ " lines of code functionally identical:"
#~ msgstr ""

#~ msgid ""
#~ "The third-party `regex "
#~ "<https://pypi.python.org/pypi/regex/>`_ module, which "
#~ "has an API compatible with the "
#~ "standard library :mod:`re` module, but "
#~ "offers additional functionality and a "
#~ "more thorough Unicode support."
#~ msgstr ""

#~ msgid ""
#~ "Regular expressions can be concatenated "
#~ "to form new regular expressions; if "
#~ "*A* and *B* are both regular "
#~ "expressions, then *AB* is also a "
#~ "regular expression. In general, if a "
#~ "string *p* matches *A* and another "
#~ "string *q* matches *B*, the string "
#~ "*pq* will match AB.  This holds "
#~ "unless *A* or *B* contain low "
#~ "precedence operations; boundary conditions "
#~ "between *A* and *B*; or have "
#~ "numbered group references.  Thus, complex "
#~ "expressions can easily be constructed "
#~ "from simpler primitive expressions like "
#~ "the ones described here.  For details"
#~ " of the theory and implementation of"
#~ " regular expressions, consult the Friedl"
#~ " book referenced above, or almost any"
#~ " textbook about compiler construction."
#~ msgstr ""

#~ msgid "Mastering Regular Expressions"
#~ msgstr ""

#~ msgid ""
#~ "Book on regular expressions by Jeffrey"
#~ " Friedl, published by O'Reilly.  The "
#~ "second edition of the book no "
#~ "longer covers Python at all, but "
#~ "the first edition covered writing good"
#~ " regular expression patterns in great "
#~ "detail."
#~ msgstr ""

#~ msgid ""
#~ "Return all non-overlapping matches of"
#~ " *pattern* in *string*, as a list "
#~ "of strings.  The *string* is scanned "
#~ "left-to-right, and matches are "
#~ "returned in the order found.  If "
#~ "one or more groups are present in"
#~ " the pattern, return a list of "
#~ "groups; this will be a list of "
#~ "tuples if the pattern has more "
#~ "than one group.  Empty matches are "
#~ "included in the result unless they "
#~ "touch the beginning of another match."
#~ msgstr ""

#~ msgid ""
#~ "Return an :term:`iterator` yielding "
#~ ":ref:`match objects <match-objects>` over "
#~ "all non-overlapping matches for the "
#~ "RE *pattern* in *string*.  The *string*"
#~ " is scanned left-to-right, and "
#~ "matches are returned in the order "
#~ "found.  Empty matches are included in"
#~ " the result unless they touch the "
#~ "beginning of another match."
#~ msgstr ""

#~ msgid ""
#~ "Deprecated since version 3.5, will be"
#~ " removed in version 3.7: Unknown "
#~ "escapes in repl consisting of '\\' "
#~ "and an ASCII letter now raise a"
#~ " deprecation warning and will be "
#~ "forbidden in Python 3.7."
#~ msgstr ""

#~ msgid "``(?imsx-imsx:...)``"
#~ msgstr ""

#~ msgid ""
#~ "(Zero or more letters from the set"
#~ " ``'i'``, ``'m'``, ``'s'``, ``'x'``, "
#~ "optionally followed by ``'-'`` followed "
#~ "by one or more letters from the"
#~ " same set.)  The letters set or "
#~ "removes the corresponding flags: :const:`re.I`"
#~ " (ignore case), :const:`re.M` (multi-line),"
#~ " :const:`re.S` (dot matches all), and "
#~ ":const:`re.X` (verbose), for the part of"
#~ " the expression.  (The flags are "
#~ "described in :ref:`contents-of-module-"
#~ "re`.)"
#~ msgstr ""

#~ msgid ""
#~ "Matches any Unicode decimal digit (that"
#~ " is, any character in Unicode "
#~ "character category [Nd]).  This includes "
#~ "``[0-9]``, and also many other digit "
#~ "characters.  If the :const:`ASCII` flag "
#~ "is used only ``[0-9]`` is matched "
#~ "(but the flag affects the entire "
#~ "regular expression, so in such cases "
#~ "using an explicit ``[0-9]`` may be "
#~ "a better choice)."
#~ msgstr ""

#~ msgid ""
#~ "Matches any character which is not "
#~ "a decimal digit. This is the "
#~ "opposite of ``\\d``. If the "
#~ ":const:`ASCII` flag is used this becomes"
#~ " the equivalent of ``[^0-9]`` (but "
#~ "the flag affects the entire regular "
#~ "expression, so in such cases using "
#~ "an explicit ``[^0-9]`` may be a "
#~ "better choice)."
#~ msgstr ""

#~ msgid ""
#~ "Matches Unicode whitespace characters (which"
#~ " includes ``[ \\t\\n\\r\\f\\v]``, and also"
#~ " many other characters, for example "
#~ "the non-breaking spaces mandated by "
#~ "typography rules in many languages). If"
#~ " the :const:`ASCII` flag is used, "
#~ "only ``[ \\t\\n\\r\\f\\v]`` is matched "
#~ "(but the flag affects the entire "
#~ "regular expression, so in such cases "
#~ "using an explicit ``[ \\t\\n\\r\\f\\v]`` "
#~ "may be a better choice)."
#~ msgstr ""

#~ msgid ""
#~ "Matches any character which is not "
#~ "a whitespace character. This is the "
#~ "opposite of ``\\s``. If the "
#~ ":const:`ASCII` flag is used this becomes"
#~ " the equivalent of ``[^ \\t\\n\\r\\f\\v]``"
#~ " (but the flag affects the entire "
#~ "regular expression, so in such cases "
#~ "using an explicit ``[^ \\t\\n\\r\\f\\v]`` "
#~ "may be a better choice)."
#~ msgstr ""

#~ msgid ""
#~ "Matches Unicode word characters; this "
#~ "includes most characters that can be "
#~ "part of a word in any language,"
#~ " as well as numbers and the "
#~ "underscore. If the :const:`ASCII` flag "
#~ "is used, only ``[a-zA-Z0-9_]`` is "
#~ "matched (but the flag affects the "
#~ "entire regular expression, so in such"
#~ " cases using an explicit ``[a-zA-Z0-9_]``"
#~ " may be a better choice)."
#~ msgstr ""

#~ msgid ""
#~ "Matches any character which is not "
#~ "a word character. This is the "
#~ "opposite of ``\\w``. If the "
#~ ":const:`ASCII` flag is used this becomes"
#~ " the equivalent of ``[^a-zA-Z0-9_]`` (but"
#~ " the flag affects the entire regular"
#~ " expression, so in such cases using"
#~ " an explicit ``[^a-zA-Z0-9_]`` may be "
#~ "a better choice).  If the "
#~ ":const:`LOCALE` flag is used, matches "
#~ "characters considered alphanumeric in the "
#~ "current locale and the underscore."
#~ msgstr ""

#~ msgid ""
#~ "Compile a regular expression pattern "
#~ "into a :ref:`regular expression object "
#~ "<re-objects>`, which can be used for"
#~ " matching using its :func:`~regex.match`, "
#~ ":func:`~regex.search` and other methods, "
#~ "described below."
#~ msgstr ""

#~ msgid ""
#~ "Note that when the Unicode patterns "
#~ "``[a-z]`` or ``[A-Z]`` are used in "
#~ "combination with the :const:`IGNORECASE` flag,"
#~ " they will match the 52 ASCII "
#~ "letters and 4 additional non-ASCII "
#~ "letters: 'İ' (U+0130, Latin capital "
#~ "letter I with dot above), 'ı' "
#~ "(U+0131, Latin small letter dotless i),"
#~ " 'ſ' (U+017F, Latin small letter long"
#~ " s) and 'K' (U+212A, Kelvin sign)."
#~ " If the :const:`ASCII` flag is used,"
#~ " only letters 'a' to 'z' and "
#~ "'A' to 'Z' are matched (but the"
#~ " flag affects the entire regular "
#~ "expression, so in such cases using "
#~ "an explicit ``(?-i:[a-zA-Z])`` may be a"
#~ " better choice)."
#~ msgstr ""

#~ msgid ""
#~ ":func:`split` doesn't currently split a "
#~ "string on an empty pattern match. "
#~ "For example::"
#~ msgstr ""

#~ msgid ""
#~ "Even though ``'x*'`` also matches 0 "
#~ "'x' before 'a', between 'b' and "
#~ "'c', and after 'c', currently these "
#~ "matches are ignored.  The correct "
#~ "behavior (i.e. splitting on empty "
#~ "matches too and returning ``['', 'a',"
#~ " 'b', 'c', '']``) will be implemented"
#~ " in future versions of Python, but"
#~ " since this is a backward "
#~ "incompatible change, a :exc:`FutureWarning` "
#~ "will be raised in the meanwhile."
#~ msgstr ""

#~ msgid ""
#~ "Patterns that can only match empty "
#~ "strings currently never split the "
#~ "string.  Since this doesn't match the"
#~ " expected behavior, a :exc:`ValueError` "
#~ "will be raised starting from Python "
#~ "3.5::"
#~ msgstr ""

#~ msgid ""
#~ "Splitting on a pattern that could "
#~ "match an empty string now raises a"
#~ " warning.  Patterns that can only "
#~ "match empty strings are now rejected."
#~ msgstr ""

#~ msgid ""
#~ "Due to the limitation of the "
#~ "current implementation the character following"
#~ " an empty match is not included "
#~ "in a next match, so ``findall(r'^|\\w+',"
#~ " 'two words')`` returns ``['', 'wo', "
#~ "'words']`` (note missed \"t\").  This is"
#~ " changed in Python 3.7."
#~ msgstr ""

#~ msgid ""
#~ "Return an :term:`iterator` yielding "
#~ ":ref:`match objects <match-objects>` over "
#~ "all non-overlapping matches for the "
#~ "RE *pattern* in *string*.  The *string*"
#~ " is scanned left-to-right, and "
#~ "matches are returned in the order "
#~ "found.  Empty matches are included in"
#~ " the result.  See also the note "
#~ "about :func:`findall`."
#~ msgstr ""

#~ msgid ""
#~ "The optional argument *count* is the "
#~ "maximum number of pattern occurrences to"
#~ " be replaced; *count* must be a "
#~ "non-negative integer.  If omitted or "
#~ "zero, all occurrences will be replaced."
#~ " Empty matches for the pattern are"
#~ " replaced only when not adjacent to"
#~ " a previous match, so ``sub('x*', "
#~ "'-', 'abc')`` returns ``'-a-b-c-'``."
#~ msgstr ""

#~ msgid ""
#~ "Unknown escapes in *repl* consisting of"
#~ " ``'\\'`` and an ASCII letter now "
#~ "raise a deprecation warning and will "
#~ "be forbidden in Python 3.7."
#~ msgstr ""

#~ msgid ""
#~ "Escape all the characters in *pattern*"
#~ " except ASCII letters, numbers and "
#~ "``'_'``. This is useful if you "
#~ "want to match an arbitrary literal "
#~ "string that may have regular expression"
#~ " metacharacters in it.  For example::"
#~ msgstr ""

#~ msgid ""
#~ "The optional *pos* and *endpos* "
#~ "parameters have the same meaning as "
#~ "for the :meth:`~regex.search` method. ::"
#~ msgstr ""

#~ msgid ""
#~ "If you want to locate a match "
#~ "anywhere in *string*, use "
#~ ":meth:`~regex.search` instead (see also :ref"
#~ ":`search-vs-match`)."
#~ msgstr ""

#~ msgid "The pattern string from which the RE object was compiled."
#~ msgstr ""

#~ msgid ""
#~ "Match objects always have a boolean "
#~ "value of ``True``. Since :meth:`~regex.match`"
#~ " and :meth:`~regex.search` return ``None`` "
#~ "when there is no match, you can"
#~ " test whether there was a match "
#~ "with a simple ``if`` statement::"
#~ msgstr ""

#~ msgid ""
#~ "Return the string obtained by doing "
#~ "backslash substitution on the template "
#~ "string *template*, as done by the "
#~ ":meth:`~regex.sub` method. Escapes such as "
#~ "``\\n`` are converted to the appropriate"
#~ " characters, and numeric backreferences "
#~ "(``\\1``, ``\\2``) and named backreferences"
#~ " (``\\g<1>``, ``\\g<name>``) are replaced "
#~ "by the contents of the corresponding "
#~ "group."
#~ msgstr ""

#~ msgid ""
#~ "The value of *pos* which was "
#~ "passed to the :meth:`~regex.search` or "
#~ ":meth:`~regex.match` method of a :ref:`regex"
#~ " object <re-objects>`.  This is the"
#~ " index into the string at which "
#~ "the RE engine started looking for "
#~ "a match."
#~ msgstr ""

#~ msgid ""
#~ "The value of *endpos* which was "
#~ "passed to the :meth:`~regex.search` or "
#~ ":meth:`~regex.match` method of a :ref:`regex"
#~ " object <re-objects>`.  This is the"
#~ " index into the string beyond which"
#~ " the RE engine will not go."
#~ msgstr ""

#~ msgid ""
#~ "The :ref:`regular expression object <re-"
#~ "objects>` whose :meth:`~regex.match` or "
#~ ":meth:`~regex.search` method produced this "
#~ "match instance."
#~ msgstr ""

#~ msgid "The string passed to :meth:`~regex.match` or :meth:`~regex.search`."
#~ msgstr ""

#~ msgid ""
#~ "To find out what card the pair "
#~ "consists of, one could use the "
#~ ":meth:`~match.group` method of the match "
#~ "object in the following manner:"
#~ msgstr ""

#~ msgid ""
#~ ":func:`findall` matches *all* occurrences of"
#~ " a pattern, not just the first "
#~ "one as :func:`search` does.  For "
#~ "example, if one was a writer and"
#~ " wanted to find all of the "
#~ "adverbs in some text, he or she"
#~ " might use :func:`findall` in the "
#~ "following manner::"
#~ msgstr ""

#~ msgid ""
#~ "If one wants more information about "
#~ "all matches of a pattern than the"
#~ " matched text, :func:`finditer` is useful"
#~ " as it provides :ref:`match objects "
#~ "<match-objects>` instead of strings.  "
#~ "Continuing with the previous example, if"
#~ " one was a writer who wanted to"
#~ " find all of the adverbs *and "
#~ "their positions* in some text, he "
#~ "or she would use :func:`finditer` in "
#~ "the following manner::"
#~ msgstr ""

