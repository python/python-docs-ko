# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-15 07:19+0900\n"
"PO-Revision-Date: 2018-12-02 15:37+0900\n"
"Last-Translator: Spike H.Y. Lee <rurouni24@gmail.com>\n"
"Language: ko_KR\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"Plural-Forms: nplurals=1; plural=0\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "유니코드 HOWTO"

#: ../Doc/howto/unicode.rst
msgid "Release"
msgstr "버전"

#: ../Doc/howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../Doc/howto/unicode.rst:9
#, fuzzy
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr "이 HOWTO는 유니코드를 지원하는 파이썬에 대한 설명과 유니코드로 작업할 때 일반적으로 마주하는 다양한 문제들에 관해 설명합니다."

#: ../Doc/howto/unicode.rst:15
msgid "Introduction to Unicode"
msgstr "유니코드 소개"

#: ../Doc/howto/unicode.rst:18
msgid "Definitions"
msgstr "정의"

#: ../Doc/howto/unicode.rst:20
msgid ""
"Today's programs need to be able to handle a wide variety of characters."
"  Applications are often internationalized to display messages and output"
" in a variety of user-selectable languages; the same program might need "
"to output an error message in English, French, Japanese, Hebrew, or "
"Russian.  Web content can be written in any of these languages and can "
"also include a variety of emoji symbols. Python's string type uses the "
"Unicode Standard for representing characters, which lets Python programs "
"work with all these different possible characters."
msgstr ""

#: ../Doc/howto/unicode.rst:30
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and "
"updated to add new languages and symbols."
msgstr ""

#: ../Doc/howto/unicode.rst:35
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'È' and 'Í'.  Characters"
" vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", 'Ⅰ', that's "
"separate from the uppercase letter 'I'.  They'll usually look the same, "
"but these are two different characters that have different meanings."
msgstr ""

#: ../Doc/howto/unicode.rst:42
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, with some 110 thousand assigned so far).  In "
"the standard and in this document, a code point is written using the "
"notation ``U+265E`` to mean the character with value ``0x265e`` (9,822 in"
" decimal)."
msgstr ""

#: ../Doc/howto/unicode.rst:49
msgid ""
"The Unicode standard contains a lot of tables listing characters and "
"their corresponding code points:"
msgstr ""

#: ../Doc/howto/unicode.rst:70
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some"
" particular character; in this case, it represents the character 'BLACK "
"CHESS KNIGHT', '♞'.  In informal contexts, this distinction between code "
"points and characters will sometimes be forgotten."
msgstr ""
"엄밀히 말하자면, 이러한 정의는 '이것이 문자 ``U+265E``'\\라고 말하는 것은 의미가 없음을 뜻합니다. "
"``U+265E``\\는 어떤 특정 문자를 표현하는 코드 포인트일 뿐입니다; 이 경우에는 'BLACK CHESS "
"KNIGHT'('♞')를 나타냅니다. 일상적인 문맥에서 코드 포인트와 문자 사이의 구분은 때때로 잊힐 겁니다."

#: ../Doc/howto/unicode.rst:77
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the "
"exact details will depend on the font being used.  Most Python code "
"doesn't need to worry about glyphs; figuring out the correct glyph to "
"display is generally the job of a GUI toolkit or a terminal's font "
"renderer."
msgstr ""
"문자는 화면이나 종이에 **글리프**\\라 불리는 그래픽 요소의 집합으로 표시됩니다. 예를 들어 대문자 A의 글리프는 두 개의 대각"
" 획과 한 개의 수평 획이지만, 정확한 세부사항은 글꼴에 따라 다릅니다. 대부분의 파이썬 코드는 글리프를 걱정할 필요가 없습니다; "
"표시할 올바른 글리프를 찾는 것은 일반적으로 GUI 툴킷이나 터미널의 글꼴 렌더러의 일입니다."

#: ../Doc/howto/unicode.rst:86
msgid "Encodings"
msgstr "인코딩"

#: ../Doc/howto/unicode.rst:88
#, fuzzy
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code"
" points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 "
"decimal).  This sequence of code points needs to be represented in memory"
" as a set of **code units**, and **code units** are then mapped to 8-bit "
"bytes.  The rules for translating a Unicode string into a sequence of "
"bytes are called a **character encoding**, or just an **encoding**."
msgstr ""
"이전 섹션 요약: 유니코드 문자열은 코드 포인트의 시퀀스이며, 0부터 ``0x10FFFF`` (십진수 1,114,111)의 범위를 "
"갖는 수입니다. 이 시퀀스는 메모리에서 바이트의 집합(0에서 255까지의 값)으로 표현되어야 합니다. 유니코드 문자열을 바이트 "
"시퀀스로 변환하는 규칙을 **인코딩**\\이라고 부릅니다."

#: ../Doc/howto/unicode.rst:96
#, fuzzy
msgid ""
"The first encoding you might think of is using 32-bit integers as the "
"code unit, and then using the CPU's representation of 32-bit integers. In"
" this representation, the string \"Python\" might look like this:"
msgstr "생각할 수 있는 첫 번째 인코딩은 32비트 정수 배열입니다. 이 표현에서 문자열 \"Python\"은 다음과 같습니다:"

#: ../Doc/howto/unicode.rst:106
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr "이 표현은 간단하지만 여러 문제를 가지고 있습니다."

#: ../Doc/howto/unicode.rst:109
msgid "It's not portable; different processors order the bytes differently."
msgstr "이식성이 없습니다; 다른 프로세서는 바이트를 다르게 정렬합니다."

#: ../Doc/howto/unicode.rst:111
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code "
"points are less than 127, or less than 255, so a lot of space is occupied"
" by ``0x00`` bytes.  The above string takes 24 bytes compared to the 6 "
"bytes needed for an ASCII representation.  Increased RAM usage doesn't "
"matter too much (desktop computers have gigabytes of RAM, and strings "
"aren't usually that large), but expanding our usage of disk and network "
"bandwidth by a factor of 4 is intolerable."
msgstr ""
"이는 공간을 매우 낭비하는 겁니다. 대부분 텍스트에서 주요 코드 포인트는 127 또는 255보다 작으므로 많은 공간이 "
"``0x00``\\으로 채워집니다. 위의 문자열은 ASCII 표현에 필요한 6 바이트와 비교하여 24 바이트를 사용합니다. 늘어난 "
"RAM 사용은 중요하지 않지만(데스크톱 컴퓨터는 기가바이트 단위의 RAM을 갖고 있고, 문자열은 대개 그 정도로 크지 않습니다), "
"디스크와 네트워크 대역폭 사용을 4배로 확장하는 것은 용납할 수 없습니다."

#: ../Doc/howto/unicode.rst:119
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a "
"new family of wide string functions would need to be used."
msgstr "``strlen()``\\과 같은 기존의 C 함수와 호환이 안 되기 때문에 새로운 와이드 문자열 함수 계열을 사용해야 합니다."

#: ../Doc/howto/unicode.rst:122
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr ""

#: ../Doc/howto/unicode.rst:125
#, fuzzy
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often "
"defaults to using it.  UTF stands for \"Unicode Transformation Format\", "
"and the '8' means that 8-bit values are used in the encoding.  (There are"
" also UTF-16 and UTF-32 encodings, but they are less frequently used than"
" UTF-8.)  UTF-8 uses the following rules:"
msgstr ""
"UTF-8은 일반적으로 가장 많이 사용되는 인코딩 중 하나입니다. UTF는 \"Unicode Transformation "
"Format\"의 약자이며 '8'은 8비트 숫자가 인코딩에 사용됨을 뜻합니다. (UTF-16과 UTF-32 인코딩도 있지만, "
"UTF-8보다 낮은 빈도로 사용됩니다.) UTF-8은 다음의 규칙을 따릅니다:"

#: ../Doc/howto/unicode.rst:131
msgid ""
"If the code point is < 128, it's represented by the corresponding byte "
"value."
msgstr "만약 코드 포인트가 128보다 작다면, 해당 바이트 값으로 표현됩니다."

#: ../Doc/howto/unicode.rst:132
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, "
"or four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"만약 코드 포인트가 128보다 크거나 같다면, 시퀀스의 각 바이트가 128에서 255 사이인 둘, 셋 또는 네 개의 바이트 시퀀스로"
" 바뀝니다."

#: ../Doc/howto/unicode.rst:135
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8은 몇 가지 편리한 특징이 있습니다:"

#: ../Doc/howto/unicode.rst:137
msgid "It can handle any Unicode code point."
msgstr "모든 유니코드 코드 포인트를 처리 할 수 있습니다."

#: ../Doc/howto/unicode.rst:138
#, fuzzy
msgid ""
"A Unicode string is turned into a sequence of bytes that contains "
"embedded zero bytes only where they represent the null character "
"(U+0000). This means that UTF-8 strings can be processed by C functions "
"such as ``strcpy()`` and sent through protocols that can't handle zero "
"bytes for anything other than end-of-string markers."
msgstr ""
"유니코드 문자열은 0 바이트를 갖지 않는 바이트 시퀀스로 변환됩니다. 이는 바이트 순서 문제를 피할 수 있으며, UTF-8 문자열을"
" ``strcpy()``\\와 같은 C 함수로 처리하고 0바이트를 처리하지 못하는 프로토콜을 통해 전송할 수 있음을 의미합니다."

#: ../Doc/howto/unicode.rst:143
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "ASCII 텍스트의 문자열 역시 유효한 UTF-8 텍스트입니다."

#: ../Doc/howto/unicode.rst:144
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr "UTF-8은 꽤 알찹니다; 일반적으로 사용되는 문자 대부분을 한두 개의 바이트로 표현할 수 있습니다."

#: ../Doc/howto/unicode.rst:146
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of "
"the next UTF-8-encoded code point and resynchronize.  It's also unlikely "
"that random 8-bit data will look like valid UTF-8."
msgstr ""
"만약 바이트가 손상 또는 손실되었다면, 다음 UTF-8 인코딩 코드 포인트의 시작을 결정하고 다시 동기화할 수 있습니다. 무작위 "
"8비트 데이터가 유효한 UTF-8처럼 보일 가능성은 낮습니다."

#: ../Doc/howto/unicode.rst:149
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. "
"This avoids the byte-ordering issues that can occur with integer and word"
" oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""

#: ../Doc/howto/unicode.rst:157 ../Doc/howto/unicode.rst:513
#: ../Doc/howto/unicode.rst:734
msgid "References"
msgstr "참조"

#: ../Doc/howto/unicode.rst:159
msgid ""
"The `Unicode Consortium site <http://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology "
"<http://www.unicode.org/history/>`_ of the origin and development of "
"Unicode is also available on the site."
msgstr ""
"`유니코드 컨소시엄 사이트 <http://www.unicode.org>`_\\는 유니코드 사양의 문자 차트, 용어집 그리고 PDF "
"버전의 유니코드 명세를 갖고 있습니다. 어려운 읽기를 준비하세요. 유니코드의 기원과 개발의 `연대기 "
"<http://www.unicode.org/history/>`_\\  역시 이 사이트에서 볼 수 있습니다."

#: ../Doc/howto/unicode.rst:164
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 "
"<https://www.youtube.com/watch?v=MijmeoH9LT4>`_ (9 minutes 36 seconds)."
msgstr ""

#: ../Doc/howto/unicode.rst:168
msgid ""
"To help understand the standard, Jukka Korpela has written `an "
"introductory guide <http://jkorpela.fi/unicode/guide.html>`_ to reading "
"the Unicode character tables."
msgstr ""
"Jukka Korpela는 표준을 이해할 수 있도록 유니코드 문자표 읽기에 대한 `입문 안내서 "
"<http://jkorpela.fi/unicode/guide.html>`_\\를 작성했습니다."

#: ../Doc/howto/unicode.rst:172
msgid ""
"Another `good introductory article "
"<https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-"
"software-developer-absolutely-positively-must-know-about-unicode-and-"
"character-sets-no-excuses/>`_ was written by Joel Spolsky. If this "
"introduction didn't make things clear to you, you should try reading this"
" alternate article before continuing."
msgstr ""
"또 다른 `좋은 입문 글 <https://www.joelonsoftware.com/2003/10/08/the-absolute-"
"minimum-every-software-developer-absolutely-positively-must-know-about-"
"unicode-and-character-sets-no-excuses/>`_\\을 Joel Spolsky가 썼습니다. 이 입문서로도 "
"명확하지 않은 경우 계속하기 전에 이 대체 문서를 읽으세요."

#: ../Doc/howto/unicode.rst:177
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and "
"`UTF-8 <https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"위키피디아 항목은 때때로 도움이 됩니다; 예를 들어, \"`문자 인코딩 "
"<https://en.wikipedia.org/wiki/Character_encoding>`_\"\\과 `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_ 항목을 보세요."

#: ../Doc/howto/unicode.rst:183
msgid "Python's Unicode Support"
msgstr "파이썬의 유니코드 지원"

#: ../Doc/howto/unicode.rst:185
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's"
" Unicode features."
msgstr "이제 유니코드의 기초를 배웠으므로 파이썬의 유니코드 기능을 살펴볼 수 있습니다."

#: ../Doc/howto/unicode.rst:189
msgid "The String Type"
msgstr "문자열 형"

#: ../Doc/howto/unicode.rst:191
#, fuzzy
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"파이썬 3.0부터는 유니코드 문자를 포함하고 있는 :class:`str` 타입을 특징으로 하며 이는 어떤 문자열이든 "
"``\"unicode rocks!\"``, ``'unicode rocks!'`` 또는 삼중 따옴표로 묶인 문자열 문법을 사용한다면 "
"유니코드로 저장됨을 뜻합니다."

#: ../Doc/howto/unicode.rst:195
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr "파이썬 소스 코드의 기본 인코딩은 UTF-8이므로 문자열 리터럴에 유니코드 문자를 쉽게 포함할 수 있습니다::"

#: ../Doc/howto/unicode.rst:205
msgid ""
"Side note: Python 3 also supports using Unicode characters in "
"identifiers::"
msgstr "사이드 노트: 파이썬 3은 유니코드 문자를 식별자에서도 지원합니다::"

#: ../Doc/howto/unicode.rst:211
msgid ""
"If you can't enter a particular character in your editor or want to keep "
"the source code ASCII-only for some reason, you can also use escape "
"sequences in string literals. (Depending on your system, you may see the "
"actual capital-delta glyph instead of a \\u escape.) ::"
msgstr ""
"편집기에서 특정 문자를 입력 할수 없거나 어떤 이유에서 ASCII만으로 소스 코드를 작성하고자 한다면, 문자열 리터럴에 이스케이프 "
"시퀀스를 사용할 수 있습니다. (시스템에 따라 다르지만, \\u 이스케이프 대신에 진짜 대문자 델타 글리프가 나타날 수 있습니다.)"
" ::"

#: ../Doc/howto/unicode.rst:223
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` "
"method of :class:`bytes`.  This method takes an *encoding* argument, such"
" as ``UTF-8``, and optionally an *errors* argument."
msgstr ""
"추가로, 문자열을 :class:`bytes`\\의 :func:`~bytes.decode` 메서드를 사용하여 만들 수 있습니다. 이 "
"메서드는 ``UTF-8``\\과 같은 *encoding* 인자와 선택적으로 *erros* 인자를 받습니다."

#: ../Doc/howto/unicode.rst:227
msgid ""
"The *errors* argument specifies the response when the input string can't "
"be converted according to the encoding's rules.  Legal values for this "
"argument are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The "
"following examples show the differences::"
msgstr ""
"*errors* 인자는 인코딩의 규칙에 따라 입력 문자열을 변환할 수 없는 경우의 응답을 지정합니다. 이 인자의 유효한 값은 "
"``'strict'`` (:exc:`UnicodeDecodeError` 예외 발생), ``'replace'`` "
"(``U+FFFD``, ``REPLACEMENT CHARACTER`` 사용), ``'ignore'`` (유니코드 결과에서 문자를 "
"그냥 생략), 또는 ``'backslashreplace'`` (``\\xNN`` 이스케이프 시퀀스를 삽입)입니다. 다음 에제는 그 "
"차이점을 보여줍니다::"

#: ../Doc/howto/unicode.rst:247
msgid ""
"Encodings are specified as strings containing the encoding's name.  "
"Python comes with roughly 100 different encodings; see the Python Library"
" Reference at :ref:`standard-encodings` for a list.  Some encodings have "
"multiple names; for example, ``'latin-1'``, ``'iso_8859_1'`` and "
"``'8859``' are all synonyms for the same encoding."
msgstr ""
"인코딩은 인코딩의 이름을 포함하는 문자열로 지정됩니다. 파이썬에는 대략 100개의 서로 다른 인코딩이 있습니다. 리스트는 :ref"
":`standard-encodings`\\에서 파이썬 라이브러리 레퍼런스를 보세요. 어떤 인코딩은 다양한 이름을 갖습니다; 예를 "
"들어, ``'latin-1'``, ``'iso_8859_1'`` 그리고 ``'8859``' 는 전부 같은 인코딩의 동의어입니다."

#: ../Doc/howto/unicode.rst:253
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` "
"built-in function, which takes integers and returns a Unicode string of "
"length 1 that contains the corresponding code point.  The reverse "
"operation is the built-in :func:`ord` function that takes a one-character"
" Unicode string and returns the code point value::"
msgstr ""
"한 문자 유니코드 문자열은 정수를 받고 해당 코드 포인트를 포함하는 길이 1인 유니코드 문자열을 반환하는 :func:`chr` 내장"
" 함수로도 만들 수 있습니다. 반대 작업은 한 문자 유니코드 문자열을 받고 코드 포인트 값을 반환하는 :func:`ord` 내장 "
"함수입니다::"

#: ../Doc/howto/unicode.rst:265
msgid "Converting to Bytes"
msgstr "바이트열로 변환"

#: ../Doc/howto/unicode.rst:267
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in"
" the requested *encoding*."
msgstr ""
":meth:`bytes.decode`\\의 반대 메서드는 요청된 *encoding*\\으로 인코딩 된 유니코드 문자열의 "
":class:`bytes`\\를 반환하는 :meth:`str.encode`\\입니다."

#: ../Doc/howto/unicode.rst:271
msgid ""
"The *errors* parameter is the same as the parameter of the "
":meth:`~bytes.decode` method but supports a few more possible handlers. "
"As well as ``'strict'``, ``'ignore'``, and ``'replace'`` (which in this "
"case inserts a question mark instead of the unencodable character), there"
" is also ``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"*errors* 매개변수는 :meth:`~bytes.decode` 메서드의 매개변수와 같지만 가능한 핸들러를 조금 더 제공합니다. "
"``'strict'``, ``'ignore'``, ``'replace'`` (이 경우 인코딩할 수 없는 문자 대신에 물음표를 "
"삽입)뿐만 아니라 ``'xmlcharrefreplace'`` (XML 문자 참조 삽입), ``backslashreplace`` "
"(``\\uNNNN`` 이스케이프 시퀀스 삽입) 그리고 ``namereplace`` (``\\N{...}`` 이스케이프 시퀀스 "
"삽입)도 있습니다."

#: ../Doc/howto/unicode.rst:279
msgid "The following example shows the different results::"
msgstr "아래 예제에서 서로 다른 결과를 보여줍니다::"

#: ../Doc/howto/unicode.rst:300
msgid ""
"The low-level routines for registering and accessing the available "
"encodings are found in the :mod:`codecs` module.  Implementing new "
"encodings also requires understanding the :mod:`codecs` module. However, "
"the encoding and decoding functions returned by this module are usually "
"more low-level than is comfortable, and writing new encodings is a "
"specialized task, so the module won't be covered in this HOWTO."
msgstr ""
"사용 가능한 인코딩을 등록하고 접근할 수 있도록 하는 저수준 루틴은 :mod:`codecs` 모듈에서 찾을 수 있습니다. 새로운 "
"인코딩을 구현하는 것도 :mod:`codecs` 모듈의 이해가 필요합니다. 하지만 이 모듈에 의해서 반환되는 인코딩과 디코딩 함수는"
" 대체로 편안한 것보다는 저수준이며, 새로운 인코딩을 작성하는 것은 전문적인 작업이므로 HOWTO에서 이 모듈을 다루지는 "
"않겠습니다."

#: ../Doc/howto/unicode.rst:309
msgid "Unicode Literals in Python Source Code"
msgstr "파이썬 소스 코드에서 유니코드 리터럴"

#: ../Doc/howto/unicode.rst:311
msgid ""
"In Python source code, specific Unicode code points can be written using "
"the ``\\u`` escape sequence, which is followed by four hex digits giving "
"the code point.  The ``\\U`` escape sequence is similar, but expects "
"eight hex digits, not four::"
msgstr ""
"파이썬 소스 코드에서 특정한 유니코드 코드 포인트는 ``\\u`` 이스케이프 시퀀스로 쓸 수 있으며, 코드 포인트를 의미하는 네 "
"개의 16진수가 뒤따릅니다. ``\\U`` 이스케이프 시퀀스와 비슷하지만 네 개가 아닌 여덟 개의 숫자여야 합니다::"

#: ../Doc/howto/unicode.rst:323
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters,"
" as you would in a program with messages in French or some other accent-"
"using language.  You can also assemble strings using the :func:`chr` "
"built-in function, but this is even more tedious."
msgstr ""
"127보다 큰 코드 포인트에 대해 이스케이프 시퀀스를 사용하는 것은 양이 적을 때 괜찮지만, 프랑스어나 다른 악센트를 사용하는 "
"언어로 작성된 프로그램 메시지 같이 악센트가 있는 문자를 사용할 경우 성가십니다. :func:`chr` 내장 함수를 이용하여 "
"문자열을 조립할 수는 있지만 더 짜증납니다."

#: ../Doc/howto/unicode.rst:329
msgid ""
"Ideally, you'd want to be able to write literals in your language's "
"natural encoding.  You could then edit Python source code with your "
"favorite editor which would display the accented characters naturally, "
"and have the right characters used at runtime."
msgstr ""
"사용하는 언어의 자연스러운 인코딩으로 리터럴을 쓸 수 있어야 이상적입니다. 그래야 악센트가 있는 문자를 자연스럽게 표시하는 사용자가"
" 가장 좋아하는 편집기로 파이썬 소스 코드를 편집할 수 있고, 실행시점에 올바른 문자를 가질 수 있습니다."

#: ../Doc/howto/unicode.rst:334
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done"
" by including a special comment as either the first or second line of the"
" source file::"
msgstr ""
"파이썬은 소스 코드를 UTF-8로 작성하는 것을 기본으로 지원하지만, 원하는 인코딩을 선언한다면 거의 모든 인코딩을 쓸 수 "
"있습니다. 이는 소스 파일의 첫 번째 또는 두 번째 줄에 특별한 주석을 포함해 작동합니다::"

#: ../Doc/howto/unicode.rst:344
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local"
" to a file.  Emacs supports many different variables, but Python only "
"supports 'coding'.  The ``-*-`` symbols indicate to Emacs that the "
"comment is special; they have no significance to Python but are a "
"convention.  Python looks for ``coding: name`` or ``coding=name`` in the "
"comment."
msgstr ""
"이 문법은 파일에 지역적인 변수를 명시하는데 사용되는 이맥스 표기법에서 영감을 받았습니다. 이맥스는 수많은 서로 다른 변수를 "
"지원하지만 파이썬은 오직 'coding'\\만을 지원합니다. ``-*-`` 기호는 이맥스에게 주석이 특별함을 나타냅니다; 파이썬에게"
" 아무 의미도 없지만 그저 관례를 따르는 것뿐입니다. 파이썬은 주석에서 ``coding: name``\\이나 "
"``coding=name``\\을 찾습니다."

#: ../Doc/howto/unicode.rst:350
msgid ""
"If you don't include such a comment, the default encoding used will be "
"UTF-8 as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"이러한 주석을 포함하지 않는다면, 이미 언급한 것처럼 기본 인코딩으로 UTF-8이 사용됩니다. :pep:`263`\\에서 정보를 더"
" 보시기 바랍니다."

#: ../Doc/howto/unicode.rst:355
msgid "Unicode Properties"
msgstr "유니코드 속성"

#: ../Doc/howto/unicode.rst:357
#, fuzzy
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also "
"display-related properties, such as how to use the code point in "
"bidirectional text."
msgstr ""
"유니코드 사양은 코드 포인트에 대한 정보 데이터베이스를 포함합니다. 각각 정의한 코드 포인트에 대해서, 정보는 문자의 이름, "
"카테고리, 적용 가능한 숫자 값(유니코드는 로마 숫자와 3분의 1 및 4분의 5와 같은 분수를 표현하는 문자를 가집니다)을 "
"포함합니다. 양방향 텍스트에서 사용하는 코드 포인트와 관련된 속성과 기타 디스플레이 관련 속성도 있습니다."

#: ../Doc/howto/unicode.rst:365
msgid ""
"The following program displays some information about several characters,"
" and prints the numeric value of one particular character::"
msgstr "아래의 프로그램은 몇몇 개의 문자에 대한 정보를 표시하고 특정한 문자의 숫자 값을 출력합니다::"

#: ../Doc/howto/unicode.rst:379
msgid "When run, this prints:"
msgstr "실행했을 때 다음을 출력합니다:"

#: ../Doc/howto/unicode.rst:390
msgid ""
"The category codes are abbreviations describing the nature of the "
"character. These are grouped into categories such as \"Letter\", "
"\"Number\", \"Punctuation\", or \"Symbol\", which in turn are broken up "
"into subcategories.  To take the codes from the above output, ``'Ll'`` "
"means 'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is "
"\"Mark, nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the "
"General Category Values section of the Unicode Character Database "
"documentation "
"<http://www.unicode.org/reports/tr44/#General_Category_Values>`_ for a "
"list of category codes."
msgstr ""
"카테고리 코드는 문자의 유형을 설명하는 약어입니다. 이것들은 \"Letter\", \"Number\", "
"\"Punctuation\", 또는 \"Symbol\"과 같은 카테고리로 묶여 있고, 이는 하위 카테고리로 나누어 집니다. 위 "
"결과물에서 코드를 가져와 보면, ``'Ll'``\\는 'Letter, lowercase', ``'No'``\\는 \"Number, "
"other\", ``'Mn'``\\은 \"Mark, nonspacing\", 그리고 ``'So'``\\는 \"Symbol, "
"other\"\\를 뜻합니다. 카테고리 코드 목록에 대해서는 `유니코드 문자 데이터베이스 문서의 일반 카테고리값 섹션 "
"<http://www.unicode.org/reports/tr44/#General_Category_Values>`_\\을 보세요."

#: ../Doc/howto/unicode.rst:401
msgid "Comparing Strings"
msgstr ""

#: ../Doc/howto/unicode.rst:403
msgid ""
"Unicode adds some complication to comparing strings, because the same set"
" of characters can be represented by different sequences of code points."
"  For example, a letter like 'ê' can be represented as a single code "
"point U+00EA, or as U+0065 U+0302, which is the code point for 'e' "
"followed by a code point for 'COMBINING CIRCUMFLEX ACCENT'.  These will "
"produce the same output when printed, but one is a string of length 1 and"
" the other is of length 2."
msgstr ""

#: ../Doc/howto/unicode.rst:411
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following"
" an algorithm described by the Unicode Standard.  This algorithm has "
"special handling for characters such as the German letter 'ß' (code point"
" U+00DF), which becomes the pair of lowercase letters 'ss'."
msgstr ""

#: ../Doc/howto/unicode.rst:424
msgid ""
"A second tool is the :mod:`unicodedata` module's "
":func:`~unicodedata.normalize` function that converts strings to one of "
"several normal forms, where letters followed by a combining character are"
" replaced with single characters.  :func:`normalize` can be used to "
"perform string comparisons that won't falsely report inequality if two "
"strings use combining characters differently:"
msgstr ""

#: ../Doc/howto/unicode.rst:447
msgid "When run, this outputs:"
msgstr "실행했을 때 다음을 출력합니다:"

#: ../Doc/howto/unicode.rst:456
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""

#: ../Doc/howto/unicode.rst:460
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr ""

#: ../Doc/howto/unicode.rst:476
msgid ""
"This will print ``True``.  (Why is :func:`NFD` invoked twice?  Because "
"there are a few characters that make :meth:`casefold` return a non-"
"normalized string, so the result needs to be normalized again. See "
"section 3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""

#: ../Doc/howto/unicode.rst:483
msgid "Unicode Regular Expressions"
msgstr "유니코드 정규식"

#: ../Doc/howto/unicode.rst:485
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided"
" either as bytes or strings.  Some of the special character sequences "
"such as ``\\d`` and ``\\w`` have different meanings depending on whether "
"the pattern is supplied as bytes or a string.  For example, ``\\d`` will "
"match the characters ``[0-9]`` in bytes but in strings will match any "
"character that's in the ``'Nd'`` category."
msgstr ""
":mod:`re` 모듈이 지원하는 정규식은 바이트열 또는 문자열로 제공됩니다. ``\\d``\\와 ``\\w`` 같은 특별한 문자 "
"시퀀스 몇몇은 패턴이 바이트열 또는 문자열에 의해 지원되는지 여부에 따라 다른 의미가 있습니다. 예를 들어, 바이트열에서 "
"``\\d``\\는 ``[0-9]``\\와 일치하지만, 문자열에서는 ``'Nd'`` 카테고리에 속하는 아무 문자와 일치합니다."

#: ../Doc/howto/unicode.rst:492
msgid ""
"The string in this example has the number 57 written in both Thai and "
"Arabic numerals::"
msgstr "이 예제의 문자열은 태국과 아라비아 숫자로 쓰인 숫자 57을 갖고 있습니다::"

#: ../Doc/howto/unicode.rst:502
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out."
"  If you supply the :const:`re.ASCII` flag to :func:`~re.compile`, "
"``\\d+`` will match the substring \"57\" instead."
msgstr ""
"실행했을 때, ``\\d+``\\은 태국 숫자와 일치하고 출력합니다. :const:`re.ASCII` 플래그를 "
":func:`~re.compile`\\에 제공했을 경우, ``\\d+``\\는 부분 문자열 \"57\"을 대신 일치시킵니다."

#: ../Doc/howto/unicode.rst:506
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and "
"``\\s`` will match either Unicode whitespace characters or ``[ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"비슷하게, ``\\w``\\는 매우 다양한 유니코드와 일치하지만, 바이트열이거나 :const:`re.ASCII`\\가 제공되면 오직"
" ``[a-zA-Z0-9_]``\\과 일치하고, ``\\s``\\는 유니코드 공백 문자나 ``[ "
"\\t\\n\\r\\f\\v]``\\와 일치합니다."

#: ../Doc/howto/unicode.rst:517
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr "파이썬 유니코드 지원에 대한 몇 개의 좋은 대안 토론은 다음과 같습니다:"

#: ../Doc/howto/unicode.rst:519
msgid ""
"`Processing Text Files in Python 3 <http://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_,"
" by Nick Coghlan."
msgstr ""
"Nick Coghlan의 `파이썬 3의 텍스트 파일 처리 <http://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_."

#: ../Doc/howto/unicode.rst:520
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a "
"PyCon 2012 presentation by Ned Batchelder."
msgstr ""
"Ned Batchelder가 PyCon 2012에서 발표한 `실용 유니코드 "
"<https://nedbatchelder.com/text/unipain.html>`_."

#: ../Doc/howto/unicode.rst:522
msgid ""
"The :class:`str` type is described in the Python library reference at "
":ref:`textseq`."
msgstr ":class:`str` 타입은 파이썬 라이브러리 레퍼런스 :ref:`textseq`\\에 설명되어 있습니다."

#: ../Doc/howto/unicode.rst:525
msgid "The documentation for the :mod:`unicodedata` module."
msgstr ":mod:`unicodedata` 모듈에 대한 문서입니다."

#: ../Doc/howto/unicode.rst:527
msgid "The documentation for the :mod:`codecs` module."
msgstr ":mod:`codecs` 모듈에 대한 문서입니다."

#: ../Doc/howto/unicode.rst:529
msgid ""
"Marc-André Lemburg gave `a presentation titled \"Python and Unicode\" "
"(PDF slides) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_ at EuroPython 2002.  The slides are an excellent "
"overview of the design of Python 2's Unicode features (where the Unicode "
"string type is called ``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-André Lemburg는 EuroPython 2002에서 발표한 `\"파이썬과 유니코드\"라는 제목의 프레젠테이션 "
"(PDF 슬라이드) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_\\을 주었습니다. 이 슬라이드는 파이썬 2의 유니코드 기능(유니코드 문자열 타입을 "
"``unicode``\\라 부르고 리터럴 ``u``\\로 시작하는) 디자인에 대한 훌륭한 개요서입니다."

#: ../Doc/howto/unicode.rst:537
msgid "Reading and Writing Unicode Data"
msgstr "유니코드 데이터 읽고 쓰기"

#: ../Doc/howto/unicode.rst:539
msgid ""
"Once you've written some code that works with Unicode data, the next "
"problem is input/output.  How do you get Unicode strings into your "
"program, and how do you convert Unicode into a form suitable for storage "
"or transmission?"
msgstr ""
"유니코드 데이터로 동작하는 코드를 작성했다면, 다음은 입출력이 문제입니다. 프로그램에 유니코드 문자열을 어떻게 집어넣을 것인가, "
"그리고 유니코드를 어떻게 저장 또는 전송에 적합한 형식으로 유니코드를 전환할 것인가?"

#: ../Doc/howto/unicode.rst:543
msgid ""
"It's possible that you may not need to do anything depending on your "
"input sources and output destinations; you should check whether the "
"libraries used in your application support Unicode natively.  XML parsers"
" often return Unicode data, for example.  Many relational databases also "
"support Unicode-valued columns and can return Unicode values from an SQL "
"query."
msgstr ""
"입력 소스 및 출력 대상에 따라 아무것도 할 필요 없을 수도 있습니다; 응용 프로그램에서 사용되는 라이브러리가 유니코드를 기본 "
"지원하는지 확인해야 됩니다. 예를 들어, XML 파서는 종종 유니코드 데이터를 반환합니다. 많은 관계형 데이터베이스 역시 유니코드 "
"값 칼럼을 지원하고, SQL 질의로부터 유니코드 값을 반환받을 수 있습니다."

#: ../Doc/howto/unicode.rst:549
msgid ""
"Unicode data is usually converted to a particular encoding before it gets"
" written to disk or sent over a socket.  It's possible to do all the work"
" yourself: open a file, read an 8-bit bytes object from it, and convert "
"the bytes with ``bytes.decode(encoding)``.  However, the manual approach "
"is not recommended."
msgstr ""
"유니코드 데이터는 디스크에 쓰이거나 소켓에 전달되기 전에 보통 특정 인코딩으로 변경됩니다. 다음의 모든 작업을 직접 할 수 "
"있습니다: 파일 열기, 8-bit 바이트열 객체 읽기, 그리고 ``bytes.decode(encoding)``\\로 바이트열 "
"전환하기. 하지만 이러한 수동 접근은 권장하지 않습니다."

#: ../Doc/howto/unicode.rst:554
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character "
"can be represented by several bytes.  If you want to read the file in "
"arbitrary-sized chunks (say, 1024 or 4096 bytes), you need to write "
"error-handling code to catch the case where only part of the bytes "
"encoding a single Unicode character are read at the end of a chunk.  One "
"solution would be to read the entire file into memory and then perform "
"the decoding, but that prevents you from working with files that are "
"extremely large; if you need to read a 2 GiB file, you need 2 GiB of RAM."
" (More, really, since for at least a moment you'd need to have both the "
"encoded string and its Unicode version in memory.)"
msgstr ""
"한 가지 문제는 인코딩의 멀티 바이트 특성입니다; 하나의 유니코드 문자는 여러 바이트로 표현됩니다. 임의의 크기의 청크로 파일을 "
"읽으려면 (1024 또는 4096바이트라 할 때), 단일 유니코드 문자를 인코딩하는 바이트 일부만 청크 끝에 읽는 경우를 잡기 위해"
" 에러 처리 코드를 작성해야 합니다. 한 가지 해결책은 파일 전체를 메모리에 읽고 디코딩을 수행하는 것이지만, 극도로 큰 파일로 "
"작업하는 것을 방해합니다; 2기가바이트 파일을 읽어야만 한다면, 2기가바이트 메모리가 필요합니다. (인코딩된 문자열과 유니코드 "
"버전을 잠깐 메모리에 가지고 있어야 하므로 실제로는 더 필요합니다.)"

#: ../Doc/howto/unicode.rst:564
msgid ""
"The solution would be to use the low-level decoding interface to catch "
"the case of partial coding sequences.  The work of implementing this has "
"already been done for you: the built-in :func:`open` function can return "
"a file-like object that assumes the file's contents are in a specified "
"encoding and accepts Unicode parameters for methods such as "
":meth:`~io.TextIOBase.read` and :meth:`~io.TextIOBase.write`.  This works"
" through :func:`open`\\'s *encoding* and *errors* parameters which are "
"interpreted just like those in :meth:`str.encode` and "
":meth:`bytes.decode`."
msgstr ""
"부분 코딩 시퀀스의 경우를 잡기 위해 저수준 디코딩 인터페이스를 사용하는 것이 해결방법입니다. 이를 구현하는 작업은 이미 "
"수행되었습니다: 내장 :func:`open` 함수는 파일 내용물이 지정된 인코딩이라고 가정하고, "
":meth:`~io.TextIOBase.read` 또는 :meth:`~io.TextIOBase.write`\\와 같은 메서드에서 "
"유니코드 매개변수를 받아들이는 파일 객체를 반환할 수 있습니다. 이는 :meth:`str.encode`\\와 "
":meth:`bytes.decode`\\에서처럼 해석되는 :func:`open`\\의 *encoding*\\과 *errors* "
"매개변수를 통해 작동합니다."

#: ../Doc/howto/unicode.rst:573
msgid "Reading Unicode from a file is therefore simple::"
msgstr "그러므로 파일에서 유니코드를 읽는 것은 간단합니다::"

#: ../Doc/howto/unicode.rst:579
msgid ""
"It's also possible to open files in update mode, allowing both reading "
"and writing::"
msgstr "업데이트 모드로 파일을 열어 읽기 또는 쓰기를 할 수도 있습니다::"

#: ../Doc/howto/unicode.rst:587
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and "
"is often written as the first character of a file in order to assist with"
" autodetection of the file's byte ordering.  Some encodings, such as "
"UTF-16, expect a BOM to be present at the start of a file; when such an "
"encoding is used, the BOM will be automatically written as the first "
"character and will be silently dropped when the file is read.  There are "
"variants of these encodings, such as 'utf-16-le' and 'utf-16-be' for "
"little-endian and big-endian encodings, that specify one particular byte "
"ordering and don't skip the BOM."
msgstr ""
"유니코드 문자 ``U+FEFF``\\는 바이트 순서 표시(BOM)로 사용되고, 파일의 바이트 순서를 자동감지하기 위해 파일의 맨 "
"처음 문자로 쓰이기도 합니다. UTF-16과 같은 일부 인코딩에서는 파일 시작 부분에 BOM이 있어야합니다; 이러한 인코딩이 쓰일 "
"때, BOM이 자동으로 첫번째 문자로 작성되고 파일을 읽을 때 조용히 없어집니다. 리틀 엔디안과 빅 엔디안을 위해 특정 바이트 "
"순서를 지정하고 BOM을 생략하지 않는 'utf-16-le'와 'utf-16-be' 같은 인코딩의 변종들이 있습니다."

#: ../Doc/howto/unicode.rst:596
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of "
"UTF-8 encoded files; the name is misleading since UTF-8 is not byte-order"
" dependent. The mark simply announces that the file is encoded in UTF-8."
"  For reading such files, use the 'utf-8-sig' codec to automatically skip"
" the mark if present."
msgstr ""
"일부 영역에서는 UTF-8로 인코딩된 파일의 시작 부분에 \"BOM\"을 사용하는 것이 관례이기도 합니다; UTF-8은 바이트 "
"순서에 의존하지 않으므로 이 이름은 오해의 소지가 있습니다. 이 표시는 이 파일이 UTF-8로 인코딩했음을 단순히 알립니다. 그런 "
"파일을 읽으려면 자동으로 이 표시를 건너뛰기 위해 'utf-8-sig' 코덱을 사용하세요."

#: ../Doc/howto/unicode.rst:603
msgid "Unicode filenames"
msgstr "유니코드 파일 이름"

#: ../Doc/howto/unicode.rst:605
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on"
" the system.  Today Python is converging on using UTF-8: Python on MacOS "
"has used UTF-8 for several versions, and Python 3.6 switched to using "
"UTF-8 on Windows as well.  On Unix systems, there will only be a "
"filesystem encoding if you've set the ``LANG`` or ``LC_CTYPE`` "
"environment variables; if you haven't, the default encoding is again "
"UTF-8."
msgstr ""

#: ../Doc/howto/unicode.rst:615
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to "
"use on your current system, in case you want to do the encoding manually,"
" but there's not much reason to bother.  When opening a file for reading "
"or writing, you can usually just provide the Unicode string as the "
"filename, and it will be automatically converted to the right encoding "
"for you::"
msgstr ""
"인코딩을 수동으로 하고 싶을 때를 대비하여 :func:`sys.getfilesystemencoding` 함수는 현재 사용하고 있는 "
"시스템의 인코딩을 반환하지만, 귀찮게 그럴 이유는 없습니다. 읽기 또는 쓰기를 위해 파일을 열 때, 보통 파일 이름으로 유니코드 "
"문자열을 제공하기만 하면 되고, 자동으로 올바른 인코딩으로 변환됩니다::"

#: ../Doc/howto/unicode.rst:625
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also "
"accept Unicode filenames."
msgstr ":mod:`os` 모듈 안의 :func:`os.stat`\\과 같은 함수 역시 유니코드 파일 이름을 수용합니다."

#: ../Doc/howto/unicode.rst:628
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue:"
" should it return the Unicode version of filenames, or should it return "
"bytes containing the encoded versions?  :func:`os.listdir` can do both, "
"depending on whether you provided the directory path as bytes or a "
"Unicode string.  If you pass a Unicode string as the path, filenames will"
" be decoded using the filesystem's encoding and a list of Unicode strings"
" will be returned, while passing a byte path will return the filenames as"
" bytes.  For example, assuming the default filesystem encoding is UTF-8, "
"running the following program::"
msgstr ""

#: ../Doc/howto/unicode.rst:646
msgid "will produce the following output:"
msgstr "아래의 출력을 만들 것입니다:"

#: ../Doc/howto/unicode.rst:654
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr "첫번째 리스트는 UTF-8로 인코딩된 파일 이름을 갖고, 두 번째 리스트는 유니코드 버전을 갖습니다."

#: ../Doc/howto/unicode.rst:657
msgid ""
"Note that on most occasions, you should can just stick with using Unicode"
" with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix "
"systems now."
msgstr ""

#: ../Doc/howto/unicode.rst:664
msgid "Tips for Writing Unicode-aware Programs"
msgstr "유니코드 인식 프로그램 작성 팁"

#: ../Doc/howto/unicode.rst:666
msgid ""
"This section provides some suggestions on writing software that deals "
"with Unicode."
msgstr "이 섹션은 유니코드를 다루는 소프트웨어를 작성할 때의 몇 가지 제안을 제공합니다."

#: ../Doc/howto/unicode.rst:669
msgid "The most important tip is:"
msgstr "가장 중요한 팁은:"

#: ../Doc/howto/unicode.rst:671
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"소프트웨어는 가능한 한 빨리 입력 데이터를 디코딩하고 마지막에만 출력을 인코딩하여 내부적으로는 유니코드 문자열에서만 작동하는 것이 "
"좋습니다."

#: ../Doc/howto/unicode.rst:674
msgid ""
"If you attempt to write processing functions that accept both Unicode and"
" byte strings, you will find your program vulnerable to bugs wherever you"
" combine the two different kinds of strings.  There is no automatic "
"encoding or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` "
"will be raised."
msgstr ""
"유니코드와 바이트 문자열을 수용하는 처리 함수를 작성하려고 시도한다면, 두 가지 다른 종류의 문자열을 결합할 때마다 프로그램이 "
"버그에 취약하다는 것을 알 수 있습니다. 자동 인코딩이나 디코딩은 없습니다: ``str + bytes``\\을 수행한다면 "
":exc:`TypeError`\\가 발생합니다."

#: ../Doc/howto/unicode.rst:679
msgid ""
"When using data coming from a web browser or some other untrusted source,"
" a common technique is to check for illegal characters in a string before"
" using the string in a generated command line or storing it in a "
"database.  If you're doing this, be careful to check the decoded string, "
"not the encoded bytes data; some encodings may have interesting "
"properties, such as not being bijective or not being fully ASCII-"
"compatible.  This is especially true if the input data also specifies the"
" encoding, since the attacker can then choose a clever way to hide "
"malicious text in the encoded bytestream."
msgstr ""
"웹 브라우저나 다른 신뢰할 수 없는 소스로부터 온 데이터를 사용할 때, 일반적인 기법은 생성된 명령행에서 문자열을 사용하거나 "
"데이터베이스에 저장하기 전에 문자열에서 잘못된 문자를 검사하는 것입니다. 이렇게 하고 있다면, 인코딩된 바이트열 데이터가 아닌 "
"디코딩 된 문자열을 검사하도록 조심하기 바랍니다; 어떤 인코딩은 일대일 대응되지 않거나 ASCII와 완전히 호환되지 않는 흥미로운 "
"속성을 가지고 있습니다. 입력 데이터가 인코딩을 지정하는 경우 특히 그러한데, 공격자가 인코딩한 바이트 스트림 안에 악의적인 "
"텍스트를 숨기는 방법을 택할 수 있기 때문입니다."

#: ../Doc/howto/unicode.rst:690
msgid "Converting Between File Encodings"
msgstr "파일 인코딩끼리 변환"

#: ../Doc/howto/unicode.rst:692
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert "
"between encodings, taking a stream that returns data in encoding #1 and "
"behaving like a stream returning data in encoding #2."
msgstr ""
":class:`~codecs.StreamRecoder` 클래스는 인코딩 #1으로 데이터를 반환하는 스트림을 받아서 인코딩 #2로 "
"데이터를 반환하는 스트림처럼 동작하여 인코딩 간에 투명하게 변환할 수 있습니다."

#: ../Doc/howto/unicode.rst:696
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can "
"wrap it with a :class:`~codecs.StreamRecoder` to return bytes encoded in "
"UTF-8::"
msgstr ""
"예를 들어, Latin-1을 사용하는 *f* 입력 파일을 가지고 있다면, 이를 UTF-8로 인코딩한 바이트열을 반환하기 위해 "
":class:`~codecs.StreamRecoder`\\로 감쌀 수 있습니다::"

#: ../Doc/howto/unicode.rst:710
msgid "Files in an Unknown Encoding"
msgstr "알 수 없는 인코딩의 파일"

#: ../Doc/howto/unicode.rst:712
msgid ""
"What can you do if you need to make a change to a file, but don't know "
"the file's encoding?  If you know the encoding is ASCII-compatible and "
"only want to examine or modify the ASCII parts, you can open the file "
"with the ``surrogateescape`` error handler::"
msgstr ""
"파일을 변경해야 하지만 파일의 인코딩을 모를 때 할 수 있는 일은 무엇일까요? 인코딩이 ASCII 호환이라는 것을 알고 있고 "
"ASCII 일부분을 검토 또는 수정만 하고자 한다면, ``surrogateescape`` 에러 핸들러와 함께 파일을 열 수 "
"있습니다::"

#: ../Doc/howto/unicode.rst:726
#, fuzzy
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code"
" points will then turn back into the same bytes when the "
"``surrogateescape`` error handler is used to encode the data and write it"
" back out."
msgstr ""
"U+DC80부터 U+DCFF까지의 범위를 가지는 유니코드 개인 사용 영역에서 ``surrogateescape`` 에러 핸들러는 비 "
"ASCII 바이트들을 코드 포인트로써 디코딩합니다. 이러한 개인 코드 포인트는 ``surrogateescape`` 에러 핸들러가 "
"데이터를 인코딩하고 다시 쓰는 경우에 사용될 때 같은 바이트열로 다시 되돌려집니다."

#: ../Doc/howto/unicode.rst:736
msgid ""
"One section of `Mastering Python 3 Input/Output "
"<http://pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o>`_, a "
"PyCon 2010 talk by David Beazley, discusses text processing and binary "
"data handling."
msgstr ""
"David Beazley가 PyCon 2010에서 발표한 `파이썬3 입출력 마스터하기 "
"<http://pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o>`_\\의 한 "
"섹션은 텍스트 처리와 바이너리 데이터 처리에 대해 논의합니다."

#: ../Doc/howto/unicode.rst:740
msgid ""
"The `PDF slides for Marc-André Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" "
"<https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-"
"applications-in-Python.pdf>`_ discuss questions of character encodings as"
" well as how to internationalize and localize an application.  These "
"slides cover Python 2.x only."
msgstr ""
"`Marc-André Lemburg의 프레젠테이션 PDF 슬라이드 \"파이썬에서 유니코드 인식 프로그램 작성\" "
"<https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-"
"applications-in-Python.pdf>`_\\은 문자 인코딩에 관한 질문은 물론 응용 프로그램을 국제화하고 지역화하는 "
"방법에 관해 설명합니다. 이 슬라이드는 파이썬 2.x만을 다룹니다."

#: ../Doc/howto/unicode.rst:746
msgid ""
"`The Guts of Unicode in Python <http://pyvideo.org/video/1768/the-guts-"
"of-unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"PyCon 2013에서 Benjamin Peterson이 발표한 `파이썬에서 유니코드의 내부 "
"<http://pyvideo.org/video/1768/the-guts-of-unicode-in-python>`_\\은 파이썬 "
"3.3에서 내부 유니코드 표현에 대해 논의합니다."

#: ../Doc/howto/unicode.rst:753
msgid "Acknowledgements"
msgstr "감사 인사"

#: ../Doc/howto/unicode.rst:755
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has"
" since been revised further by Alexander Belopolsky, Georg Brandl, Andrew"
" Kuchling, and Ezio Melotti."
msgstr ""
"이 문서의 초안은 Andrew Kuchling이 썼습니다. 이후 Alexander Belopolsky, Georg Brandl, "
"Andrew Kuchling, 그리고 Ezio Melotti에 의해 개정되었습니다."

#: ../Doc/howto/unicode.rst:759
msgid ""
"Thanks to the following people who have noted errors or offered "
"suggestions on this article: Éric Araujo, Nicholas Bastin, Nick Coghlan, "
"Marius Gedminas, Kent Johnson, Ken Krugler, Marc-André Lemburg, Martin "
"von Löwis, Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, "
"Graham Wideman."
msgstr ""

#~ msgid "History of Character Codes"
#~ msgstr "문자 코드의 역사"

#~ msgid ""
#~ "In 1968, the American Standard Code "
#~ "for Information Interchange, better known "
#~ "by its acronym ASCII, was standardized."
#~ "  ASCII defined numeric codes for "
#~ "various characters, with the numeric "
#~ "values running from 0 to 127.  For"
#~ " example, the lowercase letter 'a' is"
#~ " assigned 97 as its code value."
#~ msgstr ""
#~ "ASCII로 더 잘 알려진 미국정보교환표준부호(American "
#~ "Standard Code for Information Interchange)는"
#~ " 1968년에 표준화되었습니다. ASCII는 다양한 문자의 숫자"
#~ " 코드를 0에서 127까지의 숫자 값으로 정의합니다. "
#~ "예를 들어, 소문자 'a'는 97에 할당되어 있습니다."

#~ msgid ""
#~ "ASCII was an American-developed "
#~ "standard, so it only defined unaccented"
#~ " characters.  There was an 'e', but"
#~ " no 'é' or 'Í'.  This meant "
#~ "that languages which required accented "
#~ "characters couldn't be faithfully represented"
#~ " in ASCII. (Actually the missing "
#~ "accents matter for English, too, which"
#~ " contains words such as 'naïve' and"
#~ " 'café', and some publications have "
#~ "house styles which require spellings "
#~ "such as 'coöperate'.)"
#~ msgstr ""
#~ "ASCII는 미국에서 개발한 표준이므로 악센트가 없는 문자만"
#~ " 정의되어 있습니다. 'e'는 있었지만 'é' 또는 "
#~ "'Í'가 없었습니다. 즉, 악센트가 있는 문자는 ASCII로"
#~ " 충실하게 표현할 수 없음을 뜻합니다. (사실 누락된"
#~ " 악센트는 'naïve'와 'café'와 같은 단어를 포함하는"
#~ " 영어에서도 역시 중요하며, 하우스 스타일을 갖는 일부"
#~ " 출판물은 'coöperate'와 같은 철자를 포함합니다.)"

#~ msgid ""
#~ "For a while people just wrote "
#~ "programs that didn't display accents. In"
#~ " the mid-1980s an Apple II "
#~ "BASIC program written by a French "
#~ "speaker might have lines like these:"
#~ msgstr ""
#~ "사람들은 한동안 악센트를 표시하지 않는 프로그램을 "
#~ "작성했습니다. 1980년대 중반, 프랑스어를 사용하는 사람이 "
#~ "작성한 애플 2 베이식 프로그램은 다음과 같은 행을"
#~ " 가질 수 있습니다:"

#~ msgid ""
#~ "Those messages should contain accents "
#~ "(terminée, paramètre, enregistrés) and they"
#~ " just look wrong to someone who "
#~ "can read French."
#~ msgstr ""
#~ "이 메시지들은 악센트(terminée, paramètre, enregistrés)를"
#~ " 가지고 있어야 하므로 프랑스어를 읽는 사람들에게는 "
#~ "잘못되어 보입니다."

#~ msgid ""
#~ "In the 1980s, almost all personal "
#~ "computers were 8-bit, meaning that bytes"
#~ " could hold values ranging from 0 "
#~ "to 255.  ASCII codes only went up"
#~ " to 127, so some machines assigned"
#~ " values between 128 and 255 to "
#~ "accented characters.  Different machines had"
#~ " different codes, however, which led "
#~ "to problems exchanging files. Eventually "
#~ "various commonly used sets of values "
#~ "for the 128--255 range emerged. "
#~ "Some were true standards, defined by "
#~ "the International Organization for "
#~ "Standardization, and some were *de "
#~ "facto* conventions that were invented by"
#~ " one company or another and managed"
#~ " to catch on."
#~ msgstr ""
#~ "1980년대, 대부분의 개인용 컴퓨터는 8bit였고, 이는 "
#~ "바이트가 0부터 255까지의 범위를 가질 수 있음을 "
#~ "뜻합니다. ASCII 코드는 127까지 제한되어 있어 일부"
#~ " 기계는 128부터 255 사이의 값을 악센트를 갖는"
#~ " 문자에 할당했습니다. 하지만 서로 다른 기기들은 서로"
#~ " 다른 코드를 가지고 있었고, 이는 파일 교환에 "
#~ "문제를 일으켰습니다. 결국 128--255 범위에 대해 "
#~ "일반적으로 자주 쓰이는 다양한 값 집합들이 생겼습니다. "
#~ "일부는 국제 표준화 기구(ISO - International "
#~ "Organization for Standardization)에서 정의한 진정한"
#~ " 표준이었고, 일부는 한 회사나 또다른 회사에서 고안하여"
#~ " 널리 받아들여지도록 관리된  *사실상의* 관례였습니다."

#~ msgid ""
#~ "255 characters aren't very many.  For"
#~ " example, you can't fit both the "
#~ "accented characters used in Western "
#~ "Europe and the Cyrillic alphabet used"
#~ " for Russian into the 128--255 "
#~ "range because there are more than "
#~ "128 such characters."
#~ msgstr ""
#~ "255개의 문자는 많지 않습니다. 예를 들어, 서유럽에서"
#~ " 사용하는 악센트가 있는 문자와 러시아에서 쓰는 키릴"
#~ " 문자를 합하면 128개보다 많기 때문에 128--255"
#~ " 범위에 맞출 수 없습니다."

#~ msgid ""
#~ "You could write files using different"
#~ " codes (all your Russian files in "
#~ "a coding system called KOI8, all "
#~ "your French files in a different "
#~ "coding system called Latin1), but what"
#~ " if you wanted to write a "
#~ "French document that quotes some Russian"
#~ " text?  In the 1980s people began "
#~ "to want to solve this problem, and"
#~ " the Unicode standardization effort began."
#~ msgstr ""
#~ "다른 코드를 이용해 파일을 작성할 수 있지만(KOI8 "
#~ "코딩 시스템의 모든 러시아어 파일, Latin1 코딩 "
#~ "시스템의 모든 프랑스어 파일처럼), 어떤 러시아어 텍스트를"
#~ " 인용하는 프랑스어 문서를 쓰고 싶다면 어떻게 해야"
#~ " 할까요? 1980년대 사람들은 이 문제를 해결하고 싶어"
#~ " 했고, 유니코드 표준화 노력이 시작되었습니다."

#~ msgid ""
#~ "Unicode started out using 16-bit "
#~ "characters instead of 8-bit characters.  "
#~ "16 bits means you have 2^16 = "
#~ "65,536 distinct values available, making "
#~ "it possible to represent many different"
#~ " characters from many different alphabets;"
#~ " an initial goal was to have "
#~ "Unicode contain the alphabets for every"
#~ " single human language. It turns out"
#~ " that even 16 bits isn't enough "
#~ "to meet that goal, and the modern"
#~ " Unicode specification uses a wider "
#~ "range of codes, 0 through 1,114,111 "
#~ "( ``0x10FFFF`` in base 16)."
#~ msgstr ""
#~ "유니코드는 8-bit 문자 대신 16-bit 문자를 쓰며"
#~ " 시작했습니다. 16bit는 2^16 = 65,536개의 구별되는"
#~ " 값을 가질 수 있음을 뜻하므로, 많고 다른 "
#~ "알파벳으로부터 많고 다른 문자를 나타낼 수 있습니다; "
#~ "최초의 목적은 유니코드가 모든 인류 언어 각자의 "
#~ "알파벳을 포함 할 수 있는데 있었습니다. 이는 "
#~ "16bit로도 목적을 달성하기 어렵다는게 드러났고, 현대 "
#~ "유니코드 사양은 더 넓은 0부터 1,114,111(16진수의 "
#~ "``0x10FFFF``)까지의 범위를 사용합니다."

#~ msgid ""
#~ "There's a related ISO standard, ISO "
#~ "10646.  Unicode and ISO 10646 were "
#~ "originally separate efforts, but the "
#~ "specifications were merged with the 1.1"
#~ " revision of Unicode."
#~ msgstr ""
#~ "관련 ISO 표준으로 ISO 10646이 있습니다. 유니코드와"
#~ " ISO 10646은 각자 별도의 노력을 들였지만, "
#~ "유니코드 1.1 개정안으로 합쳐졌습니다."

#~ msgid ""
#~ "(This discussion of Unicode's history is"
#~ " highly simplified.  The precise historical"
#~ " details aren't necessary for understanding"
#~ " how to use Unicode effectively, but"
#~ " if you're curious, consult the "
#~ "Unicode consortium site listed in the"
#~ " References or the `Wikipedia entry "
#~ "for Unicode "
#~ "<https://en.wikipedia.org/wiki/Unicode#History>`_ for more"
#~ " information.)"
#~ msgstr ""
#~ "(여기서 서술하는 유니코드의 역사는 매우 간략화되었습니다. "
#~ "유니코드를 효과적으로 사용하는 방법을 이해하기 위해서는 정확한"
#~ " 역사적인 세부사항이 필요하지 않지만, 궁금하다면 참조에 "
#~ "나열한 유니코드 컨소시엄 사이트나 `위키피디아 유니코드 항목"
#~ " <https://en.wikipedia.org/wiki/Unicode#History>`_\\을 참고하세요.)"

#~ msgid ""
#~ "A **character** is the smallest possible"
#~ " component of a text.  'A', 'B', "
#~ "'C', etc., are all different characters."
#~ "  So are 'È' and 'Í'.  Characters "
#~ "are abstractions, and vary depending on"
#~ " the language or context you're "
#~ "talking about.  For example, the symbol"
#~ " for ohms (Ω) is usually drawn "
#~ "much like the capital letter omega "
#~ "(Ω) in the Greek alphabet (they "
#~ "may even be the same in some "
#~ "fonts), but these are two different "
#~ "characters that have different meanings."
#~ msgstr ""
#~ "**문자**\\는 텍스트의 가능한 최소 구성요소입니다. 'A', "
#~ "'B', 'C' 등은 전부 다른 문자입니다. 'È'\\와"
#~ " 'Í' 역시 그렇습니다. 문자는 추상적 개념이며 언어나"
#~ " 문맥에 따라 다릅니다. 예를 들어, 옴(Ω) 기호는"
#~ " 대개 그리스 문자의 대문자 오메가(Ω)와 비슷하지만(심지어 "
#~ "어떤 글꼴에서는 둘이 같습니다), 둘은 서로 다른 "
#~ "문자이며 뜻도 다릅니다."

#~ msgid ""
#~ "The Unicode standard describes how "
#~ "characters are represented by **code "
#~ "points**.  A code point is an "
#~ "integer value, usually denoted in base"
#~ " 16.  In the standard, a code "
#~ "point is written using the notation "
#~ "``U+12CA`` to mean the character with"
#~ " value ``0x12ca`` (4,810 decimal).  The "
#~ "Unicode standard contains a lot of "
#~ "tables listing characters and their "
#~ "corresponding code points:"
#~ msgstr ""
#~ "유니코드 표준은 문자를 어떻게 **코드 포인트**\\로 "
#~ "표현하는지 서술하고 있습니다. 코드 포인트는 보통 "
#~ "베이스16으로 표시된 정숫값입니다. 표준에서 코드 포인트는 "
#~ "``U+12CA`` 표기로 쓰였으며 ``0x12ca`` (십진수 "
#~ "4,810)값의  문자를 의미합니다. 유니코드 표준은 문자와 "
#~ "그에 상응하는 코드 포인트를 나열한 수많은 표를 "
#~ "포함하고 있습니다:"

#~ msgid ""
#~ "Many Internet standards are defined in"
#~ " terms of textual data, and can't "
#~ "handle content with embedded zero bytes."
#~ msgstr "많은 인터넷 표준은 텍스트 데이터로 정의되었고, 0 바이트가 포함된 내용을 처리할 수 없습니다."

#~ msgid ""
#~ "Generally people don't use this "
#~ "encoding, instead choosing other encodings "
#~ "that are more efficient and convenient."
#~ "  UTF-8 is probably the most commonly"
#~ " supported encoding; it will be "
#~ "discussed below."
#~ msgstr ""
#~ "일반적으로 사람들은 이 인코딩을 사용하지 않고 보다 "
#~ "효율적이고 편리한 다른 인코딩을 선택합니다. 아마도 "
#~ "UTF-8이 가장 보편적으로 지원되는 인코딩일 것입니다; 이는"
#~ " 아래에서 논의 합니다."

#~ msgid ""
#~ "Encodings don't have to handle every "
#~ "possible Unicode character, and most "
#~ "encodings don't.  The rules for "
#~ "converting a Unicode string into the "
#~ "ASCII encoding, for example, are simple;"
#~ " for each code point:"
#~ msgstr ""
#~ "인코딩은 사용 가능한 모든 유니코드 문자열을 처리할 "
#~ "필요는 없고, 대부분의 인코딩 역시 그렇지 않습니다. "
#~ "예를 들어 유니코드 문자열을 ASCII 인코딩으로 변환하는"
#~ " 규칙은 간단합니다; 각 코드 포인트에 대해:"

#~ msgid ""
#~ "If the code point is < 128, "
#~ "each byte is the same as the "
#~ "value of the code point."
#~ msgstr "만약 코드 포인트가 128보다 작다면, 각 바이트는 코드 포인트 값과 같습니다."

#~ msgid ""
#~ "If the code point is 128 or "
#~ "greater, the Unicode string can't be "
#~ "represented in this encoding.  (Python "
#~ "raises a :exc:`UnicodeEncodeError` exception "
#~ "in this case.)"
#~ msgstr ""
#~ "만약 코드 포인트가 128이거나 더 크다면, 이 "
#~ "인코딩으로 유니코드 문자열을 표현할 수 없습니다. (이런"
#~ " 경우 파이썬은 :exc:`UnicodeEncodeError` 예외를 "
#~ "일으킵니다.)"

#~ msgid ""
#~ "Latin-1, also known as ISO-8859-1, is"
#~ " a similar encoding.  Unicode code "
#~ "points 0--255 are identical to the"
#~ " Latin-1 values, so converting to "
#~ "this encoding simply requires converting "
#~ "code points to byte values; if a"
#~ " code point larger than 255 is "
#~ "encountered, the string can't be encoded"
#~ " into Latin-1."
#~ msgstr ""
#~ "ISO-8859-1로도 알려진 Latin-1이 비슷한 인코딩입니다. "
#~ "유니코드 코드 포인트 0--255는 Latin-1과 같으므로"
#~ " 코드 포인트를 바이트 값으로 바꾸는 간단한 일만 "
#~ "필요합니다. 문자열이 255보다 큰 코드 포인트를 마주한다면"
#~ " Latin-1로 인코딩할 수 없습니다."

#~ msgid ""
#~ "Encodings don't have to be simple "
#~ "one-to-one mappings like Latin-1.  "
#~ "Consider IBM's EBCDIC, which was used"
#~ " on IBM mainframes.  Letter values "
#~ "weren't in one block: 'a' through "
#~ "'i' had values from 129 to 137,"
#~ " but 'j' through 'r' were 145 "
#~ "through 153.  If you wanted to use"
#~ " EBCDIC as an encoding, you'd "
#~ "probably use some sort of lookup "
#~ "table to perform the conversion, but "
#~ "this is largely an internal detail."
#~ msgstr ""
#~ "인코딩은 Latin-1처럼 단순 일대일 대응이지 않아도 "
#~ "됩니다. IBM 메인 프레임에서 사용된 IBM의 EBCDIC를"
#~ " 생각해보세요. 글자값들이 하나의 블록에 있지 않습니다: "
#~ "'a'부터 'i'까지는 129부터 137의 값을 갖지만, "
#~ "'j'부터 'r'까지는 145부터 153입니다. EBCDIC를 인코딩으로"
#~ " 사용하고자 할 때, 변환을 수행하기 위해 일종의 "
#~ "조회 테이블을 사용하겠지만, 이는 주로 내부적인 세부사항일"
#~ " 뿐입니다."

#~ msgid ""
#~ "You can use a different encoding "
#~ "from UTF-8 by putting a specially-"
#~ "formatted comment as the first or "
#~ "second line of the source code::"
#~ msgstr "특별한 형식의 주석을 소스 코드의 첫 번째나 두 번째 줄에 넣어서 UTF-8이 아닌 인코딩을 사용할 수 있습니다::"

#~ msgid ""
#~ "Most of the operating systems in "
#~ "common use today support filenames that"
#~ " contain arbitrary Unicode characters.  "
#~ "Usually this is implemented by "
#~ "converting the Unicode string into some"
#~ " encoding that varies depending on "
#~ "the system.  For example, Mac OS X"
#~ " uses UTF-8 while Windows uses a "
#~ "configurable encoding; on Windows, Python "
#~ "uses the name \"mbcs\" to refer to"
#~ " whatever the currently configured encoding"
#~ " is.  On Unix systems, there will "
#~ "only be a filesystem encoding if "
#~ "you've set the ``LANG`` or ``LC_CTYPE``"
#~ " environment variables; if you haven't, "
#~ "the default encoding is UTF-8."
#~ msgstr ""
#~ "오늘날 자주 쓰이는 대부분의 운영체제는 임의의 유니코드 "
#~ "문자를 갖는 파일 이름을 지원합니다. 이는 보통 "
#~ "유니코드 문자열을 시스템에 의존적인 인코딩으로 변환하여 "
#~ "구현합니다. 예를 들어, 윈도우가 설정 가능한 인코딩을 "
#~ "사용하는 반면, 맥 OS X는 UTF-8을 사용합니다; "
#~ "윈도우에서 파이썬은 현재 설정된 인코딩이 무엇이든간에 참조하기"
#~ " 위해 \"mbcs\"라는 이름을 사용합니다. 유닉스 시스템에서"
#~ " ``LANG`` 또는 ``LC_CTYPE`` 환경변수를 설정했다면, "
#~ "파일 시스템 인코딩만을 사용합니다; 그렇지 않은 경우, "
#~ "기본 인코딩은 UTF-8입니다."

#~ msgid ""
#~ "The :func:`os.listdir` function returns "
#~ "filenames and raises an issue: should"
#~ " it return the Unicode version of "
#~ "filenames, or should it return bytes "
#~ "containing the encoded versions?  "
#~ ":func:`os.listdir` will do both, depending "
#~ "on whether you provided the directory"
#~ " path as bytes or a Unicode "
#~ "string.  If you pass a Unicode "
#~ "string as the path, filenames will "
#~ "be decoded using the filesystem's "
#~ "encoding and a list of Unicode "
#~ "strings will be returned, while passing"
#~ " a byte path will return the "
#~ "filenames as bytes.  For example, "
#~ "assuming the default filesystem encoding "
#~ "is UTF-8, running the following "
#~ "program::"
#~ msgstr ""
#~ ":func:`os.listdir` 함수는 파일 이름을 반환하고 이슈를"
#~ " 일으킵니다: 이 함수가 파일 이름의 유니코드 버전을"
#~ " 반환해야 할까요? 아니면 인코딩 버전을 포함한 "
#~ "바이트열을 반환해야 할까요? :func:`os.listdir`\\는 디렉터리 "
#~ "경로를 바이트열이나 유니코드 문자열로 제공했는지에 따라 둘"
#~ " 모두를 수행합니다. 경로를 유니코드 문자열로 넘겨주었을 "
#~ "때 파일 이름은 파일시스템의 인코딩으로 디코딩 되고 "
#~ "유니코드 문자열의 목록이 반환되는 반면, 바이트를 넘겨주었을"
#~ " 때 파일 이름을 바이트열로 반환합니다. 예를 들어,"
#~ " 기본 파일시스템 인코딩이 UTF-8이라 가정할 때, "
#~ "다음의 프로그램을 실행 시::"

#~ msgid ""
#~ "Note that on most occasions, the "
#~ "Unicode APIs should be used.  The "
#~ "bytes APIs should only be used on"
#~ " systems where undecodable file names "
#~ "can be present, i.e. Unix systems."
#~ msgstr ""
#~ "대부분의 경우를 생각했을 때 유니코드 API를 사용하는 "
#~ "것이 좋습니다. 바이트열 API는 디코딩 할 수 "
#~ "없는 파일 이름이 존재하는 시스템, 즉, 유닉스 "
#~ "시스템에서만 사용하는 것이 좋습니다."

#~ msgid ""
#~ "Thanks to the following people who "
#~ "have noted errors or offered suggestions"
#~ " on this article: Éric Araujo, "
#~ "Nicholas Bastin, Nick Coghlan, Marius "
#~ "Gedminas, Kent Johnson, Ken Krugler, "
#~ "Marc-André Lemburg, Martin von Löwis, "
#~ "Terry J. Reedy, Chad Whitacre."
#~ msgstr ""
#~ "이 문서에 오류를 알려주거나 제안을 해주신 아래의 "
#~ "사람들에게 감사를 전합니다: Éric Araujo, Nicholas"
#~ " Bastin, Nick Coghlan, Marius Gedminas, "
#~ "Kent Johnson, Ken Krugler, Marc-André"
#~ " Lemburg, Martin von Löwis, Terry J."
#~ " Reedy, Chad Whitacre."

#~ msgid ""
#~ "On the Computerphile Youtube channel, "
#~ "Tom Scott briefly `discusses the history"
#~ " of Unicode and UTF-8 "
#~ "<https://www.youtube.com/watch?v=MijmeoH9LT4>` (9 minutes"
#~ " 36 seconds)."
#~ msgstr ""

