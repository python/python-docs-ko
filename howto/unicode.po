# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: 2018-12-02 15:37+0900\n"
"Last-Translator: Spike H.Y. Lee <rurouni24@gmail.com>\n"
"Language: ko_KR\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../howto/unicode.rst:5
msgid "Unicode HOWTO"
msgstr "ìœ ë‹ˆì½”ë“œ HOWTO"

#: ../../howto/unicode.rst
msgid "Release"
msgstr "ë²„ì „"

#: ../../howto/unicode.rst:7
msgid "1.12"
msgstr "1.12"

#: ../../howto/unicode.rst:9
msgid ""
"This HOWTO discusses Python's support for the Unicode specification for "
"representing textual data, and explains various problems that people "
"commonly encounter when trying to work with Unicode."
msgstr ""
"ì´ HOWTOëŠ” í…ìŠ¤íŠ¸ ë°ì´í„°ë¥¼ ë‚˜íƒ€ë‚´ê¸° ìœ„í•œ ìœ ë‹ˆì½”ë“œ ëª…ì„¸ë¥¼ ì§€ì›í•˜ëŠ” íŒŒì´ì¬ì— ëŒ€í•œ ì„¤ëª…ê³¼ ìœ ë‹ˆì½”ë“œë¡œ ì‘ì—…í•  ë•Œ ì¼ë°˜ì ìœ¼ë¡œ "
"ë§ˆì£¼í•˜ëŠ” ë‹¤ì–‘í•œ ë¬¸ì œë“¤ì— ê´€í•´ ì„¤ëª…í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:15
msgid "Introduction to Unicode"
msgstr "ìœ ë‹ˆì½”ë“œ ì†Œê°œ"

#: ../../howto/unicode.rst:18
msgid "Definitions"
msgstr "ì •ì˜"

#: ../../howto/unicode.rst:20
msgid ""
"Today's programs need to be able to handle a wide variety of characters."
"  Applications are often internationalized to display messages and output"
" in a variety of user-selectable languages; the same program might need "
"to output an error message in English, French, Japanese, Hebrew, or "
"Russian.  Web content can be written in any of these languages and can "
"also include a variety of emoji symbols. Python's string type uses the "
"Unicode Standard for representing characters, which lets Python programs "
"work with all these different possible characters."
msgstr ""
"ì˜¤ëŠ˜ë‚ ì˜ í”„ë¡œê·¸ë¨ì€ ë‹¤ì–‘í•œ ë¬¸ìë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆì–´ì•¼ í•©ë‹ˆë‹¤. ì‘ìš© í”„ë¡œê·¸ë¨ì€ ì¢…ì¢… êµ­ì œí™”ë˜ì–´ ë‹¤ì–‘í•œ ì‚¬ìš©ì ì„ íƒ ê°€ëŠ¥í•œ ì–¸ì–´ë¡œ "
"ë©”ì‹œì§€ë¥¼ í‘œì‹œí•˜ê³  ì¶œë ¥í•©ë‹ˆë‹¤; ê°™ì€ í”„ë¡œê·¸ë¨ì´ ì˜ì–´, í”„ë‘ìŠ¤ì–´, ì¼ë³¸ì–´, íˆë¸Œë¦¬ì–´ ë˜ëŠ” ëŸ¬ì‹œì•„ì–´ë¡œ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ ì¶œë ¥í•´ì•¼ í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì›¹ ì½˜í…ì¸ ëŠ” ì´ëŸ¬í•œ ì–¸ì–´ë¡œ ì‘ì„±ë  ìˆ˜ ìˆìœ¼ë©° ë‹¤ì–‘í•œ ì´ëª¨í‹°ì½˜ ê¸°í˜¸ë¥¼ í¬í•¨í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤. íŒŒì´ì¬ì˜ ë¬¸ìì—´í˜•ì€ ë¬¸ìë¥¼ "
"í‘œí˜„í•˜ê¸° ìœ„í•´ ìœ ë‹ˆì½”ë“œ í‘œì¤€ì„ ì‚¬ìš©í•˜ë¯€ë¡œ, íŒŒì´ì¬ í”„ë¡œê·¸ë¨ì€ ê°€ëŠ¥í•œ ëª¨ë“  ë‹¤ë¥¸ ë¬¸ìë¡œ ì‘ì—… í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:30
msgid ""
"Unicode (https://www.unicode.org/) is a specification that aims to list "
"every character used by human languages and give each character its own "
"unique code.  The Unicode specifications are continually revised and "
"updated to add new languages and symbols."
msgstr ""
"ìœ ë‹ˆì½”ë“œ(https://www.unicode.org/)ëŠ” ì¸ê°„ ì–¸ì–´ì—ì„œ ì‚¬ìš©í•˜ëŠ” ëª¨ë“  ë¬¸ìë¥¼ ë‚˜ì—´í•˜ê³  ê° ë¬¸ìì— ê³ ìœ í•œ ì½”ë“œë¥¼ "
"ë¶€ì—¬í•˜ê³ ì í•˜ëŠ” ëª…ì„¸ì…ë‹ˆë‹¤. ìƒˆë¡œìš´ ì–¸ì–´ì™€ ê¸°í˜¸ë¥¼ ì¶”ê°€í•˜ê¸° ìœ„í•´ ìœ ë‹ˆì½”ë“œ ëª…ì„¸ê°€ ê³„ì† ê°œì •ë˜ê³  ê°±ì‹ ë©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:35
msgid ""
"A **character** is the smallest possible component of a text.  'A', 'B', "
"'C', etc., are all different characters.  So are 'Ãˆ' and 'Ã'.  Characters"
" vary depending on the language or context you're talking about.  For "
"example, there's a character for \"Roman Numeral One\", 'â… ', that's "
"separate from the uppercase letter 'I'.  They'll usually look the same, "
"but these are two different characters that have different meanings."
msgstr ""
"**ë¬¸ì**\\ëŠ” í…ìŠ¤íŠ¸ì˜ ê°€ëŠ¥í•œ ìµœì†Œ êµ¬ì„±ìš”ì†Œì…ë‹ˆë‹¤. 'A', 'B', 'C' ë“±ì€ ì „ë¶€ ë‹¤ë¥¸ ë¬¸ìì…ë‹ˆë‹¤. 'Ãˆ'\\ì™€ 'Ã' "
"ì—­ì‹œ ê·¸ë ‡ìŠµë‹ˆë‹¤. ë¬¸ìëŠ” ì–¸ì–´ë‚˜ ë¬¸ë§¥ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ëŒ€ë¬¸ì 'I'ì™€ëŠ” ë³„ê°œë¡œ, \"ë¡œë§ˆ ìˆ«ì í•˜ë‚˜(Roman "
"Numeral One)\"ë¥¼ ìœ„í•œ ë¬¸ì 'â… 'ê°€ ìˆìŠµë‹ˆë‹¤. ì´ë“¤ì€ ë³´í†µ ë˜‘ê°™ì•„ ë³´ì´ì§€ë§Œ, ì„œë¡œ ë‹¤ë¥¸ ì˜ë¯¸ë¥¼ ê°€ì§„ ë‘ ê°œì˜ ë‹¤ë¥¸ "
"ë¬¸ìì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:42
msgid ""
"The Unicode standard describes how characters are represented by **code "
"points**.  A code point value is an integer in the range 0 to 0x10FFFF "
"(about 1.1 million values, the `actual number assigned "
"<https://www.unicode.org/versions/latest/#Summary>`_ is less than that). "
"In the standard and in this document, a code point is written using the "
"notation ``U+265E`` to mean the character with value ``0x265e`` (9,822 in"
" decimal)."
msgstr ""
"ìœ ë‹ˆì½”ë“œ í‘œì¤€ì€ ë¬¸ìë¥¼ ì–´ë–»ê²Œ **ì½”ë“œ í¬ì¸íŠ¸**\\ë¡œ í‘œí˜„í•˜ëŠ”ì§€ ì„œìˆ í•˜ê³  ìˆìŠµë‹ˆë‹¤. ì½”ë“œ í¬ì¸íŠ¸ ê°’ì€ 0ì—ì„œ 0x10FFFF "
"ì‚¬ì´ì˜ ì •ìˆ˜ì…ë‹ˆë‹¤ (ì•½ 110ë§Œ ê°œì˜ ê°’ì…ë‹ˆë‹¤, `í• ë‹¹ëœ ì‹¤ì œ ìˆ˜ "
"<https://www.unicode.org/versions/latest/#Summary>`_\\ëŠ” ì´ë³´ë‹¤ ì ìŠµë‹ˆë‹¤). í‘œì¤€ê³¼ ì´ "
"ë¬¸ì„œì—ì„œ ì½”ë“œ í¬ì¸íŠ¸ëŠ” ``U+265E`` í‘œê¸°ë²•ì„ ì‚¬ìš©í•˜ë©°, ì´ëŠ” ê°’ ``0x265e``\\(10ì§„ìˆ˜ë¡œëŠ” 9,822)ì¸ ë¬¸ìë¥¼ "
"ì˜ë¯¸í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:50
msgid ""
"The Unicode standard contains a lot of tables listing characters and "
"their corresponding code points:"
msgstr "ìœ ë‹ˆì½”ë“œ í‘œì¤€ì€ ë¬¸ìì™€ ê·¸ì— ìƒì‘í•˜ëŠ” ì½”ë“œ í¬ì¸íŠ¸ë¥¼ ë‚˜ì—´í•œ ìˆ˜ë§ì€ í‘œë¥¼ í¬í•¨í•˜ê³  ìˆìŠµë‹ˆë‹¤:"

#: ../../howto/unicode.rst:53
msgid ""
"0061    'a'; LATIN SMALL LETTER A\n"
"0062    'b'; LATIN SMALL LETTER B\n"
"0063    'c'; LATIN SMALL LETTER C\n"
"...\n"
"007B    '{'; LEFT CURLY BRACKET\n"
"...\n"
"2167    'â…§'; ROMAN NUMERAL EIGHT\n"
"2168    'â…¨'; ROMAN NUMERAL NINE\n"
"...\n"
"265E    'â™'; BLACK CHESS KNIGHT\n"
"265F    'â™Ÿ'; BLACK CHESS PAWN\n"
"...\n"
"1F600   'ğŸ˜€'; GRINNING FACE\n"
"1F609   'ğŸ˜‰'; WINKING FACE\n"
"..."
msgstr ""

#: ../../howto/unicode.rst:71
msgid ""
"Strictly, these definitions imply that it's meaningless to say 'this is "
"character ``U+265E``'.  ``U+265E`` is a code point, which represents some"
" particular character; in this case, it represents the character 'BLACK "
"CHESS KNIGHT', 'â™'.  In informal contexts, this distinction between code "
"points and characters will sometimes be forgotten."
msgstr ""
"ì—„ë°€íˆ ë§í•˜ìë©´, ì´ëŸ¬í•œ ì •ì˜ëŠ” 'ì´ê²ƒì´ ë¬¸ì ``U+265E``'\\ë¼ê³  ë§í•˜ëŠ” ê²ƒì€ ì˜ë¯¸ê°€ ì—†ìŒì„ ëœ»í•©ë‹ˆë‹¤. "
"``U+265E``\\ëŠ” ì–´ë–¤ íŠ¹ì • ë¬¸ìë¥¼ í‘œí˜„í•˜ëŠ” ì½”ë“œ í¬ì¸íŠ¸ì¼ ë¿ì…ë‹ˆë‹¤; ì´ ê²½ìš°ì—ëŠ” 'BLACK CHESS "
"KNIGHT'('â™')ë¥¼ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤. ì¼ìƒì ì¸ ë¬¸ë§¥ì—ì„œ ì½”ë“œ í¬ì¸íŠ¸ì™€ ë¬¸ì ì‚¬ì´ì˜ êµ¬ë¶„ì€ ë•Œë•Œë¡œ ìŠí ê²ë‹ˆë‹¤."

#: ../../howto/unicode.rst:78
msgid ""
"A character is represented on a screen or on paper by a set of graphical "
"elements that's called a **glyph**.  The glyph for an uppercase A, for "
"example, is two diagonal strokes and a horizontal stroke, though the "
"exact details will depend on the font being used.  Most Python code "
"doesn't need to worry about glyphs; figuring out the correct glyph to "
"display is generally the job of a GUI toolkit or a terminal's font "
"renderer."
msgstr ""
"ë¬¸ìëŠ” í™”ë©´ì´ë‚˜ ì¢…ì´ì— **ê¸€ë¦¬í”„**\\ë¼ ë¶ˆë¦¬ëŠ” ê·¸ë˜í”½ ìš”ì†Œì˜ ì§‘í•©ìœ¼ë¡œ í‘œì‹œë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ëŒ€ë¬¸ì Aì˜ ê¸€ë¦¬í”„ëŠ” ë‘ ê°œì˜ ëŒ€ê°"
" íšê³¼ í•œ ê°œì˜ ìˆ˜í‰ íšì´ì§€ë§Œ, ì •í™•í•œ ì„¸ë¶€ì‚¬í•­ì€ ê¸€ê¼´ì— ë”°ë¼ ë‹¤ë¦…ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ì˜ íŒŒì´ì¬ ì½”ë“œëŠ” ê¸€ë¦¬í”„ë¥¼ ê±±ì •í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤; "
"í‘œì‹œí•  ì˜¬ë°”ë¥¸ ê¸€ë¦¬í”„ë¥¼ ì°¾ëŠ” ê²ƒì€ ì¼ë°˜ì ìœ¼ë¡œ GUI íˆ´í‚·ì´ë‚˜ í„°ë¯¸ë„ì˜ ê¸€ê¼´ ë Œë”ëŸ¬ì˜ ì¼ì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:87
msgid "Encodings"
msgstr "ì¸ì½”ë”©"

#: ../../howto/unicode.rst:89
msgid ""
"To summarize the previous section: a Unicode string is a sequence of code"
" points, which are numbers from 0 through ``0x10FFFF`` (1,114,111 "
"decimal).  This sequence of code points needs to be represented in memory"
" as a set of **code units**, and **code units** are then mapped to 8-bit "
"bytes.  The rules for translating a Unicode string into a sequence of "
"bytes are called a **character encoding**, or just an **encoding**."
msgstr ""
"ì´ì „ ì„¹ì…˜ ìš”ì•½: ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì€ ì½”ë“œ í¬ì¸íŠ¸ì˜ ì‹œí€€ìŠ¤ì´ë©°, 0ë¶€í„° ``0x10FFFF`` (ì‹­ì§„ìˆ˜ 1,114,111)ì˜ ë²”ìœ„ë¥¼ "
"ê°–ëŠ” ìˆ˜ì…ë‹ˆë‹¤. ì´ ì½”ë“œ í¬ì¸íŠ¸ì˜ ì‹œí€€ìŠ¤ëŠ” ë©”ëª¨ë¦¬ì—ì„œ **ì½”ë“œ ë‹¨ìœ„(code units)**\\ì˜ ì§‘í•©ìœ¼ë¡œ í‘œí˜„ë  í•„ìš”ê°€ ìˆê³ , "
"ê·¸ëŸ° ë‹¤ìŒ **ì½”ë“œ ë‹¨ìœ„**\\ëŠ” 8ë¹„íŠ¸ ë°”ì´íŠ¸ë¡œ ë§¤í•‘ë©ë‹ˆë‹¤. ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì„ ë°”ì´íŠ¸ ì‹œí€€ìŠ¤ë¡œ ë³€í™˜í•˜ëŠ” ê·œì¹™ì„ **ë¬¸ì "
"ì¸ì½”ë”©(character encoding)**, ë˜ëŠ” ë‹¨ì§€ **ì¸ì½”ë”©(encoding)**\\ì´ë¼ê³  ë¶€ë¦…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:97
msgid ""
"The first encoding you might think of is using 32-bit integers as the "
"code unit, and then using the CPU's representation of 32-bit integers. In"
" this representation, the string \"Python\" might look like this:"
msgstr ""
"ìƒê°í•  ìˆ˜ ìˆëŠ” ì²« ë²ˆì§¸ ì¸ì½”ë”©ì€ ì½”ë“œ ë‹¨ìœ„ë¡œ 32ë¹„íŠ¸ ì •ìˆ˜ë¥¼ ì‚¬ìš©í•œ ë‹¤ìŒ 32ë¹„íŠ¸ ì •ìˆ˜ì˜ CPU í‘œí˜„ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ "
"í‘œí˜„ì—ì„œ ë¬¸ìì—´ \"Python\"ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: ../../howto/unicode.rst:101
msgid ""
"   P           y           t           h           o           n\n"
"0x50 00 00 00 79 00 00 00 74 00 00 00 68 00 00 00 6f 00 00 00 6e 00 00 00"
"\n"
"   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23"
msgstr ""

#: ../../howto/unicode.rst:107
msgid ""
"This representation is straightforward but using it presents a number of "
"problems."
msgstr "ì´ í‘œí˜„ì€ ê°„ë‹¨í•˜ì§€ë§Œ ì—¬ëŸ¬ ë¬¸ì œë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:110
msgid "It's not portable; different processors order the bytes differently."
msgstr "ì´ì‹ì„±ì´ ì—†ìŠµë‹ˆë‹¤; ë‹¤ë¥¸ í”„ë¡œì„¸ì„œëŠ” ë°”ì´íŠ¸ë¥¼ ë‹¤ë¥´ê²Œ ì •ë ¬í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:112
msgid ""
"It's very wasteful of space.  In most texts, the majority of the code "
"points are less than 127, or less than 255, so a lot of space is occupied"
" by ``0x00`` bytes.  The above string takes 24 bytes compared to the 6 "
"bytes needed for an ASCII representation.  Increased RAM usage doesn't "
"matter too much (desktop computers have gigabytes of RAM, and strings "
"aren't usually that large), but expanding our usage of disk and network "
"bandwidth by a factor of 4 is intolerable."
msgstr ""
"ì´ëŠ” ê³µê°„ì„ ë§¤ìš° ë‚­ë¹„í•˜ëŠ” ê²ë‹ˆë‹¤. ëŒ€ë¶€ë¶„ í…ìŠ¤íŠ¸ì—ì„œ ì£¼ìš” ì½”ë“œ í¬ì¸íŠ¸ëŠ” 127 ë˜ëŠ” 255ë³´ë‹¤ ì‘ìœ¼ë¯€ë¡œ ë§ì€ ê³µê°„ì´ "
"``0x00``\\ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤. ìœ„ì˜ ë¬¸ìì—´ì€ ASCII í‘œí˜„ì— í•„ìš”í•œ 6 ë°”ì´íŠ¸ì™€ ë¹„êµí•˜ì—¬ 24 ë°”ì´íŠ¸ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ëŠ˜ì–´ë‚œ "
"RAM ì‚¬ìš©ì€ ì¤‘ìš”í•˜ì§€ ì•Šì§€ë§Œ(ë°ìŠ¤í¬í†± ì»´í“¨í„°ëŠ” ê¸°ê°€ë°”ì´íŠ¸ ë‹¨ìœ„ì˜ RAMì„ ê°–ê³  ìˆê³ , ë¬¸ìì—´ì€ ëŒ€ê°œ ê·¸ ì •ë„ë¡œ í¬ì§€ ì•ŠìŠµë‹ˆë‹¤), "
"ë””ìŠ¤í¬ì™€ ë„¤íŠ¸ì›Œí¬ ëŒ€ì—­í­ ì‚¬ìš©ì„ 4ë°°ë¡œ í™•ì¥í•˜ëŠ” ê²ƒì€ ìš©ë‚©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:120
msgid ""
"It's not compatible with existing C functions such as ``strlen()``, so a "
"new family of wide string functions would need to be used."
msgstr "``strlen()``\\ê³¼ ê°™ì€ ê¸°ì¡´ì˜ C í•¨ìˆ˜ì™€ í˜¸í™˜ì´ ì•ˆ ë˜ê¸° ë•Œë¬¸ì— ìƒˆë¡œìš´ ì™€ì´ë“œ ë¬¸ìì—´ í•¨ìˆ˜ ê³„ì—´ì„ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:123
msgid ""
"Therefore this encoding isn't used very much, and people instead choose "
"other encodings that are more efficient and convenient, such as UTF-8."
msgstr "ë”°ë¼ì„œ ì´ ì¸ì½”ë”©ì€ ë§ì´ ì‚¬ìš©ë˜ì§€ ì•Šìœ¼ë©°, ì‚¬ëŒë“¤ì€ UTF-8ê³¼ ê°™ì€ ë” íš¨ìœ¨ì ì´ê³  í¸ë¦¬í•œ ë‹¤ë¥¸ ì¸ì½”ë”©ì„ ì„ íƒí•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:126
msgid ""
"UTF-8 is one of the most commonly used encodings, and Python often "
"defaults to using it.  UTF stands for \"Unicode Transformation Format\", "
"and the '8' means that 8-bit values are used in the encoding.  (There are"
" also UTF-16 and UTF-32 encodings, but they are less frequently used than"
" UTF-8.)  UTF-8 uses the following rules:"
msgstr ""
"UTF-8ì€ ì¼ë°˜ì ìœ¼ë¡œ ê°€ì¥ ë§ì´ ì‚¬ìš©ë˜ëŠ” ì¸ì½”ë”© ì¤‘ í•˜ë‚˜ì´ê³ , íŒŒì´ì¬ì€ ì¢…ì¢… ê¸°ë³¸ì ìœ¼ë¡œ ì´ê²ƒì„ ì‚¬ìš©í•©ë‹ˆë‹¤. UTFëŠ” "
"\"Unicode Transformation Format\"ì˜ ì•½ìì´ë©° '8'ì€ 8ë¹„íŠ¸ ê°’ì´ ì¸ì½”ë”©ì— ì‚¬ìš©ë¨ì„ ëœ»í•©ë‹ˆë‹¤. "
"(UTF-16ê³¼ UTF-32 ì¸ì½”ë”©ë„ ìˆì§€ë§Œ, UTF-8ë³´ë‹¤ ë‚®ì€ ë¹ˆë„ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.) UTF-8ì€ ë‹¤ìŒì˜ ê·œì¹™ì„ ë”°ë¦…ë‹ˆë‹¤:"

#: ../../howto/unicode.rst:132
msgid ""
"If the code point is < 128, it's represented by the corresponding byte "
"value."
msgstr "ë§Œì•½ ì½”ë“œ í¬ì¸íŠ¸ê°€ 128ë³´ë‹¤ ì‘ë‹¤ë©´, í•´ë‹¹ ë°”ì´íŠ¸ ê°’ìœ¼ë¡œ í‘œí˜„ë©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:133
msgid ""
"If the code point is >= 128, it's turned into a sequence of two, three, "
"or four bytes, where each byte of the sequence is between 128 and 255."
msgstr ""
"ë§Œì•½ ì½”ë“œ í¬ì¸íŠ¸ê°€ 128ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ë‹¤ë©´, ì‹œí€€ìŠ¤ì˜ ê° ë°”ì´íŠ¸ê°€ 128ì—ì„œ 255 ì‚¬ì´ì¸ ë‘˜, ì…‹ ë˜ëŠ” ë„¤ ê°œì˜ ë°”ì´íŠ¸ ì‹œí€€ìŠ¤ë¡œ"
" ë°”ë€ë‹ˆë‹¤."

#: ../../howto/unicode.rst:136
msgid "UTF-8 has several convenient properties:"
msgstr "UTF-8ì€ ëª‡ ê°€ì§€ í¸ë¦¬í•œ íŠ¹ì§•ì´ ìˆìŠµë‹ˆë‹¤:"

#: ../../howto/unicode.rst:138
msgid "It can handle any Unicode code point."
msgstr "ëª¨ë“  ìœ ë‹ˆì½”ë“œ ì½”ë“œ í¬ì¸íŠ¸ë¥¼ ì²˜ë¦¬ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:139
msgid ""
"A Unicode string is turned into a sequence of bytes that contains "
"embedded zero bytes only where they represent the null character "
"(U+0000). This means that UTF-8 strings can be processed by C functions "
"such as ``strcpy()`` and sent through protocols that can't handle zero "
"bytes for anything other than end-of-string markers."
msgstr ""
"ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì€ ë„ ë¬¸ìë¥¼ í‘œí˜„í•˜ëŠ” ê³³ì—ë§Œ ë‚´ì¥ëœ 0ë°”ì´íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” ë°”ì´íŠ¸ ì‹œí€€ìŠ¤ë¡œ ë³€í™˜ë©ë‹ˆë‹¤. ì´ëŠ” UTF-8 ë¬¸ìì—´ì„ "
"``strcpy()``\\ì™€ ê°™ì€ C í•¨ìˆ˜ë¡œ ì²˜ë¦¬í•˜ê³  ë¬¸ìì—´ ë í‘œì‹œ ì´ì™¸ì˜ 0ë°”ì´íŠ¸ë¥¼ ì²˜ë¦¬í•˜ì§€ ëª»í•˜ëŠ” í”„ë¡œí† ì½œì„ í†µí•´ ì „ì†¡í•  ìˆ˜ "
"ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:144
msgid "A string of ASCII text is also valid UTF-8 text."
msgstr "ASCII í…ìŠ¤íŠ¸ì˜ ë¬¸ìì—´ ì—­ì‹œ ìœ íš¨í•œ UTF-8 í…ìŠ¤íŠ¸ì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:145
msgid ""
"UTF-8 is fairly compact; the majority of commonly used characters can be "
"represented with one or two bytes."
msgstr "UTF-8ì€ ê½¤ ì•Œì°¹ë‹ˆë‹¤; ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë¬¸ì ëŒ€ë¶€ë¶„ì„ í•œë‘ ê°œì˜ ë°”ì´íŠ¸ë¡œ í‘œí˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:147
msgid ""
"If bytes are corrupted or lost, it's possible to determine the start of "
"the next UTF-8-encoded code point and resynchronize.  It's also unlikely "
"that random 8-bit data will look like valid UTF-8."
msgstr ""
"ë§Œì•½ ë°”ì´íŠ¸ê°€ ì†ìƒ ë˜ëŠ” ì†ì‹¤ë˜ì—ˆë‹¤ë©´, ë‹¤ìŒ UTF-8 ì¸ì½”ë”© ì½”ë“œ í¬ì¸íŠ¸ì˜ ì‹œì‘ì„ ê²°ì •í•˜ê³  ë‹¤ì‹œ ë™ê¸°í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë¬´ì‘ìœ„ "
"8ë¹„íŠ¸ ë°ì´í„°ê°€ ìœ íš¨í•œ UTF-8ì²˜ëŸ¼ ë³´ì¼ ê°€ëŠ¥ì„±ì€ ë‚®ìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:150
msgid ""
"UTF-8 is a byte oriented encoding. The encoding specifies that each "
"character is represented by a specific sequence of one or more bytes. "
"This avoids the byte-ordering issues that can occur with integer and word"
" oriented encodings, like UTF-16 and UTF-32, where the sequence of bytes "
"varies depending on the hardware on which the string was encoded."
msgstr ""
"UTF-8ì€ ë°”ì´íŠ¸ ì§€í–¥ ì¸ì½”ë”©ì…ë‹ˆë‹¤. ì¸ì½”ë”©ì€ ê° ë¬¸ìê°€ í•˜ë‚˜ ì´ìƒì˜ ë°”ì´íŠ¸ì˜ íŠ¹ì • ì‹œí€€ìŠ¤ë¡œ í‘œì‹œë˜ë„ë¡ ì§€ì •í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ "
"UTF-16ê³¼ UTF-32ì™€ ê°™ì´ ë°”ì´íŠ¸ì˜ ì‹œí€€ìŠ¤ê°€ ë¬¸ìì—´ì´ ì¸ì½”ë”©ëœ í•˜ë“œì›¨ì–´ì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” ì •ìˆ˜ì™€ ì›Œë“œ(word) ì§€í–¥ "
"ì¸ì½”ë”©ì—ì„œ ë°œìƒí•  ìˆ˜ ìˆëŠ” ë°”ì´íŠ¸ ìˆœì„œ ë¬¸ì œë¥¼ í”¼í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:158 ../../howto/unicode.rst:514
#: ../../howto/unicode.rst:735
msgid "References"
msgstr "ì°¸ì¡°"

#: ../../howto/unicode.rst:160
msgid ""
"The `Unicode Consortium site <https://www.unicode.org>`_ has character "
"charts, a glossary, and PDF versions of the Unicode specification.  Be "
"prepared for some difficult reading.  `A chronology "
"<https://www.unicode.org/history/>`_ of the origin and development of "
"Unicode is also available on the site."
msgstr ""
"`ìœ ë‹ˆì½”ë“œ ì»¨ì†Œì‹œì—„ ì‚¬ì´íŠ¸ <https://www.unicode.org>`_\\ëŠ” ìœ ë‹ˆì½”ë“œ ì‚¬ì–‘ì˜ ë¬¸ì ì°¨íŠ¸, ìš©ì–´ì§‘ ê·¸ë¦¬ê³  PDF"
" ë²„ì „ì˜ ìœ ë‹ˆì½”ë“œ ëª…ì„¸ë¥¼ ê°–ê³  ìˆìŠµë‹ˆë‹¤. ì–´ë ¤ìš´ ì½ê¸°ë¥¼ ì¤€ë¹„í•˜ì„¸ìš”. ìœ ë‹ˆì½”ë“œì˜ ê¸°ì›ê³¼ ê°œë°œì˜ `ì—°ëŒ€ê¸° "
"<https://www.unicode.org/history/>`_\\  ì—­ì‹œ ì´ ì‚¬ì´íŠ¸ì—ì„œ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:165
msgid ""
"On the Computerphile Youtube channel, Tom Scott briefly `discusses the "
"history of Unicode and UTF-8 "
"<https://www.youtube.com/watch?v=MijmeoH9LT4>`_ (9 minutes 36 seconds)."
msgstr ""
"Computerphile ìœ íŠœë¸Œ ì±„ë„ì—ì„œ, Tom Scottê°€ ê°„ëµí•˜ê²Œ `ìœ ë‹ˆì½”ë“œì™€ UTF-8ì˜ ì—­ì‚¬ë¥¼ ë…¼ì˜í•©ë‹ˆë‹¤ "
"<https://www.youtube.com/watch?v=MijmeoH9LT4>`_ (9ë¶„ 36ì´ˆ)."

#: ../../howto/unicode.rst:169
#, fuzzy
msgid ""
"To help understand the standard, Jukka Korpela has written `an "
"introductory guide <https://jkorpela.fi/unicode/guide.html>`_ to reading "
"the Unicode character tables."
msgstr ""
"Jukka KorpelaëŠ” í‘œì¤€ì„ ì´í•´í•  ìˆ˜ ìˆë„ë¡ ìœ ë‹ˆì½”ë“œ ë¬¸ìí‘œ ì½ê¸°ì— ëŒ€í•œ `ì…ë¬¸ ì•ˆë‚´ì„œ "
"<http://jkorpela.fi/unicode/guide.html>`_\\ë¥¼ ì‘ì„±í–ˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:173
msgid ""
"Another `good introductory article "
"<https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-"
"software-developer-absolutely-positively-must-know-about-unicode-and-"
"character-sets-no-excuses/>`_ was written by Joel Spolsky. If this "
"introduction didn't make things clear to you, you should try reading this"
" alternate article before continuing."
msgstr ""
"ë˜ ë‹¤ë¥¸ `ì¢‹ì€ ì…ë¬¸ ê¸€ <https://www.joelonsoftware.com/2003/10/08/the-absolute-"
"minimum-every-software-developer-absolutely-positively-must-know-about-"
"unicode-and-character-sets-no-excuses/>`_\\ì„ Joel Spolskyê°€ ì¼ìŠµë‹ˆë‹¤. ì´ ì…ë¬¸ì„œë¡œë„ "
"ëª…í™•í•˜ì§€ ì•Šì€ ê²½ìš° ê³„ì†í•˜ê¸° ì „ì— ì´ ëŒ€ì²´ ë¬¸ì„œë¥¼ ì½ìœ¼ì„¸ìš”."

#: ../../howto/unicode.rst:178
msgid ""
"Wikipedia entries are often helpful; see the entries for \"`character "
"encoding <https://en.wikipedia.org/wiki/Character_encoding>`_\" and "
"`UTF-8 <https://en.wikipedia.org/wiki/UTF-8>`_, for example."
msgstr ""
"ìœ„í‚¤í”¼ë””ì•„ í•­ëª©ì€ ë•Œë•Œë¡œ ë„ì›€ì´ ë©ë‹ˆë‹¤; ì˜ˆë¥¼ ë“¤ì–´, \"`ë¬¸ì ì¸ì½”ë”© "
"<https://en.wikipedia.org/wiki/Character_encoding>`_\"\\ê³¼ `UTF-8 "
"<https://en.wikipedia.org/wiki/UTF-8>`_ í•­ëª©ì„ ë³´ì„¸ìš”."

#: ../../howto/unicode.rst:184
msgid "Python's Unicode Support"
msgstr "íŒŒì´ì¬ì˜ ìœ ë‹ˆì½”ë“œ ì§€ì›"

#: ../../howto/unicode.rst:186
msgid ""
"Now that you've learned the rudiments of Unicode, we can look at Python's"
" Unicode features."
msgstr "ì´ì œ ìœ ë‹ˆì½”ë“œì˜ ê¸°ì´ˆë¥¼ ë°°ì› ìœ¼ë¯€ë¡œ íŒŒì´ì¬ì˜ ìœ ë‹ˆì½”ë“œ ê¸°ëŠ¥ì„ ì‚´í´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:190
msgid "The String Type"
msgstr "ë¬¸ìì—´ í˜•"

#: ../../howto/unicode.rst:192
msgid ""
"Since Python 3.0, the language's :class:`str` type contains Unicode "
"characters, meaning any string created using ``\"unicode rocks!\"``, "
"``'unicode rocks!'``, or the triple-quoted string syntax is stored as "
"Unicode."
msgstr ""
"íŒŒì´ì¬ 3.0ë¶€í„°ëŠ” ì–¸ì–´ì˜ :class:`str` í˜•ì€ ìœ ë‹ˆì½”ë“œ ë¬¸ìë¥¼ í¬í•¨í•˜ê³ , ì´ëŠ” ì–´ë–¤ ë¬¸ìì—´ì´ë“  ``\"unicode "
"rocks!\"``, ``'unicode rocks!'`` ë˜ëŠ” ì‚¼ì¤‘ ë”°ì˜´í‘œë¡œ ë¬¶ì¸ ë¬¸ìì—´ ë¬¸ë²•ì„ ì‚¬ìš©í•œë‹¤ë©´ ìœ ë‹ˆì½”ë“œë¡œ ì €ì¥ë¨ì„ "
"ëœ»í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:196
msgid ""
"The default encoding for Python source code is UTF-8, so you can simply "
"include a Unicode character in a string literal::"
msgstr "íŒŒì´ì¬ ì†ŒìŠ¤ ì½”ë“œì˜ ê¸°ë³¸ ì¸ì½”ë”©ì€ UTF-8ì´ë¯€ë¡œ ë¬¸ìì—´ ë¦¬í„°ëŸ´ì— ìœ ë‹ˆì½”ë“œ ë¬¸ìë¥¼ ì‰½ê²Œ í¬í•¨í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤::"

#: ../../howto/unicode.rst:199
msgid ""
"try:\n"
"    with open('/tmp/input.txt', 'r') as f:\n"
"        ...\n"
"except OSError:\n"
"    # 'File not found' error message.\n"
"    print(\"Fichier non trouvÃ©\")"
msgstr ""

#: ../../howto/unicode.rst:206
msgid ""
"Side note: Python 3 also supports using Unicode characters in "
"identifiers::"
msgstr "ì‚¬ì´ë“œ ë…¸íŠ¸: íŒŒì´ì¬ 3ì€ ìœ ë‹ˆì½”ë“œ ë¬¸ìë¥¼ ì‹ë³„ìì—ì„œë„ ì§€ì›í•©ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:208
msgid ""
"rÃ©pertoire = \"/tmp/records.log\"\n"
"with open(rÃ©pertoire, \"w\") as f:\n"
"    f.write(\"test\\n\")"
msgstr ""

#: ../../howto/unicode.rst:212
msgid ""
"If you can't enter a particular character in your editor or want to keep "
"the source code ASCII-only for some reason, you can also use escape "
"sequences in string literals. (Depending on your system, you may see the "
"actual capital-delta glyph instead of a \\u escape.) ::"
msgstr ""
"í¸ì§‘ê¸°ì—ì„œ íŠ¹ì • ë¬¸ìë¥¼ ì…ë ¥ í• ìˆ˜ ì—†ê±°ë‚˜ ì–´ë–¤ ì´ìœ ì—ì„œ ASCIIë§Œìœ¼ë¡œ ì†ŒìŠ¤ ì½”ë“œë¥¼ ì‘ì„±í•˜ê³ ì í•œë‹¤ë©´, ë¬¸ìì—´ ë¦¬í„°ëŸ´ì— ì´ìŠ¤ì¼€ì´í”„ "
"ì‹œí€€ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì‹œìŠ¤í…œì— ë”°ë¼ ë‹¤ë¥´ì§€ë§Œ, \\u ì´ìŠ¤ì¼€ì´í”„ ëŒ€ì‹ ì— ì§„ì§œ ëŒ€ë¬¸ì ë¸íƒ€ ê¸€ë¦¬í”„ê°€ ë‚˜íƒ€ë‚  ìˆ˜ ìˆìŠµë‹ˆë‹¤.)"
" ::"

#: ../../howto/unicode.rst:217
#, python-brace-format
msgid ""
">>> \"\\N{GREEK CAPITAL LETTER DELTA}\"  # Using the character name\n"
"'\\u0394'\n"
">>> \"\\u0394\"                          # Using a 16-bit hex value\n"
"'\\u0394'\n"
">>> \"\\U00000394\"                      # Using a 32-bit hex value\n"
"'\\u0394'"
msgstr ""

#: ../../howto/unicode.rst:224
msgid ""
"In addition, one can create a string using the :func:`~bytes.decode` "
"method of :class:`bytes`.  This method takes an *encoding* argument, such"
" as ``UTF-8``, and optionally an *errors* argument."
msgstr ""
"ì¶”ê°€ë¡œ, ë¬¸ìì—´ì„ :class:`bytes`\\ì˜ :func:`~bytes.decode` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ "
"ë©”ì„œë“œëŠ” ``UTF-8``\\ê³¼ ê°™ì€ *encoding* ì¸ìì™€ ì„ íƒì ìœ¼ë¡œ *erros* ì¸ìë¥¼ ë°›ìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:228
msgid ""
"The *errors* argument specifies the response when the input string can't "
"be converted according to the encoding's rules.  Legal values for this "
"argument are ``'strict'`` (raise a :exc:`UnicodeDecodeError` exception), "
"``'replace'`` (use ``U+FFFD``, ``REPLACEMENT CHARACTER``), ``'ignore'`` "
"(just leave the character out of the Unicode result), or "
"``'backslashreplace'`` (inserts a ``\\xNN`` escape sequence). The "
"following examples show the differences::"
msgstr ""
"*errors* ì¸ìëŠ” ì¸ì½”ë”©ì˜ ê·œì¹™ì— ë”°ë¼ ì…ë ¥ ë¬¸ìì—´ì„ ë³€í™˜í•  ìˆ˜ ì—†ëŠ” ê²½ìš°ì˜ ì‘ë‹µì„ ì§€ì •í•©ë‹ˆë‹¤. ì´ ì¸ìì˜ ìœ íš¨í•œ ê°’ì€ "
"``'strict'`` (:exc:`UnicodeDecodeError` ì˜ˆì™¸ ë°œìƒ), ``'replace'`` "
"(``U+FFFD``, ``REPLACEMENT CHARACTER`` ì‚¬ìš©), ``'ignore'`` (ìœ ë‹ˆì½”ë“œ ê²°ê³¼ì—ì„œ ë¬¸ìë¥¼ "
"ê·¸ëƒ¥ ìƒëµ), ë˜ëŠ” ``'backslashreplace'`` (``\\xNN`` ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ë¥¼ ì‚½ì…)ì…ë‹ˆë‹¤. ë‹¤ìŒ ì—ì œëŠ” ê·¸ "
"ì°¨ì´ì ì„ ë³´ì—¬ì¤ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:236
msgid ""
">>> b'\\x80abc'.decode(\"utf-8\", \"strict\")\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeDecodeError: 'utf-8' codec can't decode byte 0x80 in position 0:\n"
"  invalid start byte\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"replace\")\n"
"'\\ufffdabc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"backslashreplace\")\n"
"'\\\\x80abc'\n"
">>> b'\\x80abc'.decode(\"utf-8\", \"ignore\")\n"
"'abc'"
msgstr ""

#: ../../howto/unicode.rst:248
msgid ""
"Encodings are specified as strings containing the encoding's name.  "
"Python comes with roughly 100 different encodings; see the Python Library"
" Reference at :ref:`standard-encodings` for a list.  Some encodings have "
"multiple names; for example, ``'latin-1'``, ``'iso_8859_1'`` and "
"``'8859``' are all synonyms for the same encoding."
msgstr ""
"ì¸ì½”ë”©ì€ ì¸ì½”ë”©ì˜ ì´ë¦„ì„ í¬í•¨í•˜ëŠ” ë¬¸ìì—´ë¡œ ì§€ì •ë©ë‹ˆë‹¤. íŒŒì´ì¬ì—ëŠ” ëŒ€ëµ 100ê°œì˜ ì„œë¡œ ë‹¤ë¥¸ ì¸ì½”ë”©ì´ ìˆìŠµë‹ˆë‹¤. ë¦¬ìŠ¤íŠ¸ëŠ” :ref"
":`standard-encodings`\\ì—ì„œ íŒŒì´ì¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ë³´ì„¸ìš”. ì–´ë–¤ ì¸ì½”ë”©ì€ ë‹¤ì–‘í•œ ì´ë¦„ì„ ê°–ìŠµë‹ˆë‹¤; ì˜ˆë¥¼ "
"ë“¤ì–´, ``'latin-1'``, ``'iso_8859_1'`` ê·¸ë¦¬ê³  ``'8859``' ëŠ” ì „ë¶€ ê°™ì€ ì¸ì½”ë”©ì˜ ë™ì˜ì–´ì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:254
msgid ""
"One-character Unicode strings can also be created with the :func:`chr` "
"built-in function, which takes integers and returns a Unicode string of "
"length 1 that contains the corresponding code point.  The reverse "
"operation is the built-in :func:`ord` function that takes a one-character"
" Unicode string and returns the code point value::"
msgstr ""
"í•œ ë¬¸ì ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì€ ì •ìˆ˜ë¥¼ ë°›ê³  í•´ë‹¹ ì½”ë“œ í¬ì¸íŠ¸ë¥¼ í¬í•¨í•˜ëŠ” ê¸¸ì´ 1ì¸ ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ëŠ” :func:`chr` ë‚´ì¥"
" í•¨ìˆ˜ë¡œë„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë°˜ëŒ€ ì‘ì—…ì€ í•œ ë¬¸ì ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì„ ë°›ê³  ì½”ë“œ í¬ì¸íŠ¸ ê°’ì„ ë°˜í™˜í•˜ëŠ” :func:`ord` ë‚´ì¥ "
"í•¨ìˆ˜ì…ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:260
msgid ""
">>> chr(57344)\n"
"'\\ue000'\n"
">>> ord('\\ue000')\n"
"57344"
msgstr ""

#: ../../howto/unicode.rst:266
msgid "Converting to Bytes"
msgstr "ë°”ì´íŠ¸ì—´ë¡œ ë³€í™˜"

#: ../../howto/unicode.rst:268
msgid ""
"The opposite method of :meth:`bytes.decode` is :meth:`str.encode`, which "
"returns a :class:`bytes` representation of the Unicode string, encoded in"
" the requested *encoding*."
msgstr ""
":meth:`bytes.decode`\\ì˜ ë°˜ëŒ€ ë©”ì„œë“œëŠ” ìš”ì²­ëœ *encoding*\\ìœ¼ë¡œ ì¸ì½”ë”© ëœ ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì˜ "
":class:`bytes`\\ë¥¼ ë°˜í™˜í•˜ëŠ” :meth:`str.encode`\\ì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:272
#, python-brace-format
msgid ""
"The *errors* parameter is the same as the parameter of the "
":meth:`~bytes.decode` method but supports a few more possible handlers. "
"As well as ``'strict'``, ``'ignore'``, and ``'replace'`` (which in this "
"case inserts a question mark instead of the unencodable character), there"
" is also ``'xmlcharrefreplace'`` (inserts an XML character reference), "
"``backslashreplace`` (inserts a ``\\uNNNN`` escape sequence) and "
"``namereplace`` (inserts a ``\\N{...}`` escape sequence)."
msgstr ""
"*errors* ë§¤ê°œë³€ìˆ˜ëŠ” :meth:`~bytes.decode` ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ì™€ ê°™ì§€ë§Œ ê°€ëŠ¥í•œ í•¸ë“¤ëŸ¬ë¥¼ ì¡°ê¸ˆ ë” ì œê³µí•©ë‹ˆë‹¤. "
"``'strict'``, ``'ignore'``, ``'replace'`` (ì´ ê²½ìš° ì¸ì½”ë”©í•  ìˆ˜ ì—†ëŠ” ë¬¸ì ëŒ€ì‹ ì— ë¬¼ìŒí‘œë¥¼ "
"ì‚½ì…)ë¿ë§Œ ì•„ë‹ˆë¼ ``'xmlcharrefreplace'`` (XML ë¬¸ì ì°¸ì¡° ì‚½ì…), ``backslashreplace`` "
"(``\\uNNNN`` ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ ì‚½ì…) ê·¸ë¦¬ê³  ``namereplace`` (``\\N{...}`` ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ "
"ì‚½ì…)ë„ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:280
msgid "The following example shows the different results::"
msgstr "ì•„ë˜ ì˜ˆì œì—ì„œ ì„œë¡œ ë‹¤ë¥¸ ê²°ê³¼ë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:282
#, python-brace-format
msgid ""
">>> u = chr(40960) + 'abcd' + chr(1972)\n"
">>> u.encode('utf-8')\n"
"b'\\xea\\x80\\x80abcd\\xde\\xb4'\n"
">>> u.encode('ascii')\n"
"Traceback (most recent call last):\n"
"    ...\n"
"UnicodeEncodeError: 'ascii' codec can't encode character '\\ua000' in\n"
"  position 0: ordinal not in range(128)\n"
">>> u.encode('ascii', 'ignore')\n"
"b'abcd'\n"
">>> u.encode('ascii', 'replace')\n"
"b'?abcd?'\n"
">>> u.encode('ascii', 'xmlcharrefreplace')\n"
"b'&#40960;abcd&#1972;'\n"
">>> u.encode('ascii', 'backslashreplace')\n"
"b'\\\\ua000abcd\\\\u07b4'\n"
">>> u.encode('ascii', 'namereplace')\n"
"b'\\\\N{YI SYLLABLE IT}abcd\\\\u07b4'"
msgstr ""

#: ../../howto/unicode.rst:301
msgid ""
"The low-level routines for registering and accessing the available "
"encodings are found in the :mod:`codecs` module.  Implementing new "
"encodings also requires understanding the :mod:`codecs` module. However, "
"the encoding and decoding functions returned by this module are usually "
"more low-level than is comfortable, and writing new encodings is a "
"specialized task, so the module won't be covered in this HOWTO."
msgstr ""
"ì‚¬ìš© ê°€ëŠ¥í•œ ì¸ì½”ë”©ì„ ë“±ë¡í•˜ê³  ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” ì €ìˆ˜ì¤€ ë£¨í‹´ì€ :mod:`codecs` ëª¨ë“ˆì—ì„œ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ "
"ì¸ì½”ë”©ì„ êµ¬í˜„í•˜ëŠ” ê²ƒë„ :mod:`codecs` ëª¨ë“ˆì˜ ì´í•´ê°€ í•„ìš”í•©ë‹ˆë‹¤. í•˜ì§€ë§Œ ì´ ëª¨ë“ˆì— ì˜í•´ì„œ ë°˜í™˜ë˜ëŠ” ì¸ì½”ë”©ê³¼ ë””ì½”ë”© í•¨ìˆ˜ëŠ”"
" ëŒ€ì²´ë¡œ í¸ì•ˆí•œ ê²ƒë³´ë‹¤ëŠ” ì €ìˆ˜ì¤€ì´ë©°, ìƒˆë¡œìš´ ì¸ì½”ë”©ì„ ì‘ì„±í•˜ëŠ” ê²ƒì€ ì „ë¬¸ì ì¸ ì‘ì—…ì´ë¯€ë¡œ HOWTOì—ì„œ ì´ ëª¨ë“ˆì„ ë‹¤ë£¨ì§€ëŠ” "
"ì•Šê² ìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:310
msgid "Unicode Literals in Python Source Code"
msgstr "íŒŒì´ì¬ ì†ŒìŠ¤ ì½”ë“œì—ì„œ ìœ ë‹ˆì½”ë“œ ë¦¬í„°ëŸ´"

#: ../../howto/unicode.rst:312
msgid ""
"In Python source code, specific Unicode code points can be written using "
"the ``\\u`` escape sequence, which is followed by four hex digits giving "
"the code point.  The ``\\U`` escape sequence is similar, but expects "
"eight hex digits, not four::"
msgstr ""
"íŒŒì´ì¬ ì†ŒìŠ¤ ì½”ë“œì—ì„œ íŠ¹ì •í•œ ìœ ë‹ˆì½”ë“œ ì½”ë“œ í¬ì¸íŠ¸ëŠ” ``\\u`` ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ë¡œ ì“¸ ìˆ˜ ìˆìœ¼ë©°, ì½”ë“œ í¬ì¸íŠ¸ë¥¼ ì˜ë¯¸í•˜ëŠ” ë„¤ "
"ê°œì˜ 16ì§„ìˆ˜ê°€ ë’¤ë”°ë¦…ë‹ˆë‹¤. ``\\U`` ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ì™€ ë¹„ìŠ·í•˜ì§€ë§Œ ë„¤ ê°œê°€ ì•„ë‹Œ ì—¬ëŸ ê°œì˜ ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:317
msgid ""
">>> s = \"a\\xac\\u1234\\u20ac\\U00008000\"\n"
"... #     ^^^^ two-digit hex escape\n"
"... #         ^^^^^^ four-digit Unicode escape\n"
"... #                     ^^^^^^^^^^ eight-digit Unicode escape\n"
">>> [ord(c) for c in s]\n"
"[97, 172, 4660, 8364, 32768]"
msgstr ""

#: ../../howto/unicode.rst:324
msgid ""
"Using escape sequences for code points greater than 127 is fine in small "
"doses, but becomes an annoyance if you're using many accented characters,"
" as you would in a program with messages in French or some other accent-"
"using language.  You can also assemble strings using the :func:`chr` "
"built-in function, but this is even more tedious."
msgstr ""
"127ë³´ë‹¤ í° ì½”ë“œ í¬ì¸íŠ¸ì— ëŒ€í•´ ì´ìŠ¤ì¼€ì´í”„ ì‹œí€€ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ ì–‘ì´ ì ì„ ë•Œ ê´œì°®ì§€ë§Œ, í”„ë‘ìŠ¤ì–´ë‚˜ ë‹¤ë¥¸ ì•…ì„¼íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” "
"ì–¸ì–´ë¡œ ì‘ì„±ëœ í”„ë¡œê·¸ë¨ ë©”ì‹œì§€ ê°™ì´ ì•…ì„¼íŠ¸ê°€ ìˆëŠ” ë¬¸ìë¥¼ ì‚¬ìš©í•  ê²½ìš° ì„±ê°€ì‹­ë‹ˆë‹¤. :func:`chr` ë‚´ì¥ í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ "
"ë¬¸ìì—´ì„ ì¡°ë¦½í•  ìˆ˜ëŠ” ìˆì§€ë§Œ ë” ì§œì¦ë‚©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:330
msgid ""
"Ideally, you'd want to be able to write literals in your language's "
"natural encoding.  You could then edit Python source code with your "
"favorite editor which would display the accented characters naturally, "
"and have the right characters used at runtime."
msgstr ""
"ì‚¬ìš©í•˜ëŠ” ì–¸ì–´ì˜ ìì—°ìŠ¤ëŸ¬ìš´ ì¸ì½”ë”©ìœ¼ë¡œ ë¦¬í„°ëŸ´ì„ ì“¸ ìˆ˜ ìˆì–´ì•¼ ì´ìƒì ì…ë‹ˆë‹¤. ê·¸ë˜ì•¼ ì•…ì„¼íŠ¸ê°€ ìˆëŠ” ë¬¸ìë¥¼ ìì—°ìŠ¤ëŸ½ê²Œ í‘œì‹œí•˜ëŠ” ì‚¬ìš©ìê°€"
" ê°€ì¥ ì¢‹ì•„í•˜ëŠ” í¸ì§‘ê¸°ë¡œ íŒŒì´ì¬ ì†ŒìŠ¤ ì½”ë“œë¥¼ í¸ì§‘í•  ìˆ˜ ìˆê³ , ì‹¤í–‰ì‹œì ì— ì˜¬ë°”ë¥¸ ë¬¸ìë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:335
msgid ""
"Python supports writing source code in UTF-8 by default, but you can use "
"almost any encoding if you declare the encoding being used.  This is done"
" by including a special comment as either the first or second line of the"
" source file::"
msgstr ""
"íŒŒì´ì¬ì€ ì†ŒìŠ¤ ì½”ë“œë¥¼ UTF-8ë¡œ ì‘ì„±í•˜ëŠ” ê²ƒì„ ê¸°ë³¸ìœ¼ë¡œ ì§€ì›í•˜ì§€ë§Œ, ì›í•˜ëŠ” ì¸ì½”ë”©ì„ ì„ ì–¸í•œë‹¤ë©´ ê±°ì˜ ëª¨ë“  ì¸ì½”ë”©ì„ ì“¸ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ì†ŒìŠ¤ íŒŒì¼ì˜ ì²« ë²ˆì§¸ ë˜ëŠ” ë‘ ë²ˆì§¸ ì¤„ì— íŠ¹ë³„í•œ ì£¼ì„ì„ í¬í•¨í•´ ì‘ë™í•©ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:339
msgid ""
"#!/usr/bin/env python\n"
"# -*- coding: latin-1 -*-\n"
"\n"
"u = 'abcdÃ©'\n"
"print(ord(u[-1]))"
msgstr ""

#: ../../howto/unicode.rst:345
msgid ""
"The syntax is inspired by Emacs's notation for specifying variables local"
" to a file.  Emacs supports many different variables, but Python only "
"supports 'coding'.  The ``-*-`` symbols indicate to Emacs that the "
"comment is special; they have no significance to Python but are a "
"convention.  Python looks for ``coding: name`` or ``coding=name`` in the "
"comment."
msgstr ""
"ì´ ë¬¸ë²•ì€ íŒŒì¼ì— ì§€ì—­ì ì¸ ë³€ìˆ˜ë¥¼ ëª…ì‹œí•˜ëŠ”ë° ì‚¬ìš©ë˜ëŠ” ì´ë§¥ìŠ¤ í‘œê¸°ë²•ì—ì„œ ì˜ê°ì„ ë°›ì•˜ìŠµë‹ˆë‹¤. ì´ë§¥ìŠ¤ëŠ” ìˆ˜ë§ì€ ì„œë¡œ ë‹¤ë¥¸ ë³€ìˆ˜ë¥¼ "
"ì§€ì›í•˜ì§€ë§Œ íŒŒì´ì¬ì€ ì˜¤ì§ 'coding'\\ë§Œì„ ì§€ì›í•©ë‹ˆë‹¤. ``-*-`` ê¸°í˜¸ëŠ” ì´ë§¥ìŠ¤ì—ê²Œ ì£¼ì„ì´ íŠ¹ë³„í•¨ì„ ë‚˜íƒ€ëƒ…ë‹ˆë‹¤; íŒŒì´ì¬ì—ê²Œ"
" ì•„ë¬´ ì˜ë¯¸ë„ ì—†ì§€ë§Œ ê·¸ì € ê´€ë¡€ë¥¼ ë”°ë¥´ëŠ” ê²ƒë¿ì…ë‹ˆë‹¤. íŒŒì´ì¬ì€ ì£¼ì„ì—ì„œ ``coding: name``\\ì´ë‚˜ "
"``coding=name``\\ì„ ì°¾ìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:351
msgid ""
"If you don't include such a comment, the default encoding used will be "
"UTF-8 as already mentioned.  See also :pep:`263` for more information."
msgstr ""
"ì´ëŸ¬í•œ ì£¼ì„ì„ í¬í•¨í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ì´ë¯¸ ì–¸ê¸‰í•œ ê²ƒì²˜ëŸ¼ ê¸°ë³¸ ì¸ì½”ë”©ìœ¼ë¡œ UTF-8ì´ ì‚¬ìš©ë©ë‹ˆë‹¤. :pep:`263`\\ì—ì„œ ì •ë³´ë¥¼ ë”"
" ë³´ì‹œê¸° ë°”ëë‹ˆë‹¤."

#: ../../howto/unicode.rst:356
msgid "Unicode Properties"
msgstr "ìœ ë‹ˆì½”ë“œ ì†ì„±"

#: ../../howto/unicode.rst:358
msgid ""
"The Unicode specification includes a database of information about code "
"points.  For each defined code point, the information includes the "
"character's name, its category, the numeric value if applicable (for "
"characters representing numeric concepts such as the Roman numerals, "
"fractions such as one-third and four-fifths, etc.).  There are also "
"display-related properties, such as how to use the code point in "
"bidirectional text."
msgstr ""
"ìœ ë‹ˆì½”ë“œ ì‚¬ì–‘ì€ ì½”ë“œ í¬ì¸íŠ¸ì— ëŒ€í•œ ì •ë³´ ë°ì´í„°ë² ì´ìŠ¤ë¥¼ í¬í•¨í•©ë‹ˆë‹¤. ê°ê° ì •ì˜í•œ ì½”ë“œ í¬ì¸íŠ¸ì— ëŒ€í•´ì„œ, ì •ë³´ëŠ” ë¬¸ìì˜ ì´ë¦„, "
"ì¹´í…Œê³ ë¦¬, ì ìš© ê°€ëŠ¥í•œ ìˆ«ì ê°’(ë¡œë§ˆ ìˆ«ìì™€ ê°™ì€ ìˆ«ì ê°œë…ì„ ë‚˜íƒ€ë‚´ëŠ” ë¬¸ì, 3ë¶„ì˜ 1ì´ë‚˜ 5ë¶„ì˜ 4ì™€ ê°™ì€ ë¶„ìˆ˜ë¥¼ í‘œí˜„í•˜ëŠ” ë¬¸ì"
" ë“±)ì„ í¬í•¨í•©ë‹ˆë‹¤. ì–‘ë°©í–¥ í…ìŠ¤íŠ¸ì—ì„œ ì½”ë“œ í¬ì¸íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ê³¼ ê°™ì€ ë””ìŠ¤í”Œë ˆì´ ê´€ë ¨ ì†ì„±ë„ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:366
msgid ""
"The following program displays some information about several characters,"
" and prints the numeric value of one particular character::"
msgstr "ì•„ë˜ì˜ í”„ë¡œê·¸ë¨ì€ ëª‡ëª‡ ê°œì˜ ë¬¸ìì— ëŒ€í•œ ì •ë³´ë¥¼ í‘œì‹œí•˜ê³  íŠ¹ì •í•œ ë¬¸ìì˜ ìˆ«ì ê°’ì„ ì¶œë ¥í•©ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:369
#, python-format
msgid ""
"import unicodedata\n"
"\n"
"u = chr(233) + chr(0x0bf2) + chr(3972) + chr(6000) + chr(13231)\n"
"\n"
"for i, c in enumerate(u):\n"
"    print(i, '%04x' % ord(c), unicodedata.category(c), end=\" \")\n"
"    print(unicodedata.name(c))\n"
"\n"
"# Get numeric value of second character\n"
"print(unicodedata.numeric(u[1]))"
msgstr ""

#: ../../howto/unicode.rst:380
msgid "When run, this prints:"
msgstr "ì‹¤í–‰í–ˆì„ ë•Œ ë‹¤ìŒì„ ì¶œë ¥í•©ë‹ˆë‹¤:"

#: ../../howto/unicode.rst:382
msgid ""
"0 00e9 Ll LATIN SMALL LETTER E WITH ACUTE\n"
"1 0bf2 No TAMIL NUMBER ONE THOUSAND\n"
"2 0f84 Mn TIBETAN MARK HALANTA\n"
"3 1770 Lo TAGBANWA LETTER SA\n"
"4 33af So SQUARE RAD OVER S SQUARED\n"
"1000.0"
msgstr ""

#: ../../howto/unicode.rst:391
msgid ""
"The category codes are abbreviations describing the nature of the "
"character. These are grouped into categories such as \"Letter\", "
"\"Number\", \"Punctuation\", or \"Symbol\", which in turn are broken up "
"into subcategories.  To take the codes from the above output, ``'Ll'`` "
"means 'Letter, lowercase', ``'No'`` means \"Number, other\", ``'Mn'`` is "
"\"Mark, nonspacing\", and ``'So'`` is \"Symbol, other\".  See `the "
"General Category Values section of the Unicode Character Database "
"documentation "
"<https://www.unicode.org/reports/tr44/#General_Category_Values>`_ for a "
"list of category codes."
msgstr ""
"ì¹´í…Œê³ ë¦¬ ì½”ë“œëŠ” ë¬¸ìì˜ ìœ í˜•ì„ ì„¤ëª…í•˜ëŠ” ì•½ì–´ì…ë‹ˆë‹¤. ì´ê²ƒë“¤ì€ \"Letter\", \"Number\", "
"\"Punctuation\", ë˜ëŠ” \"Symbol\"ê³¼ ê°™ì€ ì¹´í…Œê³ ë¦¬ë¡œ ë¬¶ì—¬ ìˆê³ , ì´ëŠ” í•˜ìœ„ ì¹´í…Œê³ ë¦¬ë¡œ ë‚˜ëˆ„ì–´ ì§‘ë‹ˆë‹¤. ìœ„ "
"ê²°ê³¼ë¬¼ì—ì„œ ì½”ë“œë¥¼ ê°€ì ¸ì™€ ë³´ë©´, ``'Ll'``\\ëŠ” 'Letter, lowercase', ``'No'``\\ëŠ” \"Number, "
"other\", ``'Mn'``\\ì€ \"Mark, nonspacing\", ê·¸ë¦¬ê³  ``'So'``\\ëŠ” \"Symbol, "
"other\"\\ë¥¼ ëœ»í•©ë‹ˆë‹¤. ì¹´í…Œê³ ë¦¬ ì½”ë“œ ëª©ë¡ì— ëŒ€í•´ì„œëŠ” `ìœ ë‹ˆì½”ë“œ ë¬¸ì ë°ì´í„°ë² ì´ìŠ¤ ë¬¸ì„œì˜ ì¼ë°˜ ì¹´í…Œê³ ë¦¬ê°’ ì„¹ì…˜ "
"<https://www.unicode.org/reports/tr44/#General_Category_Values>`_\\ì„ ë³´ì„¸ìš”."

#: ../../howto/unicode.rst:402
msgid "Comparing Strings"
msgstr "ë¬¸ìì—´ ë¹„êµ"

#: ../../howto/unicode.rst:404
msgid ""
"Unicode adds some complication to comparing strings, because the same set"
" of characters can be represented by different sequences of code points."
"  For example, a letter like 'Ãª' can be represented as a single code "
"point U+00EA, or as U+0065 U+0302, which is the code point for 'e' "
"followed by a code point for 'COMBINING CIRCUMFLEX ACCENT'.  These will "
"produce the same output when printed, but one is a string of length 1 and"
" the other is of length 2."
msgstr ""
"ìœ ë‹ˆì½”ë“œëŠ” ë¬¸ìì—´ ë¹„êµë¥¼ ì•½ê°„ ë³µì¡í•˜ê²Œ ë§Œë“­ë‹ˆë‹¤, ê°™ì€ ë¬¸ì ì§‘í•©ì´ ë‹¤ë¥¸ ì½”ë“œ í¬ì¸íŠ¸ ì‹œí€€ìŠ¤ë¡œ í‘œì‹œë  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì˜ˆë¥¼ "
"ë“¤ì–´, 'Ãª'ì™€ ê°™ì€ ë¬¸ìëŠ” ë‹¨ì¼ ì½”ë“œ í¬ì¸íŠ¸ U+00EAë¡œ í‘œì‹œë˜ê±°ë‚˜, 'e'ì˜ ì½”ë“œ í¬ì¸íŠ¸ ë‹¤ìŒì— 'COMBINING "
"CIRCUMFLEX ACCENT'ì˜ ì½”ë“œ í¬ì¸íŠ¸ê°€ ì˜¤ëŠ” U+0065 U+0302ë¡œ í‘œì‹œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì¸ì‡„ë  ë•Œ ê°™ì€ ì¶œë ¥ì„ "
"ìƒì„±í•˜ì§€ë§Œ, í•˜ë‚˜ëŠ” ê¸¸ì´ 1ì˜ ë¬¸ìì—´ì´ê³  ë‹¤ë¥¸ í•˜ë‚˜ëŠ” ê¸¸ì´ 2ì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:412
msgid ""
"One tool for a case-insensitive comparison is the :meth:`~str.casefold` "
"string method that converts a string to a case-insensitive form following"
" an algorithm described by the Unicode Standard.  This algorithm has "
"special handling for characters such as the German letter 'ÃŸ' (code point"
" U+00DF), which becomes the pair of lowercase letters 'ss'."
msgstr ""
"ëŒ€ì†Œ ë¬¸ìë¥¼ êµ¬ë¶„í•˜ì§€ ì•ŠëŠ” ë¹„êµë¥¼ ìœ„í•œ í•œ ê°€ì§€ ë„êµ¬ëŠ” ë¬¸ìì—´ì„ ìœ ë‹ˆì½”ë“œ í‘œì¤€ì— ì„¤ëª…ëœ ì•Œê³ ë¦¬ì¦˜ì— ë”°ë¼ ëŒ€ì†Œ ë¬¸ìë¥¼ êµ¬ë¶„í•˜ì§€ ì•ŠëŠ” "
"í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” :meth:`~str.casefold` ë¬¸ìì—´ ë©”ì„œë“œì…ë‹ˆë‹¤. ì´ ì•Œê³ ë¦¬ì¦˜ì€ ë…ì¼ì–´ ë¬¸ì 'ÃŸ'(ì½”ë“œ í¬ì¸íŠ¸ "
"U+00DF)ë¥¼ ì†Œë¬¸ì 'ss' ìŒì´ ë˜ë„ë¡ í•˜ëŠ” ê²ƒê³¼ ê°™ì´ ë¬¸ìë¥¼ íŠ¹ìˆ˜í•˜ê²Œ ì²˜ë¦¬í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:421
msgid ""
">>> street = 'GÃ¼rzenichstraÃŸe'\n"
">>> street.casefold()\n"
"'gÃ¼rzenichstrasse'"
msgstr ""

#: ../../howto/unicode.rst:425
#, fuzzy
msgid ""
"A second tool is the :mod:`unicodedata` module's "
":func:`~unicodedata.normalize` function that converts strings to one of "
"several normal forms, where letters followed by a combining character are"
" replaced with single characters.  :func:`~unicodedata.normalize` can be "
"used to perform string comparisons that won't falsely report inequality "
"if two strings use combining characters differently:"
msgstr ""
"ë‘ ë²ˆì§¸ ë„êµ¬ëŠ” :mod:`unicodedata` ëª¨ë“ˆì˜ :func:`~unicodedata.normalize` í•¨ìˆ˜ì¸ë°, ë¬¸ìì—´ì„"
" ì—¬ëŸ¬ ì •ê·œ í˜•ì‹ ì¤‘ í•˜ë‚˜ë¡œ ë³€í™˜í•©ë‹ˆë‹¤. ì—¬ê¸°ì„œ ë’¤ì— ê²°í•© ë¬¸ìê°€ ì˜¤ëŠ” ë¬¸ìëŠ” ë‹¨ì¼ ë¬¸ìë¡œ ë°”ë€ë‹ˆë‹¤. "
":func:`normalize`\\ë¥¼ ì‚¬ìš©í•˜ë©´ ë‘ ë¬¸ìì—´ì´ ë¬¸ì ê²°í•©ì„ ë‹¤ë¥´ê²Œ ì‚¬ìš©í•  ë•Œ ê°™ì§€ ì•Šë‹¤ê³  ì˜ëª» ë³´ê³ í•˜ì§€ ì•ŠëŠ” ë¬¸ìì—´ "
"ë¹„êµë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:"

#: ../../howto/unicode.rst:434
#, python-brace-format
msgid ""
"import unicodedata\n"
"\n"
"def compare_strs(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(s1) == NFD(s2)\n"
"\n"
"single_char = 'Ãª'\n"
"multiple_chars = '\\N{LATIN SMALL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"print('length of first string=', len(single_char))\n"
"print('length of second string=', len(multiple_chars))\n"
"print(compare_strs(single_char, multiple_chars))"
msgstr ""

#: ../../howto/unicode.rst:448
msgid "When run, this outputs:"
msgstr "ì‹¤í–‰í–ˆì„ ë•Œ ë‹¤ìŒì„ ì¶œë ¥í•©ë‹ˆë‹¤:"

#: ../../howto/unicode.rst:450
msgid ""
"$ python compare-strs.py\n"
"length of first string= 1\n"
"length of second string= 2\n"
"True"
msgstr ""

#: ../../howto/unicode.rst:457
msgid ""
"The first argument to the :func:`~unicodedata.normalize` function is a "
"string giving the desired normalization form, which can be one of 'NFC', "
"'NFKC', 'NFD', and 'NFKD'."
msgstr ""
":func:`~unicodedata.normalize` í•¨ìˆ˜ì˜ ì²« ë²ˆì§¸ ì¸ìëŠ” ì›í•˜ëŠ” ì •ê·œí™” í˜•ì‹ì„ ì œê³µí•˜ëŠ” ë¬¸ìì—´ì…ë‹ˆë‹¤. "
"'NFC', 'NFKC', 'NFD' ë° 'NFKD' ì¤‘ í•˜ë‚˜ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:461
msgid "The Unicode Standard also specifies how to do caseless comparisons::"
msgstr "ìœ ë‹ˆì½”ë“œ í‘œì¤€ì€ ë˜í•œ ëŒ€ì†Œ ë¬¸ìë¥¼ êµ¬ë³„í•˜ì§€ ì•Šê³  ë¹„êµí•˜ì§€ ì•ŠëŠ” ë°©ë²•ì„ ì§€ì •í•©ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:463
#, python-brace-format
msgid ""
"import unicodedata\n"
"\n"
"def compare_caseless(s1, s2):\n"
"    def NFD(s):\n"
"        return unicodedata.normalize('NFD', s)\n"
"\n"
"    return NFD(NFD(s1).casefold()) == NFD(NFD(s2).casefold())\n"
"\n"
"# Example usage\n"
"single_char = 'Ãª'\n"
"multiple_chars = '\\N{LATIN CAPITAL LETTER E}\\N{COMBINING CIRCUMFLEX "
"ACCENT}'\n"
"\n"
"print(compare_caseless(single_char, multiple_chars))"
msgstr ""

#: ../../howto/unicode.rst:477
#, fuzzy
msgid ""
"This will print ``True``.  (Why is :func:`!NFD` invoked twice?  Because "
"there are a few characters that make :meth:`~str.casefold` return a non-"
"normalized string, so the result needs to be normalized again. See "
"section 3.13 of the Unicode Standard for a discussion and an example.)"
msgstr ""
"ì´ê²ƒì€ ``True``\\ë¥¼ ì¸ì‡„í•©ë‹ˆë‹¤. (ì™œ :func:`NFD`\\ê°€ ë‘ ë²ˆ í˜¸ì¶œë ê¹Œìš”? :meth:`casefold`\\ê°€ "
"ì •ê·œí™”ë˜ì§€ ì•Šì€ ë¬¸ìì—´ì„ ë°˜í™˜í•˜ë„ë¡ í•˜ëŠ” ë¬¸ìê°€ ëª‡ ê°œ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤, ê·¸ë˜ì„œ ê²°ê³¼ë¥¼ ë‹¤ì‹œ ì •ê·œí™”í•´ì•¼ í•©ë‹ˆë‹¤. í† ë¡ ê³¼ ì˜ˆì œëŠ” "
"ìœ ë‹ˆì½”ë“œ í‘œì¤€ì˜ 3.13 ì ˆì„ ì°¸ì¡°í•˜ì‹­ì‹œì˜¤.)"

#: ../../howto/unicode.rst:484
msgid "Unicode Regular Expressions"
msgstr "ìœ ë‹ˆì½”ë“œ ì •ê·œì‹"

#: ../../howto/unicode.rst:486
msgid ""
"The regular expressions supported by the :mod:`re` module can be provided"
" either as bytes or strings.  Some of the special character sequences "
"such as ``\\d`` and ``\\w`` have different meanings depending on whether "
"the pattern is supplied as bytes or a string.  For example, ``\\d`` will "
"match the characters ``[0-9]`` in bytes but in strings will match any "
"character that's in the ``'Nd'`` category."
msgstr ""
":mod:`re` ëª¨ë“ˆì´ ì§€ì›í•˜ëŠ” ì •ê·œì‹ì€ ë°”ì´íŠ¸ì—´ ë˜ëŠ” ë¬¸ìì—´ë¡œ ì œê³µë©ë‹ˆë‹¤. ``\\d``\\ì™€ ``\\w`` ê°™ì€ íŠ¹ë³„í•œ ë¬¸ì "
"ì‹œí€€ìŠ¤ ëª‡ëª‡ì€ íŒ¨í„´ì´ ë°”ì´íŠ¸ì—´ ë˜ëŠ” ë¬¸ìì—´ì— ì˜í•´ ì§€ì›ë˜ëŠ”ì§€ ì—¬ë¶€ì— ë”°ë¼ ë‹¤ë¥¸ ì˜ë¯¸ê°€ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë°”ì´íŠ¸ì—´ì—ì„œ "
"``\\d``\\ëŠ” ``[0-9]``\\ì™€ ì¼ì¹˜í•˜ì§€ë§Œ, ë¬¸ìì—´ì—ì„œëŠ” ``'Nd'`` ì¹´í…Œê³ ë¦¬ì— ì†í•˜ëŠ” ì•„ë¬´ ë¬¸ìì™€ ì¼ì¹˜í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:493
msgid ""
"The string in this example has the number 57 written in both Thai and "
"Arabic numerals::"
msgstr "ì´ ì˜ˆì œì˜ ë¬¸ìì—´ì€ íƒœêµ­ê³¼ ì•„ë¼ë¹„ì•„ ìˆ«ìë¡œ ì“°ì¸ ìˆ«ì 57ì„ ê°–ê³  ìˆìŠµë‹ˆë‹¤::"

#: ../../howto/unicode.rst:496
msgid ""
"import re\n"
"p = re.compile(r'\\d+')\n"
"\n"
"s = \"Over \\u0e55\\u0e57 57 flavours\"\n"
"m = p.search(s)\n"
"print(repr(m.group()))"
msgstr ""

#: ../../howto/unicode.rst:503
msgid ""
"When executed, ``\\d+`` will match the Thai numerals and print them out."
"  If you supply the :const:`re.ASCII` flag to :func:`~re.compile`, "
"``\\d+`` will match the substring \"57\" instead."
msgstr ""
"ì‹¤í–‰í–ˆì„ ë•Œ, ``\\d+``\\ì€ íƒœêµ­ ìˆ«ìì™€ ì¼ì¹˜í•˜ê³  ì¶œë ¥í•©ë‹ˆë‹¤. :const:`re.ASCII` í”Œë˜ê·¸ë¥¼ "
":func:`~re.compile`\\ì— ì œê³µí–ˆì„ ê²½ìš°, ``\\d+``\\ëŠ” ë¶€ë¶„ ë¬¸ìì—´ \"57\"ì„ ëŒ€ì‹  ì¼ì¹˜ì‹œí‚µë‹ˆë‹¤."

#: ../../howto/unicode.rst:507
msgid ""
"Similarly, ``\\w`` matches a wide variety of Unicode characters but only "
"``[a-zA-Z0-9_]`` in bytes or if :const:`re.ASCII` is supplied, and "
"``\\s`` will match either Unicode whitespace characters or ``[ "
"\\t\\n\\r\\f\\v]``."
msgstr ""
"ë¹„ìŠ·í•˜ê²Œ, ``\\w``\\ëŠ” ë§¤ìš° ë‹¤ì–‘í•œ ìœ ë‹ˆì½”ë“œì™€ ì¼ì¹˜í•˜ì§€ë§Œ, ë°”ì´íŠ¸ì—´ì´ê±°ë‚˜ :const:`re.ASCII`\\ê°€ ì œê³µë˜ë©´ ì˜¤ì§"
" ``[a-zA-Z0-9_]``\\ê³¼ ì¼ì¹˜í•˜ê³ , ``\\s``\\ëŠ” ìœ ë‹ˆì½”ë“œ ê³µë°± ë¬¸ìë‚˜ ``[ "
"\\t\\n\\r\\f\\v]``\\ì™€ ì¼ì¹˜í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:518
msgid "Some good alternative discussions of Python's Unicode support are:"
msgstr "íŒŒì´ì¬ ìœ ë‹ˆì½”ë“œ ì§€ì›ì— ëŒ€í•œ ëª‡ ê°œì˜ ì¢‹ì€ ëŒ€ì•ˆ í† ë¡ ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:"

#: ../../howto/unicode.rst:520
#, fuzzy
msgid ""
"`Processing Text Files in Python 3 <https://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_,"
" by Nick Coghlan."
msgstr ""
"Nick Coghlanì˜ `íŒŒì´ì¬ 3ì˜ í…ìŠ¤íŠ¸ íŒŒì¼ ì²˜ë¦¬ <http://python-"
"notes.curiousefficiency.org/en/latest/python3/text_file_processing.html>`_."

#: ../../howto/unicode.rst:521
msgid ""
"`Pragmatic Unicode <https://nedbatchelder.com/text/unipain.html>`_, a "
"PyCon 2012 presentation by Ned Batchelder."
msgstr ""
"Ned Batchelderê°€ PyCon 2012ì—ì„œ ë°œí‘œí•œ `ì‹¤ìš© ìœ ë‹ˆì½”ë“œ "
"<https://nedbatchelder.com/text/unipain.html>`_."

#: ../../howto/unicode.rst:523
msgid ""
"The :class:`str` type is described in the Python library reference at "
":ref:`textseq`."
msgstr ":class:`str` íƒ€ì…ì€ íŒŒì´ì¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë ˆí¼ëŸ°ìŠ¤ :ref:`textseq`\\ì— ì„¤ëª…ë˜ì–´ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:526
msgid "The documentation for the :mod:`unicodedata` module."
msgstr ":mod:`unicodedata` ëª¨ë“ˆì— ëŒ€í•œ ë¬¸ì„œì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:528
msgid "The documentation for the :mod:`codecs` module."
msgstr ":mod:`codecs` ëª¨ë“ˆì— ëŒ€í•œ ë¬¸ì„œì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:530
msgid ""
"Marc-AndrÃ© Lemburg gave `a presentation titled \"Python and Unicode\" "
"(PDF slides) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_ at EuroPython 2002.  The slides are an excellent "
"overview of the design of Python 2's Unicode features (where the Unicode "
"string type is called ``unicode`` and literals start with ``u``)."
msgstr ""
"Marc-AndrÃ© LemburgëŠ” EuroPython 2002ì—ì„œ ë°œí‘œí•œ `\"íŒŒì´ì¬ê³¼ ìœ ë‹ˆì½”ë“œ\"ë¼ëŠ” ì œëª©ì˜ í”„ë ˆì  í…Œì´ì…˜ "
"(PDF ìŠ¬ë¼ì´ë“œ) <https://downloads.egenix.com/python/Unicode-"
"EPC2002-Talk.pdf>`_\\ì„ ì£¼ì—ˆìŠµë‹ˆë‹¤. ì´ ìŠ¬ë¼ì´ë“œëŠ” íŒŒì´ì¬ 2ì˜ ìœ ë‹ˆì½”ë“œ ê¸°ëŠ¥(ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ íƒ€ì…ì„ "
"``unicode``\\ë¼ ë¶€ë¥´ê³  ë¦¬í„°ëŸ´ ``u``\\ë¡œ ì‹œì‘í•˜ëŠ”) ë””ìì¸ì— ëŒ€í•œ í›Œë¥­í•œ ê°œìš”ì„œì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:538
msgid "Reading and Writing Unicode Data"
msgstr "ìœ ë‹ˆì½”ë“œ ë°ì´í„° ì½ê³  ì“°ê¸°"

#: ../../howto/unicode.rst:540
msgid ""
"Once you've written some code that works with Unicode data, the next "
"problem is input/output.  How do you get Unicode strings into your "
"program, and how do you convert Unicode into a form suitable for storage "
"or transmission?"
msgstr ""
"ìœ ë‹ˆì½”ë“œ ë°ì´í„°ë¡œ ë™ì‘í•˜ëŠ” ì½”ë“œë¥¼ ì‘ì„±í–ˆë‹¤ë©´, ë‹¤ìŒì€ ì…ì¶œë ¥ì´ ë¬¸ì œì…ë‹ˆë‹¤. í”„ë¡œê·¸ë¨ì— ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì„ ì–´ë–»ê²Œ ì§‘ì–´ë„£ì„ ê²ƒì¸ê°€, "
"ê·¸ë¦¬ê³  ìœ ë‹ˆì½”ë“œë¥¼ ì–´ë–»ê²Œ ì €ì¥ ë˜ëŠ” ì „ì†¡ì— ì í•©í•œ í˜•ì‹ìœ¼ë¡œ ìœ ë‹ˆì½”ë“œë¥¼ ì „í™˜í•  ê²ƒì¸ê°€?"

#: ../../howto/unicode.rst:544
msgid ""
"It's possible that you may not need to do anything depending on your "
"input sources and output destinations; you should check whether the "
"libraries used in your application support Unicode natively.  XML parsers"
" often return Unicode data, for example.  Many relational databases also "
"support Unicode-valued columns and can return Unicode values from an SQL "
"query."
msgstr ""
"ì…ë ¥ ì†ŒìŠ¤ ë° ì¶œë ¥ ëŒ€ìƒì— ë”°ë¼ ì•„ë¬´ê²ƒë„ í•  í•„ìš” ì—†ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤; ì‘ìš© í”„ë¡œê·¸ë¨ì—ì„œ ì‚¬ìš©ë˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ìœ ë‹ˆì½”ë“œë¥¼ ê¸°ë³¸ "
"ì§€ì›í•˜ëŠ”ì§€ í™•ì¸í•´ì•¼ ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, XML íŒŒì„œëŠ” ì¢…ì¢… ìœ ë‹ˆì½”ë“œ ë°ì´í„°ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤. ë§ì€ ê´€ê³„í˜• ë°ì´í„°ë² ì´ìŠ¤ ì—­ì‹œ ìœ ë‹ˆì½”ë“œ "
"ê°’ ì¹¼ëŸ¼ì„ ì§€ì›í•˜ê³ , SQL ì§ˆì˜ë¡œë¶€í„° ìœ ë‹ˆì½”ë“œ ê°’ì„ ë°˜í™˜ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:550
msgid ""
"Unicode data is usually converted to a particular encoding before it gets"
" written to disk or sent over a socket.  It's possible to do all the work"
" yourself: open a file, read an 8-bit bytes object from it, and convert "
"the bytes with ``bytes.decode(encoding)``.  However, the manual approach "
"is not recommended."
msgstr ""
"ìœ ë‹ˆì½”ë“œ ë°ì´í„°ëŠ” ë””ìŠ¤í¬ì— ì“°ì´ê±°ë‚˜ ì†Œì¼“ì— ì „ë‹¬ë˜ê¸° ì „ì— ë³´í†µ íŠ¹ì • ì¸ì½”ë”©ìœ¼ë¡œ ë³€ê²½ë©ë‹ˆë‹¤. ë‹¤ìŒì˜ ëª¨ë“  ì‘ì—…ì„ ì§ì ‘ í•  ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤: íŒŒì¼ ì—´ê¸°, 8-bit ë°”ì´íŠ¸ì—´ ê°ì²´ ì½ê¸°, ê·¸ë¦¬ê³  ``bytes.decode(encoding)``\\ë¡œ ë°”ì´íŠ¸ì—´ "
"ì „í™˜í•˜ê¸°. í•˜ì§€ë§Œ ì´ëŸ¬í•œ ìˆ˜ë™ ì ‘ê·¼ì€ ê¶Œì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:555
msgid ""
"One problem is the multi-byte nature of encodings; one Unicode character "
"can be represented by several bytes.  If you want to read the file in "
"arbitrary-sized chunks (say, 1024 or 4096 bytes), you need to write "
"error-handling code to catch the case where only part of the bytes "
"encoding a single Unicode character are read at the end of a chunk.  One "
"solution would be to read the entire file into memory and then perform "
"the decoding, but that prevents you from working with files that are "
"extremely large; if you need to read a 2 GiB file, you need 2 GiB of RAM."
" (More, really, since for at least a moment you'd need to have both the "
"encoded string and its Unicode version in memory.)"
msgstr ""
"í•œ ê°€ì§€ ë¬¸ì œëŠ” ì¸ì½”ë”©ì˜ ë©€í‹° ë°”ì´íŠ¸ íŠ¹ì„±ì…ë‹ˆë‹¤; í•˜ë‚˜ì˜ ìœ ë‹ˆì½”ë“œ ë¬¸ìëŠ” ì—¬ëŸ¬ ë°”ì´íŠ¸ë¡œ í‘œí˜„ë©ë‹ˆë‹¤. ì„ì˜ì˜ í¬ê¸°ì˜ ì²­í¬ë¡œ íŒŒì¼ì„ "
"ì½ìœ¼ë ¤ë©´ (1024 ë˜ëŠ” 4096ë°”ì´íŠ¸ë¼ í•  ë•Œ), ë‹¨ì¼ ìœ ë‹ˆì½”ë“œ ë¬¸ìë¥¼ ì¸ì½”ë”©í•˜ëŠ” ë°”ì´íŠ¸ ì¼ë¶€ë§Œ ì²­í¬ ëì— ì½ëŠ” ê²½ìš°ë¥¼ ì¡ê¸° ìœ„í•´"
" ì—ëŸ¬ ì²˜ë¦¬ ì½”ë“œë¥¼ ì‘ì„±í•´ì•¼ í•©ë‹ˆë‹¤. í•œ ê°€ì§€ í•´ê²°ì±…ì€ íŒŒì¼ ì „ì²´ë¥¼ ë©”ëª¨ë¦¬ì— ì½ê³  ë””ì½”ë”©ì„ ìˆ˜í–‰í•˜ëŠ” ê²ƒì´ì§€ë§Œ, ê·¹ë„ë¡œ í° íŒŒì¼ë¡œ "
"ì‘ì—…í•˜ëŠ” ê²ƒì„ ë°©í•´í•©ë‹ˆë‹¤; 2ê¸°ê°€ë°”ì´íŠ¸ íŒŒì¼ì„ ì½ì–´ì•¼ë§Œ í•œë‹¤ë©´, 2ê¸°ê°€ë°”ì´íŠ¸ ë©”ëª¨ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤. (ì¸ì½”ë”©ëœ ë¬¸ìì—´ê³¼ ìœ ë‹ˆì½”ë“œ "
"ë²„ì „ì„ ì ê¹ ë©”ëª¨ë¦¬ì— ê°€ì§€ê³  ìˆì–´ì•¼ í•˜ë¯€ë¡œ ì‹¤ì œë¡œëŠ” ë” í•„ìš”í•©ë‹ˆë‹¤.)"

#: ../../howto/unicode.rst:565
msgid ""
"The solution would be to use the low-level decoding interface to catch "
"the case of partial coding sequences.  The work of implementing this has "
"already been done for you: the built-in :func:`open` function can return "
"a file-like object that assumes the file's contents are in a specified "
"encoding and accepts Unicode parameters for methods such as "
":meth:`~io.TextIOBase.read` and :meth:`~io.TextIOBase.write`.  This works"
" through :func:`open`\\'s *encoding* and *errors* parameters which are "
"interpreted just like those in :meth:`str.encode` and "
":meth:`bytes.decode`."
msgstr ""
"ë¶€ë¶„ ì½”ë”© ì‹œí€€ìŠ¤ì˜ ê²½ìš°ë¥¼ ì¡ê¸° ìœ„í•´ ì €ìˆ˜ì¤€ ë””ì½”ë”© ì¸í„°í˜ì´ìŠ¤ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ í•´ê²°ë°©ë²•ì…ë‹ˆë‹¤. ì´ë¥¼ êµ¬í˜„í•˜ëŠ” ì‘ì—…ì€ ì´ë¯¸ "
"ìˆ˜í–‰ë˜ì—ˆìŠµë‹ˆë‹¤: ë‚´ì¥ :func:`open` í•¨ìˆ˜ëŠ” íŒŒì¼ ë‚´ìš©ë¬¼ì´ ì§€ì •ëœ ì¸ì½”ë”©ì´ë¼ê³  ê°€ì •í•˜ê³ , "
":meth:`~io.TextIOBase.read` ë˜ëŠ” :meth:`~io.TextIOBase.write`\\ì™€ ê°™ì€ ë©”ì„œë“œì—ì„œ "
"ìœ ë‹ˆì½”ë“œ ë§¤ê°œë³€ìˆ˜ë¥¼ ë°›ì•„ë“¤ì´ëŠ” íŒŒì¼ ê°ì²´ë¥¼ ë°˜í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” :meth:`str.encode`\\ì™€ "
":meth:`bytes.decode`\\ì—ì„œì²˜ëŸ¼ í•´ì„ë˜ëŠ” :func:`open`\\ì˜ *encoding*\\ê³¼ *errors* "
"ë§¤ê°œë³€ìˆ˜ë¥¼ í†µí•´ ì‘ë™í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:574
msgid "Reading Unicode from a file is therefore simple::"
msgstr "ê·¸ëŸ¬ë¯€ë¡œ íŒŒì¼ì—ì„œ ìœ ë‹ˆì½”ë“œë¥¼ ì½ëŠ” ê²ƒì€ ê°„ë‹¨í•©ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:576
msgid ""
"with open('unicode.txt', encoding='utf-8') as f:\n"
"    for line in f:\n"
"        print(repr(line))"
msgstr ""

#: ../../howto/unicode.rst:580
msgid ""
"It's also possible to open files in update mode, allowing both reading "
"and writing::"
msgstr "ì—…ë°ì´íŠ¸ ëª¨ë“œë¡œ íŒŒì¼ì„ ì—´ì–´ ì½ê¸° ë˜ëŠ” ì“°ê¸°ë¥¼ í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤::"

#: ../../howto/unicode.rst:583
msgid ""
"with open('test', encoding='utf-8', mode='w+') as f:\n"
"    f.write('\\u4500 blah blah blah\\n')\n"
"    f.seek(0)\n"
"    print(repr(f.readline()[:1]))"
msgstr ""

#: ../../howto/unicode.rst:588
msgid ""
"The Unicode character ``U+FEFF`` is used as a byte-order mark (BOM), and "
"is often written as the first character of a file in order to assist with"
" autodetection of the file's byte ordering.  Some encodings, such as "
"UTF-16, expect a BOM to be present at the start of a file; when such an "
"encoding is used, the BOM will be automatically written as the first "
"character and will be silently dropped when the file is read.  There are "
"variants of these encodings, such as 'utf-16-le' and 'utf-16-be' for "
"little-endian and big-endian encodings, that specify one particular byte "
"ordering and don't skip the BOM."
msgstr ""
"ìœ ë‹ˆì½”ë“œ ë¬¸ì ``U+FEFF``\\ëŠ” ë°”ì´íŠ¸ ìˆœì„œ í‘œì‹œ(BOM)ë¡œ ì‚¬ìš©ë˜ê³ , íŒŒì¼ì˜ ë°”ì´íŠ¸ ìˆœì„œë¥¼ ìë™ê°ì§€í•˜ê¸° ìœ„í•´ íŒŒì¼ì˜ ë§¨ "
"ì²˜ìŒ ë¬¸ìë¡œ ì“°ì´ê¸°ë„ í•©ë‹ˆë‹¤. UTF-16ê³¼ ê°™ì€ ì¼ë¶€ ì¸ì½”ë”©ì—ì„œëŠ” íŒŒì¼ ì‹œì‘ ë¶€ë¶„ì— BOMì´ ìˆì–´ì•¼í•©ë‹ˆë‹¤; ì´ëŸ¬í•œ ì¸ì½”ë”©ì´ ì“°ì¼ "
"ë•Œ, BOMì´ ìë™ìœ¼ë¡œ ì²«ë²ˆì§¸ ë¬¸ìë¡œ ì‘ì„±ë˜ê³  íŒŒì¼ì„ ì½ì„ ë•Œ ì¡°ìš©íˆ ì—†ì–´ì§‘ë‹ˆë‹¤. ë¦¬í‹€ ì—”ë””ì•ˆê³¼ ë¹… ì—”ë””ì•ˆì„ ìœ„í•´ íŠ¹ì • ë°”ì´íŠ¸ "
"ìˆœì„œë¥¼ ì§€ì •í•˜ê³  BOMì„ ìƒëµí•˜ì§€ ì•ŠëŠ” 'utf-16-le'ì™€ 'utf-16-be' ê°™ì€ ì¸ì½”ë”©ì˜ ë³€ì¢…ë“¤ì´ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:597
msgid ""
"In some areas, it is also convention to use a \"BOM\" at the start of "
"UTF-8 encoded files; the name is misleading since UTF-8 is not byte-order"
" dependent. The mark simply announces that the file is encoded in UTF-8."
"  For reading such files, use the 'utf-8-sig' codec to automatically skip"
" the mark if present."
msgstr ""
"ì¼ë¶€ ì˜ì—­ì—ì„œëŠ” UTF-8ë¡œ ì¸ì½”ë”©ëœ íŒŒì¼ì˜ ì‹œì‘ ë¶€ë¶„ì— \"BOM\"ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê´€ë¡€ì´ê¸°ë„ í•©ë‹ˆë‹¤; UTF-8ì€ ë°”ì´íŠ¸ "
"ìˆœì„œì— ì˜ì¡´í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì´ ì´ë¦„ì€ ì˜¤í•´ì˜ ì†Œì§€ê°€ ìˆìŠµë‹ˆë‹¤. ì´ í‘œì‹œëŠ” ì´ íŒŒì¼ì´ UTF-8ë¡œ ì¸ì½”ë”©í–ˆìŒì„ ë‹¨ìˆœíˆ ì•Œë¦½ë‹ˆë‹¤. ê·¸ëŸ° "
"íŒŒì¼ì„ ì½ìœ¼ë ¤ë©´ ìë™ìœ¼ë¡œ ì´ í‘œì‹œë¥¼ ê±´ë„ˆë›°ê¸° ìœ„í•´ 'utf-8-sig' ì½”ë±ì„ ì‚¬ìš©í•˜ì„¸ìš”."

#: ../../howto/unicode.rst:604
msgid "Unicode filenames"
msgstr "ìœ ë‹ˆì½”ë“œ íŒŒì¼ ì´ë¦„"

#: ../../howto/unicode.rst:606
#, fuzzy
msgid ""
"Most of the operating systems in common use today support filenames that "
"contain arbitrary Unicode characters.  Usually this is implemented by "
"converting the Unicode string into some encoding that varies depending on"
" the system.  Today Python is converging on using UTF-8: Python on MacOS "
"has used UTF-8 for several versions, and Python 3.6 switched to using "
"UTF-8 on Windows as well.  On Unix systems, there will only be a "
":term:`filesystem encoding <filesystem encoding and error handler>`. if "
"you've set the ``LANG`` or ``LC_CTYPE`` environment variables; if you "
"haven't, the default encoding is again UTF-8."
msgstr ""
"ì˜¤ëŠ˜ë‚  ìì£¼ ì“°ì´ëŠ” ëŒ€ë¶€ë¶„ì˜ ìš´ì˜ì²´ì œëŠ” ì„ì˜ì˜ ìœ ë‹ˆì½”ë“œ ë¬¸ìë¥¼ ê°–ëŠ” íŒŒì¼ ì´ë¦„ì„ ì§€ì›í•©ë‹ˆë‹¤. ì´ëŠ” ë³´í†µ ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì„ ì‹œìŠ¤í…œì— "
"ì˜ì¡´ì ì¸ ì¸ì½”ë”©ìœ¼ë¡œ ë³€í™˜í•˜ì—¬ êµ¬í˜„í•©ë‹ˆë‹¤. ì˜¤ëŠ˜ë‚ ì˜ íŒŒì´ì¬ì€ UTF-8ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒìœ¼ë¡œ ìˆ˜ë ´í•˜ê³  ìˆìŠµë‹ˆë‹¤: ë§¥ OS Xì˜ íŒŒì´ì¬ì€ "
"ì—¬ëŸ¬ ë²„ì „ì—ì„œ UTF-8ì„ ì‚¬ìš©í–ˆìœ¼ë©°, íŒŒì´ì¬ 3.6ì€ ìœˆë„ìš°ì—ì„œë„ UTF-8ì„ ì‚¬ìš©í•˜ë„ë¡ ì „í™˜í–ˆìŠµë‹ˆë‹¤. ìœ ë‹‰ìŠ¤ ì‹œìŠ¤í…œì—ì„œ "
"``LANG`` ë˜ëŠ” ``LC_CTYPE`` í™˜ê²½ë³€ìˆ˜ë¥¼ ì„¤ì •í–ˆë‹¤ë©´, íŒŒì¼ ì‹œìŠ¤í…œ ì¸ì½”ë”©ë§Œì„ ì‚¬ìš©í•©ë‹ˆë‹¤; ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°, ê¸°ë³¸ "
"ì¸ì½”ë”©ì€ ë‹¤ì‹œ UTF-8ì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:616
msgid ""
"The :func:`sys.getfilesystemencoding` function returns the encoding to "
"use on your current system, in case you want to do the encoding manually,"
" but there's not much reason to bother.  When opening a file for reading "
"or writing, you can usually just provide the Unicode string as the "
"filename, and it will be automatically converted to the right encoding "
"for you::"
msgstr ""
"ì¸ì½”ë”©ì„ ìˆ˜ë™ìœ¼ë¡œ í•˜ê³  ì‹¶ì„ ë•Œë¥¼ ëŒ€ë¹„í•˜ì—¬ :func:`sys.getfilesystemencoding` í•¨ìˆ˜ëŠ” í˜„ì¬ ì‚¬ìš©í•˜ê³  ìˆëŠ” "
"ì‹œìŠ¤í…œì˜ ì¸ì½”ë”©ì„ ë°˜í™˜í•˜ì§€ë§Œ, ê·€ì°®ê²Œ ê·¸ëŸ´ ì´ìœ ëŠ” ì—†ìŠµë‹ˆë‹¤. ì½ê¸° ë˜ëŠ” ì“°ê¸°ë¥¼ ìœ„í•´ íŒŒì¼ì„ ì—´ ë•Œ, ë³´í†µ íŒŒì¼ ì´ë¦„ìœ¼ë¡œ ìœ ë‹ˆì½”ë“œ "
"ë¬¸ìì—´ì„ ì œê³µí•˜ê¸°ë§Œ í•˜ë©´ ë˜ê³ , ìë™ìœ¼ë¡œ ì˜¬ë°”ë¥¸ ì¸ì½”ë”©ìœ¼ë¡œ ë³€í™˜ë©ë‹ˆë‹¤::"

#: ../../howto/unicode.rst:622
msgid ""
"filename = 'filename\\u4500abc'\n"
"with open(filename, 'w') as f:\n"
"    f.write('blah\\n')"
msgstr ""

#: ../../howto/unicode.rst:626
msgid ""
"Functions in the :mod:`os` module such as :func:`os.stat` will also "
"accept Unicode filenames."
msgstr ":mod:`os` ëª¨ë“ˆ ì•ˆì˜ :func:`os.stat`\\ê³¼ ê°™ì€ í•¨ìˆ˜ ì—­ì‹œ ìœ ë‹ˆì½”ë“œ íŒŒì¼ ì´ë¦„ì„ ìˆ˜ìš©í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:629
#, fuzzy
msgid ""
"The :func:`os.listdir` function returns filenames, which raises an issue:"
" should it return the Unicode version of filenames, or should it return "
"bytes containing the encoded versions?  :func:`os.listdir` can do both, "
"depending on whether you provided the directory path as bytes or a "
"Unicode string.  If you pass a Unicode string as the path, filenames will"
" be decoded using the filesystem's encoding and a list of Unicode strings"
" will be returned, while passing a byte path will return the filenames as"
" bytes.  For example, assuming the default :term:`filesystem encoding "
"<filesystem encoding and error handler>` is UTF-8, running the following "
"program::"
msgstr ""
":func:`os.listdir` í•¨ìˆ˜ëŠ” íŒŒì¼ ì´ë¦„ì„ ë°˜í™˜í•˜ëŠ”ë°, ë¬¸ì œë¥¼ ì¼ìœ¼í‚µë‹ˆë‹¤: ì´ í•¨ìˆ˜ê°€ íŒŒì¼ ì´ë¦„ì˜ ìœ ë‹ˆì½”ë“œ ë²„ì „ì„ "
"ë°˜í™˜í•´ì•¼ í• ê¹Œìš”? ì•„ë‹ˆë©´ ì¸ì½”ë”© ë²„ì „ì„ í¬í•¨í•œ ë°”ì´íŠ¸ì—´ì„ ë°˜í™˜í•´ì•¼ í• ê¹Œìš”? :func:`os.listdir`\\ì€ ë””ë ‰í„°ë¦¬ ê²½ë¡œë¥¼ "
"ë°”ì´íŠ¸ì—´ì´ë‚˜ ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ë¡œ ì œê³µí–ˆëŠ”ì§€ì— ë”°ë¼ ë‘˜ ëª¨ë‘ë¥¼ ìˆ˜í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê²½ë¡œë¥¼ ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ë¡œ ë„˜ê²¨ì£¼ì—ˆì„ ë•Œ íŒŒì¼ ì´ë¦„ì€"
" íŒŒì¼ ì‹œìŠ¤í…œì˜ ì¸ì½”ë”©ìœ¼ë¡œ ë””ì½”ë”©ë˜ê³  ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì˜ ëª©ë¡ì´ ë°˜í™˜ë˜ëŠ” ë°˜ë©´, ë°”ì´íŠ¸ë¥¼ ë„˜ê²¨ì£¼ì—ˆì„ ë•Œ íŒŒì¼ ì´ë¦„ì„ ë°”ì´íŠ¸ì—´ë¡œ "
"ë°˜í™˜í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ê¸°ë³¸ íŒŒì¼ ì‹œìŠ¤í…œ ì¸ì½”ë”©ì´ UTF-8ì´ë¼ ê°€ì •í•  ë•Œ, ë‹¤ìŒì˜ í”„ë¡œê·¸ë¨ì„ ì‹¤í–‰í•  ì‹œ::"

#: ../../howto/unicode.rst:639
msgid ""
"fn = 'filename\\u4500abc'\n"
"f = open(fn, 'w')\n"
"f.close()\n"
"\n"
"import os\n"
"print(os.listdir(b'.'))\n"
"print(os.listdir('.'))"
msgstr ""

#: ../../howto/unicode.rst:647
msgid "will produce the following output:"
msgstr "ì•„ë˜ì˜ ì¶œë ¥ì„ ë§Œë“¤ ê²ƒì…ë‹ˆë‹¤:"

#: ../../howto/unicode.rst:649
msgid ""
"$ python listdir-test.py\n"
"[b'filename\\xe4\\x94\\x80abc', ...]\n"
"['filename\\u4500abc', ...]"
msgstr ""

#: ../../howto/unicode.rst:655
msgid ""
"The first list contains UTF-8-encoded filenames, and the second list "
"contains the Unicode versions."
msgstr "ì²«ë²ˆì§¸ ë¦¬ìŠ¤íŠ¸ëŠ” UTF-8ë¡œ ì¸ì½”ë”©ëœ íŒŒì¼ ì´ë¦„ì„ ê°–ê³ , ë‘ ë²ˆì§¸ ë¦¬ìŠ¤íŠ¸ëŠ” ìœ ë‹ˆì½”ë“œ ë²„ì „ì„ ê°–ìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:658
msgid ""
"Note that on most occasions, you should can just stick with using Unicode"
" with these APIs.  The bytes APIs should only be used on systems where "
"undecodable file names can be present; that's pretty much only Unix "
"systems now."
msgstr ""
"ëŒ€ë¶€ë¶„ì˜ ê²½ìš°, ì´ëŸ¬í•œ APIë¡œ ìœ ë‹ˆì½”ë“œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆìŒì— ìœ ì˜í•˜ì‹­ì‹œì˜¤. ë°”ì´íŠ¸ì—´ APIëŠ” ë””ì½”ë”©í•  ìˆ˜ ì—†ëŠ” íŒŒì¼ ì´ë¦„ì´ ì¡´ì¬í•˜ëŠ”"
" ì‹œìŠ¤í…œì—ì„œë§Œ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤; ì§€ê¸ˆì€ ìœ ë‹‰ìŠ¤ ì‹œìŠ¤í…œì— ë¶ˆê³¼í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:665
msgid "Tips for Writing Unicode-aware Programs"
msgstr "ìœ ë‹ˆì½”ë“œ ì¸ì‹ í”„ë¡œê·¸ë¨ ì‘ì„± íŒ"

#: ../../howto/unicode.rst:667
msgid ""
"This section provides some suggestions on writing software that deals "
"with Unicode."
msgstr "ì´ ì„¹ì…˜ì€ ìœ ë‹ˆì½”ë“œë¥¼ ë‹¤ë£¨ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ë¥¼ ì‘ì„±í•  ë•Œì˜ ëª‡ ê°€ì§€ ì œì•ˆì„ ì œê³µí•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:670
msgid "The most important tip is:"
msgstr "ê°€ì¥ ì¤‘ìš”í•œ íŒì€:"

#: ../../howto/unicode.rst:672
msgid ""
"Software should only work with Unicode strings internally, decoding the "
"input data as soon as possible and encoding the output only at the end."
msgstr ""
"ì†Œí”„íŠ¸ì›¨ì–´ëŠ” ê°€ëŠ¥í•œ í•œ ë¹¨ë¦¬ ì…ë ¥ ë°ì´í„°ë¥¼ ë””ì½”ë”©í•˜ê³  ë§ˆì§€ë§‰ì—ë§Œ ì¶œë ¥ì„ ì¸ì½”ë”©í•˜ì—¬ ë‚´ë¶€ì ìœ¼ë¡œëŠ” ìœ ë‹ˆì½”ë“œ ë¬¸ìì—´ì—ì„œë§Œ ì‘ë™í•˜ëŠ” ê²ƒì´ "
"ì¢‹ìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:675
msgid ""
"If you attempt to write processing functions that accept both Unicode and"
" byte strings, you will find your program vulnerable to bugs wherever you"
" combine the two different kinds of strings.  There is no automatic "
"encoding or decoding: if you do e.g. ``str + bytes``, a :exc:`TypeError` "
"will be raised."
msgstr ""
"ìœ ë‹ˆì½”ë“œì™€ ë°”ì´íŠ¸ ë¬¸ìì—´ì„ ìˆ˜ìš©í•˜ëŠ” ì²˜ë¦¬ í•¨ìˆ˜ë¥¼ ì‘ì„±í•˜ë ¤ê³  ì‹œë„í•œë‹¤ë©´, ë‘ ê°€ì§€ ë‹¤ë¥¸ ì¢…ë¥˜ì˜ ë¬¸ìì—´ì„ ê²°í•©í•  ë•Œë§ˆë‹¤ í”„ë¡œê·¸ë¨ì´ "
"ë²„ê·¸ì— ì·¨ì•½í•˜ë‹¤ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ìë™ ì¸ì½”ë”©ì´ë‚˜ ë””ì½”ë”©ì€ ì—†ìŠµë‹ˆë‹¤: ``str + bytes``\\ì„ ìˆ˜í–‰í•œë‹¤ë©´ "
":exc:`TypeError`\\ê°€ ë°œìƒí•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:680
msgid ""
"When using data coming from a web browser or some other untrusted source,"
" a common technique is to check for illegal characters in a string before"
" using the string in a generated command line or storing it in a "
"database.  If you're doing this, be careful to check the decoded string, "
"not the encoded bytes data; some encodings may have interesting "
"properties, such as not being bijective or not being fully ASCII-"
"compatible.  This is especially true if the input data also specifies the"
" encoding, since the attacker can then choose a clever way to hide "
"malicious text in the encoded bytestream."
msgstr ""
"ì›¹ ë¸Œë¼ìš°ì €ë‚˜ ë‹¤ë¥¸ ì‹ ë¢°í•  ìˆ˜ ì—†ëŠ” ì†ŒìŠ¤ë¡œë¶€í„° ì˜¨ ë°ì´í„°ë¥¼ ì‚¬ìš©í•  ë•Œ, ì¼ë°˜ì ì¸ ê¸°ë²•ì€ ìƒì„±ëœ ëª…ë ¹í–‰ì—ì„œ ë¬¸ìì—´ì„ ì‚¬ìš©í•˜ê±°ë‚˜ "
"ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•˜ê¸° ì „ì— ë¬¸ìì—´ì—ì„œ ì˜ëª»ëœ ë¬¸ìë¥¼ ê²€ì‚¬í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ê³  ìˆë‹¤ë©´, ì¸ì½”ë”©ëœ ë°”ì´íŠ¸ì—´ ë°ì´í„°ê°€ ì•„ë‹Œ "
"ë””ì½”ë”© ëœ ë¬¸ìì—´ì„ ê²€ì‚¬í•˜ë„ë¡ ì¡°ì‹¬í•˜ê¸° ë°”ëë‹ˆë‹¤; ì–´ë–¤ ì¸ì½”ë”©ì€ ì¼ëŒ€ì¼ ëŒ€ì‘ë˜ì§€ ì•Šê±°ë‚˜ ASCIIì™€ ì™„ì „íˆ í˜¸í™˜ë˜ì§€ ì•ŠëŠ” í¥ë¯¸ë¡œìš´ "
"ì†ì„±ì„ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤. ì…ë ¥ ë°ì´í„°ê°€ ì¸ì½”ë”©ì„ ì§€ì •í•˜ëŠ” ê²½ìš° íŠ¹íˆ ê·¸ëŸ¬í•œë°, ê³µê²©ìê°€ ì¸ì½”ë”©í•œ ë°”ì´íŠ¸ ìŠ¤íŠ¸ë¦¼ ì•ˆì— ì•…ì˜ì ì¸ "
"í…ìŠ¤íŠ¸ë¥¼ ìˆ¨ê¸°ëŠ” ë°©ë²•ì„ íƒí•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤."

#: ../../howto/unicode.rst:691
msgid "Converting Between File Encodings"
msgstr "íŒŒì¼ ì¸ì½”ë”©ë¼ë¦¬ ë³€í™˜"

#: ../../howto/unicode.rst:693
msgid ""
"The :class:`~codecs.StreamRecoder` class can transparently convert "
"between encodings, taking a stream that returns data in encoding #1 and "
"behaving like a stream returning data in encoding #2."
msgstr ""
":class:`~codecs.StreamRecoder` í´ë˜ìŠ¤ëŠ” ì¸ì½”ë”© #1ìœ¼ë¡œ ë°ì´í„°ë¥¼ ë°˜í™˜í•˜ëŠ” ìŠ¤íŠ¸ë¦¼ì„ ë°›ì•„ì„œ ì¸ì½”ë”© #2ë¡œ "
"ë°ì´í„°ë¥¼ ë°˜í™˜í•˜ëŠ” ìŠ¤íŠ¸ë¦¼ì²˜ëŸ¼ ë™ì‘í•˜ì—¬ ì¸ì½”ë”© ê°„ì— íˆ¬ëª…í•˜ê²Œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:697
msgid ""
"For example, if you have an input file *f* that's in Latin-1, you can "
"wrap it with a :class:`~codecs.StreamRecoder` to return bytes encoded in "
"UTF-8::"
msgstr ""
"ì˜ˆë¥¼ ë“¤ì–´, Latin-1ì„ ì‚¬ìš©í•˜ëŠ” *f* ì…ë ¥ íŒŒì¼ì„ ê°€ì§€ê³  ìˆë‹¤ë©´, ì´ë¥¼ UTF-8ë¡œ ì¸ì½”ë”©í•œ ë°”ì´íŠ¸ì—´ì„ ë°˜í™˜í•˜ê¸° ìœ„í•´ "
":class:`~codecs.StreamRecoder`\\ë¡œ ê°ìŒ€ ìˆ˜ ìˆìŠµë‹ˆë‹¤::"

#: ../../howto/unicode.rst:701
msgid ""
"new_f = codecs.StreamRecoder(f,\n"
"    # en/decoder: used by read() to encode its results and\n"
"    # by write() to decode its input.\n"
"    codecs.getencoder('utf-8'), codecs.getdecoder('utf-8'),\n"
"\n"
"    # reader/writer: used to read and write to the stream.\n"
"    codecs.getreader('latin-1'), codecs.getwriter('latin-1') )"
msgstr ""

#: ../../howto/unicode.rst:711
msgid "Files in an Unknown Encoding"
msgstr "ì•Œ ìˆ˜ ì—†ëŠ” ì¸ì½”ë”©ì˜ íŒŒì¼"

#: ../../howto/unicode.rst:713
msgid ""
"What can you do if you need to make a change to a file, but don't know "
"the file's encoding?  If you know the encoding is ASCII-compatible and "
"only want to examine or modify the ASCII parts, you can open the file "
"with the ``surrogateescape`` error handler::"
msgstr ""
"íŒŒì¼ì„ ë³€ê²½í•´ì•¼ í•˜ì§€ë§Œ íŒŒì¼ì˜ ì¸ì½”ë”©ì„ ëª¨ë¥¼ ë•Œ í•  ìˆ˜ ìˆëŠ” ì¼ì€ ë¬´ì—‡ì¼ê¹Œìš”? ì¸ì½”ë”©ì´ ASCII í˜¸í™˜ì´ë¼ëŠ” ê²ƒì„ ì•Œê³  ìˆê³  "
"ASCII ì¼ë¶€ë¶„ì„ ê²€í†  ë˜ëŠ” ìˆ˜ì •ë§Œ í•˜ê³ ì í•œë‹¤ë©´, ``surrogateescape`` ì—ëŸ¬ í•¸ë“¤ëŸ¬ì™€ í•¨ê»˜ íŒŒì¼ì„ ì—´ ìˆ˜ "
"ìˆìŠµë‹ˆë‹¤::"

#: ../../howto/unicode.rst:718
msgid ""
"with open(fname, 'r', encoding=\"ascii\", errors=\"surrogateescape\") as "
"f:\n"
"    data = f.read()\n"
"\n"
"# make changes to the string 'data'\n"
"\n"
"with open(fname + '.new', 'w',\n"
"          encoding=\"ascii\", errors=\"surrogateescape\") as f:\n"
"    f.write(data)"
msgstr ""

#: ../../howto/unicode.rst:727
msgid ""
"The ``surrogateescape`` error handler will decode any non-ASCII bytes as "
"code points in a special range running from U+DC80 to U+DCFF.  These code"
" points will then turn back into the same bytes when the "
"``surrogateescape`` error handler is used to encode the data and write it"
" back out."
msgstr ""
"``surrogateescape`` ì—ëŸ¬ í•¸ë“¤ëŸ¬ëŠ” ë¹„ ASCII ë°”ì´íŠ¸ë“¤ì„ U+DC80ë¶€í„° U+DCFFê¹Œì§€ì˜ íŠ¹ìˆ˜í•œ ë²”ìœ„ì— ìˆëŠ” "
"ì½”ë“œ í¬ì¸íŠ¸ë¡œ ë””ì½”ë”©í•©ë‹ˆë‹¤. ì´ëŸ¬í•œ ì½”ë“œ í¬ì¸íŠ¸ëŠ” ``surrogateescape`` ì—ëŸ¬ í•¸ë“¤ëŸ¬ê°€ ë°ì´í„°ë¥¼ ì¸ì½”ë”©í•˜ê³  ë‹¤ì‹œ ì“°ëŠ” "
"ê²½ìš°ì— ì‚¬ìš©ë  ë•Œ ê°™ì€ ë°”ì´íŠ¸ì—´ë¡œ ë‹¤ì‹œ ë˜ëŒë ¤ì§‘ë‹ˆë‹¤."

#: ../../howto/unicode.rst:737
#, fuzzy
msgid ""
"One section of `Mastering Python 3 Input/Output "
"<https://pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o>`_, a "
"PyCon 2010 talk by David Beazley, discusses text processing and binary "
"data handling."
msgstr ""
"David Beazleyê°€ PyCon 2010ì—ì„œ ë°œí‘œí•œ `íŒŒì´ì¬3 ì…ì¶œë ¥ ë§ˆìŠ¤í„°í•˜ê¸° "
"<http://pyvideo.org/video/289/pycon-2010--mastering-python-3-i-o>`_\\ì˜ í•œ "
"ì„¹ì…˜ì€ í…ìŠ¤íŠ¸ ì²˜ë¦¬ì™€ ë°”ì´ë„ˆë¦¬ ë°ì´í„° ì²˜ë¦¬ì— ëŒ€í•´ ë…¼ì˜í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:741
msgid ""
"The `PDF slides for Marc-AndrÃ© Lemburg's presentation \"Writing Unicode-"
"aware Applications in Python\" "
"<https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-"
"applications-in-Python.pdf>`_ discuss questions of character encodings as"
" well as how to internationalize and localize an application.  These "
"slides cover Python 2.x only."
msgstr ""
"`Marc-AndrÃ© Lemburgì˜ í”„ë ˆì  í…Œì´ì…˜ PDF ìŠ¬ë¼ì´ë“œ \"íŒŒì´ì¬ì—ì„œ ìœ ë‹ˆì½”ë“œ ì¸ì‹ í”„ë¡œê·¸ë¨ ì‘ì„±\" "
"<https://downloads.egenix.com/python/LSM2005-Developing-Unicode-aware-"
"applications-in-Python.pdf>`_\\ì€ ë¬¸ì ì¸ì½”ë”©ì— ê´€í•œ ì§ˆë¬¸ì€ ë¬¼ë¡  ì‘ìš© í”„ë¡œê·¸ë¨ì„ êµ­ì œí™”í•˜ê³  ì§€ì—­í™”í•˜ëŠ” "
"ë°©ë²•ì— ê´€í•´ ì„¤ëª…í•©ë‹ˆë‹¤. ì´ ìŠ¬ë¼ì´ë“œëŠ” íŒŒì´ì¬ 2.xë§Œì„ ë‹¤ë£¹ë‹ˆë‹¤."

#: ../../howto/unicode.rst:747
#, fuzzy
msgid ""
"`The Guts of Unicode in Python <https://pyvideo.org/video/1768/the-guts-"
"of-unicode-in-python>`_ is a PyCon 2013 talk by Benjamin Peterson that "
"discusses the internal Unicode representation in Python 3.3."
msgstr ""
"PyCon 2013ì—ì„œ Benjamin Petersonì´ ë°œí‘œí•œ `íŒŒì´ì¬ì—ì„œ ìœ ë‹ˆì½”ë“œì˜ ë‚´ë¶€ "
"<http://pyvideo.org/video/1768/the-guts-of-unicode-in-python>`_\\ì€ íŒŒì´ì¬ "
"3.3ì—ì„œ ë‚´ë¶€ ìœ ë‹ˆì½”ë“œ í‘œí˜„ì— ëŒ€í•´ ë…¼ì˜í•©ë‹ˆë‹¤."

#: ../../howto/unicode.rst:754
msgid "Acknowledgements"
msgstr "ê°ì‚¬ ì¸ì‚¬"

#: ../../howto/unicode.rst:756
msgid ""
"The initial draft of this document was written by Andrew Kuchling. It has"
" since been revised further by Alexander Belopolsky, Georg Brandl, Andrew"
" Kuchling, and Ezio Melotti."
msgstr ""
"ì´ ë¬¸ì„œì˜ ì´ˆì•ˆì€ Andrew Kuchlingì´ ì¼ìŠµë‹ˆë‹¤. ì´í›„ Alexander Belopolsky, Georg Brandl, "
"Andrew Kuchling, ê·¸ë¦¬ê³  Ezio Melottiì— ì˜í•´ ê°œì •ë˜ì—ˆìŠµë‹ˆë‹¤."

#: ../../howto/unicode.rst:760
msgid ""
"Thanks to the following people who have noted errors or offered "
"suggestions on this article: Ã‰ric Araujo, Nicholas Bastin, Nick Coghlan, "
"Marius Gedminas, Kent Johnson, Ken Krugler, Marc-AndrÃ© Lemburg, Martin "
"von LÃ¶wis, Terry J. Reedy, Serhiy Storchaka, Eryk Sun, Chad Whitacre, "
"Graham Wideman."
msgstr ""
"ì´ ë¬¸ì„œì— ì˜¤ë¥˜ë¥¼ ì•Œë ¤ì£¼ê±°ë‚˜ ì œì•ˆì„ í•´ì£¼ì‹  ì•„ë˜ì˜ ì‚¬ëŒë“¤ì—ê²Œ ê°ì‚¬ë¥¼ ì „í•©ë‹ˆë‹¤: Ã‰ric Araujo, Nicholas Bastin,"
" Nick Coghlan, Marius Gedminas, Kent Johnson, Ken Krugler, Marc-AndrÃ© "
"Lemburg, Martin von LÃ¶wis, Terry J. Reedy, Serhiy Storchaka, Eryk Sun, "
"Chad Whitacre, Graham Wideman."

