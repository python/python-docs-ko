# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-04-08 08:18+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/howto/urllib2.rst:5
msgid "HOWTO Fetch Internet Resources Using The urllib Package"
msgstr "urllib 패키지를 사용하여 인터넷 리소스를 가져오는 방법"

#: ../Doc/howto/urllib2.rst
msgid "Author"
msgstr "저자"

#: ../Doc/howto/urllib2.rst:7
msgid "`Michael Foord <http://www.voidspace.org.uk/python/index.shtml>`_"
msgstr "`Michael Foord <http://www.voidspace.org.uk/python/index.shtml>`_"

#: ../Doc/howto/urllib2.rst:11
msgid ""
"There is a French translation of an earlier revision of this HOWTO, "
"available at `urllib2 - Le Manuel manquant "
"<http://www.voidspace.org.uk/python/articles/urllib2_francais.shtml>`_."
msgstr ""
"`urllib2 - Le Manuel manquant "
"<http://www.voidspace.org.uk/python/articles/urllib2_francais.shtml>`_\\에"
" 이 HOWTO의 이전 버전에 대한 프랑스어 번역본이 있습니다."

#: ../Doc/howto/urllib2.rst:18
msgid "Introduction"
msgstr "소개"

#: ../Doc/howto/urllib2.rst:22
msgid ""
"You may also find useful the following article on fetching web resources "
"with Python:"
msgstr "파이썬으로 웹 리소스를 가져오는 방법에 대한 다음 기사도 유용합니다:"

#: ../Doc/howto/urllib2.rst:25
msgid ""
"`Basic Authentication "
"<http://www.voidspace.org.uk/python/articles/authentication.shtml>`_"
msgstr ""
"`Basic Authentication "
"<http://www.voidspace.org.uk/python/articles/authentication.shtml>`_"

#: ../Doc/howto/urllib2.rst:27
msgid "A tutorial on *Basic Authentication*, with examples in Python."
msgstr "파이썬 예제가 있는 *기본 인증(Basic Authentication)*\\에 대한 자습서."

#: ../Doc/howto/urllib2.rst:29
msgid ""
"**urllib.request** is a Python module for fetching URLs (Uniform Resource"
" Locators). It offers a very simple interface, in the form of the "
"*urlopen* function. This is capable of fetching URLs using a variety of "
"different protocols. It also offers a slightly more complex interface for"
" handling common situations - like basic authentication, cookies, proxies"
" and so on. These are provided by objects called handlers and openers."
msgstr ""
"**urllib.request**\\는 URL(Uniform Resource Locator)을 가져오기 위한 파이썬 모듈입니다. "
"*urlopen* 함수의 형태로, 매우 간단한 인터페이스를 제공합니다. 다양한 프로토콜을 사용하여 URL을 가져올 수 있습니다. "
"또한 기본 인증(basic authentication), 쿠키, 프락시 등과 같은 일반적인 상황을 처리하기 위한 약간 더 복잡한 "
"인터페이스도 제공합니다. 이들은 처리기와 오프너라는 객체에 의해 제공됩니다."

#: ../Doc/howto/urllib2.rst:36
msgid ""
"urllib.request supports fetching URLs for many \"URL schemes\" "
"(identified by the string before the ``\":\"`` in URL - for example "
"``\"ftp\"`` is the URL scheme of ``\"ftp://python.org/\"``) using their "
"associated network protocols (e.g. FTP, HTTP). This tutorial focuses on "
"the most common case, HTTP."
msgstr ""
"urllib.request는 관련 네트워크 프로토콜(예를 들어 FTP, HTTP)을 사용하여 많은 \"URL 스킴(scheme)\""
" (URL에서 ``\":\"`` 앞의 문자열로 식별됩니다 - 예를 들어 ``\"ftp\"``\\는 "
"``\"ftp://python.org/\"``\\의 URL 스킴입니다)에 대해 URL을 가져오는 것을 지원합니다. 이 자습서는 가장"
" 흔한 경우인 HTTP에 초점을 맞춥니다."

#: ../Doc/howto/urllib2.rst:41
msgid ""
"For straightforward situations *urlopen* is very easy to use. But as soon"
" as you encounter errors or non-trivial cases when opening HTTP URLs, you"
" will need some understanding of the HyperText Transfer Protocol. The "
"most comprehensive and authoritative reference to HTTP is :rfc:`2616`. "
"This is a technical document and not intended to be easy to read. This "
"HOWTO aims to illustrate using *urllib*, with enough detail about HTTP to"
" help you through. It is not intended to replace the "
":mod:`urllib.request` docs, but is supplementary to them."
msgstr ""
"간단한 상황에서 *urlopen*\\은 사용하기가 매우 쉽습니다. 그러나 HTTP URL을 열 때 에러나 사소하지 않은 사례를 "
"만나자마자, HTTP(HyperText Transfer Protocol)에 대한 이해가 필요합니다. HTTP에 대한 가장 포괄적이고"
" 권위 있는 레퍼런스는 :rfc:`2616`\\입니다. 이것은 기술 문서이며 읽기 쉽지 않습니다. 이 HOWTO에서는 "
"*urllib*\\를 사용하는 방법을 설명하고, HTTP에 대해 충분히 자세하게 설명합니다. :mod:`urllib.request`"
" 문서를 대체하려는 것이 아니라, 보조하려는 것입니다."

#: ../Doc/howto/urllib2.rst:51
msgid "Fetching URLs"
msgstr "URL을 가져오기"

#: ../Doc/howto/urllib2.rst:53
msgid "The simplest way to use urllib.request is as follows::"
msgstr "urllib.request를 사용하는 가장 간단한 방법은 다음과 같습니다::"

#: ../Doc/howto/urllib2.rst:59
msgid ""
"If you wish to retrieve a resource via URL and store it in a temporary "
"location, you can do so via the :func:`shutil.copyfileobj` and "
":func:`tempfile.NamedTemporaryFile` functions::"
msgstr ""
"URL을 통해 리소스를 가져와서 임시 위치에 저장하려면, :func:`shutil.copyfileobj`\\와 "
":func:`tempfile.NamedTemporaryFile` 함수를 통해 수행할 수 있습니다::"

#: ../Doc/howto/urllib2.rst:74
msgid ""
"Many uses of urllib will be that simple (note that instead of an 'http:' "
"URL we could have used a URL starting with 'ftp:', 'file:', etc.).  "
"However, it's the purpose of this tutorial to explain the more "
"complicated cases, concentrating on HTTP."
msgstr ""
"urllib의 많은 용도는 이렇게 간단합니다 ('http:' URL 대신 'ftp:', 'file:' 등으로 시작하는 URL을 "
"사용할 수 있음에 유의하십시오). 그러나, 이 자습서의 목적은 HTTP에 집중하여 더 복잡한 경우를 설명하는 것입니다."

#: ../Doc/howto/urllib2.rst:79
msgid ""
"HTTP is based on requests and responses - the client makes requests and "
"servers send responses. urllib.request mirrors this with a ``Request`` "
"object which represents the HTTP request you are making. In its simplest "
"form you create a Request object that specifies the URL you want to "
"fetch. Calling ``urlopen`` with this Request object returns a response "
"object for the URL requested. This response is a file-like object, which "
"means you can for example call ``.read()`` on the response::"
msgstr ""
"HTTP는 요청과 응답을 기반으로 합니다 - 클라이언트는 요청하고 서버는 응답을 보냅니다. urllib.request는 HTTP "
"요청을 나타내는 ``Request`` 객체로 이것을 반영합니다. 가장 간단한 형식에서 가져오려는 URL을 지정하는 Request "
"객체를 만듭니다. 이 Request 객체로 ``urlopen``\\을 호출하면 요청된 URL에 대한 응답 객체를 반환합니다. 이 "
"응답은 파일류 객체입니다, 응답에서 예를 들어 ``.read()``\\를 호출할 수 있다는 뜻입니다::"

#: ../Doc/howto/urllib2.rst:93
msgid ""
"Note that urllib.request makes use of the same Request interface to "
"handle all URL schemes.  For example, you can make an FTP request like "
"so::"
msgstr ""
"urllib.request는 모든 URL 스킴을 처리하기 위해 같은 Request 인터페이스를 사용합니다. 예를 들어, 다음과 같이"
" FTP 요청을 할 수 있습니다::"

#: ../Doc/howto/urllib2.rst:98
#, fuzzy
msgid ""
"In the case of HTTP, there are two extra things that Request objects "
"allow you to do: First, you can pass data to be sent to the server.  "
"Second, you can pass extra information (\"metadata\") *about* the data or"
" about the request itself, to the server - this information is sent as "
"HTTP \"headers\".  Let's look at each of these in turn."
msgstr ""
"HTTP의 경우, Request 객체로 수행할 수 있는 추가 작업이 두 가지 있습니다: 첫째, 서버로 보낼 데이터를 전달할 수 "
"있습니다. 둘째, 데이터나 요청 자체에 *관한* 추가 정보(\"메타 데이터\")를 서버에 전달할 수 있습니다 - 이 정보는 HTTP"
" \"헤더\"로 전송됩니다. 이들을 차례로 살펴봅시다."

#: ../Doc/howto/urllib2.rst:105
msgid "Data"
msgstr "데이터"

#: ../Doc/howto/urllib2.rst:107
msgid ""
"Sometimes you want to send data to a URL (often the URL will refer to a "
"CGI (Common Gateway Interface) script or other web application). With "
"HTTP, this is often done using what's known as a **POST** request. This "
"is often what your browser does when you submit a HTML form that you "
"filled in on the web. Not all POSTs have to come from forms: you can use "
"a POST to transmit arbitrary data to your own application. In the common "
"case of HTML forms, the data needs to be encoded in a standard way, and "
"then passed to the Request object as the ``data`` argument. The encoding "
"is done using a function from the :mod:`urllib.parse` library. ::"
msgstr ""
"URL로 데이터를 보내려고 할 때도 있습니다 (종종 URL은 CGI (Common Gateway Interface) 스크립트나 다른"
" 웹 응용 프로그램을 가리킵니다). HTTP에서, 이것은 종종 **POST** 요청이라고 알려진 것을 사용하여 수행됩니다. 이것은 "
"종종 웹에서 채워 넣은 HTML 폼(form)을 제출할 때 브라우저가 수행하는 것입니다. 모든 POST가 폼에서 비롯될 필요는 "
"없습니다: POST를 사용하여 임의의 데이터를 여러분 자신의 응용 프로그램으로 전송할 수 있습니다. 일반적인 HTML 폼의 경우, "
"데이터를 표준 방식으로 인코딩할 필요가 있고, 그런 다음 ``data`` 인자로 Request 객체에 전달합니다. 인코딩은 "
":mod:`urllib.parse` 라이브러리의 함수를 사용하여 수행됩니다. ::"

#: ../Doc/howto/urllib2.rst:131
msgid ""
"Note that other encodings are sometimes required (e.g. for file upload "
"from HTML forms - see `HTML Specification, Form Submission "
"<https://www.w3.org/TR/REC-html40/interact/forms.html#h-17.13>`_ for more"
" details)."
msgstr ""
"다른 인코딩이 필요한 경우도 있음에 유의하십시오 (예를 들어 HTML 폼에서 파일을 업로드하는 경우 자세한 내용은 `HTML "
"Specification, Form Submission <https://www.w3.org/TR/REC-"
"html40/interact/forms.html#h-17.13>`_\\을 참조하십시오)."

#: ../Doc/howto/urllib2.rst:136
msgid ""
"If you do not pass the ``data`` argument, urllib uses a **GET** request. "
"One way in which GET and POST requests differ is that POST requests often"
" have \"side-effects\": they change the state of the system in some way "
"(for example by placing an order with the website for a hundredweight of "
"tinned spam to be delivered to your door).  Though the HTTP standard "
"makes it clear that POSTs are intended to *always* cause side-effects, "
"and GET requests *never* to cause side-effects, nothing prevents a GET "
"request from having side-effects, nor a POST requests from having no "
"side-effects. Data can also be passed in an HTTP GET request by encoding "
"it in the URL itself."
msgstr ""
"``data`` 인자를 전달하지 않으면, urllib는 **GET** 요청을 사용합니다. GET과 POST 요청이 다른 한 가지는 "
"POST 요청에 종종 \"부작용\"이 있다는 것입니다: 어떤 방식으로든 시스템의 상태를 변경합니다 (예를 들어 캔에 담긴 스팸이 "
"여러분의 문 앞에 배달되도록 주문을 넣습니다). HTTP 표준이 POST는 *항상* 부작용을 일으키려는 것이고, GET은 *절대* "
"부작용을 일으키지 않는다고 분명히 하고 있지만, GET 요청이 부작용을 일으키거나 POST 요청에 부작용이 없는 것을 막을 수는 "
"없습니다. URL 자체에 인코딩하여 HTTP GET 요청에 데이터를 전달할 수도 있습니다."

#: ../Doc/howto/urllib2.rst:146
msgid "This is done as follows::"
msgstr "다음과 같이 수행됩니다::"

#: ../Doc/howto/urllib2.rst:161
msgid ""
"Notice that the full URL is created by adding a ``?`` to the URL, "
"followed by the encoded values."
msgstr "전체 URL은 URL에 ``?``\\를 추가한 다음 인코딩된 값을 추가하여 만들어짐에 유의하십시오."

#: ../Doc/howto/urllib2.rst:165
msgid "Headers"
msgstr "헤더"

#: ../Doc/howto/urllib2.rst:167
msgid ""
"We'll discuss here one particular HTTP header, to illustrate how to add "
"headers to your HTTP request."
msgstr "여기서는 HTTP 요청에 헤더를 추가하는 방법을 설명하기 위해 한 가지 특정 HTTP 헤더에 관해 설명합니다."

#: ../Doc/howto/urllib2.rst:170
msgid ""
"Some websites [#]_ dislike being browsed by programs, or send different "
"versions to different browsers [#]_. By default urllib identifies itself "
"as ``Python-urllib/x.y`` (where ``x`` and ``y`` are the major and minor "
"version numbers of the Python release, e.g. ``Python-urllib/2.5``), which"
" may confuse the site, or just plain not work. The way a browser "
"identifies itself is through the ``User-Agent`` header [#]_. When you "
"create a Request object you can pass a dictionary of headers in. The "
"following example makes the same request as above, but identifies itself "
"as a version of Internet Explorer [#]_. ::"
msgstr ""
"일부 웹 사이트는 [#]_ 프로그램이 브라우징하는 것을 싫어하거나, 브라우저에 따라 다른 버전을 보냅니다 [#]_. 기본적으로, "
"urllib는 자신을 ``Python-urllib/x.y``\\(여기서 ``x`` 와 ``y``\\는 파이썬 배포의 주 버전과 부 "
"버전 번호입니다, 예를 들어 ``Python-urllib/2.5``)로 식별하는데, 이는 사이트를 혼동시키거나, 단지 작동하지 않을"
" 수 있습니다. 브라우저가 자신을 식별하는 방식은 ``User-Agent`` 헤더를 [#]_ 통하는 것입니다. Request 객체를"
" 만들 때 헤더가 담긴 딕셔너리를 전달할 수 있습니다. 다음 예제는 위와 같은 요청을 하지만, 자신을 Internet "
"Explorer의 한 버전으로 식별합니다 [#]_. ::"

#: ../Doc/howto/urllib2.rst:197
msgid ""
"The response also has two useful methods. See the section on `info and "
"geturl`_ which comes after we have a look at what happens when things go "
"wrong."
msgstr ""
"응답에는 두 가지 유용한 메서드도 있습니다. 문제가 발생했을 때 어떤 일이 발생했는지 살펴본 후에 나오는 `info와 geturl "
"<info and geturl_>`_ 섹션을 참조하십시오."

#: ../Doc/howto/urllib2.rst:202
msgid "Handling Exceptions"
msgstr "예외 처리"

#: ../Doc/howto/urllib2.rst:204
msgid ""
"*urlopen* raises :exc:`URLError` when it cannot handle a response (though"
" as usual with Python APIs, built-in exceptions such as "
":exc:`ValueError`, :exc:`TypeError` etc. may also be raised)."
msgstr ""
"*urlopen*\\은 응답을 처리할 수 없을 때 :exc:`URLError`\\를 발생시킵니다 (하지만 파이썬 API에서 "
"일상적으로 발생하는 :exc:`ValueError`, :exc:`TypeError` 등과 같은 내장 예외도 발생할 수 있습니다)."

#: ../Doc/howto/urllib2.rst:208
msgid ""
":exc:`HTTPError` is the subclass of :exc:`URLError` raised in the "
"specific case of HTTP URLs."
msgstr ":exc:`HTTPError`\\는 HTTP URL의 특정 경우에 발생하는 :exc:`URLError`\\의 서브 클래스입니다."

#: ../Doc/howto/urllib2.rst:211
msgid "The exception classes are exported from the :mod:`urllib.error` module."
msgstr "예외 클래스는 :mod:`urllib.error` 모듈이 내보냅니다."

#: ../Doc/howto/urllib2.rst:214
msgid "URLError"
msgstr "URLError"

#: ../Doc/howto/urllib2.rst:216
msgid ""
"Often, URLError is raised because there is no network connection (no "
"route to the specified server), or the specified server doesn't exist.  "
"In this case, the exception raised will have a 'reason' attribute, which "
"is a tuple containing an error code and a text error message."
msgstr ""
"종종, 네트워크 연결이 없거나 (지정된 서버로의 경로가 없거나), 지정된 서버가 없기 때문에 URLError가 발생합니다. 이 "
"경우, 발생한 예외에는 'reason' 어트리뷰트가 있으며, 이는 에러 코드와 텍스트 에러 메시지를 포함하는 튜플입니다."

#: ../Doc/howto/urllib2.rst:221
msgid "e.g. ::"
msgstr "예를 들어 ::"

#: ../Doc/howto/urllib2.rst:232
msgid "HTTPError"
msgstr "HTTPError"

#: ../Doc/howto/urllib2.rst:234
msgid ""
"Every HTTP response from the server contains a numeric \"status code\". "
"Sometimes the status code indicates that the server is unable to fulfil "
"the request. The default handlers will handle some of these responses for"
" you (for example, if the response is a \"redirection\" that requests the"
" client fetch the document from a different URL, urllib will handle that "
"for you). For those it can't handle, urlopen will raise an "
":exc:`HTTPError`. Typical errors include '404' (page not found), '403' "
"(request forbidden), and '401' (authentication required)."
msgstr ""
"서버의 모든 HTTP 응답에는 숫자 \"상태 코드\"가 포함됩니다. 때때로 상태 코드는 서버가 요청을 이행할 수 없음을 나타냅니다."
" 기본 처리기는 이러한 응답 중 일부를 처리합니다 (예를 들어, 응답이 클라이언트가 다른 URL에서 문서를 가져오도록 요청하는 "
"\"리디렉션\"인 경우, urllib가 이를 처리합니다). 처리할 수 없는 것들의 경우, urlopen은 "
":exc:`HTTPError`\\를 발생시킵니다. 일반적인 에러에는 '404' (page not found - 페이지를 찾을 수 "
"없음), '403' (request forbidden - 요청이 금지됨) 및 '401' (authentication required"
" - 인증이 필요함)이 있습니다."

#: ../Doc/howto/urllib2.rst:242
msgid "See section 10 of :rfc:`2616` for a reference on all the HTTP error codes."
msgstr "모든 HTTP 에러 코드에 대한 레퍼런스는 :rfc:`2616`\\의 섹션 10을 참조하십시오."

#: ../Doc/howto/urllib2.rst:244
msgid ""
"The :exc:`HTTPError` instance raised will have an integer 'code' "
"attribute, which corresponds to the error sent by the server."
msgstr "발생한 :exc:`HTTPError` 인스턴스는 서버에서 전송된 에러에 해당하는 정수 'code' 어트리뷰트를 갖습니다."

#: ../Doc/howto/urllib2.rst:248
msgid "Error Codes"
msgstr "에러 코드"

#: ../Doc/howto/urllib2.rst:250
msgid ""
"Because the default handlers handle redirects (codes in the 300 range), "
"and codes in the 100--299 range indicate success, you will usually only "
"see error codes in the 400--599 range."
msgstr ""
"기본 처리기는 리디렉션(300 범위의 코드)을 처리하고, 100--299 범위의 코드는 성공을 나타내므로, 보통 400--599 "
"범위의 에러 코드만 보게 됩니다."

#: ../Doc/howto/urllib2.rst:254
msgid ""
":attr:`http.server.BaseHTTPRequestHandler.responses` is a useful "
"dictionary of response codes in that shows all the response codes used by"
" :rfc:`2616`. The dictionary is reproduced here for convenience ::"
msgstr ""
":attr:`http.server.BaseHTTPRequestHandler.responses`\\는 :rfc:`2616`\\가 "
"사용하는 모든 응답 코드를 표시하는 유용한 응답 코드 딕셔너리입니다. 편의를 위해 딕셔너리를 여기에 재현합니다 ::"

#: ../Doc/howto/urllib2.rst:326
msgid ""
"When an error is raised the server responds by returning an HTTP error "
"code *and* an error page. You can use the :exc:`HTTPError` instance as a "
"response on the page returned. This means that as well as the code "
"attribute, it also has read, geturl, and info, methods as returned by the"
" ``urllib.response`` module::"
msgstr ""
"에러가 발생할 때 서버는 HTTP 에러 코드\\*와* 에러 페이지를 반환하여 응답합니다. :exc:`HTTPError` 인스턴스를 "
"반환된 페이지의 응답으로 사용할 수 있습니다. 이것은 code 어트리뷰트뿐만 아니라, ``urllib.response`` 모듈이 "
"반환하는 것처럼 read, geturl 및 info 메서드도 가지고 있음을 의미합니다::"

#: ../Doc/howto/urllib2.rst:346
msgid "Wrapping it Up"
msgstr "마무리"

#: ../Doc/howto/urllib2.rst:348
msgid ""
"So if you want to be prepared for :exc:`HTTPError` *or* :exc:`URLError` "
"there are two basic approaches. I prefer the second approach."
msgstr ""
"따라서 :exc:`HTTPError` *또는* :exc:`URLError`\\를 대비하려면 두 가지 기본적인 접근법이 있습니다. "
"저는 두 번째 접근법을 선호합니다."

#: ../Doc/howto/urllib2.rst:352
msgid "Number 1"
msgstr "1번"

#: ../Doc/howto/urllib2.rst:374
msgid ""
"The ``except HTTPError`` *must* come first, otherwise ``except URLError``"
" will *also* catch an :exc:`HTTPError`."
msgstr ""
"``except HTTPError``\\가 *반드시* 먼저 나와야 합니다. 그렇지 않으면 ``except URLError``\\가 "
":exc:`HTTPError` *도* 잡습니다."

#: ../Doc/howto/urllib2.rst:378
msgid "Number 2"
msgstr "2번"

#: ../Doc/howto/urllib2.rst:399
msgid "info and geturl"
msgstr "info와 geturl"

#: ../Doc/howto/urllib2.rst:401
msgid ""
"The response returned by urlopen (or the :exc:`HTTPError` instance) has "
"two useful methods :meth:`info` and :meth:`geturl` and is defined in the "
"module :mod:`urllib.response`.."
msgstr ""
"urlopen에 의해 반환된 응답(또는 :exc:`HTTPError` 인스턴스)에는 두 가지 유용한 메서드 "
":meth:`info`\\와 :meth:`geturl`\\이 있으며 :mod:`urllib.response` 모듈에 정의되어 "
"있습니다."

#: ../Doc/howto/urllib2.rst:405
msgid ""
"**geturl** - this returns the real URL of the page fetched. This is "
"useful because ``urlopen`` (or the opener object used) may have followed "
"a redirect. The URL of the page fetched may not be the same as the URL "
"requested."
msgstr ""
"**geturl** - 가져온 페이지의 실제 URL을 반환합니다. 이는 ``urlopen``\\(또는 사용된 오프너 객체)이 "
"리디렉션을 수행했을 수 있기 때문에 유용합니다. 가져온 페이지의 URL은 요청한 URL과 같지 않을 수 있습니다."

#: ../Doc/howto/urllib2.rst:409
msgid ""
"**info** - this returns a dictionary-like object that describes the page "
"fetched, particularly the headers sent by the server. It is currently an "
":class:`http.client.HTTPMessage` instance."
msgstr ""
"**info** - 가져온 페이지를 설명하는 딕셔너리류 객체, 특히 서버가 보낸 헤더. 현재 "
":class:`http.client.HTTPMessage` 인스턴스입니다."

#: ../Doc/howto/urllib2.rst:413
msgid ""
"Typical headers include 'Content-length', 'Content-type', and so on. See "
"the `Quick Reference to HTTP Headers <http://jkorpela.fi/http.html>`_ for"
" a useful listing of HTTP headers with brief explanations of their "
"meaning and use."
msgstr ""
"일반적인 헤더에는 'Content-length', 'Content-type' 등이 있습니다. 의미와 용도에 대한 간단한 설명이 붙은"
" 유용한 HTTP 헤더 목록은 `Quick Reference to HTTP Headers "
"<http://jkorpela.fi/http.html>`_\\를 참조하십시오."

#: ../Doc/howto/urllib2.rst:420
msgid "Openers and Handlers"
msgstr "오프너와 처리기"

#: ../Doc/howto/urllib2.rst:422
msgid ""
"When you fetch a URL you use an opener (an instance of the perhaps "
"confusingly-named :class:`urllib.request.OpenerDirector`). Normally we "
"have been using the default opener - via ``urlopen`` - but you can create"
" custom openers. Openers use handlers. All the \"heavy lifting\" is done "
"by the handlers. Each handler knows how to open URLs for a particular URL"
" scheme (http, ftp, etc.), or how to handle an aspect of URL opening, for"
" example HTTP redirections or HTTP cookies."
msgstr ""
"URL을 가져올 때 오프너(아마도 혼란스럽게 이름 붙여진 :class:`urllib.request.OpenerDirector`\\의"
" 인스턴스)를 사용합니다. 일반적으로 ``urlopen``\\을 통해 기본 오프너를 사용했지만, 사용자 정의 오프너를 만들 수 "
"있습니다. 오프너는 처리기를 사용합니다. 모든 \"어려운 일은\"은 처리기가 수행합니다. 각 처리기는 특정 URL 스킴(http, "
"ftp 등)에 대한 URL을 여는 방법이나 URL 열기의 한 측면(예를 들어 HTTP 리디렉션이나 HTTP 쿠키)을 처리하는 방법을"
" 알고 있습니다."

#: ../Doc/howto/urllib2.rst:430
msgid ""
"You will want to create openers if you want to fetch URLs with specific "
"handlers installed, for example to get an opener that handles cookies, or"
" to get an opener that does not handle redirections."
msgstr ""
"특정 처리기가 설치된 상태로 URL을 가져오려면 오프너를 만듭니다, 예를 들면 쿠키를 처리하는 오프너를 얻거나, 리디렉션을 처리하지"
" 않는 오프너를 얻는 것이 있습니다."

#: ../Doc/howto/urllib2.rst:434
msgid ""
"To create an opener, instantiate an ``OpenerDirector``, and then call "
"``.add_handler(some_handler_instance)`` repeatedly."
msgstr ""
"오프너를 만들려면, ``OpenerDirector``\\를 인스턴스화 한 다음, "
"``.add_handler(some_handler_instance)``\\를 반복적으로 호출합니다."

#: ../Doc/howto/urllib2.rst:437
msgid ""
"Alternatively, you can use ``build_opener``, which is a convenience "
"function for creating opener objects with a single function call.  "
"``build_opener`` adds several handlers by default, but provides a quick "
"way to add more and/or override the default handlers."
msgstr ""
"또는, 단일 함수 호출로 오프너 객체를 만드는 편의 함수인 ``build_opener``\\를 사용할 수 있습니다. "
"``build_opener``\\는 기본적으로 여러 처리기를 추가하지만, 더 추가하거나 기본 처리기를 재정의하는 빠른 방법을 "
"제공합니다."

#: ../Doc/howto/urllib2.rst:442
msgid ""
"Other sorts of handlers you might want to can handle proxies, "
"authentication, and other common but slightly specialised situations."
msgstr "여러분이 원할 수도 있는 다른 유형의 처리기는 프락시, 인증 및 다른 흔하지만 약간 특수한 상황을 처리할 수 있습니다."

#: ../Doc/howto/urllib2.rst:445
msgid ""
"``install_opener`` can be used to make an ``opener`` object the (global) "
"default opener. This means that calls to ``urlopen`` will use the opener "
"you have installed."
msgstr ""
"``install_opener``\\를 사용하여 ``opener`` 객체를 (전역) 기본 오프너로 만들 수 있습니다. 즉, "
"``urlopen``\\을 호출하면 설치한 오프너가 사용됩니다."

#: ../Doc/howto/urllib2.rst:449
msgid ""
"Opener objects have an ``open`` method, which can be called directly to "
"fetch urls in the same way as the ``urlopen`` function: there's no need "
"to call ``install_opener``, except as a convenience."
msgstr ""
"오프너 객체에는 ``urlopen`` 함수와 같은 방식으로 URL을 가져오기 위해 직접 호출할 수 있는 ``open`` 메서드가 "
"있습니다: 편의 이외에, ``install_opener``\\를 호출할 필요는 없습니다."

#: ../Doc/howto/urllib2.rst:455
msgid "Basic Authentication"
msgstr "기본 인증"

#: ../Doc/howto/urllib2.rst:457
msgid ""
"To illustrate creating and installing a handler we will use the "
"``HTTPBasicAuthHandler``. For a more detailed discussion of this subject "
"-- including an explanation of how Basic Authentication works - see the "
"`Basic Authentication Tutorial "
"<http://www.voidspace.org.uk/python/articles/authentication.shtml>`_."
msgstr ""
"처리기를 만들고 설치하는 것을 설명하기 위해 ``HTTPBasicAuthHandler``\\를 사용합니다. 기본 인증(Basic "
"Authentication) 작동 방식에 대한 설명을 포함하여 이 주제에 대한 자세한 설명은 `Basic Authentication"
" Tutorial "
"<http://www.voidspace.org.uk/python/articles/authentication.shtml>`_\\을 "
"참조하십시오."

#: ../Doc/howto/urllib2.rst:463
msgid ""
"When authentication is required, the server sends a header (as well as "
"the 401 error code) requesting authentication.  This specifies the "
"authentication scheme and a 'realm'. The header looks like: ``WWW-"
"Authenticate: SCHEME realm=\"REALM\"``."
msgstr ""
"인증이 필요할 때, 서버는 (401 에러 코드와 함께) 인증을 요청하는 헤더를 보냅니다. 이것은 인증 스킴과 '영역(realm)'을"
" 지정합니다. 헤더는 이렇게 생겼습니다: ``WWW-Authenticate: SCHEME realm=\"REALM\"``."

#: ../Doc/howto/urllib2.rst:468
msgid "e.g."
msgstr "예를 들어"

#: ../Doc/howto/urllib2.rst:475
msgid ""
"The client should then retry the request with the appropriate name and "
"password for the realm included as a header in the request. This is "
"'basic authentication'. In order to simplify this process we can create "
"an instance of ``HTTPBasicAuthHandler`` and an opener to use this "
"handler."
msgstr ""
"그러면 클라이언트는 영역에 적절한 이름과 비밀번호를 요청의 헤더로 포함해 요청을 다시 시도해야 합니다. 이것이 '기본 "
"인증(basic authentication)'입니다. 이 프로세스를 단순화하기 위해 ``HTTPBasicAuthHandler`` "
"인스턴스와 이 처리기를 사용할 오프너를 만들 수 있습니다."

#: ../Doc/howto/urllib2.rst:480
msgid ""
"The ``HTTPBasicAuthHandler`` uses an object called a password manager to "
"handle the mapping of URLs and realms to passwords and usernames. If you "
"know what the realm is (from the authentication header sent by the "
"server), then you can use a ``HTTPPasswordMgr``. Frequently one doesn't "
"care what the realm is. In that case, it is convenient to use "
"``HTTPPasswordMgrWithDefaultRealm``. This allows you to specify a default"
" username and password for a URL. This will be supplied in the absence of"
" you providing an alternative combination for a specific realm. We "
"indicate this by providing ``None`` as the realm argument to the "
"``add_password`` method."
msgstr ""
"``HTTPBasicAuthHandler``\\는 비밀번호 관리자(password manager)라는 객체를 사용하여 URL과 "
"영역에서 비밀번호(password)와 사용자 이름(username)으로의 매핑을 처리합니다. (서버가 보낸 인증 헤더로부터) 영역이"
" 무엇인지 안다면, ``HTTPPasswordMgr``\\를 사용할 수 있습니다. 종종 영역이 무엇인지 상관하지 않습니다. 이 "
"경우, ``HTTPPasswordMgrWithDefaultRealm``\\를 사용하는 것이 편리합니다. 이것은 URL의 기본 사용자"
" 이름과 비밀번호를 지정할 수 있습니다. 특정 영역에 대한 대체 조합을 제공하지 않으면 이것이 제공됩니다. ``None``\\을 "
"``add_password`` 메서드에 대한 realm 인자로 제공하여 이를 나타냅니다."

#: ../Doc/howto/urllib2.rst:490
msgid ""
"The top-level URL is the first URL that requires authentication. URLs "
"\"deeper\" than the URL you pass to .add_password() will also match. ::"
msgstr ""
"최상위 URL은 인증이 필요한 첫 번째 URL입니다. .add_password()에 전달한 URL보다 \"더 깊은\" URL도 "
"일치합니다. ::"

#: ../Doc/howto/urllib2.rst:515
msgid ""
"In the above example we only supplied our ``HTTPBasicAuthHandler`` to "
"``build_opener``. By default openers have the handlers for normal "
"situations -- ``ProxyHandler`` (if a proxy setting such as an "
":envvar:`http_proxy` environment variable is set), ``UnknownHandler``, "
"``HTTPHandler``, ``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, "
"``FTPHandler``, ``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."
msgstr ""
"위의 예에서 ``HTTPBasicAuthHandler`` 만 ``build_opener``\\에 제공했습니다. 기본적으로 오프너에는"
" 일반적인 상황을 위한 처리기가 있습니다 -- ``ProxyHandler`` (:envvar:`http_proxy` 환경 변수와 "
"같은 프락시 설정이 설정된 경우), ``UnknownHandler``, ``HTTPHandler``, "
"``HTTPDefaultErrorHandler``, ``HTTPRedirectHandler``, ``FTPHandler``, "
"``FileHandler``, ``DataHandler``, ``HTTPErrorProcessor``."

#: ../Doc/howto/urllib2.rst:522
msgid ""
"``top_level_url`` is in fact *either* a full URL (including the 'http:' "
"scheme component and the hostname and optionally the port number) e.g. "
"``\"http://example.com/\"`` *or* an \"authority\" (i.e. the hostname, "
"optionally including the port number) e.g. ``\"example.com\"`` or "
"``\"example.com:8080\"`` (the latter example includes a port number).  "
"The authority, if present, must NOT contain the \"userinfo\" component - "
"for example ``\"joe:password@example.com\"`` is not correct."
msgstr ""
"``top_level_url``\\은 실제로 ('http:' 스킴 구성 요소와 호스트 이름 및 선택적인 포트 번호를 포함하는) 전체"
" URL, 예를 들어 ``\"http://example.com/\"`` *이거나* \"주체(authority)\" (즉, 선택적으로"
" 포트 번호를 포함하는 호스트명), 예를 들어 ``\"example.com\"``\\이나 "
"``\"example.com:8080\"`` (후자의 예는 포트 번호를 포함합니다)입니다. 주체가 있다면 \"userinfo\" "
"구성 요소를 포함하지 않아야 합니다 - 예를 들어 ``\"joe:password@example.com\"``\\은 올바르지 "
"않습니다."

#: ../Doc/howto/urllib2.rst:532
msgid "Proxies"
msgstr "프락시"

#: ../Doc/howto/urllib2.rst:534
msgid ""
"**urllib** will auto-detect your proxy settings and use those. This is "
"through the ``ProxyHandler``, which is part of the normal handler chain "
"when a proxy setting is detected.  Normally that's a good thing, but "
"there are occasions when it may not be helpful [#]_. One way to do this "
"is to setup our own ``ProxyHandler``, with no proxies defined. This is "
"done using similar steps to setting up a `Basic Authentication`_ handler:"
" ::"
msgstr ""
"**urllib**\\는 프락시 설정을 자동 감지하여 사용합니다. 이는 프락시 설정이 감지될 때 일반 처리기 체인의 일부가 되는 "
"``ProxyHandler``\\를 통해 이루어집니다. 일반적으로 좋은 일이지만, 도움이 되지 않는 경우가 있습니다 [#]_. 이를"
" 위한 한 가지 방법은 프락시가 정의되지 않은 자체 ``ProxyHandler``\\를 설정하는 것입니다. 이것은 `Basic "
"Authentication`_ 처리기 설정과 비슷한 단계를 사용하여 수행됩니다: ::"

#: ../Doc/howto/urllib2.rst:547
msgid ""
"Currently ``urllib.request`` *does not* support fetching of ``https`` "
"locations through a proxy.  However, this can be enabled by extending "
"urllib.request as shown in the recipe [#]_."
msgstr ""
"현재 ``urllib.request``\\는 프락시를 통한 ``https`` 위치를 가져오는 것을 지원하지 *않습니다*. 그러나, "
"조리법에 표시된 대로 urllib.request를 확장하여 활성화할 수 있습니다 [#]_."

#: ../Doc/howto/urllib2.rst:553
msgid ""
"``HTTP_PROXY`` will be ignored if a variable ``REQUEST_METHOD`` is set; "
"see the documentation on :func:`~urllib.request.getproxies`."
msgstr ""
"변수 ``REQUEST_METHOD``\\가 설정되면 ``HTTP_PROXY``\\는 무시됩니다; "
":func:`~urllib.request.getproxies`\\의 설명서를 참조하십시오."

#: ../Doc/howto/urllib2.rst:558
msgid "Sockets and Layers"
msgstr "소켓과 계층"

#: ../Doc/howto/urllib2.rst:560
msgid ""
"The Python support for fetching resources from the web is layered.  "
"urllib uses the :mod:`http.client` library, which in turn uses the socket"
" library."
msgstr ""
"웹에서 리소스를 가져오기 위한 파이썬 지원은 계층화되어 있습니다. urllib는 :mod:`http.client` 라이브러리를 "
"사용하고, 이것은 다시 socket 라이브러리를 사용합니다."

#: ../Doc/howto/urllib2.rst:563
msgid ""
"As of Python 2.3 you can specify how long a socket should wait for a "
"response before timing out. This can be useful in applications which have"
" to fetch web pages. By default the socket module has *no timeout* and "
"can hang. Currently, the socket timeout is not exposed at the http.client"
" or urllib.request levels. However, you can set the default timeout "
"globally for all sockets using ::"
msgstr ""
"파이썬 2.3부터 시간제한으로 중단되기 전에 소켓이 응답을 기다리는 시간을 지정할 수 있습니다. 웹 페이지를 가져와야 하는 응용 "
"프로그램에서 유용 할 수 있습니다. 기본적으로 소켓 모듈에는 *시간제한이 없고* 멈출(hang) 수 있습니다. 현재, 소켓 "
"시간제한은 http.client나 urllib.request 수준에서 노출되지 않습니다. 그러나, 다음과 같이 모든 소켓에 대해 "
"기본 시간제한을 전역적으로 설정할 수 있습니다 ::"

#: ../Doc/howto/urllib2.rst:586
msgid "Footnotes"
msgstr "각주"

#: ../Doc/howto/urllib2.rst:588
msgid "This document was reviewed and revised by John Lee."
msgstr "이 문서는 John Lee가 검토하고 수정했습니다."

#: ../Doc/howto/urllib2.rst:590
msgid "Google for example."
msgstr "예를 들어 구글."

#: ../Doc/howto/urllib2.rst:591
msgid ""
"Browser sniffing is a very bad practice for website design - building "
"sites using web standards is much more sensible. Unfortunately a lot of "
"sites still send different versions to different browsers."
msgstr ""
"브라우저 스니핑(browser sniffing)은 웹 사이트 디자인에 매우 나쁜 습관입니다 - 웹 표준을 사용하여 사이트를 구축하는"
" 것이 훨씬 합리적입니다. 불행히도 많은 사이트가 여전히 브라우저마다 다른 버전을 보냅니다."

#: ../Doc/howto/urllib2.rst:594
msgid ""
"The user agent for MSIE 6 is *'Mozilla/4.0 (compatible; MSIE 6.0; Windows"
" NT 5.1; SV1; .NET CLR 1.1.4322)'*"
msgstr ""
"MSIE 6의 사용자 에이전트(user agent)는 *'Mozilla/4.0 (compatible; MSIE 6.0; "
"Windows NT 5.1; SV1; .NET CLR 1.1.4322)'*\\입니다."

#: ../Doc/howto/urllib2.rst:596
msgid ""
"For details of more HTTP request headers, see `Quick Reference to HTTP "
"Headers`_."
msgstr "더 많은 HTTP 요청 헤더에 대한 자세한 내용은 `Quick Reference to HTTP Headers`_\\를 참조하십시오."

#: ../Doc/howto/urllib2.rst:598
msgid ""
"In my case I have to use a proxy to access the internet at work. If you "
"attempt to fetch *localhost* URLs through this proxy it blocks them. IE "
"is set to use the proxy, which urllib picks up on. In order to test "
"scripts with a localhost server, I have to prevent urllib from using the "
"proxy."
msgstr ""
"제 경우에는 직장에서 인터넷에 액세스하려면 프락시를 사용해야 합니다. 이 프락시를 통해 *localhost* URL을 가져오려고 "
"시도하면 차단됩니다. IE는 프락시를 사용하도록 설정되어 있고, urllib는 이것을 선택합니다. localhost 서버로 "
"스크립트를 테스트하려면, urllib가 프락시를 사용하지 못하게 해야 합니다."

#: ../Doc/howto/urllib2.rst:603
msgid ""
"urllib opener for SSL proxy (CONNECT method): `ASPN Cookbook Recipe "
"<https://code.activestate.com/recipes/456195/>`_."
msgstr ""
"SSL 프락시용 urllib 오프너 (CONNECT 메서드): `ASPN Cookbook Recipe "
"<https://code.activestate.com/recipes/456195/>`_."

