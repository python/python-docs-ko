# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-25 10:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/howto/ipaddress.rst:9
msgid "An introduction to the ipaddress module"
msgstr "ipaddress 모듈에 대한 소개"

#: ../Doc/howto/ipaddress.rst
msgid "author"
msgstr "저자"

#: ../Doc/howto/ipaddress.rst:11
msgid "Peter Moody"
msgstr "Peter Moody"

#: ../Doc/howto/ipaddress.rst:12
msgid "Nick Coghlan"
msgstr "Nick Coghlan"

msgid "Overview"
msgstr "개요"

#: ../Doc/howto/ipaddress.rst:16
msgid ""
"This document aims to provide a gentle introduction to the "
":mod:`ipaddress` module. It is aimed primarily at users that aren't "
"already familiar with IP networking terminology, but may also be useful "
"to network engineers wanting an overview of how :mod:`ipaddress` "
"represents IP network addressing concepts."
msgstr ""
"이 문서는 :mod:`ipaddress` 모듈을 간략하게 소개하고자 합니다. 주로 IP 네트워킹 용어에 익숙하지 않은 사용자를 "
"대상으로 하지만, :mod:`ipaddress`\\가 IP 네트워크 주소 개념을 나타내는 방식에 대한 개요를 원하는 네트워크 "
"엔지니어에게 유용할 수도 있습니다."

#: ../Doc/howto/ipaddress.rst:24
msgid "Creating Address/Network/Interface objects"
msgstr "주소/네트워크/인터페이스 객체 만들기"

#: ../Doc/howto/ipaddress.rst:26
msgid ""
"Since :mod:`ipaddress` is a module for inspecting and manipulating IP "
"addresses, the first thing you'll want to do is create some objects.  You"
" can use :mod:`ipaddress` to create objects from strings and integers."
msgstr ""
":mod:`ipaddress`\\는 IP 주소를 검사하고 조작하는 모듈이기 때문에, 가장 먼저 하고 싶어 할 일은 몇몇 객체를 "
"만드는 것입니다. :mod:`ipaddress`\\를 사용하여 문자열과 정수로 객체를 만들 수 있습니다."

#: ../Doc/howto/ipaddress.rst:32
msgid "A Note on IP Versions"
msgstr "IP 버전에 대한 참고 사항"

#: ../Doc/howto/ipaddress.rst:34
msgid ""
"For readers that aren't particularly familiar with IP addressing, it's "
"important to know that the Internet Protocol is currently in the process "
"of moving from version 4 of the protocol to version 6. This transition is"
" occurring largely because version 4 of the protocol doesn't provide "
"enough addresses to handle the needs of the whole world, especially given"
" the increasing number of devices with direct connections to the "
"internet."
msgstr ""
"특히 IP 주소 지정에 익숙하지 않은 독자는, 인터넷 프로토콜이 현재 프로토콜 버전 4에서 버전 6으로 이동하는 과정에 있음을 아는"
" 것이 중요합니다. 이러한 전환은 주로 프로토콜 버전 4가 전 세계의 요구 사항을 처리할 수 있는 충분한 주소를 제공하지 못하기 "
"때문에 발생하고 있습니다. 특히 인터넷에 직접 연결되는 장치의 수가 증가함에 따라 더욱더 그렇습니다."

#: ../Doc/howto/ipaddress.rst:41
msgid ""
"Explaining the details of the differences between the two versions of the"
" protocol is beyond the scope of this introduction, but readers need to "
"at least be aware that these two versions exist, and it will sometimes be"
" necessary to force the use of one version or the other."
msgstr ""
"프로토콜의 두 버전 간의 차이점에 대한 자세한 설명은 이 소개의 범위를 벗어나지만, 독자는 최소한 이 두 버전이 존재한다는 사실을 "
"알고 있어야 하며, 때로는 한 버전이나 다른 버전을 강제로 사용해야 할 필요가 있습니다."

#: ../Doc/howto/ipaddress.rst:48
msgid "IP Host Addresses"
msgstr "IP 호스트 주소"

#: ../Doc/howto/ipaddress.rst:50
msgid ""
"Addresses, often referred to as \"host addresses\" are the most basic "
"unit when working with IP addressing. The simplest way to create "
"addresses is to use the :func:`ipaddress.ip_address` factory function, "
"which automatically determines whether to create an IPv4 or IPv6 address "
"based on the passed in value:"
msgstr ""
"주소, 종종 \"호스트 주소\" 라고 하는 것은 IP 주소 지정으로 작업할 때 가장 기본 단위입니다. 주소를 만드는 가장 간단한 "
"방법은 :func:`ipaddress.ip_address` 팩토리 함수를 사용하는 것인데, 전달된 값을 기반으로 IPv4나 IPv6"
" 주소 중 어느 것을 만들지 자동으로 결정합니다:"

#: ../Doc/howto/ipaddress.rst:61
msgid ""
"Addresses can also be created directly from integers. Values that will "
"fit within 32 bits are assumed to be IPv4 addresses::"
msgstr "주소는 정수에서 직접 만들 수도 있습니다. 32비트에 들어맞는 값은 IPv4 주소로 간주합니다::"

#: ../Doc/howto/ipaddress.rst:69
msgid ""
"To force the use of IPv4 or IPv6 addresses, the relevant classes can be "
"invoked directly. This is particularly useful to force creation of IPv6 "
"addresses for small integers::"
msgstr ""
"IPv4나 IPv6 주소를 강제로 사용하려면, 해당 클래스를 직접 호출할 수 있습니다. 이것은 작은 정수를 위한 IPv6 주소 "
"생성을 강제하는 데 특히 유용합니다::"

#: ../Doc/howto/ipaddress.rst:82
msgid "Defining Networks"
msgstr "네트워크 정의"

#: ../Doc/howto/ipaddress.rst:84
msgid ""
"Host addresses are usually grouped together into IP networks, so "
":mod:`ipaddress` provides a way to create, inspect and manipulate network"
" definitions. IP network objects are constructed from strings that define"
" the range of host addresses that are part of that network. The simplest "
"form for that information is a \"network address/network prefix\" pair, "
"where the prefix defines the number of leading bits that are compared to "
"determine whether or not an address is part of the network and the "
"network address defines the expected value of those bits."
msgstr ""
"호스트 주소는 대개 IP 네트워크로 그룹화되므로, :mod:`ipaddress`\\는 네트워크 정의를 만들고, 검사하고, 조작할 "
"방법을 제공합니다. IP 네트워크 객체는 해당 네트워크의 일부인 호스트 주소의 범위를 정의하는 문자열로 만들어집니다. 이 정보의 "
"가장 간단한 형식은 \"네트워크 주소/네트워크 접두사\" 쌍입니다. 접두어는 주소가 네트워크 일부인지 판별하기 위해 비교되는 선행 "
"비트 수를 정의하고, 네트워크 주소는 그 비트들의 기대되는 값을 정의합니다."

#: ../Doc/howto/ipaddress.rst:93
msgid ""
"As for addresses, a factory function is provided that determines the "
"correct IP version automatically::"
msgstr "주소의 경우, 정확한 IP 버전을 자동으로 결정하는 팩토리 함수가 제공됩니다::"

#: ../Doc/howto/ipaddress.rst:101
msgid ""
"Network objects cannot have any host bits set.  The practical effect of "
"this is that ``192.0.2.1/24`` does not describe a network.  Such "
"definitions are referred to as interface objects since the ip-"
"on-a-network notation is commonly used to describe network interfaces of "
"a computer on a given network and are described further in the next "
"section."
msgstr ""
"네트워크 객체는 호스트 비트가 설정될 수 없습니다. 이것의 실제 효과는 ``192.0.2.1/24``\\가 네트워크를 설명하지 "
"않는다는 것입니다. 이러한 정의는 인터페이스 객체라고 불리는데, 그 이유는 주어진 네트워크상의 컴퓨터의 네트워크 인터페이스를 "
"기술하기 위해 네트워크상의 IP(ip-on-a-network) 표기법이 일반적으로 사용되기 때문입니다. 자세한 내용은 다음 절에서 "
"설명합니다."

#: ../Doc/howto/ipaddress.rst:107
msgid ""
"By default, attempting to create a network object with host bits set will"
" result in :exc:`ValueError` being raised. To request that the additional"
" bits instead be coerced to zero, the flag ``strict=False`` can be passed"
" to the constructor::"
msgstr ""
"기본적으로, 호스트 비트가 설정된 네트워크 객체를 만들려고 하면 :exc:`ValueError`\\가 발생합니다. 추가 비트를 "
"강제로 0으로 변환하도록 요청하려면, 플래그 ``strict=False``\\를 생성자에 전달할 수 있습니다::"

#: ../Doc/howto/ipaddress.rst:119
msgid ""
"While the string form offers significantly more flexibility, networks can"
" also be defined with integers, just like host addresses. In this case, "
"the network is considered to contain only the single address identified "
"by the integer, so the network prefix includes the entire network "
"address::"
msgstr ""
"문자열 형식은 유연성이 훨씬 뛰어나지만, 호스트 주소와 마찬가지로 정수로 네트워크를 정의할 수도 있습니다. 이 경우, 네트워크는 "
"정수로 식별되는 단일 주소만 포함하는 것으로 간주하므로, 네트워크 접두사는 전체 네트워크 주소를 포함합니다::"

#: ../Doc/howto/ipaddress.rst:129
msgid ""
"As with addresses, creation of a particular kind of network can be forced"
" by calling the class constructor directly instead of using the factory "
"function."
msgstr "주소와 마찬가지로, 팩토리 함수를 사용하는 대신 클래스 생성자를 직접 호출하여 특정 종류의 네트워크를 만들 수 있습니다."

#: ../Doc/howto/ipaddress.rst:135
msgid "Host Interfaces"
msgstr "호스트 인터페이스"

#: ../Doc/howto/ipaddress.rst:137
msgid ""
"As mentioned just above, if you need to describe an address on a "
"particular network, neither the address nor the network classes are "
"sufficient. Notation like ``192.0.2.1/24`` is commonly used by network "
"engineers and the people who write tools for firewalls and routers as "
"shorthand for \"the host ``192.0.2.1`` on the network ``192.0.2.0/24``\","
" Accordingly, :mod:`ipaddress` provides a set of hybrid classes that "
"associate an address with a particular network. The interface for "
"creation is identical to that for defining network objects, except that "
"the address portion isn't constrained to being a network address."
msgstr ""
"위에서 언급했듯이, 특정 네트워크상의 주소를 설명해야 하는 경우, 주소로도 네트워크 클래스로도 충분하지 않습니다. "
"``192.0.2.1/24``\\와 같은 표기법은 네트워크 엔지니어와 방화벽과 라우터 용 도구를 작성하는 사람들이 \"네트워크 "
"``192.0.2.0/24`` 상의 호스트 ``192.0.2.1``\\\" 의 줄임말로 많이 사용합니다. 따라서, "
":mod:`ipaddress`\\는 주소를 특정 네트워크와 결합하는 혼성 클래스 집합을 제공합니다. 생성을 위한 인터페이스는 주소 "
"부분이 네트워크 주소로 제한되지 않는 것을 제외하고는 네트워크 객체를 정의하는 것과 같습니다."

#: ../Doc/howto/ipaddress.rst:152
msgid ""
"Integer inputs are accepted (as with networks), and use of a particular "
"IP version can be forced by calling the relevant constructor directly."
msgstr "정수 입력이 받아들여지고 (네트워크처럼), 특정 IP 버전의 사용은 관련 생성자를 직접 호출함으로써 강제될 수 있습니다."

#: ../Doc/howto/ipaddress.rst:157
msgid "Inspecting Address/Network/Interface Objects"
msgstr "주소/네트워크/인터페이스 객체 검사"

#: ../Doc/howto/ipaddress.rst:159
msgid ""
"You've gone to the trouble of creating an "
"IPv(4|6)(Address|Network|Interface) object, so you probably want to get "
"information about it.  :mod:`ipaddress` tries to make doing this easy and"
" intuitive."
msgstr ""
"여러분은 IPv(4|6)(Address|Network|Interface) 객체를 만드는 데 어려움을 겪었다면, 아마도 이에 대한 "
"정보를 얻고 자 할 것입니다. :mod:`ipaddress`\\는 이 작업을 쉽고 직관적으로 만들려고 합니다."

#: ../Doc/howto/ipaddress.rst:163
msgid "Extracting the IP version::"
msgstr "IP 버전 추출하기::"

#: ../Doc/howto/ipaddress.rst:172
msgid "Obtaining the network from an interface::"
msgstr "인터페이스에서 네트워크 얻기::"

#: ../Doc/howto/ipaddress.rst:181
msgid "Finding out how many individual addresses are in a network::"
msgstr "네트워크에 있는 개별 주소의 개수 찾기::"

#: ../Doc/howto/ipaddress.rst:190
msgid "Iterating through the \"usable\" addresses on a network::"
msgstr "네트워크에서 \"사용 가능한\" 주소 이터레이트하기::"

#: ../Doc/howto/ipaddress.rst:205
msgid ""
"Obtaining the netmask (i.e. set bits corresponding to the network prefix)"
" or the hostmask (any bits that are not part of the netmask):"
msgstr ""
"넷 마스크(netmask)(즉, 네트워크 접두사에 해당하는 비트들)나 호스트 마스크(hostmask)(넷 마스크에 포함되지 않은 "
"비트들) 얻기:"

#: ../Doc/howto/ipaddress.rst:220
msgid "Exploding or compressing the address::"
msgstr "주소를 펼치거나 압축하기::"

#: ../Doc/howto/ipaddress.rst:231
msgid ""
"While IPv4 doesn't support explosion or compression, the associated "
"objects still provide the relevant properties so that version neutral "
"code can easily ensure the most concise or most verbose form is used for "
"IPv6 addresses while still correctly handling IPv4 addresses."
msgstr ""
"IPv4는 펼치기와 압축을 지원하지 않지만, 연관된 객체는 여전히 관련 프로퍼티를 제공하므로 버전 중립적인 코드가 IPv4 주소를 "
"올바르게 처리하면서도 IPv6 주소에 대해 가장 간결하거나 가장 자세한 형식을 쉽게 사용할 수 있습니다."

#: ../Doc/howto/ipaddress.rst:238
msgid "Networks as lists of Addresses"
msgstr "주소 리스트로서의 네트워크"

#: ../Doc/howto/ipaddress.rst:240
msgid ""
"It's sometimes useful to treat networks as lists.  This means it is "
"possible to index them like this::"
msgstr "네트워크를 리스트로 취급하는 것이 때로 유용합니다. 즉, 다음과 같이 인덱싱할 수 있습니다::"

#: ../Doc/howto/ipaddress.rst:253
msgid ""
"It also means that network objects lend themselves to using the list "
"membership test syntax like this::"
msgstr "이것은 또한 네트워크 객체가 다음과 같은 리스트 멤버십 테스트 문법을 사용하는 데 적합하다는 것을 의미합니다::"

#: ../Doc/howto/ipaddress.rst:259
msgid "Containment testing is done efficiently based on the network prefix::"
msgstr "포함 테스트는 네트워크 접두어를 기반으로 효율적으로 수행됩니다::"

#: ../Doc/howto/ipaddress.rst:269
msgid "Comparisons"
msgstr "비교"

#: ../Doc/howto/ipaddress.rst:271
msgid ""
":mod:`ipaddress` provides some simple, hopefully intuitive ways to "
"compare objects, where it makes sense::"
msgstr ":mod:`ipaddress`\\는 의미가 있는 곳에서 객체를 비교하는 간단하고 직관적인 방법을 제공합니다::"

#: ../Doc/howto/ipaddress.rst:277
msgid ""
"A :exc:`TypeError` exception is raised if you try to compare objects of "
"different versions or different types."
msgstr "다른 버전이나 다른 형의 객체를 비교하려고 하면 :exc:`TypeError` 예외가 발생합니다."

#: ../Doc/howto/ipaddress.rst:282
msgid "Using IP Addresses with other modules"
msgstr "다른 모듈과 함께 IP 주소 사용하기"

#: ../Doc/howto/ipaddress.rst:284
msgid ""
"Other modules that use IP addresses (such as :mod:`socket`) usually won't"
" accept objects from this module directly. Instead, they must be coerced "
"to an integer or string that the other module will accept::"
msgstr ""
"IP 주소를 사용하는 다른 모듈(가령 :mod:`socket`)은 일반적으로 이 모듈의 객체를 직접 받아들이지 않습니다. 대신, "
"다른 모듈이 받아들일 수 있는 정수나 문자열로 강제 변환되어야 합니다::"

#: ../Doc/howto/ipaddress.rst:296
msgid "Getting more detail when instance creation fails"
msgstr "인스턴스 생성 실패 시 세부 사항 가져오기"

#: ../Doc/howto/ipaddress.rst:298
msgid ""
"When creating address/network/interface objects using the version-"
"agnostic factory functions, any errors will be reported as "
":exc:`ValueError` with a generic error message that simply says the "
"passed in value was not recognized as an object of that type. The lack of"
" a specific error is because it's necessary to know whether the value is "
"*supposed* to be IPv4 or IPv6 in order to provide more detail on why it "
"has been rejected."
msgstr ""
"버전에 구애받지 않는 팩토리 함수를 사용하여 주소/네트워크/인터페이스 객체를 만들 때, 단순히 전달된 값이 해당 형의 객체로 "
"인식되지 않는다는 일반 에러 메시지와 함께 에러가 :exc:`ValueError`\\로 보고됩니다. 구체적인 에러가 없는 이유는 "
"거부된 이유에 대한 자세한 정보를 제공하기 위해서는 값이 IPv4나 IPv6 중 어는 것으로 *가정되는지*\\를 알아야 하기 "
"때문입니다."

#: ../Doc/howto/ipaddress.rst:305
msgid ""
"To support use cases where it is useful to have access to this additional"
" detail, the individual class constructors actually raise the "
":exc:`ValueError` subclasses :exc:`ipaddress.AddressValueError` and "
":exc:`ipaddress.NetmaskValueError` to indicate exactly which part of the "
"definition failed to parse correctly."
msgstr ""
"이 추가 세부 정보를 액세스하는 것이 유용한 사용 사례를 지원하기 위해, 개별 클래스 생성자는 실제로 "
":exc:`ValueError` 서브 클래스 :exc:`ipaddress.AddressValueError`\\와 "
":exc:`ipaddress.NetmaskValueError`\\를 발생시켜 정의의 어느 부분에서 구문 분석하는 데 실패했는지 "
"정확히 가리킵니다."

#: ../Doc/howto/ipaddress.rst:311
msgid ""
"The error messages are significantly more detailed when using the class "
"constructors directly. For example::"
msgstr "에러 메시지는 클래스 생성자를 직접 사용할 때 훨씬 자세해집니다. 예를 들어::"

#: ../Doc/howto/ipaddress.rst:332
msgid ""
"However, both of the module specific exceptions have :exc:`ValueError` as"
" their parent class, so if you're not concerned with the particular type "
"of error, you can still write code like the following::"
msgstr ""
"그러나, 두 모듈 특정 예외 모두 부모 클래스로 :exc:`ValueError`\\를 가지므로, 특정 유형의 에러에 관심이 없다면,"
" 여전히 다음과 같은 코드를 작성할 수 있습니다::"

