# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 11:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/howto/logging.rst:3
msgid "Logging HOWTO"
msgstr "로깅 HOWTO"

#: ../Doc/howto/logging.rst
msgid "Author"
msgstr "저자"

#: ../Doc/howto/logging.rst:5
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../Doc/howto/logging.rst:12
msgid "Basic Logging Tutorial"
msgstr "기초 로깅 자습서"

#: ../Doc/howto/logging.rst:14
msgid ""
"Logging is a means of tracking events that happen when some software "
"runs. The software's developer adds logging calls to their code to "
"indicate that certain events have occurred. An event is described by a "
"descriptive message which can optionally contain variable data (i.e. data"
" that is potentially different for each occurrence of the event). Events "
"also have an importance which the developer ascribes to the event; the "
"importance can also be called the *level* or *severity*."
msgstr ""
"로깅은 어떤 소프트웨어가 실행될 때 발생하는 이벤트를 추적하는 수단입니다. 소프트웨어 개발자는 코드에 로깅 호출을 추가하여 특정 이벤트가"
" 발생했음을 나타냅니다. 이벤트는 선택적으로 가변 데이터 (즉, 이벤트 발생마다 잠재적으로 다른 데이터)를 포함할 수 있는 설명 메시지로"
" 기술됩니다. 이벤트는 또한 개발자가 이벤트에 부여한 중요도를 가지고 있습니다; 중요도는 *수준(level)* 또는 "
"*심각도(severity)* 라고도 부를 수 있습니다."

#: ../Doc/howto/logging.rst:23
msgid "When to use logging"
msgstr "로깅을 사용할 때"

#: ../Doc/howto/logging.rst:25
msgid ""
"Logging provides a set of convenience functions for simple logging usage."
" These are :func:`debug`, :func:`info`, :func:`warning`, :func:`error` "
"and :func:`critical`. To determine when to use logging, see the table "
"below, which states, for each of a set of common tasks, the best tool to "
"use for it."
msgstr ""
"로깅은 간단한 로깅 사용을 위한 일련의 편리 함수를 제공합니다. :func:`debug`, :func:`info`, "
":func:`warning`, :func:`error` 그리고 :func:`critical` 입니다. 로깅을 사용할 때를 결정하려면 아래"
" 표를 참조하십시오. 일반적인 작업 집합 각각에 대해 사용하기에 가장 적합한 도구를 설명합니다."

#: ../Doc/howto/logging.rst:31
msgid "Task you want to perform"
msgstr "수행하려는 작업"

#: ../Doc/howto/logging.rst:31
msgid "The best tool for the task"
msgstr "작업을 위한 최상의 도구"

#: ../Doc/howto/logging.rst:33
msgid ""
"Display console output for ordinary usage of a command line script or "
"program"
msgstr "명령행 스크립트 또는 프로그램의 일반적인 사용을 위한 콘솔 출력 표시"

#: ../Doc/howto/logging.rst:33
msgid ":func:`print`"
msgstr ":func:`print`"

#: ../Doc/howto/logging.rst:37
msgid ""
"Report events that occur during normal operation of a program (e.g. for "
"status monitoring or fault investigation)"
msgstr "프로그램의 정상 작동 중에 발생하는 이벤트 보고 (가령 상태 모니터링이나 결함 조사)"

#: ../Doc/howto/logging.rst:37
msgid ""
":func:`logging.info` (or :func:`logging.debug` for very detailed output "
"for diagnostic purposes)"
msgstr ":func:`logging.info` (또는 진단 목적의 아주 자세한 출력의 경우 :func:`logging.debug`)"

#: ../Doc/howto/logging.rst:42
msgid "Issue a warning regarding a particular runtime event"
msgstr "특정 실행시간 이벤트와 관련하여 경고를 발행"

#: ../Doc/howto/logging.rst:42
msgid ""
":func:`warnings.warn` in library code if the issue is avoidable and the "
"client application should be modified to eliminate the warning"
msgstr ""
"라이브러리 코드에서 :func:`warnings.warn`: 문제를 피할 수 있고 경고를 제거하기 위해 클라이언트 응용 프로그램이 "
"수정되어야 하는 경우"

#: ../Doc/howto/logging.rst:47
msgid ""
":func:`logging.warning` if there is nothing the client application can do"
" about the situation, but the event should still be noted"
msgstr ""
":func:`logging.warning`: 클라이언트 응용 프로그램이 할 수 있는 일이 없는 상황이지만 이벤트를 계속 주목해야 하는 "
"경우"

#: ../Doc/howto/logging.rst:52
msgid "Report an error regarding a particular runtime event"
msgstr "특정 실행시간 이벤트와 관련하여 에러를 보고"

#: ../Doc/howto/logging.rst:52
msgid "Raise an exception"
msgstr "예외를 일으킵니다"

#: ../Doc/howto/logging.rst:55
msgid ""
"Report suppression of an error without raising an exception (e.g. error "
"handler in a long-running server process)"
msgstr "예외를 발생시키지 않고 에러의 억제를 보고 (가령 장기 실행 서버 프로세스의 에러 처리기)"

#: ../Doc/howto/logging.rst:55
msgid ""
":func:`logging.error`, :func:`logging.exception` or "
":func:`logging.critical` as appropriate for the specific error and "
"application domain"
msgstr ""
"구체적인 에러와 응용 프로그램 영역에 적절한 :func:`logging.error`, :func:`logging.exception`, "
":func:`logging.critical`"

#: ../Doc/howto/logging.rst:62
msgid ""
"The logging functions are named after the level or severity of the events"
" they are used to track. The standard levels and their applicability are "
"described below (in increasing order of severity):"
msgstr ""
"로깅 함수는 추적되는 이벤트의 수준 또는 심각도를 따라 명명됩니다. 표준 수준과 그 용도는 아래에 설명되어 있습니다 (심각도가 높아지는 "
"순서대로).:"

#: ../Doc/howto/logging.rst:69 ../Doc/howto/logging.rst:846
msgid "Level"
msgstr "수준"

#: ../Doc/howto/logging.rst:69
msgid "When it's used"
msgstr "사용할 때"

#: ../Doc/howto/logging.rst:71 ../Doc/howto/logging.rst:856
msgid "``DEBUG``"
msgstr "``DEBUG``"

#: ../Doc/howto/logging.rst:71
msgid "Detailed information, typically of interest only when diagnosing problems."
msgstr "상세한 정보. 보통 문제를 진단할 때만 필요합니다."

#: ../Doc/howto/logging.rst:74 ../Doc/howto/logging.rst:854
msgid "``INFO``"
msgstr "``INFO``"

#: ../Doc/howto/logging.rst:74
msgid "Confirmation that things are working as expected."
msgstr "예상대로 작동하는지에 대한 확인."

#: ../Doc/howto/logging.rst:77 ../Doc/howto/logging.rst:852
msgid "``WARNING``"
msgstr "``WARNING``"

#: ../Doc/howto/logging.rst:77
msgid ""
"An indication that something unexpected happened, or indicative of some "
"problem in the near future (e.g. 'disk space low'). The software is still"
" working as expected."
msgstr ""
"예상치 못한 일이 발생했거나 가까운 미래에 발생할 문제(예를 들어 '디스크 공간 부족')에 대한 표시. 소프트웨어는 여전히 예상대로 "
"작동합니다."

#: ../Doc/howto/logging.rst:82 ../Doc/howto/logging.rst:850
msgid "``ERROR``"
msgstr "``ERROR``"

#: ../Doc/howto/logging.rst:82
msgid ""
"Due to a more serious problem, the software has not been able to perform "
"some function."
msgstr "더욱 심각한 문제로 인해, 소프트웨어가 일부 기능을 수행하지 못했습니다."

#: ../Doc/howto/logging.rst:85 ../Doc/howto/logging.rst:848
msgid "``CRITICAL``"
msgstr "``CRITICAL``"

#: ../Doc/howto/logging.rst:85
msgid ""
"A serious error, indicating that the program itself may be unable to "
"continue running."
msgstr "심각한 에러. 프로그램 자체가 계속 실행되지 않을 수 있음을 나타냅니다."

#: ../Doc/howto/logging.rst:89
msgid ""
"The default level is ``WARNING``, which means that only events of this "
"level and above will be tracked, unless the logging package is configured"
" to do otherwise."
msgstr ""
"기본 수준은 ``WARNING`` 입니다. 이는 logging 패키지가 달리 구성되지 않는 한, 이 수준 이상의 이벤트만 추적된다는 것을"
" 의미합니다."

#: ../Doc/howto/logging.rst:93
msgid ""
"Events that are tracked can be handled in different ways. The simplest "
"way of handling tracked events is to print them to the console. Another "
"common way is to write them to a disk file."
msgstr ""
"추적되는 이벤트는 여러 방식으로 처리될 수 있습니다. 추적된 이벤트를 처리하는 가장 간단한 방법은 콘솔에 인쇄하는 것입니다. 또 다른 "
"일반적인 방법은 디스크 파일에 기록하는 것입니다."

#: ../Doc/howto/logging.rst:101
msgid "A simple example"
msgstr "간단한 예"

#: ../Doc/howto/logging.rst:103
msgid "A very simple example is::"
msgstr "아주 간단한 예는 이렇습니다::"

#: ../Doc/howto/logging.rst:109
msgid "If you type these lines into a script and run it, you'll see:"
msgstr "이 줄들을 스크립트에 입력하고 실행하면:"

#: ../Doc/howto/logging.rst:115
msgid ""
"printed out on the console. The ``INFO`` message doesn't appear because "
"the default level is ``WARNING``. The printed message includes the "
"indication of the level and the description of the event provided in the "
"logging call, i.e. 'Watch out!'. Don't worry about the 'root' part for "
"now: it will be explained later. The actual output can be formatted quite"
" flexibly if you need that; formatting options will also be explained "
"later."
msgstr ""
"이 콘솔에 출력됩니다. 기본 수준이 ``WARNING`` 이므로, ``INFO`` 메시지는 나타나지 않습니다. 인쇄된 메시지에는 수준 "
"표시와 로깅 호출에 제공된 이벤트의 설명(즉, 'Watch out!')이 포함됩니다. 당장은 'root' 부분에 대해서는 걱정하지 "
"마십시오: 나중에 설명합니다. 필요한 경우 실제 출력을 매우 유연하게 포맷 할 수 있습니다; 포매팅 옵션도 나중에 설명합니다."

#: ../Doc/howto/logging.rst:124
msgid "Logging to a file"
msgstr "파일에 로깅 하기"

#: ../Doc/howto/logging.rst:126
msgid ""
"A very common situation is that of recording logging events in a file, so"
" let's look at that next. Be sure to try the following in a newly-started"
" Python interpreter, and don't just continue from the session described "
"above::"
msgstr ""
"매우 일반적인 상황은 로깅 이벤트를 파일에 기록하는 것이므로, 다음으로 살펴보겠습니다. 새로 시작된 파이썬 인터프리터에서 다음을 "
"시도해보고, 위에서 설명한 세션을 계속 진행하지는 마십시오::"

#: ../Doc/howto/logging.rst:136
msgid ""
"And now if we open the file and look at what we have, we should find the "
"log messages:"
msgstr "이제 파일을 열고 내용을 살펴본다면, 로그 메시지를 찾을 수 있습니다:"

#: ../Doc/howto/logging.rst:145
msgid ""
"This example also shows how you can set the logging level which acts as "
"the threshold for tracking. In this case, because we set the threshold to"
" ``DEBUG``, all of the messages were printed."
msgstr ""
"이 예제는 추적 임곗값 역할을 하는 로깅 수준을 설정하는 방법도 보여줍니다. 이 경우 임곗값을 ``DEBUG`` 로 설정했기 때문에 모든"
" 메시지가 출력되었습니다."

#: ../Doc/howto/logging.rst:149
msgid "If you want to set the logging level from a command-line option such as:"
msgstr "다음과 같은 방식으로 명령행 옵션에서 로깅 수준을 설정하려고 하고:"

#: ../Doc/howto/logging.rst:155
msgid ""
"and you have the value of the parameter passed for ``--log`` in some "
"variable *loglevel*, you can use::"
msgstr "어떤 변수 *loglevel* 에 ``--log`` 로 전달된 매개 변수의 값이 들어있다면, 이런 방법으로::"

#: ../Doc/howto/logging.rst:160
msgid ""
"to get the value which you'll pass to :func:`basicConfig` via the *level*"
" argument. You may want to error check any user input value, perhaps as "
"in the following example::"
msgstr ""
"*level* 인자를 통해 :func:`basicConfig` 에게 전달할 값을 얻습니다. 아마 다음 예제에서와같이, 사용자 입력 값을 "
"오류 검사 하고 싶을 겁니다::"

#: ../Doc/howto/logging.rst:172
msgid ""
"The call to :func:`basicConfig` should come *before* any calls to "
":func:`debug`, :func:`info` etc. As it's intended as a one-off simple "
"configuration facility, only the first call will actually do anything: "
"subsequent calls are effectively no-ops."
msgstr ""
":func:`basicConfig` 에 대한 호출은 :func:`debug`, :func:`info` 등의 호출 *전*\\에 올 필요가 "
"있습니다. 일회용의 간단한 설정 기능으로 의도되었기 때문에, 오직 첫 번째 호출만 뭔가 할 수 있습니다: 후속 호출은 사실상 아무 작업도"
" 수행하지 않습니다."

#: ../Doc/howto/logging.rst:177
msgid ""
"If you run the above script several times, the messages from successive "
"runs are appended to the file *example.log*. If you want each run to "
"start afresh, not remembering the messages from earlier runs, you can "
"specify the *filemode* argument, by changing the call in the above "
"example to::"
msgstr ""
"위의 스크립트를 여러 번 실행하면, 후속 실행의 메시지가 *example.log* 파일에 추가됩니다. 이전 실행의 메시지를 기억하지 "
"않고, 각 실행이 새로 시작하게 하려면, 위 예제에서 호출이 *filemode* 인자를 지정하도록 다음과 같이 변경할 수 있습니다::"

#: ../Doc/howto/logging.rst:184
msgid ""
"The output will be the same as before, but the log file is no longer "
"appended to, so the messages from earlier runs are lost."
msgstr "출력은 이전과 같지만, 더는 로그 파일에 덧붙여지지 않으므로 이전 실행의 메시지는 손실됩니다."

#: ../Doc/howto/logging.rst:189
msgid "Logging from multiple modules"
msgstr "여러 모듈에서의 로깅"

#: ../Doc/howto/logging.rst:191
msgid ""
"If your program consists of multiple modules, here's an example of how "
"you could organize logging in it::"
msgstr "프로그램이 여러 모듈로 구성되어있는 경우, 로깅을 구성하는 방법의 예는 다음과 같습니다::"

#: ../Doc/howto/logging.rst:215
msgid "If you run *myapp.py*, you should see this in *myapp.log*:"
msgstr "*myapp.py* 를 실행하면, *myapp.log* 에 다음과 같이 표시됩니다:"

#: ../Doc/howto/logging.rst:223
msgid ""
"which is hopefully what you were expecting to see. You can generalize "
"this to multiple modules, using the pattern in *mylib.py*. Note that for "
"this simple usage pattern, you won't know, by looking in the log file, "
"*where* in your application your messages came from, apart from looking "
"at the event description. If you want to track the location of your "
"messages, you'll need to refer to the documentation beyond the tutorial "
"level -- see :ref:`logging-advanced-tutorial`."
msgstr ""
"여러분이 기대한 것이기를 바랍니다. *mylib.py* 의 패턴을 사용하여 이것을 여러 모듈로 일반화 할 수 있습니다. 이 간단한 사용 "
"패턴의 경우, 이벤트 설명을 보는 것 외에, 로그 파일을 들여다보는 것만으로는 메시지가 응용 프로그램의 *어디서* 왔는지 알 수 "
"없습니다. 메시지의 위치를 ​​추적하려면, 자습서 수준 이상의 문서를 참조해야 합니다 -- :ref:`logging-advanced-"
"tutorial`\\를 참조하세요."

#: ../Doc/howto/logging.rst:233
msgid "Logging variable data"
msgstr "변수 데이터 로깅"

#: ../Doc/howto/logging.rst:235
msgid ""
"To log variable data, use a format string for the event description "
"message and append the variable data as arguments. For example::"
msgstr "변수 데이터를 기록하려면, 이벤트 설명 메시지에 포맷 문자열을 사용하고 변수 데이터를 인자로 추가하십시오. 예를 들면::"

#: ../Doc/howto/logging.rst:241
msgid "will display:"
msgstr "이것은 다음과 같이 출력합니다:"

#: ../Doc/howto/logging.rst:247
#, python-format
msgid ""
"As you can see, merging of variable data into the event description "
"message uses the old, %-style of string formatting. This is for backwards"
" compatibility: the logging package pre-dates newer formatting options "
"such as :meth:`str.format` and :class:`string.Template`. These newer "
"formatting options *are* supported, but exploring them is outside the "
"scope of this tutorial: see :ref:`formatting-styles` for more "
"information."
msgstr ""
"보시다시피, 이벤트 설명 메시지에 가변 데이터를 병합하는데 이전 %-스타일의 문자열 포매팅을 사용합니다. 이전 버전과의 호환성을 위한 "
"것입니다: logging 패키지는 :meth:`str.format` 과 :class:`string.Template` 과 같은 새로운 "
"포매팅 옵션 이전부터 존재해왔습니다. 이 새로운 포매팅 옵션 *역시* 지원되지만, 이 자습서의 범위를 벗어납니다: 좀 더 자세한 정보는 "
":ref:`formatting-styles`\\를 참조하세요."

#: ../Doc/howto/logging.rst:256
msgid "Changing the format of displayed messages"
msgstr "표시된 메시지의 포맷 변경"

#: ../Doc/howto/logging.rst:258
msgid ""
"To change the format which is used to display messages, you need to "
"specify the format you want to use::"
msgstr "메시지를 표시하는 데 사용되는 포맷을 변경하려면 사용할 format을 지정해야 합니다::"

#: ../Doc/howto/logging.rst:267
msgid "which would print:"
msgstr "이것은 다음과 같이 인쇄합니다:"

#: ../Doc/howto/logging.rst:275
msgid ""
"Notice that the 'root' which appeared in earlier examples has "
"disappeared. For a full set of things that can appear in format strings, "
"you can refer to the documentation for :ref:`logrecord-attributes`, but "
"for simple usage, you just need the *levelname* (severity), *message* "
"(event description, including variable data) and perhaps to display when "
"the event occurred. This is described in the next section."
msgstr ""
"앞의 예제에서 나타난 'root' 가 사라졌음에 주목하십시오. 포맷 문자열에 나타날 수 있는 모든 것은 :ref:`logrecord-"
"attributes` 문서를 참고하게요. 하지만, 간단한 사용을 위해서는 *levelname* (심각도), *message* (이벤트 "
"설명, 변수 데이터 포함) 와 아마도 발생 시각을 표시해야 할 것입니다. 이것은 다음 섹션에서 설명합니다."

#: ../Doc/howto/logging.rst:284
msgid "Displaying the date/time in messages"
msgstr "메시지에 날짜/시간 표시"

#: ../Doc/howto/logging.rst:286
#, python-format
msgid ""
"To display the date and time of an event, you would place '%(asctime)s' "
"in your format string::"
msgstr "이벤트의 날짜와 시간을 표시하려면, 포맷 문자열에 '%(asctime)s' 을 넣으십시오::"

#: ../Doc/howto/logging.rst:293
msgid "which should print something like this:"
msgstr "이것은 이런 식으로 인쇄합니다:"

#: ../Doc/howto/logging.rst:299
msgid ""
"The default format for date/time display (shown above) is like ISO8601 or"
" :rfc:`3339`. If you need more control over the formatting of the "
"date/time, provide a *datefmt* argument to ``basicConfig``, as in this "
"example::"
msgstr ""
"(위에 나온) 날짜/시간 표시의 기본 포맷은 ISO8601 또는 :rfc:`3339`\\와 같습니다. 날짜/시간의 포맷을 좀 더 제어해야"
" 하는 경우, 이 예제에서와같이 ``basicConfig`` 에 *datefmt* 인자를 제공하십시오::"

#: ../Doc/howto/logging.rst:307
msgid "which would display something like this:"
msgstr "그러면 다음과 같이 표시됩니다:"

#: ../Doc/howto/logging.rst:313
msgid ""
"The format of the *datefmt* argument is the same as supported by "
":func:`time.strftime`."
msgstr "*datefmt* 인자의 형식은 :func:`time.strftime` 에 의해 지원되는 것과 같습니다."

#: ../Doc/howto/logging.rst:318
msgid "Next Steps"
msgstr "다음 단계"

#: ../Doc/howto/logging.rst:320
msgid ""
"That concludes the basic tutorial. It should be enough to get you up and "
"running with logging. There's a lot more that the logging package offers,"
" but to get the best out of it, you'll need to invest a little more of "
"your time in reading the following sections. If you're ready for that, "
"grab some of your favourite beverage and carry on."
msgstr ""
"이것으로 기본 자습서를 마칩니다. 여러분이 로깅을 시작하고 사용하는데 충분할 겁니다. logging 패키지가 더 많은 것들을 제공하지만,"
" 최선의 결과를 얻으려면 다음 섹션을 읽는 데 시간을 조금 더 투자하시기 바랍니다. 준비되었다면, 좋아하는 음료 한잔 준비하시고 "
"계속합시다."

#: ../Doc/howto/logging.rst:326
msgid ""
"If your logging needs are simple, then use the above examples to "
"incorporate logging into your own scripts, and if you run into problems "
"or don't understand something, please post a question on the "
"comp.lang.python Usenet group (available at "
"https://groups.google.com/forum/#!forum/comp.lang.python) and you should "
"receive help before too long."
msgstr ""
"로깅 요구가 간단하면, 위의 예제를 사용하여 자신의 스크립트에 로깅을 통합하십시오. 문제가 발생하거나 이해할 수 없는 부분이 있으면 "
"comp.lang.python 유즈넷 그룹에 질문을 올리십시오 "
"(https://groups.google.com/forum/#!forum/comp.lang.python 에 있습니다). 도움을 받는 데 "
"아주 오래 걸리지는 않을 겁니다."

#: ../Doc/howto/logging.rst:332
msgid ""
"Still here? You can carry on reading the next few sections, which provide"
" a slightly more advanced/in-depth tutorial than the basic one above. "
"After that, you can take a look at the :ref:`logging-cookbook`."
msgstr ""
"아직 계신가요? 위의 기본 섹션보다 약간 더 고급/심층적인 자습서를 제공하는 다음 몇 섹션을 계속 읽을 수 있습니다. 그 후에, "
":ref:`logging-cookbook`\\을 살펴볼 수 있습니다."

#: ../Doc/howto/logging.rst:340
msgid "Advanced Logging Tutorial"
msgstr "고급 로깅 ​​자습서"

#: ../Doc/howto/logging.rst:342
msgid ""
"The logging library takes a modular approach and offers several "
"categories of components: loggers, handlers, filters, and formatters."
msgstr ""
"logging 라이브러리는 모듈 방식으로 구성되며, 로거, 처리기, 필터 및 포매터와 같은 여러 범주의 구성 요소를 제공합니다."

#: ../Doc/howto/logging.rst:345
msgid "Loggers expose the interface that application code directly uses."
msgstr "로거는 응용 프로그램 코드가 직접 사용하는 인터페이스를 노출합니다."

#: ../Doc/howto/logging.rst:346
msgid ""
"Handlers send the log records (created by loggers) to the appropriate "
"destination."
msgstr "처리기는 (로거에 의해 만들어진) 로그 레코드를 적절한 목적지로 보냅니다."

#: ../Doc/howto/logging.rst:348
msgid ""
"Filters provide a finer grained facility for determining which log "
"records to output."
msgstr "필터는 출력할 로그 레코드를 결정하기 위한 보다 정밀한 기능을 제공합니다."

#: ../Doc/howto/logging.rst:350
msgid "Formatters specify the layout of log records in the final output."
msgstr "포매터는 최종 출력에서 ​​로그 레코드의 배치를 지정합니다."

#: ../Doc/howto/logging.rst:352
msgid ""
"Log event information is passed between loggers, handlers, filters and "
"formatters in a :class:`LogRecord` instance."
msgstr "로그 이벤트 정보는 :class:`LogRecord` 인스턴스를 통해 로거, 처리기, 필터 및 포매터 간에 전달됩니다."

#: ../Doc/howto/logging.rst:355
msgid ""
"Logging is performed by calling methods on instances of the "
":class:`Logger` class (hereafter called :dfn:`loggers`). Each instance "
"has a name, and they are conceptually arranged in a namespace hierarchy "
"using dots (periods) as separators. For example, a logger named 'scan' is"
" the parent of loggers 'scan.text', 'scan.html' and 'scan.pdf'. Logger "
"names can be anything you want, and indicate the area of an application "
"in which a logged message originates."
msgstr ""
"로깅은 :class:`Logger` 클래스(이하 :dfn:`로거 (loggers)` 라고 합니다) 인스턴스의 메서드를 호출하여 "
"수행됩니다. 각 인스턴스에는 이름이 있으며, 점(마침표)을 구분 기호로 사용하여 개념적으로는 이름 공간 계층 구조로 배열됩니다. 예를 "
"들어, 'scan'이라는 로거는 'scan.text', 'scan.html' 및 'scan.pdf' 로거의 부모입니다. 로거 이름은 "
"원하는 어떤 것이건 될 수 있으며, 로그 된 메시지가 시작된 응용 프로그램 영역을 나타냅니다."

#: ../Doc/howto/logging.rst:362
msgid ""
"A good convention to use when naming loggers is to use a module-level "
"logger, in each module which uses logging, named as follows::"
msgstr "로거의 이름을 지을 때 사용할 좋은 규칙은 다음과 같이 로깅을 사용하는 각 모듈에서 모듈 수준 로거를 사용하는 것입니다::"

#: ../Doc/howto/logging.rst:367
msgid ""
"This means that logger names track the package/module hierarchy, and it's"
" intuitively obvious where events are logged just from the logger name."
msgstr ""
"이것은 로거 이름이 패키지/모듈 계층을 추적한다는 것을 의미하며, 로거 이름으로부터 이벤트가 기록되는 위치를 직관적으로 명확히 알 수 "
"있습니다."

#: ../Doc/howto/logging.rst:370
msgid ""
"The root of the hierarchy of loggers is called the root logger. That's "
"the logger used by the functions :func:`debug`, :func:`info`, "
":func:`warning`, :func:`error` and :func:`critical`, which just call the "
"same-named method of the root logger. The functions and the methods have "
"the same signatures. The root logger's name is printed as 'root' in the "
"logged output."
msgstr ""
"로거 계층의 뿌리를 루트 로거라고 합니다. 이것이 :func:`debug`, :func:`info`, :func:`warning`, "
":func:`error` 그리고 :func:`critical` 함수에 의해 사용되는 로거인데, 루트 로거의 같은 이름의 메서드들 "
"호출합니다. 함수와 메서드는 같은 서명을 가집니다. 루트 로거의 이름은 로그 된 출력에 'root' 로 인쇄됩니다."

#: ../Doc/howto/logging.rst:376
msgid ""
"It is, of course, possible to log messages to different destinations. "
"Support is included in the package for writing log messages to files, "
"HTTP GET/POST locations, email via SMTP, generic sockets, queues, or OS-"
"specific logging mechanisms such as syslog or the Windows NT event log. "
"Destinations are served by :dfn:`handler` classes. You can create your "
"own log destination class if you have special requirements not met by any"
" of the built-in handler classes."
msgstr ""
"물론 로그 메시지를 다른 대상에 기록하는 것도 가능합니다. 로그 메시지를 파일, HTTP GET/POST 위치, SMTP를 통한 전자 "
"메일, 일반 소켓, 큐 또는 syslog 나 윈도우 NT 이벤트 로그와 같은 OS 특정 로깅 메커니즘에 쓰는 지원이 패키지에 포함되어 "
"있습니다. 목적지는 :dfn:`처리기 (handler)` 클래스에 의해 제공됩니다. 내장된 처리기 클래스에 의해 충족되지 않는 특별한 "
"요구 사항이 있는 경우, 자체 로그 대상 클래스를 작성할 수 있습니다."

#: ../Doc/howto/logging.rst:383
msgid ""
"By default, no destination is set for any logging messages. You can "
"specify a destination (such as console or file) by using "
":func:`basicConfig` as in the tutorial examples. If you call the "
"functions  :func:`debug`, :func:`info`, :func:`warning`, :func:`error` "
"and :func:`critical`, they will check to see if no destination is set; "
"and if one is not set, they will set a destination of the console "
"(``sys.stderr``) and a default format for the displayed message before "
"delegating to the root logger to do the actual message output."
msgstr ""
"기본적으로, 로그 메시지에는 대상이 설정되지 않습니다. 자습서 예제에서와같이 :func:`basicConfig`\\를 사용하여 대상(가령"
" 콘솔 또는 파일)을 지정할 수 있습니다. :func:`debug`, :func:`info`, :func:`warning`, "
":func:`error` 및 :func:`critical` 함수를 호출하면 목적지가 설정되어 있지 않은지 확인합니다; 설정되지 않았다면,"
" 실제 메시지 출력을 하기 위해 루트 로거에 위임하기 전에, 콘솔(``sys.stderr``)을 대상으로 설정하고 표시되는 메시지의 기본"
" 포맷을 설정합니다."

#: ../Doc/howto/logging.rst:391
msgid "The default format set by :func:`basicConfig` for messages is:"
msgstr "메시지에 대해 :func:`basicConfig` 에 의해 설정된 기본 포맷은 다음과 같습니다:"

#: ../Doc/howto/logging.rst:397
msgid ""
"You can change this by passing a format string to :func:`basicConfig` "
"with the *format* keyword argument. For all options regarding how a "
"format string is constructed, see :ref:`formatter-objects`."
msgstr ""
"포맷 문자열을 *format* 키워드 인자로 :func:`basicConfig` 에 전달하여 이를 변경할 수 있습니다. 포맷 문자열 작성"
" 방법과 관련된 모든 옵션은 :ref:`formatter-objects`\\를 참조하십시오."

#: ../Doc/howto/logging.rst:402
msgid "Logging Flow"
msgstr "로깅 흐름"

#: ../Doc/howto/logging.rst:404
msgid ""
"The flow of log event information in loggers and handlers is illustrated "
"in the following diagram."
msgstr "로거 및 처리기에서 로그 이벤트 정보의 흐름은 다음 도표에 설명되어 있습니다."

#: ../Doc/howto/logging.rst:410
msgid "Loggers"
msgstr "로거"

#: ../Doc/howto/logging.rst:412
msgid ""
":class:`Logger` objects have a threefold job.  First, they expose several"
" methods to application code so that applications can log messages at "
"runtime. Second, logger objects determine which log messages to act upon "
"based upon severity (the default filtering facility) or filter objects.  "
"Third, logger objects pass along relevant log messages to all interested "
"log handlers."
msgstr ""
":class:`Logger` 객체는 세 가지 작업을 합니다. 첫째, 응용 프로그램이 실행시간에 메시지를 기록 할 수 있도록 여러 메서드를"
" 응용 프로그램 코드에 노출합니다. 둘째, 로거 객체는 심각도 (기본 필터링 장치) 또는 필터 객체에 따라 어떤 로그 메시지를 처리할지 "
"결정합니다. 셋째, 로거 객체는 관련 로그 메시지를 관심 있는 모든 로그 처리기로 전달합니다."

#: ../Doc/howto/logging.rst:418
msgid ""
"The most widely used methods on logger objects fall into two categories: "
"configuration and message sending."
msgstr "로거 객체에서 가장 널리 사용되는 메서드는 두 가지 범주로 분류됩니다: 구성 및 메시지 전송"

#: ../Doc/howto/logging.rst:421
msgid "These are the most common configuration methods:"
msgstr "다음은 가장 일반적인 구성 메서드입니다:"

#: ../Doc/howto/logging.rst:423
msgid ""
":meth:`Logger.setLevel` specifies the lowest-severity log message a "
"logger will handle, where debug is the lowest built-in severity level and"
" critical is the highest built-in severity.  For example, if the severity"
" level is INFO, the logger will handle only INFO, WARNING, ERROR, and "
"CRITICAL messages and will ignore DEBUG messages."
msgstr ""
":meth:`Logger.setLevel`\\은 로거가 처리할 가장 낮은 심각도의 로그 메시지를 지정합니다. debug은 가장 낮은 내장"
" 심각도 수준이고 critical은 가장 높은 내장 심각도입니다. 예를 들어, 심각도 수준이 INFO이면 로거는 INFO, "
"WARNING, ERROR 및 CRITICAL 메시지만 처리하고 DEBUG 메시지는 무시합니다."

#: ../Doc/howto/logging.rst:429
msgid ""
":meth:`Logger.addHandler` and :meth:`Logger.removeHandler` add and remove"
" handler objects from the logger object.  Handlers are covered in more "
"detail in :ref:`handler-basic`."
msgstr ""
":meth:`Logger.addHandler` 와 :meth:`Logger.removeHandler` 는 로거 객체에서 처리기 객체를 "
"추가하고 제거합니다. 처리기는 :ref:`handler-basic`\\에서 더욱 자세히 다룹니다."

#: ../Doc/howto/logging.rst:433
msgid ""
":meth:`Logger.addFilter` and :meth:`Logger.removeFilter` add and remove "
"filter objects from the logger object.  Filters are covered in more "
"detail in :ref:`filter`."
msgstr ""
":meth:`Logger.addFilter` 와 :meth:`Logger.removeFilter` 는 로거 객체에서 필터 객체를 추가하고"
" 제거합니다. 필터는 :ref:`filter`\\에서 더욱 자세히 다룹니다."

#: ../Doc/howto/logging.rst:437
msgid ""
"You don't need to always call these methods on every logger you create. "
"See the last two paragraphs in this section."
msgstr "생성 한 모든 로거에서 항상 이 메서드를 호출할 필요는 없습니다. 이 섹션의 마지막 두 단락을 참조하십시오."

#: ../Doc/howto/logging.rst:440
msgid ""
"With the logger object configured, the following methods create log "
"messages:"
msgstr "로거 객체가 구성된 상태에서 다음 메서드는 로그 메시지를 만듭니다:"

#: ../Doc/howto/logging.rst:442
#, python-format
msgid ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, "
":meth:`Logger.error`, and :meth:`Logger.critical` all create log records "
"with a message and a level that corresponds to their respective method "
"names. The message is actually a format string, which may contain the "
"standard string substitution syntax of ``%s``, ``%d``, ``%f``, and so on."
"  The rest of their arguments is a list of objects that correspond with "
"the substitution fields in the message.  With regard to ``**kwargs``, the"
" logging methods care only about a keyword of ``exc_info`` and use it to "
"determine whether to log exception information."
msgstr ""
":meth:`Logger.debug`, :meth:`Logger.info`, :meth:`Logger.warning`, "
":meth:`Logger.error` 그리고 :meth:`Logger.critical`\\은 모두 메시지 와 메서드 이름에 해당하는 "
"수준으로 로그 레코드를 만듭니다. 메시지는 실제로는 포맷 문자열이며, ``%s``, ``%d``, ``%f`` 등의 표준 문자열 치환 "
"문법을 포함 할 수 있습니다. 나머지 인자들은 메시지의 치환 필드에 해당하는 객체 목록입니다. ``**kwargs`` 의 경우, 로깅 "
"메서드는 ``exc_info`` 라는 키워드에 대해서만 신경을 쓰고 예외 정보를 로깅 할지를 결정할 때 사용합니다."

#: ../Doc/howto/logging.rst:452
msgid ""
":meth:`Logger.exception` creates a log message similar to "
":meth:`Logger.error`.  The difference is that :meth:`Logger.exception` "
"dumps a stack trace along with it.  Call this method only from an "
"exception handler."
msgstr ""
":meth:`Logger.exception` 은 :meth:`Logger.error` 와 비슷한 로그 메시지를 생성합니다. 차이점은 "
":meth:`Logger.exception` 가 스택 트레이스를 덤프한다는 것입니다. 예외 처리기에서만 이 메서드를 호출하십시오."

#: ../Doc/howto/logging.rst:456
msgid ""
":meth:`Logger.log` takes a log level as an explicit argument.  This is a "
"little more verbose for logging messages than using the log level "
"convenience methods listed above, but this is how to log at custom log "
"levels."
msgstr ""
":meth:`Logger.log` 는 명시적 인자로 로그 수준을 받아들입니다. 위에 나열된 로그 수준 편의 메서드를 사용하는 것보다 로깅"
" 메시지를 만들 때 더 장황해지지만, 사용자 정의 로그 수준으로 로깅 하는 방법입니다."

#: ../Doc/howto/logging.rst:460
msgid ""
":func:`getLogger` returns a reference to a logger instance with the "
"specified name if it is provided, or ``root`` if not.  The names are "
"period-separated hierarchical structures.  Multiple calls to "
":func:`getLogger` with the same name will return a reference to the same "
"logger object.  Loggers that are further down in the hierarchical list "
"are children of loggers higher up in the list. For example, given a "
"logger with a name of ``foo``, loggers with names of ``foo.bar``, "
"``foo.bar.baz``, and ``foo.bam`` are all descendants of ``foo``."
msgstr ""
":func:`getLogger` 는 이름이 제공되는 경우 지정된 이름을 가진 로거 인스턴스에 대한 참조를 반환하고, 그렇지 않으면 "
"``root`` 를 반환합니다. 이름은 마침표로 구분된 계층적 구조입니다. 같은 이름으로 :func:`getLogger` 를 여러 번 "
"호출하면 같은 로거 객체에 대한 참조를 반환합니다. 계층적 목록에서 더 아래쪽에 있는 로거는 목록에서 상위에 있는 로거의 자식입니다. "
"예를 들어, 이름이 ``foo`` 인 로거가 주어지면, ``foo.bar``, ``foo.bar.baz``, 그리고 ``foo.bam``"
" 의 이름을 가진 로거는 모두 ``foo`` 의 자손입니다."

#: ../Doc/howto/logging.rst:468
msgid ""
"Loggers have a concept of *effective level*. If a level is not explicitly"
" set on a logger, the level of its parent is used instead as its "
"effective level. If the parent has no explicit level set, *its* parent is"
" examined, and so on - all ancestors are searched until an explicitly set"
" level is found. The root logger always has an explicit level set "
"(``WARNING`` by default). When deciding whether to process an event, the "
"effective level of the logger is used to determine whether the event is "
"passed to the logger's handlers."
msgstr ""
"로거에는 *실효 수준* 이라는 개념이 있습니다. 수준이 로거에 명시적으로 설정되지 않은 경우, 부모 수준을 실효 수준으로 대신 "
"사용합니다. 부모가 명시적 수준 집합을 가지고 있지 않으면, 다시 그것의 부모가 검사되고, 등등 - 명시적으로 설정된 수준이 발견될 "
"때까지 모든 조상이 검색됩니다. 루트 로거는 항상 명시적인 수준 집합(기본적으로 ``WARNING``)을 가지고 있습니다. 이벤트 처리 "
"여부를 결정할 때, 로거의 실효 수준이 이벤트가 로거 처리기로 전달되는지를 판별하는 데 사용됩니다."

#: ../Doc/howto/logging.rst:476
msgid ""
"Child loggers propagate messages up to the handlers associated with their"
" ancestor loggers. Because of this, it is unnecessary to define and "
"configure handlers for all the loggers an application uses. It is "
"sufficient to configure handlers for a top-level logger and create child "
"loggers as needed. (You can, however, turn off propagation by setting the"
" *propagate* attribute of a logger to ``False``.)"
msgstr ""
"자식 로거는 조상 로거와 연관된 처리기로 메시지를 전달합니다. 이 때문에 응용 프로그램에서 사용하는 모든 로거에 대해 처리기를 정의하고 "
"구성할 필요가 없습니다. 최상위 수준 로거에 대한 처리기를 구성하고 필요에 따라 자식 로거를 만드는 것으로 충분합니다. (그러나, 로거의"
" *propagate* 어트리뷰트를 ``False`` 로 설정하여 전파를 끌 수 있습니다.)"

#: ../Doc/howto/logging.rst:487
msgid "Handlers"
msgstr "처리기"

#: ../Doc/howto/logging.rst:489
msgid ""
":class:`~logging.Handler` objects are responsible for dispatching the "
"appropriate log messages (based on the log messages' severity) to the "
"handler's specified destination.  :class:`Logger` objects can add zero or"
" more handler objects to themselves with an :meth:`~Logger.addHandler` "
"method.  As an example scenario, an application may want to send all log "
"messages to a log file, all log messages of error or higher to stdout, "
"and all messages of critical to an email address. This scenario requires "
"three individual handlers where each handler is responsible for sending "
"messages of a specific severity to a specific location."
msgstr ""
":class:`~logging.Handler` 객체는 (로그 메시지의 심각도를 기반으로) 적절한 로그 메시지를 처리기의 지정된 대상으로 "
"전달하는 역할을 합니다. :class:`Logger` 객체는 :meth:`~Logger.addHandler` 메서드를 사용하여 0개 "
"이상의 처리기 객체를 자신에게 추가 할 수 있습니다. 예를 들어, 응용 프로그램은 모든 로그 메시지를 로그 파일로 보내고, "
"에러(error)와 그 이상의 모든 로그 메시지를 표준 출력으로 보내고, 모든 심각한 에러(critical) 메시지를 전자 메일 주소로 "
"보낼 수 있습니다. 이 시나리오에서는 각 처리기가 특정 심각도의 메시지를 특정 위치로 보내는 3개의 개별 처리기가 필요합니다."

#: ../Doc/howto/logging.rst:499
msgid ""
"The standard library includes quite a few handler types (see :ref"
":`useful-handlers`); the tutorials use mainly :class:`StreamHandler` and "
":class:`FileHandler` in its examples."
msgstr ""
"표준 라이브러리에는 꽤 많은 처리기형이 포함되어있습니다 (:ref:`useful-handlers` 참조). 자습서는 주로 "
":class:`StreamHandler` 와 :class:`FileHandler` 를 예제에서 사용합니다."

#: ../Doc/howto/logging.rst:503
msgid ""
"There are very few methods in a handler for application developers to "
"concern themselves with.  The only handler methods that seem relevant for"
" application developers who are using the built-in handler objects (that "
"is, not creating custom handlers) are the following configuration "
"methods:"
msgstr ""
"처리기에는 응용 프로그램 개발자가 직접 신경 써야 할 메서드가 거의 없습니다. 기본 제공 처리기 객체를 사용하는 (즉, 사용자 정의 "
"처리기를 만들지 않는) 응용 프로그램 개발자와 관련이 있는 처리기 메서드는 다음과 같은 구성 메서드뿐입니다:"

#: ../Doc/howto/logging.rst:508
msgid ""
"The :meth:`~Handler.setLevel` method, just as in logger objects, "
"specifies the lowest severity that will be dispatched to the appropriate "
"destination.  Why are there two :func:`setLevel` methods?  The level set "
"in the logger determines which severity of messages it will pass to its "
"handlers.  The level set in each handler determines which messages that "
"handler will send on."
msgstr ""
":meth:`~Handler.setLevel` 메서드는 로거 객체에서와 마찬가지로 적절한 목적지로 보내지는 가장 낮은 심각도를 "
"지정합니다. 왜 두 개의 :func:`setLevel` 메서드가 있어야 할까요? 로거에 설정된 수준은 처리기에 전달할 메시지의 심각도를 "
"판별합니다. 각 처리기에 설정된 수준은 처리기가 전송할 메시지를 결정합니다."

#: ../Doc/howto/logging.rst:514
msgid ""
":meth:`~Handler.setFormatter` selects a Formatter object for this handler"
" to use."
msgstr ":meth:`~Handler.setFormatter` 는 처리기가 사용할 포매터 객체를 선택합니다."

#: ../Doc/howto/logging.rst:517
msgid ""
":meth:`~Handler.addFilter` and :meth:`~Handler.removeFilter` respectively"
" configure and deconfigure filter objects on handlers."
msgstr ""
":meth:`~Handler.addFilter` 와 :meth:`~Handler.removeFilter` 는 각각 처리기에서 필터 객체를"
" 구성하고 해제합니다."

#: ../Doc/howto/logging.rst:520
msgid ""
"Application code should not directly instantiate and use instances of "
":class:`Handler`.  Instead, the :class:`Handler` class is a base class "
"that defines the interface that all handlers should have and establishes "
"some default behavior that child classes can use (or override)."
msgstr ""
"응용 프로그램 코드는 :class:`Handler` 의 인스턴스를 직접 인스턴스화해서 사용해서는 안 됩니다. 대신, "
":class:`Handler` 클래스는 모든 처리기가 가져야 하는 인터페이스를 정의하고 자식 클래스가 사용할 수 있는 (또는 재정의할 수"
" 있는) 기본 동작을 설정하는 베이스 클래스입니다."

#: ../Doc/howto/logging.rst:527
msgid "Formatters"
msgstr "포매터"

#: ../Doc/howto/logging.rst:529
msgid ""
"Formatter objects configure the final order, structure, and contents of "
"the log message.  Unlike the base :class:`logging.Handler` class, "
"application code may instantiate formatter classes, although you could "
"likely subclass the formatter if your application needs special behavior."
"  The constructor takes three optional arguments -- a message format "
"string, a date format string and a style indicator."
msgstr ""
"포매터 객체는 로그 메시지의 최종 순서, 구조 및 내용을 구성합니다. 베이스 :class:`logging.Handler` 클래스와는 "
"달리, 응용 프로그램 코드는 포매터 클래스를 인스턴스화 할 수 있습니다. 응용 프로그램에 특별한 동작이 필요한 경우 포매터의 서브 "
"클래스를 만들 수도 있습니다. 생성자는 세 가지 선택적 인자를 취합니다 -- 메시지 포맷 문자열, 날짜 포맷 문자열 및 스타일 지시자."

#: ../Doc/howto/logging.rst:538
msgid ""
"If there is no message format string, the default is to use the raw "
"message.  If there is no date format string, the default date format is:"
msgstr ""
"메시지 포맷 문자열이 없으면, 기본값은 날 메시지를 사용하는 것입니다. 날짜 포맷 문자열이 없으면, 기본 날짜 형식은 다음과 같습니다:"

#: ../Doc/howto/logging.rst:545
msgid ""
"with the milliseconds tacked on at the end. The ``style`` is one of `%`, "
"'{' or '$'. If one of these is not specified, then '%' will be used."
msgstr ""
"끝에 밀리 초가 기록됩니다. ``style`` 은 `%`, '{' 또는 '$' 중 하나입니다. 이 중 하나가 지정되지 않으면, '%' 가"
" 사용됩니다."

#: ../Doc/howto/logging.rst:548
msgid ""
"If the ``style`` is '%', the message format string uses ``%(<dictionary "
"key>)s`` styled string substitution; the possible keys are documented in "
":ref:`logrecord-attributes`. If the style is '{', the message format "
"string is assumed to be compatible with :meth:`str.format` (using keyword"
" arguments), while if the style is '$' then the message format string "
"should conform to what is expected by :meth:`string.Template.substitute`."
msgstr ""
"``style`` 이 '%' 이면, 메시지 포맷 문자열은 ``%(<dictionary key>)s`` 스타일의 문자열 치환을 사용합니다;"
" 가능한 키는 :ref:`logrecord-attributes` 에 문서로 만들어져 있습니다. style이 '{' 인 경우 메시지 포맷 "
"문자열은 :meth:`str.format`\\(키워드 인자 사용)과 호환되는 것으로 가정하고, 스타일이 '$' 이면 메시지 포맷 문자열은"
" :meth:`string.Template.substitute` 가 기대하는 것과 일치해야 합니다."

#: ../Doc/howto/logging.rst:555
msgid "Added the ``style`` parameter."
msgstr "``style`` 매개 변수를 추가했습니다."

#: ../Doc/howto/logging.rst:558
msgid ""
"The following message format string will log the time in a human-readable"
" format, the severity of the message, and the contents of the message, in"
" that order::"
msgstr "다음 메시지 포맷 문자열은 사람이 읽을 수 있는 형식의 시간, 메시지의 심각도 및 메시지의 내용을 순서대로 기록합니다::"

#: ../Doc/howto/logging.rst:564
msgid ""
"Formatters use a user-configurable function to convert the creation time "
"of a record to a tuple. By default, :func:`time.localtime` is used; to "
"change this for a particular formatter instance, set the ``converter`` "
"attribute of the instance to a function with the same signature as "
":func:`time.localtime` or :func:`time.gmtime`. To change it for all "
"formatters, for example if you want all logging times to be shown in GMT,"
" set the ``converter`` attribute in the Formatter class (to "
"``time.gmtime`` for GMT display)."
msgstr ""
"포매터는 사용자가 구성 할 수 있는 함수를 사용하여 레코드의 생성 시간을 튜플로 변환합니다. 기본적으로, "
":func:`time.localtime` 이 사용됩니다; 특정 포매터 인스턴스에 대해 이를 변경하려면, 인스턴스의 "
"``converter`` 어트리뷰트를 :func:`time.localtime` 또는 :func:`time.gmtime` 과 같은 서명을 "
"가진 함수로 설정하십시오. 모든 포매터를 변경하려면, 예를 들어 모든 로깅 시간을 GMT로 표시하려면, Formatter 클래스의 "
"``converter`` 어트리뷰트를 설정하십시오 (GMT 표시를 위해 ``time.gmtime`` 으로)."

#: ../Doc/howto/logging.rst:574
msgid "Configuring Logging"
msgstr "로깅 구성"

#: ../Doc/howto/logging.rst:578
msgid "Programmers can configure logging in three ways:"
msgstr "프로그래머는 세 가지 방법으로 로깅을 구성 할 수 있습니다:"

#: ../Doc/howto/logging.rst:580
msgid ""
"Creating loggers, handlers, and formatters explicitly using Python code "
"that calls the configuration methods listed above."
msgstr "위에 나열된 구성 메서드를 호출하는 파이썬 코드를 사용하여 로거, 처리기 및 포매터를 명시적으로 만듭니다."

#: ../Doc/howto/logging.rst:582
msgid ""
"Creating a logging config file and reading it using the "
":func:`fileConfig` function."
msgstr "로깅 구성 파일을 만들고, :func:`fileConfig` 함수를 사용하여 그것을 읽습니다."

#: ../Doc/howto/logging.rst:584
msgid ""
"Creating a dictionary of configuration information and passing it to the "
":func:`dictConfig` function."
msgstr "구성 정보의 딕셔너리를 만들고, :func:`dictConfig` 함수에 전달합니다."

#: ../Doc/howto/logging.rst:587
msgid ""
"For the reference documentation on the last two options, see :ref"
":`logging-config-api`.  The following example configures a very simple "
"logger, a console handler, and a simple formatter using Python code::"
msgstr ""
"마지막 두 옵션에 대한 참조 설명서는 :ref:`logging-config-api`\\를 참조하십시오. 다음 예제는 파이썬 코드를 "
"사용하여 매우 단순한 로거, 콘솔 처리기 및 간단한 포매터를 구성합니다::"

#: ../Doc/howto/logging.rst:617
msgid "Running this module from the command line produces the following output:"
msgstr "명령행에서 이 모듈을 실행하면 다음과 같이 출력됩니다:"

#: ../Doc/howto/logging.rst:628
msgid ""
"The following Python module creates a logger, handler, and formatter "
"nearly identical to those in the example listed above, with the only "
"difference being the names of the objects::"
msgstr "다음의 파이썬 모듈은 위에 열거된 예제와 거의 같고 객체의 이름 만 다른 로거, 처리기 및 포매터를 생성합니다::"

#: ../Doc/howto/logging.rst:647
msgid "Here is the logging.conf file:"
msgstr "logging.conf 파일은 이렇습니다:"

#: ../Doc/howto/logging.rst:680
msgid ""
"The output is nearly identical to that of the non-config-file-based "
"example:"
msgstr "출력은 구성 파일 기반이 아닌 예제와 거의 같습니다:"

#: ../Doc/howto/logging.rst:691
msgid ""
"You can see that the config file approach has a few advantages over the "
"Python code approach, mainly separation of configuration and code and the"
" ability of noncoders to easily modify the logging properties."
msgstr ""
"구성 파일 접근법이 파이썬 코드 접근법보다 몇 가지 장점이 있음을 알 수 있습니다. 주로 구성과 코드의 분리와 코더가 아니라도 로깅 "
"속성을 쉽게 수정할 수 있다는 것입니다."

#: ../Doc/howto/logging.rst:695
msgid ""
"The :func:`fileConfig` function takes a default parameter, "
"``disable_existing_loggers``, which defaults to ``True`` for reasons of "
"backward compatibility. This may or may not be what you want, since it "
"will cause any loggers existing before the :func:`fileConfig` call to be "
"disabled unless they (or an ancestor) are explicitly named in the "
"configuration.  Please refer to the reference documentation for more "
"information, and specify ``False`` for this parameter if you wish."
msgstr ""
":func:`fileConfig` 함수는 기본 매개 변수 ``disable_existing_loggers`` 를 취하는데, 하위 호환성을"
" 위해 기본값은 ``True`` 입니다. 이것들은 여러분이 원하는 것일 수도 있고 아닐 수도 있습니다. 왜냐하면 "
":func:`fileConfig` 호출 전에 존재하는 모든 로거들이, 구성에서 명시적으로 명명되지 않는 한, 비활성화되기 때문입니다. "
"자세한 내용은 참조 설명서를 참조하고, 원한다면 이 매개 변수에 ``False`` 를 지정하십시오."

#: ../Doc/howto/logging.rst:703
msgid ""
"The dictionary passed to :func:`dictConfig` can also specify a Boolean "
"value with key ``disable_existing_loggers``, which if not specified "
"explicitly in the dictionary also defaults to being interpreted as "
"``True``.  This leads to the logger-disabling behaviour described above, "
"which may not be what you want - in which case, provide the key "
"explicitly with a value of ``False``."
msgstr ""
":func:`dictConfig` 에 전달된 딕셔너리 또한 ``disable_existing_loggers`` 키로 논리값을 지정할 수 "
"있습니다. 딕셔너리에 명시적으로 지정되지 않으면 기본적으로 ``True`` 로 해석됩니다. 이것은 위에서 설명한 로거 비활성화 동작으로 "
"이어지는데, 여러분이 원하는 것이 아닐 수도 있습니다. 이 경우 키에 명시적으로 ``False`` 값을 제공하십시오."

#: ../Doc/howto/logging.rst:713
msgid ""
"Note that the class names referenced in config files need to be either "
"relative to the logging module, or absolute values which can be resolved "
"using normal import mechanisms. Thus, you could use either "
":class:`~logging.handlers.WatchedFileHandler` (relative to the logging "
"module) or ``mypackage.mymodule.MyHandler`` (for a class defined in "
"package ``mypackage`` and module ``mymodule``, where ``mypackage`` is "
"available on the Python import path)."
msgstr ""
"구성 파일에서 참조되는 클래스 이름은 logging 모듈에 상대적이거나, 일반적인 임포트 메커니즘을 사용하여 결정할 수 있는 절댓값이어야"
" 합니다. 따라서, :class:`~logging.handlers.WatchedFileHandler` (logging 모듈에 상대적) "
"또는 ``mypackage.mymodule.MyHandler`` (패키지 ``mypackage`` 와 모듈 ``mymodule`` 에 "
"정의된 클래스, 여기서 ``mypackage`` 는 파이썬 임포트 경로에서 사용 가능해야 합니다)."

#: ../Doc/howto/logging.rst:721
msgid ""
"In Python 3.2, a new means of configuring logging has been introduced, "
"using dictionaries to hold configuration information. This provides a "
"superset of the functionality of the config-file-based approach outlined "
"above, and is the recommended configuration method for new applications "
"and deployments. Because a Python dictionary is used to hold "
"configuration information, and since you can populate that dictionary "
"using different means, you have more options for configuration. For "
"example, you can use a configuration file in JSON format, or, if you have"
" access to YAML processing functionality, a file in YAML format, to "
"populate the configuration dictionary. Or, of course, you can construct "
"the dictionary in Python code, receive it in pickled form over a socket, "
"or use whatever approach makes sense for your application."
msgstr ""
"파이썬 3.2에서는 구성 정보를 보관하는 딕셔너리를 사용하여 로깅을 구성하는 새로운 방법이 도입되었습니다. 이는 위에 설명된 구성 파일 "
"기반 접근 방식의 기능을 제공하며, 새로운 응용 프로그램 및 배포에 권장되는 구성 방법입니다. 파이썬 딕셔너리가 구성 정보를 저장하는 데"
" 사용되고, 다른 방법을 사용하여 해당 딕셔너리를 채울 수 있으므로 더 많은 구성 옵션을 갖게 됩니다. 예를 들어, 구성 딕셔너리를 "
"채우는데 JSON 형식의 구성 파일이나, YAML 처리 기능에 액세스할 수 있는 경우, YAML 형식의 파일을 사용할 수 있습니다. "
"물론, 파이썬 코드로 딕셔너리를 만들거나, 소켓을 통해 피클 된 형태로 수신하거나, 그 밖의 응용 프로그램에 적합한 어떤 방식도 사용할 "
"수 있습니다."

#: ../Doc/howto/logging.rst:733
msgid ""
"Here's an example of the same configuration as above, in YAML format for "
"the new dictionary-based approach:"
msgstr "다음은 새로운 딕셔너리 기반 접근 방식으로 YAML 형식으로 위와 같이 구성한 예입니다:"

#: ../Doc/howto/logging.rst:757
msgid ""
"For more information about logging using a dictionary, see :ref:`logging-"
"config-api`."
msgstr "딕셔너리를 사용하여 로깅 하는 방법에 대한 자세한 내용은 :ref:`logging-config-api`\\를 참조하십시오."

#: ../Doc/howto/logging.rst:761
msgid "What happens if no configuration is provided"
msgstr "구성이 제공되지 않으면 어떻게 되는가"

#: ../Doc/howto/logging.rst:763
msgid ""
"If no logging configuration is provided, it is possible to have a "
"situation where a logging event needs to be output, but no handlers can "
"be found to output the event. The behaviour of the logging package in "
"these circumstances is dependent on the Python version."
msgstr ""
"로깅 구성이 제공되지 않으면, 로깅 이벤트를 출력해야 하지만 이벤트를 출력하는 처리기를 찾을 수 없는 상황이 발생할 수 있습니다. 이러한"
" 상황에서 logging 패키지의 동작은 파이썬 버전에 따라 다릅니다."

#: ../Doc/howto/logging.rst:768
msgid "For versions of Python prior to 3.2, the behaviour is as follows:"
msgstr "3.2 이전의 파이썬 버전의 경우 동작은 다음과 같습니다:"

#: ../Doc/howto/logging.rst:770
msgid ""
"If *logging.raiseExceptions* is ``False`` (production mode), the event is"
" silently dropped."
msgstr "*logging.raiseExceptions* 가 ``False`` (프로덕션 모드)이면, 이벤트가 조용히 무시됩니다."

#: ../Doc/howto/logging.rst:773
msgid ""
"If *logging.raiseExceptions* is ``True`` (development mode), a message "
"'No handlers could be found for logger X.Y.Z' is printed once."
msgstr ""
"*logging.raiseExceptions* 가 ``True`` (개발 모드) 이면, 'No handlers could be found"
" for logger X.Y.Z' 라는 메시지가 한 번 인쇄됩니다."

#: ../Doc/howto/logging.rst:776
msgid "In Python 3.2 and later, the behaviour is as follows:"
msgstr "파이썬 3.2 및 이후 버전에서는 다음과 같이 동작합니다:"

#: ../Doc/howto/logging.rst:778
msgid ""
"The event is output using a 'handler of last resort', stored in "
"``logging.lastResort``. This internal handler is not associated with any "
"logger, and acts like a :class:`~logging.StreamHandler` which writes the "
"event description message to the current value of ``sys.stderr`` "
"(therefore respecting any redirections which may be in effect). No "
"formatting is done on the message - just the bare event description "
"message is printed. The handler's level is set to ``WARNING``, so all "
"events at this and greater severities will be output."
msgstr ""
"이 이벤트는 ``logging.lastResort`` 에 저장된 '최후 수단 처리기'를 사용하여 출력됩니다. 이 내부 처리기는 어떤 "
"로거와도 연관되어 있지 않고, 이벤트 설명 메시지를 ``sys.stderr`` 의 현재 값으로 쓰는 (따라서 현재 효과를 발휘하고 있는 "
"모든 리디렉션을 존중합니다) :class:`~logging.StreamHandler` 처럼 동작합니다. 메시지에는 어떤 포매팅도 적용되지"
" 않습니다 - 이벤트 설명 메시지가 그대로 인쇄됩니다. 처리기의 수준은 ``WARNING`` 으로 설정되어 있으므로, 이보다 크거나 같은"
" 심각도의 모든 이벤트가 출력됩니다."

#: ../Doc/howto/logging.rst:787
msgid ""
"To obtain the pre-3.2 behaviour, ``logging.lastResort`` can be set to "
"``None``."
msgstr "3.2 이전의 동작을 얻으려면, ``logging.lastResort`` 를 ``None`` 으로 설정할 수 있습니다."

#: ../Doc/howto/logging.rst:792
msgid "Configuring Logging for a Library"
msgstr "라이브러리 로깅 구성"

#: ../Doc/howto/logging.rst:794
msgid ""
"When developing a library which uses logging, you should take care to "
"document how the library uses logging - for example, the names of loggers"
" used. Some consideration also needs to be given to its logging "
"configuration. If the using application does not use logging, and library"
" code makes logging calls, then (as described in the previous section) "
"events of severity ``WARNING`` and greater will be printed to "
"``sys.stderr``. This is regarded as the best default behaviour."
msgstr ""
"로깅을 사용하는 라이브러리를 개발할 때, 라이브러리에서 로깅을 사용하는 방법을 문서로 만들어야 합니다 - 예를 들어, 사용된 로거의 "
"이름. 또한, 로깅 구성에 대한 고려가 필요합니다. 사용하는 응용 프로그램이 로깅을 사용하지 않고 라이브러리 코드가 로깅을 호출하면, "
"(앞 절에서 설명했듯이) 심각도가 ``WARNING`` 이상인 이벤트는 ``sys.stderr`` 에 출력됩니다. 이것이 최상의 기본 "
"동작인 것으로 간주합니다."

#: ../Doc/howto/logging.rst:802
msgid ""
"If for some reason you *don't* want these messages printed in the absence"
" of any logging configuration, you can attach a do-nothing handler to the"
" top-level logger for your library. This avoids the message being "
"printed, since a handler will be always be found for the library's "
"events: it just doesn't produce any output. If the library user "
"configures logging for application use, presumably that configuration "
"will add some handlers, and if levels are suitably configured then "
"logging calls made in library code will send output to those handlers, as"
" normal."
msgstr ""
"어떤 이유로 로깅 구성이 없을 때 이 메시지가 인쇄되는 것을 원하지 *않는*\\다면, 라이브러리의 최상위 로거에 아무것도 하지 않는 "
"처리기를 연결할 수 있습니다. 이렇게 하면 메시지가 인쇄되는 것을 피할 수 있습니다. 라이브러리의 이벤트를 위한 처리기가 항상 존재하기 "
"때문입니다: 단지 아무런 출력도 만들지 않을 뿐입니다. 라이브러리 사용자가 응용 프로그램이 사용하기 위해 로깅을 구성하면, 아마도 그 "
"구성이 어떤 처리기를 추가할 것이고, 수준이 적절하게 구성된 경우 라이브러리에서 이루어진 로깅 호출은 그 처리기로 정상적으로 출력을 보낼"
" 것입니다."

#: ../Doc/howto/logging.rst:811
msgid ""
"A do-nothing handler is included in the logging package: "
":class:`~logging.NullHandler` (since Python 3.1). An instance of this "
"handler could be added to the top-level logger of the logging namespace "
"used by the library (*if* you want to prevent your library's logged "
"events being output to ``sys.stderr`` in the absence of logging "
"configuration). If all logging by a library *foo* is done using loggers "
"with names matching 'foo.x', 'foo.x.y', etc. then the code::"
msgstr ""
"아무것도 하지 않는 처리기가 logging 패키지에 포함되어 있습니다: :class:`~logging.NullHandler` (파이썬 "
"3.1부터). 이 처리기의 인스턴스는 라이브러리가 사용하는 로깅 이름 공간의 최상위 로거에 추가될 수 있습니다 (*만약* 로깅 구성이 "
"없는 경우 라이브러리가 로깅한 이벤트가 ``sys.stderr`` 에 출력되는 것을 막으려면). 라이브러리 *foo* 에 의한 모든 "
"로깅이 'foo.x', 'foo.x.y' 등과 일치하는 이름을 가진 로거들만 사용한다면, 다음과 같은 코드가::"

#: ../Doc/howto/logging.rst:822
msgid ""
"should have the desired effect. If an organisation produces a number of "
"libraries, then the logger name specified can be 'orgname.foo' rather "
"than just 'foo'."
msgstr ""
"원하는 효과를 주어야 합니다. 만약 조직이 여러 라이브러리를 만든다면, 지정된 로거 이름으로 단순한 'foo' 대신에 "
"'orgname.foo'를 사용할 수 있습니다."

#: ../Doc/howto/logging.rst:826
msgid ""
"It is strongly advised that you *do not add any handlers other than* "
":class:`~logging.NullHandler` *to your library's loggers*. This is "
"because the configuration of handlers is the prerogative of the "
"application developer who uses your library. The application developer "
"knows their target audience and what handlers are most appropriate for "
"their application: if you add handlers 'under the hood', you might well "
"interfere with their ability to carry out unit tests and deliver logs "
"which suit their requirements."
msgstr ""
":class:`~logging.NullHandler` *이외의 처리기를 라이브러리의 로거에 추가하지 않는 것이* 좋습니다. 이것은 처리기"
" 구성이 라이브러리를 사용하는 응용 프로그램 개발자의 특권이기 때문입니다. 응용 프로그램 개발자는 사용자와 응용 프로그램에 가장 적합한 "
"처리기가 무엇인지 알고 있습니다. 여러분이 처리기를 '이면에서' 추가하면, 단위 테스트를 수행하고 그들의 요구사항에 맞는 로그를 전달하는"
" 작업을 방해할 수 있습니다."

#: ../Doc/howto/logging.rst:837
msgid "Logging Levels"
msgstr "로깅 수준"

#: ../Doc/howto/logging.rst:839
msgid ""
"The numeric values of logging levels are given in the following table. "
"These are primarily of interest if you want to define your own levels, "
"and need them to have specific values relative to the predefined levels. "
"If you define a level with the same numeric value, it overwrites the "
"predefined value; the predefined name is lost."
msgstr ""
"로깅 수준의 숫자 값은 다음 표에 나와 있습니다. 이것은 주로 여러분 자신의 수준을 정의하고 사전 정의된 수준에 상대적인 특정 값을 "
"갖도록 하려는 경우 관심의 대상입니다. 같은 숫자 값을 가진 수준을 정의하면 미리 정의된 값을 덮어씁니다; 사전 정의된 이름이 "
"유실됩니다."

#: ../Doc/howto/logging.rst:846
msgid "Numeric value"
msgstr "숫자 값"

#: ../Doc/howto/logging.rst:848
msgid "50"
msgstr "50"

#: ../Doc/howto/logging.rst:850
msgid "40"
msgstr "40"

#: ../Doc/howto/logging.rst:852
msgid "30"
msgstr "30"

#: ../Doc/howto/logging.rst:854
msgid "20"
msgstr "20"

#: ../Doc/howto/logging.rst:856
msgid "10"
msgstr "10"

#: ../Doc/howto/logging.rst:858
msgid "``NOTSET``"
msgstr "``NOTSET``"

#: ../Doc/howto/logging.rst:858
msgid "0"
msgstr "0"

#: ../Doc/howto/logging.rst:861
msgid ""
"Levels can also be associated with loggers, being set either by the "
"developer or through loading a saved logging configuration. When a "
"logging method is called on a logger, the logger compares its own level "
"with the level associated with the method call. If the logger's level is "
"higher than the method call's, no logging message is actually generated. "
"This is the basic mechanism controlling the verbosity of logging output."
msgstr ""
"또한, 수준은 개발자가 설정하거나 저장된 로깅 구성을 로드하여 로거와 연관될 수 있습니다. 로깅 메서드가 로거에 호출되면, 로거는 자체 "
"​​수준을 메서드 호출과 연관된 수준과 비교합니다. 로거 수준이 메서드 호출보다 높으면 실제로 로깅 메시지가 생성되지 않습니다. 이것은 "
"로그 출력의 상세도를 제어하는 ​​기본 메커니즘입니다."

#: ../Doc/howto/logging.rst:868
msgid ""
"Logging messages are encoded as instances of the "
":class:`~logging.LogRecord` class. When a logger decides to actually log "
"an event, a :class:`~logging.LogRecord` instance is created from the "
"logging message."
msgstr ""
"로깅 메시지는 :class:`~logging.LogRecord` 클래스의 인스턴스로 인코딩됩니다. 로거가 실제로 이벤트를 로그 하기로 "
"하면, :class:`~logging.LogRecord` 인스턴스가 로깅 메시지로부터 만들어집니다."

#: ../Doc/howto/logging.rst:872
msgid ""
"Logging messages are subjected to a dispatch mechanism through the use of"
" :dfn:`handlers`, which are instances of subclasses of the "
":class:`Handler` class. Handlers are responsible for ensuring that a "
"logged message (in the form of a :class:`LogRecord`) ends up in a "
"particular location (or set of locations) which is useful for the target "
"audience for that message (such as end users, support desk staff, system "
"administrators, developers). Handlers are passed :class:`LogRecord` "
"instances intended for particular destinations. Each logger can have "
"zero, one or more handlers associated with it (via the "
":meth:`~Logger.addHandler` method of :class:`Logger`). In addition to any"
" handlers directly associated with a logger, *all handlers associated "
"with all ancestors of the logger* are called to dispatch the message "
"(unless the *propagate* flag for a logger is set to a false value, at "
"which point the passing to ancestor handlers stops)."
msgstr ""
"로깅 메시지는 :class:`Handler` 클래스의 서브 클래스의 인스턴스인 :dfn:`처리기 (handlers)` 를 통한 전달 "
"메커니즘을 적용받게 됩니다. 처리기는 로그된 메시지(:class:`LogRecord` 형식)가 대상 독자(가령 최종 사용자, 지원 데스크"
" 직원, 시스템 관리자, 개발자)에게 유용한 특정 위치(또는 위치 집합)에 도달하도록 할 책임이 있습니다. 처리기로는 특정 목적지를 위한"
" :class:`LogRecord` 인스턴스가 전달됩니다. 각 로거에는 0개 이상의 처리기가 연관될 수 있습니다 "
"(:class:`Logger` 의 :meth:`~Logger.addHandler` 메서드를 통해). 로거에 직접 연관된 모든 처리기뿐만 "
"아니라, (로거의 *propagate* 플래그가 거짓 값으로 설정되어 있지 않은 한, 그 지점에서 부모 처리기로의 전달이 멈춥니다) "
"*로거의 모든 조상과 연관된 모든 처리기*\\가 메시지를 전달하도록 호출됩니다."

#: ../Doc/howto/logging.rst:886
msgid ""
"Just as for loggers, handlers can have levels associated with them. A "
"handler's level acts as a filter in the same way as a logger's level "
"does. If a handler decides to actually dispatch an event, the "
":meth:`~Handler.emit` method is used to send the message to its "
"destination. Most user-defined subclasses of :class:`Handler` will need "
"to override this :meth:`~Handler.emit`."
msgstr ""
"로거와 마찬가지로, 처리기도 연관된 수준을 가질 수 있습니다. 처리기의 수준은 로거의 수준과 같은 방식으로 필터의 역할을 합니다. "
"처리기가 실제로 이벤트를 전달하기로 하면, :meth:`~Handler.emit` 메서드가 목적지로 메시지를 보내기 위해 사용됩니다. "
":class:`Handler` 의 대부분의 사용자 정의 서브 클래스는 이 :meth:`~Handler.emit` 를 재정의해야 합니다."

#: ../Doc/howto/logging.rst:895
msgid "Custom Levels"
msgstr "사용자 정의 수준"

#: ../Doc/howto/logging.rst:897
msgid ""
"Defining your own levels is possible, but should not be necessary, as the"
" existing levels have been chosen on the basis of practical experience. "
"However, if you are convinced that you need custom levels, great care "
"should be exercised when doing this, and it is possibly *a very bad idea "
"to define custom levels if you are developing a library*. That's because "
"if multiple library authors all define their own custom levels, there is "
"a chance that the logging output from such multiple libraries used "
"together will be difficult for the using developer to control and/or "
"interpret, because a given numeric value might mean different things for "
"different libraries."
msgstr ""
"여러분 자신의 수준을 정의하는 것이 가능하지만 필요하지는 않은데, 현재의 수준이 실무 경험에 근거하여 선택되었기 때문입니다. 하지만, "
"사용자 정의 수준이 필요하다고 확신하는 경우, 이를 수행할 때 많은 주의를 기울여야 합니다. *라이브러리를 개발하고 있다면 사용자 지정 "
"수준을 정의하는 것은 매우 나쁜 생각*\\일 수 있습니다. 왜냐하면, 여러 라이브러리 작성자가 모두 자신의 사용자 정의 수준을 정의하면,"
" 주어진 숫자 값이 라이브러리마다 각기 다른 것을 의미 할 수 있으므로, 사용 중인 개발자가 함께 사용하는 여러 라이브러리의 로깅 결과를"
" 제어하거나 해석하는 것이 어려울 수 있기 때문입니다."

#: ../Doc/howto/logging.rst:910
msgid "Useful Handlers"
msgstr "유용한 처리기"

#: ../Doc/howto/logging.rst:912
msgid ""
"In addition to the base :class:`Handler` class, many useful subclasses "
"are provided:"
msgstr "베이스 :class:`Handler` 클래스 외에도 많은 유용한 서브 클래스가 제공됩니다:"

#: ../Doc/howto/logging.rst:915
msgid ""
":class:`StreamHandler` instances send messages to streams (file-like "
"objects)."
msgstr ":class:`StreamHandler` 인스턴스는 스트림(파일류 객체)에 메시지를 보냅니다."

#: ../Doc/howto/logging.rst:918
msgid ":class:`FileHandler` instances send messages to disk files."
msgstr ":class:`FileHandler` 인스턴스는 디스크 파일에 메시지를 보냅니다."

#: ../Doc/howto/logging.rst:920
msgid ""
":class:`~handlers.BaseRotatingHandler` is the base class for handlers "
"that rotate log files at a certain point. It is not meant to be  "
"instantiated directly. Instead, use "
":class:`~handlers.RotatingFileHandler` or "
":class:`~handlers.TimedRotatingFileHandler`."
msgstr ""
":class:`~handlers.BaseRotatingHandler` 는 특정 지점에서 로그 파일을 회전시키는 처리기의 베이스 "
"클래스입니다. 직접 인스턴스화하는 것은 아닙니다. 대신 :class:`~handlers.RotatingFileHandler` 또는 "
":class:`~handlers.TimedRotatingFileHandler` 를 사용하십시오."

#: ../Doc/howto/logging.rst:925
msgid ""
":class:`~handlers.RotatingFileHandler` instances send messages to disk "
"files, with support for maximum log file sizes and log file rotation."
msgstr ""
":class:`~handlers.RotatingFileHandler` 인스턴스는 디스크 파일에 메시지를 보내는데, 최대 로그 파일 크기와"
" 로그 파일 회전을 지원합니다."

#: ../Doc/howto/logging.rst:928
msgid ""
":class:`~handlers.TimedRotatingFileHandler` instances send messages to "
"disk files, rotating the log file at certain timed intervals."
msgstr ""
":class:`~handlers.TimedRotatingFileHandler` 인스턴스는 디스크 파일에 메시지를 보내는데, 일정한 시간 "
"간격으로 로그 파일을 회전시킵니다."

#: ../Doc/howto/logging.rst:931
msgid ""
":class:`~handlers.SocketHandler` instances send messages to TCP/IP "
"sockets. Since 3.4, Unix domain sockets are also supported."
msgstr ""
":class:`~handlers.SocketHandler` 인스턴스는 TCP/IP 소켓에 메시지를 보냅니다. 3.4부터, 유닉스 도메인 "
"소켓도 지원됩니다."

#: ../Doc/howto/logging.rst:934
msgid ""
":class:`~handlers.DatagramHandler` instances send messages to UDP "
"sockets. Since 3.4, Unix domain sockets are also supported."
msgstr ""
":class:`~handlers.DatagramHandler` 인스턴스는 UDP 소켓에 메시지를 보냅니다. 3.4부터, 유닉스 도메인 "
"소켓도 지원됩니다."

#: ../Doc/howto/logging.rst:937
msgid ""
":class:`~handlers.SMTPHandler` instances send messages to a designated "
"email address."
msgstr ":class:`~handlers.SMTPHandler` 인스턴스는 지정된 전자 우편 주소로 메시지를 보냅니다."

#: ../Doc/howto/logging.rst:940
msgid ""
":class:`~handlers.SysLogHandler` instances send messages to a Unix syslog"
" daemon, possibly on a remote machine."
msgstr ""
":class:`~handlers.SysLogHandler` 인스턴스는 유닉스 syslog 데몬(원격 기계에 있는 것도 가능합니다)에 "
"메시지를 보냅니다."

#: ../Doc/howto/logging.rst:943
msgid ""
":class:`~handlers.NTEventLogHandler` instances send messages to a Windows"
" NT/2000/XP event log."
msgstr ""
":class:`~handlers.NTEventLogHandler` 인스턴스는 윈도우 NT/2000/XP 이벤트 로그에 메시지를 보냅니다."

#: ../Doc/howto/logging.rst:946
msgid ""
":class:`~handlers.MemoryHandler` instances send messages to a buffer in "
"memory, which is flushed whenever specific criteria are met."
msgstr ""
":class:`~handlers.MemoryHandler` 인스턴스는 메모리에 있는 버퍼에 메시지를 보내는데, 특정 기준이 만족 될 "
"때마다 플러시 됩니다."

#: ../Doc/howto/logging.rst:949
msgid ""
":class:`~handlers.HTTPHandler` instances send messages to an HTTP server "
"using either ``GET`` or ``POST`` semantics."
msgstr ""
":class:`~handlers.HTTPHandler` 인스턴스는 ``GET`` 또는 ``POST`` 을 사용해서 HTTP 서버에 "
"메시지를 보냅니다."

#: ../Doc/howto/logging.rst:952
msgid ""
":class:`~handlers.WatchedFileHandler` instances watch the file they are "
"logging to. If the file changes, it is closed and reopened using the file"
" name. This handler is only useful on Unix-like systems; Windows does not"
" support the underlying mechanism used."
msgstr ""
":class:`~handlers.WatchedFileHandler` 인스턴스는 그들이 로깅하고 있는 파일을 감시합니다. 파일이 변경되면 "
"닫히고 파일 이름을 사용하여 다시 열립니다. 이 처리기는 유닉스 계열 시스템에서만 유용합니다; 윈도우는 사용된 하부 메커니즘을 지원하지 "
"않습니다."

#: ../Doc/howto/logging.rst:957
msgid ""
":class:`~handlers.QueueHandler` instances send messages to a queue, such "
"as those implemented in the :mod:`queue` or :mod:`multiprocessing` "
"modules."
msgstr ""
":class:`~handlers.QueueHandler` 인스턴스는 :mod:`queue` 또는 :mod:`multiprocessing`"
" 모듈에 구현된 것과 같은 큐로 메시지를 보냅니다."

#: ../Doc/howto/logging.rst:960
msgid ""
":class:`NullHandler` instances do nothing with error messages. They are "
"used by library developers who want to use logging, but want to avoid the"
" 'No handlers could be found for logger XXX' message which can be "
"displayed if the library user has not configured logging. See :ref"
":`library-config` for more information."
msgstr ""
":class:`NullHandler` 인스턴스는 에러 메시지로 아무것도 하지 않습니다. 라이브러리 개발자가 로깅을 사용하지만, 라이브러리"
" 사용자가 로깅을 구성하지 않으면 표시될 수 있는 'No handlers could be found for logger XXX' 라는 "
"메시지를 피하려고 할 때 사용합니다. 자세한 정보는 :ref:`library-config` 를 보십시오."

#: ../Doc/howto/logging.rst:966
msgid "The :class:`NullHandler` class."
msgstr ":class:`NullHandler` 클래스."

#: ../Doc/howto/logging.rst:969
msgid "The :class:`~handlers.QueueHandler` class."
msgstr ":class:`~handlers.QueueHandler` 클래스."

#: ../Doc/howto/logging.rst:972
msgid ""
"The :class:`NullHandler`, :class:`StreamHandler` and :class:`FileHandler`"
" classes are defined in the core logging package. The other handlers are "
"defined in a sub- module, :mod:`logging.handlers`. (There is also another"
" sub-module, :mod:`logging.config`, for configuration functionality.)"
msgstr ""
":class:`NullHandler`, :class:`StreamHandler` 와 :class:`FileHandler` 클래스는 코어 "
"logging 패키지에 정의되어 있습니다. 다른 처리기는 하위 모듈인 :mod:`logging.handlers` 에 정의되어 있습니다. "
"(구성 기능을 위한, 또 다른 하위 모듈 :mod:`logging.config` 도 있습니다.)"

#: ../Doc/howto/logging.rst:977
#, python-format
msgid ""
"Logged messages are formatted for presentation through instances of the "
":class:`Formatter` class. They are initialized with a format string "
"suitable for use with the % operator and a dictionary."
msgstr ""
"로그된 메시지는 :class:`Formatter` 클래스의 인스턴스를 통해 표시를 위해 포맷됩니다. % 연산자와 딕셔너리와 함께 "
"사용하기에 적합한 포맷 문자열로 초기화됩니다."

#: ../Doc/howto/logging.rst:981
msgid ""
"For formatting multiple messages in a batch, instances of "
":class:`~handlers.BufferingFormatter` can be used. In addition to the "
"format string (which is applied to each message in the batch), there is "
"provision for header and trailer format strings."
msgstr ""
"일괄 처리로 여러 개의 메시지를 포맷하려면, :class:`~handlers.BufferingFormatter` 의 인스턴스를 사용할 수"
" 있습니다. 포맷 문자열(일괄 처리 때 각 메시지에 적용됩니다)에 더해, 헤더와 트레일러 포맷 문자열에 대한 고려가 있습니다."

#: ../Doc/howto/logging.rst:986
msgid ""
"When filtering based on logger level and/or handler level is not enough, "
"instances of :class:`Filter` can be added to both :class:`Logger` and "
":class:`Handler` instances (through their :meth:`~Handler.addFilter` "
"method). Before deciding to process a message further, both loggers and "
"handlers consult all their filters for permission. If any filter returns "
"a false value, the message is not processed further."
msgstr ""
"로거 수준과 처리기 수준을 기반으로 필터링하는 것만으로는 충분하지 않은 경우, :class:`Logger` 및 "
":class:`Handler` 인스턴스에 (:meth:`~Handler.addFilter` 메서드를 통해) :class:`Filter` "
"인스턴스를 추가 할 수 있습니다. 메시지를 더 처리하기로 하기 전에, 로거와 처리기는 모든 필터에 허락을 요청합니다. 한 필터라도 거짓 "
"값을 반환하면 메시지는 더 처리되지 않습니다."

#: ../Doc/howto/logging.rst:993
msgid ""
"The basic :class:`Filter` functionality allows filtering by specific "
"logger name. If this feature is used, messages sent to the named logger "
"and its children are allowed through the filter, and all others dropped."
msgstr ""
"기본적인 :class:`Filter` 기능은 특정 로거 이름으로 필터링하는 것을 지원합니다. 이 기능을 사용하면, 명명된 로거와 그 "
"자식으로 보낸 메시지는 필터를 통과하도록 허용되고, 다른 모든 메시지는 삭제됩니다."

#: ../Doc/howto/logging.rst:1001
msgid "Exceptions raised during logging"
msgstr "로깅 중에 발생하는 예외"

#: ../Doc/howto/logging.rst:1003
msgid ""
"The logging package is designed to swallow exceptions which occur while "
"logging in production. This is so that errors which occur while handling "
"logging events - such as logging misconfiguration, network or other "
"similar errors - do not cause the application using logging to terminate "
"prematurely."
msgstr ""
"logging 패키지는 프로덕션에서 로깅 하는 동안 발생하는 예외를 삼키도록 설계되었습니다. 이는 로깅 이벤트를 처리하는 동안 발생하는 "
"에러(가령 잘못된 로깅 구성, 네트워크 또는 기타 유사한 에러)가 로깅을 사용하는 응용 프로그램을 조기에 종료시키지 않도록 하기 위한 "
"것입니다."

#: ../Doc/howto/logging.rst:1008
msgid ""
":class:`SystemExit` and :class:`KeyboardInterrupt` exceptions are never "
"swallowed. Other exceptions which occur during the :meth:`~Handler.emit` "
"method of a :class:`Handler` subclass are passed to its "
":meth:`~Handler.handleError` method."
msgstr ""
":class:`SystemExit` 과 :class:`KeyboardInterrupt` 예외는 절대 삼켜지지 않습니다. "
":class:`Handler` 서브 클래스의 :meth:`~Handler.emit` 메서드가 실행되는 동안 발생하는 다른 예외는 "
":meth:`~Handler.handleError` 메서드에 전달됩니다."

#: ../Doc/howto/logging.rst:1013
msgid ""
"The default implementation of :meth:`~Handler.handleError` in "
":class:`Handler` checks to see if a module-level variable, "
":data:`raiseExceptions`, is set. If set, a traceback is printed to "
":data:`sys.stderr`. If not set, the exception is swallowed."
msgstr ""
":class:`Handler` 에 있는 :meth:`~Handler.handleError` 의 기본 구현은 모듈 수준 변수 "
":data:`raiseExceptions` 가 설정되어 있는지를 검사합니다. 설정되어있으면, 트레이스백이 "
":data:`sys.stderr` 에 인쇄됩니다. 설정되지 않았으면 예외를 삼킵니다."

#: ../Doc/howto/logging.rst:1018
msgid ""
"The default value of :data:`raiseExceptions` is ``True``. This is because"
" during development, you typically want to be notified of any exceptions "
"that occur. It's advised that you set :data:`raiseExceptions` to "
"``False`` for production usage."
msgstr ""
":data:`raiseExceptions` 의 기본값은 ``True`` 입니다. 개발 중에는, 보통 발생하는 예외에 대한 알림을 받기를 "
"원하기 때문입니다. 프로덕션 용도로는 :data:`raiseExceptions` 를 ``False`` 로 설정하는 것이 좋습니다."

#: ../Doc/howto/logging.rst:1028
msgid "Using arbitrary objects as messages"
msgstr "임의의 객체를 메시지로 사용하기"

#: ../Doc/howto/logging.rst:1030
msgid ""
"In the preceding sections and examples, it has been assumed that the "
"message passed when logging the event is a string. However, this is not "
"the only possibility. You can pass an arbitrary object as a message, and "
"its :meth:`~object.__str__` method will be called when the logging system"
" needs to convert it to a string representation. In fact, if you want to,"
" you can avoid computing a string representation altogether - for "
"example, the :class:`~handlers.SocketHandler` emits an event by pickling "
"it and sending it over the wire."
msgstr ""
"앞의 절과 예제에서 이벤트를 로깅할 때 전달되는 메시지는 문자열이라고 가정했습니다. 그러나 이것만 가능한 것은 아닙니다. 임의의 객체를 "
"메시지로 전달할 수 있으며, 로깅 시스템이 이를 문자열 표현으로 변환해야 할 때 :meth:`~object.__str__` 메서드가 "
"호출됩니다. 사실, 원한다면, 문자열 표현을 계산하는 것을 완전히 피할 수 있습니다 - 예를 들어, "
":class:`~handlers.SocketHandler` 는 이벤트를 피클링해서 와이어를 통해 전송하는 방식으로 이벤트를 보냅니다."

#: ../Doc/howto/logging.rst:1041
msgid "Optimization"
msgstr "최적화"

#: ../Doc/howto/logging.rst:1043
msgid ""
"Formatting of message arguments is deferred until it cannot be avoided. "
"However, computing the arguments passed to the logging method can also be"
" expensive, and you may want to avoid doing it if the logger will just "
"throw away your event. To decide what to do, you can call the "
":meth:`~Logger.isEnabledFor` method which takes a level argument and "
"returns true if the event would be created by the Logger for that level "
"of call. You can write code like this::"
msgstr ""
"메시지 인자의 포매팅은 피할 수 없을 때까지 연기됩니다. 하지만, 로깅 메서드에 전달된 인자를 계산하는 것 또한 비용이 많이들 수 있고,"
" 로거가 이벤트를 버리는 경우에는 수행하지 않고 싶을 수 있습니다. 꼭 해야 할 것을 결정하기 위해서, level 인자를 취하고 해당 "
"수준의 호출이 로거에 의해 이벤트가 생성되면 참을 반환하는 :meth:`~Logger.isEnabledFor` 메서드를 호출 할 수 "
"있습니다. 다음과 같은 코드를 작성할 수 있습니다::"

#: ../Doc/howto/logging.rst:1055
msgid ""
"so that if the logger's threshold is set above ``DEBUG``, the calls to "
":func:`expensive_func1` and :func:`expensive_func2` are never made."
msgstr ""
"그러면, 로거의 수준이 ``DEBUG`` 보다 높게 설정된 경우, :func:`expensive_func1` 과 "
":func:`expensive_func2` 호출은 절대 일어나지 않습니다."

#: ../Doc/howto/logging.rst:1058
msgid ""
"In some cases, :meth:`~Logger.isEnabledFor` can itself be more expensive "
"than you'd like (e.g. for deeply nested loggers where an explicit level "
"is only set high up in the logger hierarchy). In such cases (or if you "
"want to avoid calling a method in tight loops), you can cache the result "
"of a call to :meth:`~Logger.isEnabledFor` in a local or instance "
"variable, and use that instead of calling the method each time. Such a "
"cached value would only need to be recomputed when the logging "
"configuration changes dynamically while the application is running (which"
" is not all that common)."
msgstr ""
"때에 따라, :meth:`~Logger.isEnabledFor` 자체가 원하는 것보다 더 비쌀 수 있습니다 (예를 들어, 명시적 수준이 "
"로거 계층의 상단에서만 설정된 깊이 중첩된 로거의 경우). 그러한 경우 (또는 꽉 짜인 루프 내에서 메서드를 호출하지 않으려는 경우) "
"지역이나 인스턴스 변수에 :meth:`~Logger.isEnabledFor` 의 호출 결과를 캐시하고, 매번 메서드를 호출하는 대신 그 "
"값을 사용할 수 있습니다. 이러한 캐시 된 값은 응용 프로그램이 실행되는 동안 로깅 구성이 동적으로 변경될 때(그리 흔한 경우는 "
"아닙니다)만 재계산될 필요가 있습니다."

#: ../Doc/howto/logging.rst:1067
msgid ""
"There are other optimizations which can be made for specific applications"
" which need more precise control over what logging information is "
"collected. Here's a list of things you can do to avoid processing during "
"logging which you don't need:"
msgstr ""
"로깅 정보를 수집하는 방법을 보다 정밀하게 제어해야 하는 특정 응용 프로그램에 대해 수행할 수 있는 다른 최적화가 있습니다. 다음은 "
"필요하지 않은 로깅 처리를 피하고자 수행할 수 있는 작업 목록입니다:"

#: ../Doc/howto/logging.rst:1073
msgid "What you don't want to collect"
msgstr "수집하고 싶지 않은 것"

#: ../Doc/howto/logging.rst:1073
msgid "How to avoid collecting it"
msgstr "수집하는 것을 피하는 방법"

#: ../Doc/howto/logging.rst:1075
msgid "Information about where calls were made from."
msgstr "호출이 이루어진 위치에 관한 정보."

#: ../Doc/howto/logging.rst:1075
msgid ""
"Set ``logging._srcfile`` to ``None``. This avoids calling "
":func:`sys._getframe`, which may help to speed up your code in "
"environments like PyPy (which can't speed up code that uses "
":func:`sys._getframe`), if and when PyPy supports Python 3.x."
msgstr ""
"``logging._srcfile`` 을 ``None`` 으로 설정하십시오. 이렇게 하면 :func:`sys._getframe` 호출을 "
"피할 수 있는데, PyPy 가 파이썬 3.x를 지원할 때, PyPy(:func:`sys._getframe` 를 사용하는 코드의 속도를 "
"높일 수 없습니다)와 같은 환경에서 코드 속도를 높이는 데 도움이 됩니다."

#: ../Doc/howto/logging.rst:1083
msgid "Threading information."
msgstr "스레딩 정보."

#: ../Doc/howto/logging.rst:1083
msgid "Set ``logging.logThreads`` to ``0``."
msgstr "``logging.logThreads`` 를 ``0`` 으로 설정하십시오."

#: ../Doc/howto/logging.rst:1085
msgid "Process information."
msgstr "프로세스 정보."

#: ../Doc/howto/logging.rst:1085
msgid "Set ``logging.logProcesses`` to ``0``."
msgstr "``logging.logProcesses`` 를 ``0`` 으로 설정하십시오."

#: ../Doc/howto/logging.rst:1088
msgid ""
"Also note that the core logging module only includes the basic handlers. "
"If you don't import :mod:`logging.handlers` and :mod:`logging.config`, "
"they won't take up any memory."
msgstr ""
"또한, 코어 logging 모듈에는 기본 처리기만 포함됩니다. :mod:`logging.handlers` 와 "
":mod:`logging.config` 를 임포트 하지 않으면 메모리를 차지하지 않습니다."

#: ../Doc/howto/logging.rst:1095
msgid "Module :mod:`logging`"
msgstr "모듈 :mod:`logging`"

#: ../Doc/howto/logging.rst:1095
msgid "API reference for the logging module."
msgstr "logging 모듈에 대한 API 참조"

#: ../Doc/howto/logging.rst:1098
msgid "Module :mod:`logging.config`"
msgstr "모듈 :mod:`logging.config`"

#: ../Doc/howto/logging.rst:1098
msgid "Configuration API for the logging module."
msgstr "logging 모듈용 구성 API."

#: ../Doc/howto/logging.rst:1101
msgid "Module :mod:`logging.handlers`"
msgstr "모듈 :mod:`logging.handlers`"

#: ../Doc/howto/logging.rst:1101
msgid "Useful handlers included with the logging module."
msgstr "logging 모듈에 포함된 유용한 처리기."

#: ../Doc/howto/logging.rst:1103
msgid ":ref:`A logging cookbook <logging-cookbook>`"
msgstr ":ref:`로깅 요리책 <logging-cookbook>`"
