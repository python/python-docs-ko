# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: 2018-09-28 22:00+0900\n"
"Last-Translator: SeomGi, Han <iandmyhand@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "함수형 프로그래밍 HOWTO"

#: ../Doc/howto/functional.rst
msgid "Author"
msgstr "저자"

#: ../Doc/howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr "A. M. Kuchling"

#: ../Doc/howto/functional.rst
msgid "Release"
msgstr "버전"

#: ../Doc/howto/functional.rst:6
msgid "0.32"
msgstr "0.32"

#: ../Doc/howto/functional.rst:8
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to "
"the concepts of functional programming, we'll look at language features "
"such as :term:`iterator`\\s and :term:`generator`\\s and relevant library"
" modules such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"이 문서에서는, 함수형 방식으로 프로그램을 구현하는데 적합한 파이썬의 특성에 대해 알아볼 것입니다. 함수형 프로그래밍의 개념을 "
"소개한 뒤에, :term:`이터레이터 <iterator>` , :term:`제너레이터 <generator>` 와 같은 언어의 특성과"
" :mod:`itertools` , :mod:`functools` 와 같은 관련 라이브러리 모듈을 살펴볼 것입니다."

#: ../Doc/howto/functional.rst:16
msgid "Introduction"
msgstr "소개"

#: ../Doc/howto/functional.rst:18
msgid ""
"This section explains the basic concept of functional programming; if "
"you're just interested in learning about Python language features, skip "
"to the next section on :ref:`functional-howto-iterators`."
msgstr ""
"이 절에서는 함수형 프로그래밍의 기본적인 개념을 설명합니다; 만약 단순히 파이썬의 언어적 특성에 관해서만 관심이 있으시다면, "
":ref:`functional-howto-iterators` 절로 건너뛰세요."

#: ../Doc/howto/functional.rst:22
msgid ""
"Programming languages support decomposing problems in several different "
"ways:"
msgstr "프로그래밍 언어들은 다음과 같이 각각 다른 방식으로 문제를 더 작은 부분으로 분할하는 방법을 지원합니다:"

#: ../Doc/howto/functional.rst:24
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input."
"  C, Pascal, and even Unix shells are procedural languages."
msgstr ""
"대부분의 프로그래밍 언어들은 **절차적** 입니다: 프로그램은 컴퓨터에 프로그램의 입력을 어떻게 할지 알려주는 명령 목록입니다. "
"C, 파스칼, 유닉스 셸과 같은 것들은 절차적 언어입니다."

#: ../Doc/howto/functional.rst:28
msgid ""
"In **declarative** languages, you write a specification that describes "
"the problem to be solved, and the language implementation figures out how"
" to perform the computation efficiently.  SQL is the declarative language"
" you're most likely to be familiar with; a SQL query describes the data "
"set you want to retrieve, and the SQL engine decides whether to scan "
"tables or use indexes, which subclauses should be performed first, etc."
msgstr ""
"**선언적** 언어에서는 해결해야 할 문제를 설명하는 명세서를 작성하고, 언어 구현은 계산을 효과적으로 수행하는 방법을 파악합니다."
" SQL은 가장 친숙한 선언적 언어입니다; SQL 질의는 검색하고 싶은 데이터 세트를 설명하고, SQL 엔진은 테이블을 스캔하거나 "
"인덱스를 사용할 것인지, 어떤 하위 구문을 먼저 수행해야 하는지 등을 결정합니다."

#: ../Doc/howto/functional.rst:35
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this "
"internal state in some way. Smalltalk and Java are object-oriented "
"languages.  C++ and Python are languages that support object-oriented "
"programming, but don't force the use of object-oriented features."
msgstr ""
"**객체지향** 프로그램은 객체들의 컬렉션을 다룹니다. 객체는 내부적인 상태를 갖고 있으며 이 내부적인 상태를 어떤 방식으로 "
"가져오거나 수정하는 메서드를 제공합니다. 스몰토크와 자바는 객체지향 언어입니다. C++ 와 파이썬은 객체지향 프로그래밍을 지원하는 "
"언어이지만, 객체 지향적인 특성들을 사용하도록 강제하지는 않습니다."

#: ../Doc/howto/functional.rst:41
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have "
"any internal state that affects the output produced for a given input.  "
"Well-known functional languages include the ML family (Standard ML, "
"OCaml, and other variants) and Haskell."
msgstr ""
"**함수형** 프로그래밍은 함수들의 세트로 문제를 분해합니다. 이상적으로 말하면, 함수들은 입력을 받아서 출력을 만들어내기만 하며,"
" 주어진 입력에 대해 생성된 출력에 영향을 끼칠만한 어떠한 내부적인 상태도 가지지 않습니다. 잘 알려진 함수형 언어로는 ML "
"계열(Standard ML, OCaml 및 다른 변형)과 하스켈이 있습니다."

#: ../Doc/howto/functional.rst:47
msgid ""
"The designers of some computer languages choose to emphasize one "
"particular approach to programming.  This often makes it difficult to "
"write programs that use a different approach.  Other languages are multi-"
"paradigm languages that support several different approaches. Lisp, C++, "
"and Python are multi-paradigm; you can write programs or libraries that "
"are largely procedural, object-oriented, or functional in all of these "
"languages.  In a large program, different sections might be written using"
" different approaches; the GUI might be object-oriented while the "
"processing logic is procedural or functional, for example."
msgstr ""
"일부 컴퓨터 언어의 설계자들은 프로그래밍에 대한 한 가지의 특별한 접근 방식을 강조합니다. 이것은 종종 다른 접근 방식으로 "
"프로그램을 작성하는 것을 어렵게 만듭니다. 다른 언어들은 다양한 접근 방법을 지원하는 다중 패러다임 언어입니다. Lisp, C++,"
" 파이썬 등은 다중 패러다임 언어입니다; 이러한 언어에서는 절차적, 객체 지향적 혹은 함수형으로 프로그램이나 라이브러리를 작성할 수"
" 있습니다. 거대한 프로그램에서, 각 구역은 서로 다른 접근 방법을 사용하여 작성될 수 있습니다; 예를 들어 처리 로직이 절차적 "
"혹은 함수형으로 작성되었을 때, GUI는 객체 지향적으로 작성될 수 있습니다."

#: ../Doc/howto/functional.rst:58
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional "
"style discourages functions with side effects that modify internal state "
"or make other changes that aren't visible in the function's return value."
"  Functions that have no side effects at all are called **purely "
"functional**.  Avoiding side effects means not using data structures that"
" get updated as a program runs; every function's output must only depend "
"on its input."
msgstr ""
"함수형 프로그램에서, 입력은 여러 함수의 세트를 통해 흘러 다닙니다. 각 함수는 입력으로부터 동작해서 출력을 만들어냅니다. 함수형 "
"방식은 내부 상태를 수정하거나 함수의 반환 값에서 보이지 않는 다른 변경사항들을 만드는 부작용이 있는 함수를 사용하지 않습니다. "
"부작용이 전혀 없는 함수를 **순수 함수** 라고 합니다. 부작용을 피한다는 것은 프로그램이 실행될 때 수정될 수 있는 자료 구조를"
" 사용하지 않는다는 의미입니다; 모든 함수의 출력은 입력에만 의존해야 합니다."

#: ../Doc/howto/functional.rst:66
msgid ""
"Some languages are very strict about purity and don't even have "
"assignment statements such as ``a=3`` or ``c = a + b``, but it's "
"difficult to avoid all side effects.  Printing to the screen or writing "
"to a disk file are side effects, for example.  For example, in Python a "
"call to the :func:`print` or :func:`time.sleep` function both return no "
"useful value; they're only called for their side effects of sending some "
"text to the screen or pausing execution for a second."
msgstr ""
"어떤 언어는 순수성에 대해 매우 엄격하며, ``a=3`` 혹은 ``c = a + b`` 와 같은 대입문조차 없지만, 모든 부작용을 "
"피하는 것은 어렵습니다. 예를 들어, 화면에 출력하거나 디스크 파일에 쓰는 작업은 부작용입니다. 구체적인 예로, 파이썬에서 "
":func:`print` 혹은 :func:`time.sleep` 함수를 호출하면 의미 없는 값을 반환합니다; 이 함수들은 화면에 "
"문자열을 보내거나 잠시 동안 실행을 일시 중지하는 작업과 같은 부작용을 위해 호출합니다."

#: ../Doc/howto/functional.rst:74
msgid ""
"Python programs written in functional style usually won't go to the "
"extreme of avoiding all I/O or all assignments; instead, they'll provide "
"a functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have"
" other side effects."
msgstr ""
"함수형 방식으로 작성된 파이썬 프로그램은 보통 극단적으로 모든 I/O 혹은 대입문을 회피하는 방식으로 나아가지는 않습니다; 대신 "
"함수형처럼 보이는 인터페이스를 제공하며 내부적으로는 함수형이 아닌 기능들을 사용합니다. 예를 들어 함수의 구현은 여전히 지역 변수에"
" 값을 대입하는 방식이 사용되지만 전역 변수를 수정하거나 다른 부작용을 발생시키지는 않습니다."

#: ../Doc/howto/functional.rst:80
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, "
"and programs consist of making the right set of state changes.  "
"Functional programming wants to avoid state changes as much as possible "
"and works with data flowing between functions.  In Python you might "
"combine the two approaches by writing functions that take and return "
"instances representing objects in your application (e-mail messages, "
"transactions, etc.)."
msgstr ""
"함수형 프로그래밍은 객체 지향 프로그래밍의 반대라고 생각할 수 있습니다. 객체는 내부 상태들을 갖고 있으며 이 상태들을 수정할 수 "
"있는 메서드의 호출 모음이 포함된 작은 캡슐이며, 프로그램은 올바른 상태 변경 집합을 구성합니다. 함수형 프로그래밍은 가능한 한 "
"상태 변경을 피하고자 하며 함수 간의 데이터 흐름을 사용합니다. 파이썬에서는 응용 프로그램의 객체를 나타내는 인스턴스(이메일 "
"메시지, 트랜잭션 등)를 가져와서 반환하는 함수를 작성함으로써 두 가지 접근 방식을 결합할 수 있습니다."

#: ../Doc/howto/functional.rst:89
msgid ""
"Functional design may seem like an odd constraint to work under.  Why "
"should you avoid objects and side effects?  There are theoretical and "
"practical advantages to the functional style:"
msgstr ""
"함수형 설계는 동작 방식에 이상한 제약이 있는 것처럼 보일 수 있습니다. 왜 객체와 부작용을 피해야만 할까요? 함수형 방식은 "
"이론적으로도, 실질적으로도 다음과 같은 장점이 있습니다:"

#: ../Doc/howto/functional.rst:93
msgid "Formal provability."
msgstr "형식적 증명 가능성."

#: ../Doc/howto/functional.rst:94
msgid "Modularity."
msgstr "모듈성."

#: ../Doc/howto/functional.rst:95
msgid "Composability."
msgstr "결합성."

#: ../Doc/howto/functional.rst:96
msgid "Ease of debugging and testing."
msgstr "디버깅과 테스트 용이성."

#: ../Doc/howto/functional.rst:100
msgid "Formal provability"
msgstr "형식적 증명 가능성"

#: ../Doc/howto/functional.rst:102
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical "
"proof that a functional program is correct."
msgstr "이론적인 장점은 함수형 프로그램이 정확하다는 수학적 증명을 만드는 것이 더 쉽다는 것입니다."

#: ../Doc/howto/functional.rst:105
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces"
" the right result for all possible inputs."
msgstr ""
"오랫동안 연구자들은 수학적으로 프로그램이 정확하다는 것을 증명하는 방법을 찾는 데 관심을 보여왔습니다. 이것은 수많은 입력에 대해 "
"프로그램을 테스트하고 출력이 정확하다고 결론짓거나, 프로그램의 소스코드를 읽어보고 코드가 올바르다고 결론짓는 것과는 다릅니다; "
"그들의 목표는 입력 가능한 모든 것에 대해 프로그램이 올바른 결과를 산출한다는 엄격한 증거를 찾는 것입니다."

#: ../Doc/howto/functional.rst:112
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's "
"variables that are always true.  For each line of code, you then show "
"that if invariants X and Y are true **before** the line is executed, the "
"slightly different invariants X' and Y' are true **after** the line is "
"executed.  This continues until you reach the end of the program, at "
"which point the invariants should match the desired conditions on the "
"program's output."
msgstr ""
"프로그램이 올바른지 증명하기 위해 사용하는 기술은 항상 참인 입력 데이터와 프로그램의 변수라는 특성을 지닌 **불변자** 를 "
"작성하는 것입니다. 각 코드 행에 대해, 그 행이 실행되기 **전에** 불변자 X와 Y가 참이라면, 그 행이 실행된 **후에** "
"약간 다른 불변자 X' 및 Y'가 참이라는 것을 보여줍니다. 이 작업은 프로그램이 종료될 때까지 계속되며, 종료 시점에서 불변자는 "
"프로그램의 출력으로써 원하는 조건과 일치해야만 합니다."

#: ../Doc/howto/functional.rst:120
msgid ""
"Functional programming's avoidance of assignments arose because "
"assignments are difficult to handle with this technique; assignments can "
"break invariants that were true before the assignment without producing "
"any new invariants that can be propagated onward."
msgstr ""
"함수형 프로그래밍에서 값 대입을 피하려는 이유는 값 대입이 이러한 기법을 활용하는 것을 어렵게 만들기 때문입니다; 대입은 다음 "
"단계로 나아갈 수 있는 새 불변자를 만들지 않은 채로, 대입전에 참이었던 불변자를 무너뜨릴 수 있습니다."

#: ../Doc/howto/functional.rst:125
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that "
"are several pages long; the proof of correctness for a moderately "
"complicated program would be enormous, and few or none of the programs "
"you use daily (the Python interpreter, your XML parser, your web browser)"
" could be proven correct.  Even if you wrote down or generated a proof, "
"there would then be the question of verifying the proof; maybe there's an"
" error in it, and you wrongly believe you've proved the program correct."
msgstr ""
"불행하게도, 정확한 프로그램임을 증명하는 것은 실제로는 비실용적이며 파이썬 소프트웨어와 관련이 없습니다. 사소한 프로그램일지라도 "
"여러 페이지 분량의 증명이 필요합니다; 적당히 복잡한 프로그램에 대한 정확성의 증명은 엄청난 양일 것이며, 매일 사용하는 프로그램 "
"(파이썬 인터프리터, XML 파서, 웹 브라우저)의 정확성은 거의 증명이 불가능할 수도 있습니다. 만약 증명을 작성하거나 "
"만들었더라도, 그 증명이 검증된 것인지 의구심이 들 것입니다; 어쩌면 그 증명에 오류가 있을 수도 있고, 프로그램의 정확성이 "
"증명되었다고 잘못 믿고 있을 수도 있습니다."

#: ../Doc/howto/functional.rst:136
msgid "Modularity"
msgstr "모듈성"

#: ../Doc/howto/functional.rst:138
msgid ""
"A more practical benefit of functional programming is that it forces you "
"to break apart your problem into small pieces.  Programs are more modular"
" as a result.  It's easier to specify and write a small function that "
"does one thing than a large function that performs a complicated "
"transformation.  Small functions are also easier to read and to check for"
" errors."
msgstr ""
"함수형 프로그래밍의 실질적인 이점은 문제를 작은 조각으로 분해하도록 강제한다는 점입니다. 결과적으로 프로그램은 더욱 모듈화가 "
"됩니다. 복잡한 변환을 수행하는 거대한 함수보다, 한 가지 작업을 수행하는 작은 함수를 명시하고 작성하기가 더 쉽습니다. 작은 "
"함수는 읽기에도 더 쉽고 오류를 확인하기도 쉽습니다."

#: ../Doc/howto/functional.rst:146
msgid "Ease of debugging and testing"
msgstr "디버깅과 테스트 용이성"

#: ../Doc/howto/functional.rst:148
msgid "Testing and debugging a functional-style program is easier."
msgstr "함수형 방식 프로그램은 테스트하고 디버깅하는 것이 더 쉽습니다."

#: ../Doc/howto/functional.rst:150
msgid ""
"Debugging is simplified because functions are generally small and clearly"
" specified.  When a program doesn't work, each function is an interface "
"point where you can check that the data are correct.  You can look at the"
" intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"일반적으로 함수가 작고 분명하게 명시되기 때문에 디버깅이 단순화됩니다. 프로그램이 동작하지 않는다면, 각 함수는 데이터가 올바른지 "
"확인할 수 있는 접점이 됩니다. 중간 지점의 입력과 출력을 살펴보면 버그가 있는 함수를 빠르게 분간할 수 있습니다."

#: ../Doc/howto/functional.rst:155
msgid ""
"Testing is easier because each function is a potential subject for a unit"
" test. Functions don't depend on system state that needs to be replicated"
" before running a test; instead you only have to synthesize the right "
"input and then check that the output matches expectations."
msgstr ""
"각 함수는 잠재적으로 단위 테스트의 대상이기 때문에 테스트가 더 쉽습니다. 함수는 테스트를 실행하기 전에 복제해야 하는 시스템 "
"상태에 의존하지 않습니다; 올바른 입력을 만들고 결과가 예상과 일치하는지 확인만 하면 됩니다."

#: ../Doc/howto/functional.rst:162
msgid "Composability"
msgstr "결합성"

#: ../Doc/howto/functional.rst:164
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will "
"be unavoidably specialized to a particular application, but others will "
"be useful in a wide variety of programs.  For example, a function that "
"takes a directory path and returns all the XML files in the directory, or"
" a function that takes a filename and returns its contents, can be "
"applied to many different situations."
msgstr ""
"함수형 방식의 프로그램을 만들 때, 다양한 입력과 출력으로 여러 가지 함수를 작성하게 됩니다. 이러한 함수 중 일부는 불가피하게 "
"특정 응용 프로그램에 특화될 수 있지만, 대체로 다양한 프로그램에서 유용하게 사용할 수 있습니다. 예를 들어 디렉터리 경로를 받아서"
" 그 디렉터리 내의 모든 XML 파일을 반환하는 함수나, 혹은 파일명을 받아서 그 내용을 반환하는 함수는 다양한 상황에 적용할 수 "
"있습니다."

#: ../Doc/howto/functional.rst:171
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new "
"configuration and writing a few functions specialized for the current "
"task."
msgstr ""
"시간이 흐르면, 여러분은 개인적인 유틸리티 라이브러리를 구성하게 될 것입니다. 보통, 새로운 구성으로 기존 함수를 배치하고 현재 "
"작업에 특화된 몇 가지 함수만을 작성해서 새로운 프로그램을 구성하게 됩니다."

#: ../Doc/howto/functional.rst:179
msgid "Iterators"
msgstr "이터레이터"

#: ../Doc/howto/functional.rst:181
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr "함수형 방식의 프로그램을 작성하는 중요한 토대가 되는 파이썬 언어의 기능을 살펴보겠습니다: 이터레이터."

#: ../Doc/howto/functional.rst:184
msgid ""
"An iterator is an object representing a stream of data; this object "
"returns the data one element at a time.  A Python iterator must support a"
" method called :meth:`~iterator.__next__` that takes no arguments and "
"always returns the next element of the stream.  If there are no more "
"elements in the stream, :meth:`~iterator.__next__` must raise the "
":exc:`StopIteration` exception. Iterators don't have to be finite, "
"though; it's perfectly reasonable to write an iterator that produces an "
"infinite stream of data."
msgstr ""
"이터레이터는 데이터 스트림을 나타내는 객체입니다; 이 객체는 한 번에 한 요소씩 데이터를 반환합니다. 파이썬 이터레이터는 반드시 "
":meth:`~iterator.__next__` 라는 메서드를 지원해야 합니다. 이 메서드는 인자를 취하지 않고 항상 스트림의 다음"
" 요소를 반환합니다. 만약 스트림에 더는 요소가 없다면, :meth:`~iterator.__next__` 는 "
":exc:`StopIteration` 예외를 발생시켜야 합니다. 이터레이터가 유한할 필요는 없습니다; 무한한 데이터 스트림을 "
"생성하는 이터레이터를 작성하는 것도 합리적인 방법입니다."

#: ../Doc/howto/functional.rst:192
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to"
" return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  "
"Several of Python's built-in data types support iteration, the most "
"common being lists and dictionaries.  An object is called "
":term:`iterable` if you can get an iterator for it."
msgstr ""
"내장 함수 :func:`iter` 는 임의의 객체를 취하여 객체의 내용이나 요소를 반환하는 이터레이터를 반환합니다. 객체가 "
"이터레이션을 지원하지 않으면 :exc:`TypeError` 를 발생시킵니다. 파이썬의 내장 데이터형 중 몇 가지가 이터레이션을 "
"지원하는데, 가장 일반적인 것은 리스트와 딕셔너리입니다. 이터레이터를 얻을 수 있는 객체는 :term:`이터러블 "
"<iterable>` 이라고 불립니다."

#: ../Doc/howto/functional.rst:199
msgid "You can experiment with the iteration interface manually:"
msgstr "수동으로 이터레이션 인터페이스를 실험해볼 수 있습니다:"

#: ../Doc/howto/functional.rst:217
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X "
"in Y``, Y must be an iterator or some object for which :func:`iter` can "
"create an iterator.  These two statements are equivalent::"
msgstr ""
"파이썬은 여러 다른 컨텍스트에서 이터러블 객체를 기대하며, 가장 중요한 것은 :keyword:`for` 문입니다. ``for X "
"in Y`` 문에서 Y는 반드시 이터레이터 혹은 :func:`iter` 가 이터레이터를 생성할 수 있는 객체이어야 합니다. 다음 두"
" 문장은 같은 의미입니다::"

#: ../Doc/howto/functional.rst:229
msgid ""
"Iterators can be materialized as lists or tuples by using the "
":func:`list` or :func:`tuple` constructor functions:"
msgstr "이터레이터는 :func:`list` 또는 :func:`tuple` 생성자 함수를 사용하여 리스트나 튜플로 나타낼 수 있습니다:"

#: ../Doc/howto/functional.rst:238
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"시퀀스 언패킹 또한 이터레이터를 지원합니다: 이터레이터가 N개의 요소를 반환한다는 것을 알고 있다면, 그것들을 N-튜플로 언패킹할 "
"수 있습니다:"

#: ../Doc/howto/functional.rst:247
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator."
"  You'll run into obvious problems if the iterator is infinite; "
":func:`max`, :func:`min` will never return, and if the element X never "
"appears in the stream, the ``\"in\"`` and ``\"not in\"`` operators won't "
"return either."
msgstr ""
":func:`max` 및 :func:`min` 과 같은 내장 함수는 하나의 이터레이터 인자를 취할 수 있으며 가장 큰 혹은 가장 "
"작은 요소를 반환합니다. ``\"in\"`` 과 ``\"not in\"`` 연산자 또한 이터레이터를 지원합니다: 이터레이터가 반환한"
" 스트림에서 X가 발견되면 ``X in iterator`` 는 참입니다. 이터레이터가 무한하다면 명백한 문제에 부딪힙니다; "
":func:`max` 와 :func:`min` 는 영원히 결과를 반환하지 않으며, 요소 X가 스트림에서 나타나지 않으면 "
"``\"in\"`` 과 ``\"not in\"`` 연산자 역시 영원히 결과를 반환하지 않을 것입니다."

#: ../Doc/howto/functional.rst:255
msgid ""
"Note that you can only go forward in an iterator; there's no way to get "
"the previous element, reset the iterator, or make a copy of it.  Iterator"
" objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to "
"create a new iterator."
msgstr ""
"이터레이터에서는 오직 앞으로만 나아갈 수 있다는 점에 유의하세요; 이전 요소를 가져오거나, 이터레이터를 재설정하거나, 사본을 만들 "
"방법은 없습니다. 이터레이터 객체는 선택적으로 이러한 추가 기능을 제공할 수 있지만, 이터레이터 프로토콜은 "
":meth:`~iterator.__next__` 메서드만 명시해두었습니다. 함수는 모든 이터레이터의 출력을 소비할 수 있으므로 같은"
" 스트림에서 다른 작업을 수행해야 하는 경우 새로운 이터레이터를 만들어야 합니다."

#: ../Doc/howto/functional.rst:265
msgid "Data Types That Support Iterators"
msgstr "이터레이터를 지원하는 데이터형"

#: ../Doc/howto/functional.rst:267
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support "
"creation of an iterator."
msgstr ""
"리스트와 튜플이 이터레이터를 어떻게 지원하는지 이미 살펴보았습니다. 실제로 문자열과 같은 파이썬 시퀀스형은 이터레이터의 생성을 "
"자동으로 지원합니다."

#: ../Doc/howto/functional.rst:271
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop "
"over the dictionary's keys::"
msgstr ":func:`iter` 를 딕셔너리에 적용하면 딕셔너리의 키를 반복하는 이터레이터를 반환합니다::"

#: ../Doc/howto/functional.rst:291
msgid ""
"Note that starting with Python 3.7, dictionary iteration order is "
"guaranteed to be the same as the insertion order. In earlier versions, "
"the behaviour was unspecified and could vary between implementations."
msgstr ""

#: ../Doc/howto/functional.rst:295
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the "
":meth:`~dict.values` or :meth:`~dict.items` methods to get an appropriate"
" iterator."
msgstr ""
":func:`iter` 를 딕셔너리에 적용하는 것은 항상 키를 반복하지만, 딕셔너리에는 다른 이터레이터를 반환하는 메서드가 "
"있습니다. 값이나 키/값 쌍을 반복하는 경우에는 명시적으로 :meth:`~dict.values` 혹은 "
":meth:`~dict.items` 메서드를 사용하여 적절한 이터레이터를 얻을 수 있습니다."

#: ../Doc/howto/functional.rst:301
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite"
" stream of ``(key, value)`` tuples:"
msgstr ":func:`dict` 생성자는 ``(키, 값)`` 튜플의 유한한 스트림을 반환하는 이터레이터를 받을 수 있습니다:"

#: ../Doc/howto/functional.rst:308
msgid ""
"Files also support iteration by calling the "
":meth:`~io.TextIOBase.readline` method until there are no more lines in "
"the file.  This means you can read each line of a file like this::"
msgstr ""
"또한 파일은 더는 새로운 줄이 없을 때까지 :meth:`~io.TextIOBase.readline` 메서드를 호출하여 이터레이션을 "
"지원합니다. 즉, 다음과 같이 파일의 각 행을 읽을 수 있습니다::"

#: ../Doc/howto/functional.rst:316
msgid ""
"Sets can take their contents from an iterable and let you iterate over "
"the set's elements::"
msgstr "집합은 이터러블에서 내용을 가져와서 집합의 원소를 반복할 수 있습니다::"

#: ../Doc/howto/functional.rst:326
msgid "Generator expressions and list comprehensions"
msgstr "제너레이터 표현식과 리스트 컴프리헨션"

#: ../Doc/howto/functional.rst:328
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"이터레이터의 출력에 대한 두 가지 일반적인 연산은 1) 모든 요소에 대해 어떤 연산을 수행하고, 2) 어떤 조건을 만족하는 요소의 "
"부분 집합을 선택하는 것입니다. 예를 들어 문자열 리스트가 있으면 각 줄에서 후미 공백을 제거하거나, 주어진 서브 스트링을 포함하는"
" 모든 문자열을 추출할 수 있습니다."

#: ../Doc/howto/functional.rst:334
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" "
"and \"genexps\") are a concise notation for such operations, borrowed "
"from the functional programming language Haskell "
"(https://www.haskell.org/).  You can strip all the whitespace from a "
"stream of strings with the following code::"
msgstr ""
"리스트 컴프리헨션과 제너레이터 표현식(줄임말: \"listcomps\" 및 \"genexps\")은 함수형 프로그래밍 언어 "
"하스켈(https://www.haskell.org/)에서 빌린 이러한 작업을 위한 간결한 표기법입니다. 다음 코드를 사용하여 문자열"
" 스트림에서 모든 공백을 제거할 수 있습니다::"

#: ../Doc/howto/functional.rst:347
msgid "You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr "``\"if\"`` 조건을 추가하여 특정 요소만 선택할 수도 있습니다::"

#: ../Doc/howto/functional.rst:352
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` "
"is a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not"
" needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return"
" an infinite stream or a very large amount of data.  Generator "
"expressions are preferable in these situations."
msgstr ""
"리스트 컴프리헨션을 사용하면 파이썬 리스트를 얻을 수 있습니다; ``stripped_list`` 는 이터레이터가 아니라 결과 행을 "
"담고 있는 리스트입니다. 제너레이터 표현식은 필요에 따라 값을 계산하는 이터레이터를 반환하며 모든 값을 한 번에 구체화할 필요가 "
"없습니다. 즉, 무한 스트림이나 매우 많은 양의 데이터를 반환하는 이터레이터로 작업하는 경우 리스트 컴프리헨션은 유용하지 않습니다."
" 제너레이터 표현식은 이러한 상황에서 유용합니다."

#: ../Doc/howto/functional.rst:359
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"제너레이터 표현식은 괄호(\"()\")로 묶여 있으며 리스트 컴프리헨션은 꺾쇠괄호(\"[]\")로 묶여 있습니다. 제너레이터 "
"표현식은 다음과 같은 형식입니다::"

#: ../Doc/howto/functional.rst:372
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr "다시 말하면, 리스트 컴프리헨션을 위해서는 바깥쪽 괄호만 다릅니다(괄호 대신 꺾쇠괄호)."

#: ../Doc/howto/functional.rst:375
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when "
"``condition`` is true."
msgstr ""
"생성된 출력의 요소는 ``expression`` 의 연속적인 값이 될 것입니다. ``if`` 절은 모두 선택적입니다; if 절이 "
"존재한다면, ``expression`` 은 ``condition`` 이 참일 때만 평가되고 결과에 추가됩니다."

#: ../Doc/howto/functional.rst:379
msgid ""
"Generator expressions always have to be written inside parentheses, but "
"the parentheses signalling a function call also count.  If you want to "
"create an iterator that will be immediately passed to a function you can "
"write::"
msgstr ""
"제너레이터 표현식은 항상 괄호 안에 작성해야 하지만 함수 호출을 알리는 괄호도 포함됩니다. 함수에 즉시 전달되는 이터레이터를 만들고"
" 싶다면 다음과 같이 작성할 수 있습니다::"

#: ../Doc/howto/functional.rst:385
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated "
"over from left to right, **not** in parallel.  For each element in "
"``sequence1``, ``sequence2`` is looped over from the beginning.  "
"``sequence3`` is then looped over for each resulting pair of elements "
"from ``sequence1`` and ``sequence2``."
msgstr ""
"``for...in`` 절은 반복할 시퀀스를 포함합니다. 시퀀스는 왼쪽에서 오른쪽으로 반복되며 병렬로 처리되지 **않기** 때문에 "
"같은 길이일 필요는 없습니다. ``sequence1`` 의 각 요소에 대해 ``sequence2`` 는 처음부터 반복됩니다. "
"``sequence3`` 은 ``sequence1`` 과 ``sequence2`` 의 각각 모든 결과에 대해 반복됩니다."

#: ../Doc/howto/functional.rst:391
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr "다른 식으로 표현하면, 리스트 컴프리헨션 혹은 제너레이터 표현식은 다음 파이썬 코드와 같습니다::"

#: ../Doc/howto/functional.rst:408
msgid ""
"This means that when there are multiple ``for...in`` clauses but no "
"``if`` clauses, the length of the resulting output will be equal to the "
"product of the lengths of all the sequences.  If you have two lists of "
"length 3, the output list is 9 elements long:"
msgstr ""
"이것은 여러 개의 ``for...in`` 절이 있지만 ``if`` 절이 없을 때 결과 출력의 길이가 모든 시퀀스 길이의 곱과 같음을"
" 의미합니다. 길이가 3인 두 개의 리스트가 있는 경우 출력 목록의 길이는 9개입니다:"

#: ../Doc/howto/functional.rst:420
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if "
"``expression`` is creating a tuple, it must be surrounded with "
"parentheses.  The first list comprehension below is a syntax error, while"
" the second one is correct::"
msgstr ""
"파이썬 문법의 모호함을 피하고자, ``expression`` 이 튜플을 생성하고 있다면, 괄호로 묶어야 합니다. 아래의 첫 번째 "
"리스트 컴프리헨션은 구문 오류이며, 두 번째는 올바릅니다::"

#: ../Doc/howto/functional.rst:431
msgid "Generators"
msgstr "제너레이터"

#: ../Doc/howto/functional.rst:433
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"제너레이터는 이터레이터를 작성하는 작업을 단순화하는 특별한 클래스의 함수입니다. 일반 함수는 값을 계산하여 반환하지만, 제너레이터는"
" 값의 스트림을 반환하는 이터레이터를 반환합니다."

#: ../Doc/howto/functional.rst:437
msgid ""
"You're doubtless familiar with how regular function calls work in Python "
"or C. When you call a function, it gets a private namespace where its "
"local variables are created.  When the function reaches a ``return`` "
"statement, the local variables are destroyed and the value is returned to"
" the caller.  A later call to the same function creates a new private "
"namespace and a fresh set of local variables. But, what if the local "
"variables weren't thrown away on exiting a function?  What if you could "
"later resume the function where it left off?  This is what generators "
"provide; they can be thought of as resumable functions."
msgstr ""
"파이썬이나 C에서 정규 함수 호출이 어떻게 작동하는지 잘 알고 있을 것입니다. 함수를 호출하면 지역 변수가 생성되는 비공개 이름 "
"공간이 생깁니다. 함수가 ``return`` 문에 도달하면 지역 변수가 소멸하고 그 값이 호출자에게 반환됩니다. 같은 함수를 나중에"
" 호출하면 새로운 비공개 이름 공간과 새로운 지역 변수 집합이 만들어집니다. 그러나 지역 변수가 함수를 빠져나갈 때 버려지지 않으면"
" 어떻게 될까요? 나중에 중단했던 곳에서 함수를 다시 시작할 수 있다면 어떨까요? 이것이 제너레이터가 제공하는 것입니다; 그들은 "
"재개 가능한 함수라고 생각할 수 있습니다."

#: ../Doc/howto/functional.rst:446
msgid "Here's the simplest example of a generator function:"
msgstr "다음은 제너레이터 함수의 가장 간단한 예입니다:"

#: ../Doc/howto/functional.rst:452
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator "
"function; this is detected by Python's :term:`bytecode` compiler which "
"compiles the function specially as a result."
msgstr ""
":keyword:`yield` 키워드를 포함하는 함수는 제너레이터 함수입니다; 이것은 파이썬의 :term:`바이트코드 "
"<bytecode>` 컴파일러에 의해 감지됩니다. 결과적으로 컴파일러는 특별하게 함수를 컴파일합니다."

#: ../Doc/howto/functional.rst:456
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator "
"protocol.  On executing the ``yield`` expression, the generator outputs "
"the value of ``i``, similar to a ``return`` statement.  The big "
"difference between ``yield`` and a ``return`` statement is that on "
"reaching a ``yield`` the generator's state of execution is suspended and "
"local variables are preserved.  On the next call to the generator's "
":meth:`~generator.__next__` method, the function will resume executing."
msgstr ""
"제너레이터 함수를 호출하면 단일 값을 반환하지 않습니다; 대신 이터레이터 프로토콜을 지원하는 제너레이터 객체를 반환합니다. "
"``yield`` 표현식을 실행하면 제너레이터는 ``return`` 문과 비슷하게 ``i`` 의 값을 출력합니다. ``yield``"
" 와 ``return`` 의 큰 차이점은 ``yield`` 에 도달하면 제너레이터의 실행 상태가 일시 중단되고 지역 변수가 "
"보존된다는 것입니다. 제너레이터의 :meth:`~generator.__next__` 메서드가 다음에 실행될 때, 함수가 다시 "
"실행됩니다."

#: ../Doc/howto/functional.rst:465
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "다음은 ``generate_ints()`` 제너레이터의 사용 예입니다:"

#: ../Doc/howto/functional.rst:482
#, fuzzy
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a, b, c = "
"generate_ints(3)``."
msgstr ""
"여러분은 똑같이 ``for i in generate_ints(5)`` 또는 ``a,b,c = generate_ints(3)`` 라고"
" 쓸 수 있습니다."

#: ../Doc/howto/functional.rst:485
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the "
":meth:`~generator.__next__` method.  Once this happens, or the bottom of "
"the function is reached, the procession of values ends and the generator "
"cannot yield any further values."
msgstr ""
"제너레이터 함수 내에서, ``return value`` 는 :meth:`~generator.__next__` 메서드에서 "
"``StopIteration(value)`` 를 발생시킵니다. 이런 일이 발생하거나 함수의 맨 아래에 도달하면 값의 행렬이 끝나고 "
"제너레이터는 더는 값을 산출할 수 없습니다."

#: ../Doc/howto/functional.rst:490
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"직접 클래스를 작성하고 제너레이터의 모든 지역 변수를 인스턴스 변수로 저장하여 제너레이터의 효과를 수동으로 얻을 수 있습니다. 예를"
" 들어, 정수 리스트를 반환하는 것은 ``self.count`` 를 0으로 설정하고 :meth:`~iterator.__next__`"
" 메서드로 ``self.count`` 를 증가시켜 반환하는 식으로 수행할 수 있습니다. 그러나, 다소 복잡한 제너레이터의 경우에는 "
"해당 클래스를 작성하는 것이 훨씬 더 복잡할 수 있습니다."

#: ../Doc/howto/functional.rst:498
msgid ""
"The test suite included with Python's library, "
":source:`Lib/test/test_generators.py`, contains a number of more "
"interesting examples.  Here's one generator that implements an in-order "
"traversal of a tree using generators recursively. ::"
msgstr ""
"파이썬의 라이브러리인 :source:`Lib/test/test_generators.py` 에 포함된 테스트 묶음에는 더 많은 "
"흥미로운 예제들이 있습니다. 제너레이터를 재귀적으로 사용하여 트리를 중위 순회하는 것을 구현하는 하나의 제너레이터가 있습니다. ::"

#: ../Doc/howto/functional.rst:514
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the "
"N-Queens problem (placing N queens on an NxN chess board so that no queen"
" threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"``test_generators.py`` 의 다른 두 가지 예는, N-여왕 문제(NxN 체스판에 서로 다른  왕비를 위협할 수 "
"없도록 N개의 왕비를 배치하는 문제)와 기사의 여행(기사가 NxN 체스판의 모든 칸을 정확히 한 번씩 갈 수 있도록 하는 방법을 "
"찾는 문제)입니다."

#: ../Doc/howto/functional.rst:522
msgid "Passing values into a generator"
msgstr "제너레이터에 값 전달하기"

#: ../Doc/howto/functional.rst:524
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to "
"pass any new information into the function when its execution is resumed."
"  You could hack together this ability by making the generator look at a "
"global variable or by passing in some mutable object that callers then "
"modify, but these approaches are messy."
msgstr ""
"파이썬 2.4 및 그 이전 버전에서 제너레이터는 출력만 생성했습니다. 제너레이터의 코드가 이터레이터를 만들기 위해 호출된 후에는 그"
" 실행이 다시 시작될 때 함수에 새로운 정보를 전달할 방법이 없었습니다. 제너레이터가 전역 변수를 보거나 호출자가 수정할 수 있는 "
"변경 가능한 객체를 전달함으로써 이 기능을 해킹할 수 있지만, 이러한 접근법은 지저분한 방식입니다."

#: ../Doc/howto/functional.rst:531
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. "
":keyword:`yield` became an expression, returning a value that can be "
"assigned to a variable or otherwise operated on::"
msgstr ""
"파이썬 2.5에서는 제너레이터에 값을 전달하는 간단한 방법이 있습니다. :keyword:`yield` 는 표현식이 되어 변수에 "
"대입하거나 다른 식으로 조작할 수 있는 값을 반환합니다::"

#: ../Doc/howto/functional.rst:537
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the"
" above example. The parentheses aren't always necessary, but it's easier "
"to always add them instead of having to remember when they're needed."
msgstr ""
"위 예제처럼 반환 값으로 무엇인가를 할 때 ``yield`` 표현식 주위에 **항상** 괄호를 넣는 것이 좋습니다. 괄호는 항상 "
"필요한 것은 아니지만 필요한 시점을 기억하지 않고 항상 추가하기가 더 쉽습니다."

#: ../Doc/howto/functional.rst:542
msgid ""
"(:pep:`342` explains the exact rules, which are that a "
"``yield``-expression must always be parenthesized except when it occurs "
"at the top-level expression on the right-hand side of an assignment.  "
"This means you can write ``val = yield i`` but have to use parentheses "
"when there's an operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` 는 정확한 규칙을 설명합니다. 이것은 대입의 오른쪽에 있는 최상위 표현식에서 발생하는 경우를 제외하고 항상 "
"``yield`` 표현식을 괄호로 묶어야 한다는 것입니다. ``val = yield i`` 라고 쓸 수도 있지만, ``val = "
"(yield i) + 12`` 처럼 연산이 있을 때는 괄호를 써야합니다.)"

#: ../Doc/howto/functional.rst:548
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and "
"the ``yield`` expression returns the specified value.  If the regular "
":meth:`~generator.__next__` method is called, the ``yield`` returns "
"``None``."
msgstr ""
"값은 :meth:`send(value) <generator.send>` 메서드를 호출하여 제너레이터로 보내집니다. 이 메서드는 "
"제너레이터의 코드를 다시 시작하고 ``yield`` 표현식은 지정된 값을 반환합니다. 만약 정규 "
":meth:`~generator.__next__` 메서드가 호출되면 ``yield`` 는 ``None`` 을 반환합니다."

#: ../Doc/howto/functional.rst:553
msgid ""
"Here's a simple counter that increments by 1 and allows changing the "
"value of the internal counter."
msgstr "다음은 1씩 증가하며 내부 카운터값을 변경할 수 있는 간단한 카운터입니다."

#: ../Doc/howto/functional.rst:568
msgid "And here's an example of changing the counter:"
msgstr "다음은 카운터 변경의 예시입니다:"

#: ../Doc/howto/functional.rst:585
msgid ""
"Because ``yield`` will often be returning ``None``, you should always "
"check for this case.  Don't just use its value in expressions unless "
"you're sure that the :meth:`~generator.send` method will be the only "
"method used to resume your generator function."
msgstr ""
"``yield`` 가 종종 ``None`` 을 반환할 것이므로, 항상 이 경우를 확인해야 합니다. "
":meth:`~generator.send` 메서드가 제너레이터 함수를 다시 시작하는데 사용되는 유일한 메서드가 아니라면, 표현식의 "
"결괏값을 확인없이 사용하지 마세요."

#: ../Doc/howto/functional.rst:590
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr ":meth:`~generator.send` 외에도 제너레이터에 대한 두 가지 다른 메서드가 있습니다:"

#: ../Doc/howto/functional.rst:593
msgid ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` is used"
" to raise an exception inside the generator; the exception is raised by "
"the ``yield`` expression where the generator's execution is paused."
msgstr ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` 는 제너레이터"
" 내에서 예외를 발생시키는 데 사용됩니다; 예외는 제너레이터의 실행이 일시 중지된 ``yield`` 표현식에 의해 발생합니다."

#: ../Doc/howto/functional.rst:597
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside "
"the generator to terminate the iteration.  On receiving this exception, "
"the generator's code must either raise :exc:`GeneratorExit` or "
":exc:`StopIteration`; catching the exception and doing anything else is "
"illegal and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close`"
" will also be called by Python's garbage collector when the generator is "
"garbage-collected."
msgstr ""
":meth:`~generator.close` 는 생성자 내에서 :exc:`GeneratorExit` 예외를 발생시켜 이터레이션을 "
"종료합니다. 이 예외가 발생하면 제너레이터의 코드는 :exc:`GeneratorExit` 또는 :exc:`StopIteration`"
" 을 발생시켜야 합니다; 예외를 받고도 다른 작업을 하는 것은 금지되어 있으며 :exc:`RuntimeError` 를 촉발합니다. "
":meth:`~generator.close` 는 제너레이터가 가비지로 수거될 때 파이썬의 가비지 수거기에 의해 호출될 것입니다."

#: ../Doc/howto/functional.rst:605
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching "
":exc:`GeneratorExit`."
msgstr ""
":exc:`GeneratorExit` 이 발생할 때 정리 작업을 위한 코드를 실행해야 한다면 :exc:`GeneratorExit` "
"를 잡는 대신 ``try: ... finally:`` 를 사용하는 것이 좋습니다."

#: ../Doc/howto/functional.rst:608
msgid ""
"The cumulative effect of these changes is to turn generators from one-way"
" producers of information into both producers and consumers."
msgstr "이러한 변화의 누적 효과는 제너레이터를 일방적인 정보 생산자에서 생산자와 소비자 모두로 전환하는 것입니다."

#: ../Doc/howto/functional.rst:611
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but "
"coroutines can be entered, exited, and resumed at many different points "
"(the ``yield`` statements)."
msgstr ""
"제너레이터는 **코루틴** 이 되어 더 일반적인 형태의 서브루틴이 됩니다. 서브루틴은 한 지점에서 시작되고 다른 한 지점(함수의 맨"
" 위와 ``return`` 문)에서 빠져나옵니다. 그러나 여러 다른 지점에서 코루틴을 시작하고 빠져나오고 다시 시작할 수 "
"있습니다(``yield`` 문)."

#: ../Doc/howto/functional.rst:618
msgid "Built-in functions"
msgstr "내장 함수"

#: ../Doc/howto/functional.rst:620
msgid "Let's look in more detail at built-in functions often used with iterators."
msgstr "이터레이터에서 자주 사용되는 내장 함수를 자세히 살펴보겠습니다."

#: ../Doc/howto/functional.rst:622
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` "
"duplicate the features of generator expressions:"
msgstr "파이썬의 두 가지 내장 함수인 :func:`map` 와 :func:`filter` 는 제너레이터 표현식의 기능을 복제합니다:"

#: ../Doc/howto/functional.rst:634
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the "
"sequence"
msgstr ":func:`map(f, iterA, iterB, ...) <map>` 은 다음과 같은 시퀀스에 대한 이터레이터를 반환합니다."

#: ../Doc/howto/functional.rst:626
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."
msgstr ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."

#: ../Doc/howto/functional.rst:636
msgid "You can of course achieve the same effect with a list comprehension."
msgstr "물론 리스트 컴프리헨션으로 같은 효과를 얻을 수 있습니다."

#: ../Doc/howto/functional.rst:638
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the"
" sequence elements that meet a certain condition, and is similarly "
"duplicated by list comprehensions.  A **predicate** is a function that "
"returns the truth value of some condition; for use with :func:`filter`, "
"the predicate must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` 는 특정 조건을 만족하는 모든 시퀀스 요소에 대한 "
"이터레이터를 반환하며, 마찬가지로 리스트 컴프리헨션에 의해 복제됩니다. **predicate** 는 어떤 조건의 진릿값을 반환하는 "
"함수입니다; :func:`filter` 와 함께 사용하는 경우, predicate는 단일 값을 받아들여야 합니다."

#: ../Doc/howto/functional.rst:651
msgid "This can also be written as a list comprehension:"
msgstr "또한 이것은 리스트 컴프리헨션으로 작성될 수 있습니다:"

#: ../Doc/howto/functional.rst:657
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in "
"the iterable returning 2-tuples containing the count (from *start*) and "
"each element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` 는 카운트(*start* 부터)와 각 요소를 "
"포함하는 2-튜플을 반환하는 이터러블의 요소를 계산합니다. ::"

#: ../Doc/howto/functional.rst:667
msgid ""
":func:`enumerate` is often used when looping through a list and recording"
" the indexes at which certain conditions are met::"
msgstr ":func:`enumerate` 는 리스트를 반복하고 특정 조건이 충족되는 인덱스를 기록할 때 자주 사용됩니다::"

#: ../Doc/howto/functional.rst:675
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all "
"the elements of the iterable into a list, sorts the list, and returns the"
" sorted result.  The *key* and *reverse* arguments are passed through to "
"the constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` 는 이터러블의 모든 요소를"
" 리스트로 모으고, 리스트를 정렬하고, 정렬된 결과를 반환합니다. *key* 와 *reverse* 인자는 생성된 리스트의 "
":meth:`~list.sort` 메서드로 전달됩니다. ::"

#: ../Doc/howto/functional.rst:690
msgid "(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr "(정렬에 대한 자세한 설명은 :ref:`sortinghowto` 를 참고하세요.)"

#: ../Doc/howto/functional.rst:693
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at"
" the truth values of an iterable's contents.  :func:`any` returns "
"``True`` if any element in the iterable is a true value, and :func:`all` "
"returns ``True`` if all of the elements are true values:"
msgstr ""
":func:`any(iter) <any>` 및 :func:`all(iter) <all>` 내장 함수는 이터러블의 진릿값을 봅니다. "
":func:`any` 는 이터러블의 어떤 요소가 참이면 ``True`` 를 반환하고, :func:`all` 은 모든 요소가 참이면 "
"``True`` 를 반환합니다:"

#: ../Doc/howto/functional.rst:712
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable"
" and returns them in a tuple::"
msgstr ":func:`zip(iterA, iterB, ...) <zip>` 은 각 이터러블에서 하나의 요소를 취하여 튜플로 반환합니다::"

#: ../Doc/howto/functional.rst:718
msgid ""
"It doesn't construct an in-memory list and exhaust all the input "
"iterators before returning; instead tuples are constructed and returned "
"only if they're requested.  (The technical term for this behaviour is "
"`lazy evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"이 함수는 결과를 반환하기 전에 메모리 내의 리스트를 구성하거나 모든 입력 이터레이터를 처리하지 않습니다; 대신 튜플은 요청된 "
"경우에만 생성하여 반환합니다. (이 동작의 전문 용어는 `느긋한 평가 "
"<https://en.wikipedia.org/wiki/Lazy_evaluation>`__ 입니다.)"

#: ../Doc/howto/functional.rst:723
msgid ""
"This iterator is intended to be used with iterables that are all of the "
"same length.  If the iterables are of different lengths, the resulting "
"stream will be the same length as the shortest iterable. ::"
msgstr ""
"이 이터레이터는 모두 같은 길이의 이터러블과 함께 사용하기 위한 것입니다. 이터러블의 길이가 다른 경우 결과 스트림은 가장 짧은 "
"이터러블과 같은 길이가 됩니다. ::"

#: ../Doc/howto/functional.rst:730
msgid ""
"You should avoid doing this, though, because an element may be taken from"
" the longer iterators and discarded.  This means you can't go on to use "
"the iterators further because you risk skipping a discarded element."
msgstr ""
"더 긴 이터레이터에서 나머지 요소는 버려질 수 있기 때문에 이런 방식은 피해야 합니다. 즉, 삭제된 요소를 건너뛸 위험이 있으므로 "
"이터레이터를 계속 사용할 수 없습니다."

#: ../Doc/howto/functional.rst:736
msgid "The itertools module"
msgstr "itertools 모듈"

#: ../Doc/howto/functional.rst:738
msgid ""
"The :mod:`itertools` module contains a number of commonly-used iterators "
"as well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
":mod:`itertools` 모듈은 공통적으로 사용되는 많은 이터레이터와 몇몇 이터레이터를 결합하기 위한 함수를 포함합니다. 이 "
"절에서는 작은 예제를 보여줌으로써 모듈의 내용을 소개합니다."

#: ../Doc/howto/functional.rst:742
msgid "The module's functions fall into a few broad classes:"
msgstr "모듈의 기능은 몇 가지 광범위한 클래스로 분류됩니다:"

#: ../Doc/howto/functional.rst:744
msgid "Functions that create a new iterator based on an existing iterator."
msgstr "기존 이터레이터를 기반으로 새로운 이터레이터를 만드는 함수."

#: ../Doc/howto/functional.rst:745
msgid "Functions for treating an iterator's elements as function arguments."
msgstr "이터레이터의 요소를 함수 인자로 처리하는 함수."

#: ../Doc/howto/functional.rst:746
msgid "Functions for selecting portions of an iterator's output."
msgstr "이터레이터의 출력 부분을 선택하는 함수."

#: ../Doc/howto/functional.rst:747
msgid "A function for grouping an iterator's output."
msgstr "이터레이터의 출력을 분류하는 함수."

#: ../Doc/howto/functional.rst:750
msgid "Creating new iterators"
msgstr "새로운 이터레이터 만들기"

#: ../Doc/howto/functional.rst:752
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an "
"infinite stream of evenly spaced values.  You can optionally supply the "
"starting number, which defaults to 0, and the interval between numbers, "
"which defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` 는 균등하게 간격을 둔 값들의 "
"무한한 스트림을 반환합니다. 선택적으로 기본값이 0인 시작 번호와 기본값이 1인 숫자 사이의 간격을 제공할 수 있습니다::"

#: ../Doc/howto/functional.rst:763
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the "
"contents of a provided iterable and returns a new iterator that returns "
"its elements from first to last.  The new iterator will repeat these "
"elements infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` 은 제공된 이터러블의 내용 사본을 저장하고 "
"처음부터 마지막까지 요소를 반환하는 새로운 이터레이터를 반환합니다. 새로운 이터레이터는 이러한 요소를 무한히 반복합니다. ::"

#: ../Doc/howto/functional.rst:770
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the "
"provided element *n* times, or returns the element endlessly if *n* is "
"not provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` 는 제공된 요소를 *n* 번 "
"반환하거나, *n* 이 제공되지 않으면 끝없이 요소를 반환합니다. ::"

#: ../Doc/howto/functional.rst:778
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of "
"the first iterator, then all the elements of the second, and so on, until"
" all of the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` 은 임의의 수의 "
"이터러블을 입력으로 취하여, 첫 번째 이터러블의 모든 요소를 반환한 다음 두 번째 요소의 모든 요소를 반환하고, 모든 이터러블이 다"
" 소모될 때까지 이 동작을 반복합니다. ::"

#: ../Doc/howto/functional.rst:786
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a "
"value for *step*, elements will be skipped accordingly.  Unlike Python's "
"string and list slicing, you can't use negative values for *start*, "
"*stop*, or *step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"는 이터레이터의 조각 스트림을 반환합니다. 단일 *stop* 인자를 사용하면 처음 *stop*\\개 요소가 반환됩니다. 시작 "
"인덱스를 지정하면 *stop-start* 요소가 생기고, *step* 에 값을 지정하면 요소는 그에 따라 생략됩니다. 파이썬의 "
"문자열 및 리스트 슬라이싱과 달리, *start*, *stop*, *step* 에 음수값을 사용할 수 없습니다. ::"

#: ../Doc/howto/functional.rst:800
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; "
"it returns *n* independent iterators that will all return the contents of"
" the source iterator. If you don't supply a value for *n*, the default is"
" 2.  Replicating iterators requires saving some of the contents of the "
"source iterator, so this can consume significant memory if the iterator "
"is large and one of the new iterators is consumed more than the others. "
"::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` 는 이터레이터를 복제합니다; 원본 "
"이터레이터의 내용을 모두 반환하는 *n* 개의 독립적인 이터레이터를 반환합니다. *n* 에 대한 값을 제공하지 않으면 기본값은 "
"2입니다. 이터레이터를 복제하려면 원본 이터레이터의 일부 내용을 저장해야 하므로 이터레이터가 크고 새로운 이터레이터 중 하나가 다른"
" 것보다 많이 소비된다면 이것은 상당한 메모리를 소비할 수 있습니다. ::"

#: ../Doc/howto/functional.rst:819
msgid "Calling functions on elements"
msgstr "요소에 대한 함수 호출"

#: ../Doc/howto/functional.rst:821
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) "
"<operator.add>` (adds two values), :func:`operator.ne(a, b)  "
"<operator.ne>` (same as ``a != b``), and :func:`operator.attrgetter('id')"
" <operator.attrgetter>` (returns a callable that fetches the ``.id`` "
"attribute)."
msgstr ""
":mod:`operator` 모듈은 파이썬의 연산자에 대응하는 함수 집합을 포함합니다. 예를 들어 "
":func:`operator.add(a, b) <operator.add>` (두 개의 값을 더하기), "
":func:`operator.ne(a, b) <operator.ne>` (``a != b`` 와 동일) 및 "
":func:`operator.attrgetter('id') <operator.attrgetter>` (``.id`` 어트리뷰트를 "
"가져오는 콜러블을 반환)와 같은 함수가 있습니다."

#: ../Doc/howto/functional.rst:827
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that "
"the iterable will return a stream of tuples, and calls *func* using these"
" tuples as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` 은 이터러블이 튜플의 "
"스트림을 반환할 것이라고 가정하고, 이 튜플을 인자로 사용하여 *func* 를 호출합니다::"

#: ../Doc/howto/functional.rst:839
msgid "Selecting elements"
msgstr "요소 선택하기"

#: ../Doc/howto/functional.rst:841
msgid ""
"Another group of functions chooses a subset of an iterator's elements "
"based on a predicate."
msgstr "또 다른 함수 모음은 서술자에 기초하여 이터러블 요소의 부분 집합을 선택합니다."

#: ../Doc/howto/functional.rst:844
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is"
" the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` 는 "
":func:`filter` 의 반대이며, predicate가 거짓을 반환하는 모든 요소를 반환합니다::"

#: ../Doc/howto/functional.rst:851
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` "
"returns elements for as long as the predicate returns true.  Once the "
"predicate returns false, the iterator will signal the end of its results."
" ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` 은 "
"predicate가 참을 반환하는 한, 요소를 반환합니다. predicate가 거짓을 반환하면 이터레이터는 결과의 종료를 알립니다."
" ::"

#: ../Doc/howto/functional.rst:864
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` "
"discards elements while the predicate returns true, and then returns the "
"rest of the iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` 은 "
"predicate가 참을 반환하는 동안 요소를 버리고, 나머지 이터러블의 결과를 반환합니다. ::"

#: ../Doc/howto/functional.rst:874
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes "
"two iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either "
"one is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` 는 두 개의 "
"이터레이터를 취하고 *selectors* 의 해당 요소가 참인 *data* 의 요소만을 반환하고, 한쪽이 고갈될 때마다 중단합니다::"

#: ../Doc/howto/functional.rst:883
msgid "Combinatoric functions"
msgstr "조합 함수"

#: ../Doc/howto/functional.rst:885
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` 는 "
"*iterable* 에 포함된 모든 요소의 가능한 *r*-튜플 조합을 제공하는 이터레이터를 반환합니다.  ::"

#: ../Doc/howto/functional.rst:900
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 "
"in the examples above.  A similar function, "
":func:`itertools.permutations(iterable, r=None) "
"<itertools.permutations>`, removes this constraint on the order, "
"returning all possible arrangements of length *r*::"
msgstr ""
"각 튜플 내의 원소들은 *iterable* 이 반환한 것과 같은 순서로 유지됩니다. 예를 들어 위의 예시에서 숫자 1은 항상 2, 3, 4"
" 또는 5 앞에 옵니다. 비슷한 함수인 :func:`itertools.permutations(iterable, r=None) "
"<itertools.permutations>` 은 제약 조건을 제거하여 길이 *r* 의 가능한 모든 순열을 반환합니다::"

#: ../Doc/howto/functional.rst:919
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr "*r* 에 값을 지정하지 않으면 이터러블의 길이가 사용됩니다. 즉, 모든 요소가 치환됩니다."

#: ../Doc/howto/functional.rst:922
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr "이 함수는 위치별로 가능한 모든 조합을 생성하며 *iterable* 의 내용이 고유해야 할 필요는 없습니다::"

#: ../Doc/howto/functional.rst:929
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr "같은 튜플 ``('a', 'a', 'b')`` 가 두 번 발생하지만, 두 개의 'a' 문자열은 다른 위치에서 왔습니다."

#: ../Doc/howto/functional.rst:932
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` function relaxes a different "
"constraint: elements can be repeated within a single tuple.  Conceptually"
" an element is selected for the first position of each tuple and then is "
"replaced before the second element is selected.  ::"
msgstr ""
":func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` 함수는 다른 제약을 완화합니다: 요소는 단일 튜플 "
"내에서 반복될 수 있습니다. 개념적으로 요소는 각 튜플의 첫 번째 위치에 대해 선택되고 두 번째 요소가 선택되기 전에 대체됩니다."
"  ::"

#: ../Doc/howto/functional.rst:947
msgid "Grouping elements"
msgstr "요소 분류"

#: ../Doc/howto/functional.rst:949
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, "
"the key is simply each element itself."
msgstr ""
"마지막으로 소개할 :func:`itertools.groupby(iter, key_func=None) "
"<itertools.groupby>` 함수는 가장 복잡합니다. ``key_func(elem)`` 는 이터러블에 의해 반환된 각 "
"요소에 대한 키값을 계산할 수 있는 함수입니다. 키 함수를 제공하지 않으면 키는 단순히 각 요소 자체입니다."

#: ../Doc/howto/functional.rst:954
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the"
" underlying iterable that have the same key value, and returns a stream "
"of 2-tuples containing a key value and an iterator for the elements with "
"that key."
msgstr ""
":func:`~itertools.groupby` 는 이터러블 내부에서 키값이 같은 연속된 모든 요소를 수집하여 키값과 해당 키를 "
"가진 요소의 이터러블을 포함하는 2-튜플의 스트림을 반환합니다."

#: ../Doc/howto/functional.rst:982
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's "
"contents will already be sorted based on the key.  Note that the returned"
" iterators also use the underlying iterable, so you have to consume the "
"results of iterator-1 before requesting iterator-2 and its corresponding "
"key."
msgstr ""
":func:`~itertools.groupby` 는 이터러블 내부의 내용이 키에 따라 이미 정렬되었다고 가정합니다. 반환된 "
"이터레이터 역시 이터러블 내부를 사용하므로 이터레이터-2와 해당 키를 요청하기 전에 이터레이터-1의 결과를 소진해야 합니다."

#: ../Doc/howto/functional.rst:989
msgid "The functools module"
msgstr "functools 모듈"

#: ../Doc/howto/functional.rst:991
msgid ""
"The :mod:`functools` module in Python 2.5 contains some higher-order "
"functions. A **higher-order function** takes one or more functions as "
"input and returns a new function.  The most useful tool in this module is"
" the :func:`functools.partial` function."
msgstr ""
"파이썬 2.5의 :mod:`functools` 모듈은 고차 함수를 포함하고 있습니다. **고차 함수** 는 하나 이상의 함수를 "
"입력으로 사용하고 새로운 함수를 반환합니다. 이 모듈에서 가장 유용한 도구는 :func:`functools.partial` "
"함수입니다."

#: ../Doc/howto/functional.rst:996
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters"
" filled in. Consider a Python function ``f(a, b, c)``; you may wish to "
"create a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; "
"you're filling in a value for one of ``f()``'s parameters.  This is "
"called \"partial function application\"."
msgstr ""
"함수형 방식으로 작성된 프로그램의 경우, 일부 매개 변수가 채워진 기존 함수의 변형이 필요한 경우가 있습니다. 파이썬 함수 "
"``f(a, b, c)`` 를 고려해보세요; 파이썬 함수인 ``f(1, b, c)`` 에 해당하는 새로운 함수 ``g(b, c)``"
" 를 만들 수 있습니다; 이를 \"부분적 함수 적용\" 이라고 합니다."

#: ../Doc/howto/functional.rst:1002
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke "
"``function`` with the filled-in arguments."
msgstr ""
":func:`~functools.partial` 의 생성자는 ``(function, arg1, arg2, ..., "
"kwarg1=value1, kwarg2=value2)`` 와 같은 인자를 취합니다. 결과 객체는 콜러블이므로, 채워진 인자로 "
"``function`` 을 실행하기 위해서는 결과 객체를 호출하면 됩니다."

#: ../Doc/howto/functional.rst:1007
msgid "Here's a small but realistic example::"
msgstr "작지만 현실적인 예가 있습니다::"

#: ../Doc/howto/functional.rst:1019
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a "
"function that takes two elements and returns a single value.  "
":func:`functools.reduce` takes the first two elements A and B returned by"
" the iterator and calculates ``func(A, B)``.  It then requests the third "
"element, C, calculates ``func(func(A, B), C)``, combines this result with"
" the fourth element returned, and continues until the iterable is "
"exhausted.  If the iterable returns no values at all, a :exc:`TypeError` "
"exception is raised.  If the initial value is supplied, it's used as a "
"starting point and ``func(initial_value, A)`` is the first calculation. "
"::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"는 모든 이터러블 요소에 대해 누적 연산을 수행하므로 무한 이터러블에 적용할 수 없습니다. *func* 는 두 요소를 사용하여 "
"하나의 값을 반환하는 함수이어야 합니다. :func:`functools.reduce` 는 이터레이터가 반환한 처음 두 요소 A와 "
"B를 취해 ``func(A, B)`` 를 계산합니다. 그다음 세 번째 요소인 C를 취해 ``func(func(A, B), C)`` "
"를 계산하고, 이 결과를 반환된 네 번째 요소와 결합해 이터러블이 소진될 때까지 계속합니다. 이터러블이 전혀 값을 반환하지 않으면 "
":exc:`TypeError` 예외가 발생합니다. 초기값이 제공되면 시작점으로 사용되며 ``func(initial_value, "
"A)`` 가 첫 번째로 계산됩니다. ::"

#: ../Doc/howto/functional.rst:1043
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add"
" up all the elements of the iterable.  This case is so common that "
"there's a special built-in called :func:`sum` to compute it:"
msgstr ""
":func:`operator.add` 를 :func:`functools.reduce` 와 함께 사용하면 이터러블의 모든 요소를 "
"합합니다. 이 경우는 매우 일반적이어서 이를 계산하기 위해 :func:`sum` 이라는 특수 내장 함수가 제공됩니다:"

#: ../Doc/howto/functional.rst:1055
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to "
"just write the obvious :keyword:`for` loop::"
msgstr ""
"그렇지만 :func:`functools.reduce` 를 사용하는 많은 경우에 명백하게 :keyword:`for` 루프만 작성하는 "
"것이 더 명확할 수 있습니다::"

#: ../Doc/howto/functional.rst:1067
msgid ""
"A related function is :func:`itertools.accumulate(iterable, "
"func=operator.add) <itertools.accumulate>`.  It performs the same "
"calculation, but instead of returning only the final result, "
":func:`accumulate` returns an iterator that also yields each partial "
"result::"
msgstr ""
"관련 함수는 :func:`itertools.accumulate(iterable, func=operator.add) "
"<itertools.accumulate>` 입니다. 같은 계산을 수행하지만, 최종 결과만 반환하는 대신 "
":func:`accumulate` 는 각 부분 결과를 반환하는 이터레이터를 반환합니다::"

#: ../Doc/howto/functional.rst:1080
msgid "The operator module"
msgstr "operator 모듈"

#: ../Doc/howto/functional.rst:1082
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often"
" useful in functional-style code because they save you from writing "
"trivial functions that perform a single operation."
msgstr ""
":mod:`operator` 모듈은 이전에 언급되었습니다. 여기에는 파이썬 연산자에 해당하는 함수 집합이 포함되어 있습니다. 단일 "
"연산을 수행하는 사소한 함수를 작성하지 않아도 되므로 이러한 함수는 함수형 방식 코드에서 유용합니다."

#: ../Doc/howto/functional.rst:1087
msgid "Some of the functions in this module are:"
msgstr "이 모듈의 몇몇 함수는 다음과 같습니다:"

#: ../Doc/howto/functional.rst:1089
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr "수학 연산: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, ``abs()``, ..."

#: ../Doc/howto/functional.rst:1090
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr "논리 연산: ``not_()``, ``truth()``."

#: ../Doc/howto/functional.rst:1091
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr "비트 연산: ``and_()``, ``or_()``, ``invert()``."

#: ../Doc/howto/functional.rst:1092
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and "
"``ge()``."
msgstr "비교: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, ``ge()``."

#: ../Doc/howto/functional.rst:1093
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr "객체 아이덴티티: ``is_()``, ``is_not()``."

#: ../Doc/howto/functional.rst:1095
msgid "Consult the operator module's documentation for a complete list."
msgstr "전체 목록은 연산자 모듈의 문서를 참고하세요."

#: ../Doc/howto/functional.rst:1099
msgid "Small functions and the lambda expression"
msgstr "작은 함수와 람다 표현식"

#: ../Doc/howto/functional.rst:1101
msgid ""
"When writing functional-style programs, you'll often need little "
"functions that act as predicates or that combine elements in some way."
msgstr "함수형 방식의 프로그램을 작성할 때, 서술자로 동작하거나 어떤 식으로든 요소를 결합하는 작은 함수가 필요할 것입니다."

#: ../Doc/howto/functional.rst:1104
msgid ""
"If there's a Python built-in or a module function that's suitable, you "
"don't need to define a new function at all::"
msgstr "파이썬 내장 함수나 적당한 모듈 함수가 있다면, 새로운 함수를 정의할 필요가 전혀 없습니다::"

#: ../Doc/howto/functional.rst:1110
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to"
" write small functions is to use the :keyword:`lambda` statement.  "
"``lambda`` takes a number of parameters and an expression combining these"
" parameters, and creates an anonymous function that returns the value of "
"the expression::"
msgstr ""
"필요한 기능이 없다면 작성해야 합니다. 작은 함수를 작성하는 한 가지 방법은 :keyword:`lambda` 문을 사용하는 "
"것입니다. ``lambda`` 는 여러 매개 변수와 이들 매개 변수를 결합하는 표현식을 취해 표현식의 값을 반환하는 익명의 함수를 "
"만듭니다::"

#: ../Doc/howto/functional.rst:1119
msgid ""
"An alternative is to just use the ``def`` statement and define a function"
" in the usual way::"
msgstr "다른 방법은 ``def`` 문을 사용하고 일반적인 방식으로 함수를 정의하는 것입니다::"

#: ../Doc/howto/functional.rst:1128
msgid ""
"Which alternative is preferable?  That's a style question; my usual "
"course is to avoid using ``lambda``."
msgstr ""
"어떤 대안이 바람직할까요? 이것은 스타일에 대한 질문입니다; 필자가 평소에 사용하는 방법은 ``lambda`` 사용을 피하는 "
"것입니다."

#: ../Doc/howto/functional.rst:1131
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much "
"in a ``lambda`` statement, you'll end up with an overly complicated "
"expression that's hard to read.  Quick, what's the following code doing? "
"::"
msgstr ""
"필자가 선호하는 방식에 대한 이유 중 하나는 ``lambda`` 가 정의할 수 있는 함수가 상당히 제한적이기 때문입니다. 결과는 "
"단일 표현식으로 계산할 수 있어야 합니다. 즉, ``if... elif... else`` 비교 또는 ``try... except``"
" 문을 가질 수 없습니다. ``lambda`` 문에서 너무 많은 것을 하려고 하면, 읽기 어려운 복잡한 표현으로 끝날 것입니다. "
"다음 코드가 무엇을 하는지 빠르게 알아보세요. ::"

#: ../Doc/howto/functional.rst:1141
msgid ""
"You can figure it out, but it takes time to disentangle the expression to"
" figure out what's going on.  Using a short nested ``def`` statements "
"makes things a little bit better::"
msgstr ""
"여러분은 이해할 수 있지만, 어떻게 동작하는지 이해하기 위해 표현식을 풀어내는 데 시간이 걸립니다. 짧게 중첩된 ``def`` 문을"
" 사용하면 좀 더 나은 것을 만들 수 있습니다::"

#: ../Doc/howto/functional.rst:1151
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr "그러나 단순히 ``for`` 루프를 사용했다면 가장 좋았을 것입니다::"

#: ../Doc/howto/functional.rst:1157
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr "혹은 :func:`sum` 내장 함수와 제너레이터 표현식이었어도 좋았을 것입니다::"

#: ../Doc/howto/functional.rst:1161
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for``"
" loops."
msgstr ":func:`functools.reduce` 를 사용하는 많은 경우, ``for`` 루프로 작성했을 때 더 명확합니다."

#: ../Doc/howto/functional.rst:1163
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring "
"uses of ``lambda``:"
msgstr "Fredrik Lundh는 한때 ``lambda`` 사용법의 리팩토링을 위해 다음과 같은 규칙 집합을 제안했습니다:"

#: ../Doc/howto/functional.rst:1166
msgid "Write a lambda function."
msgstr "람다 함수를 작성하세요."

#: ../Doc/howto/functional.rst:1167
msgid "Write a comment explaining what the heck that lambda does."
msgstr "람다가 하는 일에 관해 설명하는 글을 쓰세요."

#: ../Doc/howto/functional.rst:1168
msgid ""
"Study the comment for a while, and think of a name that captures the "
"essence of the comment."
msgstr "잠깐 설명을 검토하고 설명의 본질을 포착하는 이름을 생각해보세요."

#: ../Doc/howto/functional.rst:1170
msgid "Convert the lambda to a def statement, using that name."
msgstr "해당 이름을 사용하여 람다를 def 문으로 변환합니다."

#: ../Doc/howto/functional.rst:1171
msgid "Remove the comment."
msgstr "설명을 삭제하세요."

#: ../Doc/howto/functional.rst:1173
msgid ""
"I really like these rules, but you're free to disagree about whether this"
" lambda-free style is better."
msgstr "필자는 이 규칙을 정말 좋아하지만, 여러분은 이렇게 람다가 없는 방식이 더 나은지에 대해 동의하지 않을 수 있습니다."

#: ../Doc/howto/functional.rst:1178
msgid "Revision History and Acknowledgements"
msgstr "개정내역 및 감사의 글"

#: ../Doc/howto/functional.rst:1180
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this "
"article: Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim "
"Jewett, Mike Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake "
"Winton."
msgstr ""
"필자는 이 글의 다양한 초안을 제안하고 수정하고 도와준 다음 사람들에게 감사하고 싶습니다: Ian Bicking, Nick "
"Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, Mike Krell, Leandro "
"Lameiro, Jussi Salmela, Collin Winter, Blake Winton."

#: ../Doc/howto/functional.rst:1185
msgid "Version 0.1: posted June 30 2006."
msgstr "버전 0.1: 2006년 6월 30일 게시."

#: ../Doc/howto/functional.rst:1187
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "버전 0.11: 2006년 7월 1일 게시. 오타 수정."

#: ../Doc/howto/functional.rst:1189
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections "
"into one. Typo fixes."
msgstr "버전 0.2: 2006년 7월 10일 게시. 제너레이터 표현식과 리스트 컴프리헨션 섹션을 하나로 통합. 오타 수정."

#: ../Doc/howto/functional.rst:1192
msgid "Version 0.21: Added more references suggested on the tutor mailing list."
msgstr "버전 0.21: 튜터 메일링 리스트에서 추천된 참고 문헌을 추가."

#: ../Doc/howto/functional.rst:1194
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by "
"Collin Winter; adds short section on the operator module; a few other "
"edits."
msgstr ""
"버전 0.30: Collin Winter가 작성한 ``functional`` 모듈에 대한 섹션 추가; 연산자 모듈에 대한 짧은 섹션"
" 추가; 몇 가지 다른 편집."

#: ../Doc/howto/functional.rst:1199
msgid "References"
msgstr "참고 문헌"

#: ../Doc/howto/functional.rst:1202
msgid "General"
msgstr "일반"

#: ../Doc/howto/functional.rst:1204
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson "
"and Gerald Jay Sussman with Julie Sussman.  Full text at "
"https://mitpress.mit.edu/sicp/.  In this classic textbook of computer "
"science, chapters 2 and 3 discuss the use of sequences and streams to "
"organize the data flow inside a program.  The book uses Scheme for its "
"examples, but many of the design approaches described in these chapters "
"are applicable to functional-style Python code."
msgstr ""
"Harold Abelson과 Gerald Jay Sussman, Julie Sussman의 **Structure and "
"Interpretation of Computer Programs**. 전체 문서는 "
"https://mitpress.mit.edu/sicp/ 에 있습니다. 이 고전적인 컴퓨터 과학 교과서에서 2장과 3장은 프로그램 "
"내에서 데이터 흐름을 구성하기 위해 시퀀스와 스트림을 사용하는 방법을 설명합니다. 이 책은 스킴(Scheme)을 예제로 사용하지만,"
" 이 장에서 설명한 디자인 방식 중 상당수는 함수형 방식 파이썬 코드에 적용할 수 있습니다."

#: ../Doc/howto/functional.rst:1212
msgid ""
"http://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy "
"historical introduction."
msgstr ""
"http://www.defmacro.org/ramblings/fp.html: 오랜 역사적 소개와 함께 자바 예제를 사용한 함수형 "
"프로그래밍에 대한 일반적인 개론."

#: ../Doc/howto/functional.rst:1215
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: 함수형 프로그래밍을 설명하는 일반 "
"위키피디아 항목."

#: ../Doc/howto/functional.rst:1218
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr "https://en.wikipedia.org/wiki/Coroutine: 코루틴에 대한 항목."

#: ../Doc/howto/functional.rst:1220
msgid "https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr "https://en.wikipedia.org/wiki/Currying: 커링 개념에 대한 항목."

#: ../Doc/howto/functional.rst:1223
msgid "Python-specific"
msgstr "파이썬 특정"

#: ../Doc/howto/functional.rst:1225
msgid ""
"http://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming "
"for text processing, in the section titled \"Utilizing Higher-Order "
"Functions in Text Processing\"."
msgstr ""
"http://gnosis.cx/TPiP/: David Mertz의 책 :title-reference:`Text Processing "
"in Python` 의 첫 번째 장에서는 \"Utilizing Higher-Order Functions in Text "
"Processing\" 절에서 텍스트 처리를 위한 함수형 프로그래밍에 관해 설명합니다."

#: ../Doc/howto/functional.rst:1230
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming "
"for IBM's DeveloperWorks site; see `part 1 "
"<https://www.ibm.com/developerworks/linux/library/l-prog/index.html>`__, "
"`part 2 "
"<https://www.ibm.com/developerworks/linux/library/l-prog2/index.html>`__,"
" and `part 3 "
"<https://www.ibm.com/developerworks/linux/library/l-prog3/index.html>`__,"
msgstr ""
"Mertz는 또한 IBM의 DeveloperWorks 사이트에서 함수형 프로그래밍 기사 시리즈 3부작을 작성했습니다; `part 1"
" <https://www.ibm.com/developerworks/linux/library/l-prog/index.html>`__,"
" `part 2 "
"<https://www.ibm.com/developerworks/linux/library/l-prog2/index.html>`__,"
" `part 3 "
"<https://www.ibm.com/developerworks/linux/library/l-prog3/index.html>`__,"

#: ../Doc/howto/functional.rst:1238
msgid "Python documentation"
msgstr "파이썬 설명서"

#: ../Doc/howto/functional.rst:1240
msgid "Documentation for the :mod:`itertools` module."
msgstr ":mod:`itertools` 모듈에 대한 설명서"

#: ../Doc/howto/functional.rst:1242
msgid "Documentation for the :mod:`functools` module."
msgstr ":mod:`functools` 모듈에 대한 설명서"

#: ../Doc/howto/functional.rst:1244
msgid "Documentation for the :mod:`operator` module."
msgstr ":mod:`operator` 모듈에 대한 설명서"

#: ../Doc/howto/functional.rst:1246
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"제너레이터 표현식\""

#: ../Doc/howto/functional.rst:1248
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ":pep:`342`: \"개선된 제너레이터를 통한 코루틴\" 은 파이썬 2.5의 새로운 제너레이터 기능을 설명합니다."

#~ msgid ""
#~ "Note that the order is essentially "
#~ "random, because it's based on the "
#~ "hash ordering of the objects in "
#~ "the dictionary."
#~ msgstr "딕셔너리 내에 있는 객체의 해시 순서에 기반하기 때문에 순서는 기본적으로 무작위입니다."

