# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: 2018-05-16 22:54+0900\n"
"Last-Translator: SeomGi, Han <iandmyhand@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/howto/functional.rst:3
msgid "Functional Programming HOWTO"
msgstr "함수형 프로그래밍 입문서"

#: ../Doc/howto/functional.rst
msgid "Author"
msgstr "저자"

#: ../Doc/howto/functional.rst:5
msgid "A. M. Kuchling"
msgstr ""

#: ../Doc/howto/functional.rst
msgid "Release"
msgstr ""

#: ../Doc/howto/functional.rst:6
msgid "0.32"
msgstr ""

#: ../Doc/howto/functional.rst:8
msgid ""
"In this document, we'll take a tour of Python's features suitable for "
"implementing programs in a functional style.  After an introduction to "
"the concepts of functional programming, we'll look at language features "
"such as :term:`iterator`\\s and :term:`generator`\\s and relevant library"
" modules such as :mod:`itertools` and :mod:`functools`."
msgstr ""
"이 문서에서는, 함수형 방식으로 프로그램을 구현하는데 적합한 파이썬의 특성에 대해 알아볼 것입니다. "
"함수형 프로그래밍의 개념을 소개한 뒤에, :term:`이터레이터 <iterator>` , "
":term:`제너레이터 <generator>` 와 같은 언어의 특성과 :mod:`itertools` , "
":mod:`functools` 와 같은 관련 라이브러리 모듈을 살펴볼 것입니다."

#: ../Doc/howto/functional.rst:16
msgid "Introduction"
msgstr "소개"

#: ../Doc/howto/functional.rst:18
msgid ""
"This section explains the basic concept of functional programming; if "
"you're just interested in learning about Python language features, skip "
"to the next section on :ref:`functional-howto-iterators`."
msgstr ""
"이 절에서는 함수형 프로그래밍의 기본적인 개념을 설명합니다. 만약 단순히 파이썬의 언어적 특성에 "
"관해서만 관심이 있으시다면, :ref:`functional-howto-iterators` 절로 건너뛰세요."

#: ../Doc/howto/functional.rst:22
msgid ""
"Programming languages support decomposing problems in several different "
"ways:"
msgstr ""
"프로그래밍 언어들은 다음과 같이 각각 다른 방식으로 문제를 더 작은 부분으로 분할하는 방법을 "
"지원합니다."

#: ../Doc/howto/functional.rst:24
msgid ""
"Most programming languages are **procedural**: programs are lists of "
"instructions that tell the computer what to do with the program's input."
"  C, Pascal, and even Unix shells are procedural languages."
msgstr ""
"대부분의 프로그래밍 언어들은 **절차적** 입니다. 프로그램은 컴퓨터에 프로그램의 입력을 어떻게 "
"할지 알려주는 명령 목록입니다. C, 파스칼, 유닉스 셸과 같은 것들은 절차적 언어입니다."

#: ../Doc/howto/functional.rst:28
msgid ""
"In **declarative** languages, you write a specification that describes "
"the problem to be solved, and the language implementation figures out how"
" to perform the computation efficiently.  SQL is the declarative language"
" you're most likely to be familiar with; a SQL query describes the data "
"set you want to retrieve, and the SQL engine decides whether to scan "
"tables or use indexes, which subclauses should be performed first, etc."
msgstr ""
"**선언적** 언어에서는 해결해야 할 문제를 설명하는 명세서를 작성하고, 언어 구현은 계산을 "
"효과적으로 수행하는 방법을 파악합니다. SQL은 가장 친숙한 선언적 언어입니다. SQL 질의는 검색하고 "
"싶은 데이터 세트를 설명하고, SQL 엔진은 테이블을 스캔하거나 인덱스를 사용할 것인지, 어떤 하위 "
"구문을 먼저 수행해야 하는지 등을 결정합니다."

#: ../Doc/howto/functional.rst:35
msgid ""
"**Object-oriented** programs manipulate collections of objects.  Objects "
"have internal state and support methods that query or modify this "
"internal state in some way. Smalltalk and Java are object-oriented "
"languages.  C++ and Python are languages that support object-oriented "
"programming, but don't force the use of object-oriented features."
msgstr ""
"**객체지향** 프로그램은 객체들의 컬렉션을 다룹니다. 객체는 내부적인 상태를 갖고 있으며 이 "
"내부적인 상태를 어떤 방식으로 가져오거나 수정하는 메서드를 제공합니다. 스몰토크와 자바는 객체지향 "
"언어입니다. C++ 와 파이썬은 객체지향 프로그래밍을 지원하는 언어이지만, 객체 지향적인 특성들을 "
"사용하도록 강제하지는 않습니다."

#: ../Doc/howto/functional.rst:41
msgid ""
"**Functional** programming decomposes a problem into a set of functions. "
"Ideally, functions only take inputs and produce outputs, and don't have "
"any internal state that affects the output produced for a given input.  "
"Well-known functional languages include the ML family (Standard ML, "
"OCaml, and other variants) and Haskell."
msgstr ""
"**함수형** 프로그래밍은 함수들의 세트로 문제를 분해합니다. 이상적으로 말하면, 함수들은 입력을 "
"받아서 출력을 만들어내기만 하며, 주어진 입력에 대해 생성된 출력에 영향을 끼칠만한 어떠한 내부적인 "
"상태도 가지지 않습니다. 잘 알려진 함수형 언어로는 ML 계열(Standard ML, OCaml 및 다른 "
"변형)과 하스켈이 있습니다."

#: ../Doc/howto/functional.rst:47
msgid ""
"The designers of some computer languages choose to emphasize one "
"particular approach to programming.  This often makes it difficult to "
"write programs that use a different approach.  Other languages are multi-"
"paradigm languages that support several different approaches. Lisp, C++, "
"and Python are multi-paradigm; you can write programs or libraries that "
"are largely procedural, object-oriented, or functional in all of these "
"languages.  In a large program, different sections might be written using"
" different approaches; the GUI might be object-oriented while the "
"processing logic is procedural or functional, for example."
msgstr ""
"일부 컴퓨터 언어의 설계자들은 프로그래밍에 대한 한 가지의 특별한 접근 방식을 강조합니다. 이것은 "
"종종 다른 접근 방식으로 프로그램을 작성하는 것을 어렵게 만듭니다. 다른 언어들은 다양한 접근 방법을 "
"지원하는 다중 패러다임 언어입니다. Lisp, C++, 파이썬 등은 다중 패러다임 언어입니다. 이러한 "
"언어에서는 절차적, 객체 지향적 혹은 함수형으로 프로그램이나 라이브러리를 작성할 수 있습니다. "
"거대한 프로그램에서, 각 구역은 서로 다른 접근 방법을 사용하여 작성될 수 있습니다. 예를 들어 처리 "
"로직이 절차적 혹은 함수형으로 작성되었을 때, GUI는 객체 지향적으로 작성될 수 있습니다."

#: ../Doc/howto/functional.rst:58
msgid ""
"In a functional program, input flows through a set of functions. Each "
"function operates on its input and produces some output.  Functional "
"style discourages functions with side effects that modify internal state "
"or make other changes that aren't visible in the function's return value."
"  Functions that have no side effects at all are called **purely "
"functional**.  Avoiding side effects means not using data structures that"
" get updated as a program runs; every function's output must only depend "
"on its input."
msgstr ""
"함수형 프로그램에서, 입력은 여러 함수의 세트를 통해 흘러 다닙니다. 각 함수는 입력으로부터 동작해서 "
"출력을 만들어냅니다. 함수형 방식은 내부 상태를 수정하거나 함수의 반환 값에서 보이지 않는 다른 "
"변경사항들을 만드는 부작용이 있는 함수를 사용하지 않습니다. 부작용이 전혀 없는 함수를 "
"**순수 함수** 라고 합니다. 부작용을 피한다는 것은 프로그램이 실행될 때 수정될 수 있는 자료 구조를 "
"사용하지 않는다는 의미입니다. 모든 함수의 출력은 입력에만 의존해야 합니다."

#: ../Doc/howto/functional.rst:66
msgid ""
"Some languages are very strict about purity and don't even have "
"assignment statements such as ``a=3`` or ``c = a + b``, but it's "
"difficult to avoid all side effects.  Printing to the screen or writing "
"to a disk file are side effects, for example.  For example, in Python a "
"call to the :func:`print` or :func:`time.sleep` function both return no "
"useful value; they're only called for their side effects of sending some "
"text to the screen or pausing execution for a second."
msgstr ""
"어떤 언어는 순수성에 대해 매우 엄격하며, ``a=3`` 혹은 ``c = a + b`` 와 같은 대입문조차 "
"없지만, 모든 부작용을 피하는 것은 어렵습니다. 화면에 출력하거나 디스크 파일에 쓰는 작업은 부작용을 "
"만들어낼 수 있습니다. 예를 들어, 파이썬에서 :func:`print` 혹은 :func:`time.sleep` "
"함수를 호출하면 의미 없는 값을 반환합니다. 이 함수들은 화면에 문자열을 보내거나 잠시 동안 실행을 "
"일시 중지하는 작업과 같은 부작용을 호출할 뿐입니다."

#: ../Doc/howto/functional.rst:74
msgid ""
"Python programs written in functional style usually won't go to the "
"extreme of avoiding all I/O or all assignments; instead, they'll provide "
"a functional-appearing interface but will use non-functional features "
"internally. For example, the implementation of a function will still use "
"assignments to local variables, but won't modify global variables or have"
" other side effects."
msgstr ""
"함수형 방식으로 작성된 파이썬 프로그램은 보통 극단적으로 모든 I/O 혹은 대입문을 회피하는 방식으로 "
"나아가지는 않습니다. 대신 함수형처럼 보이는 인터페이스를 제공하며 내부적으로는 함수형이 아닌 "
"기능들을 사용합니다. 예를 들어 함수의 구현은 여전히 지역 변수에 값을 할당하는 방식이 사용되지만 "
"전역 변수를 수정하거나 다른 부작용을 발생시키지는 않습니다."

#: ../Doc/howto/functional.rst:80
msgid ""
"Functional programming can be considered the opposite of object-oriented "
"programming.  Objects are little capsules containing some internal state "
"along with a collection of method calls that let you modify this state, "
"and programs consist of making the right set of state changes.  "
"Functional programming wants to avoid state changes as much as possible "
"and works with data flowing between functions.  In Python you might "
"combine the two approaches by writing functions that take and return "
"instances representing objects in your application (e-mail messages, "
"transactions, etc.)."
msgstr ""
"함수형 프로그래밍은 객체 지향 프로그래밍의 반대라고 생각할 수 있습니다. 객체는 내부 상태들을 갖고 "
"있으며 이 상태들을 수정할 수 있는 메서드의 호출 모음이 포함된 작은 캡슐이며, 프로그램은 올바른 "
"상태 변경 집합을 구성합니다. 함수형 프로그래밍은 가능한 한 상태 변경을 피하고자 하며 함수 간의 "
"데이터 흐름을 사용합니다. 파이썬에서는 응용 프로그램의 객체를 나타내는 인스턴스(이메일 메시지, "
"트랜잭션 등)를 가져와서 반환하는 함수를 작성함으로써 두 가지 접근 방식을 결합할 수 있습니다."

#: ../Doc/howto/functional.rst:89
msgid ""
"Functional design may seem like an odd constraint to work under.  Why "
"should you avoid objects and side effects?  There are theoretical and "
"practical advantages to the functional style:"
msgstr ""
"함수형 설계는 동작 방식에 이상한 제약이 있는 것처럼 보일 수 있습니다. 왜 객체와 부작용을 "
"피해야만 할까요? 함수형 방식은 이론적으로도, 실질적으로도 다음과 같은 장점이 있습니다."

#: ../Doc/howto/functional.rst:93
msgid "Formal provability."
msgstr "공식적인 증명."

#: ../Doc/howto/functional.rst:94
msgid "Modularity."
msgstr "모듈성."

#: ../Doc/howto/functional.rst:95
msgid "Composability."
msgstr "결합성."

#: ../Doc/howto/functional.rst:96
msgid "Ease of debugging and testing."
msgstr "디버깅과 테스트 용이성."

#: ../Doc/howto/functional.rst:100
msgid "Formal provability"
msgstr "공식적인 증명"

#: ../Doc/howto/functional.rst:102
msgid ""
"A theoretical benefit is that it's easier to construct a mathematical "
"proof that a functional program is correct."
msgstr ""
"이론적인 장점은 함수형 프로그램이 정확하다는 수학적 증명을 만드는 것이 더 쉽다는 것입니다."

#: ../Doc/howto/functional.rst:105
msgid ""
"For a long time researchers have been interested in finding ways to "
"mathematically prove programs correct.  This is different from testing a "
"program on numerous inputs and concluding that its output is usually "
"correct, or reading a program's source code and concluding that the code "
"looks right; the goal is instead a rigorous proof that a program produces"
" the right result for all possible inputs."
msgstr ""
"오랫동안 연구자들은 수학적으로 프로그램이 정확하다는 것을 증명하는 방법을 찾는 데 관심을 "
"보여왔습니다. 이것은 수많은 입력에 대해 프로그램을 테스트하고 출력이 정확하다고 결론짓거나, "
"프로그램의 소스코드를 읽어보고 코드가 올바르다고 결론짓는 것과는 다릅니다. 그들의 목표는 입력 "
"가능한 모든 것에 대해 프로그램이 올바른 결과를 산출한다는 엄격한 증거를 찾는 것입니다."

#: ../Doc/howto/functional.rst:112
msgid ""
"The technique used to prove programs correct is to write down "
"**invariants**, properties of the input data and of the program's "
"variables that are always true.  For each line of code, you then show "
"that if invariants X and Y are true **before** the line is executed, the "
"slightly different invariants X' and Y' are true **after** the line is "
"executed.  This continues until you reach the end of the program, at "
"which point the invariants should match the desired conditions on the "
"program's output."
msgstr ""
"프로그램이 올바른지 증명하기 위해 사용하는 기술은 항상 참인 **불변 변수**, 입력 데이터의 특성, "
"프로그램의 변수의 특성을 작성하는 것입니다. 각 코드 행에 대해, 그 행이 실행되기 **전에** 불변 "
"변수 X와 Y가 참이라면, 그 행이 실행된 **후에** 약간 다른 불변 변수 X' 및 Y'가 참이라는 것을 "
"보여줍니다. 이 작업은 프로그램이 종료될 때까지 계속되며, 종료 시점에서 불변 변수는 프로그램의 "
"출력으로써 원하는 조건과 일치해야만 합니다."

#: ../Doc/howto/functional.rst:120
msgid ""
"Functional programming's avoidance of assignments arose because "
"assignments are difficult to handle with this technique; assignments can "
"break invariants that were true before the assignment without producing "
"any new invariants that can be propagated onward."
msgstr ""
"함수형 프로그래밍에서 값 할당을 피하려는 이유는 값 할당이 이러한 기법을 활용하는 것을 어렵게 "
"만들기 때문입니다. 값 할당은, 전달이 가능한 새로운 불변 변수를 만들어내지 않는 값 할당 이전에 "
"불변 변수가 참이었다는 점을 무너뜨릴 수 있습니다."

#: ../Doc/howto/functional.rst:125
msgid ""
"Unfortunately, proving programs correct is largely impractical and not "
"relevant to Python software. Even trivial programs require proofs that "
"are several pages long; the proof of correctness for a moderately "
"complicated program would be enormous, and few or none of the programs "
"you use daily (the Python interpreter, your XML parser, your web browser)"
" could be proven correct.  Even if you wrote down or generated a proof, "
"there would then be the question of verifying the proof; maybe there's an"
" error in it, and you wrongly believe you've proved the program correct."
msgstr ""
"불행하게도, 정확한 프로그램임을 증명하는 것은 실제로는 비실용적이며 파이썬 소프트웨어와 관련이 "
"없습니다. 사소한 프로그램일지라도 여러 페이지 분량의 증명이 필요합니다. 적당히 복잡한 프로그램에 "
"대한 정확성의 증명은 엄청난 양일 것이며, 매일 사용하는 프로그램 (파이썬 인터프리터, XML 파서, "
"웹 브라우저)의 정확성은 거의 증명이 불가능할 수도 있습니다. 만약 증명을 작성하거나 만들었더라도, "
"그 증명이 검증된 것인지 의구심이 들 것입니다. 어쩌면 그 증명에 오류가 있을 수도 있고, 프로그램의 "
"정확성이 증명되었다고 잘못 믿고 있을 수도 있습니다."

#: ../Doc/howto/functional.rst:136
msgid "Modularity"
msgstr "모듈성"

#: ../Doc/howto/functional.rst:138
msgid ""
"A more practical benefit of functional programming is that it forces you "
"to break apart your problem into small pieces.  Programs are more modular"
" as a result.  It's easier to specify and write a small function that "
"does one thing than a large function that performs a complicated "
"transformation.  Small functions are also easier to read and to check for"
" errors."
msgstr ""
"함수형 프로그래밍의 실질적인 이점은 문제를 작은 조각으로 분해하도록 강제한다는 점입니다. 결과적으로 "
"프로그램은 더욱 모듈화가 됩니다. 복잡한 변환을 수행하는 거대한 함수보다, 한 가지 작업을 수행하는 "
"작은 함수를 명시하고 작성하기가 더 쉽습니다. 작은 함수는 읽기에도 더 쉽고 오류를 확인하기도 "
"쉽습니다."

#: ../Doc/howto/functional.rst:146
msgid "Ease of debugging and testing"
msgstr "디버깅과 테스트 용이성"

#: ../Doc/howto/functional.rst:148
msgid "Testing and debugging a functional-style program is easier."
msgstr "함수형 방식 프로그램은 테스트하고 디버깅하는 것이 더 쉽습니다."

#: ../Doc/howto/functional.rst:150
msgid ""
"Debugging is simplified because functions are generally small and clearly"
" specified.  When a program doesn't work, each function is an interface "
"point where you can check that the data are correct.  You can look at the"
" intermediate inputs and outputs to quickly isolate the function that's "
"responsible for a bug."
msgstr ""
"일반적으로 함수가 작고 분명하게 명시되기 때문에 디버깅이 단순화됩니다. 프로그램이 동작하지 "
"않는다면, 각 함수는 데이터가 올바른지 확인할 수 있는 접점이 됩니다. 중간 지점의 입력과 출력을 "
"살펴보면 버그가 있는 함수를 빠르게 분간할 수 있습니다."

#: ../Doc/howto/functional.rst:155
msgid ""
"Testing is easier because each function is a potential subject for a unit"
" test. Functions don't depend on system state that needs to be replicated"
" before running a test; instead you only have to synthesize the right "
"input and then check that the output matches expectations."
msgstr ""
"각 함수는 잠재적으로 단위 테스트의 대상이기 때문에 테스트가 더 쉽습니다. 함수는 테스트를 실행하기 "
"전에 복제해야 하는 시스템 상태에 의존하지 않습니다. 올바른 입력에 집중하고 결과가 예상과 "
"일치하는지 확인만 하면 됩니다."

#: ../Doc/howto/functional.rst:162
msgid "Composability"
msgstr "결합성"

#: ../Doc/howto/functional.rst:164
msgid ""
"As you work on a functional-style program, you'll write a number of "
"functions with varying inputs and outputs.  Some of these functions will "
"be unavoidably specialized to a particular application, but others will "
"be useful in a wide variety of programs.  For example, a function that "
"takes a directory path and returns all the XML files in the directory, or"
" a function that takes a filename and returns its contents, can be "
"applied to many different situations."
msgstr ""
"함수형 방식의 프로그램을 만들 때, 다양한 입력과 출력으로 여러 가지 함수를 작성하게 됩니다. 이러한 "
"함수 중 일부는 불가피하게 특정 응용 프로그램에 특화될 수 있지만, 대체로 다양한 프로그램에서 "
"유용하게 사용할 수 있습니다. 예를 들어 디렉토리 경로를 받아서 그 디렉토리 내의 모든 XML 파일을 "
"반환하는 함수나, 혹은 파일명을 받아서 그 내용을 반환하는 함수는 다양한 상황에 적용할 수 있습니다."

#: ../Doc/howto/functional.rst:171
msgid ""
"Over time you'll form a personal library of utilities.  Often you'll "
"assemble new programs by arranging existing functions in a new "
"configuration and writing a few functions specialized for the current "
"task."
msgstr ""
"시간이 흐르면, 여러분은 개인적인 유틸리티 라이브러리를 구성하게 될 것입니다. 보통, 새로운 "
"구성으로 기존 함수를 배치하고 현재 작업에 특화된 몇 가지 기능만을 작성해서 새로운 프로그램을 "
"구성하게 됩니다."

#: ../Doc/howto/functional.rst:179
msgid "Iterators"
msgstr "이터레이터"

#: ../Doc/howto/functional.rst:181
msgid ""
"I'll start by looking at a Python language feature that's an important "
"foundation for writing functional-style programs: iterators."
msgstr ""
"함수형 방식의 프로그램을 작성하는 중요한 토대가 되는 파이썬 언어의 이터레이터라는 "
"기능을 살펴보겠습니다."

#: ../Doc/howto/functional.rst:184
msgid ""
"An iterator is an object representing a stream of data; this object "
"returns the data one element at a time.  A Python iterator must support a"
" method called :meth:`~iterator.__next__` that takes no arguments and "
"always returns the next element of the stream.  If there are no more "
"elements in the stream, :meth:`~iterator.__next__` must raise the "
":exc:`StopIteration` exception. Iterators don't have to be finite, "
"though; it's perfectly reasonable to write an iterator that produces an "
"infinite stream of data."
msgstr ""
"이터레이터는 데이터 스트림을 나타내는 객체입니다. 이 객체는 한 번에 한 요소씩 데이터를 반환합니다. "
"파이썬 이터레이터는 반드시 :meth:`~iterator.__next__` 라는 메서드를 지원해야 합니다. 이 "
"메서드는 인수를 취하지 않고 항상 스트림의 다음 요소를 반환합니다. 만약 스트림에 더는 요소가 "
"없다면, :meth:`~iterator.__next__` 는 :exc:`StopIteration` 예외를 발생시켜야 "
"합니다. 이터레이터가 유한할 필요는 없습니다. 무한한 데이터 스트림을 생성하는 이터레이터를 작성하는 "
"것도 합리적인 방법입니다."

#: ../Doc/howto/functional.rst:192
msgid ""
"The built-in :func:`iter` function takes an arbitrary object and tries to"
" return an iterator that will return the object's contents or elements, "
"raising :exc:`TypeError` if the object doesn't support iteration.  "
"Several of Python's built-in data types support iteration, the most "
"common being lists and dictionaries.  An object is called "
":term:`iterable` if you can get an iterator for it."
msgstr ""
"내장 함수 :func:`iter` 는 임의의 객체를 취하여 객체의 내용이나 요소를 반환하는 이터레이터를 "
"반환합니다. 객체가 이터레이션을 지원하지 않으면 :exc:`TypeError` 를 발생시킵니다. 파이썬의 "
"내장 데이터 유형 중 일부는 가장 일반적인 리스트이자 딕셔너리인 이터레이션을 지원합니다. "
"이터레이터를 얻을 수 있는 객체는 :term:`이터러블 <iterable>` 이라고 불립니다."

#: ../Doc/howto/functional.rst:199
msgid "You can experiment with the iteration interface manually:"
msgstr "수동으로 이터레이션 인터페이스를 실험해볼 수 있습니다."

#: ../Doc/howto/functional.rst:217
msgid ""
"Python expects iterable objects in several different contexts, the most "
"important being the :keyword:`for` statement.  In the statement ``for X "
"in Y``, Y must be an iterator or some object for which :func:`iter` can "
"create an iterator.  These two statements are equivalent::"
msgstr ""
"파이썬은 여러 다른 컨텍스트에서 이터러블 객체를 기대하며, 가장 중요한 것은 :keyword:`for` "
"문입니다. ``for X in Y`` 문에서 Y는 반드시 이터레이터 혹은 :func:`iter` 가 "
"이터레이터를 생성할 수 있는 객체이어야 합니다. 다음 두 문장은 같은 의미입니다."

#: ../Doc/howto/functional.rst:229
msgid ""
"Iterators can be materialized as lists or tuples by using the "
":func:`list` or :func:`tuple` constructor functions:"
msgstr ""
"이터레이터는 :func:`list` 또는 :func:`tuple` 생성자 함수를 사용하여 리스트나 "
"튜플로 나타낼 수 있습니다."

#: ../Doc/howto/functional.rst:238
msgid ""
"Sequence unpacking also supports iterators: if you know an iterator will "
"return N elements, you can unpack them into an N-tuple:"
msgstr ""
"시퀀스 언패킹 또한 이터레이터를 지원합니다. 이터레이터가 N개의 요소를 반환한다는 것을 알고 있다면, "
"그것들을 N-튜플로 언패킹할 수 있습니다."

#: ../Doc/howto/functional.rst:247
msgid ""
"Built-in functions such as :func:`max` and :func:`min` can take a single "
"iterator argument and will return the largest or smallest element.  The "
"``\"in\"`` and ``\"not in\"`` operators also support iterators: ``X in "
"iterator`` is true if X is found in the stream returned by the iterator."
"  You'll run into obvious problems if the iterator is infinite; "
":func:`max`, :func:`min` will never return, and if the element X never "
"appears in the stream, the ``\"in\"`` and ``\"not in\"`` operators won't "
"return either."
msgstr ""
":func:`max` 및 :func:`min` 과 같은 내장 함수는 하나의 이터레이터 인수를 취할 수 있으며 "
"가장 큰 혹은 가장 작은 요소를 반환합니다. ``\"in\"`` 과 ``\"not in\"`` 연산자 또한 "
"이터레이터를 지원합니다. 이터레이터가 반환한 스트림에서 X가 발견되면 ``X in iterator`` 는 "
"참입니다. 이터레이터가 무한하다면 명백한 문제를 발견할 수 있습니다. :func:`max` 와 "
":func:`min` 는 영원히 결과를 반환하지 않으며, 요소 X가 스트림에서 나타나지 않으면 "
"``\"in\"`` 과 ``\"not in\"`` 연산자 역시 영원히 결과를 반환하지 않을 것입니다."

#: ../Doc/howto/functional.rst:255
msgid ""
"Note that you can only go forward in an iterator; there's no way to get "
"the previous element, reset the iterator, or make a copy of it.  Iterator"
" objects can optionally provide these additional capabilities, but the "
"iterator protocol only specifies the :meth:`~iterator.__next__` method.  "
"Functions may therefore consume all of the iterator's output, and if you "
"need to do something different with the same stream, you'll have to "
"create a new iterator."
msgstr ""
"이터레이터에서는 오직 앞으로만 나아갈 수 있다는 점에 유의하세요. 이전 요소를 가져오거나, "
"이터레이터를 재설정하거나, 사본을 만들 방법은 없습니다. 이터레이터 객체는 선택적으로 이러한 추가 "
"기능을 제공할 수 있지만, 이터레이터 프로토콜은 :meth:`~iterator.__next__` 메서드만 "
"명시해두었습니다. 함수는 모든 이터레이터의 출력을 소비할 수 있으므로 같은 스트림에서 다른 작업을 "
"수행해야 하는 경우 새로운 이터레이터를 만들어야 합니다."

#: ../Doc/howto/functional.rst:265
msgid "Data Types That Support Iterators"
msgstr "이터레이터를 지원하는 데이터 유형"

#: ../Doc/howto/functional.rst:267
msgid ""
"We've already seen how lists and tuples support iterators.  In fact, any "
"Python sequence type, such as strings, will automatically support "
"creation of an iterator."
msgstr ""
"리스트와 튜플이 이터레이터를 어떻게 지원하는지 이미 살펴보았습니다. 실제로 문자열과 같은 파이썬 "
"시퀀스 유형은 이터레이터의 생성을 자동으로 지원합니다."

#: ../Doc/howto/functional.rst:271
msgid ""
"Calling :func:`iter` on a dictionary returns an iterator that will loop "
"over the dictionary's keys::"
msgstr ""
":func:`iter` 를 딕셔너리에 적용하면 딕셔너리의 키를 반복하는 이터레이터를 반환합니다."

#: ../Doc/howto/functional.rst:291
msgid ""
"Note that the order is essentially random, because it's based on the hash"
" ordering of the objects in the dictionary."
msgstr ""
"딕셔너리 내에 있는 객체의 해시 순서에 기반하기 때문에 순서는 기본적으로 무작위입니다."

#: ../Doc/howto/functional.rst:294
msgid ""
"Applying :func:`iter` to a dictionary always loops over the keys, but "
"dictionaries have methods that return other iterators.  If you want to "
"iterate over values or key/value pairs, you can explicitly call the "
":meth:`~dict.values` or :meth:`~dict.items` methods to get an appropriate"
" iterator."
msgstr ""
":func:`iter` 를 딕셔너리에 적용하는 것은 항상 키를 반복하지만, 딕셔너리에는 다른 "
"이터레이터를 반환하는 메서드가 있습니다. 값이나 키/값 쌍을 반복하는 경우에는 명시적으로 "
":meth:`~dict.values` 혹은 :meth:`~dict.items` 메서드를 사용하여 적절한 이터레이터를 "
"얻을 수 있습니다."

#: ../Doc/howto/functional.rst:300
msgid ""
"The :func:`dict` constructor can accept an iterator that returns a finite"
" stream of ``(key, value)`` tuples:"
msgstr ""
":func:`dict` 생성자는 ``(키, 값)`` 튜플의 유한한 스트림을 반환하는 이터레이터를 받을 수 "
"있습니다."

#: ../Doc/howto/functional.rst:307
msgid ""
"Files also support iteration by calling the "
":meth:`~io.TextIOBase.readline` method until there are no more lines in "
"the file.  This means you can read each line of a file like this::"
msgstr ""
"또한 파일은 더는 새로운 줄이 없을 때까지 :meth:`~io.TextIOBase.readline` 메서드를 "
"호출하여 이터레이션을 지원합니다. 즉, 다음과 같이 파일의 각 행을 읽을 수 있습니다."

#: ../Doc/howto/functional.rst:315
msgid ""
"Sets can take their contents from an iterable and let you iterate over "
"the set's elements::"
msgstr ""
"집합은 이터러블에서 내용을 가져와서 집합의 요소를 반복할 수 있습니다."

#: ../Doc/howto/functional.rst:325
msgid "Generator expressions and list comprehensions"
msgstr "제너레이터 표현식과 리스트 컴프리헨션"

#: ../Doc/howto/functional.rst:327
msgid ""
"Two common operations on an iterator's output are 1) performing some "
"operation for every element, 2) selecting a subset of elements that meet "
"some condition. For example, given a list of strings, you might want to "
"strip off trailing whitespace from each line or extract all the strings "
"containing a given substring."
msgstr ""
"이터레이터의 출력에 대한 두 가지 일반적인 연산은 1) 모든 요소에 대해 일부 연산을 수행하고, 2) "
"어떤 조건을 만족하는 요소의 하위 집합을 선택하는 것입니다. 예를 들어 문자열 리스트가 있으면 각 "
"줄에서 후미 공백을 제거하거나, 주어진 하위 문자열을 포함하는 모든 문자열을 추출할 수 있습니다."

#: ../Doc/howto/functional.rst:333
msgid ""
"List comprehensions and generator expressions (short form: \"listcomps\" "
"and \"genexps\") are a concise notation for such operations, borrowed "
"from the functional programming language Haskell "
"(https://www.haskell.org/).  You can strip all the whitespace from a "
"stream of strings with the following code::"
msgstr ""
"리스트 컴프리헨션과 제너레이터 표현식(줄임말: \"listcomps\" 및 \"genexps\")은 함수형 "
"프로그래밍 언어 하스켈(https://www.haskell.org/)에서 빌린 이러한 작업을 위한 간결한 "
"표기법입니다. 다음 코드를 사용하여 문자열 스트림에서 모든 공백을 제거할 수 있습니다."

#: ../Doc/howto/functional.rst:346
msgid "You can select only certain elements by adding an ``\"if\"`` condition::"
msgstr ""
"``\"if\"`` 조건을 추가하여 특정 요소만 선택할 수도 있습니다."

#: ../Doc/howto/functional.rst:351
msgid ""
"With a list comprehension, you get back a Python list; ``stripped_list`` "
"is a list containing the resulting lines, not an iterator.  Generator "
"expressions return an iterator that computes the values as necessary, not"
" needing to materialize all the values at once.  This means that list "
"comprehensions aren't useful if you're working with iterators that return"
" an infinite stream or a very large amount of data.  Generator "
"expressions are preferable in these situations."
msgstr ""
"리스트 컴프리헨션을 사용하면 파이썬 리스트를 얻을 수 있습니다. ``stripped_list`` 는 "
"이터레이터가 아닌 결과 행을 담고 있는 리스트입니다. 제너레이터 표현식은 필요에 따라 값을 계산하는 "
"이터레이터를 반환하며 모든 값을 한 번에 구체화할 필요가 없습니다. 즉, 무한 스트림이나 매우 많은 "
"양의 데이터를 반환하는 이터레이터로 작업하는 경우 리스트 컴프리헨션은 유용하지 않습니다. 제너레이터 "
"표현식은 이러한 상황에서 유용합니다."

#: ../Doc/howto/functional.rst:358
msgid ""
"Generator expressions are surrounded by parentheses (\"()\") and list "
"comprehensions are surrounded by square brackets (\"[]\").  Generator "
"expressions have the form::"
msgstr ""
"제너레이터 표현식은 괄호(\"()\")로 묶여 있으며 리스트 컴프리헨션은 대괄호(\"[]\")로 묶여 "
"있습니다. 제너레이터 표현식은 다음과 같은 형식입니다."

#: ../Doc/howto/functional.rst:371
msgid ""
"Again, for a list comprehension only the outside brackets are different "
"(square brackets instead of parentheses)."
msgstr ""
"다시 말하면, 리스트 컴프리헨션을 위해서는 바깥쪽 괄호만 다릅니다(괄호 대신 대괄호)."

#: ../Doc/howto/functional.rst:374
msgid ""
"The elements of the generated output will be the successive values of "
"``expression``.  The ``if`` clauses are all optional; if present, "
"``expression`` is only evaluated and added to the result when "
"``condition`` is true."
msgstr ""
"생성된 출력의 요소는 ``expression`` 의 연속적인 값이 될 것입니다. ``if`` 절은 "
"모두 선택적입니다. ``expression`` 은 ``condition`` 이 참일 때만 "
"평가되고 결과에 추가됩니다."

#: ../Doc/howto/functional.rst:378
msgid ""
"Generator expressions always have to be written inside parentheses, but "
"the parentheses signalling a function call also count.  If you want to "
"create an iterator that will be immediately passed to a function you can "
"write::"
msgstr ""
"제너레이터 표현식은 항상 괄호 안에 작성해야 하지만 함수 호출을 알리는 괄호도 포함됩니다. 함수에 "
"즉시 전달되는 반복자를 만들고 싶다면 다음과 같이 작성할 수 있습니다."

#: ../Doc/howto/functional.rst:384
msgid ""
"The ``for...in`` clauses contain the sequences to be iterated over.  The "
"sequences do not have to be the same length, because they are iterated "
"over from left to right, **not** in parallel.  For each element in "
"``sequence1``, ``sequence2`` is looped over from the beginning.  "
"``sequence3`` is then looped over for each resulting pair of elements "
"from ``sequence1`` and ``sequence2``."
msgstr ""
"``for...in`` 절은 반복할 시퀀스를 포함합니다. 시퀀스는 왼쪽에서 오른쪽으로 반복되며 병렬로 "
"처리되지 **않기** 때문에 같은 길이일 필요는 없습니다. ``sequence1`` 의 각 요소에 대해 "
"``sequence2`` 는 처음부터 반복됩니다. ``sequence3`` 은 ``sequence1`` 과 "
"``sequence2`` 의 각 결과 쌍에 대해 반복됩니다."

#: ../Doc/howto/functional.rst:390
msgid ""
"To put it another way, a list comprehension or generator expression is "
"equivalent to the following Python code::"
msgstr ""
"다른 식으로 표현하면, 리스트 컴프리헨션 혹은 제너레이터 표현식은 다음 파이썬 코드와 같습니다."

#: ../Doc/howto/functional.rst:407
msgid ""
"This means that when there are multiple ``for...in`` clauses but no "
"``if`` clauses, the length of the resulting output will be equal to the "
"product of the lengths of all the sequences.  If you have two lists of "
"length 3, the output list is 9 elements long:"
msgstr ""
"이것은 여러 개의 ``for...in`` 절이 있지만 ``if`` 절이 없을 때 결과 출력의 길이가 모든 "
"시퀀스 길이의 곱과 같음을 의미합니다. 길이가 3인 두 개의 리스트가 있는 경우 출력 목록의 길이는 "
"9개입니다."

#: ../Doc/howto/functional.rst:419
msgid ""
"To avoid introducing an ambiguity into Python's grammar, if "
"``expression`` is creating a tuple, it must be surrounded with "
"parentheses.  The first list comprehension below is a syntax error, while"
" the second one is correct::"
msgstr ""
"파이썬 문법의 모호함을 피하고자, ``expression`` 이 튜플을 생성하고 있다면, 괄호로 묶어야 "
"합니다. 아래의 첫 번째 리스트 컴프리헨션은 구문 오류이며, 두 번째는 올바릅니다."

#: ../Doc/howto/functional.rst:430
msgid "Generators"
msgstr "제너레이터"

#: ../Doc/howto/functional.rst:432
msgid ""
"Generators are a special class of functions that simplify the task of "
"writing iterators.  Regular functions compute a value and return it, but "
"generators return an iterator that returns a stream of values."
msgstr ""
"제너레이터는 이터레이터를 작성하는 작업을 단순화하는 특별한 클래스의 함수입니다. 일반 함수는 값을 "
"계산하여 반환하지만, 제너레이터는 값의 스트림을 반환하는 이터레이터를 반환합니다."

#: ../Doc/howto/functional.rst:436
msgid ""
"You're doubtless familiar with how regular function calls work in Python "
"or C. When you call a function, it gets a private namespace where its "
"local variables are created.  When the function reaches a ``return`` "
"statement, the local variables are destroyed and the value is returned to"
" the caller.  A later call to the same function creates a new private "
"namespace and a fresh set of local variables. But, what if the local "
"variables weren't thrown away on exiting a function?  What if you could "
"later resume the function where it left off?  This is what generators "
"provide; they can be thought of as resumable functions."
msgstr ""
"파이썬이나 C에서 정규 함수 호출이 어떻게 작동하는지 잘 알고 있을 것입니다. 함수를 호출하면 "
"지역 변수가 생성되는 비공개 이름 공간이 생깁니다. 함수가 ``return`` 문에 도달하면 지역 변수가 "
"소멸하고 그 값이 호출자에게 반환됩니다. 같은 함수를 나중에 호출하면 새로운 비공개 이름 공간과 "
"새로운 지역 변수 집합이 만들어집니다. 그러나 지역 변수가 함수를 빠져나갈 때 버려지지 않으면 "
"어떻게 될까요? 나중에 중단했던 곳에서 함수를 다시 시작할 수 있다면 어떨까요? 이것이 제너레이터가 "
"제공하는 것입니다. 그들은 재개 가능한 함수라고 생각할 수 있습니다."

#: ../Doc/howto/functional.rst:445
msgid "Here's the simplest example of a generator function:"
msgstr "다음은 제너레이터 함수의 가장 간단한 예입니다."

#: ../Doc/howto/functional.rst:451
msgid ""
"Any function containing a :keyword:`yield` keyword is a generator "
"function; this is detected by Python's :term:`bytecode` compiler which "
"compiles the function specially as a result."
msgstr ""
":keyword:`yield` 키워드를 포함하는 함수는 제너레이터 함수입니다. 이것은 파이썬의 "
":term:`바이트코드 <bytecode>` 컴파일러에 의해 감지됩니다. 이 컴파일러는 결과를 함수로 컴파일합니다."

#: ../Doc/howto/functional.rst:455
msgid ""
"When you call a generator function, it doesn't return a single value; "
"instead it returns a generator object that supports the iterator "
"protocol.  On executing the ``yield`` expression, the generator outputs "
"the value of ``i``, similar to a ``return`` statement.  The big "
"difference between ``yield`` and a ``return`` statement is that on "
"reaching a ``yield`` the generator's state of execution is suspended and "
"local variables are preserved.  On the next call to the generator's "
":meth:`~generator.__next__` method, the function will resume executing."
msgstr ""
"제너레이터 함수를 호출하면 단일 값을 반환하지 않습니다. 대신 이터레이터 프로토콜을 지원하는 "
"제너레이터 객체를 반환합니다. ``yield`` 표현식을 실행하면 제너레이터는 ``return`` 문과 "
"비슷한 ``i`` 의 값을 출력합니다. ``yield`` 와 ``return`` 의 큰 차이점은 ``yield`` "
"에 도달하면 제너레이터의 실행 상태가 일시 중단되고 지역 변수가 보존된다는 것입니다. 제너레이터의 "
":meth:`~generator.__next__` 메서드가 다음에 실행될 때, 함수가 다시 실행됩니다."

#: ../Doc/howto/functional.rst:464
msgid "Here's a sample usage of the ``generate_ints()`` generator:"
msgstr "다음은 ``generate_ints()`` 제너레이터의 사용 예입니다."

#: ../Doc/howto/functional.rst:481
msgid ""
"You could equally write ``for i in generate_ints(5)``, or ``a,b,c = "
"generate_ints(3)``."
msgstr ""
"여러분은 똑같이 ``for i in generate_ints(5)`` 또는 "
"``a,b,c = generate_ints(3)`` 라고 쓸 수 있습니다."

#: ../Doc/howto/functional.rst:484
msgid ""
"Inside a generator function, ``return value`` causes "
"``StopIteration(value)`` to be raised from the "
":meth:`~generator.__next__` method.  Once this happens, or the bottom of "
"the function is reached, the procession of values ends and the generator "
"cannot yield any further values."
msgstr ""
"제너레이터 함수 내에서, ``return value`` 는 :meth:`~generator.__next__` 메서드에서 "
"``StopIteration(value)`` 를 발생시킵니다. 이런 일이 발생하거나 함수의 맨 아래에 도달하면 "
"값의 행렬이 끝나고 제너레이터는 더는 값을 산출할 수 없습니다."

#: ../Doc/howto/functional.rst:489
msgid ""
"You could achieve the effect of generators manually by writing your own "
"class and storing all the local variables of the generator as instance "
"variables.  For example, returning a list of integers could be done by "
"setting ``self.count`` to 0, and having the :meth:`~iterator.__next__` "
"method increment ``self.count`` and return it. However, for a moderately "
"complicated generator, writing a corresponding class can be much messier."
msgstr ""
"직접 클래스를 작성하고 제너레이터의 모든 지역 변수를 인스턴스 변수로 저장하여 제너레이터의 효과를 "
"수동으로 얻을 수 있습니다. 예를 들어, 정수 리스트를 반환하는 것은 ``self.count`` 를 0으로 "
"설정하고 :meth:`~iterator.__next__` 메서드로 ``self.count`` 를 증가시켜 반환하는 "
"식으로 수행할 수 있습니다. 그러나, 다소 복잡한 제너레이터의 경우에는 해당 클래스를 작성하는 것이 "
"훨씬 더 복잡할 수 있습니다."

#: ../Doc/howto/functional.rst:497
msgid ""
"The test suite included with Python's library, "
":source:`Lib/test/test_generators.py`, contains a number of more "
"interesting examples.  Here's one generator that implements an in-order "
"traversal of a tree using generators recursively. ::"
msgstr ""
"파이썬의 라이브러리인 :source:`Lib/test/test_generators.py` 에 포함된 테스트 묶음에는 "
"더 많은 흥미로운 예제들이 있습니다. 제너레이터를 재귀적으로 사용하여 트리를 순차적으로 순회하는 "
"것을 구현하는 하나의 제너레이터가 있습니다."

#: ../Doc/howto/functional.rst:513
msgid ""
"Two other examples in ``test_generators.py`` produce solutions for the "
"N-Queens problem (placing N queens on an NxN chess board so that no queen"
" threatens another) and the Knight's Tour (finding a route that takes a "
"knight to every square of an NxN chessboard without visiting any square "
"twice)."
msgstr ""
"``test_generators.py`` 의 다른 두 가지 예는, N-여왕 문제(NxN 체스판에 서로 다른 "
" 왕비를 위협할 수 없도록 N개의 왕비를 배치하는 문제)와 기사의 여행(나이트가 NxN 체스판의 모든 "
"칸을 정확히 한 번씩 갈 수 있도록 하는 방법을 찾는 문제)입니다."

#: ../Doc/howto/functional.rst:521
msgid "Passing values into a generator"
msgstr "제너레이터에 값 전달하기"

#: ../Doc/howto/functional.rst:523
msgid ""
"In Python 2.4 and earlier, generators only produced output.  Once a "
"generator's code was invoked to create an iterator, there was no way to "
"pass any new information into the function when its execution is resumed."
"  You could hack together this ability by making the generator look at a "
"global variable or by passing in some mutable object that callers then "
"modify, but these approaches are messy."
msgstr ""
"파이썬 2.4 및 그 이전 버전에서 제너레이터는 출력만 생성했습니다. 제너레이터의 코드가 이터레이터를 "
"만들기 위해 호출된 후에는 그 실행이 다시 시작될 때 함수에 새로운 정보를 전달할 방법이 없었습니다. "
"제너레이터가 전역 변수를 보거나 호출자가 수정할 수 있는 변경 가능한 객체를 전달함으로써 이 기능을 "
"해킹할 수 있지만, 이러한 접근법은 지저분한 방식입니다."

#: ../Doc/howto/functional.rst:530
msgid ""
"In Python 2.5 there's a simple way to pass values into a generator. "
":keyword:`yield` became an expression, returning a value that can be "
"assigned to a variable or otherwise operated on::"
msgstr ""
"파이썬 2.5에서는 제너레이터에 값을 전달하는 간단한 방법이 있습니다. :keyword:`yield` 는 "
"표현식이 되어 변수에 할당하거나 다른 식으로 조작할 수 있는 값을 반환합니다."

#: ../Doc/howto/functional.rst:536
msgid ""
"I recommend that you **always** put parentheses around a ``yield`` "
"expression when you're doing something with the returned value, as in the"
" above example. The parentheses aren't always necessary, but it's easier "
"to always add them instead of having to remember when they're needed."
msgstr ""
"위 예제처럼 반환 값으로 무엇인가를 할 때 ``yield`` 표현식 주위에 **항상** 괄호를 넣는 것이 "
"좋습니다. 괄호는 항상 필요한 것은 아니지만 필요한 시점을 기억하지 않고 항상 추가하기가 더 쉽습니다."

#: ../Doc/howto/functional.rst:541
msgid ""
"(:pep:`342` explains the exact rules, which are that a "
"``yield``-expression must always be parenthesized except when it occurs "
"at the top-level expression on the right-hand side of an assignment.  "
"This means you can write ``val = yield i`` but have to use parentheses "
"when there's an operation, as in ``val = (yield i) + 12``.)"
msgstr ""
"(:pep:`342` 는 정확한 규칙을 설명합니다. 이것은 할당의 오른쪽에 있는 최상위 표현식에서 "
"발생하는 경우를 제외하고 항상 ``yield`` 표현식을 괄호로 묶어야 한다는 것입니다. "
"``val = yield i`` 라고 쓸 수도 있지만, ``val = (yield i) + 12`` 처럼 연산이 "
"있을 때는 괄호를 써야합니다.)"

#: ../Doc/howto/functional.rst:547
msgid ""
"Values are sent into a generator by calling its :meth:`send(value) "
"<generator.send>` method.  This method resumes the generator's code and "
"the ``yield`` expression returns the specified value.  If the regular "
":meth:`~generator.__next__` method is called, the ``yield`` returns "
"``None``."
msgstr ""
"값은 :meth:`send(value) <generator.send>` 메서드를 호출하여 제너레이터로 보내집니다. "
"이 메서드는 제너레이터의 코드를 다시 시작하고 ``yield`` 표현식은 지정된 값을 반환합니다. 만약 "
"정규 :meth:`~generator.__next__` 메서드가 호출되면 ``yield`` 는 ``None`` 을 "
"반환합니다."

#: ../Doc/howto/functional.rst:552
msgid ""
"Here's a simple counter that increments by 1 and allows changing the "
"value of the internal counter."
msgstr ""
"다음은 1씩 증가하며 내부 카운터값을 변경할 수 있는 간단한 카운터입니다."

#: ../Doc/howto/functional.rst:567
msgid "And here's an example of changing the counter:"
msgstr ""
"다음은 카운터 변경의 예시입니다."

#: ../Doc/howto/functional.rst:584
msgid ""
"Because ``yield`` will often be returning ``None``, you should always "
"check for this case.  Don't just use its value in expressions unless "
"you're sure that the :meth:`~generator.send` method will be the only "
"method used to resume your generator function."
msgstr ""
"``yield`` 가 종종 ``None`` 을 반환할 것이므로, 항상 이 경우를 확인해야 합니다. "
":meth:`~generator.send` 메서드가 제너레이터 함수를 다시 시작하는데 사용되는 유일한 "
"메서드가 아니라면, 표현식에서 값을 사용하지 마세요."

#: ../Doc/howto/functional.rst:589
msgid ""
"In addition to :meth:`~generator.send`, there are two other methods on "
"generators:"
msgstr ""
":meth:`~generator.send` 외에도 제너레이터에 대한 두 가지 다른 메서드가 있습니다."

#: ../Doc/howto/functional.rst:592
msgid ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` is used"
" to raise an exception inside the generator; the exception is raised by "
"the ``yield`` expression where the generator's execution is paused."
msgstr ""
":meth:`throw(type, value=None, traceback=None) <generator.throw>` 는 "
"제너레이터 내에서 예외를 발생시키는 데 사용됩니다. 예외는 제너레이터의 실행이 일시 중지된 "
"``yield`` 표현식에 의해 발생합니다."

#: ../Doc/howto/functional.rst:596
msgid ""
":meth:`~generator.close` raises a :exc:`GeneratorExit` exception inside "
"the generator to terminate the iteration.  On receiving this exception, "
"the generator's code must either raise :exc:`GeneratorExit` or "
":exc:`StopIteration`; catching the exception and doing anything else is "
"illegal and will trigger a :exc:`RuntimeError`.  :meth:`~generator.close`"
" will also be called by Python's garbage collector when the generator is "
"garbage-collected."
msgstr ""
":meth:`~generator.close` 는 생성자 내에서 :exc:`GeneratorExit` 예외를 발생시켜 "
"이터레이션을 종료합니다. 이 예외가 발생하면 제너레이터의 코드는 :exc:`GeneratorExit` "
"또는 :exc:`StopIteration` 을 발생시켜야 합니다. 예외를 받고도 다른 작업을 하는 것은 "
"금지되어 있으며 :exc:`RuntimeError` 를 촉발합니다. :meth:`~generator.close` 는 "
"제너레이터가 가비지로 수거될 때 파이썬의 가비지 수거기에 의해 호출될 것입니다."

#: ../Doc/howto/functional.rst:604
msgid ""
"If you need to run cleanup code when a :exc:`GeneratorExit` occurs, I "
"suggest using a ``try: ... finally:`` suite instead of catching "
":exc:`GeneratorExit`."
msgstr ""
":exc:`GeneratorExit` 이 발생할 때 정리 작업을 위한 코드를 실행해야 한다면 "
":exc:`GeneratorExit` 를 잡는 대신 ``try: ... finally:`` 를 사용하는 것이 "
"좋습니다."

#: ../Doc/howto/functional.rst:607
msgid ""
"The cumulative effect of these changes is to turn generators from one-way"
" producers of information into both producers and consumers."
msgstr ""
"이러한 변화의 누적 효과는 제너레이터를 일방적인 정보 생산자에서 생산자와 소비자 모두로 전환하는 "
"것입니다."

#: ../Doc/howto/functional.rst:610
msgid ""
"Generators also become **coroutines**, a more generalized form of "
"subroutines. Subroutines are entered at one point and exited at another "
"point (the top of the function, and a ``return`` statement), but "
"coroutines can be entered, exited, and resumed at many different points "
"(the ``yield`` statements)."
msgstr ""
"제너레이터는 **코루틴** 이 되어 더 일반적인 형태의 서브루틴이 됩니다. 서브루틴은 한 지점에서 "
"시작되고 다른 한 지점(함수의 맨 위와 ``return`` 문)에서 빠져나옵니다. 그러나 여러 다른 "
"지점에서 코루틴을 시작하고 빠져나오고 다시 시작할 수 있습니다(``yield`` 문)."

#: ../Doc/howto/functional.rst:617
msgid "Built-in functions"
msgstr "내장 함수"

#: ../Doc/howto/functional.rst:619
msgid "Let's look in more detail at built-in functions often used with iterators."
msgstr ""
"이터레이터에서 자주 사용되는 내장 함수를 자세히 살펴보겠습니다."

#: ../Doc/howto/functional.rst:621
msgid ""
"Two of Python's built-in functions, :func:`map` and :func:`filter` "
"duplicate the features of generator expressions:"
msgstr ""
"파이썬의 두 가지 내장 함수인 :func:`map` 와 :func:`filter` 는 제너레이터 표현식의 "
"특징을 복제합니다."

#: ../Doc/howto/functional.rst:633
msgid ""
":func:`map(f, iterA, iterB, ...) <map>` returns an iterator over the "
"sequence"
msgstr ""
":func:`map(f, iterA, iterB, ...) <map>` 은 시퀀스에 대한 이터레이터를 반환합니다."

#: ../Doc/howto/functional.rst:625
msgid ""
"``f(iterA[0], iterB[0]), f(iterA[1], iterB[1]), f(iterA[2], iterB[2]), "
"...``."
msgstr ""

#: ../Doc/howto/functional.rst:635
msgid "You can of course achieve the same effect with a list comprehension."
msgstr ""
"물론 리스트 컴프리헨션으로 같은 효과를 얻을 수 있습니다."

#: ../Doc/howto/functional.rst:637
msgid ""
":func:`filter(predicate, iter) <filter>` returns an iterator over all the"
" sequence elements that meet a certain condition, and is similarly "
"duplicated by list comprehensions.  A **predicate** is a function that "
"returns the truth value of some condition; for use with :func:`filter`, "
"the predicate must take a single value."
msgstr ""
":func:`filter(predicate, iter) <filter>` 는 특정 조건을 만족하는 모든 시퀀스 요소에 "
"대한 이터레이터를 반환하며, 마찬가지로 리스트 컴프리헨션에 의해 복제됩니다. **술어** 는 어떤 "
"조건의 진릿값을 반환하는 함수입니다. :func:`filter` 와 함께 사용하는 경우, 술어는 단일 값을 "
"가져야 합니다."

#: ../Doc/howto/functional.rst:650
msgid "This can also be written as a list comprehension:"
msgstr ""
"또한 이것은 리스트 컴프리헨션으로 작성될 수 있습니다."

#: ../Doc/howto/functional.rst:656
msgid ""
":func:`enumerate(iter, start=0) <enumerate>` counts off the elements in "
"the iterable returning 2-tuples containing the count (from *start*) and "
"each element. ::"
msgstr ""
":func:`enumerate(iter, start=0) <enumerate>` 는 카운트(start부터)와 각 요소를 "
"포함하는 2개의 요소로 구성된 튜플을 반환하는 이터러블의 요소를 계산합니다."

#: ../Doc/howto/functional.rst:666
msgid ""
":func:`enumerate` is often used when looping through a list and recording"
" the indexes at which certain conditions are met::"
msgstr ""
":func:`enumerate` 는 리스트를 반복하고 특정 조건이 충족되는 인덱스를 기록할 때 자주 사용됩니다."

#: ../Doc/howto/functional.rst:674
msgid ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` collects all "
"the elements of the iterable into a list, sorts the list, and returns the"
" sorted result.  The *key* and *reverse* arguments are passed through to "
"the constructed list's :meth:`~list.sort` method. ::"
msgstr ""
":func:`sorted(iterable, key=None, reverse=False) <sorted>` 는 이터러블의 모든 "
"요소를 리스트로 모으고, 리스트를 정렬하고, 정렬된 결과를 반환합니다. *key* 와 *reverse* "
"인수는 생성된 리스트의 :meth:`~list.sort` 메서드로 전달됩니다."

#: ../Doc/howto/functional.rst:689
msgid "(For a more detailed discussion of sorting, see the :ref:`sortinghowto`.)"
msgstr ""
"정렬에 대한 자세한 설명은 :ref:`sortinghowto` 를 참고하세요."

#: ../Doc/howto/functional.rst:692
msgid ""
"The :func:`any(iter) <any>` and :func:`all(iter) <all>` built-ins look at"
" the truth values of an iterable's contents.  :func:`any` returns "
"``True`` if any element in the iterable is a true value, and :func:`all` "
"returns ``True`` if all of the elements are true values:"
msgstr ""
":func:`any(iter) <any>` 및 :func:`all(iter) <all>` 내장 함수는 반복 가능한 내용의 "
"진릿값을 봅니다. :func:`any` 는 이터러블의 어떤 요소가 참이면 ``True`` 를 반환하고, "
":func:`all` 은 모든 요소가 참이면 ``True`` 를 반환합니다."

#: ../Doc/howto/functional.rst:711
msgid ""
":func:`zip(iterA, iterB, ...) <zip>` takes one element from each iterable"
" and returns them in a tuple::"
msgstr ""
":func:`zip(iterA, iterB, ...) <zip>` 은 각 이터러블에서 하나의 요소를 취하여 튜플로 "
"반환합니다."

#: ../Doc/howto/functional.rst:717
msgid ""
"It doesn't construct an in-memory list and exhaust all the input "
"iterators before returning; instead tuples are constructed and returned "
"only if they're requested.  (The technical term for this behaviour is "
"`lazy evaluation <https://en.wikipedia.org/wiki/Lazy_evaluation>`__.)"
msgstr ""
"이 함수는 결과를 반환하기 전에 메모리 내의 리스트를 구성하거나 모든 입력 이터레이터를 처리하지 않습니다. "
"대신 튜플은 요청된 경우에만 생성하여 반환합니다. (이 동작의 전문 용어는 "
"`느긋한 계산법 <https://en.wikipedia.org/wiki/Lazy_evaluation>`__ 입니다.)"

#: ../Doc/howto/functional.rst:722
msgid ""
"This iterator is intended to be used with iterables that are all of the "
"same length.  If the iterables are of different lengths, the resulting "
"stream will be the same length as the shortest iterable. ::"
msgstr ""
"이 이터레이터는 모두 같은 길이의 이터러블과 함께 사용하기 위한 것입니다. 이터러블의 길이가 다른 "
"경우 결과 스트림은 가장 짧은 이터러블과 같은 길이가 됩니다."

#: ../Doc/howto/functional.rst:729
msgid ""
"You should avoid doing this, though, because an element may be taken from"
" the longer iterators and discarded.  This means you can't go on to use "
"the iterators further because you risk skipping a discarded element."
msgstr ""
"더 긴 이터레이터에서 나머지 요소는 버려지기 때문에 이런 방식은 피해야 합니다. 즉, 삭제된 요소를 "
"건너뛸 위험이 있으므로 이터레이터를 계속 사용할 수 없습니다."

#: ../Doc/howto/functional.rst:735
msgid "The itertools module"
msgstr "itertools 모듈"

#: ../Doc/howto/functional.rst:737
msgid ""
"The :mod:`itertools` module contains a number of commonly-used iterators "
"as well as functions for combining several iterators.  This section will "
"introduce the module's contents by showing small examples."
msgstr ""
":mod:`itertools` 모듈은 공통적으로 사용되는 많은 이터레이터와 몇몇 이터레이터를 결합하기 위한 함수를 포함합니다. 이 절에서는 작은 예제를 보여줌으로써 모듈의 내용을 소개합니다."

#: ../Doc/howto/functional.rst:741
msgid "The module's functions fall into a few broad classes:"
msgstr ""
"모듈의 기능은 몇 가지 광범위한 클래스로 분류됩니다."

#: ../Doc/howto/functional.rst:743
msgid "Functions that create a new iterator based on an existing iterator."
msgstr ""
"기존 이터레이터를 기반으로 새로운 이터레이터를 만드는 함수."

#: ../Doc/howto/functional.rst:744
msgid "Functions for treating an iterator's elements as function arguments."
msgstr ""
"이터레이터의 요소를 함수 인수로 처리하는 함수."

#: ../Doc/howto/functional.rst:745
msgid "Functions for selecting portions of an iterator's output."
msgstr ""
"이터레이터의 출력 부분을 선택하는 함수."

#: ../Doc/howto/functional.rst:746
msgid "A function for grouping an iterator's output."
msgstr ""
"이터레이터의 출력을 분류하는 함수."

#: ../Doc/howto/functional.rst:749
msgid "Creating new iterators"
msgstr ""
"새로운 이터레이터 만들기"

#: ../Doc/howto/functional.rst:751
msgid ""
":func:`itertools.count(start, step) <itertools.count>` returns an "
"infinite stream of evenly spaced values.  You can optionally supply the "
"starting number, which defaults to 0, and the interval between numbers, "
"which defaults to 1::"
msgstr ""
":func:`itertools.count(start, step) <itertools.count>` 는 균등하게 간격을 둔 "
"값들의 무한한 스트림을 반환합니다. 선택적으로 기본값이 0인 시작 번호와 기본값이 1인 숫자 사이의 "
"간격을 제공할 수 있습니다."

#: ../Doc/howto/functional.rst:762
msgid ""
":func:`itertools.cycle(iter) <itertools.cycle>` saves a copy of the "
"contents of a provided iterable and returns a new iterator that returns "
"its elements from first to last.  The new iterator will repeat these "
"elements infinitely. ::"
msgstr ""
":func:`itertools.cycle(iter) <itertools.cycle>` 은 제공된 이터러블의 내용 "
"사본을 저장하고 처음부터 마지막까지 요소를 반환하는 새로운 이터레이터를 반환합니다. 새로운 "
"이터레이터는 이러한 요소를 무한히 반복합니다."

#: ../Doc/howto/functional.rst:769
msgid ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` returns the "
"provided element *n* times, or returns the element endlessly if *n* is "
"not provided. ::"
msgstr ""
":func:`itertools.repeat(elem, [n]) <itertools.repeat>` 는 제공된 요소를 "
"*n* 번 반환하거나, *n* 이 제공되지 않으면 끝없이 요소를 반환합니다."

#: ../Doc/howto/functional.rst:777
msgid ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` takes an "
"arbitrary number of iterables as input, and returns all the elements of "
"the first iterator, then all the elements of the second, and so on, until"
" all of the iterables have been exhausted. ::"
msgstr ""
":func:`itertools.chain(iterA, iterB, ...) <itertools.chain>` 은 임의의 수의 "
"이터러블을 입력으로 취하여, 첫 번째 이터러블의 모든 요소를 반환한 다음 두 번째 요소의 모든 요소를 "
"반환하고, 모든 이터러블이 다 소모될 때까지 이 동작을 반복합니다."

#: ../Doc/howto/functional.rst:785
msgid ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` "
"returns a stream that's a slice of the iterator.  With a single *stop* "
"argument, it will return the first *stop* elements.  If you supply a "
"starting index, you'll get *stop-start* elements, and if you supply a "
"value for *step*, elements will be skipped accordingly.  Unlike Python's "
"string and list slicing, you can't use negative values for *start*, "
"*stop*, or *step*. ::"
msgstr ""
":func:`itertools.islice(iter, [start], stop, [step]) <itertools.islice>` 는 "
"이터레이터의 조각인 스트림을 반환합니다. 단일 *stop* 인수를 사용하면 첫 번째 *stop* 요소가 "
"반환됩니다. 시작 인덱스를 지정하면 *stop-start* 요소가 생기고, *step* 에 값을 지정하면 요소는 "
"그에 따라 생략됩니다. 파이썬의 문자열 및 리스트 슬라이싱과 달리, *start*, *stop*, *step* 에 "
"음수값을 사용할 수 없습니다."

#: ../Doc/howto/functional.rst:799
msgid ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` replicates an iterator; "
"it returns *n* independent iterators that will all return the contents of"
" the source iterator. If you don't supply a value for *n*, the default is"
" 2.  Replicating iterators requires saving some of the contents of the "
"source iterator, so this can consume significant memory if the iterator "
"is large and one of the new iterators is consumed more than the others. "
"::"
msgstr ""
":func:`itertools.tee(iter, [n]) <itertools.tee>` 는 이터레이터를 복제합니다. "
"원본 이터레이터의 내용을 모두 반환하는 *n* 개의 독립적인 이터레이터를 반환합니다. *n* 에 대한 "
"값을 제공하지 않으면 기본값은 2입니다. 이터레이터를 복제하려면 원본 이터레이터의 일부 내용을 "
"저장해야 하므로 이터레이터가 크고 새로운 이터레이터 중 하나가 다른 것보다 많이 소비된다면 이것은 "
"상당한 메모리를 소비할 수 있습니다."

#: ../Doc/howto/functional.rst:818
msgid "Calling functions on elements"
msgstr "요소에 대한 함수 호출"

#: ../Doc/howto/functional.rst:820
msgid ""
"The :mod:`operator` module contains a set of functions corresponding to "
"Python's operators.  Some examples are :func:`operator.add(a, b) "
"<operator.add>` (adds two values), :func:`operator.ne(a, b)  "
"<operator.ne>` (same as ``a != b``), and :func:`operator.attrgetter('id')"
" <operator.attrgetter>` (returns a callable that fetches the ``.id`` "
"attribute)."
msgstr ""
":mod:`operator` 모듈은 파이썬의 연산자에 대응하는 함수 집합을 포함합니다. 예를 들어 "
":func:`operator.add(a, b) <operator.add>` (두 개의 값을 더하기), "
":func:`operator.ne(a, b) <operator.ne>` (``a != b`` 와 동일) 및 "
":func:`operator.attrgetter('id') <operator.attrgetter>` "
"(``.id`` 속성을 가져오는 콜러블을 반환)와 같은 함수가 있습니다."

#: ../Doc/howto/functional.rst:826
msgid ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` assumes that "
"the iterable will return a stream of tuples, and calls *func* using these"
" tuples as the arguments::"
msgstr ""
":func:`itertools.starmap(func, iter) <itertools.starmap>` 은 이터러블이 "
"튜플의 스트림을 반환할 것이라고 가정하고, 이 튜플을 인수로 사용하여 *func* 를 호출합니다."

#: ../Doc/howto/functional.rst:838
msgid "Selecting elements"
msgstr "요소 선택하기"

#: ../Doc/howto/functional.rst:840
msgid ""
"Another group of functions chooses a subset of an iterator's elements "
"based on a predicate."
msgstr ""
"또 다른 함수 모음은 술어에 기초하여 이터러블 요소의 하위 집합을 선택합니다."

#: ../Doc/howto/functional.rst:843
msgid ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` is"
" the opposite of :func:`filter`, returning all elements for which the "
"predicate returns false::"
msgstr ""
":func:`itertools.filterfalse(predicate, iter) <itertools.filterfalse>` 는 "
":func:`filter` 의 반대이며, 술어가 거짓을 반환하는 모든 요소를 반환합니다."

#: ../Doc/howto/functional.rst:850
msgid ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` "
"returns elements for as long as the predicate returns true.  Once the "
"predicate returns false, the iterator will signal the end of its results."
" ::"
msgstr ""
":func:`itertools.takewhile(predicate, iter) <itertools.takewhile>` 은 "
"술어가 참을 반환하는 한 요소를 반환합니다. 술어가 거짓을 반환하면 이터레이터는 결과의 종료를 "
"알립니다."

#: ../Doc/howto/functional.rst:863
msgid ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` "
"discards elements while the predicate returns true, and then returns the "
"rest of the iterable's results. ::"
msgstr ""
":func:`itertools.dropwhile(predicate, iter) <itertools.dropwhile>` 은 "
"술어가 참을 반환하는 동안 요소를 버리고, 나머지 이터러블의 결과를 반환합니다."

#: ../Doc/howto/functional.rst:873
msgid ""
":func:`itertools.compress(data, selectors) <itertools.compress>` takes "
"two iterators and returns only those elements of *data* for which the "
"corresponding element of *selectors* is true, stopping whenever either "
"one is exhausted::"
msgstr ""
":func:`itertools.compress(data, selectors) <itertools.compress>` 는 "
"두 개의 이터레이터를 취하고 *셀렉터* 의 해당 요소가 참인 *데이터* 의 요소만을 반환하고, "
"한쪽이 고갈될 때마다 중단합니다."

#: ../Doc/howto/functional.rst:882
msgid "Combinatoric functions"
msgstr "조합 함수"

#: ../Doc/howto/functional.rst:884
msgid ""
"The :func:`itertools.combinations(iterable, r) <itertools.combinations>` "
"returns an iterator giving all possible *r*-tuple combinations of the "
"elements contained in *iterable*.  ::"
msgstr ""
":func:`itertools.combinations(iterable, r) <itertools.combinations>` 는 "
"*이터러블* 에 포함된 모든 요소의 가능한 *r*-튜플 조합을 제공하는 이터레이터를 반환합니다."

#: ../Doc/howto/functional.rst:899
msgid ""
"The elements within each tuple remain in the same order as *iterable* "
"returned them.  For example, the number 1 is always before 2, 3, 4, or 5 "
"in the examples above.  A similar function, "
":func:`itertools.permutations(iterable, r=None) "
"<itertools.permutations>`, removes this constraint on the order, "
"returning all possible arrangements of length *r*::"
msgstr ""
"각 튜플 내의 요소들은 *이터러블* 이 반환한 것과 같은 순서로 유지됩니다. 예를 들어 위의 예시에서 "
"숫자 1은 항상 2, 3, 4 또는 5 앞에 옵니다. 비슷한 함수인 "
":func:`itertools.permutations(iterable, r=None) <itertools.permutations>` "
"은 제약 조건을 제거하여 길이 *r* 의 가능한 모든 배열을 반환합니다."

#: ../Doc/howto/functional.rst:918
msgid ""
"If you don't supply a value for *r* the length of the iterable is used, "
"meaning that all the elements are permuted."
msgstr ""
"*r* 에 값을 지정하지 않으면 이터러블의 길이가 사용됩니다. 즉, 모든 요소가 치환됩니다."

#: ../Doc/howto/functional.rst:921
msgid ""
"Note that these functions produce all of the possible combinations by "
"position and don't require that the contents of *iterable* are unique::"
msgstr ""
"이 함수는 위치별로 가능한 모든 조합을 생성하며 *이터러블* 의 내용이 고유해야 할 필요는 없습니다."

#: ../Doc/howto/functional.rst:928
msgid ""
"The identical tuple ``('a', 'a', 'b')`` occurs twice, but the two 'a' "
"strings came from different positions."
msgstr ""
"같은 튜플 ``('a', 'a', 'b')`` 가 두 번 발생하지만, 두 개의 'a' 문자열은 다른 위치에서 "
"왔습니다."

#: ../Doc/howto/functional.rst:931
msgid ""
"The :func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` function relaxes a different "
"constraint: elements can be repeated within a single tuple.  Conceptually"
" an element is selected for the first position of each tuple and then is "
"replaced before the second element is selected.  ::"
msgstr ""
":func:`itertools.combinations_with_replacement(iterable, r) "
"<itertools.combinations_with_replacement>` 함수는 다른 제약을 완화합니다. "
"요소는 단일 튜플 내에서 반복될 수 있습니다. 개념적으로 요소는 각 튜플의 첫 번째 위치에 대해 "
"선택되고 두 번째 요소가 선택되기 전에 대체됩니다."

#: ../Doc/howto/functional.rst:946
msgid "Grouping elements"
msgstr "요소 그룹화"

#: ../Doc/howto/functional.rst:948
msgid ""
"The last function I'll discuss, :func:`itertools.groupby(iter, "
"key_func=None) <itertools.groupby>`, is the most complicated.  "
"``key_func(elem)`` is a function that can compute a key value for each "
"element returned by the iterable.  If you don't supply a key function, "
"the key is simply each element itself."
msgstr ""
"마지막으로 소개할 :func:`itertools.groupby(iter, key_func=None) <itertools.groupby>` "
"함수는 가장 복잡합니다. ``key_func(elem)`` 는 이터러블에 의해 반환된 각 요소에 대한 키값을 "
"계산할 수 있는 함수입니다. 키 함수를 제공하지 않으면 키는 단순히 각 요소 자체입니다."

#: ../Doc/howto/functional.rst:953
msgid ""
":func:`~itertools.groupby` collects all the consecutive elements from the"
" underlying iterable that have the same key value, and returns a stream "
"of 2-tuples containing a key value and an iterator for the elements with "
"that key."
msgstr ""
":func:`~itertools.groupby` 는 키값이 같은 기본 이터러블에서 연속된 모든 요소를 수집하여 "
"키값과 해당 키를 가진 요소의 이터러블을 포함하는 2-튜플의 스트림을 반환합니다."

#: ../Doc/howto/functional.rst:981
msgid ""
":func:`~itertools.groupby` assumes that the underlying iterable's "
"contents will already be sorted based on the key.  Note that the returned"
" iterators also use the underlying iterable, so you have to consume the "
"results of iterator-1 before requesting iterator-2 and its corresponding "
"key."
msgstr ""
":func:`~itertools.groupby` 는 기본적인 이터러블 내용이 키에 따라 이미 정렬되었다고 가정합니다. "
"반환된 이터레이터 역시 기본적인 이터러블을 사용하므로 이터레이터-2와 해당 키를 요청하기 전에 "
"이터레이터-1의 결과를 사용해야 합니다."

#: ../Doc/howto/functional.rst:988
msgid "The functools module"
msgstr "functools 모듈"

#: ../Doc/howto/functional.rst:990
msgid ""
"The :mod:`functools` module in Python 2.5 contains some higher-order "
"functions. A **higher-order function** takes one or more functions as "
"input and returns a new function.  The most useful tool in this module is"
" the :func:`functools.partial` function."
msgstr ""
"파이썬 2.5의 :mod:`functools` 모듈은 고차원 함수를 포함하고 있습니다. **고차 함수** 는 "
"하나 이상의 함수를 입력으로 사용하고 새로운 함수를 반환합니다. 이 모듈에서 가장 유용한 도구는 "
":func:`functools.partial` 함수입니다."

#: ../Doc/howto/functional.rst:995
msgid ""
"For programs written in a functional style, you'll sometimes want to "
"construct variants of existing functions that have some of the parameters"
" filled in. Consider a Python function ``f(a, b, c)``; you may wish to "
"create a new function ``g(b, c)`` that's equivalent to ``f(1, b, c)``; "
"you're filling in a value for one of ``f()``'s parameters.  This is "
"called \"partial function application\"."
msgstr ""
"함수형 방식으로 작성된 프로그램의 경우, 일부 매개 변수가 채워진 기존 함수의 변형이 필요한 경우가 "
"있습니다. 파이썬 함수 ``f(a, b, c)`` 를 고려해보세요. 파이썬 함수인 ``f(1, b, c)`` 에 "
"해당하는 새로운 함수 ``g(b, c)`` 를 만들 수 있습니다. 이를 \"부분적 함수 응용 프로그램\" "
"이라고 합니다."

#: ../Doc/howto/functional.rst:1001
msgid ""
"The constructor for :func:`~functools.partial` takes the arguments "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)``.  The "
"resulting object is callable, so you can just call it to invoke "
"``function`` with the filled-in arguments."
msgstr ""
":func:`~functools.partial` 의 생성자는 "
"``(function, arg1, arg2, ..., kwarg1=value1, kwarg2=value2)`` 와 같은 "
"인수를 취합니다. 결과 객체는 호출할 수 있으므로, 채워진 인수로 ``function`` 을 "
"실행하기 위해서는 결과 객체를 호출하면 됩니다."

#: ../Doc/howto/functional.rst:1006
msgid "Here's a small but realistic example::"
msgstr "작지만 현실적인 예가 있습니다."

#: ../Doc/howto/functional.rst:1018
msgid ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` "
"cumulatively performs an operation on all the iterable's elements and, "
"therefore, can't be applied to infinite iterables. *func* must be a "
"function that takes two elements and returns a single value.  "
":func:`functools.reduce` takes the first two elements A and B returned by"
" the iterator and calculates ``func(A, B)``.  It then requests the third "
"element, C, calculates ``func(func(A, B), C)``, combines this result with"
" the fourth element returned, and continues until the iterable is "
"exhausted.  If the iterable returns no values at all, a :exc:`TypeError` "
"exception is raised.  If the initial value is supplied, it's used as a "
"starting point and ``func(initial_value, A)`` is the first calculation. "
"::"
msgstr ""
":func:`functools.reduce(func, iter, [initial_value]) <functools.reduce>` 는 "
"모든 이터러블 요소에 대해 누적 연산을 수행하므로 무한 이터러블에 적용할 수 없습니다. *func* 는 "
"두 요소를 사용하여 하나의 값을 반환하는 함수이어야 합니다. :func:`functools.reduce` 는 "
"이터레이터가 반환한 처음 두 요소 A와 B를 취해 ``func(A, B)`` 를 계산합니다. 그다음 세 번째 "
"요소인 C를 취해 ``func(func(A, B), C)`` 를 계산하고, 이 결과를 반환된 네 번째 요소와 "
"결합해 이터러블이 소진될 때까지 계속합니다. 이터러블이 값을 반환하지 않으면 :exc:`TypeError` "
"예외가 발생합니다. 초기값이 제공되면 시작점으로 사용되며 ``func(initial_value, A)`` 가 "
"첫 번째로 계산됩니다."

#: ../Doc/howto/functional.rst:1042
msgid ""
"If you use :func:`operator.add` with :func:`functools.reduce`, you'll add"
" up all the elements of the iterable.  This case is so common that "
"there's a special built-in called :func:`sum` to compute it:"
msgstr ""
":func:`operator.add` 를 :func:`functools.reduce` 와 함께 사용하면 이터러블의 "
"모든 요소가 추가됩니다. 이 경우는 매우 일반적이어서 :func:`sum` 이라는 특수 내장 함수가 "
"제공됩니다."

#: ../Doc/howto/functional.rst:1054
msgid ""
"For many uses of :func:`functools.reduce`, though, it can be clearer to "
"just write the obvious :keyword:`for` loop::"
msgstr ""
"그렇지만 :func:`functools.reduce` 를 여러 번 사용하는 경우, 명백한 :keyword:`for` "
"루프만 작성하는 것이 더 명확할 수 있습니다."

#: ../Doc/howto/functional.rst:1066
msgid ""
"A related function is :func:`itertools.accumulate(iterable, "
"func=operator.add) <itertools.accumulate>`.  It performs the same "
"calculation, but instead of returning only the final result, "
":func:`accumulate` returns an iterator that also yields each partial "
"result::"
msgstr ""
"관련 함수는 :func:`itertools.accumulate(iterable, func=operator.add) "
"<itertools.accumulate>` 입니다. 같은 계산을 수행하지만, 최종 결과만 반환하는 대신 "
":func:`accumulate` 는 각 부분 결과를 반환하는 이터레이터를 반환합니다."

#: ../Doc/howto/functional.rst:1079
msgid "The operator module"
msgstr "연산자 모듈"

#: ../Doc/howto/functional.rst:1081
msgid ""
"The :mod:`operator` module was mentioned earlier.  It contains a set of "
"functions corresponding to Python's operators.  These functions are often"
" useful in functional-style code because they save you from writing "
"trivial functions that perform a single operation."
msgstr ""
":mod:`operator` 모듈은 이전에 언급되었습니다. 여기에는 파이썬 연산자에 해당하는 함수 집합이 "
"포함되어 있습니다. 단일 작업을 수행하는 사소한 함수를 작성하지 않아도 되므로 이러한 함수는 "
"함수형 방식 코드에서 유용합니다."

#: ../Doc/howto/functional.rst:1086
msgid "Some of the functions in this module are:"
msgstr ""
"이 모듈의 몇몇 함수는 다음과 같습니다."

#: ../Doc/howto/functional.rst:1088
msgid ""
"Math operations: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."
msgstr ""
"수학 연산: ``add()``, ``sub()``, ``mul()``, ``floordiv()``, "
"``abs()``, ..."

#: ../Doc/howto/functional.rst:1089
msgid "Logical operations: ``not_()``, ``truth()``."
msgstr ""
"논리 연산: ``not_()``, ``truth()``."

#: ../Doc/howto/functional.rst:1090
msgid "Bitwise operations: ``and_()``, ``or_()``, ``invert()``."
msgstr ""
"비트 연산: ``and_()``, ``or_()``, ``invert()``."

#: ../Doc/howto/functional.rst:1091
msgid ""
"Comparisons: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, and "
"``ge()``."
msgstr ""
"비교: ``eq()``, ``ne()``, ``lt()``, ``le()``, ``gt()``, ``ge()``."

#: ../Doc/howto/functional.rst:1092
msgid "Object identity: ``is_()``, ``is_not()``."
msgstr ""
"객체 동일성: ``is_()``, ``is_not()``."

#: ../Doc/howto/functional.rst:1094
msgid "Consult the operator module's documentation for a complete list."
msgstr ""
"전체 목록은 연산자 모듈의 문서를 참고하세요."

#: ../Doc/howto/functional.rst:1098
msgid "Small functions and the lambda expression"
msgstr ""
"작은 함수와 람다식"

#: ../Doc/howto/functional.rst:1100
msgid ""
"When writing functional-style programs, you'll often need little "
"functions that act as predicates or that combine elements in some way."
msgstr ""
"함수형 방식의 프로그램을 작성할 때, 술어로 동작하거나 어떤 식으로든 요소를 결합하는 "
"작은 함수가 필요할 것입니다."

#: ../Doc/howto/functional.rst:1103
msgid ""
"If there's a Python built-in or a module function that's suitable, you "
"don't need to define a new function at all::"
msgstr ""
"파이썬 내장 함수나 적당한 모듈 함수가 있다면, 새로운 함수를 정의할 필요가 전혀 없습니다."

#: ../Doc/howto/functional.rst:1109
msgid ""
"If the function you need doesn't exist, you need to write it.  One way to"
" write small functions is to use the :keyword:`lambda` statement.  "
"``lambda`` takes a number of parameters and an expression combining these"
" parameters, and creates an anonymous function that returns the value of "
"the expression::"
msgstr ""
"필요한 기능이 없다면 작성해야 합니다. 작은 함수를 작성하는 한 가지 방법은 :keyword:`lambda` "
"문을 사용하는 것입니다. ``lambda`` 는 여러 매개 변수와 이들 매개 변수를 결합하는 표현식을 취해 "
"표현식의 값을 반환하는 익명의 함수를 만듭니다."

#: ../Doc/howto/functional.rst:1118
msgid ""
"An alternative is to just use the ``def`` statement and define a function"
" in the usual way::"
msgstr ""
"다른 방법은 ``def`` 문을 사용하고 일반적인 방식으로 함수를 정의하는 것입니다."

#: ../Doc/howto/functional.rst:1127
msgid ""
"Which alternative is preferable?  That's a style question; my usual "
"course is to avoid using ``lambda``."
msgstr ""
"어떤 대안이 바람직할까요? 이것은 스타일에 대한 질문입니다. 필자가 평소에 사용하는 방법은 "
"``lambda`` 사용을 피하는 것입니다."

#: ../Doc/howto/functional.rst:1130
msgid ""
"One reason for my preference is that ``lambda`` is quite limited in the "
"functions it can define.  The result has to be computable as a single "
"expression, which means you can't have multiway ``if... elif... else`` "
"comparisons or ``try... except`` statements.  If you try to do too much "
"in a ``lambda`` statement, you'll end up with an overly complicated "
"expression that's hard to read.  Quick, what's the following code doing? "
"::"
msgstr ""
"필자가 선호하는 방식에 대한 이유 중 하나는 ``lambda`` 가 정의할 수 있는 기능이 상당히 "
"제한적이기 때문입니다. 결과는 단일 표현식으로 계산할 수 있어야 합니다. 즉, "
"``if... elif... else`` 비교 또는 ``try... except`` 문을 가질 수 없습니다. "
"``lambda`` 문에서 너무 많은 것을 하려고 하면, 읽기 어려운 복잡한 표현으로 끝날 것입니다. "
"다음 코드가 무엇을 하는지 빠르게 알아보세요."

#: ../Doc/howto/functional.rst:1140
msgid ""
"You can figure it out, but it takes time to disentangle the expression to"
" figure out what's going on.  Using a short nested ``def`` statements "
"makes things a little bit better::"
msgstr ""
"여러분은 이해할 수 있지만, 어떻게 동작하는지 이해하기 위해 표현식을 풀어내는 데 시간이 걸립니다. "
"짧게 중첩된 ``def`` 문을 사용하면 좀 더 나은 것을 만들 수 있습니다."

#: ../Doc/howto/functional.rst:1150
msgid "But it would be best of all if I had simply used a ``for`` loop::"
msgstr ""
"그러나 단순히 ``for`` 루프를 사용했다면 가장 좋았을 것입니다."

#: ../Doc/howto/functional.rst:1156
msgid "Or the :func:`sum` built-in and a generator expression::"
msgstr ""
"혹은 :func:`sum` 내장 함수와 제너레이터 표현식이었어도 좋았을 것입니다."

#: ../Doc/howto/functional.rst:1160
msgid ""
"Many uses of :func:`functools.reduce` are clearer when written as ``for``"
" loops."
msgstr ""
":func:`functools.reduce` 를 사용하는 많은 경우, ``for`` 루프와 같은 용도로 "
"작성되었을 때 더 명확합니다."

#: ../Doc/howto/functional.rst:1162
msgid ""
"Fredrik Lundh once suggested the following set of rules for refactoring "
"uses of ``lambda``:"
msgstr ""
"프레더릭 룬트(Fredrik Lundh)는 한때 ``lambda`` 사용법의 리팩토링을 위해 다음과 같은 "
"규칙 집합을 제안했습니다."

#: ../Doc/howto/functional.rst:1165
msgid "Write a lambda function."
msgstr "람다 함수를 작성하세요."

#: ../Doc/howto/functional.rst:1166
msgid "Write a comment explaining what the heck that lambda does."
msgstr ""
"람다가 하는 일에 관해 설명하는 글을 쓰세요."

#: ../Doc/howto/functional.rst:1167
msgid ""
"Study the comment for a while, and think of a name that captures the "
"essence of the comment."
msgstr ""
"잠깐 설명을 검토하고 설명의 본질을 포착하는 이름을 생각해보세요."

#: ../Doc/howto/functional.rst:1169
msgid "Convert the lambda to a def statement, using that name."
msgstr ""
"해당 이름을 사용하여 람다를 def 문으로 변환합니다."

#: ../Doc/howto/functional.rst:1170
msgid "Remove the comment."
msgstr ""
"설명을 삭제하세요."

#: ../Doc/howto/functional.rst:1172
msgid ""
"I really like these rules, but you're free to disagree about whether this"
" lambda-free style is better."
msgstr ""
"필자는 이 규칙을 정말 좋아하지만, 여러분은 이렇게 람다가 없는 방식이 더 나은지에 대해 동의하지 "
"않을 수 있습니다."

#: ../Doc/howto/functional.rst:1177
msgid "Revision History and Acknowledgements"
msgstr "개정내역 및 감사의 글"

#: ../Doc/howto/functional.rst:1179
msgid ""
"The author would like to thank the following people for offering "
"suggestions, corrections and assistance with various drafts of this "
"article: Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim "
"Jewett, Mike Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake "
"Winton."
msgstr ""
"필자는 이 글의 다양한 초안을 제안하고 수정하고 도와준 다음 사람들에게 감사하고 싶습니다. "
"Ian Bicking, Nick Coghlan, Nick Efford, Raymond Hettinger, Jim Jewett, "
"Mike Krell, Leandro Lameiro, Jussi Salmela, Collin Winter, Blake Winton."

#: ../Doc/howto/functional.rst:1184
msgid "Version 0.1: posted June 30 2006."
msgstr "버전 0.1: 2006년 6월 30일 게시."

#: ../Doc/howto/functional.rst:1186
msgid "Version 0.11: posted July 1 2006.  Typo fixes."
msgstr "버전 0.11: 2006년 7월 1일 게시. 오타 수정."

#: ../Doc/howto/functional.rst:1188
msgid ""
"Version 0.2: posted July 10 2006.  Merged genexp and listcomp sections "
"into one. Typo fixes."
msgstr ""
"버전 0.2: 2006년 7월 10일 게시. 제너레이터 표현식과 리스트 컴프리헨션 섹션을 하나로 통합. 오타 수정."

#: ../Doc/howto/functional.rst:1191
msgid "Version 0.21: Added more references suggested on the tutor mailing list."
msgstr ""
"버전 0.21: 튜터 메일링 리스트에서 추천된 참고 문헌을 추가."

#: ../Doc/howto/functional.rst:1193
msgid ""
"Version 0.30: Adds a section on the ``functional`` module written by "
"Collin Winter; adds short section on the operator module; a few other "
"edits."
msgstr ""
"버전 0.30: Collin Winter가 작성한 ``functional`` 모듈에 섹션 추가. 연산자 모듈에 짧은 "
"섹션 추가. 몇 가지 다른 편집."

#: ../Doc/howto/functional.rst:1198
msgid "References"
msgstr "참고 문헌"

#: ../Doc/howto/functional.rst:1201
msgid "General"
msgstr "일반"

#: ../Doc/howto/functional.rst:1203
msgid ""
"**Structure and Interpretation of Computer Programs**, by Harold Abelson "
"and Gerald Jay Sussman with Julie Sussman.  Full text at "
"https://mitpress.mit.edu/sicp/.  In this classic textbook of computer "
"science, chapters 2 and 3 discuss the use of sequences and streams to "
"organize the data flow inside a program.  The book uses Scheme for its "
"examples, but many of the design approaches described in these chapters "
"are applicable to functional-style Python code."
msgstr ""
"Harold Abelson과 Gerald Jay Sussman, Julie Sussman의 컴퓨터 프로그램 구조와 해석. "
"전체 문서는 https://mitpress.mit.edu/sicp/ 에 있습니다. 이 고전적인 컴퓨터 과학 "
"교과서에서 2장과 3장은 프로그램 내에서 데이터 흐름을 구성하기 위해 시퀀스와 스트림을 사용하는 "
"방법을 설명합니다. 이 책은 스킴(Scheme)을 예제로 사용하지만, 이 장에서 설명한 디자인 방식 중 "
"상당수는 함수형 방식 파이썬 코드에 적용할 수 있습니다."

#: ../Doc/howto/functional.rst:1211
msgid ""
"http://www.defmacro.org/ramblings/fp.html: A general introduction to "
"functional programming that uses Java examples and has a lengthy "
"historical introduction."
msgstr ""
"http://www.defmacro.org/ramblings/fp.html: 오랜 역사적 소개와 함께 자바 예제를 "
"사용한 함수형 프로그래밍에 대한 일반적인 개론."

#: ../Doc/howto/functional.rst:1214
msgid ""
"https://en.wikipedia.org/wiki/Functional_programming: General Wikipedia "
"entry describing functional programming."
msgstr ""
"https://en.wikipedia.org/wiki/Functional_programming: 함수형 프로그래밍을 "
"설명하는 일반 위키피디아 항목."

#: ../Doc/howto/functional.rst:1217
msgid "https://en.wikipedia.org/wiki/Coroutine: Entry for coroutines."
msgstr ""
"https://en.wikipedia.org/wiki/Coroutine: 코루틴에 대한 항목."

#: ../Doc/howto/functional.rst:1219
msgid "https://en.wikipedia.org/wiki/Currying: Entry for the concept of currying."
msgstr ""
"https://en.wikipedia.org/wiki/Currying: 커링 개념에 대한 항목."

#: ../Doc/howto/functional.rst:1222
msgid "Python-specific"
msgstr "파이썬 특정"

#: ../Doc/howto/functional.rst:1224
msgid ""
"http://gnosis.cx/TPiP/: The first chapter of David Mertz's book :title-"
"reference:`Text Processing in Python` discusses functional programming "
"for text processing, in the section titled \"Utilizing Higher-Order "
"Functions in Text Processing\"."
msgstr ""
"http://gnosis.cx/TPiP/: David Mertz의 책 :title-reference:`Text Processing in Python` "
"의 첫 번째 장에서는 \"텍스트 처리에서 고차 함수 활용\" 절에서 텍스트 처리를 위한 함수형 프로그래밍에 "
"관해 설명합니다."

#: ../Doc/howto/functional.rst:1229
msgid ""
"Mertz also wrote a 3-part series of articles on functional programming "
"for IBM's DeveloperWorks site; see `part 1 "
"<https://www.ibm.com/developerworks/linux/library/l-prog/index.html>`__, "
"`part 2 "
"<https://www.ibm.com/developerworks/linux/library/l-prog2/index.html>`__,"
" and `part 3 "
"<https://www.ibm.com/developerworks/linux/library/l-prog3/index.html>`__,"
msgstr ""
"Mertz는 또한 IBM의 DeveloperWorks 사이트에서 함수형 프로그래밍 기사 시리즈 3부작을 작성했습니다. `part 1 "
"<https://www.ibm.com/developerworks/linux/library/l-prog/index.html>`__, "
"`part 2 "
"<https://www.ibm.com/developerworks/linux/library/l-prog2/index.html>`__, "
"`part 3 "
"<https://www.ibm.com/developerworks/linux/library/l-prog3/index.html>`__,"

#: ../Doc/howto/functional.rst:1237
msgid "Python documentation"
msgstr "파이썬 문서"

#: ../Doc/howto/functional.rst:1239
msgid "Documentation for the :mod:`itertools` module."
msgstr ":mod:`itertools` 모듈에 대한 문서"

#: ../Doc/howto/functional.rst:1241
msgid "Documentation for the :mod:`functools` module."
msgstr ":mod:`functools` 모듈에 대한 문서"

#: ../Doc/howto/functional.rst:1243
msgid "Documentation for the :mod:`operator` module."
msgstr ":mod:`operator` 모듈에 대한 문서"

#: ../Doc/howto/functional.rst:1245
msgid ":pep:`289`: \"Generator Expressions\""
msgstr ":pep:`289`: \"제너레이터 표현식\""

#: ../Doc/howto/functional.rst:1247
msgid ""
":pep:`342`: \"Coroutines via Enhanced Generators\" describes the new "
"generator features in Python 2.5."
msgstr ""
":pep:`342`: \"강화된 제너레이터를 통한 코루틴\" 은 파이썬 2.5의 새로운 제너레이터 "
"기능을 설명합니다."

