# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-15 07:19+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: ../Doc/howto/cporting.rst:7
msgid "Porting Extension Modules to Python 3"
msgstr "확장 모듈을 파이썬 3에 이식하기"

#: ../Doc/howto/cporting.rst:9
msgid ""
"We recommend the following resources for porting extension modules to "
"Python 3:"
msgstr ""

#: ../Doc/howto/cporting.rst:11
msgid ""
"The `Migrating C extensions`_ chapter from *Supporting Python 3: An in-"
"depth guide*, a book on moving from Python 2 to Python 3 in general, "
"guides the reader through porting an extension module."
msgstr ""

#: ../Doc/howto/cporting.rst:15
msgid ""
"The `Porting guide`_ from the *py3c* project provides opinionated "
"suggestions with supporting code."
msgstr ""

#: ../Doc/howto/cporting.rst:17
msgid ""
"The `Cython`_ and `CFFI`_ libraries offer abstractions over Python's C "
"API. Extensions generally need to be re-written to use one of them, but "
"the library then handles differences between various Python versions and "
"implementations."
msgstr ""

#~ msgid "author"
#~ msgstr "저자"

#~ msgid "Benjamin Peterson"
#~ msgstr "Benjamin Peterson"

#~ msgid "Abstract"
#~ msgstr "요약"

#~ msgid ""
#~ "Although changing the C-API was not "
#~ "one of Python 3's objectives, the "
#~ "many Python-level changes made leaving"
#~ " Python 2's API intact impossible.  "
#~ "In fact, some changes such as "
#~ ":func:`int` and :func:`long` unification are"
#~ " more obvious on the C level.  "
#~ "This document endeavors to document "
#~ "incompatibilities and how they can be"
#~ " worked around."
#~ msgstr ""
#~ "C-API를 변경하는 것이 파이썬 3의 목표 중 "
#~ "하나는 아니었지만, 파이썬 수준의 많은 변경으로 인해 "
#~ "파이썬 2의 API를 그대로 남겨두는 것은 불가능했습니다."
#~ " 사실, :func:`int`\\와 :func:`long` 통합과 같은 "
#~ "일부 변경 사항은 C 수준에서 더 분명합니다. 이"
#~ " 문서는 비 호환성을 기록으로 남기고 그 문제를 "
#~ "해결하는 방법을 설명합니다."

#~ msgid "Conditional compilation"
#~ msgstr "조건부 컴파일"

#~ msgid ""
#~ "The easiest way to compile only "
#~ "some code for Python 3 is to "
#~ "check if :c:macro:`PY_MAJOR_VERSION` is "
#~ "greater than or equal to 3. ::"
#~ msgstr ""
#~ "어떤 코드를 파이썬 3에서만 컴파일하는 가장 쉬운 "
#~ "방법은 :c:macro:`PY_MAJOR_VERSION`\\이 3 이상인지 확인하는"
#~ " 것입니다. ::"

#~ msgid ""
#~ "API functions that are not present "
#~ "can be aliased to their equivalents "
#~ "within conditional blocks."
#~ msgstr "존재하지 않는 API 함수는 조건 블록 내에서 동등한 것으로 별칭을 만들 수 있습니다."

#~ msgid "Changes to Object APIs"
#~ msgstr "객체 API의 변경 사항"

#~ msgid ""
#~ "Python 3 merged together some types "
#~ "with similar functions while cleanly "
#~ "separating others."
#~ msgstr "파이썬 3은 비슷한 기능을 가진 일부 형을 병합하면서 다른 것들은 깨끗하게 분리합니다."

#~ msgid "str/unicode Unification"
#~ msgstr "str/unicode 통합"

#~ msgid ""
#~ "Python 3's :func:`str` type is "
#~ "equivalent to Python 2's :func:`unicode`; "
#~ "the C functions are called "
#~ "``PyUnicode_*`` for both.  The old 8-bit"
#~ " string type has become :func:`bytes`, "
#~ "with C functions called ``PyBytes_*``.  "
#~ "Python 2.6 and later provide a "
#~ "compatibility header, :file:`bytesobject.h`, mapping"
#~ " ``PyBytes`` names to ``PyString`` ones."
#~ "  For best compatibility with Python "
#~ "3, :c:type:`PyUnicode` should be used "
#~ "for textual data and :c:type:`PyBytes` "
#~ "for binary data.  It's also important"
#~ " to remember that :c:type:`PyBytes` and "
#~ ":c:type:`PyUnicode` in Python 3 are not"
#~ " interchangeable like :c:type:`PyString` and "
#~ ":c:type:`PyUnicode` are in Python 2.  "
#~ "The following example shows best "
#~ "practices with regards to :c:type:`PyUnicode`,"
#~ " :c:type:`PyString`, and :c:type:`PyBytes`. ::"
#~ msgstr ""
#~ "파이썬 3의 :func:`str` 형은 파이썬 2의 "
#~ ":func:`unicode`\\와 동등합니다; C 함수는 모두 "
#~ "``PyUnicode_*``\\입니다. 이전의 8비트 문자열형은 "
#~ ":func:`bytes`\\가 되었고, C 함수는 ``PyBytes_*``\\가"
#~ " 되었습니다. 파이썬 2.6 이상은 호환성 헤더 "
#~ ":file:`bytesobject.h`\\를 제공하며, ``PyBytes`` 이름을 "
#~ "``PyString`` 으로 매핑합니다. 파이썬 3과의 최상의 "
#~ "호환성을 위해, 텍스트 데이터에는 :c:type:`PyUnicode`\\를, "
#~ "바이너리 데이터에는 :c:type:`PyBytes`\\를 사용해야 합니다. "
#~ "파이썬 3의 :c:type:`PyBytes`\\와 :c:type:`PyUnicode`\\가"
#~ " 파이썬 2의 :c:type:`PyString`\\과 "
#~ ":c:type:`PyUnicode`\\처럼 교환할 수 없다는 것을 "
#~ "기억하는 것도 중요합니다. 다음 예는 "
#~ ":c:type:`PyUnicode`, :c:type:`PyString` 및 "
#~ ":c:type:`PyBytes`\\에 대한 모범 사례를 보여줍니다. ::"

#~ msgid "long/int Unification"
#~ msgstr "long/int 통합"

#~ msgid ""
#~ "Python 3 has only one integer "
#~ "type, :func:`int`.  But it actually "
#~ "corresponds to Python 2's :func:`long` "
#~ "type—the :func:`int` type used in Python"
#~ " 2 was removed.  In the C-API, "
#~ "``PyInt_*`` functions are replaced by "
#~ "their ``PyLong_*`` equivalents."
#~ msgstr ""
#~ "파이썬 3은 오직 하나의 정수형 :func:`int`\\만을 "
#~ "가집니다. 그러나 이것은 실제로 파이썬 2의 "
#~ ":func:`long` 형에 해당합니다 - 파이썬 2에서 "
#~ "사용된 :func:`int` 형은 제거되었습니다. C-API에서, "
#~ "``PyInt_*`` 함수는 동등한 ``PyLong_*`` 함수로 "
#~ "대체됩니다."

#~ msgid "Module initialization and state"
#~ msgstr "모듈 초기화와 상태"

#~ msgid ""
#~ "Python 3 has a revamped extension "
#~ "module initialization system.  (See "
#~ ":pep:`3121`.)  Instead of storing module "
#~ "state in globals, they should be "
#~ "stored in an interpreter specific "
#~ "structure.  Creating modules that act "
#~ "correctly in both Python 2 and "
#~ "Python 3 is tricky.  The following "
#~ "simple example demonstrates how. ::"
#~ msgstr ""
#~ "파이썬 3에는 개선된 확장 모듈 초기화 시스템이 "
#~ "있습니다. (:pep:`3121`\\를 참조하십시오.) 모듈 상태를 "
#~ "전역에 저장하는 대신, 인터프리터별 구조체에 저장해야 합니다."
#~ " 파이썬 2와 파이썬 3 모두에서 올바르게 동작하는"
#~ " 모듈을 만드는 것은 까다 롭습니다. 다음의 간단한"
#~ " 예제는 방법을 보여줍니다. ::"

#~ msgid "CObject replaced with Capsule"
#~ msgstr "캡슐로 대체된 CObject"

#~ msgid ""
#~ "The :c:type:`Capsule` object was introduced"
#~ " in Python 3.1 and 2.7 to "
#~ "replace :c:type:`CObject`.  CObjects were "
#~ "useful, but the :c:type:`CObject` API "
#~ "was problematic: it didn't permit "
#~ "distinguishing between valid CObjects, which"
#~ " allowed mismatched CObjects to crash "
#~ "the interpreter, and some of its "
#~ "APIs relied on undefined behavior in "
#~ "C. (For further reading on the "
#~ "rationale behind Capsules, please see "
#~ ":issue:`5630`.)"
#~ msgstr ""
#~ ":c:type:`Capsule` 객체는 :c:type:`CObject`\\를 대체하기 "
#~ "위해 파이썬 3.1과 2.7에 도입되었습니다. CObject는 "
#~ "유용했지만, :c:type:`CObject` API는 문제가 있었습니다: "
#~ "유효한 CObject를 구분할 수 없어서 불일치한 "
#~ "CObject가 인터프리터에 충돌을 일으킬 수 있도록 했고,"
#~ " 일부 API는 C의 정의되지 않은 동작에 의존했습니다."
#~ " (캡슐을 뒷받침하는 이유에 대한 자세한 내용은 "
#~ ":issue:`5630`\\를 참조하십시오.)"

#~ msgid ""
#~ "If you're currently using CObjects, and"
#~ " you want to migrate to 3.1 or"
#~ " newer, you'll need to switch to "
#~ "Capsules. :c:type:`CObject` was deprecated in"
#~ " 3.1 and 2.7 and completely removed"
#~ " in Python 3.2.  If you only "
#~ "support 2.7, or 3.1 and above, you"
#~ " can simply switch to :c:type:`Capsule`."
#~ "  If you need to support Python "
#~ "3.0, or versions of Python earlier "
#~ "than 2.7, you'll have to support "
#~ "both CObjects and Capsules. (Note that"
#~ " Python 3.0 is no longer supported,"
#~ " and it is not recommended for "
#~ "production use.)"
#~ msgstr ""
#~ "현재 CObject를 사용하고 있고, 3.1 이상으로 "
#~ "이전하려고 한다면, 캡슐로 전환해야 합니다. "
#~ ":c:type:`CObject`\\는 3.1과 2.7에서 폐지되었고, 파이썬 "
#~ "3.2에서 완전히 제거되었습니다. 2.7이나 3.1 이상만 "
#~ "지원한다면, 단순히 :c:type:`Capsule`\\로 전환할 수 "
#~ "있습니다. 파이썬 3.0이나 2.7 이전의 파이썬 버전을"
#~ " 지원해야 한다면, CObject와 캡슐을 모두 지원해야 "
#~ "합니다. (파이썬 3.0은 더는 지원되지 않으며 프로덕션"
#~ " 용도로 권장되지 않음에 유의하십시오.)"

#~ msgid ""
#~ "The following example header file "
#~ ":file:`capsulethunk.h` may solve the problem"
#~ " for you.  Simply write your code "
#~ "against the :c:type:`Capsule` API and "
#~ "include this header file after "
#~ ":file:`Python.h`.  Your code will "
#~ "automatically use Capsules in versions "
#~ "of Python with Capsules, and switch "
#~ "to CObjects when Capsules are "
#~ "unavailable."
#~ msgstr ""
#~ "다음 예제 헤더 파일 :file:`capsulethunk.h`\\는 "
#~ "문제를 해결할 수 있습니다. :c:type:`Capsule` API로"
#~ " 코드를 작성하고, :file:`Python.h` 다음에 이 헤더"
#~ " 파일을 포함하십시오. 여러분의 코드는 자동으로 캡슐이 "
#~ "있는 파이썬 버전에서 캡슐을 사용하고, 캡슐을 사용할 "
#~ "수 없을 때 CObject로 전환합니다."

#~ msgid ""
#~ ":file:`capsulethunk.h` simulates Capsules using "
#~ "CObjects.  However, :c:type:`CObject` provides "
#~ "no place to store the capsule's "
#~ "\"name\".  As a result the simulated "
#~ ":c:type:`Capsule` objects created by "
#~ ":file:`capsulethunk.h` behave slightly differently"
#~ " from real Capsules.  Specifically:"
#~ msgstr ""
#~ ":file:`capsulethunk.h`\\는 CObject를 사용하여 캡슐을 "
#~ "시뮬레이션합니다. 그러나, :c:type:`CObject`\\는 캡슐의 "
#~ "\"이름(name)\"을 저장할 장소를 제공하지 않습니다. 결과적으로"
#~ " :file:`capsulethunk.h`\\가 만든 시뮬레이트 된 "
#~ ":c:type:`Capsule` 객체는 실제 캡슐과 약간 다르게 "
#~ "동작합니다. 구체적으로:"

#~ msgid "The name parameter passed in to :c:func:`PyCapsule_New` is ignored."
#~ msgstr ":c:func:`PyCapsule_New`\\에 전달된 name 매개 변수는 무시됩니다."

#~ msgid ""
#~ "The name parameter passed in to "
#~ ":c:func:`PyCapsule_IsValid` and "
#~ ":c:func:`PyCapsule_GetPointer` is ignored, and "
#~ "no error checking of the name is"
#~ " performed."
#~ msgstr ""
#~ ":c:func:`PyCapsule_IsValid` 와 "
#~ ":c:func:`PyCapsule_GetPointer`\\에 전달된 name 매개 "
#~ "변수는 무시되며, name에 대한 에러 검사는 수행되지 "
#~ "않습니다."

#~ msgid ":c:func:`PyCapsule_GetName` always returns NULL."
#~ msgstr ":c:func:`PyCapsule_GetName`\\은 항상 NULL을 반환합니다."

#~ msgid ""
#~ ":c:func:`PyCapsule_SetName` always raises an "
#~ "exception and returns failure.  (Since "
#~ "there's no way to store a name "
#~ "in a CObject, noisy failure of "
#~ ":c:func:`PyCapsule_SetName` was deemed preferable"
#~ " to silent failure here.  If this "
#~ "is inconvenient, feel free to modify "
#~ "your local copy as you see fit.)"
#~ msgstr ""
#~ ":c:func:`PyCapsule_SetName`\\은 항상 예외를 발생시키고 "
#~ "실패를 반환합니다. (CObject에 이름을 저장할 수 있는"
#~ " 방법이 없으므로, 여기서 조용한 실패보다 요란한 "
#~ ":c:func:`PyCapsule_SetName`\\의 실패를 선호합니다. 이것이 "
#~ "불편하다면, 적절하다고 생각하는 대로 로컬 복사본을 자유롭게"
#~ " 수정하십시오.)"

#~ msgid ""
#~ "You can find :file:`capsulethunk.h` in "
#~ "the Python source distribution as "
#~ ":source:`Doc/includes/capsulethunk.h`.  We also "
#~ "include it here for your convenience:"
#~ msgstr ""
#~ ":file:`capsulethunk.h`\\는 파이썬 소스 배포판의 "
#~ ":source:`Doc/includes/capsulethunk.h`\\에서 찾을 수 있습니다."
#~ " 여러분의 편의를 위해 여기에도 포함합니다:"

#~ msgid "Other options"
#~ msgstr "다른 옵션"

#~ msgid ""
#~ "If you are writing a new extension"
#~ " module, you might consider `Cython "
#~ "<http://cython.org/>`_.  It translates a "
#~ "Python-like language to C.  The "
#~ "extension modules it creates are "
#~ "compatible with Python 3 and Python "
#~ "2."
#~ msgstr ""
#~ "새 확장 모듈을 작성하고 있다면, `Cython "
#~ "<http://cython.org/>`_\\을 고려하십시오. 파이썬과 비슷한 언어를"
#~ " C로 변환합니다. 만들어진 확장 모듈은 파이썬 3과"
#~ " 파이썬 2 모두와 호환됩니다."

