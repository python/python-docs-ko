# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 11:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/howto/logging-cookbook.rst:5
msgid "Logging Cookbook"
msgstr "로깅 요리책"

#: ../Doc/howto/logging-cookbook.rst
msgid "Author"
msgstr "저자"

#: ../Doc/howto/logging-cookbook.rst:7
msgid "Vinay Sajip <vinay_sajip at red-dove dot com>"
msgstr "Vinay Sajip <vinay_sajip at red-dove dot com>"

#: ../Doc/howto/logging-cookbook.rst:9
msgid ""
"This page contains a number of recipes related to logging, which have "
"been found useful in the past."
msgstr "이 페이지는 과거에 유용했던 로깅 관련 조리법을 많이 포함하고 있습니다."

#: ../Doc/howto/logging-cookbook.rst:15
msgid "Using logging in multiple modules"
msgstr "여러 모듈에서 로깅 사용하기"

#: ../Doc/howto/logging-cookbook.rst:17
msgid ""
"Multiple calls to ``logging.getLogger('someLogger')`` return a reference "
"to the same logger object.  This is true not only within the same module,"
" but also across modules as long as it is in the same Python interpreter "
"process.  It is true for references to the same object; additionally, "
"application code can define and configure a parent logger in one module "
"and create (but not configure) a child logger in a separate module, and "
"all logger calls to the child will pass up to the parent.  Here is a main"
" module::"
msgstr ""
"``logging.getLogger('someLogger')`` 를 여러 번 호출하면 같은 로거 객체에 대한 참조가 반환됩니다. 같은 "
"모듈 내에서뿐만 아니라, 같은 파이썬 인터프리터 프로세스에 있는 한, 여러 모듈에서도 마찬가지입니다. 참조가 같은 객체를 가리킨다는 것에"
" 더해, 응용 프로그램 코드는 하나의 모듈에서 부모 로거를 정의 및 구성하고 별도의 모듈에서 자식 로거를 생성 (구성하지 않음) 할 수 "
"있으며, 자식에 대한 모든 로거 호출은 부모로 전달됩니다. 다음은 메인 모듈입니다::"

#: ../Doc/howto/logging-cookbook.rst:55
msgid "Here is the auxiliary module::"
msgstr "다음은 보조 모듈입니다::"

#: ../Doc/howto/logging-cookbook.rst:75
msgid "The output looks like this:"
msgstr "출력은 이렇게 됩니다:"

#: ../Doc/howto/logging-cookbook.rst:101
msgid "Logging from multiple threads"
msgstr "여러 스레드에서 로깅 하기"

#: ../Doc/howto/logging-cookbook.rst:103
msgid ""
"Logging from multiple threads requires no special effort. The following "
"example shows logging from the main (initial) thread and another thread::"
msgstr ""
"여러 스레드에서 로깅 하는데 특별한 노력이 필요하지는 않습니다. 다음 예제에서는 메인 (최초) 스레드와 다른 스레드에서의 로깅을 "
"보여줍니다::"

#: ../Doc/howto/logging-cookbook.rst:132
msgid "When run, the script should print something like the following:"
msgstr "실행하면 스크립트는 다음과 같이 인쇄합니다:"

#: ../Doc/howto/logging-cookbook.rst:154
msgid ""
"This shows the logging output interspersed as one might expect. This "
"approach works for more threads than shown here, of course."
msgstr "예상대로 로그 출력이 산재해 있음을 볼 수 있습니다. 물론, 이 방법은 여기에 표시된 것보다 많은 스레드에서도 작동합니다."

#: ../Doc/howto/logging-cookbook.rst:158
msgid "Multiple handlers and formatters"
msgstr "다중 처리기 및 포매터"

#: ../Doc/howto/logging-cookbook.rst:160
msgid ""
"Loggers are plain Python objects.  The :meth:`~Logger.addHandler` method "
"has no minimum or maximum quota for the number of handlers you may add.  "
"Sometimes it will be beneficial for an application to log all messages of"
" all severities to a text file while simultaneously logging errors or "
"above to the console.  To set this up, simply configure the appropriate "
"handlers.  The logging calls in the application code will remain "
"unchanged.  Here is a slight modification to the previous simple module-"
"based configuration example::"
msgstr ""
"로거는 일반 파이썬 객체입니다. :meth:`~Logger.addHandler` 메서드에는 추가할 수 있는 처리기의 수에 대한 최소 또는"
" 최대 할당량이 없습니다. 때로는 응용 프로그램이 모든 심각도의 모든 메시지를 텍스트 파일에 기록하는 동시에, 에러 또는 그 이상을 "
"콘솔에 기록하는 것이 유용 할 수 있습니다. 이렇게 설정하려면, 적절한 처리기를 구성하기만 하면 됩니다. 응용 프로그램 코드의 로깅 "
"호출은 변경되지 않습니다. 다음은 앞의 간단한 모듈 기반 구성 예제를 약간 수정 한 것입니다::"

#: ../Doc/howto/logging-cookbook.rst:193
msgid ""
"Notice that the 'application' code does not care about multiple handlers."
"  All that changed was the addition and configuration of a new handler "
"named *fh*."
msgstr ""
"'응용 프로그램' 코드는 여러 처리기에 신경 쓰지 않습니다. 변경된 것은 *fh* 라는 새로운 처리기의 추가 및 구성뿐입니다."

#: ../Doc/howto/logging-cookbook.rst:196
msgid ""
"The ability to create new handlers with higher- or lower-severity filters"
" can be very helpful when writing and testing an application.  Instead of"
" using many ``print`` statements for debugging, use ``logger.debug``: "
"Unlike the print statements, which you will have to delete or comment out"
" later, the logger.debug statements can remain intact in the source code "
"and remain dormant until you need them again.  At that time, the only "
"change that needs to happen is to modify the severity level of the logger"
" and/or handler to debug."
msgstr ""
"중요도가 높거나 낮은 필터를 사용하여 새 처리기를 만드는 기능은 응용 프로그램을 작성하고 테스트할 때 매우 유용합니다. 디버깅을 위해 "
"많은 ``print`` 문을 사용하는 대신에 ``logger.debug`` 를 사용하십시오: 나중에 삭제하거나 주석 처리해야 할 "
"print 문과 달리, logger.debug 문은 소스 코드에서 그대로 유지될 수 있고, 그들을 다시 필요로 할 때까지 휴면 상태로 "
"남아 있습니다. 그때, 필요한 유일한 변경은 로거 또는 처리기의 심각도 수준을 DEBUG로 수정하는 것입니다."

#: ../Doc/howto/logging-cookbook.rst:207
msgid "Logging to multiple destinations"
msgstr "여러 대상으로 로깅 하기"

#: ../Doc/howto/logging-cookbook.rst:209
msgid ""
"Let's say you want to log to console and file with different message "
"formats and in differing circumstances. Say you want to log messages with"
" levels of DEBUG and higher to file, and those messages at level INFO and"
" higher to the console. Let's also assume that the file should contain "
"timestamps, but the console messages should not. Here's how you can "
"achieve this::"
msgstr ""
"다른 메시지 포맷으로 다른 상황에서 콘솔과 파일에 기록하려고 한다고 가정 해 봅시다. DEBUG 이상 수준의 메시지를 파일에 기록하고, "
"수준 INFO 이상인 메시지를 콘솔에 기록하려고 한다고 가정 해보십시오. 또한, 타임스탬프가 파일에는 포함되어야 하지만, 콘솔 메시지에는"
" 없어야 한다고 가정합시다. 이렇게 하면 됩니다::"

#: ../Doc/howto/logging-cookbook.rst:247
msgid "When you run this, on the console you will see"
msgstr "실행하면 콘솔에는 다음과 같이 출력됩니다."

#: ../Doc/howto/logging-cookbook.rst:256
msgid "and in the file you will see something like"
msgstr "파일에는 이렇게 기록됩니다."

#: ../Doc/howto/logging-cookbook.rst:266
msgid ""
"As you can see, the DEBUG message only shows up in the file. The other "
"messages are sent to both destinations."
msgstr "보시다시피 DEBUG 메시지는 파일에만 표시됩니다. 다른 메시지는 두 목적지로 전송됩니다."

#: ../Doc/howto/logging-cookbook.rst:269
msgid ""
"This example uses console and file handlers, but you can use any number "
"and combination of handlers you choose."
msgstr "이 예제는 콘솔과 파일 처리기를 사용하지만, 여러분이 선택하는 처리기의 수나 조합에 제약이 없습니다."

#: ../Doc/howto/logging-cookbook.rst:274
msgid "Configuration server example"
msgstr "구성 서버 예제"

#: ../Doc/howto/logging-cookbook.rst:276
msgid "Here is an example of a module using the logging configuration server::"
msgstr "다음은 로깅 구성 서버를 사용하는 모듈의 예입니다::"

#: ../Doc/howto/logging-cookbook.rst:307
msgid ""
"And here is a script that takes a filename and sends that file to the "
"server, properly preceded with the binary-encoded length, as the new "
"logging configuration::"
msgstr ""
"다음은 파일 이름을 받아서, 그 파일을 새 로깅 구성으로 (이진 인코딩된 길이를 적절하게 앞에 붙여서) 서버로 보내는 스크립트입니다::"

#: ../Doc/howto/logging-cookbook.rst:330
msgid "Dealing with handlers that block"
msgstr "블록 하는 처리기 다루기"

#: ../Doc/howto/logging-cookbook.rst:334
msgid ""
"Sometimes you have to get your logging handlers to do their work without "
"blocking the thread you're logging from. This is common in Web "
"applications, though of course it also occurs in other scenarios."
msgstr ""
"때로는 로깅 처리기가 로깅 중인 스레드를 블록 하지 않고 작업을 수행해야 하는 경우가 있습니다. 이것은 웹 응용 프로그램에서 흔히 "
"나타나는 요구사항이지만, 물론 다른 시나리오에서도 발생합니다."

#: ../Doc/howto/logging-cookbook.rst:338
msgid ""
"A common culprit which demonstrates sluggish behaviour is the "
":class:`SMTPHandler`: sending emails can take a long time, for a number "
"of reasons outside the developer's control (for example, a poorly "
"performing mail or network infrastructure). But almost any network-based "
"handler can block: Even a :class:`SocketHandler` operation may do a DNS "
"query under the hood which is too slow (and this query can be deep in the"
" socket library code, below the Python layer, and outside your control)."
msgstr ""
"흔히 느린 행동을 보이는 범인은 :class:`SMTPHandler` 입니다: 개발자의 통제 밖에 있는 여러 가지 이유로, 이메일을 "
"보내는 데 오랜 시간이 걸릴 수 있습니다 (예를 들어, 잘 동작하지 않는 메일 또는 네트워크 인프라). 그러나 거의 모든 네트워크 기반 "
"처리기는 블록 할 수 있습니다. :class:`SocketHandler` 작업도 너무 느린 DNS 질의를 이면에서 수행 할 수 있습니다 "
"(그리고 이 질의는 여러분의 통제 밖에 있는, 파이썬 계층 아래의 소켓 라이브러리 코드 깊숙이 있을 수 있습니다)."

#: ../Doc/howto/logging-cookbook.rst:346
msgid ""
"One solution is to use a two-part approach. For the first part, attach "
"only a :class:`QueueHandler` to those loggers which are accessed from "
"performance-critical threads. They simply write to their queue, which can"
" be sized to a large enough capacity or initialized with no upper bound "
"to their size. The write to the queue will typically be accepted quickly,"
" though you will probably need to catch the :exc:`queue.Full` exception "
"as a precaution in your code. If you are a library developer who has "
"performance-critical threads in their code, be sure to document this "
"(together with a suggestion to attach only ``QueueHandlers`` to your "
"loggers) for the benefit of other developers who will use your code."
msgstr ""
"한 가지 해결책은 두 부분으로 된 접근법을 사용하는 것입니다. 첫 번째 부분에서는, 성능이 중요한 스레드에서 액세스하는 로거에 "
":class:`QueueHandler` 만 붙입니다. 그들은 단순히 큐에 씁니다. 충분한 용량으로 큐의 크기를 조정하거나, 크기의 상한이"
" 없도록 초기화 할 수 있습니다. 큐에 대한 쓰기는 일반적으로 신속하게 받아들여지지만, 코드에서 예방책으로 "
":exc:`queue.Full` 예외를 잡아야 할 것입니다. 코드에 성능이 중요한 스레드가 있는 라이브러리 개발자인 경우, 코드를 사용할"
" 다른 개발자의 이익을 위해 이것을 (여러분의 로거에 ``QueueHandlers`` 만 붙이라는 제안과 함께) 문서로 만들어야 합니다."

#: ../Doc/howto/logging-cookbook.rst:357
msgid ""
"The second part of the solution is :class:`QueueListener`, which has been"
" designed as the counterpart to :class:`QueueHandler`.  A "
":class:`QueueListener` is very simple: it's passed a queue and some "
"handlers, and it fires up an internal thread which listens to its queue "
"for LogRecords sent from ``QueueHandlers`` (or any other source of "
"``LogRecords``, for that matter). The ``LogRecords`` are removed from the"
" queue and passed to the handlers for processing."
msgstr ""
"해결책의 두 번째 부분은 :class:`QueueListener`\\며, 이는 :class:`QueueHandler` 에 상응하여 "
"설계되었습니다. :class:`QueueListener` 는 매우 간단합니다: 큐와 처리기를 넘겨주면 ``QueueHandlers`` "
"(또는 ``LogRecords`` 의 다른 소스)에서 보낸 LogRecord를 큐에서 수신하는 내부 스레드를 시작합니다. "
"``LogRecords`` 는 큐에서 제거되고 처리를 위해 처리기로 전달됩니다."

#: ../Doc/howto/logging-cookbook.rst:365
msgid ""
"The advantage of having a separate :class:`QueueListener` class is that "
"you can use the same instance to service multiple ``QueueHandlers``. This"
" is more resource-friendly than, say, having threaded versions of the "
"existing handler classes, which would eat up one thread per handler for "
"no particular benefit."
msgstr ""
"별도의 :class:`QueueListener` 클래스를 사용하면 같은 인스턴스를 사용하여 여러 개의 ``QueueHandlers`` 를"
" 처리할 수 ​​있다는 장점이 있습니다. 이것은 특별한 이점 없이 처리기당 하나의 스레드를 먹게 되는 기존의 처리기 클래스의 스레드 "
"버전을 만드는 것보다 자원 친화적입니다."

#: ../Doc/howto/logging-cookbook.rst:370
msgid "An example of using these two classes follows (imports omitted)::"
msgstr "이 두 클래스를 사용하는 예제는 다음과 같습니다 (임포트 생략)::"

#: ../Doc/howto/logging-cookbook.rst:388
msgid "which, when run, will produce:"
msgstr "실행하면, 다음과 같은 결과를 만듭니다:"

#: ../Doc/howto/logging-cookbook.rst:394
msgid ""
"Prior to Python 3.5, the :class:`QueueListener` always passed every "
"message received from the queue to every handler it was initialized with."
" (This was because it was assumed that level filtering was all done on "
"the other side, where the queue is filled.) From 3.5 onwards, this "
"behaviour can be changed by passing a keyword argument "
"``respect_handler_level=True`` to the listener's constructor. When this "
"is done, the listener compares the level of each message with the "
"handler's level, and only passes a message to a handler if it's "
"appropriate to do so."
msgstr ""
"파이썬 3.5 이전 버전에서는, :class:`QueueListener` 는 항상 큐에서 받은 모든 메시지를 초기화될 때 제공된 모든 "
"처리기로 전달했습니다. (이것은 큐가 채워질 때 수준 필터링이 모두 반대편에서 행해졌다고 가정했기 때문입니다.) 3.5 이후부터, 이 "
"동작은 키워드 인자 ``respect_handler_level=True`` 를 리스너의 생성자에 전달함으로써 변경될 수 있습니다. 이렇게"
" 할 때, 리스너는 각 메시지의 수준을 처리기의 수준과 비교하여, 적절한 메시지만 처리기에 전달되도록 합니다."

#: ../Doc/howto/logging-cookbook.rst:407
msgid "Sending and receiving logging events across a network"
msgstr "네트워크에서 로깅 이벤트 보내고 받기"

#: ../Doc/howto/logging-cookbook.rst:409
msgid ""
"Let's say you want to send logging events across a network, and handle "
"them at the receiving end. A simple way of doing this is attaching a "
":class:`SocketHandler` instance to the root logger at the sending end::"
msgstr ""
"네트워크를 통해 로깅 이벤트를 보내고, 받는 쪽에서 처리하려고 한다고 합시다. 이렇게 하는 간단한 방법은 "
":class:`SocketHandler` 인스턴스를 보내는 쪽의 루트 로거에 연결하는 것입니다::"

#: ../Doc/howto/logging-cookbook.rst:437
msgid ""
"At the receiving end, you can set up a receiver using the "
":mod:`socketserver` module. Here is a basic working example::"
msgstr ""
"수신 측에서는 :mod:`socketserver` 모듈을 사용하여 수신기를 구성할 수 있습니다. 기본적인 작업 예제는 다음과 같습니다::"

#: ../Doc/howto/logging-cookbook.rst:525
msgid ""
"First run the server, and then the client. On the client side, nothing is"
" printed on the console; on the server side, you should see something "
"like:"
msgstr ""
"먼저 서버를 실행한 다음 클라이언트를 실행합니다. 클라이언트 쪽에서는 콘솔에 아무것도 인쇄되지 않습니다. 서버 측에서 다음과 같은 내용이"
" 보여야 합니다.:"

#: ../Doc/howto/logging-cookbook.rst:537
msgid ""
"Note that there are some security issues with pickle in some scenarios. "
"If these affect you, you can use an alternative serialization scheme by "
"overriding the :meth:`~handlers.SocketHandler.makePickle` method and "
"implementing your alternative there, as well as adapting the above script"
" to use your alternative serialization."
msgstr ""
"일부 시나리오에서는 피클이 몇 가지 보안 문제를 수반함에 유의하십시오. 이 문제가 중요하면, "
":meth:`~handlers.SocketHandler.makePickle` 메서드를 재정의하고 거기서 여러분의 대안을 구현해서 다른 "
"직렬화를 사용하는 한편, 위의 스크립트가 그 직렬화를 사용하도록 수정하십시오."

#: ../Doc/howto/logging-cookbook.rst:547
msgid "Adding contextual information to your logging output"
msgstr "로그 출력에 문맥 정보 추가"

#: ../Doc/howto/logging-cookbook.rst:549
msgid ""
"Sometimes you want logging output to contain contextual information in "
"addition to the parameters passed to the logging call. For example, in a "
"networked application, it may be desirable to log client-specific "
"information in the log (e.g. remote client's username, or IP address). "
"Although you could use the *extra* parameter to achieve this, it's not "
"always convenient to pass the information in this way. While it might be "
"tempting to create :class:`Logger` instances on a per-connection basis, "
"this is not a good idea because these instances are not garbage "
"collected. While this is not a problem in practice, when the number of "
":class:`Logger` instances is dependent on the level of granularity you "
"want to use in logging an application, it could be hard to manage if the "
"number of :class:`Logger` instances becomes effectively unbounded."
msgstr ""
"로깅 호출에 전달된 매개 변수 외에도 로깅 출력에 문맥 정보가 포함되기 원하는 경우가 있습니다. 예를 들어, 네트워크 응용 프로그램에서,"
" (원격 클라이언트의 사용자 이름 또는 IP 주소와 같은) 클라이언트별 정보를 로그에 기록하는 것이 바람직 할 수 있습니다. 이를 "
"달성하기 위해 *extra* 매개 변수를 사용할 수는 있지만, 이러한 방식으로 정보를 전달하는 것이 항상 편리하지는 않습니다. 연결마다 "
":class:`Logger` 인스턴스를 만들고 싶을지 모르지만, 이러한 인스턴스는 가비지 수집되지 않기 때문에 좋지 않습니다. "
":class:`Logger` 인스턴스의 수가 응용 프로그램 로깅에 사용하고자 하는 세분성 수준에 의존적일 때 이것이 실제로 문제가 되지는"
" 않지만, :class:`Logger` 인스턴스의 수가 실질적으로 무제한이 되면 관리하기 어려울 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:564
msgid "Using LoggerAdapters to impart contextual information"
msgstr "문맥 정보 전달에 LoggerAdapters 사용하기"

#: ../Doc/howto/logging-cookbook.rst:566
msgid ""
"An easy way in which you can pass contextual information to be output "
"along with logging event information is to use the :class:`LoggerAdapter`"
" class. This class is designed to look like a :class:`Logger`, so that "
"you can call :meth:`debug`, :meth:`info`, :meth:`warning`, :meth:`error`,"
" :meth:`exception`, :meth:`critical` and :meth:`log`. These methods have "
"the same signatures as their counterparts in :class:`Logger`, so you can "
"use the two types of instances interchangeably."
msgstr ""
"로깅 이벤트 정보와 함께 출력되는 문맥 정보를 전달하는 쉬운 방법은 :class:`LoggerAdapter` 클래스를 사용하는 것입니다."
" 이 클래스는 :class:`Logger`\\처럼 보이도록 설계되어 있어서, :meth:`debug`, :meth:`info`, "
":meth:`warning`, :meth:`error`, :meth:`exception`, :meth:`critical` 및 "
":meth:`log`\\를 호출할 수 있습니다. 이 메서드들은 :class:`Logger` 에 있는 것과 똑같은 서명을 가지므로, 두 "
"형의 인스턴스를 같은 의미로 사용할 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:574
msgid ""
"When you create an instance of :class:`LoggerAdapter`, you pass it a "
":class:`Logger` instance and a dict-like object which contains your "
"contextual information. When you call one of the logging methods on an "
"instance of :class:`LoggerAdapter`, it delegates the call to the "
"underlying instance of :class:`Logger` passed to its constructor, and "
"arranges to pass the contextual information in the delegated call. Here's"
" a snippet from the code of :class:`LoggerAdapter`::"
msgstr ""
":class:`LoggerAdapter` 의 인스턴스를 생성할 때, :class:`Logger` 인스턴스와 문맥 정보가 포함된 딕셔너리류"
" 객체를 전달합니다. :class:`LoggerAdapter` 의 인스턴스에서 로깅 메서드 중 하나를 호출하면, 생성자에 전달된 하위 "
":class:`Logger` 인스턴스에 호출을 위임하고, 이 호출에 문맥 정보를 전달하도록 배치합니다. 다음은 "
":class:`LoggerAdapter` 코드에서 발췌한 내용입니다::"

#: ../Doc/howto/logging-cookbook.rst:590
msgid ""
"The :meth:`~LoggerAdapter.process` method of :class:`LoggerAdapter` is "
"where the contextual information is added to the logging output. It's "
"passed the message and keyword arguments of the logging call, and it "
"passes back (potentially) modified versions of these to use in the call "
"to the underlying logger. The default implementation of this method "
"leaves the message alone, but inserts an 'extra' key in the keyword "
"argument whose value is the dict-like object passed to the constructor. "
"Of course, if you had passed an 'extra' keyword argument in the call to "
"the adapter, it will be silently overwritten."
msgstr ""
":class:`LoggerAdapter` 의 :meth:`~LoggerAdapter.process` 메서드는 문맥 정보가 로그 출력에 "
"추가되는 곳입니다. 로깅 호출의 메시지 및 키워드 인자를 받아서, 하부 로거에 대한 호출에서 사용될 (대체로) 수정된 버전을 돌려줍니다."
" 이 메서드의 기본 구현은 메시지는 그대로 두고, 키워드 인자에 생성자로 전달된 딕셔너리류 객체를 값으로 갖는 'extra' 키를 "
"삽입합니다. 물론, 어댑터에 대한 호출에서 'extra' 키워드 인자를 전달한 경우 자동으로 덮어씁니다."

#: ../Doc/howto/logging-cookbook.rst:599
msgid ""
"The advantage of using 'extra' is that the values in the dict-like object"
" are merged into the :class:`LogRecord` instance's __dict__, allowing you"
" to use customized strings with your :class:`Formatter` instances which "
"know about the keys of the dict-like object. If you need a different "
"method, e.g. if you want to prepend or append the contextual information "
"to the message string, you just need to subclass :class:`LoggerAdapter` "
"and override :meth:`~LoggerAdapter.process` to do what you need. Here is "
"a simple example::"
msgstr ""
"'extra'\\를 사용하는 장점은, 딕셔너리류 객체에 들어있는 값이 :class:`LogRecord` 인스턴스의 __dict__에 "
"병합되어, 키에 대해 알고 있는 :class:`Formatter` 인스턴스로 사용자 정의된 문자열을 사용할 수 있게 된다는 것입니다. "
"다른 방법이 필요한 경우, 가령 메시지 문자열의 앞이나 뒤에 문맥 정보를 덧붙이려는 경우, :class:`LoggerAdapter` 의 "
"서브 클래스를 만들고, 필요한 작업을 수행하기 위해 :meth:`~LoggerAdapter.process` 를 재정의해야 합니다. 다음은"
" 간단한 예제입니다::"

#: ../Doc/howto/logging-cookbook.rst:615
msgid "which you can use like this::"
msgstr "이런 식으로 사용할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:620
msgid ""
"Then any events that you log to the adapter will have the value of "
"``some_conn_id`` prepended to the log messages."
msgstr "그러면 어댑터에 로그 하는 모든 이벤트는 로그 메시지 앞에 ``some_conn_id`` 값이 붙습니다."

#: ../Doc/howto/logging-cookbook.rst:624
msgid "Using objects other than dicts to pass contextual information"
msgstr "딕셔너리 이외의 객체를 사용하여 문맥 정보 전달하기"

#: ../Doc/howto/logging-cookbook.rst:626
msgid ""
"You don't need to pass an actual dict to a :class:`LoggerAdapter` - you "
"could pass an instance of a class which implements ``__getitem__`` and "
"``__iter__`` so that it looks like a dict to logging. This would be "
"useful if you want to generate values dynamically (whereas the values in "
"a dict would be constant)."
msgstr ""
"실제 딕셔너리를 :class:`LoggerAdapter` 에 전달할 필요는 없습니다 - 로깅에 딕셔너리처럼 보일 수 있도록, "
"``__getitem__`` 과 ``__iter__`` 를 구현하는 클래스의 인스턴스를 전달할 수 있습니다. 값을 동적으로 생성하려는 "
"경우 (반면에 딕셔너리에 들어있는 값은 바뀌지 않습니다) 유용합니다."

#: ../Doc/howto/logging-cookbook.rst:635
msgid "Using Filters to impart contextual information"
msgstr "문맥 정보 전달에 필터 사용하기"

#: ../Doc/howto/logging-cookbook.rst:637
msgid ""
"You can also add contextual information to log output using a user-"
"defined :class:`Filter`. ``Filter`` instances are allowed to modify the "
"``LogRecords`` passed to them, including adding additional attributes "
"which can then be output using a suitable format string, or if needed a "
"custom :class:`Formatter`."
msgstr ""
"사용자 정의 :class:`Filter`\\를 사용하여 로그 출력에 문맥 정보를 추가할 수도 있습니다. ``Filter`` 인스턴스는 "
"전달된 ``LogRecords`` 를 수정할 수 있는데, 어트리뷰트를 추가해서 적절한 포맷 문자열이나 필요하다면 사용자 정의 "
":class:`Formatter`\\를 사용해서 출력되도록 할 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:642
msgid ""
"For example in a web application, the request being processed (or at "
"least, the interesting parts of it) can be stored in a threadlocal "
"(:class:`threading.local`) variable, and then accessed from a ``Filter`` "
"to add, say, information from the request - say, the remote IP address "
"and remote user's username - to the ``LogRecord``, using the attribute "
"names 'ip' and 'user' as in the ``LoggerAdapter`` example above. In that "
"case, the same format string can be used to get similar output to that "
"shown above. Here's an example script::"
msgstr ""
"예를 들어 웹 응용 프로그램에서, 처리 중인 요청(또는 적어도 그것의 흥미로운 부분)을 스레드 로컬 "
"(:class:`threading.local`) 변수에 저장한 다음, ``Filter`` 에서 액세스해서, 요청에서 온 정보를 - 원격 "
"IP 주소와 원격 사용자의 사용자 이름이라고 합시다 - 위의 ``LoggerAdapter`` 예제에서와같이 어트리뷰트 이름 'ip'\\와"
" 'user'\\를 사용하여 ``LogRecord`` 에 추가할 수 있습니다. 이 경우 같은 포맷 문자열을 사용하여 위에 표시된 것과 "
"비슷한 출력을 얻을 수 있습니다. 다음은 스크립트 예입니다::"

#: ../Doc/howto/logging-cookbook.rst:688
msgid "which, when run, produces something like:"
msgstr "실행하면 다음과 같은 결과가 나옵니다:"

#: ../Doc/howto/logging-cookbook.rst:709
msgid "Logging to a single file from multiple processes"
msgstr "여러 프로세스에서 단일 파일에 로깅 하기"

#: ../Doc/howto/logging-cookbook.rst:711
msgid ""
"Although logging is thread-safe, and logging to a single file from "
"multiple threads in a single process *is* supported, logging to a single "
"file from *multiple processes* is *not* supported, because there is no "
"standard way to serialize access to a single file across multiple "
"processes in Python. If you need to log to a single file from multiple "
"processes, one way of doing this is to have all the processes log to a "
":class:`~handlers.SocketHandler`, and have a separate process which "
"implements a socket server which reads from the socket and logs to file. "
"(If you prefer, you can dedicate one thread in one of the existing "
"processes to perform this function.) :ref:`This section <network-"
"logging>` documents this approach in more detail and includes a working "
"socket receiver which can be used as a starting point for you to adapt in"
" your own applications."
msgstr ""
"logging 이 스레드-안전하고, 단일 프로세스의 여러 스레드에서 단일 파일로 로깅 하는 것이 *지원되지만*, 파이썬에서 여러 "
"프로세스가 단일 파일에 액세스하는 것을 직렬화하는 표준적인 방법이 없으므로, *여러 프로세스*\\에서 단일 파일로 로깅 하는 것은 "
"지원되지 *않습니다*. 여러 프로세스에서 하나의 파일에 로그 해야 하는 경우, 이 작업을 수행하는 한 가지 방법은 모든 프로세스가 로그를"
" :class:`~handlers.SocketHandler` 에 기록하고, 소켓에서 읽어서 파일로 로그 하는 소켓 서버를 구현하는 별도의"
" 프로세스를 사용하는 것입니다. (원한다면, 기존 프로세스 중 하나에서 한 스레드가 이 기능을 전담하도록 할 수 있습니다.) "
":ref:`이 섹션 <network-logging>`\\에서 이 접근법을 더 자세하게 설명하고, 여러분의 응용 프로그램에 적용하기 위한 "
"출발점으로 사용할 수 있는 작동하는 소켓 수신기를 제공합니다."

#: ../Doc/howto/logging-cookbook.rst:724
msgid ""
"If you are using a recent version of Python which includes the "
":mod:`multiprocessing` module, you could write your own handler which "
"uses the :class:`~multiprocessing.Lock` class from this module to "
"serialize access to the file from your processes. The existing "
":class:`FileHandler` and subclasses do not make use of "
":mod:`multiprocessing` at present, though they may do so in the future. "
"Note that at present, the :mod:`multiprocessing` module does not provide "
"working lock functionality on all platforms (see "
"https://bugs.python.org/issue3770)."
msgstr ""
":mod:`multiprocessing` 모듈을 포함하는 최신 버전의 파이썬을 사용하고 있다면, 이 모듈의 "
":class:`~multiprocessing.Lock` 클래스를 사용하는 독자적인 처리기를 작성하여 여러 프로세스에서 파일에 액세스하는 "
"것을 직렬화 할 수 있습니다. 기존 :class:`FileHandler` 와 서브 클래스들은, 앞으로는 가능할 수 있지만, 현재 "
":mod:`multiprocessing`\\을 사용하지 않습니다. 현재 :mod:`multiprocessing` 모듈이 모든 플랫폼에서 "
"작동하는 록 기능을 제공하지는 않는다는 것에 유의하십시오 (https://bugs.python.org/issue3770 를 참조하세요)."

#: ../Doc/howto/logging-cookbook.rst:735
msgid ""
"Alternatively, you can use a ``Queue`` and a :class:`QueueHandler` to "
"send all logging events to one of the processes in your multi-process "
"application. The following example script demonstrates how you can do "
"this; in the example a separate listener process listens for events sent "
"by other processes and logs them according to its own logging "
"configuration. Although the example only demonstrates one way of doing it"
" (for example, you may want to use a listener thread rather than a "
"separate listener process -- the implementation would be analogous) it "
"does allow for completely different logging configurations for the "
"listener and the other processes in your application, and can be used as "
"the basis for code meeting your own specific requirements::"
msgstr ""
"또는, ``Queue`` 와 :class:`QueueHandler` 를 사용하여, 모든 로깅 이벤트를 다중 프로세스 응용 프로그램의 "
"프로세스 중 하나에 보낼 수 있습니다. 다음 예제 스크립트는 이렇게 하는 방법을 보여줍니다; 예제에서 별도의 리스너 프로세스가 다른 "
"프로세스가 보낸 이벤트를 수신하고 자체 로깅 구성에 따라 이벤트를 기록합니다. 이 예제가 한 가지 방법만을 보여 주지만 (예를 들어, "
"별도의 리스너 프로세스 대신 리스너 스레드를 사용할 수도 있습니다 -- 구현은 비슷할 것입니다), 리스너와 응용 프로그램의 다른 "
"프로세스가 완전히 다른 로깅 구성을 사용하도록 허용하고, 여러분 자신의 특별한 요구 사항을 충족하는 코드의 기초로 사용할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:851
msgid ""
"A variant of the above script keeps the logging in the main process, in a"
" separate thread::"
msgstr "위의 스크립트 변형은 로깅을 메인 프로세스의 별도의 스레드에서 유지합니다::"

#: ../Doc/howto/logging-cookbook.rst:946
msgid ""
"This variant shows how you can e.g. apply configuration for particular "
"loggers - e.g. the ``foo`` logger has a special handler which stores all "
"events in the ``foo`` subsystem in a file ``mplog-foo.log``. This will be"
" used by the logging machinery in the main process (even though the "
"logging events are generated in the worker processes) to direct the "
"messages to the appropriate destinations."
msgstr ""
"이 변형은 특정 로거에 대한 구성을 적용하는 방법을 보여줍니다 - 예를 들어, ``foo`` 로거는 ``foo`` 서브 시스템의 모든 "
"이벤트를 ``mplog-foo.log`` 파일에 저장하는 특별한 처리기를 갖고 있습니다. 이것은 메인 프로세스의 로깅 시스템이 ( 로깅 "
"이벤트가 작업자 프로세스에서 만들어졌다 하더라도) 메시지를 적절한 대상으로 전달하는 데 사용됩니다."

#: ../Doc/howto/logging-cookbook.rst:953
msgid "Using file rotation"
msgstr "파일 회전 사용하기"

#: ../Doc/howto/logging-cookbook.rst:958
msgid ""
"Sometimes you want to let a log file grow to a certain size, then open a "
"new file and log to that. You may want to keep a certain number of these "
"files, and when that many files have been created, rotate the files so "
"that the number of files and the size of the files both remain bounded. "
"For this usage pattern, the logging package provides a "
":class:`~handlers.RotatingFileHandler`::"
msgstr ""
"때로는 로그 파일이 특정 크기까지 커지도록 한 다음, 새 파일을 열고 그곳에 로그에 기록하려고 할 수 있습니다. 이 파일들을 특정 수만 "
"유지하고, 그 수 만큼의 파일이 만들어지면, 파일을 회전시켜 파일의 개수와 크기 모두 제한되도록 하고 싶을 수 있습니다. 이 사용 패턴을"
" 위해, logging 패키지는 :class:`~handlers.RotatingFileHandler` 를 제공합니다::"

#: ../Doc/howto/logging-cookbook.rst:990
msgid ""
"The result should be 6 separate files, each with part of the log history "
"for the application:"
msgstr "결과는 6개의 파일이어야 하고, 각기 응용 프로그램에 대한 로그 기록의 일부입니다:"

#: ../Doc/howto/logging-cookbook.rst:1002
msgid ""
"The most current file is always :file:`logging_rotatingfile_example.out`,"
" and each time it reaches the size limit it is renamed with the suffix "
"``.1``. Each of the existing backup files is renamed to increment the "
"suffix (``.1`` becomes ``.2``, etc.)  and the ``.6`` file is erased."
msgstr ""
"가장 최근의 파일은 항상 :file:`logging_rotatingfile_example.out` 이며, 크기 제한에 도달할 때마다 "
"접미사 ``.1`` 이 붙은 이름으로 변경됩니다. 기존 백업 파일 각각의 이름이 변경되어 접미사가 증가하고 ( ``.1`` 이 "
"``.2`` 가 되는 등) ``.6`` 파일이 지워집니다."

#: ../Doc/howto/logging-cookbook.rst:1007
msgid ""
"Obviously this example sets the log length much too small as an extreme "
"example.  You would want to set *maxBytes* to an appropriate value."
msgstr "분명, 이 예제는 로그 길이를 극단적으로 작게 설정합니다. *maxBytes* 를 적절한 값으로 설정하고 싶을 겁니다."

#: ../Doc/howto/logging-cookbook.rst:1013
msgid "Use of alternative formatting styles"
msgstr "대체 포매팅 스타일 사용하기"

#: ../Doc/howto/logging-cookbook.rst:1015
#, python-format
msgid ""
"When logging was added to the Python standard library, the only way of "
"formatting messages with variable content was to use the %-formatting "
"method. Since then, Python has gained two new formatting approaches: "
":class:`string.Template` (added in Python 2.4) and :meth:`str.format` "
"(added in Python 2.6)."
msgstr ""
"logging이 파이썬 표준 라이브러리에 추가되었을 때, 가변 내용으로 메시지를 포맷하는 유일한 방법은 %-포매팅 방법을 사용하는 "
"것이었습니다. 그 이후로, 파이썬은 두 개의 새로운 포매팅 접근법을 얻었습니다: :class:`string.Template`\\(파이썬 "
"2.4에 추가됨)과 :meth:`str.format`\\(파이썬 2.6에 추가됨)."

#: ../Doc/howto/logging-cookbook.rst:1021
msgid ""
"Logging (as of 3.2) provides improved support for these two additional "
"formatting styles. The :class:`Formatter` class been enhanced to take an "
"additional, optional keyword parameter named ``style``. This defaults to "
"``'%'``, but other possible values are ``'{'`` and ``'$'``, which "
"correspond to the other two formatting styles. Backwards compatibility is"
" maintained by default (as you would expect), but by explicitly "
"specifying a style parameter, you get the ability to specify format "
"strings which work with :meth:`str.format` or :class:`string.Template`. "
"Here's an example console session to show the possibilities:"
msgstr ""
"로깅은 (3.2부터) 이 두 가지 추가 포매팅 스타일에 대해 개선된 지원을 제공합니다. :class:`Formatter` 클래스는 "
"``style`` 이라는 추가적인 키워드 매개 변수를 취하도록 개선되었습니다. 기본값은 ``'%'`` 이지만, 다른 두 가지 포매팅 "
"스타일에 해당하는 ``'{'`` 및 ``'$'`` 를 사용할 수 있습니다. (여러분이 기대하듯이) 이전 버전과의 호환성은 기본적으로 "
"유지되지만, style 매개변수를 명시적으로 지정하면 :meth:`str.format` 또는 :class:`string.Template`"
" 과 함께 작동하는 포맷 문자열을 지정할 수 있습니다. 다음은 가능성을 보여주기 위한 예제 콘솔 세션입니다:"

#: ../Doc/howto/logging-cookbook.rst:1055
#, python-format
msgid ""
"Note that the formatting of logging messages for final output to logs is "
"completely independent of how an individual logging message is "
"constructed. That can still use %-formatting, as shown here::"
msgstr ""
"로그로 최종 출력하기 위해 로깅 메시지를 포매팅하는 것은 개별 로깅 메시지가 구성되는 방식과 완전히 별개입니다. 개별 메시지에는 다음과 "
"같이 %-포매팅을 사용할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:1063
#, python-format
msgid ""
"Logging calls (``logger.debug()``, ``logger.info()`` etc.) only take "
"positional parameters for the actual logging message itself, with keyword"
" parameters used only for determining options for how to handle the "
"actual logging call (e.g. the ``exc_info`` keyword parameter to indicate "
"that traceback information should be logged, or the ``extra`` keyword "
"parameter to indicate additional contextual information to be added to "
"the log). So you cannot directly make logging calls using "
":meth:`str.format` or :class:`string.Template` syntax, because internally"
" the logging package uses %-formatting to merge the format string and the"
" variable arguments. There would be no changing this while preserving "
"backward compatibility, since all logging calls which are out there in "
"existing code will be using %-format strings."
msgstr ""
"로깅 호출(``logger.debug()``, ``logger.info()`` 등)은 실제 로깅 메시지 자체를 위해서는 위치 매개 "
"변수만을 취하고, 키워드 매개 변수는 실제 로깅 호출을 어떻게 다뤄야 하는지를 지정하는 옵션을 결정하는 용도로만 사용됩니다 (예를 들어,"
" 트레이스백 정보를 로그 해야 할지를 가리키는 ``exc_info`` 키워드 매개 변수나 로그에 추가되는 문맥 정보를 나타내는 "
"``extra`` 키워드 매개 변수). 그래서 여러분은 :meth:`str.format` 또는 "
":class:`string.Template` 문법을 사용하여 직접 로깅 호출을 할 수 없습니다, 내부적으로 logging 패키지가 "
"%-포매팅을 사용하여 포맷 문자열과 변수 인자를 병합하기 때문입니다. 이전 버전과의 호환성을 유지하는 동안은 이 상황이 바뀌지 않을 "
"것입니다. 기존 코드에 있는 모든 로깅 호출이 %-포맷 문자열을 사용하기 때문입니다."

#: ../Doc/howto/logging-cookbook.rst:1076
msgid ""
"There is, however, a way that you can use {}- and $- formatting to "
"construct your individual log messages. Recall that for a message you can"
" use an arbitrary object as a message format string, and that the logging"
" package will call ``str()`` on that object to get the actual format "
"string. Consider the following two classes::"
msgstr ""
"그러나 {}- 및 $- 포매팅을 사용하여 개별 로그 메시지를 구성하는 방법이 있습니다. 메시지의 경우, 메시지 포맷 문자열로 임의의 "
"객체를 사용할 수 있으며, logging 패키지는 실제 형식 문자열을 얻기 위해 그 객체에 대해 ``str()`` 을 호출한다는 것을 "
"상기하십시오. 다음 두 가지 클래스를 고려하십시오::"

#: ../Doc/howto/logging-cookbook.rst:1100
#, python-format
msgid ""
"Either of these can be used in place of a format string, to allow {}- or "
"$-formatting to be used to build the actual \"message\" part which "
"appears in the formatted log output in place of \"%(message)s\" or "
"\"{message}\" or \"$message\". It's a little unwieldy to use the class "
"names whenever you want to log something, but it's quite palatable if you"
" use an alias such as __ (double underscore --- not to be confused with "
"_, the single underscore used as a synonym/alias for "
":func:`gettext.gettext` or its brethren)."
msgstr ""
"이 중 하나를 포맷 문자열 대신 사용하면, {}- 또는 $-포매팅을 사용하여 포맷된 로그 출력의 \"%(message)s\", "
"\"{message}\" 또는 \"$message\" 자리에 나타나는 실제 \"message\" 부분을 만들 수 있습니다. 어떤 것을 "
"로그 하고 싶을 때마다 클래스 이름을 사용하는 것은 다소 꼴사납지만, __(두 개의 밑줄 ---- "
":func:`gettext.gettext` 나 그 형제들의 동의어/별칭으로 사용되는 _ 과 혼동하지 마세요)와 같은 별칭을 사용하면 꽤 "
"쓸만합니다."

#: ../Doc/howto/logging-cookbook.rst:1108
msgid ""
"The above classes are not included in Python, though they're easy enough "
"to copy and paste into your own code. They can be used as follows "
"(assuming that they're declared in a module called ``wherever``):"
msgstr ""
"위의 클래스가 파이썬에 포함되어 있지는 않지만, 아주 쉽게 여러분의 코드에 복사하여 붙여넣을 수 있습니다. 다음과 같이 사용될 수 "
"있습니다 (``wherever`` 라는 모듈에서 선언되었다고 가정합니다):"

#: ../Doc/howto/logging-cookbook.rst:1130
msgid ""
"While the above examples use ``print()`` to show how the formatting "
"works, you would of course use ``logger.debug()`` or similar to actually "
"log using this approach."
msgstr ""
"위의 예제는 ``print()`` 를 사용하여 포매팅이 어떻게 작동하는지 보여주고 있지만, 물론 이 접근법으로 실제 로깅 할 때는 "
"``logger.debug()`` 나 그와 유사한 것을 사용해야 합니다."

#: ../Doc/howto/logging-cookbook.rst:1134
msgid ""
"One thing to note is that you pay no significant performance penalty with"
" this approach: the actual formatting happens not when you make the "
"logging call, but when (and if) the logged message is actually about to "
"be output to a log by a handler. So the only slightly unusual thing which"
" might trip you up is that the parentheses go around the format string "
"and the arguments, not just the format string. That's because the __ "
"notation is just syntax sugar for a constructor call to one of the "
"XXXMessage classes."
msgstr ""
"한 가지 지적할 점은, 이 접근법이 성능상으로 큰 문제가 없다는 것입니다: 실제 포매팅은 로깅 호출을 할 때가 아니라 로깅 된 메시지를 "
"실제로 처리기가 로그로 출력할 때 (그리고 실제로 그렇게 될 때만) 발생합니다. 그래서 여러분이 실수할 수도 있을 특이함은 괄호가 포맷 "
"문자열과 인자들을 모두 감싼다는 것뿐입니다. __ 표기법이 단지 XXXMessage 클래스 중 하나에 대한 생성자 호출의 편의 문법이기 "
"때문입니다."

#: ../Doc/howto/logging-cookbook.rst:1142
msgid ""
"If you prefer, you can use a :class:`LoggerAdapter` to achieve a similar "
"effect to the above, as in the following example::"
msgstr "원한다면, :class:`LoggerAdapter` 를 사용하여 다음 예제와 같이 위와 유사한 효과를 얻을 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:1173
msgid ""
"The above script should log the message ``Hello, world!`` when run with "
"Python 3.2 or later."
msgstr "이 스크립트는 파이썬 3.2 이상에서 실행될 때 ``Hello, world!`` 라는 메시지를 기록해야 합니다."

#: ../Doc/howto/logging-cookbook.rst:1182
msgid "Customizing ``LogRecord``"
msgstr "사용자 정의 ``LogRecord``"

#: ../Doc/howto/logging-cookbook.rst:1184
msgid ""
"Every logging event is represented by a :class:`LogRecord` instance. When"
" an event is logged and not filtered out by a logger's level, a "
":class:`LogRecord` is created, populated with information about the event"
" and then passed to the handlers for that logger (and its ancestors, up "
"to and including the logger where further propagation up the hierarchy is"
" disabled). Before Python 3.2, there were only two places where this "
"creation was done:"
msgstr ""
"모든 로깅 이벤트는 :class:`LogRecord` 인스턴스로 표현됩니다. 이벤트가 로그 되고 로거 수준에 의해 필터링 되지 않으면, "
":class:`LogRecord` 가 생성되고 이벤트에 대한 정보로 채워진 다음 해당 로거(와 그 조상들, 계층 상위로의 전파가 "
"비활성화된 지점의 로거까지)의 처리기로 전달됩니다. 파이썬 3.2 이전에는, 이 ​​생성이 일어나는 곳이 두 곳밖에 없었습니다:"

#: ../Doc/howto/logging-cookbook.rst:1191
msgid ""
":meth:`Logger.makeRecord`, which is called in the normal process of "
"logging an event. This invoked :class:`LogRecord` directly to create an "
"instance."
msgstr ""
":meth:`Logger.makeRecord`, 이벤트 로깅의 일반적인 프로세스에서 호출됩니다. 인스턴스를 생성하기 위해 "
":class:`LogRecord` 를 직접 호출합니다."

#: ../Doc/howto/logging-cookbook.rst:1194
msgid ""
":func:`makeLogRecord`, which is called with a dictionary containing "
"attributes to be added to the LogRecord. This is typically invoked when a"
" suitable dictionary has been received over the network (e.g. in pickle "
"form via a :class:`~handlers.SocketHandler`, or in JSON form via an "
":class:`~handlers.HTTPHandler`)."
msgstr ""
":func:`makeLogRecord`, LogRecord에 추가될 어트리뷰트를 포함하는 딕셔너리와 함께 호출됩니다. 보통 적절한 "
"딕셔너리가 네트워크를 통해 (예를 들어, :class:`~handlers.SocketHandler` 를 통해 피클 형태로, 또는 "
":class:`~handlers.HTTPHandler` 를 통해 JSON 형식으로) 수신될 때 호출됩니다."

#: ../Doc/howto/logging-cookbook.rst:1200
msgid ""
"This has usually meant that if you need to do anything special with a "
":class:`LogRecord`, you've had to do one of the following."
msgstr ""
"이것은 보통 :class:`LogRecord` 로 특별한 것을 할 필요가 있다면, 다음 중 하나를 해야 한다는 것을 의미합니다."

#: ../Doc/howto/logging-cookbook.rst:1203
msgid ""
"Create your own :class:`Logger` subclass, which overrides "
":meth:`Logger.makeRecord`, and set it using "
":func:`~logging.setLoggerClass` before any loggers that you care about "
"are instantiated."
msgstr ""
":meth:`Logger.makeRecord` 를 재정의하는 자신만의 :class:`Logger` 서브 클래스를 만들고, 관심 있는 "
"로거의 인스턴스가 만들어지기 전에 :func:`~logging.setLoggerClass` 를 사용하여 설정하십시오."

#: ../Doc/howto/logging-cookbook.rst:1206
msgid ""
"Add a :class:`Filter` to a logger or handler, which does the necessary "
"special manipulation you need when its :meth:`~Filter.filter` method is "
"called."
msgstr ""
"로거나 처리기에 :class:`Filter`\\를 추가해서 :meth:`~Filter.filter` 메서드가 호출될 때 필요한 특별한 "
"조작을 하십시오."

#: ../Doc/howto/logging-cookbook.rst:1210
msgid ""
"The first approach would be a little unwieldy in the scenario where (say)"
" several different libraries wanted to do different things. Each would "
"attempt to set its own :class:`Logger` subclass, and the one which did "
"this last would win."
msgstr ""
"첫 번째 접근법은 여러 라이브러리가 서로 다른 일을 하고 싶어 하는 시나리오에서는 다루기 힘들 것입니다. 각자 자신의 "
":class:`Logger` 서브 클래스를 설정하려고 시도할 것이고, 마지막 것이 이기게 될 것입니다."

#: ../Doc/howto/logging-cookbook.rst:1215
msgid ""
"The second approach works reasonably well for many cases, but does not "
"allow you to e.g. use a specialized subclass of :class:`LogRecord`. "
"Library developers can set a suitable filter on their loggers, but they "
"would have to remember to do this every time they introduced a new logger"
" (which they would do simply by adding new packages or modules and doing "
"::"
msgstr ""
"두 번째 접근법은 많은 경우에 합리적으로 잘 작동하지만, :class:`LogRecord` 의 특별한 서브 클래스를 사용할 수는 "
"없습니다. 라이브러리 개발자는 로거에 적절한 필터를 설정할 수 있지만, 새로운 로거를 도입할 때마다 이를 수행해야 한다는 것을 기억해야 "
"합니다. 이를 고려하지 않는다면 새 패키지나 모듈을 추가하고 모듈 수준에서 단순히 다음과 같이 합니다::"

#: ../Doc/howto/logging-cookbook.rst:1223
msgid ""
"at module level). It's probably one too many things to think about. "
"Developers could also add the filter to a :class:`~logging.NullHandler` "
"attached to their top-level logger, but this would not be invoked if an "
"application developer attached a handler to a lower-level library logger "
"--- so output from that handler would not reflect the intentions of the "
"library developer."
msgstr ""
"이것은 아마도 고려해야 할 많은 것 중 하나일 뿐입니다. 개발자는 자신의 최상위 로거에 첨부된 "
":class:`~logging.NullHandler` 에도 필터를 추가 할 수 있지만, 응용 프로그램 개발자가 하위 수준 라이브러리 "
"로거에 처리기를 연결하면 호출되지 않습니다 --- 그래서 그 처리기로부터의 출력은 라이브러리 개발자의 의도를 반영하지 못합니다."

#: ../Doc/howto/logging-cookbook.rst:1229
msgid ""
"In Python 3.2 and later, :class:`~logging.LogRecord` creation is done "
"through a factory, which you can specify. The factory is just a callable "
"you can set with :func:`~logging.setLogRecordFactory`, and interrogate "
"with :func:`~logging.getLogRecordFactory`. The factory is invoked with "
"the same signature as the :class:`~logging.LogRecord` constructor, as "
":class:`LogRecord` is the default setting for the factory."
msgstr ""
"파이썬 3.2 이상에서는, :class:`~logging.LogRecord` 생성이 사용자가 지정할 수 있는 팩토리를 통해 수행됩니다. "
"팩토리는 :func:`~logging.setLogRecordFactory` 로 설정할 수 있고, "
":func:`~logging.getLogRecordFactory` 로 조회할 수 있는 콜러블입니다. 팩토리는 "
":class:`~logging.LogRecord` 생성자와 같은 서명으로 호출되고, 기본 설정은 :class:`LogRecord` "
"입니다."

#: ../Doc/howto/logging-cookbook.rst:1236
msgid ""
"This approach allows a custom factory to control all aspects of LogRecord"
" creation. For example, you could return a subclass, or just add some "
"additional attributes to the record once created, using a pattern similar"
" to this::"
msgstr ""
"이 방법을 사용하면 사용자 정의 팩토리가 LogRecord 생성의 모든 측면을 제어 할 수 있습니다. 예를 들어, 서브 클래스를 "
"반환하거나, 다음과 같은 방법으로 생성된 레코드에 어트리뷰트를 추가 할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:1249
msgid ""
"This pattern allows different libraries to chain factories together, and "
"as long as they don't overwrite each other's attributes or "
"unintentionally overwrite the attributes provided as standard, there "
"should be no surprises. However, it should be borne in mind that each "
"link in the chain adds run-time overhead to all logging operations, and "
"the technique should only be used when the use of a :class:`Filter` does "
"not provide the desired result."
msgstr ""
"이 패턴은 서로 다른 라이브러리가 팩토리를 체인으로 연결할 수 있도록 하며, 서로의 어트리뷰트를 덮어쓰거나 의도하지 않게 표준으로 제공된"
" 어트리뷰트를 덮어쓰지 않는 한, 놀랄 일은 없어야 합니다. 그러나 체인의 각 고리는 모든 로깅 작업에 실행시간 오버헤드를 추가하므로, "
":class:`Filter`\\를 사용해서 원하는 결과를 얻을 수 없을 때만 이 기법을 사용해야 합니다."

#: ../Doc/howto/logging-cookbook.rst:1260
msgid "Subclassing QueueHandler - a ZeroMQ example"
msgstr "QueueHandler 서브 클래스 만들기 - ZeroMQ 예제"

#: ../Doc/howto/logging-cookbook.rst:1262
msgid ""
"You can use a :class:`QueueHandler` subclass to send messages to other "
"kinds of queues, for example a ZeroMQ 'publish' socket. In the example "
"below,the socket is created separately and passed to the handler (as its "
"'queue')::"
msgstr ""
":class:`QueueHandler` 서브 클래스를 사용하여 다른 유형의 큐에 메시지를 보낼 수 있습니다, 예를 들어 ZeroMQ "
"'publish' 소켓. 아래 예제에서, 소켓은 별도로 생성되어 처리기로 ('queue'\\로) 전달됩니다::"

#: ../Doc/howto/logging-cookbook.rst:1281
msgid ""
"Of course there are other ways of organizing this, for example passing in"
" the data needed by the handler to create the socket::"
msgstr "물론 구성하는 다른 방법이 있습니다. 예를 들어 처리기가 소켓을 만드는데 필요한 데이터를 전달하는 것입니다::"

#: ../Doc/howto/logging-cookbook.rst:1299
msgid "Subclassing QueueListener - a ZeroMQ example"
msgstr "QueueListener 서브 클래스 만들기 - ZeroMQ 예제"

#: ../Doc/howto/logging-cookbook.rst:1301
msgid ""
"You can also subclass :class:`QueueListener` to get messages from other "
"kinds of queues, for example a ZeroMQ 'subscribe' socket. Here's an "
"example::"
msgstr ""
"다른 유형의 큐에서 메시지를 받기 위해 :class:`QueueListener` 의 서브 클래스를 만들 수도 있습니다, 예를 들어 "
"ZeroMQ 'subscribe' 소켓. 다음은 그 예입니다::"

#: ../Doc/howto/logging-cookbook.rst:1320
msgid "Module :mod:`logging`"
msgstr "모듈 :mod:`logging`"

#: ../Doc/howto/logging-cookbook.rst:1320
msgid "API reference for the logging module."
msgstr "logging 모듈에 대한 API 참조"

#: ../Doc/howto/logging-cookbook.rst:1323
msgid "Module :mod:`logging.config`"
msgstr "모듈 :mod:`logging.config`"

#: ../Doc/howto/logging-cookbook.rst:1323
msgid "Configuration API for the logging module."
msgstr "logging 모듈용 구성 API."

#: ../Doc/howto/logging-cookbook.rst:1326
msgid "Module :mod:`logging.handlers`"
msgstr "모듈 :mod:`logging.handlers`"

#: ../Doc/howto/logging-cookbook.rst:1326
msgid "Useful handlers included with the logging module."
msgstr "logging 모듈에 포함된 유용한 처리기."

#: ../Doc/howto/logging-cookbook.rst:1328
msgid ":ref:`A basic logging tutorial <logging-basic-tutorial>`"
msgstr ":ref:`기초 로깅 자습서 <logging-basic-tutorial>`"

#: ../Doc/howto/logging-cookbook.rst:1330
msgid ":ref:`A more advanced logging tutorial <logging-advanced-tutorial>`"
msgstr ":ref:`고급 로깅 자습서 <logging-advanced-tutorial>`"

#: ../Doc/howto/logging-cookbook.rst:1334
msgid "An example dictionary-based configuration"
msgstr "딕셔너리 기반 구성의 예"

#: ../Doc/howto/logging-cookbook.rst:1336
msgid ""
"Below is an example of a logging configuration dictionary - it's taken "
"from the `documentation on the Django project "
"<https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-"
"logging>`_. This dictionary is passed to :func:`~config.dictConfig` to "
"put the configuration into effect::"
msgstr ""
"다음은 로깅 구성 딕셔너리의 예입니다 - `장고 프로젝트 설명서 "
"<https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-"
"logging>`_ 에서 가져왔습니다. 이 딕셔너리를 :func:`~config.dictConfig` 로 전달하여 구성을 적용합니다::"

#: ../Doc/howto/logging-cookbook.rst:1392
msgid ""
"For more information about this configuration, you can see the `relevant "
"section <https://docs.djangoproject.com/en/1.9/topics/logging"
"/#configuring-logging>`_ of the Django documentation."
msgstr ""
"이 구성에 대한 더 자세한 정보는 장고 설명서의 `관련 섹션 "
"<https://docs.djangoproject.com/en/1.9/topics/logging/#configuring-"
"logging>`_ 을 참조하세요."

#: ../Doc/howto/logging-cookbook.rst:1399
msgid "Using a rotator and namer to customize log rotation processing"
msgstr "rotator와 namer를 사용해서 로그 회전 처리하기"

#: ../Doc/howto/logging-cookbook.rst:1401
msgid ""
"An example of how you can define a namer and rotator is given in the "
"following snippet, which shows zlib-based compression of the log file::"
msgstr "다음 코드 조각에 namer 와 rotator를 정의하는 예가 있는데, 로그 파일을 zlib 기반으로 압축합니다::"

#: ../Doc/howto/logging-cookbook.rst:1419
msgid ""
"These are not \"true\" .gz files, as they are bare compressed data, with "
"no \"container\" such as you’d find in an actual gzip file. This snippet "
"is just for illustration purposes."
msgstr ""
"이것은 \"진짜\" .gz 파일이 아닙니다. 단순히 압축된 데이터일 뿐이고, 실제 gzip 파일에서 찾을 수 있는 \"컨테이너\" 가 "
"없습니다. 이 코드 조각은 단지 설명을 위한 것일 뿐입니다."

#: ../Doc/howto/logging-cookbook.rst:1424
msgid "A more elaborate multiprocessing example"
msgstr "좀 더 정교한 multiprocessing 예제"

#: ../Doc/howto/logging-cookbook.rst:1426
msgid ""
"The following working example shows how logging can be used with "
"multiprocessing using configuration files. The configurations are fairly "
"simple, but serve to illustrate how more complex ones could be "
"implemented in a real multiprocessing scenario."
msgstr ""
"다음 동작하는 예제에서는 구성 파일을 사용하여 로깅을 multiprocessing과 함께 사용하는 방법을 보여줍니다. 구성은 매우 "
"간단하지만, 실제 multiprocessing 시나리오에서 더 복잡한 구성을 구현할 수 있음을 예시합니다."

#: ../Doc/howto/logging-cookbook.rst:1431
msgid ""
"In the example, the main process spawns a listener process and some "
"worker processes. Each of the main process, the listener and the workers "
"have three separate configurations (the workers all share the same "
"configuration). We can see logging in the main process, how the workers "
"log to a QueueHandler and how the listener implements a QueueListener and"
" a more complex logging configuration, and arranges to dispatch events "
"received via the queue to the handlers specified in the configuration. "
"Note that these configurations are purely illustrative, but you should be"
" able to adapt this example to your own scenario."
msgstr ""
"이 예에서, 주 프로세스는 리스너 프로세스와 몇 개의 작업자 프로세스를 생성합니다. 주 프로세스, 리스너 및 작업자를 위한 세 가지 "
"구성이 있습니다 (모든 작업자는 같은 구성을 공유합니다). 주 프로세스에서의 로깅, 작업자가 QueueHandler에 로그 하는 방법, "
"그리고 리스너가 QueueListener 및 더욱 복잡한 로깅 구성을 구현하고 큐를 통해 수신한 이벤트를 구성에서 지정된 처리기로 "
"전달하도록 배치하는 는 방법을 볼 수 있습니다. 이러한 구성은 설명을 위한 것이지만, 이 예제를 여러분 자신의 시나리오에 적용할 수 "
"있어야 합니다."

#: ../Doc/howto/logging-cookbook.rst:1441
msgid ""
"Here's the script - the docstrings and the comments hopefully explain how"
" it works::"
msgstr "스크립트는 다음과 같습니다 - 독스트링과 주석이 어떻게 작동하는지 잘 설명하기를 바랍니다::"

#: ../Doc/howto/logging-cookbook.rst:1653
msgid "Inserting a BOM into messages sent to a SysLogHandler"
msgstr "SysLogHandler로 전송된 메시지에 BOM 삽입하기"

#: ../Doc/howto/logging-cookbook.rst:1655
msgid ""
":rfc:`5424` requires that a Unicode message be sent to a syslog daemon as"
" a set of bytes which have the following structure: an optional pure-"
"ASCII component, followed by a UTF-8 Byte Order Mark (BOM), followed by "
"Unicode encoded using UTF-8. (See the :rfc:`relevant section of the "
"specification <5424#section-6>`.)"
msgstr ""
":rfc:`5424` 는 유니코드 메시지가 다음 구조를 갖는 바이트들로 syslog 데몬에 전송되어야 함을 요구합니다: 선택적인 순수 "
"ASCII 구성 요소, 그 뒤를 이어 UTF-8 바이트 순서 표식 (BOM), 그 뒤를 이어 UTF-8으로 인코딩된 유니코드. "
"(:rfc:`이 규격의 관련 절 <5424#section-6>` 을 참조하십시오.)"

#: ../Doc/howto/logging-cookbook.rst:1661
msgid ""
"In Python 3.1, code was added to :class:`~logging.handlers.SysLogHandler`"
" to insert a BOM into the message, but unfortunately, it was implemented "
"incorrectly, with the BOM appearing at the beginning of the message and "
"hence not allowing any pure-ASCII component to appear before it."
msgstr ""
"파이썬 3.1에서, BOM을 메시지에 삽입하는 코드가 :class:`~logging.handlers.SysLogHandler` 에 "
"추가되었지만, 유감스럽게도, BOM이 메시지의 시작 부분에 나타나서 그 앞에 순수 ASCII 구성 요소를 허락하지 않도록 잘못 "
"구현되었습니다."

#: ../Doc/howto/logging-cookbook.rst:1667
msgid ""
"As this behaviour is broken, the incorrect BOM insertion code is being "
"removed from Python 3.2.4 and later. However, it is not being replaced, "
"and if you want to produce :rfc:`5424`-compliant messages which include a"
" BOM, an optional pure-ASCII sequence before it and arbitrary Unicode "
"after it, encoded using UTF-8, then you need to do the following:"
msgstr ""
"이 동작이 잘못됨에 따라, 잘못된 BOM 삽입 코드가 파이썬 3.2.4 이상에서 제거되었습니다. 그러나, 올바른 코드로 대체되지는 "
"않았고, BOM을 포함하고, 그 앞에 순수 ASCII 시퀀스, 그 뒤에 UTF-8으로 인코딩된 임의의 유니코드로 구성된 "
":rfc:`5424`-호환 메시지를 생성하려는 경우 다음과 같이 해야 합니다:"

#: ../Doc/howto/logging-cookbook.rst:1673
msgid ""
"Attach a :class:`~logging.Formatter` instance to your "
":class:`~logging.handlers.SysLogHandler` instance, with a format string "
"such as::"
msgstr ""
":class:`~logging.Formatter` 인스턴스를 :class:`~logging.handlers.SysLogHandler` "
"인스턴스에 다음과 같은 포맷 문자열과 함께 첨부하십시오::"

#: ../Doc/howto/logging-cookbook.rst:1679
msgid ""
"The Unicode code point U+FEFF, when encoded using UTF-8, will be encoded "
"as a UTF-8 BOM -- the byte-string ``b'\\xef\\xbb\\xbf'``."
msgstr ""
"유니코드 코드 포인트 U+FEFF는, UTF-8을 사용하여 인코딩될 때, UTF-8 BOM으로 인코딩됩니다 -- 바이트열 "
"``b'\\xef\\xbb\\xbf'``."

#: ../Doc/howto/logging-cookbook.rst:1682
msgid ""
"Replace the ASCII section with whatever placeholders you like, but make "
"sure that the data that appears in there after substitution is always "
"ASCII (that way, it will remain unchanged after UTF-8 encoding)."
msgstr ""
"ASCII section을 원하는 자리 표시기로 바꾸십시오. 그러나 치환 후 나타나는 데이터가 항상 ASCII임미 보장되어야 합니다 "
"(그렇게 되면, UTF-8 인코딩 이후에는 변경되지 않은 채로 유지됩니다)."

#: ../Doc/howto/logging-cookbook.rst:1686
msgid ""
"Replace the Unicode section with whatever placeholders you like; if the "
"data which appears there after substitution contains characters outside "
"the ASCII range, that's fine -- it will be encoded using UTF-8."
msgstr ""
"Unidcode section을 원하는 자리 표시기로 바꾸십시오; 치환 후 나타나는 데이터에 ASCII 범위를 벗어나는 문자가 포함되어 "
"있어도 괜찮습니다 -- UTF-8을 사용하여 인코딩됩니다."

#: ../Doc/howto/logging-cookbook.rst:1690
msgid ""
"The formatted message *will* be encoded using UTF-8 encoding by "
"``SysLogHandler``. If you follow the above rules, you should be able to "
"produce :rfc:`5424`-compliant messages. If you don't, logging may not "
"complain, but your messages will not be RFC 5424-compliant, and your "
"syslog daemon may complain."
msgstr ""
"포맷된 된 메시지는 ``SysLogHandler`` 에 의해 UTF-8 인코딩을 사용하여 인코딩\\*됩니다*. 위의 규칙을 따르는 경우,"
" :rfc:`5424`-호환 메시지를 생성할 수 있어야 합니다. 그렇지 않으면, logging이 불평하지 않을 수도 있지만, 메시지가 "
"RFC 5424와 호환되지 않고 syslog 데몬이 불평 할 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:1697
msgid "Implementing structured logging"
msgstr "구조적 로깅 구현"

#: ../Doc/howto/logging-cookbook.rst:1699
msgid ""
"Although most logging messages are intended for reading by humans, and "
"thus not readily machine-parseable, there might be circumstances where "
"you want to output messages in a structured format which *is* capable of "
"being parsed by a program (without needing complex regular expressions to"
" parse the log message). This is straightforward to achieve using the "
"logging package. There are a number of ways in which this could be "
"achieved, but the following is a simple approach which uses JSON to "
"serialise the event in a machine-parseable manner::"
msgstr ""
"대부분의 로깅 메시지는 사람이 읽을 수 있도록 만들어졌기 때문에 쉽게 기계에서 파싱 할 수 없지만, 프로그램에서 (복잡한 정규식을 "
"사용하지 않고도) 구문 분석할 수 *있는* 구조화된 포맷으로 메시지를 출력하려는 ​​상황이 있을 수 있습니다. 이것은 logging "
"패키지를 사용하여 쉽게 달성 할 수 있습니다. 이것이 달성될 수 있는 여러 가지 방법이 있지만, 다음은 JSON을 사용하여 기계가 파싱할"
" 수 있는 방식으로 이벤트를 직렬화하는 간단한 접근법입니다::"

#: ../Doc/howto/logging-cookbook.rst:1723
msgid "If the above script is run, it prints:"
msgstr "위의 스크립트가 실행되면 다음과 같이 인쇄됩니다:"

#: ../Doc/howto/logging-cookbook.rst:1729
#: ../Doc/howto/logging-cookbook.rst:1778
msgid ""
"Note that the order of items might be different according to the version "
"of Python used."
msgstr "항목의 순서는 사용된 파이썬 버전에 따라 다를 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:1732
msgid ""
"If you need more specialised processing, you can use a custom JSON "
"encoder, as in the following complete example::"
msgstr "좀 더 특별한 처리가 필요한 경우, 다음 예제와 같이 사용자 정의 JSON 인코더를 사용할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:1772
msgid "When the above script is run, it prints:"
msgstr "위의 스크립트를 실행하면 다음과 같이 인쇄합니다:"

#: ../Doc/howto/logging-cookbook.rst:1787
msgid "Customizing handlers with :func:`dictConfig`"
msgstr ":func:`dictConfig`\\로 처리기를 사용자 정의하기"

#: ../Doc/howto/logging-cookbook.rst:1789
msgid ""
"There are times when you want to customize logging handlers in particular"
" ways, and if you use :func:`dictConfig` you may be able to do this "
"without subclassing. As an example, consider that you may want to set the"
" ownership of a log file. On POSIX, this is easily done using "
":func:`shutil.chown`, but the file handlers in the stdlib don't offer "
"built-in support. You can customize handler creation using a plain "
"function such as::"
msgstr ""
"특정 상황에서 로깅 처리기를 사용자 정의하고 싶을 때가 있고, :func:`dictConfig`\\를 사용하고 있다면 서브 클래스를 "
"만들지 않고도 이 작업을 수행 할 수 있습니다. 예를 들어, 로그 파일의 소유권을 설정하고 싶다고 합시다. POSIX에서, "
":func:`shutil.chown` 을 사용하면 쉽게 할 수 있지만, 표준 라이브러리의 파일 처리기는 내장된 지원을 제공하지 않습니다."
" 다음과 같은 일반 함수를 사용하여 처리기 생성을 사용자 정의 할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:1803
msgid ""
"You can then specify, in a logging configuration passed to "
":func:`dictConfig`, that a logging handler be created by calling this "
"function::"
msgstr ""
"그런 다음, :func:`dictConfig` 에 전달되는 로깅 구성에서, 이 함수를 호출하여 로깅 처리기를 생성하도록 지정할 수 "
"있습니다::"

#: ../Doc/howto/logging-cookbook.rst:1836
msgid ""
"In this example I am setting the ownership using the ``pulse`` user and "
"group, just for the purposes of illustration. Putting it together into a "
"working script, ``chowntest.py``::"
msgstr ""
"이 예제에서는 단지 예를 들기 위해 ``pulse`` 라는 사용자와 그룹을 사용하여 소유권을 설정합니다. 작동하는 스크립트 "
"``chowntest.py`` 로 정리하면::"

#: ../Doc/howto/logging-cookbook.rst:1883
msgid "To run this, you will probably need to run as ``root``:"
msgstr "이것을 실행하기 위해서는, 아마도 ``root`` 로 실행해야 할 것입니다:"

#: ../Doc/howto/logging-cookbook.rst:1893
msgid ""
"Note that this example uses Python 3.3 because that's where "
":func:`shutil.chown` makes an appearance. This approach should work with "
"any Python version that supports :func:`dictConfig` - namely, Python 2.7,"
" 3.2 or later. With pre-3.3 versions, you would need to implement the "
"actual ownership change using e.g. :func:`os.chown`."
msgstr ""
"이 예제는 :func:`shutil.chown` 이 등장한 파이썬 3.3을 사용합니다. 이 접근법은 "
":func:`dictConfig`\\를 지원하는 모든 파이썬 버전에서 작동합니다 - 파이썬 2.7, 3.2 이상. 3.3 이전 버전의 "
"경우, (예를 들어) :func:`os.chown` 을 사용하여 실제 소유권 변경을 구현해야 합니다."

#: ../Doc/howto/logging-cookbook.rst:1899
msgid ""
"In practice, the handler-creating function may be in a utility module "
"somewhere in your project. Instead of the line in the configuration::"
msgstr ""
"실제로는, 처리기 생성 함수가 프로젝트 어딘가에 있는 유틸리티 모듈에 있을 수 있습니다. 구성에 있는 다음과 같은 줄 대신::"

#: ../Doc/howto/logging-cookbook.rst:1904
msgid "you could use e.g.::"
msgstr "예를 들면 이렇게 쓸 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:1908
msgid ""
"where ``project.util`` can be replaced with the actual name of the "
"package where the function resides. In the above working script, using "
"``'ext://__main__.owned_file_handler'`` should work. Here, the actual "
"callable is resolved by :func:`dictConfig` from the ``ext://`` "
"specification."
msgstr ""
"여기서 ``project.util`` 은 함수가 있는 패키지의 실제 이름으로 바꿀 수 있습니다. 위의 작업 스크립트에서 "
"``'ext://__main__.owned_file_handler'`` 를 사용해도 됩니다. 여기서, 실제 콜러블은 ``ext://`` "
"스펙으로부터 :func:`dictConfig` 에 의해 결정됩니다."

#: ../Doc/howto/logging-cookbook.rst:1913
msgid ""
"This example hopefully also points the way to how you could implement "
"other types of file change - e.g. setting specific POSIX permission bits "
"- in the same way, using :func:`os.chmod`."
msgstr ""
"이 예제는 희망하건대 다른 형태의 파일 변경을 - 예를 들어 특정 POSIX 권한 비트 설정 - 같은 방법으로 "
"(:func:`os.chmod` 를 사용해서) 구현하는 방법도 알려줍니다."

#: ../Doc/howto/logging-cookbook.rst:1917
msgid ""
"Of course, the approach could also be extended to types of handler other "
"than a :class:`~logging.FileHandler` - for example, one of the rotating "
"file handlers, or a different type of handler altogether."
msgstr ""
"물론 이 접근법은 :class:`~logging.FileHandler` 이외의 처리기 유형으로도 확장될 수 있습니다 - 예를 들어, 회전"
" 파일 처리기 중 하나 또는 다른 유형의 처리기 모두."

#: ../Doc/howto/logging-cookbook.rst:1927
msgid "Using particular formatting styles throughout your application"
msgstr "응용 프로그램 전체에서 특정 포맷 스타일 사용하기"

#: ../Doc/howto/logging-cookbook.rst:1929
msgid ""
"In Python 3.2, the :class:`~logging.Formatter` gained a ``style`` keyword"
" parameter which, while defaulting to ``%`` for backward compatibility, "
"allowed the specification of ``{`` or ``$`` to support the formatting "
"approaches supported by :meth:`str.format` and :class:`string.Template`. "
"Note that this governs the formatting of logging messages for final "
"output to logs, and is completely orthogonal to how an individual logging"
" message is constructed."
msgstr ""
"파이썬 3.2에서, :class:`~logging.Formatter` 는 ``style`` 키워드 매개변수를 얻었는데, 이전 버전과의 "
"호환성을 위해 ``%`` 를 기본값으로 사용하면서 ``{`` 또는 ``$`` 를 지정하면 :meth:`str.format` 과 "
":class:`string.Template` 에 의해 지원되는 포매팅 접근법을 사용할 수 있도록 합니다. 이것은 로그 되는 최종 출력으로"
" 로깅 메시지를 포매팅하는 것과 관계된 것이고, 개별 로깅 메시지가 만들어지는 방법과는 무관함에 주의하십시오."

#: ../Doc/howto/logging-cookbook.rst:1936
#, python-format
msgid ""
"Logging calls (:meth:`~Logger.debug`, :meth:`~Logger.info` etc.) only "
"take positional parameters for the actual logging message itself, with "
"keyword parameters used only for determining options for how to handle "
"the logging call (e.g. the ``exc_info`` keyword parameter to indicate "
"that traceback information should be logged, or the ``extra`` keyword "
"parameter to indicate additional contextual information to be added to "
"the log). So you cannot directly make logging calls using "
":meth:`str.format` or :class:`string.Template` syntax, because internally"
" the logging package uses %-formatting to merge the format string and the"
" variable arguments. There would no changing this while preserving "
"backward compatibility, since all logging calls which are out there in "
"existing code will be using %-format strings."
msgstr ""
"로깅 호출(:meth:`~Logger.debug`, :meth:`~Logger.info` 등)은 실제 로깅 메시지 자체를 위해서는 위치 "
"매개 변수만을 취하고, 키워드 매개 변수는 실제 로깅 호출을 어떻게 다뤄야 하는지를 지정하는 옵션을 결정하는 용도로만 사용됩니다 (예를 "
"들어, 트레이스백 정보를 로그 해야 할지를 가리키는 ``exc_info`` 키워드 매개 변수나 로그에 추가되는 문맥 정보를 나타내는 "
"``extra`` 키워드 매개 변수). 그래서 여러분은 :meth:`str.format` 또는 "
":class:`string.Template` 문법을 사용하여 직접 로깅 호출을 할 수 없습니다, 내부적으로 logging 패키지가 "
"%-포매팅을 사용하여 포맷 문자열과 변수 인자를 병합하기 때문입니다. 이전 버전과의 호환성을 유지하는 동안은 이 상황이 바뀌지 않을 "
"것입니다. 기존 코드에 있는 모든 로깅 호출이 %-포맷 문자열을 사용하기 때문입니다."

#: ../Doc/howto/logging-cookbook.rst:1948
#, python-format
msgid ""
"There have been suggestions to associate format styles with specific "
"loggers, but that approach also runs into backward compatibility problems"
" because any existing code could be using a given logger name and using "
"%-formatting."
msgstr ""
"포맷 스타일을 특정 로거와 연관시키는 제안이 있었지만, 이전 버전과의 호환성 문제가 있는데, 기존 코드가 그 로거 이름으로 %-포매팅을 "
"사용할 수 있기 때문입니다."

#: ../Doc/howto/logging-cookbook.rst:1952
msgid ""
"For logging to work interoperably between any third-party libraries and "
"your code, decisions about formatting need to be made at the level of the"
" individual logging call. This opens up a couple of ways in which "
"alternative formatting styles can be accommodated."
msgstr ""
"제삼자 라이브러리와 여러분의 코드 간에 상호 운용이 가능하도록 로깅 하려면, 개별 로깅 호출 수준에서 포매팅을 결정해야 합니다. 이렇게 "
"할 때 대체 포매팅 스타일을 수용 할 수 있는 몇 가지 길이 열립니다."

#: ../Doc/howto/logging-cookbook.rst:1959
msgid "Using LogRecord factories"
msgstr "LogRecord 팩토리 사용"

#: ../Doc/howto/logging-cookbook.rst:1961
#, python-format
msgid ""
"In Python 3.2, along with the :class:`~logging.Formatter` changes "
"mentioned above, the logging package gained the ability to allow users to"
" set their own :class:`LogRecord` subclasses, using the "
":func:`setLogRecordFactory` function. You can use this to set your own "
"subclass of :class:`LogRecord`, which does the Right Thing by overriding "
"the :meth:`~LogRecord.getMessage` method. The base class implementation "
"of this method is where the ``msg % args`` formatting happens, and where "
"you can substitute your alternate formatting; however, you should be "
"careful to support all formatting styles and allow %-formatting as the "
"default, to ensure interoperability with other code. Care should also be "
"taken to call ``str(self.msg)``, just as the base implementation does."
msgstr ""
"파이썬 3.2에서, 위에서 언급 한 :class:`~logging.Formatter` 변경 사항과 함께, logging 패키지는 "
":func:`setLogRecordFactory` 함수를 사용하여 사용자가 자신의 :class:`LogRecord` 서브 클래스를 설정할"
" 수 있는 기능을 얻었습니다. 이것을 사용하면, 원하는 일을 하도록 :meth:`~LogRecord.getMessage` 메서드를 "
"재정의하는 여러분 자신의 :class:`LogRecord` 서브 클래스를 설정할 수 있습니다. 이 메서드의 베이스 클래스 구현이 "
"``msg % args`` 포매팅이 일어나는 곳이며, 여러분이 대체 포매팅으로 치환할 수 있는 곳입니다; 그러나, 모든 포매팅 스타일을 "
"지원하면서 다른 코드와의 상호 운용성을 보장하기 위해 %-포매팅을 기본값으로 사용하도록 주의해야 합니다. 또한, 베이스 구현과 마찬가지로"
" ``str(self.msg)`` 를 호출하도록 주의해야 합니다."

#: ../Doc/howto/logging-cookbook.rst:1972
msgid ""
"Refer to the reference documentation on :func:`setLogRecordFactory` and "
":class:`LogRecord` for more information."
msgstr ""
"자세한 정보는 :func:`setLogRecordFactory`\\와 :class:`LogRecord` 에 대한 레퍼런스 설명서를 "
"참조하십시오."

#: ../Doc/howto/logging-cookbook.rst:1977
msgid "Using custom message objects"
msgstr "사용자 정의 메시지 객체 사용"

#: ../Doc/howto/logging-cookbook.rst:1979
msgid ""
"There is another, perhaps simpler way that you can use {}- and $- "
"formatting to construct your individual log messages. You may recall "
"(from :ref:`arbitrary-object-messages`) that when logging you can use an "
"arbitrary object as a message format string, and that the logging package"
" will call :func:`str` on that object to get the actual format string. "
"Consider the following two classes::"
msgstr ""
"{}- 및 $-포매팅을 사용하여 개별 로그 메시지를 작성할 수 있는 또 다른, 아마도 더 간단한 방법이 있습니다. "
"(:ref:`arbitrary-object-messages`\\에서) 로깅 할 때 임의의 객체를 메시지 포맷 문자열로 사용할 수 있고, "
"logging 패키지는 그 객체에 대해 :func:`str` 을 호출하여 실제 형식 문자열을 얻는다고 했던 것을 기억하실 수 있을 "
"겁니다. 다음 두 클래스를 생각해봅시다::"

#: ../Doc/howto/logging-cookbook.rst:2004
#, python-format
msgid ""
"Either of these can be used in place of a format string, to allow {}- or "
"$-formatting to be used to build the actual \"message\" part which "
"appears in the formatted log output in place of “%(message)s” or "
"“{message}” or “$message”. If you find it a little unwieldy to use the "
"class names whenever you want to log something, you can make it more "
"palatable if you use an alias such as ``M`` or ``_`` for the message (or "
"perhaps ``__``, if you are using ``_`` for localization)."
msgstr ""
"이 중 하나를 포맷 문자열 대신 사용하면, {}- 또는 $-포매팅을 사용하여 포맷된 로그 출력의 \"%(message)s\", "
"\"{message}\" 또는 \"$message\" 자리에 나타나는 실제 \"message\" 부분을 만들 수 있습니다. 어떤 것을 "
"로그 하고 싶을 때마다 클래스 이름을 사용하는 것이 다소 꼴사납다면, 메시지에 ``M`` 이나 ``_`` 과 같은 별칭을 사용해서 더 "
"쓸만하게 만들 수 있습니다 (또는 지역화에 ``_`` 를 사용하고 있다면, 아마도 ``__``)."

#: ../Doc/howto/logging-cookbook.rst:2012
msgid ""
"Examples of this approach are given below. Firstly, formatting with "
":meth:`str.format`::"
msgstr "이 접근법의 예가 아래에 나와 있습니다. 먼저, :meth:`str.format` 를 사용하는 포매팅입니다::"

#: ../Doc/howto/logging-cookbook.rst:2026
msgid "Secondly, formatting with :class:`string.Template`::"
msgstr "두 번째로, :class:`string.Template` 를 사용하는 포매팅입니다::"

#: ../Doc/howto/logging-cookbook.rst:2033
msgid ""
"One thing to note is that you pay no significant performance penalty with"
" this approach: the actual formatting happens not when you make the "
"logging call, but when (and if) the logged message is actually about to "
"be output to a log by a handler. So the only slightly unusual thing which"
" might trip you up is that the parentheses go around the format string "
"and the arguments, not just the format string. That’s because the __ "
"notation is just syntax sugar for a constructor call to one of the "
"``XXXMessage`` classes shown above."
msgstr ""
"한 가지 지적할 점은, 이 접근법이 성능상으로 큰 문제가 없다는 것입니다: 실제 포매팅은 로깅 호출을 할 때가 아니라 로깅 된 메시지를 "
"실제로 처리기가 로그로 출력할 때 (그리고 실제로 그렇게 될 때만) 발생합니다. 그래서 여러분이 실수할 수도 있을 특이함은 괄호가 포맷 "
"문자열과 인자들을 모두 감싼다는 것뿐입니다. __ 표기법이 단지 ``XXXMessage`` 클래스 중 하나에 대한 생성자 호출의 편의 "
"문법이기 때문입니다."

#: ../Doc/howto/logging-cookbook.rst:2047
msgid "Configuring filters with :func:`dictConfig`"
msgstr ":func:`dictConfig`\\로 필터 구성하기"

#: ../Doc/howto/logging-cookbook.rst:2049
msgid ""
"You *can* configure filters using :func:`~logging.config.dictConfig`, "
"though it might not be obvious at first glance how to do it (hence this "
"recipe). Since :class:`~logging.Filter` is the only filter class included"
" in the standard library, and it is unlikely to cater to many "
"requirements (it's only there as a base class), you will typically need "
"to define your own :class:`~logging.Filter` subclass with an overridden "
":meth:`~logging.Filter.filter` method. To do this, specify the ``()`` key"
" in the configuration dictionary for the filter, specifying a callable "
"which will be used to create the filter (a class is the most obvious, but"
" you can provide any callable which returns a :class:`~logging.Filter` "
"instance). Here is a complete example::"
msgstr ""
":func:`~logging.config.dictConfig` 를 사용하여 필터를 구성할 수 *있습니다*. 하지만 처음에는 어떻게 해야 "
"할지 명확하지 않을 수 있습니다 (그래서 이 조리법을 제공합니다). :class:`~logging.Filter` 가 표준 라이브러리에 "
"포함된 유일한 필터 클래스이고, 많은 요구 사항을 충족시키지는 않을 것이기 때문에 (오직 베이스 클래스로 제공됩니다), 일반적으로 "
":meth:`~logging.Filter.filter` 메서드를 재정의하는 여러분 자신의 :class:`~logging.Filter` "
"서브 클래스를 정의할 필요가 있습니다. 이렇게 하려면, 필터를 생성하는 데 사용될 콜러블을 필터의 구성 딕셔너리에 ``()`` 키로 "
"지정하십시오 (클래스가 가장 분명하지만 :class:`~logging.Filter` 인스턴스를 반환하는 콜러블은 모두 가능합니다). "
"다음은 완전한 예입니다::"

#: ../Doc/howto/logging-cookbook.rst:2102
msgid ""
"This example shows how you can pass configuration data to the callable "
"which constructs the instance, in the form of keyword parameters. When "
"run, the above script will print:"
msgstr ""
"이 예제는 인스턴스를 만드는 콜러블로 키워드 매개 변수 형식으로 구성 데이터를 전달하는 방법을 보여줍니다. 실행하면, 위의 스크립트는 "
"다음을 인쇄합니다:"

#: ../Doc/howto/logging-cookbook.rst:2110
msgid "which shows that the filter is working as configured."
msgstr "필터가 구성된 대로 작동하고 있음을 보여줍니다."

#: ../Doc/howto/logging-cookbook.rst:2112
msgid "A couple of extra points to note:"
msgstr "주목해야 할 몇 가지 추가 사항:"

#: ../Doc/howto/logging-cookbook.rst:2114
msgid ""
"If you can't refer to the callable directly in the configuration (e.g. if"
" it lives in a different module, and you can't import it directly where "
"the configuration dictionary is), you can use the form ``ext://...`` as "
"described in :ref:`logging-config-dict-externalobj`. For example, you "
"could have used the text ``'ext://__main__.MyFilter'`` instead of "
"``MyFilter`` in the above example."
msgstr ""
"구성에서 직접 참조할 수 없는 경우 (예를 들어, 다른 모듈에 있고 구성 딕셔너리가 있는 곳에서 직접 임포트 할 수 없는 경우), "
":ref:`logging-config-dict-externalobj` 에 설명된 대로 ``ext://...`` 형식을 사용할 수 "
"있습니다. 예를 들어, 위의 예에서 ``MyFilter`` 대신 ``'ext://__main__.MyFilter'`` 를 사용할 수 "
"있습니다."

#: ../Doc/howto/logging-cookbook.rst:2121
msgid ""
"As well as for filters, this technique can also be used to configure "
"custom handlers and formatters. See :ref:`logging-config-dict-userdef` "
"for more information on how logging supports using user-defined objects "
"in its configuration, and see the other cookbook recipe :ref:`custom-"
"handlers` above."
msgstr ""
"필터뿐만 아니라, 이 기술을 사용자 정의 처리기 및 포매터를 구성하는데 사용할 수도 있습니다. logging이 구성에서 사용자 정의 "
"객체를 어떻게 지원하는지에 대한 더 많은 정보는 :ref:`logging-config-dict-userdef` 를 보시고, 위의 다른 "
"요리책 조리법 :ref:`custom-handlers` 도 보십시오."

#: ../Doc/howto/logging-cookbook.rst:2130
msgid "Customized exception formatting"
msgstr "사용자 정의된 예외 포매팅"

#: ../Doc/howto/logging-cookbook.rst:2132
msgid ""
"There might be times when you want to do customized exception formatting "
"- for argument's sake, let's say you want exactly one line per logged "
"event, even when exception information is present. You can do this with a"
" custom formatter class, as shown in the following example::"
msgstr ""
"예외 포매팅을 사용자 정의하고 싶을 때가 있습니다 - 논쟁의 여지는 있지만, 예외 정보가 포함된 경우에도 이벤트 당 정확히 한 줄이 "
"기록되기 원한다고 합시다. 다음 예제처럼, 사용자 정의 포매터 클래스를 사용할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:2173
msgid "When run, this produces a file with exactly two lines:"
msgstr "실행하면, 정확하게 두 줄의 파일이 생성됩니다:"

#: ../Doc/howto/logging-cookbook.rst:2180
msgid ""
"While the above treatment is simplistic, it points the way to how "
"exception information can be formatted to your liking. The "
":mod:`traceback` module may be helpful for more specialized needs."
msgstr ""
"위의 처리는 단순하지만, 예외 정보를 원하는 대로 포맷하는 방법을 알려줍니다. :mod:`traceback` 모듈은 더욱 전문화된 요구에"
" 도움이 될 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:2187
msgid "Speaking logging messages"
msgstr "로깅 메시지 말하기"

#: ../Doc/howto/logging-cookbook.rst:2189
msgid ""
"There might be situations when it is desirable to have logging messages "
"rendered in an audible rather than a visible format. This is easy to do "
"if you have text-to-speech (TTS) functionality available in your system, "
"even if it doesn't have a Python binding. Most TTS systems have a command"
" line program you can run, and this can be invoked from a handler using "
":mod:`subprocess`. It's assumed here that TTS command line programs won't"
" expect to interact with users or take a long time to complete, and that "
"the frequency of logged messages will be not so high as to swamp the user"
" with messages, and that it's acceptable to have the messages spoken one "
"at a time rather than concurrently, The example implementation below "
"waits for one message to be spoken before the next is processed, and this"
" might cause other handlers to be kept waiting. Here is a short example "
"showing the approach, which assumes that the ``espeak`` TTS package is "
"available::"
msgstr ""
"로깅 메시지를 보여주는 대신 들려주는 것이 바람직한 상황이 있을 수 있습니다. 여러분의 시스템에 텍스트-음성 변환 (TTS) 기능이 "
"있다면 쉽습니다, 파이썬 바인딩이 없어도 됩니다. 대부분의 TTS 시스템에는 실행할 수 있는 명령행 프로그램이 있으며, 이것을 "
":mod:`subprocess` 를 사용하여 처리기에서 호출 할 수 있습니다. 여기서 TTS 명령행 프로그램이 사용자와 상호 작용하거나,"
" 완료하는 데 오랜 시간이 걸릴 것으로 기대되지 않으며, 로그 되는 메시지의 빈도가 메시지로 사용자를 압도할 정도로 높지 않으며, "
"메시지는 동시에 처리되지 않고 한 번에 하나씩 읽어도 된다고 가정합니다. 아래의 예제 구현은 다음 메시지가 처리되기 전에 하나의 메시지를"
" 다 읽을 때까지 대기하고, 이 때문에 다른 처리기가 대기 상태로 유지될 수 있습니다. 다음은 ``espeak`` TTS 패키지가 사용 "
"가능하다고 가정하는 접근법을 보여주는 간단한 예입니다::"

#: ../Doc/howto/logging-cookbook.rst:2231
msgid ""
"When run, this script should say \"Hello\" and then \"Goodbye\" in a "
"female voice."
msgstr "실행하면, 이 스크립트는 여성 음성으로 \"Hello\"와 \"Goodbye\"를 차례대로 말합니다."

#: ../Doc/howto/logging-cookbook.rst:2233
msgid ""
"The above approach can, of course, be adapted to other TTS systems and "
"even other systems altogether which can process messages via external "
"programs run from a command line."
msgstr ""
"물론 위의 접근법은 다른 TTS 시스템과 명령행에서 실행되는 외부 프로그램을 통해 메시지를 처리 ​​할 수 있는 전혀 다른 시스템에도 "
"적용될 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:2241
msgid "Buffering logging messages and outputting them conditionally"
msgstr "로깅 메시지를 버퍼링하고 조건부 출력하기"

#: ../Doc/howto/logging-cookbook.rst:2243
msgid ""
"There might be situations where you want to log messages in a temporary "
"area and only output them if a certain condition occurs. For example, you"
" may want to start logging debug events in a function, and if the "
"function completes without errors, you don't want to clutter the log with"
" the collected debug information, but if there is an error, you want all "
"the debug information to be output as well as the error."
msgstr ""
"임시 영역에 메시지를 기록하고 특정 조건이 발생할 때만 메시지를 출력하려는 ​​상황이 있을 수 있습니다. 예를 들어, 함수에서 디버그 "
"이벤트를 로깅 하기를 원할 수 있습니다. 함수가 에러 없이 완료되면 수집된 디버그 정보로 로그를 어지럽히고 싶지 않지만, 에러가 있으면 "
"에러뿐만 아니라 모든 디버그 정보를 출력하고 싶습니다."

#: ../Doc/howto/logging-cookbook.rst:2250
msgid ""
"Here is an example which shows how you could do this using a decorator "
"for your functions where you want logging to behave this way. It makes "
"use of the :class:`logging.handlers.MemoryHandler`, which allows "
"buffering of logged events until some condition occurs, at which point "
"the buffered events are ``flushed`` - passed to another handler (the "
"``target`` handler) for processing. By default, the ``MemoryHandler`` "
"flushed when its buffer gets filled up or an event whose level is greater"
" than or equal to a specified threshold is seen. You can use this recipe "
"with a more specialised subclass of ``MemoryHandler`` if you want custom "
"flushing behavior."
msgstr ""
"다음은 로깅이 이러한 방식으로 작동하기 원하는 함수에 데코레이터를 사용하여 이를 수행할 방법을 보여주는 예제입니다. "
":class:`logging.handlers.MemoryHandler` 를 사용하는데, 어떤 상황이 발생할 때까지 로그 된 이벤트를 "
"버퍼링할 수 있도록 하고, 때가 되면 버퍼링 된 이벤트들이 ``flush`` 됩니다 - 처리를 위해 다른 처리기(``target`` "
"처리기)로 전달됩니다. 기본적으로, ``MemoryHandler`` 는 버퍼가 다 차거나 수준이 지정된 임계값보다 크거나 같은 이벤트가 "
"발생하면 플러시 됩니다. 사용자 정의 플러시 동작을 원할 경우, 이 조리법을 ``MemoryHandler`` 의 더 특수한 서브 클래스와"
" 함께 사용할 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:2260
msgid ""
"The example script has a simple function, ``foo``, which just cycles "
"through all the logging levels, writing to ``sys.stderr`` to say what "
"level it's about to log at, and then actually logging a message at that "
"level. You can pass a parameter to ``foo`` which, if true, will log at "
"ERROR and CRITICAL levels - otherwise, it only logs at DEBUG, INFO and "
"WARNING levels."
msgstr ""
"예제 스크립트에는 간단한 함수 ``foo`` 가 있는데, 모든 로그 수준을 순회하면서, 어떤 수준으로 로그 할지를 "
"``sys.stderr`` 에 쓴 다음, 그 수준으로 실제 메시지를 로깅 합니다. 매개 변수를 ``foo`` 에 전달할 수 있는데, "
"참이면 ERROR 및 CRITICAL 수준으로 로그 합니다 - 그렇지 않으면 DEBUG, INFO 및 WARNING 수준에서만 로그 "
"합니다."

#: ../Doc/howto/logging-cookbook.rst:2266
msgid ""
"The script just arranges to decorate ``foo`` with a decorator which will "
"do the conditional logging that's required. The decorator takes a logger "
"as a parameter and attaches a memory handler for the duration of the call"
" to the decorated function. The decorator can be additionally "
"parameterised using a target handler, a level at which flushing should "
"occur, and a capacity for the buffer. These default to a "
":class:`~logging.StreamHandler` which writes to ``sys.stderr``, "
"``logging.ERROR`` and ``100`` respectively."
msgstr ""
"이 스크립트는 필요한 조건부 로깅을 수행할 데코레이터로 ``foo`` 를 데코레이트 하기만 합니다. 데코레이터는 로거를 매개 변수로 받고"
" 데코레이트 된 함수가 호출되는 동안 메모리 처리기를 연결합니다. 데코레이터는 target 처리기, 플러싱이 발생해야 하는 수준 및 버퍼"
" 용량을 추가로 매개 변수로 받을 수 있습니다. 이것들은 각각 ``sys.stderr`` 로 쓰는 "
":class:`~logging.StreamHandler`, ``logging.ERROR``, ``100`` 을 기본값으로 합니다."

#: ../Doc/howto/logging-cookbook.rst:2274
msgid "Here's the script::"
msgstr "스크립트는 다음과 같습니다::"

#: ../Doc/howto/logging-cookbook.rst:2337
msgid "When this script is run, the following output should be observed:"
msgstr "이 스크립트를 실행하면 다음과 같은 출력이 나타납니다.:"

#: ../Doc/howto/logging-cookbook.rst:2367
msgid ""
"As you can see, actual logging output only occurs when an event is logged"
" whose severity is ERROR or greater, but in that case, any previous "
"events at lower severities are also logged."
msgstr ""
"보시다시피, 실제 로깅 출력은 심각도가 ERROR 이상인 이벤트가 기록될 때만 발생하지만, 이 경우 심각도가 낮은 이전 이벤트도 "
"기록됩니다."

#: ../Doc/howto/logging-cookbook.rst:2371
msgid "You can of course use the conventional means of decoration::"
msgstr "물론 전통적인 데코레이션 수단을 쓸 수 있습니다.::"

#: ../Doc/howto/logging-cookbook.rst:2381
msgid "Formatting times using UTC (GMT) via configuration"
msgstr "구성을 통해 UTC(GMT)로 시간을 포맷하기"

#: ../Doc/howto/logging-cookbook.rst:2383
msgid ""
"Sometimes you want to format times using UTC, which can be done using a "
"class such as `UTCFormatter`, shown below::"
msgstr ""
"때로는 UTC를 사용하여 시간을 포맷하고 싶습니다. 아래에 표시된 `UTCFormatter` 와 같은 클래스를 사용할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:2392
msgid ""
"and you can then use the ``UTCFormatter`` in your code instead of "
":class:`~logging.Formatter`. If you want to do that via configuration, "
"you can use the :func:`~logging.config.dictConfig` API with an approach "
"illustrated by the following complete example::"
msgstr ""
"이제 :class:`~logging.Formatter` 대신 코드에서 ``UTCFormatter`` 를 사용할 수 있습니다. 구성을 통해"
" 이를 수행하려면, 다음에 나오는 완전한 예제에 의해 설명된 접근법으로 :func:`~logging.config.dictConfig` "
"API를 사용할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:2435
msgid "When this script is run, it should print something like:"
msgstr "이 스크립트를 실행하면, 다음과 같은 내용을 인쇄합니다:"

#: ../Doc/howto/logging-cookbook.rst:2442
msgid ""
"showing how the time is formatted both as local time and UTC, one for "
"each handler."
msgstr "시간이 한 처리기에서는 UTC로, 다른 처리기에서는 지역 시간으로 포맷되는 것을 보여줍니다."

#: ../Doc/howto/logging-cookbook.rst:2449
msgid "Using a context manager for selective logging"
msgstr "선택적 로깅을 위해 컨텍스트 관리자 사용하기"

#: ../Doc/howto/logging-cookbook.rst:2451
msgid ""
"There are times when it would be useful to temporarily change the logging"
" configuration and revert it back after doing something. For this, a "
"context manager is the most obvious way of saving and restoring the "
"logging context. Here is a simple example of such a context manager, "
"which allows you to optionally change the logging level and add a logging"
" handler purely in the scope of the context manager::"
msgstr ""
"로깅 구성을 일시적으로 변경하고 무언가를 한 후에 되돌리는 것이 유용할 때가 있습니다. 이를 위해, 컨텍스트 관리자는 로깅 컨텍스트를 "
"저장하고 복원하는 가장 분명한 방법입니다. 다음은 그러한 컨텍스트 관리자의 간단한 예입니다. 컨텍스트 관리자의 범위 안에서 선택적으로 "
"로깅 수준을 변경하고 로깅 처리기를 추가 할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:2484
msgid ""
"If you specify a level value, the logger's level is set to that value in "
"the scope of the with block covered by the context manager. If you "
"specify a handler, it is added to the logger on entry to the block and "
"removed on exit from the block. You can also ask the manager to close the"
" handler for you on block exit - you could do this if you don't need the "
"handler any more."
msgstr ""
"수준 값을 지정하면, 로거의 수준은 컨텍스트 관리자가 적용되는 with 블록의 범위 안에서 해당 값으로 설정됩니다. 처리기를 지정하면, "
"블록 진입 시 로거에 추가되고 블록에서 빠져나갈 때 제거됩니다. 블록을 빠져나갈 때 처리기를 닫도록 관리자에게 요청할 수도 있습니다 - "
"더는 처리기가 필요하지 않으면 이렇게 할 수 있습니다."

#: ../Doc/howto/logging-cookbook.rst:2490
msgid ""
"To illustrate how it works, we can add the following block of code to the"
" above::"
msgstr "작동 원리를 보여주기 위해, 다음 코드 블록을 위에 추가 할 수 있습니다::"

#: ../Doc/howto/logging-cookbook.rst:2508
msgid ""
"We initially set the logger's level to ``INFO``, so message #1 appears "
"and message #2 doesn't. We then change the level to ``DEBUG`` temporarily"
" in the following ``with`` block, and so message #3 appears. After the "
"block exits, the logger's level is restored to ``INFO`` and so message #4"
" doesn't appear. In the next ``with`` block, we set the level to "
"``DEBUG`` again but also add a handler writing to ``sys.stdout``. Thus, "
"message #5 appears twice on the console (once via ``stderr`` and once via"
" ``stdout``). After the ``with`` statement's completion, the status is as"
" it was before so message #6 appears (like message #1) whereas message #7"
" doesn't (just like message #2)."
msgstr ""
"우리는 초기에 로거 수준을 ``INFO`` 로 설정합니다. 그래서 메시지 #1은 나타나고 메시지 #2는 나타나지 않습니다. 그다음에 "
"``with`` 블록에서 수준을 ``DEBUG`` 로 임시 변경하면, 메시지 #3이 나타납니다. 블록이 종료되면 로거 수준이 "
"``INFO`` 로 복원되므로, 메시지 #4가 표시되지 않습니다. 그다음 ``with`` 블록에서 수준을 다시 ``DEBUG`` 로 다시"
" 설정하지만, ``sys.stdout`` 으로 쓰는 처리기도 추가합니다. 따라서 메시지 #5는 콘솔에 두 번 표시됩니다 "
"(``stderr`` 를 통해 한 번, ``stdout`` 을 통해 한 번). ``with`` 문장이 완료된 후에 상태는 이전과 "
"같으므로, (메시지 #1처럼) 메시지 #6이 나타나고, (메시지 #2처럼) 메시지 #7은 보이지 않습니다."

#: ../Doc/howto/logging-cookbook.rst:2518
msgid "If we run the resulting script, the result is as follows:"
msgstr "이렇게 만든 스크립트를 실행하면, 결과는 다음과 같습니다:"

#: ../Doc/howto/logging-cookbook.rst:2529
msgid ""
"If we run it again, but pipe ``stderr`` to ``/dev/null``, we see the "
"following, which is the only message written to ``stdout``:"
msgstr ""
"다시 실행하면서 ``stderr`` 를 ``/dev/null`` 로 리디렉트하면, 다음과 같이 ``stdout`` 으로 출력된 메시지만 "
"나타납니다:"

#: ../Doc/howto/logging-cookbook.rst:2537
msgid "Once again, but piping ``stdout`` to ``/dev/null``, we get:"
msgstr "다시 한번, 하지만 ``stdout`` 을 ``/dev/null`` 로 리디렉트하면, 이렇게 됩니다:"

#: ../Doc/howto/logging-cookbook.rst:2547
msgid ""
"In this case, the message #5 printed to ``stdout`` doesn't appear, as "
"expected."
msgstr "이 경우, ``stdout`` 에 인쇄된 메시지 #5는 예상대로 나타나지 않습니다."

#: ../Doc/howto/logging-cookbook.rst:2549
msgid ""
"Of course, the approach described here can be generalised, for example to"
" attach logging filters temporarily. Note that the above code works in "
"Python 2 as well as Python 3."
msgstr ""
"물론 여기서 설명한 방법을 일반화 할 수 있습니다. 예를 들어 로깅 필터를 임시로 첨부 할 수 있습니다. 위의 코드는 파이썬 2와 파이썬"
" 3에서 모두 작동합니다."
