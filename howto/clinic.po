# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-19 18:31+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:5
msgid "Argument Clinic How-To"
msgstr "인자 클리닉 How-To"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst
msgid "author"
msgstr "저자"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:7
msgid "Larry Hastings"
msgstr "Larry Hastings"

msgid "Abstract"
msgstr "요약"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:12
msgid ""
"Argument Clinic is a preprocessor for CPython C files. Its purpose is to "
"automate all the boilerplate involved with writing argument parsing code "
"for \"builtins\". This document shows you how to convert your first C "
"function to work with Argument Clinic, and then introduces some advanced "
"topics on Argument Clinic usage."
msgstr ""
"인자 클리닉(Argument Clinic)은 CPython C 파일을 위한 전 처리기입니다. 그 목적은 \"내장\"에 대한 인자 "
"구문 분석 코드 작성과 관련된 모든 상용구를 자동화하는 것입니다. 이 설명서는 여러분의 첫 번째 C 함수를 인자 클리닉과 함께 "
"작동하도록 변환하는 방법을 보여준 다음, 인자 클리닉 사용에 대한 몇 가지 고급 주제를 소개합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:19
msgid ""
"Currently Argument Clinic is considered internal-only for CPython.  Its "
"use is not supported for files outside CPython, and no guarantees are "
"made regarding backwards compatibility for future versions.  In other "
"words: if you maintain an external C extension for CPython, you're "
"welcome to experiment with Argument Clinic in your own code.  But the "
"version of Argument Clinic that ships with the next version of CPython "
"*could* be totally incompatible and break all your code."
msgstr ""
"현재 인자 클리닉은 CPython에 내부 전용으로 간주합니다. CPython 외부의 파일에 대해서는 사용이 지원되지 않으며, 향후 "
"버전에서 이전 버전과의 호환성을 보장하지 않습니다. 즉: 여러분이 CPython에 대한 외부 C 확장을 유지한다면, 여러분의 자체 "
"코드에서 인자 클리닉을 실험하는 것은 환영합니다. 그러나 다음 버전의 CPython과 함께 제공되는 인자 클리닉 버전은 완전히 "
"호환되지 않고 여러분의 모든 코드를 망가뜨릴 수 *있습니다*."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:29
msgid "The Goals Of Argument Clinic"
msgstr "인자 클리닉의 목표"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:31
msgid ""
"Argument Clinic's primary goal is to take over responsibility for all "
"argument parsing code inside CPython.  This means that, when you convert "
"a function to work with Argument Clinic, that function should no longer "
"do any of its own argument parsing—the code generated by Argument Clinic "
"should be a \"black box\" to you, where CPython calls in at the top, and "
"your code gets called at the bottom, with ``PyObject *args`` (and maybe "
"``PyObject *kwargs``) magically converted into the C variables and types "
"you need."
msgstr ""
"인자 클리닉의 주요 목표는 CPython 내부의 모든 인자 구문 분석 코드에 대한 책임을 인수하는 것입니다. 즉, 인자 클리닉에서 "
"작동하도록 함수를 변환할 때, 해당 함수는 더는 자체 인자 구문 분석을 수행하지 않아야 합니다 - 인자 클리닉에서 생성된 코드는 "
"여러분에게 \"블랙박스\"여야 합니다, CPython이 맨 위에서 호출하고, 맨 아래에서 여러분의 코드가 호출되고, "
"``PyObject *args`` (그리고 아마도 ``PyObject *kwargs``)가 여러분이 필요로 하는 C 변수와 형으로 "
"마술처럼 변환됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:41
msgid ""
"In order for Argument Clinic to accomplish its primary goal, it must be "
"easy to use.  Currently, working with CPython's argument parsing library "
"is a chore, requiring maintaining redundant information in a surprising "
"number of places. When you use Argument Clinic, you don't have to repeat "
"yourself."
msgstr ""
"인자 클리닉이 기본 목표를 달성하려면, 사용하기 쉬워야 합니다. 현재, CPython의 인자 구문 분석 라이브러리로 작업하는 것은 "
"따분한 일이며, 놀랄 정도로 많은 장소에서 중복된 정보를 유지해야 합니다. 인자 클리닉을 사용할 때, 여러분 스스로 반복할 필요가 "
"없습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:47
msgid ""
"Obviously, no one would want to use Argument Clinic unless it's solving "
"their problem—and without creating new problems of its own. So it's "
"paramount that Argument Clinic generate correct code. It'd be nice if the"
" code was faster, too, but at the very least it should not introduce a "
"major speed regression.  (Eventually Argument Clinic *should* make a "
"major speedup possible—we could rewrite its code generator to produce "
"tailor-made argument parsing code, rather than calling the general-"
"purpose CPython argument parsing library.  That would make for the "
"fastest argument parsing possible!)"
msgstr ""
"분명히, 자체적으로 새로운 문제를 만들지 않으면서 자신의 문제를 해결하지 않는 한 아무도 인자 클리닉을 사용하고 싶어 하지 않을 "
"것입니다. 따라서 인자 클리닉이 올바른 코드를 생성하는 것이 가장 중요합니다. 코드가 더 빠르면 좋겠지만, 최소한 주요 속도 회귀를"
" 도입해서는 안 됩니다. (인자 클리닉은 결국 대폭적인 속도 향상을 가능하게 해야 *합니다* - 범용 CPython 인자 구문 분석"
" 라이브러리를 호출하는 대신 맞춤형 인자 구문 분석 코드를 생성하도록 코드 생성기를 다시 작성할 수 있습니다. 그러면 가능한 가장 "
"빠른 인자 구문 분석이 될 것입니다!)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:59
msgid ""
"Additionally, Argument Clinic must be flexible enough to work with any "
"approach to argument parsing.  Python has some functions with some very "
"strange parsing behaviors; Argument Clinic's goal is to support all of "
"them."
msgstr ""
"또한, 인자 클리닉은 인자 구문 분석에 대한 모든 접근 방식을 사용할 수 있을 만큼 유연해야 합니다. 파이썬에는 매우 이상한 구문 "
"분석 동작을 가진 몇 가지 함수가 있습니다; 인자 클리닉의 목표는 이들 모두를 지원하는 것입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:64
msgid ""
"Finally, the original motivation for Argument Clinic was to provide "
"introspection \"signatures\" for CPython builtins. It used to be, the "
"introspection query functions would throw an exception if you passed in a"
" builtin.  With Argument Clinic, that's a thing of the past!"
msgstr ""
"마지막으로, 인자 클리닉의 원래 동기는 CPython 내장에 대한 인트로스펙션 \"서명\"을 제공하는 것이었습니다. 예전에는 내장을"
" 전달하면 인트로스펙션 조회 함수에서 예외가 발생했습니다. 인자 클리닉을 사용하면, 그것은 과거의 일입니다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:70
msgid ""
"One idea you should keep in mind, as you work with Argument Clinic: the "
"more information you give it, the better job it'll be able to do. "
"Argument Clinic is admittedly relatively simple right now.  But as it "
"evolves it will get more sophisticated, and it should be able to do many "
"interesting and smart things with all the information you give it."
msgstr ""
"인자 클리닉과 함께 일할 때, 명심해야 할 한 가지 아이디어가 있습니다: 더 많은 정보를 제공할수록, 더 나은 작업을 수행할 수 "
"있습니다. 인자 클리닉은 현재 비교적 간단합니다. 그러나 진화함에 따라 더 정교해질 것이며, 여러분이 제공하는 모든 정보로 많은 "
"흥미롭고 현명한 일을 할 수 있어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:80
msgid "Basic Concepts And Usage"
msgstr "기본 개념과 사용법"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:82
msgid ""
"Argument Clinic ships with CPython; you'll find it in "
"``Tools/clinic/clinic.py``. If you run that script, specifying a C file "
"as an argument:"
msgstr ""
"인자 클리닉은 CPython과 함께 제공됩니다; ``Tools/clinic/clinic.py``\\에서 찾을 수 있습니다. 해당 "
"스크립트를 실행하면, C 파일을 인자로 지정합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:89
msgid ""
"Argument Clinic will scan over the file looking for lines that look "
"exactly like this:"
msgstr "인자 클리닉은 파일을 스캔하여 다음과 같은 줄을 찾습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:96
msgid ""
"When it finds one, it reads everything up to a line that looks exactly "
"like this:"
msgstr "찾으면, 다음과 같은 줄까지 모든 것을 읽습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:103
msgid ""
"Everything in between these two lines is input for Argument Clinic. All "
"of these lines, including the beginning and ending comment lines, are "
"collectively called an Argument Clinic \"block\"."
msgstr ""
"이 두 줄 사이의 모든 것은 인자 클리닉에 대한 입력입니다. 시작과 끝 주석 줄을 포함하여, 이러한 모든 줄을 총칭하여 인자 클리닉"
" \"블록\"이라고 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:107
msgid ""
"When Argument Clinic parses one of these blocks, it generates output.  "
"This output is rewritten into the C file immediately after the block, "
"followed by a comment containing a checksum. The Argument Clinic block "
"now looks like this:"
msgstr ""
"인자 클리닉이 이러한 블록 중 하나를 구문 분석할 때, 출력을 생성합니다. 이 출력은 C 파일의 블록 바로 뒤에 다시 쓰이고, "
"체크섬이 포함된 주석이 이어집니다. 인자 클리닉 블록은 이제 다음과 같습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:120
msgid ""
"If you run Argument Clinic on the same file a second time, Argument "
"Clinic will discard the old output and write out the new output with a "
"fresh checksum line.  However, if the input hasn't changed, the output "
"won't change either."
msgstr ""
"같은 파일에서 인자 클리닉을 두 번 실행하면, 인자 클리닉은 이전 출력을 버리고 새로운 체크섬 줄로 새 출력을 작성합니다. 그러나,"
" 입력이 변경되지 않았으면, 출력도 변경되지 않습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:124
msgid ""
"You should never modify the output portion of an Argument Clinic block.  "
"Instead, change the input until it produces the output you want.  (That's"
" the purpose of the checksum—to detect if someone changed the output, as "
"these edits would be lost the next time Argument Clinic writes out fresh "
"output.)"
msgstr ""
"인자 클리닉 블록의 출력 부분을 수정해서는 안 됩니다. 대신, 원하는 출력을 생성할 때까지 입력을 변경하십시오. (그것이 체크섬의 "
"목적입니다 - 누군가 출력을 변경했는지 감지하는 것, 다음에 인자 클리닉이 새로운 출력을 작성할 때 이러한 편집이 손실되기 "
"때문입니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:129
msgid ""
"For the sake of clarity, here's the terminology we'll use with Argument "
"Clinic:"
msgstr "명확성을 위해, 인자 클리닉에서 사용할 용어는 다음과 같습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:131
msgid "The first line of the comment (``/*[clinic input]``) is the *start line*."
msgstr "주석의 첫 번째 줄(``/*[clinic input]``)은 *시작 줄(start line)*\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:132
msgid ""
"The last line of the initial comment (``[clinic start generated "
"code]*/``) is the *end line*."
msgstr "초기 주석의 마지막 줄(``[clinic start generated code]*/``)은 *끝줄(end line)*\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:133
msgid ""
"The last line (``/*[clinic end generated code: checksum=...]*/``) is the "
"*checksum line*."
msgstr ""
"마지막 줄(``/*[clinic end generated code: checksum=...]*/``)은 *체크섬 줄(checksum"
" line)*\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:134
msgid "In between the start line and the end line is the *input*."
msgstr "시작 줄과 끝줄 사이에 잇는 것이 *입력(input)*\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:135
msgid "In between the end line and the checksum line is the *output*."
msgstr "끝줄과 체크섬 줄 사이에 있는 것이 *출력(output)*\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:136
msgid ""
"All the text collectively, from the start line to the checksum line "
"inclusively, is the *block*.  (A block that hasn't been successfully "
"processed by Argument Clinic yet doesn't have output or a checksum line, "
"but it's still considered a block.)"
msgstr ""
"시작 줄에서 체크섬 줄까지 모든 텍스트는 총칭하여 *블록(block)*\\입니다. (인자 클리닉에서 성공적으로 처리되지 않은 블록은"
" 아직 출력이나 체크섬 줄이 없지만, 여전히 블록으로 간주합니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:143
msgid "Converting Your First Function"
msgstr "첫 번째 함수 변환하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:145
msgid ""
"The best way to get a sense of how Argument Clinic works is to convert a "
"function to work with it.  Here, then, are the bare minimum steps you'd "
"need to follow to convert a function to work with Argument Clinic.  Note "
"that for code you plan to check in to CPython, you really should take the"
" conversion farther, using some of the advanced concepts you'll see later"
" on in the document (like \"return converters\" and \"self converters\")."
" But we'll keep it simple for this walkthrough so you can learn."
msgstr ""
"인자 클리닉의 작동 방식을 이해하는 가장 좋은 방법은 함수를 작동하도록 변환하는 것입니다. 다음은, 인자 클리닉에서 작동하도록 "
"함수를 변환하기 위해 따라야 할 최소한의 단계입니다. CPython에 체크인하려는 코드의 경우, 설명서의 뒷부분에서 볼 수 있는 "
"고급 개념(\"반환 변환기\"와 \"self 변환기\"와 같은)을 사용하여 변환 작업을 더 진행해야 합니다. 하지만 이 연습에서는 "
"배우기 쉽도록 간단하게 유지하겠습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:154
msgid "Let's dive in!"
msgstr "뛰어듭시다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:156
msgid ""
"Make sure you're working with a freshly updated checkout of the CPython "
"trunk."
msgstr "CPython trunk의 새로 갱신된 체크 아웃으로 작업하고 있는지 확인하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:159
msgid ""
"Find a Python builtin that calls either :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_ParseTupleAndKeywords`, and hasn't been converted to work "
"with Argument Clinic yet. For my example I'm using "
"``_pickle.Pickler.dump()``."
msgstr ""
":c:func:`PyArg_ParseTuple`\\이나 :c:func:`PyArg_ParseTupleAndKeywords` 를 "
"호출하고, 아직 인자 클리닉에서 작동하도록 변환되지 않은 파이썬 내장을 찾습니다. 제 예에서는 "
"``_pickle.Pickler.dump()``\\를 사용하고 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:164
msgid ""
"If the call to the ``PyArg_Parse`` function uses any of the following "
"format units:"
msgstr "``PyArg_Parse`` 함수에 대한 호출이 다음 포맷 단위 중 하나를 사용하거나:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:176
msgid ""
"or if it has multiple calls to :c:func:`PyArg_ParseTuple`, you should "
"choose a different function.  Argument Clinic *does* support all of these"
" scenarios.  But these are advanced topics—let's do something simpler for"
" your first function."
msgstr ""
"또는 :c:func:`PyArg_ParseTuple`\\에 대한 여러 호출이 있으면, 다른 함수를 선택해야 합니다. 인자 클리닉은 "
"이러한 모든 시나리오를 *지원합니다*. 그러나 이것들은 고급 주제입니다 - 첫 번째 함수로 더 간단한 것을 해봅시다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:181
msgid ""
"Also, if the function has multiple calls to :c:func:`PyArg_ParseTuple` or"
" :c:func:`PyArg_ParseTupleAndKeywords` where it supports different types "
"for the same argument, or if the function uses something besides "
"PyArg_Parse functions to parse its arguments, it probably isn't suitable "
"for conversion to Argument Clinic.  Argument Clinic doesn't support "
"generic functions or polymorphic parameters."
msgstr ""
"또한, 함수가 같은 인자에 대해 다른 형을 지원하는 :c:func:`PyArg_ParseTuple`\\이나 "
":c:func:`PyArg_ParseTupleAndKeywords` 에 대한 여러 호출이 있거나, 함수가 인자를 구문 분석하기 위해"
" PyArg_Parse 함수 이외의 것을 사용하면, 인자 클리닉으로 변환하는 데 적합하지 않을 수 있습니다. 인자 클리닉은 제네릭 "
"함수나 다형성 매개 변수를 지원하지 않습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:188
msgid "Add the following boilerplate above the function, creating our block::"
msgstr "함수 위에 다음과 같은 상용구를 추가하여, 블록을 만듭니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:193
msgid ""
"Cut the docstring and paste it in between the ``[clinic]`` lines, "
"removing all the junk that makes it a properly quoted C string. When "
"you're done you should have just the text, based at the left margin, with"
" no line wider than 80 characters. (Argument Clinic will preserve indents"
" inside the docstring.)"
msgstr ""
"독스트링을 잘라내어 ``[clinic]`` 줄 사이에 붙여넣고, 적절하게 인용된 C 문자열을 만드는 모든 정크를 제거합니다. "
"완료되면 왼쪽 여백을 기준으로 텍스트가 80자보다 넓은 줄이 없는, 텍스트만 남게 됩니다. (인자 클리닉은 독스트링 내부의 "
"들여쓰기를 유지합니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:199
msgid ""
"If the old docstring had a first line that looked like a function "
"signature, throw that line away.  (The docstring doesn't need it "
"anymore—when you use ``help()`` on your builtin in the future, the first "
"line will be built automatically based on the function's signature.)"
msgstr ""
"이전 독스트링에 함수 서명처럼 보이는 첫 번째 줄이 있으면, 해당 줄을 버립니다. (독스트링은 이것이 더는 필요하지 않습니다 - "
"향후 내장에 ``help()``\\를 사용할 때, 첫 번째 줄은 함수의 서명에 따라 자동으로 구축됩니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:205
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:226
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:250
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:308
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:348
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:375
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:481
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:533
msgid "Sample::"
msgstr "샘플::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:211
msgid ""
"If your docstring doesn't have a \"summary\" line, Argument Clinic will "
"complain.  So let's make sure it has one.  The \"summary\" line should be"
" a paragraph consisting of a single 80-column line at the beginning of "
"the docstring."
msgstr ""
"독스트링에 \"요약\" 줄이 없으면, 인자 클리닉이 불평합니다. 그러니 하나 있도록 합시다. \"요약\" 줄은 독스트링의 시작 "
"부분에 있는 단일 80열 줄로 구성된 단락이어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:216
msgid ""
"(Our example docstring consists solely of a summary line, so the sample "
"code doesn't have to change for this step.)"
msgstr "(예제 독스트링은 요약 줄로만 구성되어서, 이 단계에서 샘플 코드를 변경할 필요가 없습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:219
msgid ""
"Above the docstring, enter the name of the function, followed by a blank "
"line.  This should be the Python name of the function, and should be the "
"full dotted path to the function—it should start with the name of the "
"module, include any sub-modules, and if the function is a method on a "
"class it should include the class name too."
msgstr ""
"독스트링 위에, 함수 이름을 입력한 다음, 빈 줄을 입력합니다. 이것은 함수의 파이썬 이름이어야 하며, 함수에 대한 전체 점표기법 "
"경로여야 합니다 - 모듈 이름으로 시작하고, 모든 하위 모듈을 포함해야 하며, 함수가 클래스의 메서드이면 클래스 이름도 포함해야 "
"합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:234
msgid ""
"If this is the first time that module or class has been used with "
"Argument Clinic in this C file, you must declare the module and/or class."
"  Proper Argument Clinic hygiene prefers declaring these in a separate "
"block somewhere near the top of the C file, in the same way that include "
"files and statics go at the top.  (In our sample code we'll just show the"
" two blocks next to each other.)"
msgstr ""
"이 C 파일에서 해당 모듈이나 클래스가 인자 클리닉과 함께 처음 사용된 것이면, 모듈 및/또는 클래스를 선언해야 합니다. 적절한 "
"인자 클리닉 위생법은 인클루드 파일과 정적 객체가 상단에 가는 것과 같은 방식으로 C 파일의 상단 근처에 있는 별도의 블록에 이를 "
"선언하는 것을 선호합니다. (샘플 코드에서는 서로 옆에 있는 두 블록만 표시합니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:242
msgid ""
"The name of the class and module should be the same as the one seen by "
"Python.  Check the name defined in the :c:type:`PyModuleDef` or "
":c:type:`PyTypeObject` as appropriate."
msgstr ""
"클래스와 모듈의 이름은 파이썬에서 보는 이름과 같아야 합니다. :c:type:`PyModuleDef`\\나 "
":c:type:`PyTypeObject`\\에 정의된 이름을 적절하게 확인하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:246
msgid ""
"When you declare a class, you must also specify two aspects of its type "
"in C: the type declaration you'd use for a pointer to an instance of this"
" class, and a pointer to the :c:type:`PyTypeObject` for this class."
msgstr ""
"클래스를 선언할 때, C에서 해당 형의 두 가지 측면을 지정해야 합니다: 이 클래스의 인스턴스에 대한 포인터에 사용할 형 선언, "
"그리고 이 클래스를 위한 :c:type:`PyTypeObject`\\에 대한 포인터."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:266
msgid ""
"Declare each of the parameters to the function.  Each parameter should "
"get its own line.  All the parameter lines should be indented from the "
"function name and the docstring."
msgstr ""
"각 매개 변수를 함수에 선언합니다. 각 매개 변수는 자체 줄을 가져야 합니다. 모든 매개 변수 줄은 함수 이름과 독스트링에서 "
"들여쓰기 되어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:270
msgid "The general form of these parameter lines is as follows:"
msgstr "이러한 매개 변수 줄의 일반적인 형식은 다음과 같습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:276
msgid "If the parameter has a default value, add that after the converter:"
msgstr "매개 변수에 기본값이 있으면, 변환기(converter) 뒤에 추가하십시오:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:283
msgid ""
"Argument Clinic's support for \"default values\" is quite sophisticated; "
"please see :ref:`the section below on default values <default_values>` "
"for more information."
msgstr ""
"\"기본값\"에 대한 인자 클리닉의 지원은 매우 정교합니다; 자세한 내용은 :ref:`아래의 기본값에 관한 섹션 "
"<default_values>`\\을 참조하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:287
msgid "Add a blank line below the parameters."
msgstr "매개 변수 아래에 빈 줄을 추가합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:289
msgid ""
"What's a \"converter\"?  It establishes both the type of the variable "
"used in C, and the method to convert the Python value into a C value at "
"runtime. For now you're going to use what's called a \"legacy "
"converter\"—a convenience syntax intended to make porting old code into "
"Argument Clinic easier."
msgstr ""
"\"변환기(converter)\"는 무엇일까요? C에서 사용되는 변수의 형과, 실행 시간에 파이썬 값을 C값으로 변환하는 방법을 "
"모두 설정합니다. 지금은 이전 코드를 인자 클리닉으로 더 쉽게 이식할 수 있도록 고안된 편의 문법인 \"레거시 변환기\"를 사용할 "
"것입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:296
msgid ""
"For each parameter, copy the \"format unit\" for that parameter from the "
"``PyArg_Parse()`` format argument and specify *that* as its converter, as"
" a quoted string.  (\"format unit\" is the formal name for the one-to-"
"three character substring of the ``format`` parameter that tells the "
"argument parsing function what the type of the variable is and how to "
"convert it.  For more on format units please see :ref:`arg-parsing`.)"
msgstr ""
"매개 변수마다, ``PyArg_Parse()`` format 인자에서 해당 매개 변수의 \"포맷 단위\"를 복사하고 *그것을* "
"(따옴표로 묶은 문자열로) 변환기로 지정하십시오. (\"포맷 단위\"는 인자 구문 분석 함수에 변수 형과 변환 방법을 알려주는 "
"``format`` 매개 변수의 1~3문자 부분 문자열에 대한 공식 이름입니다. 포맷 단위에 대한 자세한 내용은 :ref:`arg-"
"parsing`\\을 참조하십시오. )"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:305
msgid ""
"For multicharacter format units like ``z#``, use the entire two-or-three "
"character string."
msgstr "``z#``\\과 같은 다중 문자 포맷 단위의 경우, 전체 2~3문자 문자열 전체를 사용합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:323
msgid ""
"If your function has ``|`` in the format string, meaning some parameters "
"have default values, you can ignore it.  Argument Clinic infers which "
"parameters are optional based on whether or not they have default values."
msgstr ""
"함수의 포맷 문자열에 ``|``\\가 있으면 (일부 매개 변수에 기본값이 있음을 의미합니다), 무시할 수 있습니다. 인자 클리닉은 "
"기본값이 있는지에 따라 어떤 매개 변수가 선택적인지 유추합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:328
msgid ""
"If your function has ``$`` in the format string, meaning it takes "
"keyword-only arguments, specify ``*`` on a line by itself before the "
"first keyword-only argument, indented the same as the parameter lines."
msgstr ""
"함수의 포맷 문자열에 ``$``\\가 있으면 (키워드 전용 인자를 취함을 의미합니다), 첫 번째 키워드 전용 인자 앞에 "
"``*``\\를 별도의 줄로 지정하고 매개 변수 줄과 같게 들여쓰기합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:333
msgid "(``_pickle.Pickler.dump`` has neither, so our sample is unchanged.)"
msgstr "(``_pickle.Pickler.dump``\\에는 둘 다 없어서, 샘플은 변경되지 않습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:336
msgid ""
"If the existing C function calls :c:func:`PyArg_ParseTuple` (as opposed "
"to :c:func:`PyArg_ParseTupleAndKeywords`), then all its arguments are "
"positional-only."
msgstr ""
"기존 C 함수가 :c:func:`PyArg_ParseTuple`\\을 호출하면 "
"(:c:func:`PyArg_ParseTupleAndKeywords` 가 아니라), 모든 인자는 위치 전용입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:340
msgid ""
"To mark all parameters as positional-only in Argument Clinic, add a ``/``"
" on a line by itself after the last parameter, indented the same as the "
"parameter lines."
msgstr ""
"인자 클리닉에서 모든 매개 변수를 위치 전용으로 표시하려면, 마지막 매개 변수 뒤에 ``/``\\를 추가하고 매개 변수 줄과 같게 "
"들여쓰기합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:344
msgid ""
"Currently this is all-or-nothing; either all parameters are positional-"
"only, or none of them are.  (In the future Argument Clinic may relax this"
" restriction.)"
msgstr ""
"현재 이것은 전부 아니면 전무입니다; 모든 매개 변수가 위치 전용이거나, 아무것도 아닙니다. (향후 인자 클리닉에서 이 제한을 "
"완화할 수 있습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:364
msgid ""
"It's helpful to write a per-parameter docstring for each parameter. But "
"per-parameter docstrings are optional; you can skip this step if you "
"prefer."
msgstr ""
"매개 변수마다 매개 변수별 독스트링을 작성하는 것이 유용합니다. 그러나 매개 변수별 독스트링은 선택 사항입니다; 원한다면 이 단계를"
" 건너뛸 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:368
msgid ""
"Here's how to add a per-parameter docstring.  The first line of the per-"
"parameter docstring must be indented further than the parameter "
"definition.  The left margin of this first line establishes the left "
"margin for the whole per-parameter docstring; all the text you write will"
" be outdented by this amount.  You can write as much text as you like, "
"across multiple lines if you wish."
msgstr ""
"매개 변수별 독스트링을 추가하는 방법은 다음과 같습니다. 매개 변수별 독스트링의 첫 번째 줄은 매개 변수 정의보다 더 들여 써야 "
"합니다. 이 첫 번째 줄의 왼쪽 여백은 전체 매개 변수별 독스트링에 대한 왼쪽 여백을 설정합니다; 작성하는 모든 텍스트는 이 양만큼"
" 내어 쓰게 됩니다. 원한다면 여러 줄에 걸쳐, 원하는 만큼 텍스트를 작성할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:392
msgid ""
"Save and close the file, then run ``Tools/clinic/clinic.py`` on it.  With"
" luck everything worked---your block now has output, and a ``.c.h`` file "
"has been generated! Reopen the file in your text editor to see::"
msgstr ""
"파일을 저장하고 닫은 다음, 그것에 대해 ``Tools/clinic/clinic.py``\\를 실행합니다. 운 좋게도 모든 것이 "
"작동했습니다---이제 블록에 출력이 있고 ``.c.h`` 파일이 생성되었습니다! 텍스트 편집기에서 파일을 다시 열어 다음을 "
"확인하십시오::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:411
msgid ""
"Obviously, if Argument Clinic didn't produce any output, it's because it "
"found an error in your input.  Keep fixing your errors and retrying until"
" Argument Clinic processes your file without complaint."
msgstr ""
"명백히, 인자 클리닉이 출력을 생성하지 않았다면, 입력에서 에러를 발견했기 때문입니다. 인자 클리닉이 불평 없이 파일을 처리할 "
"때까지 에러를 수정하고 재시도하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:415
msgid ""
"For readability, most of the glue code has been generated to a ``.c.h`` "
"file.  You'll need to include that in your original ``.c`` file, "
"typically right after the clinic module block::"
msgstr ""
"가독성을 위해, 대부분의 글루(glue) 코드는 ``.c.h`` 파일에 생성되었습니다. 일반적으로 클리닉 모듈 블록 바로 뒤에서, "
"원본 ``.c`` 파일에 포함해야 할 필요가 있습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:421
msgid ""
"Double-check that the argument-parsing code Argument Clinic generated "
"looks basically the same as the existing code."
msgstr "인자 클리닉에서 생성한 인자 구문 분석 코드가 기본적으로 기존 코드와 같은지 다시 확인합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:424
msgid ""
"First, ensure both places use the same argument-parsing function. The "
"existing code must call either :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_ParseTupleAndKeywords`; ensure that the code generated by "
"Argument Clinic calls the *exact* same function."
msgstr ""
"먼저, 두 곳에서 같은 인자 구문 분석 함수를 사용하는지 확인하십시오. 기존 코드는 "
":c:func:`PyArg_ParseTuple`\\이나 :c:func:`PyArg_ParseTupleAndKeywords` 를 "
"호출해야 합니다; 인자 클리닉에서 생성한 코드가 *정확히* 같은 함수를 호출하는지 확인합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:430
msgid ""
"Second, the format string passed in to :c:func:`PyArg_ParseTuple` or "
":c:func:`PyArg_ParseTupleAndKeywords` should be *exactly* the same as the"
" hand-written one in the existing function, up to the colon or semi-"
"colon."
msgstr ""
"둘째, :c:func:`PyArg_ParseTuple`\\이나 :c:func:`PyArg_ParseTupleAndKeywords` "
"에 전달된 포맷 문자열은 콜론이나 세미콜론까지 기존 함수에서 손으로 쓴 것과 *정확히* 같아야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:435
msgid ""
"(Argument Clinic always generates its format strings with a ``:`` "
"followed by the name of the function.  If the existing code's format "
"string ends with ``;``, to provide usage help, this change is "
"harmless—don't worry about it.)"
msgstr ""
"(인자 클리닉은 항상 ``:`` 뒤에 함수 이름이 있는 포맷 문자열을 생성합니다. 기존 코드의 포맷 문자열이 ``;``\\로 끝나면"
" (사용법 도움말을 제공하기 위해), 이 변경 사항은 무해합니다 - 걱정하지 마십시오.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:440
msgid ""
"Third, for parameters whose format units require two arguments (like a "
"length variable, or an encoding string, or a pointer to a conversion "
"function), ensure that the second argument is *exactly* the same between "
"the two invocations."
msgstr ""
"셋째, 포맷 단위가 두 개의 인자(가령 길이 변수, 인코딩 문자열 또는 변환 함수에 대한 포인터)를 요구하는 매개 변수의 경우, 두"
" 번째 인자가 두 호출 간에 *정확히* 같은지 확인하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:445
msgid ""
"Fourth, inside the output portion of the block you'll find a preprocessor"
" macro defining the appropriate static :c:type:`PyMethodDef` structure "
"for this builtin::"
msgstr ""
"넷째, 블록의 출력 부분 내부에 이 내장에 적합한 정적 :c:type:`PyMethodDef` 구조체를 정의하는 전 처리기 매크로가"
" 있습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:452
msgid ""
"This static structure should be *exactly* the same as the existing static"
" :c:type:`PyMethodDef` structure for this builtin."
msgstr "이 정적 구조체는 이 내장의 기존 정적 :c:type:`PyMethodDef` 구조체와 *정확히* 같아야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:455
msgid ""
"If any of these items differ in *any way*, adjust your Argument Clinic "
"function specification and rerun ``Tools/clinic/clinic.py`` until they "
"*are* the same."
msgstr ""
"이러한 항목 중 *어떤 식으로*\\건 다른 항목이 있으면, 인자 클리닉 함수 명세를 조정하고 같아질 때까지 "
"``Tools/clinic/clinic.py``\\를 다시 실행합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:460
msgid ""
"Notice that the last line of its output is the declaration of your "
"\"impl\" function.  This is where the builtin's implementation goes. "
"Delete the existing prototype of the function you're modifying, but leave"
" the opening curly brace.  Now delete its argument parsing code and the "
"declarations of all the variables it dumps the arguments into. Notice how"
" the Python arguments are now arguments to this impl function; if the "
"implementation used different names for these variables, fix it."
msgstr ""
"출력의 마지막 줄은 \"impl\" 함수의 선언임에 유의하십시오. 여기가 내장 구현이 들어가는 곳입니다. 수정 중인 함수의 기존 "
"프로토타입을 삭제하십시오, 하지만 여는 중괄호는 그대로 둡니다. 이제 인자 구문 분석 코드와 인자를 덤프하는 모든 변수의 선언을 "
"삭제합니다. 이제 어떤 식으로 파이썬 인자가 이 impl 함수에 대한 인자가 되는지 주목하십시오; 구현에서 이러한 변수에 다른 "
"이름을 사용했다면, 수정하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:468
msgid ""
"Let's reiterate, just because it's kind of weird.  Your code should now "
"look like this::"
msgstr "좀 괴상하니, 반복합시다. 이제 코드는 다음과 같아야 합니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:477
msgid ""
"Argument Clinic generated the checksum line and the function prototype "
"just above it.  You should write the opening (and closing) curly braces "
"for the function, and the implementation inside."
msgstr ""
"인자 클리닉은 체크섬 줄과 그 바로 위에 함수 프로토타입을 생성했습니다. 함수와 내부 구현에 대한 여는 (그리고 닫는) 중괄호를 "
"작성해야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:522
msgid ""
"Remember the macro with the :c:type:`PyMethodDef` structure for this "
"function?  Find the existing :c:type:`PyMethodDef` structure for this "
"function and replace it with a reference to the macro.  (If the builtin "
"is at module scope, this will probably be very near the end of the file; "
"if the builtin is a class method, this will probably be below but "
"relatively near to the implementation.)"
msgstr ""
"이 함수에 대한 :c:type:`PyMethodDef` 구조체의 매크로를 기억하십니까? 이 함수에 대한 기존 "
":c:type:`PyMethodDef` 구조체를 찾아 매크로에 대한 참조로 바꿉니다. (내장이 모듈 스코프에 있으면, 아마도 파일의"
" 끝부분에 가까울 것입니다; 내장이 클래스 메서드이면, 아마도 아래에 있지만, 상대적으로 구현에 가까울 것입니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:529
msgid ""
"Note that the body of the macro contains a trailing comma.  So when you "
"replace the existing static :c:type:`PyMethodDef` structure with the "
"macro, *don't* add a comma to the end."
msgstr ""
"매크로 본문에는 후행 쉼표가 포함되어 있음에 유의하십시오. 따라서 기존의 정적 :c:type:`PyMethodDef` 구조체를 "
"매크로로 바꿀 때, 끝에 쉼표를 추가하지 *마십시오*."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:542
msgid ""
"Compile, then run the relevant portions of the regression-test suite. "
"This change should not introduce any new compile-time warnings or errors,"
" and there should be no externally-visible change to Python's behavior."
msgstr ""
"컴파일한 다음, 회귀 테스트 스위트의 관련 부분을 실행합니다. 이 변경으로 인해 새로운 컴파일 시간 경고나 에러가 발생해서는 안 "
"되며, 파이썬의 동작에 대해 외부에서 볼 수 있는 변경 사항이 없어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:546
msgid ""
"Well, except for one difference: ``inspect.signature()`` run on your "
"function should now provide a valid signature!"
msgstr ""
"한 가지 차이점이 있습니다: 함수에 대해 실행되는 ``inspect.signature()``\\는 이제 유효한 서명을 제공해야 "
"합니다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:549
msgid ""
"Congratulations, you've ported your first function to work with Argument "
"Clinic!"
msgstr "축하합니다, 인자 클리닉과 함께 작동하는 첫 번째 함수를 이식했습니다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:552
msgid "Advanced Topics"
msgstr "고급 주제"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:554
msgid ""
"Now that you've had some experience working with Argument Clinic, it's "
"time for some advanced topics."
msgstr "이제 인자 클리닉으로 작업한 경험이 있고, 몇 가지 고급 주제를 살펴볼 시간입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:559
msgid "Symbolic default values"
msgstr "기호 기본값"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:561
msgid ""
"The default value you provide for a parameter can't be any arbitrary "
"expression.  Currently the following are explicitly supported:"
msgstr "매개 변수에 제공하는 기본값은 임의의 표현식이 될 수 없습니다. 현재 다음이 명시적으로 지원됩니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:564
msgid "Numeric constants (integer and float)"
msgstr "숫자 상수 (정수와 부동 소수점)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:565
msgid "String constants"
msgstr "문자열 상수"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:566
msgid "``True``, ``False``, and ``None``"
msgstr "``True``, ``False`` 및 ``None``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:567
msgid ""
"Simple symbolic constants like ``sys.maxsize``, which must start with the"
" name of the module"
msgstr "``sys.maxsize``\\와 같은 간단한 기호 상수, 모듈 이름으로 시작해야 합니다"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:570
msgid ""
"In case you're curious, this is implemented in  ``from_builtin()`` in "
"``Lib/inspect.py``."
msgstr "궁금한 점이 있을 때를 위해, 이것은 ``Lib/inspect.py``\\의 ``from_builtin()``\\에서 구현됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:573
msgid ""
"(In the future, this may need to get even more elaborate, to allow full "
"expressions like ``CONSTANT - 1``.)"
msgstr "(미래에는, ``CONSTANT - 1``\\과 같은 완전한 표현식을 허용하기 위해, 더 정교해질 필요가 있습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:578
msgid "Renaming the C functions and variables generated by Argument Clinic"
msgstr "인자 클리닉에서 생성한 C 함수와 변수 이름 변경하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:580
msgid ""
"Argument Clinic automatically names the functions it generates for you. "
"Occasionally this may cause a problem, if the generated name collides "
"with the name of an existing C function.  There's an easy solution: "
"override the names used for the C functions.  Just add the keyword "
"``\"as\"`` to your function declaration line, followed by the function "
"name you wish to use. Argument Clinic will use that function name for the"
" base (generated) function, then add ``\"_impl\"`` to the end and use "
"that for the name of the impl function."
msgstr ""
"인자 클리닉은 자동으로 생성되는 함수의 이름을 지정합니다. 생성된 이름이 기존 C 함수의 이름과 충돌하면, 때때로 이로 인해 문제가"
" 발생할 수 있습니다. 쉬운 해결책이 있습니다: C 함수에 사용되는 이름을 재정의하는 것입니다. 함수 선언 줄에 키워드 "
"``\"as\"``\\를 추가한 다음 사용하려는 함수 이름을 추가하면 됩니다. 인자 클리닉은 기본 (생성된) 함수에 해당 함수 "
"이름을 사용한 다음, 끝에 ``\"_impl\"``\\을 추가하고 이를 impl 함수의 이름에 사용합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:588
msgid ""
"For example, if we wanted to rename the C function names generated for "
"``pickle.Pickler.dump``, it'd look like this::"
msgstr "예를 들어, ``pickle.Pickler.dump``\\에 대해 생성된 C 함수 이름을 바꾸려면, 다음과 같이 됩니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:596
msgid ""
"The base function would now be named ``pickler_dumper()``, and the impl "
"function would now be named ``pickler_dumper_impl()``."
msgstr ""
"이제 기본 함수의 이름은 ``pickler_dumper()``\\이고 impl 함수의 이름은 "
"``pickler_dumper_impl()``\\이 됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:600
msgid ""
"Similarly, you may have a problem where you want to give a parameter a "
"specific Python name, but that name may be inconvenient in C.  Argument "
"Clinic allows you to give a parameter different names in Python and in C,"
" using the same ``\"as\"`` syntax::"
msgstr ""
"마찬가지로, 매개 변수에 특정 파이썬 이름을 지정하려고 하지만, 해당 이름이 C에서 불편할 수 있는 경우 문제가 있을 수 있습니다."
" 인자 클리닉에서는 같은 ``\"as\"`` 문법을 사용하여, 파이썬과 C에서 매개 변수에 다른 이름을 지정할 수 있도록 합니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:614
msgid ""
"Here, the name used in Python (in the signature and the ``keywords`` "
"array) would be ``file``, but the C variable would be named ``file_obj``."
msgstr ""
"여기서, 파이썬에서 사용되는 이름(서명과 ``keywords`` 배열에서)은 ``file``\\이지만, C 변수의 이름은 "
"``file_obj``\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:617
msgid "You can use this to rename the ``self`` parameter too!"
msgstr "이것을 사용하여 ``self`` 매개 변수의 이름도 바꿀 수 있습니다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:621
msgid "Converting functions using PyArg_UnpackTuple"
msgstr "PyArg_UnpackTuple을 사용하여 함수 변환하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:623
msgid ""
"To convert a function parsing its arguments with "
":c:func:`PyArg_UnpackTuple`, simply write out all the arguments, "
"specifying each as an ``object``.  You may specify the ``type`` argument "
"to cast the type as appropriate.  All arguments should be marked "
"positional-only (add a ``/`` on a line by itself after the last "
"argument)."
msgstr ""
":c:func:`PyArg_UnpackTuple`\\로 인자를 구문 분석하는 함수를 변환하려면, 각 인자를 ``object``\\로"
" 지정하여 모든 인자를 작성하면 됩니다. ``type`` 인자를 지정하여 형을 적절하게 캐스트 할 수 있습니다. 모든 인자는 위치 "
"전용으로 표시되어야 합니다 (마지막 인자 뒤에 ``/``\\를 자체 줄로 추가하십시오)."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:629
msgid ""
"Currently the generated code will use :c:func:`PyArg_ParseTuple`, but "
"this will change soon."
msgstr "현재 생성된 코드는 :c:func:`PyArg_ParseTuple`\\을 사용하지만, 곧 변경됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:633
msgid "Optional Groups"
msgstr "선택적 그룹"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:635
msgid ""
"Some legacy functions have a tricky approach to parsing their arguments: "
"they count the number of positional arguments, then use a ``switch`` "
"statement to call one of several different :c:func:`PyArg_ParseTuple` "
"calls depending on how many positional arguments there are.  (These "
"functions cannot accept keyword-only arguments.)  This approach was used "
"to simulate optional arguments back before "
":c:func:`PyArg_ParseTupleAndKeywords` was created."
msgstr ""
"일부 레거시 함수는 인자를 구문 분석하는 데 까다로운 접근 방식을 사용합니다: 위치 인자의 수를 계산한 다음 ``switch`` "
"문을 사용하여 위치 인자의 수에 따라 여러 :c:func:`PyArg_ParseTuple` 호출 중 하나를 호출합니다. (이러한 "
"함수는 키워드 전용 인자를 받아들일 수 없습니다.) 이 접근 방식은 "
":c:func:`PyArg_ParseTupleAndKeywords` 가 만들어지기 전에 선택적 인자를 시뮬레이션하는 데 "
"사용되었습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:642
msgid ""
"While functions using this approach can often be converted to use "
":c:func:`PyArg_ParseTupleAndKeywords`, optional arguments, and default "
"values, it's not always possible.  Some of these legacy functions have "
"behaviors :c:func:`PyArg_ParseTupleAndKeywords` doesn't directly support."
" The most obvious example is the builtin function ``range()``, which has "
"an optional argument on the *left* side of its required argument! Another"
" example is ``curses.window.addch()``, which has a group of two arguments"
" that must always be specified together.  (The arguments are called ``x``"
" and ``y``; if you call the function passing in ``x``, you must also pass"
" in ``y``—and if you don't pass in ``x`` you may not pass in ``y`` "
"either.)"
msgstr ""
"이 접근 방식을 사용하는 함수는 종종 :c:func:`PyArg_ParseTupleAndKeywords`, 선택적 인자 및 기본값을"
" 사용하도록 변환될 수 있지만, 항상 가능한 것은 아닙니다. 이러한 레거시 함수 중 일부에는 "
":c:func:`PyArg_ParseTupleAndKeywords` 가 직접 지원하지 않는 동작이 있습니다. 가장 명백한 예는 필수"
" 인자의 *좌* 측에 선택적 인자가 있는 내장 함수 ``range()``\\입니다! 또 다른 예는 항상 함께 지정되어야 하는 두 "
"개의 인자 그룹이 있는 ``curses.window.addch()``\\입니다. (인자는 ``x`` 와 ``y``\\라고 합니다; "
"함수를 호출할 때 ``x``\\를 전달하면 ``y``\\도 전달해야 합니다 - 그리고 ``x``\\를 전달하지 않으면 "
"``y``\\도 전달할 수 없습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:654
msgid ""
"In any case, the goal of Argument Clinic is to support argument parsing "
"for all existing CPython builtins without changing their semantics. "
"Therefore Argument Clinic supports this alternate approach to parsing, "
"using what are called *optional groups*. Optional groups are groups of "
"arguments that must all be passed in together. They can be to the left or"
" the right of the required arguments.  They can *only* be used with "
"positional-only parameters."
msgstr ""
"어쨌든, 인자 클리닉의 목표는 의미를 변경하지 않고 기존의 모든 CPython 내장에 대한 인자 구문 분석을 지원하는 것입니다. "
"따라서 인자 클리닉은 *선택적 그룹(optional groups)*\\이라는 것을 사용하여, 구문 분석에 대한 이러한 대체 접근 "
"방식을 지원합니다. 선택적 그룹은 모두 함께 전달되어야 하는 인자 그룹입니다. 필수 인자의 왼쪽 또는 오른쪽에 있을 수 있습니다. "
"위치 전용 매개 변수에만 사용할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:662
msgid ""
"Optional groups are *only* intended for use when converting functions "
"that make multiple calls to :c:func:`PyArg_ParseTuple`! Functions that "
"use *any* other approach for parsing arguments should *almost never* be "
"converted to Argument Clinic using optional groups.  Functions using "
"optional groups currently cannot have accurate signatures in Python, "
"because Python just doesn't understand the concept.  Please avoid using "
"optional groups wherever possible."
msgstr ""
"선택적 그룹은 *오직* :c:func:`PyArg_ParseTuple`\\을 여러 번 호출하는 함수를 변환할 때 사용하려는 "
"것입니다! 인자를 구문 분석하기 위해 *다른* 접근 방식을 사용하는 함수는 *거의 절대* 선택적 그룹을 사용하여 인자 클리닉으로 "
"변환되지 않습니다. 선택적 그룹을 사용하는 함수는 현재 파이썬에서 정확한 서명을 가질 수 없습니다, 파이썬이 개념을 이해하지 못하기"
" 때문입니다. 가능한 한 선택적 그룹을 사용하지 마십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:671
msgid ""
"To specify an optional group, add a ``[`` on a line by itself before the "
"parameters you wish to group together, and a ``]`` on a line by itself "
"after these parameters.  As an example, here's how "
"``curses.window.addch`` uses optional groups to make the first two "
"parameters and the last parameter optional::"
msgstr ""
"선택적 그룹을 지정하려면, 함께 그룹화하려는 매개 변수 앞에 ``[``\\를 단독 줄로 추가하고, 이러한 매개 변수 뒤에 단독 줄로"
" ``]``\\를 추가합니다. 예를 들어, ``curses.window.addch``\\가 선택적 그룹을 사용하여 처음 두 매개 "
"변수와 마지막 매개 변수를 선택적으로 만드는 방법은 다음과 같습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:700
msgid "Notes:"
msgstr "노트:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:702
msgid ""
"For every optional group, one additional parameter will be passed into "
"the impl function representing the group.  The parameter will be an int "
"named ``group_{direction}_{number}``, where ``{direction}`` is either "
"``right`` or ``left`` depending on whether the group is before or after "
"the required parameters, and ``{number}`` is a monotonically increasing "
"number (starting at 1) indicating how far away the group is from the "
"required parameters.  When the impl is called, this parameter will be set"
" to zero if this group was unused, and set to non-zero if this group was "
"used. (By used or unused, I mean whether or not the parameters received "
"arguments in this invocation.)"
msgstr ""
"모든 선택적 그룹에 대해, 하나의 추가 매개 변수가 impl 함수로 전달되어 그룹을 나타냅니다. 매개 변수는 "
"``group_{direction}_{number}``\\라는 이름의 정수입니다. 여기서 ``{direction}``\\은 그룹이 "
"필수 매개 변수 앞인지 뒤인지에 따라 ``right``\\나 ``left``\\이고, ``{number}``\\는 그룹이 필수 매개"
" 변수에서 얼마나 멀리 떨어져 있는지를 나타내는 단조 증가 하는 숫자(1에서 시작)입니다. impl이 호출될 때, 이 그룹이 "
"사용되지 않았으면 이 매개 변수는 0으로 설정되고, 이 그룹이 사용되면 0이 아닌 값으로 설정됩니다. (사용했다는 표현은, 매개 "
"변수가 이 호출에서 인자를 받았는지를 의미합니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:713
msgid ""
"If there are no required arguments, the optional groups will behave as if"
" they're to the right of the required arguments."
msgstr "필수 인자가 없으면, 선택적 그룹은 필수 인자의 오른쪽에 있는 것처럼 작동합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:716
msgid ""
"In the case of ambiguity, the argument parsing code favors parameters on "
"the left (before the required parameters)."
msgstr "모호한 경우, 인자 구문 분석 코드는 왼쪽(필수 매개 변수 앞)의 매개 변수를 선호합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:719
msgid "Optional groups can only contain positional-only parameters."
msgstr "선택적 그룹은 위치 전용 매개 변수 만 포함할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:721
msgid ""
"Optional groups are *only* intended for legacy code.  Please do not use "
"optional groups for new code."
msgstr "선택적 그룹은 *오직* 레거시 코드를 위한 것입니다. 새 코드에 선택적 그룹을 사용하지 마십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:726
msgid "Using real Argument Clinic converters, instead of \"legacy converters\""
msgstr "\"레거시 변환기\" 대신 실제 인자 클리닉 변환기 사용하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:728
msgid ""
"To save time, and to minimize how much you need to learn to achieve your "
"first port to Argument Clinic, the walkthrough above tells you to use "
"\"legacy converters\".  \"Legacy converters\" are a convenience, designed"
" explicitly to make porting existing code to Argument Clinic easier.  And"
" to be clear, their use is acceptable when porting code for Python 3.4."
msgstr ""
"시간을 절약하고, 인자 클리닉으로의 첫 번째 이식을 달성하는 데 필요한 학습량을 최소화하기 위해, 위의 연습에서는 \"레거시 "
"변환기\"를 사용하도록 지시합니다. \"레거시 변환기\"는 기존 코드를 인자 클리닉으로 더 쉽게 이식 할 수 있도록 명시적으로 "
"설계된 편의 기능입니다. 명확하게 말하면, 파이썬 3.4 용 코드를 이식할 때는 사용할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:735
msgid ""
"However, in the long term we probably want all our blocks to use Argument"
" Clinic's real syntax for converters.  Why?  A couple reasons:"
msgstr ""
"그러나, 장기적으로 우리는 모든 블록이 변환기를 위한 인자 클리닉의 실제 문법을 사용하기를 원할 것입니다. 왜일까요? 몇 가지 "
"이유가 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:739
msgid "The proper converters are far easier to read and clearer in their intent."
msgstr "적절한 변환기는 읽기가 훨씬 쉽고 의도가 명확합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:740
msgid ""
"There are some format units that are unsupported as \"legacy "
"converters\", because they require arguments, and the legacy converter "
"syntax doesn't support specifying arguments."
msgstr ""
"인자가 필요한데, 레거시 변환기 문법이 인자 지정을 지원하지 않아서, \"레거시 변환기\"로 지원되지 않는 일부 포맷 단위가 "
"있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:743
msgid ""
"In the future we may have a new argument parsing library that isn't "
"restricted to what :c:func:`PyArg_ParseTuple` supports; this flexibility "
"won't be available to parameters using legacy converters."
msgstr ""
"미래에 우리는 :c:func:`PyArg_ParseTuple`\\이 지원하는 것에 제한되지 않는 새로운 인자 구문 분석 라이브러리를"
" 가질 수 있습니다; 이러한 유연성은 레거시 변환기를 사용하는 매개 변수에는 제공되지 않을 것입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:747
msgid ""
"Therefore, if you don't mind a little extra effort, please use the normal"
" converters instead of legacy converters."
msgstr "따라서, 약간의 추가 노력을 꺼리지 않는다면, 레거시 변환기 대신 일반 변환기를 사용하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:750
msgid ""
"In a nutshell, the syntax for Argument Clinic (non-legacy) converters "
"looks like a Python function call.  However, if there are no explicit "
"arguments to the function (all functions take their default values), you "
"may omit the parentheses.  Thus ``bool`` and ``bool()`` are exactly the "
"same converters."
msgstr ""
"간단히 말해서, 인자 클리닉 (비 레거시) 변환기의 문법은 파이썬 함수 호출처럼 보입니다; 그러나, 함수에 대한 명시적 인자가 "
"없으면 (모든 함수가 기본값을 취함), 괄호를 생략할 수 있습니다. 따라서 ``bool`` 과 ``bool()`` 은 정확히 같은 "
"변환기입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:756
msgid ""
"All arguments to Argument Clinic converters are keyword-only. All "
"Argument Clinic converters accept the following arguments:"
msgstr "인자 클리닉 변환기에 대한 모든 인자는 키워드 전용입니다. 모든 인자 클리닉 변환기는 다음 인자를 받아들입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:764
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1252
msgid "``c_default``"
msgstr "``c_default``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:760
msgid ""
"The default value for this parameter when defined in C. Specifically, "
"this will be the initializer for the variable declared in the \"parse "
"function\".  See :ref:`the section on default values <default_values>` "
"for how to use this. Specified as a string."
msgstr ""
"C에서 정의될 때 이 매개 변수의 기본값. 특히, 이것은 \"구문 분석 함수\"에서 선언된 변수의 초기화자가 됩니다. 이것을 "
"사용하는 방법은 :ref:`기본값에 관한 섹션 <default_values>`\\을 참조하십시오. 문자열로 지정됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:769
msgid "``annotation``"
msgstr "``annotation``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:767
msgid ""
"The annotation value for this parameter.  Not currently supported, "
"because :pep:`8` mandates that the Python library may not use "
"annotations."
msgstr ""
"이 매개 변수의 어노테이션 값. :pep:`8`\\은 파이썬 라이브러리가 어노테이션을 사용하지 않도록 요구하므로, 현재 지원되지 "
"않습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:771
msgid ""
"In addition, some converters accept additional arguments.  Here is a list"
" of these arguments, along with their meanings:"
msgstr "또한, 일부 변환기는 추가 인자를 받아들입니다. 다음은 의미와 함께, 이러한 인자들의 목록입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:780
msgid "``accept``"
msgstr "``accept``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:775
msgid ""
"A set of Python types (and possibly pseudo-types); this restricts the "
"allowable Python argument to values of these types. (This is not a "
"general-purpose facility; as a rule it only supports specific lists of "
"types as shown in the legacy converter table.)"
msgstr ""
"파이썬 형(그리고 의사 형도 가능)의 집합; 이는 허용 가능한 파이썬 인자를 이러한 형의 값으로 제한합니다. (이것은 범용 기능이 "
"아닙니다; 일반적으로 레거시 변환기 표에 표시된 특정 형 리스트만 지원합니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:780
msgid "To accept ``None``, add ``NoneType`` to this set."
msgstr "``None``\\을 받아들이려면, 이 집합에 ``NoneType``\\을 추가하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:785
msgid "``bitwise``"
msgstr "``bitwise``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:783
msgid ""
"Only supported for unsigned integers.  The native integer value of this "
"Python argument will be written to the parameter without any range "
"checking, even for negative values."
msgstr ""
"부호 없는 정수에 대해서만 지원됩니다. 이 파이썬 인자의 네이티브 정숫값은 음수 값에 대해서조차 범위 검사 없이 매개 변수에 "
"기록됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:790
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1266
msgid "``converter``"
msgstr "``converter``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:788
msgid ""
"Only supported by the ``object`` converter.  Specifies the name of a "
":ref:`C \"converter function\" <o_ampersand>` to use to convert this "
"object to a native type."
msgstr ""
"``object`` 변환기에서만 지원됩니다. 이 객체를 네이티브 형으로 변환하는 데 사용할 :ref:`C \"변환기 함수\" "
"<o_ampersand>`\\의 이름을 지정합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:795
msgid "``encoding``"
msgstr "``encoding``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:793
msgid ""
"Only supported for strings.  Specifies the encoding to use when "
"converting this string from a Python str (Unicode) value into a C ``char "
"*`` value."
msgstr ""
"문자열에 대해서만 지원됩니다. 이 문자열을 파이썬 str (유니코드) 값에서 C ``char *`` 값으로 변환할 때 사용할 "
"인코딩을 지정합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:799
msgid "``subclass_of``"
msgstr "``subclass_of``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:798
msgid ""
"Only supported for the ``object`` converter.  Requires that the Python "
"value be a subclass of a Python type, as expressed in C."
msgstr "``object`` 변환기에 대해서만 지원됩니다. 파이썬 값은 C로 표현된 파이썬 형의 서브 클래스여야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:804
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1238
msgid "``type``"
msgstr "``type``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:802
msgid ""
"Only supported for the ``object`` and ``self`` converters.  Specifies the"
" C type that will be used to declare the variable.  Default value is "
"``\"PyObject *\"``."
msgstr ""
"``object``\\와 ``self`` 변환기에 대해서만 지원됩니다. 변수를 선언하는 데 사용할 C형을 지정합니다. 기본값은 "
"``\"PyObject *\"``\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:810
msgid "``zeroes``"
msgstr "``zeroes``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:807
msgid ""
"Only supported for strings.  If true, embedded NUL bytes (``'\\\\0'``) "
"are permitted inside the value.  The length of the string will be passed "
"in to the impl function, just after the string parameter, as a parameter "
"named ``<parameter_name>_length``."
msgstr ""
"문자열에 대해서만 지원됩니다. 참이면, 값 내에 내장된 NUL 바이트(``'\\\\0'``)가 허용됩니다. 문자열의 길이는 문자열 "
"매개 변수 바로 뒤에 ``<parameter_name>_length``\\라는 이름의 매개 변수로 impl 함수에 전달됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:812
msgid ""
"Please note, not every possible combination of arguments will work. "
"Usually these arguments are implemented by specific ``PyArg_ParseTuple`` "
"*format units*, with specific behavior.  For example, currently you "
"cannot call ``unsigned_short`` without also specifying ``bitwise=True``. "
"Although it's perfectly reasonable to think this would work, these "
"semantics don't map to any existing format unit.  So Argument Clinic "
"doesn't support it.  (Or, at least, not yet.)"
msgstr ""
"가능한 모든 인자 조합이 작동하는 것은 아님에 유의하십시오. 일반적으로 이러한 인자는 특정 동작을 갖는 특정 "
"``PyArg_ParseTuple`` *포맷 단위*\\에 의해 구현됩니다. 예를 들어, 현재 ``bitwise=True``\\를 "
"지정하지 않고 ``unsigned_short``\\를 호출할 수 없습니다. 이것이 작동하리라 생각하는 것이 합리적이지만, 이러한 "
"의미는 기존 포맷 단위에 매핑되지 않습니다. 그래서 인자 클리닉은 이것을 지원하지 않습니다. (또는, 적어도 아직은 아닙니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:820
msgid ""
"Below is a table showing the mapping of legacy converters into real "
"Argument Clinic converters.  On the left is the legacy converter, on the "
"right is the text you'd replace it with."
msgstr ""
"다음은 레거시 변환기를 실제 인자 클리닉 변환기에 매핑하는 표입니다. 왼쪽에는 레거시 변환기가 있고, 오른쪽에는 교체할 텍스트가 "
"있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:825
msgid "``'B'``"
msgstr "``'B'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:825
msgid "``unsigned_char(bitwise=True)``"
msgstr "``unsigned_char(bitwise=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:826
msgid "``'b'``"
msgstr "``'b'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:826
msgid "``unsigned_char``"
msgstr "``unsigned_char``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:827
msgid "``'c'``"
msgstr "``'c'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:827
msgid "``char``"
msgstr "``char``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:828
msgid "``'C'``"
msgstr "``'C'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:828
msgid "``int(accept={str})``"
msgstr "``int(accept={str})``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:829
msgid "``'d'``"
msgstr "``'d'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:829
msgid "``double``"
msgstr "``double``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:830
msgid "``'D'``"
msgstr "``'D'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:830
msgid "``Py_complex``"
msgstr "``Py_complex``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:831
msgid "``'es'``"
msgstr "``'es'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:831
msgid "``str(encoding='name_of_encoding')``"
msgstr "``str(encoding='name_of_encoding')``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:832
msgid "``'es#'``"
msgstr "``'es#'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:832
msgid "``str(encoding='name_of_encoding', zeroes=True)``"
msgstr "``str(encoding='name_of_encoding', zeroes=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:833
msgid "``'et'``"
msgstr "``'et'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:833
msgid "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"
msgstr "``str(encoding='name_of_encoding', accept={bytes, bytearray, str})``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:834
msgid "``'et#'``"
msgstr "``'et#'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:834
msgid ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"
msgstr ""
"``str(encoding='name_of_encoding', accept={bytes, bytearray, str}, "
"zeroes=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:835
msgid "``'f'``"
msgstr "``'f'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:835
msgid "``float``"
msgstr "``float``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:836
msgid "``'h'``"
msgstr "``'h'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:836
msgid "``short``"
msgstr "``short``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:837
msgid "``'H'``"
msgstr "``'H'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:837
msgid "``unsigned_short(bitwise=True)``"
msgstr "``unsigned_short(bitwise=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:838
msgid "``'i'``"
msgstr "``'i'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:838
msgid "``int``"
msgstr "``int``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:839
msgid "``'I'``"
msgstr "``'I'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:839
msgid "``unsigned_int(bitwise=True)``"
msgstr "``unsigned_int(bitwise=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:840
msgid "``'k'``"
msgstr "``'k'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:840
msgid "``unsigned_long(bitwise=True)``"
msgstr "``unsigned_long(bitwise=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:841
msgid "``'K'``"
msgstr "``'K'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:841
msgid "``unsigned_long_long(bitwise=True)``"
msgstr "``unsigned_long_long(bitwise=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:842
msgid "``'l'``"
msgstr "``'l'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:842
msgid "``long``"
msgstr "``long``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:843
msgid "``'L'``"
msgstr "``'L'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:843
msgid "``long long``"
msgstr "``long long``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:844
msgid "``'n'``"
msgstr "``'n'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:844
msgid "``Py_ssize_t``"
msgstr "``Py_ssize_t``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:845
msgid "``'O'``"
msgstr "``'O'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:845
msgid "``object``"
msgstr "``object``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:846
msgid "``'O!'``"
msgstr "``'O!'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:846
msgid "``object(subclass_of='&PySomething_Type')``"
msgstr "``object(subclass_of='&PySomething_Type')``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:847
msgid "``'O&'``"
msgstr "``'O&'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:847
msgid "``object(converter='name_of_c_function')``"
msgstr "``object(converter='name_of_c_function')``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:848
msgid "``'p'``"
msgstr "``'p'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:848
msgid "``bool``"
msgstr "``bool``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:849
msgid "``'S'``"
msgstr "``'S'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:849
msgid "``PyBytesObject``"
msgstr "``PyBytesObject``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:850
msgid "``'s'``"
msgstr "``'s'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:850
msgid "``str``"
msgstr "``str``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:851
msgid "``'s#'``"
msgstr "``'s#'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:851
msgid "``str(zeroes=True)``"
msgstr "``str(zeroes=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:852
msgid "``'s*'``"
msgstr "``'s*'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:852
msgid "``Py_buffer(accept={buffer, str})``"
msgstr "``Py_buffer(accept={buffer, str})``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:853
msgid "``'U'``"
msgstr "``'U'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:853
msgid "``unicode``"
msgstr "``unicode``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:854
msgid "``'u'``"
msgstr "``'u'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:854
msgid "``Py_UNICODE``"
msgstr "``Py_UNICODE``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:855
msgid "``'u#'``"
msgstr "``'u#'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:855
msgid "``Py_UNICODE(zeroes=True)``"
msgstr "``Py_UNICODE(zeroes=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:856
msgid "``'w*'``"
msgstr "``'w*'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:856
msgid "``Py_buffer(accept={rwbuffer})``"
msgstr "``Py_buffer(accept={rwbuffer})``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:857
msgid "``'Y'``"
msgstr "``'Y'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:857
msgid "``PyByteArrayObject``"
msgstr "``PyByteArrayObject``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:858
msgid "``'y'``"
msgstr "``'y'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:858
msgid "``str(accept={bytes})``"
msgstr "``str(accept={bytes})``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:859
msgid "``'y#'``"
msgstr "``'y#'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:859
msgid "``str(accept={robuffer}, zeroes=True)``"
msgstr "``str(accept={robuffer}, zeroes=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:860
msgid "``'y*'``"
msgstr "``'y*'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:860
msgid "``Py_buffer``"
msgstr "``Py_buffer``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:861
msgid "``'Z'``"
msgstr "``'Z'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:861
msgid "``Py_UNICODE(accept={str, NoneType})``"
msgstr "``Py_UNICODE(accept={str, NoneType})``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:862
msgid "``'Z#'``"
msgstr "``'Z#'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:862
msgid "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"
msgstr "``Py_UNICODE(accept={str, NoneType}, zeroes=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:863
msgid "``'z'``"
msgstr "``'z'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:863
msgid "``str(accept={str, NoneType})``"
msgstr "``str(accept={str, NoneType})``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:864
msgid "``'z#'``"
msgstr "``'z#'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:864
msgid "``str(accept={str, NoneType}, zeroes=True)``"
msgstr "``str(accept={str, NoneType}, zeroes=True)``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:865
msgid "``'z*'``"
msgstr "``'z*'``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:865
msgid "``Py_buffer(accept={buffer, str, NoneType})``"
msgstr "``Py_buffer(accept={buffer, str, NoneType})``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:868
msgid ""
"As an example, here's our sample ``pickle.Pickler.dump`` using the proper"
" converter::"
msgstr "예를 들어, 적절한 변환기를 사용하는 샘플 ``pickle.Pickler.dump``\\는 다음과 같습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:881
msgid ""
"One advantage of real converters is that they're more flexible than "
"legacy converters.  For example, the ``unsigned_int`` converter (and all "
"the ``unsigned_`` converters) can be specified without ``bitwise=True``."
"  Their default behavior performs range checking on the value, and they "
"won't accept negative numbers.  You just can't do that with a legacy "
"converter!"
msgstr ""
"실제 변환기의 한 가지 장점은 레거시 변환기보다 유연하다는 것입니다. 예를 들어, ``unsigned_int`` 변환기(그리고 모든"
" ``unsigned_`` 변환기)는 ``bitwise=True`` 없이 지정될 수 있습니다. 기본 동작은 값에 대해 범위 검사를 "
"수행하며, 음수를 허용하지 않습니다. 레거시 변환기로는 그렇게 할 수 없습니다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:887
msgid ""
"Argument Clinic will show you all the converters it has available.  For "
"each converter it'll show you all the parameters it accepts, along with "
"the default value for each parameter. Just run ``Tools/clinic/clinic.py "
"--converters`` to see the full list."
msgstr ""
"인자 클리닉은 사용 가능한 모든 변환기를 보여줍니다. 각 변환기에 대해 허용되는 모든 매개 변수와 각 매개 변수의 기본값이 "
"표시됩니다. 전체 목록을 보려면 ``Tools/clinic/clinic.py --converters``\\를 실행하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:893
msgid "Py_buffer"
msgstr "Py_buffer"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:895
msgid ""
"When using the ``Py_buffer`` converter (or the ``'s*'``, ``'w*'``, "
"``'*y'``, or ``'z*'`` legacy converters), you *must* not call "
":c:func:`PyBuffer_Release` on the provided buffer. Argument Clinic "
"generates code that does it for you (in the parsing function)."
msgstr ""
"``Py_buffer`` 변환기(또는 ``'s*'``, ``'w*'``, ``'*y'`` 또는 ``'z*'`` 레거시 변환기)를 "
"사용할 때, 제공된 버퍼에서 :c:func:`PyBuffer_Release`\\를 호출하지 *않아야* 합니다. 인자 클리닉은 (구문"
" 분석 함수에서) 이를 수행하는 코드를 생성합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:903
msgid "Advanced converters"
msgstr "고급 변환기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:905
msgid ""
"Remember those format units you skipped for your first time because they "
"were advanced?  Here's how to handle those too."
msgstr "고급이기 때문에 처음에는 건너뛴 포맷 단위를 기억하십니까? 다음은 이것도 처리하는 방법입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:908
msgid ""
"The trick is, all those format units take arguments—either conversion "
"functions, or types, or strings specifying an encoding. (But \"legacy "
"converters\" don't support arguments.  That's why we skipped them for "
"your first function.)  The argument you specified to the format unit is "
"now an argument to the converter; this argument is either ``converter`` "
"(for ``O&``), ``subclass_of`` (for ``O!``), or ``encoding`` (for all the "
"format units that start with ``e``)."
msgstr ""
"트릭은, 모든 포맷 단위가 인자를 취한다는 것입니다 - 변환 함수, 형 또는 인코딩을 지정하는 문자열. (그러나 \"레거시 "
"변환기\"는 인자를 지원하지 않습니다. 이것이 바로 첫 번째 함수에서 건너뛴 이유입니다.) 포맷 단위에 지정한 인자는 이제 변환기에"
" 대한 인자입니다; 이 인자는 ``converter`` (``O&``\\의 경우), ``subclass_of`` (``O!`` 의 "
"경우) 또는 ``encoding`` (``e``\\로 시작하는 모든 포맷 단위의 경우)입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:916
msgid ""
"When using ``subclass_of``, you may also want to use the other custom "
"argument for ``object()``: ``type``, which lets you set the type actually"
" used for the parameter.  For example, if you want to ensure that the "
"object is a subclass of ``PyUnicode_Type``, you probably want to use the "
"converter ``object(type='PyUnicodeObject *', "
"subclass_of='&PyUnicode_Type')``."
msgstr ""
"``subclass_of``\\를 사용할 때, ``object()``\\에 대한 다른 사용자 정의 인자를 사용하고 싶을 수도 "
"있습니다: 매개 변수에 실제로 사용되는 형을 설정할 수 있는 ``type``. 예를 들어, 객체가 "
"``PyUnicode_Type``\\의 서브 클래스인지 확인하려면, ``object(type='PyUnicodeObject *', "
"subclass_of='&PyUnicode_Type')`` 변환기를 사용할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:922
msgid ""
"One possible problem with using Argument Clinic: it takes away some "
"possible flexibility for the format units starting with ``e``.  When "
"writing a ``PyArg_Parse`` call by hand, you could theoretically decide at"
" runtime what encoding string to pass in to :c:func:`PyArg_ParseTuple`."
"   But now this string must be hard-coded at Argument-Clinic-"
"preprocessing-time.  This limitation is deliberate; it made supporting "
"this format unit much easier, and may allow for future optimizations. "
"This restriction doesn't seem unreasonable; CPython itself always passes "
"in static hard-coded encoding strings for parameters whose format units "
"start with ``e``."
msgstr ""
"인자 클리닉을 사용할 때 발생할 수 있는 한 가지 문제: ``e``\\로 시작하는 포맷 단위에 대해 일부 가능한 유연성을 "
"제거합니다. ``PyArg_Parse`` 호출을 직접 작성할 때, 이론적으로 실행 시간에 "
":c:func:`PyArg_ParseTuple`\\에 전달할 인코딩 문자열을 결정할 수 있습니다. 그러나 이제 이 문자열은 인자 "
"클리닉 처리 시점에 하드 코딩되어야 합니다. 이 제한은 의도적입니다; 이 포맷 단위를 지원하는 것을 훨씬 쉽게 만들고, 향후 "
"최적화를 허용할 수 있습니다. 이 제한은 비합리적으로 보이지 않습니다; CPython 자체는 항상 포맷 단위가 ``e``\\로 "
"시작하는 매개 변수에 대해 정적 하드 코딩된 인코딩 문자열을 전달합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:935
msgid "Parameter default values"
msgstr "매개 변수 기본값"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:937
msgid ""
"Default values for parameters can be any of a number of values. At their "
"simplest, they can be string, int, or float literals:"
msgstr "매개 변수의 기본값은 여러 값 중 하나일 수 있습니다. 가장 간단하게는, 문자열, 정수 또는 부동 소수점 리터럴일 수 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:946
msgid "They can also use any of Python's built-in constants:"
msgstr "또한 파이썬의 내장 상수를 사용할 수 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:954
msgid ""
"There's also special support for a default value of ``NULL``, and for "
"simple expressions, documented in the following sections."
msgstr "또한 다음 섹션에 설명된 ``NULL``\\과 단순 표현식 기본값에 대한 특별 지원도 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:959
msgid "The ``NULL`` default value"
msgstr "``NULL`` 기본값"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:961
msgid ""
"For string and object parameters, you can set them to ``None`` to "
"indicate that there's no default.  However, that means the C variable "
"will be initialized to ``Py_None``.  For convenience's sakes, there's a "
"special value called ``NULL`` for just this reason: from Python's "
"perspective it behaves like a default value of ``None``, but the C "
"variable is initialized with ``NULL``."
msgstr ""
"문자열과 객체 매개 변수의 경우, ``None``\\으로 설정하여 기본값이 없음을 나타낼 수 있습니다. 그러나, 이는 C 변수가 "
"``Py_None``\\으로 초기화됨을 의미합니다. 편의상, 이 이유로 ``NULL``\\이라는 특수 값이 있습니다: 파이썬의 "
"관점에서 보면 ``None``\\의 기본값처럼 동작하지만, C 변수는 ``NULL``\\로 초기화됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:969
msgid "Expressions specified as default values"
msgstr "기본값으로 지정된 표현식"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:971
msgid ""
"The default value for a parameter can be more than just a literal value. "
"It can be an entire expression, using math operators and looking up "
"attributes on objects.  However, this support isn't exactly simple, "
"because of some non-obvious semantics."
msgstr ""
"매개 변수의 기본값은 단순한 리터럴 값 이상이 될 수 있습니다. 수학 연산자를 사용하고 객체의 어트리뷰트를 조회하는 전체 표현식이 "
"될 수 있습니다. 그러나, 이 지원은 일부 명확하지 않은 의미로 인해 간단하지 않습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:976
msgid "Consider the following example:"
msgstr "다음 예를 고려하십시오:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:982
msgid ""
"``sys.maxsize`` can have different values on different platforms.  "
"Therefore Argument Clinic can't simply evaluate that expression locally "
"and hard-code it in C.  So it stores the default in such a way that it "
"will get evaluated at runtime, when the user asks for the function's "
"signature."
msgstr ""
"``sys.maxsize``\\는 플랫폼마다 다른 값을 가질 수 있습니다. 따라서 인자 클리닉은 단순히 해당 표현식을 로컬에서 "
"평가하고 C로 하드 코딩할 수 없습니다. 따라서 사용자가 함수의 서명을 요청할 때, 실행 시간에 평가되는 방식으로 기본값을 "
"저장합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:987
msgid ""
"What namespace is available when the expression is evaluated?  It's "
"evaluated in the context of the module the builtin came from.  So, if "
"your module has an attribute called \"``max_widgets``\", you may simply "
"use it:"
msgstr ""
"식을 평가할 때 사용할 수 있는 이름 공간은 무엇입니까? 내장이 온 모듈의 컨텍스트에서 평가됩니다. 따라서, 모듈에 "
"\"``max_widgets``\"라는 어트리뷰트가 있으면, 간단히 사용할 수 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:995
msgid ""
"If the symbol isn't found in the current module, it fails over to looking"
" in ``sys.modules``.  That's how it can find ``sys.maxsize`` for example."
"  (Since you don't know in advance what modules the user will load into "
"their interpreter, it's best to restrict yourself to modules that are "
"preloaded by Python itself.)"
msgstr ""
"심볼이 현재 모듈에서 발견되지 않으면, ``sys.modules``\\를 찾는 것으로 폴백 됩니다. 이것이 예를 들어 "
"``sys.maxsize``\\를 찾는 방법입니다. (사용자가 인터프리터에 로드할 모듈을 미리 알지 못하므로, 파이썬 자체에 의해 "
"미리 로드된 모듈로 제한하는 것이 가장 좋습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1000
msgid ""
"Evaluating default values only at runtime means Argument Clinic can't "
"compute the correct equivalent C default value.  So you need to tell it "
"explicitly. When you use an expression, you must also specify the "
"equivalent expression in C, using the ``c_default`` parameter to the "
"converter:"
msgstr ""
"실행 시간에만 기본값을 평가한다는 것은 인자 클리닉이 올바른 동등한 C 기본값을 계산할 수 없음을 의미합니다. 그래서 여러분은 "
"그것을 명시적으로 말할 필요가 있습니다. 표현식을 사용할 때, 변환기에 대한 ``c_default`` 매개 변수를 사용하여 C에서 "
"동등한 표현식도 지정해야 합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1009
msgid ""
"Another complication: Argument Clinic can't know in advance whether or "
"not the expression you supply is valid.  It parses it to make sure it "
"looks legal, but it can't *actually* know.  You must be very careful when"
" using expressions to specify values that are guaranteed to be valid at "
"runtime!"
msgstr ""
"또 다른 복잡함: 인자 클리닉은 여러분이 제공한 표현식이 유효한지를 미리 알 수 없습니다. 올바르게 보이는지 확인하기 위해 구문 "
"분석하지만, *실제로* 올바른지 알 수는 없습니다. 실행 시간에 유효하다고 보장되는 값을 지정하기 위해 표현식을 사용할 때 매우 "
"주의해야 합니다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1014
msgid ""
"Finally, because expressions must be representable as static C values, "
"there are many restrictions on legal expressions.  Here's a list of "
"Python features you're not permitted to use:"
msgstr ""
"마지막으로, 표현식은 정적 C값으로 표현할 수 있어야 하므로, 유효한 표현식에는 많은 제한이 있습니다. 다음은 사용이 허용되지 않는"
" 파이썬 기능 목록입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1018
msgid "Function calls."
msgstr "함수 호출."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1019
msgid "Inline if statements (``3 if foo else 5``)."
msgstr "인라인 if 문 (``3 if foo else 5``)."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1020
msgid "Automatic sequence unpacking (``*[1, 2, 3]``)."
msgstr "자동 시퀀스 언 패킹 (``*[1, 2, 3]``)."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1021
msgid "List/set/dict comprehensions and generator expressions."
msgstr "리스트/집합/딕셔너리 컴프리헨션과 제너레이터 표현식."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1022
msgid "Tuple/list/set/dict literals."
msgstr "튜플/이스트/집합/딕셔너리 리터럴."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1027
msgid "Using a return converter"
msgstr "반환 변환기 사용하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1029
msgid ""
"By default the impl function Argument Clinic generates for you returns "
"``PyObject *``. But your C function often computes some C type, then "
"converts it into the ``PyObject *`` at the last moment.  Argument Clinic "
"handles converting your inputs from Python types into native C types—why "
"not have it convert your return value from a native C type into a Python "
"type too?"
msgstr ""
"기본적으로 인자 클리닉이 생성하는 impl 함수는 ``PyObject *``\\를 반환합니다. 그러나 여러분의 C 함수는 종종 어떤"
" C형을 계산한 다음, 마지막 순간에 ``PyObject *``\\로 변환합니다. 인자 클리닉은 파이썬 형의 입력을 네이티브 "
"C형으로 변환하는 작업을 처리합니다 - 반환 값을 네이티브 C형에서 파이썬 형으로 변환하지 않을 이유가 무엇입니까?"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1035
msgid ""
"That's what a \"return converter\" does.  It changes your impl function "
"to return some C type, then adds code to the generated (non-impl) "
"function to handle converting that value into the appropriate ``PyObject "
"*``."
msgstr ""
"이것이 \"반환 변환기(return converter)\"가 하는 일입니다. C형을 반환하도록 impl 함수를 변경한 다음, 생성된"
" (impl이 아닌) 함수에 코드를 추가하여 해당 값을 적절한 ``PyObject *``\\로 변환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1039
msgid ""
"The syntax for return converters is similar to that of parameter "
"converters. You specify the return converter like it was a return "
"annotation on the function itself.  Return converters behave much the "
"same as parameter converters; they take arguments, the arguments are all "
"keyword-only, and if you're not changing any of the default arguments you"
" can omit the parentheses."
msgstr ""
"반환 변환기의 문법은 매개 변수 변환기의 것과 유사합니다. 함수 자체에 대한 반환 어노테이션처럼 반환 변환기를 지정합니다. 반환 "
"변환기는 매개 변수 변환기와 거의 같게 작동합니다; 인자를 취하고, 인자는 모두 키워드 전용이며, 기본 인자를 변경하지 않으면 "
"괄호를 생략할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1045
msgid ""
"(If you use both ``\"as\"`` *and* a return converter for your function, "
"the ``\"as\"`` should come before the return converter.)"
msgstr "(함수에 대해 ``\"as\"``\\와 반환 변환기를 *모두* 사용하면, ``\"as\"``\\가 반환 변환기 앞에 와야 합니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1048
msgid ""
"There's one additional complication when using return converters: how do "
"you indicate an error has occurred?  Normally, a function returns a valid"
" (non-``NULL``) pointer for success, and ``NULL`` for failure.  But if "
"you use an integer return converter, all integers are valid.  How can "
"Argument Clinic detect an error?  Its solution: each return converter "
"implicitly looks for a special value that indicates an error.  If you "
"return that value, and an error has been set (``PyErr_Occurred()`` "
"returns a true value), then the generated code will propagate the error."
"  Otherwise it will encode the value you return like normal."
msgstr ""
"반환 변환기를 사용할 때 한 가지 추가적인 문제가 있습니다: 에러가 발생했음을 어떻게 표시합니까? 일반적으로, 함수는 성공에 대해 "
"유효한 (``NULL``\\이 아닌) 포인터를 반환하고, 실패에 대해 ``NULL``\\을 반환합니다. 그러나 정수 반환 변환기를 "
"사용하면, 모든 정수가 유효합니다. 인자 클리닉은 어떻게 에러를 감지할까요? 해결책: 각 반환 변환기는 에러를 나타내는 특수 값을 "
"묵시적으로 찾습니다. 해당 값을 반환하고 에러가 설정되면 (``PyErr_Occurred()``\\는 참값을 반환합니다), 생성된 "
"코드가 에러를 전파합니다. 그렇지 않으면 정상일 때처럼 반환되는 값을 인코딩합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1057
msgid "Currently Argument Clinic supports only a few return converters:"
msgstr "현재 인자 클리닉은 단지 몇 가지 반환 변환기만 지원합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1072
msgid ""
"None of these take parameters.  For the first three, return -1 to "
"indicate error.  For ``DecodeFSDefault``, the return type is ``const char"
" *``; return a ``NULL`` pointer to indicate an error."
msgstr ""
"이들 중 어느 것도 매개 변수를 취하지 않습니다. 처음 세 개의 경우, -1을 반환하여 에러를 나타냅니다. "
"``DecodeFSDefault`` 의 경우, 반환형은 ``const char *``\\입니다; 에러를 나타내기 위해 "
"``NULL`` 포인터를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1076
msgid ""
"(There's also an experimental ``NoneType`` converter, which lets you "
"return ``Py_None`` on success or ``NULL`` on failure, without having to "
"increment the reference count on ``Py_None``.  I'm not sure it adds "
"enough clarity to be worth using.)"
msgstr ""
"(``Py_None``\\에 대한 참조 횟수를 늘리지 않고, 성공 시 ``Py_None``\\을 반환하거나 실패 시 "
"``NULL``\\을 반환할 수 있는, 실험적인 ``NoneType`` 변환기도 있습니다. 사용할 가치가 있을 만큼 명확성을 추가할"
" 수 있을지 모르겠습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1081
msgid ""
"To see all the return converters Argument Clinic supports, along with "
"their parameters (if any), just run ``Tools/clinic/clinic.py "
"--converters`` for the full list."
msgstr ""
"인자 클리닉이 지원하는 모든 반환 변환기를 매개 변수(있다면)와 함께 보려면, 전체 목록을 위해 "
"``Tools/clinic/clinic.py --converters``\\를 실행하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1087
msgid "Cloning existing functions"
msgstr "기존 함수 복제하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1089
msgid ""
"If you have a number of functions that look similar, you may be able to "
"use Clinic's \"clone\" feature.  When you clone an existing function, you"
" reuse:"
msgstr ""
"유사해 보이는 함수가 여러 개이면, 클리닉의 \"복제(clone)\" 기능을 사용할 수 있습니다. 기존 함수를 복제할 때, 다음을 "
"재사용합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1093
msgid "its parameters, including"
msgstr "다음을 포함하는 매개 변수"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1095
msgid "their names,"
msgstr "그들의 이름,"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1097
msgid "their converters, with all parameters,"
msgstr "모든 매개 변수와 함께, 그들의 변환기,"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1099
msgid "their default values,"
msgstr "그들의 기본값,"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1101
msgid "their per-parameter docstrings,"
msgstr "그들의 매개 변수별 독스트링,"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1103
msgid ""
"their *kind* (whether they're positional only, positional or keyword, or "
"keyword only), and"
msgstr "그들의 *종류(kind)* (위치 전용, 위치-키워드 또는 키워드 전용인지), 그리고"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1106
msgid "its return converter."
msgstr "반환 변환기."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1108
msgid ""
"The only thing not copied from the original function is its docstring; "
"the syntax allows you to specify a new docstring."
msgstr "원래 함수에서 복사되지 않는 유일한 것은 독스트링입니다; 문법은 새 독스트링을 지정할 수 있도록 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1111
msgid "Here's the syntax for cloning a function::"
msgstr "다음은 함수 복제 문법입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1119
msgid ""
"(The functions can be in different modules or classes.  I wrote "
"``module.class`` in the sample just to illustrate that you must use the "
"full path to *both* functions.)"
msgstr ""
"(함수는 다른 모듈이나 클래스에 있을 수 있습니다. *두* 함수에 전체 경로를 사용해야 함을 예시하기 위해 샘플에 "
"``module.class``\\를 작성했습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1123
msgid ""
"Sorry, there's no syntax for partially-cloning a function, or cloning a "
"function then modifying it.  Cloning is an all-or nothing proposition."
msgstr "죄송합니다, 함수를 부분적으로 복제하거나, 함수를 복제한 다음 수정하는 문법은 없습니다. 복제는 전부 아니면 전무입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1126
msgid ""
"Also, the function you are cloning from must have been previously defined"
" in the current file."
msgstr "또한, 복제하려는 함수는 현재 파일에 이전에 정의되어 있어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1130
msgid "Calling Python code"
msgstr "파이썬 코드 호출하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1132
msgid ""
"The rest of the advanced topics require you to write Python code which "
"lives inside your C file and modifies Argument Clinic's runtime state.  "
"This is simple: you simply define a Python block."
msgstr ""
"나머지 고급 주제에서는 C 파일에서 파이썬 코드를 작성하고 인자 클리닉의 실행 시간 상태를 수정해야 합니다. 이것은 간단합니다: "
"파이썬 블록을 정의하기만 하면 됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1136
msgid ""
"A Python block uses different delimiter lines than an Argument Clinic "
"function block.  It looks like this::"
msgstr "파이썬 블록은 인자 클리닉 함수 블록과 다른 구분자 줄을 사용합니다. 다음과 같이 보입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1143
msgid ""
"All the code inside the Python block is executed at the time it's parsed."
"  All text written to stdout inside the block is redirected into the "
"\"output\" after the block."
msgstr ""
"파이썬 블록 내부의 모든 코드는 구문 분석될 때 실행됩니다. 블록 내부에서 stdout에 기록된 모든 텍스트는 블록 뒤의 "
"\"출력\"으로 리디렉션됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1147
msgid ""
"As an example, here's a Python block that adds a static integer variable "
"to the C code::"
msgstr "예를 들어, 다음은 C 코드에 정적 정수 변수를 추가하는 파이썬 블록입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1158
msgid "Using a \"self converter\""
msgstr "\"self 변환기\" 사용하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1160
msgid ""
"Argument Clinic automatically adds a \"self\" parameter for you using a "
"default converter.  It automatically sets the ``type`` of this parameter "
"to the \"pointer to an instance\" you specified when you declared the "
"type.  However, you can override Argument Clinic's converter and specify "
"one yourself. Just add your own ``self`` parameter as the first parameter"
" in a block, and ensure that its converter is an instance of "
"``self_converter`` or a subclass thereof."
msgstr ""
"인자 클리닉은 기본 변환기를 사용하여 \"self\" 매개 변수를 자동으로 추가합니다. 이 매개 변수의 ``type``\\을 형을 "
"선언할 때 지정한 \"인스턴스에 대한 포인터\"로 자동 설정합니다. 그러나, 인자 클리닉의 변환기를 재정의하고 직접 지정할 수 "
"있습니다. 자신의 ``self`` 매개 변수를 블록의 첫 번째 매개 변수로 추가하고, 변환기가 "
"``self_converter``\\나 서브 클래스의 인스턴스가 되도록 하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1169
msgid ""
"What's the point?  This lets you override the type of ``self``, or give "
"it a different default name."
msgstr "요점은 무엇일까요? 이렇게 하면 ``self`` 형을 재정의하거나, 다른 기본 이름을 지정할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1172
msgid ""
"How do you specify the custom type you want to cast ``self`` to? If you "
"only have one or two functions with the same type for ``self``, you can "
"directly use Argument Clinic's existing ``self`` converter, passing in "
"the type you want to use as the ``type`` parameter::"
msgstr ""
"``self``\\를 캐스트 하려는 사용자 정의 형을 어떻게 지정할까요? ``self``\\에 대해 같은 형의 함수가 하나나 두 "
"개만 있으면, 인자 클리닉의 기존 ``self`` 변환기를 직접 사용하여, 사용할 형을 ``type`` 매개 변수로 전달할 수 "
"있습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1188
msgid ""
"On the other hand, if you have a lot of functions that will use the same "
"type for ``self``, it's best to create your own converter, subclassing "
"``self_converter`` but overwriting the ``type`` member::"
msgstr ""
"반면에, ``self``\\에 대해 같은 형을 사용할 함수가 많으면, ``self_converter``\\를 서브 클래싱하지만 "
"``type`` 멤버를 재정의하는 자체 변환기를 만드는 것이 가장 좋습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1211
msgid "Writing a custom converter"
msgstr "사용자 정의 변환기 작성하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1213
msgid ""
"As we hinted at in the previous section... you can write your own "
"converters! A converter is simply a Python class that inherits from "
"``CConverter``. The main purpose of a custom converter is if you have a "
"parameter using the ``O&`` format unit—parsing this parameter means "
"calling a :c:func:`PyArg_ParseTuple` \"converter function\"."
msgstr ""
"이전 섹션에서 암시했듯이... 자신만의 변환기를 작성할 수 있습니다! 변환기는 ``CConverter``\\를 상속하는 단순한 "
"파이썬 클래스입니다. 사용자 정의 변환기의 주요 목적은 ``O&`` 포맷 단위를 사용하는 매개 변수가 있을 때입니다 - 이 매개 "
"변수를 구문 분석한다는 것은 :c:func:`PyArg_ParseTuple` \"변환기 함수\"를 호출하는 것을 의미합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1219
msgid ""
"Your converter class should be named ``*something*_converter``. If the "
"name follows this convention, then your converter class will be "
"automatically registered with Argument Clinic; its name will be the name "
"of your class with the ``_converter`` suffix stripped off.  (This is "
"accomplished with a metaclass.)"
msgstr ""
"변환기 클래스의 이름은 ``*something*_converter``\\여야 합니다. 이름이 이 규칙을 따르면, 변환기 클래스가 "
"인자 클리닉에 자동으로 등록됩니다: 그 이름은 ``_converter`` 접미사가 제거된 클래스 이름이 됩니다. (이는 메타 "
"클래스로 수행됩니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1225
msgid ""
"You shouldn't subclass ``CConverter.__init__``.  Instead, you should "
"write a ``converter_init()`` function.  ``converter_init()`` always "
"accepts a ``self`` parameter; after that, all additional parameters "
"*must* be keyword-only.  Any arguments passed in to the converter in "
"Argument Clinic will be passed along to your ``converter_init()``."
msgstr ""
"``CConverter.__init__``\\를 서브 클래스 해서는 안 됩니다. 대신, ``converter_init()`` 함수를"
" 작성해야 합니다. ``converter_init()``\\는 항상 ``self`` 매개 변수를 받아들입니다; 그 후에, 모든 추가"
" 매개 변수는 *반드시* 키워드 전용이어야 합니다. 인자 클리닉의 변환기에 전달된 모든 인자는 여러분의 "
"``converter_init()``\\로 전달됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1232
msgid ""
"There are some additional members of ``CConverter`` you may wish to "
"specify in your subclass.  Here's the current list:"
msgstr "서브 클래스에 지정하고 싶을 ``CConverter``\\의 추가 멤버가 있습니다. 현재 목록은 다음과 같습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1236
msgid ""
"The C type to use for this variable. ``type`` should be a Python string "
"specifying the type, e.g. ``int``. If this is a pointer type, the type "
"string should end with ``' *'``."
msgstr ""
"이 변수에 사용할 C형. ``type``\\은 형을 지정하는 파이썬 문자열이어야 합니다, 예를 들어 ``int``. 포인터형이면, "
"형 문자열은 ``' *'``\\로 끝나야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1242
msgid "``default``"
msgstr "``default``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1241
msgid ""
"The Python default value for this parameter, as a Python value. Or the "
"magic value ``unspecified`` if there is no default."
msgstr "이 매개 변수의 파이썬 기본값 (파이썬 값). 또는 기본값이 없으면 매직 값 ``unspecified``."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1247
msgid "``py_default``"
msgstr "``py_default``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1245
msgid ""
"``default`` as it should appear in Python code, as a string. Or ``None`` "
"if there is no default."
msgstr "파이썬 코드에 나타날 ``default`` (문자열). 또는 기본값이 없으면 ``None``."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1250
msgid ""
"``default`` as it should appear in C code, as a string. Or ``None`` if "
"there is no default."
msgstr "C 코드에 나타날 ``default`` (문자열). 또는 기본값이 없으면 ``None``."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1263
msgid "``c_ignored_default``"
msgstr "``c_ignored_default``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1255
msgid ""
"The default value used to initialize the C variable when there is no "
"default, but not specifying a default may result in an \"uninitialized "
"variable\" warning.  This can easily happen when using option "
"groups—although properly-written code will never actually use this value,"
" the variable does get passed in to the impl, and the C compiler will "
"complain about the \"use\" of the uninitialized value.  This value should"
" always be a non-empty string."
msgstr ""
"기본값은 없지만, 기본값을 지정하지 않으면 \"초기화되지 않은 변수\" 경고를 발생시킬 수 있을 때, C 변수를 초기화하는 데 "
"사용되는 기본값. 이는 옵션 그룹을 사용할 때 쉽게 발생할 수 있습니다 - 적절하게 작성된 코드는 실제로 이 값을 사용하지 않지만,"
" 변수는 impl에 전달되며, C 컴파일러는 초기화되지 않은 값의 \"사용\"에 대해 불평합니다. 이 값은 항상 비어 있지 않은 "
"문자열이어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1266
msgid "The name of the C converter function, as a string."
msgstr "C 변환기 함수의 이름 (문자열)."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1271
msgid "``impl_by_reference``"
msgstr "``impl_by_reference``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1269
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of "
"the name of the variable when passing it into the impl function."
msgstr "불리언 값. 참이면, 인자 클리닉은 변수를 impl 함수에 전달할 때 변수 이름 앞에 ``&``\\를 추가합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1277
msgid "``parse_by_reference``"
msgstr "``parse_by_reference``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1274
msgid ""
"A boolean value.  If true, Argument Clinic will add a ``&`` in front of "
"the name of the variable when passing it into :c:func:`PyArg_ParseTuple`."
msgstr ""
"불리언 값. 참이면, 인자 클리닉은 변수를 :c:func:`PyArg_ParseTuple`\\에 전달할 때 변수 이름 앞에 "
"``&``\\를 추가합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1279
msgid ""
"Here's the simplest example of a custom converter, from "
"``Modules/zlibmodule.c``::"
msgstr "다음은 ``Modules/zlibmodule.c``\\에서 온, 사용자 정의 변환기의 가장 간단한 예입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1290
msgid ""
"This block adds a converter to Argument Clinic named ``ssize_t``.  "
"Parameters declared as ``ssize_t`` will be declared as type "
"``Py_ssize_t``, and will be parsed by the ``'O&'`` format unit, which "
"will call the ``ssize_t_converter`` converter function.  ``ssize_t`` "
"variables automatically support default values."
msgstr ""
"이 블록은 ``ssize_t``\\라는 이름의 변환기를 인자 클리닉에 추가합니다. ``ssize_t``\\로 선언된 매개 변수는 "
"``Py_ssize_t`` 형으로 선언되고, ``ssize_t_converter`` 변환기 함수를 호출하는 ``'O&'`` 포맷 "
"단위로 구문 분석됩니다. ``ssize_t`` 변수는 자동으로 기본값을 지원합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1296
msgid ""
"More sophisticated custom converters can insert custom C code to handle "
"initialization and cleanup. You can see more examples of custom "
"converters in the CPython source tree; grep the C files for the string "
"``CConverter``."
msgstr ""
"더욱 정교한 사용자 정의 변환기는 사용자 정의 C 코드를 삽입하여 초기화와 정리를 처리할 수 있습니다. CPython 소스 트리에서"
" 사용자 정의 변환기의 더 많은 예제를 볼 수 있습니다; 문자열 ``CConverter``\\에 대해 C 파일을 grep 하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1302
msgid "Writing a custom return converter"
msgstr "사용자 정의 반환 변환기 작성하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1304
msgid ""
"Writing a custom return converter is much like writing a custom "
"converter.  Except it's somewhat simpler, because return converters are "
"themselves much simpler."
msgstr ""
"사용자 정의 반환 변환기를 작성하는 것은 사용자 정의 변환기를 작성하는 것과 매우 유사합니다. 반환 변환기 자체가 훨씬 간단하기 "
"때문에 다소 간단하다는 점만 다릅니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1308
msgid ""
"Return converters must subclass ``CReturnConverter``. There are no "
"examples yet of custom return converters, because they are not widely "
"used yet.  If you wish to write your own return converter, please read "
"``Tools/clinic/clinic.py``, specifically the implementation of "
"``CReturnConverter`` and all its subclasses."
msgstr ""
"반환 변환기는 ``CReturnConverter``\\를 서브 클래스 해야 합니다. 아직 널리 사용되지 않기 때문에, 사용자 정의 "
"반환 변환기의 예는 아직 없습니다. 자체 반환 변환기를 작성하려면, ``Tools/clinic/clinic.py``, 특히 "
"``CReturnConverter``\\와 모든 서브 클래스의 구현을 읽으십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1316
msgid "METH_O and METH_NOARGS"
msgstr "METH_O와 METH_NOARGS"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1318
msgid ""
"To convert a function using ``METH_O``, make sure the function's single "
"argument is using the ``object`` converter, and mark the arguments as "
"positional-only::"
msgstr ""
"``METH_O``\\를 사용하는 함수를 변환하려면, 함수의 단일 인자가 ``object`` 변환기를 사용하고 있는지 확인하고, "
"인자를 위치 전용으로 표시하십시오::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1330
msgid ""
"To convert a function using ``METH_NOARGS``, just don't specify any "
"arguments."
msgstr "``METH_NOARGS``\\를 사용하는 함수를 변환하려면, 인자를 지정하지 마십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1333
msgid ""
"You can still use a self converter, a return converter, and specify a "
"``type`` argument to the object converter for ``METH_O``."
msgstr ""
"여전히 self 변환기, 반환 변환기를 사용하고, ``METH_O``\\를 위한 객체 변환기에 ``type`` 인자를 지정할 수 "
"있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1337
msgid "tp_new and tp_init functions"
msgstr "tp_new와 tp_init 함수"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1339
msgid ""
"You can convert ``tp_new`` and ``tp_init`` functions.  Just name them "
"``__new__`` or ``__init__`` as appropriate.  Notes:"
msgstr ""
"``tp_new``\\와 ``tp_init`` 함수를 변환할 수 있습니다. 적절하게 ``__new__``\\나 "
"``__init__``\\로 이름을 지정하십시오. 참고:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1342
msgid ""
"The function name generated for ``__new__`` doesn't end in ``__new__`` "
"like it would by default.  It's just the name of the class, converted "
"into a valid C identifier."
msgstr ""
"``__new__``\\에 대해 생성된 함수 이름은 기본적으로 그런 것처럼 ``__new__``\\로 끝나지 않습니다. 유효한 C "
"식별자로 변환된 클래스의 이름일 뿐입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1346
msgid "No ``PyMethodDef`` ``#define`` is generated for these functions."
msgstr "이러한 함수에 대해 ``PyMethodDef`` ``#define``\\이 생성되지 않습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1348
msgid "``__init__`` functions return ``int``, not ``PyObject *``."
msgstr "``__init__`` 함수는 ``PyObject *``\\가 아니라 ``int``\\를 반환합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1350
msgid "Use the docstring as the class docstring."
msgstr "독스트링을 클래스 독스트링으로 사용합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1352
msgid ""
"Although ``__new__`` and ``__init__`` functions must always accept both "
"the ``args`` and ``kwargs`` objects, when converting you may specify any "
"signature for these functions that you like. (If your function doesn't "
"support keywords, the parsing function generated will throw an exception "
"if it receives any.)"
msgstr ""
"``__new__``\\와 ``__init__`` 함수는 항상 ``args``\\와 ``kwargs`` 객체를 모두 받아들여야 "
"하지만, 변환할 때 이러한 함수에 대해 원하는 서명을 지정할 수 있습니다. (함수가 키워드를 지원하지 않으면, 생성된 구문 분석 "
"함수에서 받게 되면 예외가 발생합니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1359
msgid "Changing and redirecting Clinic's output"
msgstr "클리닉 출력을 변경하고 리디렉션하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1361
msgid ""
"It can be inconvenient to have Clinic's output interspersed with your "
"conventional hand-edited C code.  Luckily, Clinic is configurable: you "
"can buffer up its output for printing later (or earlier!), or write its "
"output to a separate file.  You can also add a prefix or suffix to every "
"line of Clinic's generated output."
msgstr ""
"기존의 수작업으로 편집 한 C 코드에 클리닉의 출력을 산재시키는 것은 불편할 수 있습니다. 운 좋게도, 클리닉은 구성 가능합니다: "
"나중에 (또는 이전에!) 인쇄하기 위해 출력을 버퍼링하거나, 별도의 파일에 출력을 쓸 수 있습니다. 클리닉의 생성된 출력의 모든 "
"줄에 접두사나 접미사를 추가할 수도 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1367
msgid ""
"While changing Clinic's output in this manner can be a boon to "
"readability, it may result in Clinic code using types before they are "
"defined, or your code attempting to use Clinic-generated code before it "
"is defined. These problems can be easily solved by rearranging the "
"declarations in your file, or moving where Clinic's generated code goes."
"  (This is why the default behavior of Clinic is to output everything "
"into the current block; while many people consider this hampers "
"readability, it will never require rearranging your code to fix "
"definition-before-use problems.)"
msgstr ""
"이러한 방식으로 클리닉의 출력을 변경하면 가독성에 도움이 될 수 있지만, 형이 정의되기 전에 형을 사용하는 클리닉 코드가 "
"발생하거나, 정의되기 전에 클리닉에서 생성된 코드를 사용하려고 시도할 수 있습니다. 이러한 문제는 파일에서 선언을 재정렬하거나, "
"클리닉에서 생성된 코드가 있는 곳으로 이동하여 쉽게 해결할 수 있습니다. (이것이 클리닉의 기본 동작이 모든 것을 현재 블록으로 "
"출력하는 이유입니다; 많은 사람이 이것이 가독성을 방해한다고 생각하지만, 사용 전 정의 문제를 고치기 위해 코드를 재배열할 필요가 "
"없습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1376
msgid "Let's start with defining some terminology:"
msgstr "몇 가지 용어를 정의하는 것으로 시작하겠습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1403
msgid "*field*"
msgstr "*field*"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1379
msgid ""
"A field, in this context, is a subsection of Clinic's output. For "
"example, the ``#define`` for the ``PyMethodDef`` structure is a field, "
"called ``methoddef_define``.  Clinic has seven different fields it can "
"output per function definition:"
msgstr ""
"이 문맥에서, 필드는 클리닉 출력의 하위 섹션입니다. 예를 들어, ``PyMethodDef`` 구조체의 ``#define``\\은 "
"``methoddef_define``\\이라는 필드입니다. 클리닉에는 함수 정의당 출력할 수 있는 7가지 필드가 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1394
msgid ""
"All the names are of the form ``\"<a>_<b>\"``, where ``\"<a>\"`` is the "
"semantic object represented (the parsing function, the impl function, the"
" docstring, or the methoddef structure) and ``\"<b>\"`` represents what "
"kind of statement the field is.  Field names that end in "
"``\"_prototype\"`` represent forward declarations of that thing, without "
"the actual body/data of the thing; field names that end in "
"``\"_definition\"`` represent the actual definition of the thing, with "
"the body/data of the thing.  (``\"methoddef\"`` is special, it's the only"
" one that ends with ``\"_define\"``, representing that it's a "
"preprocessor #define.)"
msgstr ""
"모든 이름은 ``\"<a>_<b>\"`` 형식입니다. 여기서 ``\"<a>\"``\\는 표현 된 의미 객체(구문 분석 함수, "
"impl 함수, 독스트링 또는 methoddef 구조체)이고 ``\"<b>\"``\\는 필드가 어떤 종류의 문장인지를 나타냅니다. "
"``\"_prototype\"``\\으로 끝나는 필드 이름은 무언가의 실제 본문/데이터 없이 무언가의 전방 선언을 나타냅니다; "
"``\"_definition\"``\\으로 끝나는 필드 이름은 무언가의 본문/데이터와 함께 무언가의 실제 정의를 나타냅니다. "
"(``\"methoddef\"``\\는 특별합니다. 전 처리기 #define임을 나타내는 ``\"_define\"``\\으로 끝나는"
" 유일한 것입니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1437
msgid "*destination*"
msgstr "*destination*"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1406
msgid ""
"A destination is a place Clinic can write output to.  There are five "
"built-in destinations:"
msgstr "목적지(destination)는 클리닉이 출력을 쓸 수 있는 장소입니다. 5개의 내장 목적지가 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1411
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1486
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1564
msgid "``block``"
msgstr "``block``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1410
msgid ""
"The default destination: printed in the output section of the current "
"Clinic block."
msgstr "기본 목적지: 현재 클리닉 블록의 출력 섹션에 인쇄됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1417
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1513
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1567
msgid "``buffer``"
msgstr "``buffer``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1414
msgid ""
"A text buffer where you can save text for later.  Text sent here is "
"appended to the end of any existing text.  It's an error to have any text"
" left in the buffer when Clinic finishes processing a file."
msgstr ""
"나중을 위해 텍스트를 저장할 수 있는 텍스트 버퍼. 여기로 전송된 텍스트는 기존 텍스트의 끝에 추가됩니다. 클리닉이 파일 처리를 "
"완료할 때 버퍼에 텍스트가 남아 있으면 에러입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1428
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1499
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1593
msgid "``file``"
msgstr "``file``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1420
msgid ""
"A separate \"clinic file\" that will be created automatically by Clinic. "
"The filename chosen for the file is ``{basename}.clinic{extension}``, "
"where ``basename`` and ``extension`` were assigned the output from "
"``os.path.splitext()`` run on the current file.  (Example: the ``file`` "
"destination for ``_pickle.c`` would be written to ``_pickle.clinic.c``.)"
msgstr ""
"클리닉이 자동으로 만들 별도의 \"클리닉 파일\"입니다. 파일에 대해 선택한 파일명은 "
"``{basename}.clinic{extension}``\\입니다. 여기서 ``basename``\\과 "
"``extension``\\에는 현재 파일에 대해 실행되는 ``os.path.splitext()``\\의 출력이 대입되었습니다. "
"(예: ``_pickle.c``\\의 ``file`` 목적지는 ``_pickle.clinic.c``\\에 기록됩니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1427
msgid ""
"**Important: When using a** ``file`` **destination, you** *must check in*"
" **the generated file!**"
msgstr "**중요:** ``file`` **목적지를 사용할 때, 생성된 파일을** *반드시 체크인하는* **것이 중요합니다!**"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1433
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1526
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1597
msgid "``two-pass``"
msgstr "``two-pass``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1431
msgid ""
"A buffer like ``buffer``.  However, a two-pass buffer can only be dumped "
"once, and it prints out all text sent to it during all processing, even "
"from Clinic blocks *after* the dumping point."
msgstr ""
"``buffer``\\와 같은 버퍼. 그러나, 2 패스 버퍼는 한 번만 덤프 할 수 있으며, 모든 처리 중에 전송된 모든 텍스트를 "
"인쇄합니다, 클리닉에서 덤프 지점 *이후의* 클리닉 블록에서 온 것마저도."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1437
#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1560
msgid "``suppress``"
msgstr "``suppress``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1436
msgid "The text is suppressed—thrown away."
msgstr "텍스트가 표시되지 않고 버려집니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1439
msgid "Clinic defines five new directives that let you reconfigure its output."
msgstr "클리닉은 출력을 재구성 할 수 있는 5개의 새로운 지시문을 정의합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1441
msgid "The first new directive is ``dump``:"
msgstr "첫 번째 새 지시문은 ``dump``\\입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1447
msgid ""
"This dumps the current contents of the named destination into the output "
"of the current block, and empties it.  This only works with ``buffer`` "
"and ``two-pass`` destinations."
msgstr ""
"이것은 명명된 목적지의 현재 내용을 현재 블록의 출력으로 덤프하고, 목적지를 비웁니다. 이것은 ``buffer``\\와 ``two-"
"pass`` 목적지에서만 작동합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1451
msgid ""
"The second new directive is ``output``.  The most basic form of "
"``output`` is like this:"
msgstr "두 번째 새 지시문은 ``output``\\입니다. ``output``\\의 가장 기본적인 형태는 다음과 같습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1458
msgid ""
"This tells Clinic to output *field* to *destination*.  ``output`` also "
"supports a special meta-destination, called ``everything``, which tells "
"Clinic to output *all* fields to that *destination*."
msgstr ""
"이것은 클리닉에 *field*\\를 *destination*\\으로 출력하도록 지시합니다. ``output``\\은 "
"``everything``\\이라는 특수 메타 목적지를 지원합니다. 이 메타 목적지는 클리닉에 *모든* 필드를 해당 *목적지*\\로"
" 출력하도록 지시합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1462
msgid "``output`` has a number of other functions:"
msgstr "``output``\\에는 여러 가지 다른 함수가 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1471
msgid ""
"``output push`` and ``output pop`` allow you to push and pop "
"configurations on an internal configuration stack, so that you can "
"temporarily modify the output configuration, then easily restore the "
"previous configuration.  Simply push before your change to save the "
"current configuration, then pop when you wish to restore the previous "
"configuration."
msgstr ""
"``output push``\\와 ``output pop``\\을 사용하면 내부 구성 스택에 구성을 푸시하고 팝할 수 있어서, 출력"
" 구성을 일시적으로 수정한 다음, 이전 구성을 쉽게 복원 할 수 있습니다. 변경하기 전에 푸시해서 현재 구성을 저장한 다음, 이전 "
"구성을 복원하기 원할 때 팝 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1478
msgid ""
"``output preset`` sets Clinic's output to one of several built-in preset "
"configurations, as follows:"
msgstr "``output preset``\\은 클리닉의 출력을 다음과 같은 여러 내장 사전 설정 구성 중 하나로 설정합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1482
msgid ""
"Clinic's original starting configuration.  Writes everything immediately "
"after the input block."
msgstr "클리닉의 원래 시작 구성. 입력 블록 바로 뒤에 모든 것을 씁니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1485
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write "
"everything else to ``block``."
msgstr ""
"``parser_prototype``\\과 ``docstring_prototype``\\을 억제하고, 나머지는 모두 "
"``block``\\에 씁니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1489
msgid ""
"Designed to write everything to the \"clinic file\" that it can. You then"
" ``#include`` this file near the top of your file. You may need to "
"rearrange your file to make this work, though usually this just means "
"creating forward declarations for various ``typedef`` and "
"``PyTypeObject`` definitions."
msgstr ""
"가능한 모든 것을 \"클리닉 파일\"에 기록하도록 설계되었습니다. 그러면 여러분은 파일 상단 근처에서 이 파일을 "
"``#include`` 합니다. 이것이 작동하려면 파일을 다시 재배치해야 할 수 있습니다, 일반적으로 이것은 단지 다양한 "
"``typedef``\\와 ``PyTypeObject`` 정의에 대한 전방 선언을 만드는 것을 의미하지만."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1495
msgid ""
"Suppress the ``parser_prototype`` and ``docstring_prototype``, write the "
"``impl_definition`` to ``block``, and write everything else to ``file``."
msgstr ""
"``parser_prototype``\\과 ``docstring_prototype``\\을 억제하고, "
"``impl_definition``\\을 ``block``\\에 쓰고 나머지는 모두 ``file``\\에 씁니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1499
msgid "The default filename is ``\"{dirname}/clinic/{basename}.h\"``."
msgstr "기본 파일명은 ``\"{dirname}/clinic/{basename}.h\"``\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1502
msgid ""
"Save up most of the output from Clinic, to be written into your file near"
" the end.  For Python files implementing modules or builtin types, it's "
"recommended that you dump the buffer just above the static structures for"
" your module or builtin type; these are normally very near the end.  "
"Using ``buffer`` may require even more editing than ``file``, if your "
"file has static ``PyMethodDef`` arrays defined in the middle of the file."
msgstr ""
"클리닉의 출력 대부분을 저장하여, 마지막에 파일에 기록합니다. 모듈이나 내장형을 구현하는 파이썬 파일의 경우, 모듈이나 내장형의 "
"정적 구조 바로 위에 버퍼를 덤프하는 것이 좋습니다; 이것들은 일반적으로 거의 끝부분에 있습니다. 파일 중간에 정의된 정적 "
"``PyMethodDef`` 배열이 있으면, ``buffer``\\를 사용하면 ``file``\\보다 더 많은 편집이 필요할 수 "
"있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1511
msgid ""
"Suppress the ``parser_prototype``, ``impl_prototype``, and "
"``docstring_prototype``, write the ``impl_definition`` to ``block``, and "
"write everything else to ``file``."
msgstr ""
"``parser_prototype``, ``impl_prototype`` 및 ``docstring_prototype``\\을 "
"억제하고, ``impl_definition``\\을 ``block``\\에 쓰고, 나머지는 모두 ``file``\\에 씁니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1516
msgid ""
"Similar to the ``buffer`` preset, but writes forward declarations to the "
"``two-pass`` buffer, and definitions to the ``buffer``. This is similar "
"to the ``buffer`` preset, but may require less editing than ``buffer``.  "
"Dump the ``two-pass`` buffer near the top of your file, and dump the "
"``buffer`` near the end just like you would when using the ``buffer`` "
"preset."
msgstr ""
"``buffer`` 사전 설정과 유사하지만, 전방 선언을 ``two-pass`` 버퍼에 쓰고, 정의를 ``buffer``\\에 "
"씁니다. 이것은 ``buffer`` 사전 설정과 유사하지만, ``buffer``\\보다 편집이 덜 필요할 수 있습니다. 파일 상단 "
"근처에 ``two-pass`` 버퍼를 덤프하고, ``buffer`` 사전 설정을 사용할 때처럼 끝 근처에 ``buffer``\\를 "
"덤프하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1523
msgid ""
"Suppresses the ``impl_prototype``, write the ``impl_definition`` to "
"``block``, write ``docstring_prototype``, ``methoddef_define``, and "
"``parser_prototype`` to ``two-pass``, write everything else to "
"``buffer``."
msgstr ""
"``impl_prototype``\\을 억제하고, ``impl_definition``\\을 ``block``\\에 쓰고, "
"``docstring_prototype``, ``methoddef_define`` 및 ``parser_prototype``\\을 "
"``two-pass``\\에 쓰고, 나머지는 모두 ``buffer``\\에 씁니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1537
msgid "``partial-buffer``"
msgstr "``partial-buffer``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1529
msgid ""
"Similar to the ``buffer`` preset, but writes more things to ``block``, "
"only writing the really big chunks of generated code to ``buffer``. This "
"avoids the definition-before-use problem of ``buffer`` completely, at the"
" small cost of having slightly more stuff in the block's output. Dump the"
" ``buffer`` near the end, just like you would when using the ``buffer`` "
"preset."
msgstr ""
"``buffer`` 사전 설정과 유사하지만, ``block``\\에 더 많은 것을 쓰고, 생성된 코드의 정말 큰 덩어리만 "
"``buffer``\\에 씁니다. 이것은 블록의 출력에 약간 더 많은 것을 갖는 적은 비용으로, ``buffer``\\의 사용 전 "
"정의 문제를 완전히 피합니다. ``buffer`` 사전 설정을 사용할 때처럼, 끝부분에 ``buffer``\\를 덤프하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1536
msgid ""
"Suppresses the ``impl_prototype``, write the ``docstring_definition`` and"
" ``parser_definition`` to ``buffer``, write everything else to ``block``."
msgstr ""
"``impl_prototype``\\을 억제하고, ``docstring_definition``\\과 "
"``parser_definition``\\을 ``buffer``\\에 쓰고, 나머지는 모두 ``block``\\에 씁니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1539
msgid "The third new directive is ``destination``:"
msgstr "세 번째 새 지시문은 ``destination``\\입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1545
msgid "This performs an operation on the destination named ``name``."
msgstr "``name``\\이라는 목적지에서 작업을 수행합니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1547
msgid "There are two defined subcommands: ``new`` and ``clear``."
msgstr "두 개의 정의된 부속 명령이 있습니다: ``new``\\와 ``clear``."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1549
msgid "The ``new`` subcommand works like this:"
msgstr "``new`` 부속 명령은 다음과 같이 작동합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1555
msgid "This creates a new destination with name ``<name>`` and type ``<type>``."
msgstr "이렇게 하면 이름이 ``<name>``\\이고 형이 ``<type>``\\인 새 목적지가 만들어집니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1557
msgid "There are five destination types:"
msgstr "다음과 같은 5가지 목적지 형이 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1560
msgid "Throws the text away."
msgstr "텍스트를 버립니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1563
msgid "Writes the text to the current block.  This is what Clinic originally did."
msgstr "현재 블록에 텍스트를 씁니다. 이것이 클리닉이 원래 한 일입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1567
msgid "A simple text buffer, like the \"buffer\" builtin destination above."
msgstr "위의 \"buffer\" 내장 목적지와 같은, 간단한 텍스트 버퍼."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1570
msgid ""
"A text file.  The file destination takes an extra argument, a template to"
" use for building the filename, like so:"
msgstr "텍스트 파일. 파일 목적지는 다음과 같이 파일명을 빌드하는 데 사용할 템플릿인 추가 인자를 취합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1573
msgid "destination <name> new <type> <file_template>"
msgstr "destination <name> new <type> <file_template>"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1575
msgid ""
"The template can use three strings internally that will be replaced by "
"bits of the filename:"
msgstr "템플릿은 내부적으로 파일명의 일부로 대체되는 세 개의 문자열을 사용할 수 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1578
msgid "{path}"
msgstr "{path}"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1579
msgid "The full path to the file, including directory and full filename."
msgstr "디렉터리와 전체 파일명을 포함하는, 파일의 전체 경로."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1580
msgid "{dirname}"
msgstr "{dirname}"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1581
msgid "The name of the directory the file is in."
msgstr "파일이 있는 디렉터리의 이름."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1582
msgid "{basename}"
msgstr "{basename}"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1583
msgid "Just the name of the file, not including the directory."
msgstr "디렉터리를 제외한, 파일의 이름."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1585
msgid "{basename_root}"
msgstr "{basename_root}"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1585
msgid ""
"Basename with the extension clipped off (everything up to but not "
"including the last '.')."
msgstr "확장자가 잘린 basename (마지막 '.'을 포함하지 않는 모든 것)."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1589
msgid "{basename_extension}"
msgstr "{basename_extension}"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1588
msgid ""
"The last '.' and everything after it.  If the basename does not contain a"
" period, this will be the empty string."
msgstr "마지막 '.' 그리고 그 이후의 모든 것. basename에 마침표가 포함되어 있지 않으면, 빈 문자열이 됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1591
msgid ""
"If there are no periods in the filename, {basename} and {filename} are "
"the same, and {extension} is empty.  \"{basename}{extension}\" is always "
"exactly the same as \"{filename}\".\""
msgstr ""
"파일명에 마침표가 없으면, {basename}과 {filename}은 같고, {extension}은 비어 "
"있습니다.\"{basename}{extension}\"은 항상 \"{filename}\".\"과 정확히 같습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1596
msgid "A two-pass buffer, like the \"two-pass\" builtin destination above."
msgstr "위의 \"two-pass\" 내장 목적지와 같은, 2 패스 버퍼."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1599
msgid "The ``clear`` subcommand works like this:"
msgstr "``clear`` 부속 명령은 다음과 같이 작동합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1605
msgid ""
"It removes all the accumulated text up to this point in the destination. "
"(I don't know what you'd need this for, but I thought maybe it'd be "
"useful while someone's experimenting.)"
msgstr ""
"목적지에서 이 지점까지 누적된 모든 텍스트를 제거합니다. (이것이 무엇에 필요한지 모르겠지만, 누군가가 실험하는 동안 유용하리라 "
"생각했습니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1609
msgid "The fourth new directive is ``set``:"
msgstr "네 번째 새 지시문은 ``set``\\입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1616
msgid ""
"``set`` lets you set two internal variables in Clinic. ``line_prefix`` is"
" a string that will be prepended to every line of Clinic's output; "
"``line_suffix`` is a string that will be appended to every line of "
"Clinic's output."
msgstr ""
"``set``\\을 사용하면 클리닉에서 두 개의 내부 변수를 설정할 수 있습니다. ``line_prefix``\\는 클리닉 출력의 "
"모든 줄 앞에 추가되는 문자열입니다; ``line_suffix``\\는 클리닉 출력의 모든 줄에 뒤에 추가되는 문자열입니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1620
msgid "Both of these support two format strings:"
msgstr "둘 다 두 가지 포맷 문자열을 지원합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1623
msgid "``{block comment start}``"
msgstr "``{block comment start}``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1623
msgid "Turns into the string ``/*``, the start-comment text sequence for C files."
msgstr "C 파일의 시작 주석 텍스트 시퀀스인, ``/*`` 문자열로 바뀝니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1626
msgid "``{block comment end}``"
msgstr "``{block comment end}``"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1626
msgid "Turns into the string ``*/``, the end-comment text sequence for C files."
msgstr "C 파일의 종료 주석 텍스트 시퀀스인 ``*/`` 문자열로 바뀝니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1628
msgid ""
"The final new directive is one you shouldn't need to use directly, called"
" ``preserve``:"
msgstr "마지막 새 지시문은 ``preserve``\\라고 하는 여러분이 직접 사용할 필요가 없는 것입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1635
msgid ""
"This tells Clinic that the current contents of the output should be kept,"
" unmodified. This is used internally by Clinic when dumping output into "
"``file`` files; wrapping it in a Clinic block lets Clinic use its "
"existing checksum functionality to ensure the file was not modified by "
"hand before it gets overwritten."
msgstr ""
"이것은 출력의 현재 내용이 수정되지 않고 유지되어야 함을 클리닉에 알려줍니다. 이는 ``file`` 파일로 출력을 덤프할 때 "
"클리닉에서 내부적으로 사용됩니다; 클리닉 블록에서 래핑하면 클리닉이 기존 체크섬 기능을 사용하여 파일을 덮어쓰기 전에 수동으로 "
"수정하지 않았는지 확인할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1642
msgid "The #ifdef trick"
msgstr "#ifdef 트릭"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1644
msgid ""
"If you're converting a function that isn't available on all platforms, "
"there's a trick you can use to make life a little easier.  The existing "
"code probably looks like this::"
msgstr ""
"모든 플랫폼에서 사용할 수 없는 함수를 변환한다면, 좀 더 쉽게 만드는 데 사용할 수 있는 트릭이 있습니다. 기존 코드는 아마도 "
"이럴 겁니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1655
msgid ""
"And then in the ``PyMethodDef`` structure at the bottom the existing code"
" will have:"
msgstr "그런 다음 하단의 ``PyMethodDef`` 구조체에서 기존 코드는 다음과 같습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1664
msgid ""
"In this scenario, you should enclose the body of your impl function "
"inside the ``#ifdef``, like so::"
msgstr "이 시나리오에서는, 다음과 같이 ``#ifdef`` 안에 impl 함수의 본문을 묶어야 합니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1678
msgid ""
"Then, remove those three lines from the ``PyMethodDef`` structure, "
"replacing them with the macro Argument Clinic generated:"
msgstr "그런 다음, ``PyMethodDef`` 구조체에서 앞의 세 줄을 제거하고 인자 클리닉이 생성한 매크로로 바꿉니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1685
msgid ""
"(You can find the real name for this macro inside the generated code. Or "
"you can calculate it yourself: it's the name of your function as defined "
"on the first line of your block, but with periods changed to underscores,"
" uppercased, and ``\"_METHODDEF\"`` added to the end.)"
msgstr ""
"(생성된 코드 내에서 이 매크로의 실제 이름을 찾을 수 있습니다. 또는 직접 계산할 수 있습니다: 블록의 첫 번째 줄에 정의된 함수"
" 이름이지만, 마침표는 밑줄로 변경되고, 대문자로 변경되고, ``\"_METHODDEF\"``\\를 끝에 추가합니다.)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1690
msgid ""
"Perhaps you're wondering: what if ``HAVE_FUNCTIONNAME`` isn't defined? "
"The ``MODULE_FUNCTIONNAME_METHODDEF`` macro won't be defined either!"
msgstr ""
"아마도 여러분은 궁금할 겁니다: ``HAVE_FUNCTIONNAME``\\이 정의되지 않으면? "
"``MODULE_FUNCTIONNAME_METHODDEF`` 매크로도 정의되지 않습니다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1693
msgid ""
"Here's where Argument Clinic gets very clever.  It actually detects that "
"the Argument Clinic block might be deactivated by the ``#ifdef``.  When "
"that happens, it generates a little extra code that looks like this::"
msgstr ""
"여기가 인자 클리닉이 매우 영리해지는 곳입니다. 실제로 인자 클리닉 블록이 ``#ifdef``\\에 의해 비활성화될 수 있음을 "
"감지합니다. 이 경우, 다음과 같은 약간의 추가 코드를 생성합니다::"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1701
msgid ""
"That means the macro always works.  If the function is defined, this "
"turns into the correct structure, including the trailing comma.  If the "
"function is undefined, this turns into nothing."
msgstr ""
"이는 매크로가 항상 작동함을 의미합니다. 함수가 정의되면, 후행 쉼표를 포함하여 올바른 구조로 바뀝니다. 함수가 정의되어 있지 "
"않으면, 아무것도 아니게 됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1705
msgid ""
"However, this causes one ticklish problem: where should Argument Clinic "
"put this extra code when using the \"block\" output preset?  It can't go "
"in the output block, because that could be deactivated by the ``#ifdef``."
"  (That's the whole point!)"
msgstr ""
"그러나 이것은 한 가지 귀찮은 문제를 일으킵니다: 인자 클리닉은 \"block\" 출력 사전 설정을 사용할 때 이 추가 코드를 "
"어디에 넣어야 할까요? ``#ifdef``\\에 의해 비활성화될 수 있기 때문에, 출력 블록에 들어갈 수 없습니다. (그게 "
"요점입니다!)"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1709
msgid ""
"In this situation, Argument Clinic writes the extra code to the "
"\"buffer\" destination. This may mean that you get a complaint from "
"Argument Clinic:"
msgstr "이 상황에서, 인자 클리닉은 \"버퍼\" 목적지에 추가 코드를 작성합니다. 이는 인자 클리닉이 불평함을 의미 할 수 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1717
msgid ""
"When this happens, just open your file, find the ``dump buffer`` block "
"that Argument Clinic added to your file (it'll be at the very bottom), "
"then move it above the ``PyMethodDef`` structure where that macro is "
"used."
msgstr ""
"이 경우, 파일을 열고, 인자 클리닉이 파일에 추가한 ``dump buffer`` 블록(맨 아래에 있습니다)을 찾은 다음, 해당 "
"매크로가 사용되는 ``PyMethodDef`` 구조체 위로 옮깁니다."

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1724
msgid "Using Argument Clinic in Python files"
msgstr "파이썬 파일에서 인자 클리닉 사용하기"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1726
msgid ""
"It's actually possible to use Argument Clinic to preprocess Python files."
" There's no point to using Argument Clinic blocks, of course, as the "
"output wouldn't make any sense to the Python interpreter.  But using "
"Argument Clinic to run Python blocks lets you use Python as a Python "
"preprocessor!"
msgstr ""
"인자 클리닉을 사용하여 파이썬 파일을 전처리하는 것이 실제로 가능합니다. 물론 인자 클리닉 블록을 사용하는 것은 의미가 없습니다. "
"출력이 파이썬 인터프리터에게 의미가 없기 때문입니다. 하지만 인자 클리닉을 사용하여 파이썬 블록을 실행하면 파이썬을 파이썬 "
"전처리기로 사용할 수 있습니다!"

#: /Users/flowdas/works/docs/python/src/Doc/howto/clinic.rst:1731
msgid ""
"Since Python comments are different from C comments, Argument Clinic "
"blocks embedded in Python files look slightly different.  They look like "
"this:"
msgstr "파이썬 주석은 C 주석과 다르기 때문에, 파이썬 파일에 포함된 인자 클리닉 블록은 약간 다르게 보입니다. 이런 식입니다:"

