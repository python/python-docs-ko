# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-12-25 10:27+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.6.0\n"

#: ../Doc/tutorial/inputoutput.rst:5
msgid "Input and Output"
msgstr "입력과 출력"

#: ../Doc/tutorial/inputoutput.rst:7
msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. "
"This chapter will discuss some of the possibilities."
msgstr ""
"프로그램의 출력을 표현하는 여러 가지 방법이 있습니다; 사람이 일기에 적합한 형태로 데이터를 인쇄할 수도 있고, 나중에 사용하기 "
"위해 파일에 쓸 수도 있습니다. 이 장에서는 몇 가지 가능성을 논합니다."

#: ../Doc/tutorial/inputoutput.rst:15
msgid "Fancier Output Formatting"
msgstr "장식적인 출력 포매팅"

#: ../Doc/tutorial/inputoutput.rst:17
msgid ""
"So far we've encountered two ways of writing values: *expression "
"statements* and the :func:`print` function.  (A third way is using the "
":meth:`write` method of file objects; the standard output file can be "
"referenced as ``sys.stdout``. See the Library Reference for more "
"information on this.)"
msgstr ""
"지금까지 우리는 값을 쓰는 두 가지 방법을 만났습니다: *표현식 문장* 과 :func:`print` 함수입니다. (세 번째 방법은 "
"파일 객체의 :meth:`write` 메서드를 사용하는 것입니다; 표준 출력 파일은 ``sys.stdout`` 로 참조할 수 "
"있습니다. 이것에 대한 자세한 정보는 라이브러리 레퍼런스를 보세요.)"

#: ../Doc/tutorial/inputoutput.rst:22
msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values. There are several ways to format "
"output."
msgstr ""
"종종 단순히 스페이스로 구분된 값을 인쇄하는 것보다 출력 형식을 더 많이 제어해야 하는 경우가 있습니다. 출력을 포맷하는 데는 여러"
" 가지 방법이 있습니다."

#: ../Doc/tutorial/inputoutput.rst:25
msgid ""
"To use :ref:`formatted string literals <tut-f-strings>`, begin a string "
"with ``f`` or ``F`` before the opening quotation mark or triple quotation"
" mark. Inside this string, you can write a Python expression between "
"``{`` and ``}`` characters that can refer to variables or literal values."
msgstr ""
":ref:`포맷 문자열 리터럴 <tut-f-strings>`\\을 사용하려면, 시작 인용 부호 또는 삼중 인용 부호 앞에 ``f``"
" 또는 ``F`` 를 붙여 문자열을 시작하십시오. 이 문자열 안에서, ``{`` 및 ``}`` 문자 사이에, 변수 또는 리터럴 값을"
" 참조할 수 있는 파이썬 표현식을 작성할 수 있습니다."

#: ../Doc/tutorial/inputoutput.rst:37
msgid ""
"The :meth:`str.format` method of strings requires more manual effort.  "
"You'll still use ``{`` and ``}`` to mark where a variable will be "
"substituted and can provide detailed formatting directives, but you'll "
"also need to provide the information to be formatted."
msgstr ""
"문자열의 :meth:`str.format` 메서드는 더 많은 수작업을 요구합니다. 변수가 대체 될 위치를 표시하기 위해 ``{`` "
"및 ``}``\\를 여전히 사용하고, 자세한 포매팅 디렉티브를 제공할 수 있지만, 포맷할 정보도 제공해야 합니다."

#: ../Doc/tutorial/inputoutput.rst:50
msgid ""
"Finally, you can do all the string handling yourself by using string "
"slicing and concatenation operations to create any layout you can "
"imagine.  The string type has some methods that perform useful operations"
" for padding strings to a given column width."
msgstr ""
"마지막으로, 문자열 슬라이싱 및 이어붙이기 연산을 사용하여 상상할 수 있는 모든 배치를 만듦으로써, 모든 문자열 처리를 스스로 "
"수행할 수 있습니다. 문자열형에는 주어진 열 너비로 문자열을 채우는 데 유용한 연산을 수행하는 몇 가지 메서드가 있습니다."

#: ../Doc/tutorial/inputoutput.rst:55
msgid ""
"When you don't need fancy output but just want a quick display of some "
"variables for debugging purposes, you can convert any value to a string "
"with the :func:`repr` or :func:`str` functions."
msgstr ""
"장식적인 출력이 필요하지 않고 단지 디버깅을 위해 일부 변수를 빠르게 표시하려면, :func:`repr` 또는 :func:`str`"
" 함수를 사용하여 모든 값을 문자열로 변환할 수 있습니다."

#: ../Doc/tutorial/inputoutput.rst:59
msgid ""
"The :func:`str` function is meant to return representations of values "
"which are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a "
":exc:`SyntaxError` if there is no equivalent syntax).  For objects which "
"don't have a particular representation for human consumption, :func:`str`"
" will return the same value as :func:`repr`.  Many values, such as "
"numbers or structures like lists and dictionaries, have the same "
"representation using either function.  Strings, in particular, have two "
"distinct representations."
msgstr ""
":func:`str` 함수는 어느 정도 사람이 읽기에 적합한 형태로 값의 표현을 돌려주게 되어있습니다. 반면에 "
":func:`repr` 은 인터프리터에 의해 읽힐 수 있는 형태를 만들게 되어있습니다 (또는 그렇게 표현할 수 있는 문법이 없으면 "
":exc:`SyntaxError` 를 일으키도록 구성됩니다). 사람이 소비하기 위한 특별한 표현이 없는 객체의 경우, "
":func:`str` 는 :func:`repr` 과 같은 값을 돌려줍니다. 많은 값, 숫자들이나 리스트와 딕셔너리와 같은 구조들, "
"은 두 함수를 쓸 때 같은 표현을 합니다. 특별히, 문자열은 두 가지 표현을 합니다."

#: ../Doc/tutorial/inputoutput.rst:68
msgid "Some examples::"
msgstr "몇 가지 예를 듭니다::"

#: ../Doc/tutorial/inputoutput.rst:91
msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class that "
"offers yet another way to substitute values into strings, using "
"placeholders like ``$x`` and replacing them with values from a "
"dictionary, but offers much less control of the formatting."
msgstr ""
":mod:`string` 모듈에는 문자열에 값을 치환하는 또 다른 방법을 제공하는 :class:`~string.Template` "
"클래스가 포함되어 있습니다. ``$x``\\와 같은 자리 표시자를 사용하고 이것들을 딕셔너리에서 오는 값으로 치환하지만, 포매팅에 "
"대한 제어를 훨씬 덜 제공합니다."

#: ../Doc/tutorial/inputoutput.rst:100
msgid "Formatted String Literals"
msgstr "포맷 문자열 리터럴"

#: ../Doc/tutorial/inputoutput.rst:102
msgid ""
":ref:`Formatted string literals <f-strings>` (also called f-strings for "
"short) let you include the value of Python expressions inside a string by"
" prefixing the string with ``f`` or ``F`` and writing expressions as "
"``{expression}``."
msgstr ""
":ref:`포맷 문자열 리터럴 <f-strings>`\\(간단히 f-문자열이라고도 합니다)은 문자열에 ``f`` 또는 ``F`` "
"접두어를 붙이고 표현식을 ``{expression}``\\로 작성하여 문자열에 파이썬 표현식의 값을 삽입할 수 있게 합니다."

#: ../Doc/tutorial/inputoutput.rst:107
msgid ""
"An optional format specifier can follow the expression. This allows "
"greater control over how the value is formatted. The following example "
"rounds pi to three places after the decimal::"
msgstr ""
"선택적인 포맷 지정자가 표현식 뒤에 올 수 있습니다. 이것으로 값이 포맷되는 방식을 더 정교하게 제어할 수 있습니다. 다음 예는 "
"원주율을 소수점 이하 세 자리로 반올림합니다."

#: ../Doc/tutorial/inputoutput.rst:115
msgid ""
"Passing an integer after the ``':'`` will cause that field to be a "
"minimum number of characters wide.  This is useful for making columns "
"line up. ::"
msgstr "``':'`` 뒤에 정수를 전달하면 해당 필드의 최소 문자 폭이 됩니다. 열을 줄 맞춤할 때 편리합니다. ::"

#: ../Doc/tutorial/inputoutput.rst:126
msgid ""
"Other modifiers can be used to convert the value before it is formatted. "
"``'!a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and "
"``'!r'`` applies :func:`repr`::"
msgstr ""
"다른 수정자를 사용하면 포맷되기 전에 값을 변환할 수 있습니다. ``'!a'``\\는 :func:`ascii`\\를, "
"``'!s'``\\는 :func:`str`\\을, ``'!r'``\\는 :func:`repr`\\을 적용합니다.::"

#: ../Doc/tutorial/inputoutput.rst:136
msgid ""
"For a reference on these format specifications, see the reference guide "
"for the :ref:`formatspec`."
msgstr "이러한 포맷 사양에 대한 레퍼런스는 :ref:`formatspec`\\에 대한 레퍼런스 지침서를 참조하십시오."

#: ../Doc/tutorial/inputoutput.rst:142
msgid "The String format() Method"
msgstr "문자열 format() 메서드"

#: ../Doc/tutorial/inputoutput.rst:144
msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr ":meth:`str.format` 메서드의 기본적인 사용법은 이런 식입니다::"

#: ../Doc/tutorial/inputoutput.rst:149
msgid ""
"The brackets and characters within them (called format fields) are "
"replaced with the objects passed into the :meth:`str.format` method.  A "
"number in the brackets can be used to refer to the position of the object"
" passed into the :meth:`str.format` method. ::"
msgstr ""
"중괄호와 그 안에 있는 문자들 (포맷 필드라고 부른다) 은 :meth:`str.format` 메서드로 전달된 객체들로 치환됩니다. "
"중괄호 안의 숫자는 :meth:`str.format` 메서드로 전달된 객체들의 위치를 가리키는데 사용될 수 있습니다. ::"

#: ../Doc/tutorial/inputoutput.rst:159
msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their "
"values are referred to by using the name of the argument. ::"
msgstr ":meth:`str.format` 메서드에 키워드 인자가 사용되면, 그 값들은 인자의 이름을 사용해서 지정할 수 있습니다. ::"

#: ../Doc/tutorial/inputoutput.rst:166
msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr "위치와 키워드 인자를 자유롭게 조합할 수 있습니다::"

#: ../Doc/tutorial/inputoutput.rst:172
msgid ""
"If you have a really long format string that you don't want to split up, "
"it would be nice if you could reference the variables to be formatted by "
"name instead of by position.  This can be done by simply passing the dict"
" and using square brackets ``'[]'`` to access the keys ::"
msgstr ""
"나누고 싶지 않은 정말 긴 포맷 문자열이 있을 때, 포맷할 변수들을 위치 대신에 이름으로 지정할 수 있다면 좋을 것입니다. 간단히 "
"딕셔너리를 넘기고 키를 액세스하는데 대괄호 ``'[]'`` 를 사용하면 됩니다 ::"

#: ../Doc/tutorial/inputoutput.rst:182
msgid ""
"This could also be done by passing the table as keyword arguments with "
"the '**' notation. ::"
msgstr "'**' 표기법을 사용해서 table을 키워드 인자로 전달해도 같은 결과를 얻을 수 있습니다. ::"

#: ../Doc/tutorial/inputoutput.rst:189
msgid ""
"This is particularly useful in combination with the built-in function "
":func:`vars`, which returns a dictionary containing all local variables."
msgstr "이 방법은 모든 지역 변수들을 담은 딕셔너리를 돌려주는 내장 함수 :func:`vars` 와 함께 사용할 때 특히 쓸모가 있습니다. "

#: ../Doc/tutorial/inputoutput.rst:192
msgid ""
"As an example, the following lines produce a tidily-aligned set of "
"columns giving integers and their squares and cubes::"
msgstr "예를 들어, 다음 줄은 정수와 그 제곱과 세제곱을 제공하는 빽빽하게 정렬된 열 집합을 생성합니다::"

#: ../Doc/tutorial/inputoutput.rst:209
msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see"
" :ref:`formatstrings`."
msgstr ":meth:`str.format` 를 사용한 문자열 포매팅의 완전한 개요는 :ref:`formatstrings` 을 보세요."

#: ../Doc/tutorial/inputoutput.rst:214
msgid "Manual String Formatting"
msgstr "수동 문자열 포매팅"

#: ../Doc/tutorial/inputoutput.rst:216
msgid "Here's the same table of squares and cubes, formatted manually::"
msgstr "여기 같은 제곱수와 세제곱수 표를 수동으로 포매팅했습니다::"

#: ../Doc/tutorial/inputoutput.rst:234
msgid ""
"(Note that the one space between each column was added by the way "
":func:`print` works: it always adds spaces between its arguments.)"
msgstr ""
"(:func:`print` 의 동작 방식으로 인해 각 칼럼 사이에 스페이스 하나가 추가되었음에 유의하세요: 항상 인자들 사이에 "
"스페이스를 추가합니다.)"

#: ../Doc/tutorial/inputoutput.rst:237
msgid ""
"The :meth:`str.rjust` method of string objects right-justifies a string "
"in a field of a given width by padding it with spaces on the left. There "
"are similar methods :meth:`str.ljust` and :meth:`str.center`. These "
"methods do not write anything, they just return a new string. If the "
"input string is too long, they don't truncate it, but return it "
"unchanged; this will mess up your column lay-out but that's usually "
"better than the alternative, which would be lying about a value. (If you "
"really want truncation you can always add a slice operation, as in "
"``x.ljust(n)[:n]``.)"
msgstr ""
"문자열 객체의 :meth:`str.rjust` 메서드는 왼쪽에 스페이스를 채워서 주어진 폭으로 문자열을 우측 줄 맞춤합니다. 비슷한"
" 메서드 :meth:`str.ljust` 와 :meth:`str.center` 도 있습니다. 이 메서드들은 어떤 것도 출력하지 "
"않습니다, 단지 새 문자열을 돌려줍니다. 입력 문자열이 너무 길면, 자르지 않고, 변경 없이 그냥 돌려줍니다; 이것이 열 배치를 "
"엉망으로 만들겠지만, 보통 값에 대해 거짓말을 하게 될 대안보다는 낫습니다. (정말로 잘라내기를 원한다면, 항상 슬라이스 연산을 "
"추가할 수 있습니다, ``x.ljust(n)[:n]`` 처럼.)"

#: ../Doc/tutorial/inputoutput.rst:246
msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string "
"on the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"다른 메서드도 있습니다, :meth:`str.zfill`. 숫자 문자열의 왼쪽에 0을 채웁니다. 플러스와 마이너스 부호도 "
"이해합니다:: "

#: ../Doc/tutorial/inputoutput.rst:258
msgid "Old string formatting"
msgstr "예전의 문자열 포매팅"

#: ../Doc/tutorial/inputoutput.rst:260
msgid ""
"The ``%`` operator can also be used for string formatting. It interprets "
"the left argument much like a :c:func:`sprintf`\\ -style format string to"
" be applied to the right argument, and returns the string resulting from "
"this formatting operation. For example::"
msgstr ""
"``%`` 연산자도 문자열 포매팅에 사용될 수 있습니다. 왼쪽 인자를 오른쪽 인자에 적용되는 :c:func:`sprintf`\\ "
"-스타일 포맷 문자열로 해석하고, 이 포매팅 연산의 결과로 얻어지는 문자열을 돌려줍니다. 예를 들어::"

#: ../Doc/tutorial/inputoutput.rst:269
msgid "More information can be found in the :ref:`old-string-formatting` section."
msgstr "더 자세한 내용은 :ref:`old-string-formatting` 섹션에 나옵니다."

#: ../Doc/tutorial/inputoutput.rst:275
msgid "Reading and Writing Files"
msgstr "파일을 읽고 쓰기"

#: ../Doc/tutorial/inputoutput.rst:281
msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used "
"with two arguments: ``open(filename, mode)``."
msgstr ""
":func:`open` 은 :term:`파일 객체 <file object>` 를 돌려주고, 두 개의 인자를 주는 방식이 가장 많이 "
"사용됩니다: ``open(filename, mode)``."

#: ../Doc/tutorial/inputoutput.rst:293
msgid ""
"The first argument is a string containing the filename.  The second "
"argument is another string containing a few characters describing the way"
" in which the file will be used.  *mode* can be ``'r'`` when the file "
"will only be read, ``'w'`` for only writing (an existing file with the "
"same name will be erased), and ``'a'`` opens the file for appending; any "
"data written to the file is automatically added to the end.  ``'r+'`` "
"opens the file for both reading and writing. The *mode* argument is "
"optional; ``'r'`` will be assumed if it's omitted."
msgstr ""
"첫 번째 인자는 파일 이름을 담은 문자열입니다. 두 번째 인자는 파일이 사용될 방식을 설명하는 몇 개의 문자들을 담은 또 하나의 "
"문자열입니다. *mode* 는 파일을 읽기만 하면 ``'r'``, 쓰기만 하면 ``'w'`` (같은 이름의 이미 존재하는 파일은 "
"삭제됩니다) 가 되고, ``'a'`` 는 파일을 덧붙이기 위해 엽니다; 파일에 기록되는 모든 데이터는 자동으로 끝에 붙습니다. "
"``'r+'`` 는 파일을 읽고 쓰기 위해 엽니다. *mode* 인자는 선택적인데, 생략하면 ``'r'`` 이 가정됩니다."

#: ../Doc/tutorial/inputoutput.rst:302
msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"encoding. If encoding is not specified, the default is platform dependent"
" (see :func:`open`). ``'b'`` appended to the mode opens the file in "
":dfn:`binary mode`: now the data is read and written in the form of bytes"
" objects.  This mode should be used for all files that don't contain "
"text."
msgstr ""
"보통, 파일은 :dfn:`텍스트 모드 (text mode)` 로 열리는데, 이 뜻은, 파일에 문자열을 읽고 쓰고, 파일에는 특정한 "
"인코딩으로 저장된다는 것입니다. 인코딩이 지정되지 않으면 기본값은 플랫폼 의존적입니다 (:func:`open` 을 보세요). "
"mode 에 덧붙여진 ``'b'`` 는 파일을 :dfn:`바이너리 모드 (binary mode)` 로 엽니다: 이제 데이터는 "
"바이트열 객체의 형태로 읽고 쓰입니다. 텍스트를 포함하지 않는 모든 파일에는 이 모드를 사용해야 합니다."

#: ../Doc/tutorial/inputoutput.rst:309
msgid ""
"In text mode, the default when reading is to convert platform-specific "
"line endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  "
"When writing in text mode, the default is to convert occurrences of "
"``\\n`` back to platform-specific line endings.  This behind-the-scenes "
"modification to file data is fine for text files, but will corrupt binary"
" data like that in :file:`JPEG` or :file:`EXE` files.  Be very careful to"
" use binary mode when reading and writing such files."
msgstr ""
"텍스트 모드에서, 읽을 때의 기본 동작은 플랫폼 의존적인 줄 종료 (유닉스에서 ``\\n``, 윈도우에서 ``\\r\\n``) 를 "
"단지 ``\\n`` 로 변경하는 것입니다. 텍스트 모드로 쓸 때, 기본 동작은 ``\\n`` 를 다시 플랫폼 의존적인 줄 종료로 "
"변환하는 것입니다. 이 파일 데이터에 대한 무대 뒤의 수정은 텍스트 파일의 경우는 문제가 안 되지만, :file:`JPEG` 이나 "
":file:`EXE` 파일과 같은 바이너리 데이터를 망치게 됩니다. 그런 파일을 읽고 쓸 때 바이너리 모드를 사용하도록 주의하세요."

#: ../Doc/tutorial/inputoutput.rst:317
msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after "
"its suite finishes, even if an exception is raised at some point.  Using "
":keyword:`!with` is also much shorter than writing equivalent "
":keyword:`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"파일 객체를 다룰 때 :keyword:`with` 키워드를 사용하는 것은 좋은 습관입니다. 혜택은 도중 예외가 발생하더라도 스위트가"
" 종료될 때 파일이 올바르게 닫힌다는 것입니다. :keyword:`!with` 를 사용하는 것은 동등한 :keyword:`try`\\"
" -\\ :keyword:`finally` 블록을 쓰는 것에 비교해 훨씬 짧기도 합니다::"

#: ../Doc/tutorial/inputoutput.rst:328
msgid ""
"If you're not using the :keyword:`with` keyword, then you should call "
"``f.close()`` to close the file and immediately free up any system "
"resources used by it. If you don't explicitly close a file, Python's "
"garbage collector will eventually destroy the object and close the open "
"file for you, but the file may stay open for a while.  Another risk is "
"that different Python implementations will do this clean-up at different "
"times."
msgstr ""
":keyword:`with` 키워드를 사용하지 않으면, ``f.close()`` 를 호출해서 파일을 닫고 사용된 시스템 자원을 즉시"
" 반납해야 합니다. 명시적으로 파일을 닫지 않으면, 파이썬의 가비지 수거기가 결국에는 객체를 파괴하고 여러분을 대신해서 파일을 닫게"
" 되지만, 파일이 한동안 열린 상태로 남아있게 됩니다. 또 다른 위험은 다른 파이썬 구현들은 이 뒷정리를 서로 다른 시점에 "
"수행한다는 것입니다."

#: ../Doc/tutorial/inputoutput.rst:336
msgid ""
"After a file object is closed, either by a :keyword:`with` statement or "
"by calling ``f.close()``, attempts to use the file object will "
"automatically fail. ::"
msgstr ""
"파일 객체가 닫힌 후에는, :keyword:`with` 문이나 ``f.close()`` 를 호출하는 경우 모두, 파일 객체를 "
"사용하려는 시도는 자동으로 실패합니다. ::"

#: ../Doc/tutorial/inputoutput.rst:350
msgid "Methods of File Objects"
msgstr "파일 객체의 매소드"

#: ../Doc/tutorial/inputoutput.rst:352
msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr "이 섹션의 나머지 예들은 ``f`` 라는 파일 객체가 이미 만들어졌다고 가정합니다."

#: ../Doc/tutorial/inputoutput.rst:355
msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some "
"quantity of data and returns it as a string (in text mode) or bytes "
"object (in binary mode). *size* is an optional numeric argument.  When "
"*size* is omitted or negative, the entire contents of the file will be "
"read and returned; it's your problem if the file is twice as large as "
"your machine's memory. Otherwise, at most *size* bytes are read and "
"returned. If the end of the file has been reached, ``f.read()`` will "
"return an empty string (``''``).  ::"
msgstr ""
"파일의 내용을 읽으려면, ``f.read(size)`` 를 호출하는데, 일정량의 데이터를 읽고 문자열 (텍스트 모드 에서) 이나 "
"바이트열 (바이너리 모드에서) 로 돌려줍니다. *size* 는 선택적인 숫자 인자다. *size* 가 생략되거나 음수면 파일의 내용"
" 전체를 읽어서 돌려줍니다; 파일의 크기가 기계의 메모리보다 두 배 크다면 여러분이 감당할 문제입니다. 그렇지 않으면 최대 "
"*size* 바이트를 읽고 돌려줍니다. 파일의 끝에 도달하면, ``f.read()`` 는 빈 문자열 (``''``) 을 돌려줍니다."
" ::"

#: ../Doc/tutorial/inputoutput.rst:369
msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the "
"last line of the file if the file doesn't end in a newline.  This makes "
"the return value unambiguous; if ``f.readline()`` returns an empty "
"string, the end of the file has been reached, while a blank line is "
"represented by ``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` 은 파일에서 한 줄을 읽습니다; 개행 문자 (``\\n``) 는 문자열의 끝에 보존되고, 파일이 "
"개행문자로 끝나지 않는 때에만 파일의 마지막 줄에서만 생략됩니다. 이렇게 반환 값을 모호하지 않게 만듭니다; "
"``f.readline()`` 가 빈 문자열을 돌려주면, 파일의 끝에 도달한 것이지만, 빈 줄은 ``'\\n'``, 즉 하나의 "
"개행문자만을 포함하는 문자열로 표현됩니다. ::"

#: ../Doc/tutorial/inputoutput.rst:383
msgid ""
"For reading lines from a file, you can loop over the file object. This is"
" memory efficient, fast, and leads to simple code::"
msgstr "파일에서 줄들을 읽으려면, 파일 객체에 대해 루핑할 수 있습니다. 이것은 메모리 효율적이고, 빠르며 간단한 코드로 이어집니다::"

#: ../Doc/tutorial/inputoutput.rst:392
msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr "파일의 모든 줄을 리스트로 읽어 들이려면 ``list(f)`` 나 ``f.readlines()`` 를 쓸 수 있습니다."

#: ../Doc/tutorial/inputoutput.rst:395
msgid ""
"``f.write(string)`` writes the contents of *string* to the file, "
"returning the number of characters written. ::"
msgstr "``f.write(string)`` 은 *string* 의 내용을 파일에 쓰고, 출력된 문자들의 개수를 돌려줍니다."

#: ../Doc/tutorial/inputoutput.rst:401
msgid ""
"Other types of objects need to be converted -- either to a string (in "
"text mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"다른 형의 객체들은 쓰기 전에 변환될 필요가 있습니다 -- 문자열 (텍스트 모드에서) 이나 바이트열 객체 (바이너리 모드에서) 로 "
"--::"

#: ../Doc/tutorial/inputoutput.rst:409
msgid ""
"``f.tell()`` returns an integer giving the file object's current position"
" in the file represented as number of bytes from the beginning of the "
"file when in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` 은 파일의 현재 위치를 가리키는 정수를 돌려주는데, 바이너리 모드의 경우 파일의 처음부터의 바이트 수로 "
"표현되고 텍스트 모드의 경우는 불투명한 숫자입니다."

#: ../Doc/tutorial/inputoutput.rst:413
msgid ""
"To change the file object's position, use ``f.seek(offset, from_what)``."
"  The position is computed from adding *offset* to a reference point; the"
" reference point is selected by the *from_what* argument.  A *from_what* "
"value of 0 measures from the beginning of the file, 1 uses the current "
"file position, and 2 uses the end of the file as the reference point.  "
"*from_what* can be omitted and defaults to 0, using the beginning of the "
"file as the reference point. ::"
msgstr ""
"파일 객체의 위치를 바꾸려면, ``f.seek(offset, from_what)`` 를 사용합니다. 위치는 기준점에 *offset*"
" 을 더해서 계산됩니다; 기준점은 *from_what* 인자로 선택합니다. *from_what* 값이 0이면 파일의 처음부터 "
"측정하고, 1이면 현재 파일 위치를 사용하고, 2 는 파일의 끝을 기준점으로 사용합니다. *from_what* 은 생략될 수 있고,"
" 기본값은 0이라서 파일의 처음을 기준점으로 사용합니다. ::"

#: ../Doc/tutorial/inputoutput.rst:432
msgid ""
"In text files (those opened without a ``b`` in the mode string), only "
"seeks relative to the beginning of the file are allowed (the exception "
"being seeking to the very file end with ``seek(0, 2)``) and the only "
"valid *offset* values are those returned from the ``f.tell()``, or zero. "
"Any other *offset* value produces undefined behaviour."
msgstr ""
"텍스트 파일에서는 (모드 문자열에 ``b`` 가 없이 열린 것들), 파일의 시작에 상대적인 위치 변경만 허락되고 (예외는 "
"``seek(0, 2)`` 를 사용해서 파일의 끝으로 위치를 변경하는 경우입니다), 올바른 *offset* 값은 "
"``f.tell()`` 이 돌려준 값과 0뿐입니다. 그 밖의 다른 *offset* 값은 정의되지 않은 결과를 낳습니다."

#: ../Doc/tutorial/inputoutput.rst:438
msgid ""
"File objects have some additional methods, such as :meth:`~file.isatty` "
"and :meth:`~file.truncate` which are less frequently used; consult the "
"Library Reference for a complete guide to file objects."
msgstr ""
"파일 객체는 :meth:`~file.isatty` 나 :meth:`~file.truncate` 같은 몇 가지 메서드를 더 갖고 "
"있는데, 덜 자주 사용됩니다; 파일 객체에 대한 완전한 안내는 라이브러리 레퍼런스를 참조하세요."

#: ../Doc/tutorial/inputoutput.rst:446
msgid "Saving structured data with :mod:`json`"
msgstr ":mod:`json` 으로 구조적인 데이터를 저장하기"

#: ../Doc/tutorial/inputoutput.rst:450
msgid ""
"Strings can easily be written to and read from a file.  Numbers take a "
"bit more effort, since the :meth:`read` method only returns strings, "
"which will have to be passed to a function like :func:`int`, which takes "
"a string like ``'123'`` and returns its numeric value 123.  When you want"
" to save more complex data types like nested lists and dictionaries, "
"parsing and serializing by hand becomes complicated."
msgstr ""
"문자열은 파일에 쉽게 읽고 쓸 수 있습니다. 숫자는 약간의 수고를 해야 하는데, :meth:`read` 메서드가 문자열만을 돌려주기"
" 때문입니다. 이 문자열을 :func:`int` 같은 함수로 전달해야만 하는데, ``'123'`` 같은 문자열을 받고 숫자 값 "
"123을 돌려줍니다. 중첩된 리스트나 딕셔너리 같은 더 복잡한 데이터를 저장하려고 할 때, 수작업으로 파싱하고 직렬화하는 것이 "
"까다로울 수 있습니다."

#: ../Doc/tutorial/inputoutput.rst:457
msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular "
"data interchange format called `JSON (JavaScript Object Notation) "
"<http://json.org>`_.  The standard module called :mod:`json` can take "
"Python data hierarchies, and convert them to string representations; this"
" process is called :dfn:`serializing`.  Reconstructing the data from the "
"string representation is called :dfn:`deserializing`.  Between "
"serializing and deserializing, the string representing the object may "
"have been stored in a file or data, or sent over a network connection to "
"some distant machine."
msgstr ""
"사용자가 반복적으로 복잡한 데이터형을 파일에 저장하는 코드를 작성하고 디버깅하도록 하는 대신, 파이썬은 `JSON "
"(JavaScript Object Notation) <http://json.org>`_ 이라는 널리 쓰이는 데이터 교환 형식을 "
"사용할 수 있게 합니다. :mod:`json` 이라는 표준 모듈은 파이썬 데이터 계층을 받아서 문자열 표현으로 바꿔줍니다; 이 "
"절차를 :dfn:`직렬화 (serializing)` 라고 부릅니다. 문자열 표현으로부터 데이터를 재구성하는 것은 :dfn:`역 "
"직렬화 (deserializing)` 라고 부릅니다. 직렬화와 역 직렬화 사이에서, 객체를 표현하는 문자열은 파일이나 데이터에 "
"저장되거나 네트워크 연결을 통해 원격 기계로 전송될 수 있습니다."

#: ../Doc/tutorial/inputoutput.rst:468
msgid ""
"The JSON format is commonly used by modern applications to allow for data"
" exchange.  Many programmers are already familiar with it, which makes it"
" a good choice for interoperability."
msgstr ""
"JSON 형식은 데이터 교환을 위해 현대 응용 프로그램들이 자주 사용합니다. 많은 프로그래머가 이미 이것에 익숙하므로, 연동성을 "
"위한 좋은 선택이 됩니다."

#: ../Doc/tutorial/inputoutput.rst:472
msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr "객체 ``x`` 가 있을 때, 간단한 한 줄의 코드로 그것의 JSON 문자열 표현을 볼 수 있습니다::"

#: ../Doc/tutorial/inputoutput.rst:479
msgid ""
"Another variant of the :func:`~json.dumps` function, called "
":func:`~json.dump`, simply serializes the object to a :term:`text file`."
"  So if ``f`` is a :term:`text file` object opened for writing, we can do"
" this::"
msgstr ""
":func:`~json.dump`\\라는 :func:`~json.dumps` 함수의 변종은 객체를 :term:`텍스트 파일 "
"<text file>` 로 직렬화합니다. 그래서 ``f`` 가 쓰기를 위해 열린 :term:`텍스트 파일 <text file>` "
"이면, 이렇게 할 수 있습니다::"

#: ../Doc/tutorial/inputoutput.rst:485
msgid ""
"To decode the object again, if ``f`` is a :term:`text file` object which "
"has been opened for reading::"
msgstr "객체를 다시 디코드하려면, ``f`` 가 읽기를 위해 열린 :term:`텍스트 파일 <text file>` 객체일 때::"

#: ../Doc/tutorial/inputoutput.rst:490
msgid ""
"This simple serialization technique can handle lists and dictionaries, "
"but serializing arbitrary class instances in JSON requires a bit of extra"
" effort. The reference for the :mod:`json` module contains an explanation"
" of this."
msgstr ""
"이 간단한 직렬화 테크닉이 리스트와 딕셔너리를 다룰 수 있지만, 임의의 클래스 인스턴스를 JSON 으로 직렬화하기 위해서는 약간의 "
"수고가 더 필요합니다. :mod:`json` 모듈의 레퍼런스는 이 방법에 대한 설명을 담고 있습니다."

#: ../Doc/tutorial/inputoutput.rst:496
msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - 피클 모듈"

#: ../Doc/tutorial/inputoutput.rst:498
msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows "
"the serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: "
"deserializing pickle data coming from an untrusted source can execute "
"arbitrary code, if the data was crafted by a skilled attacker."
msgstr ""
":ref:`JSON <tut-json>` 에 반해, *pickle* 은 임의의 복잡한 파이썬 객체들을 직렬화할 수 있는 "
"프로토콜입니다. 파이썬에 국한되고 다른 언어로 작성된 응용 프로그램들과 통신하는데 사용될 수 없습니다. 기본적으로 안전하지 않기도 "
"합니다: 믿을 수 없는 소스에서 온 데이터를 역 직렬화할 때, 숙련된 공격자에 의해 데이터가 조작되었다면 임의의 코드가 실행될 수 "
"있습니다."

