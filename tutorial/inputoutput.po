# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-04-17 23:44+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../tutorial/inputoutput.rst:5
msgid "Input and Output"
msgstr "입력과 출력"

#: ../../tutorial/inputoutput.rst:7
msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. "
"This chapter will discuss some of the possibilities."
msgstr ""
"프로그램의 출력을 표현하는 여러 가지 방법이 있습니다; 사람이 일기에 적합한 형태로 데이터를 인쇄할 수도 있고, 나중에 사용하기 "
"위해 파일에 쓸 수도 있습니다. 이 장에서는 몇 가지 가능성을 논합니다."

#: ../../tutorial/inputoutput.rst:15
msgid "Fancier Output Formatting"
msgstr "장식적인 출력 포매팅"

#: ../../tutorial/inputoutput.rst:17
#, fuzzy
msgid ""
"So far we've encountered two ways of writing values: *expression "
"statements* and the :func:`print` function.  (A third way is using the "
":meth:`~io.TextIOBase.write` method of file objects; the standard output "
"file can be referenced as ``sys.stdout``. See the Library Reference for "
"more information on this.)"
msgstr ""
"지금까지 우리는 값을 쓰는 두 가지 방법을 만났습니다: *표현식 문장* 과 :func:`print` 함수입니다. (세 번째 방법은 "
"파일 객체의 :meth:`write` 메서드를 사용하는 것입니다; 표준 출력 파일은 ``sys.stdout`` 로 참조할 수 "
"있습니다. 이것에 대한 자세한 정보는 라이브러리 레퍼런스를 보세요.)"

#: ../../tutorial/inputoutput.rst:22
msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values. There are several ways to format "
"output."
msgstr ""
"종종 단순히 스페이스로 구분된 값을 인쇄하는 것보다 출력 형식을 더 많이 제어해야 하는 경우가 있습니다. 출력을 포맷하는 데는 여러"
" 가지 방법이 있습니다."

#: ../../tutorial/inputoutput.rst:25
#, python-brace-format
msgid ""
"To use :ref:`formatted string literals <tut-f-strings>`, begin a string "
"with ``f`` or ``F`` before the opening quotation mark or triple quotation"
" mark. Inside this string, you can write a Python expression between "
"``{`` and ``}`` characters that can refer to variables or literal values."
msgstr ""
":ref:`포맷 문자열 리터럴 <tut-f-strings>`\\을 사용하려면, 시작 인용 부호 또는 삼중 인용 부호 앞에 ``f``"
" 또는 ``F`` 를 붙여 문자열을 시작하십시오. 이 문자열 안에서, ``{`` 및 ``}`` 문자 사이에, 변수 또는 리터럴 값을"
" 참조할 수 있는 파이썬 표현식을 작성할 수 있습니다."

#: ../../tutorial/inputoutput.rst:32
#, python-brace-format
msgid ""
">>> year = 2016\n"
">>> event = 'Referendum'\n"
">>> f'Results of the {year} {event}'\n"
"'Results of the 2016 Referendum'"
msgstr ""

#: ../../tutorial/inputoutput.rst:37
#, fuzzy, python-brace-format
msgid ""
"The :meth:`str.format` method of strings requires more manual effort.  "
"You'll still use ``{`` and ``}`` to mark where a variable will be "
"substituted and can provide detailed formatting directives, but you'll "
"also need to provide the information to be formatted. In the following "
"code block there are two examples of how to format variables:"
msgstr ""
"문자열의 :meth:`str.format` 메서드는 더 많은 수작업을 요구합니다. 변수가 대체 될 위치를 표시하기 위해 ``{`` "
"및 ``}``\\를 여전히 사용하고, 자세한 포매팅 디렉티브를 제공할 수 있지만, 포맷할 정보도 제공해야 합니다."

#: ../../tutorial/inputoutput.rst:46
#, python-brace-format
msgid ""
">>> yes_votes = 42_572_654\n"
">>> total_votes = 85_705_149\n"
">>> percentage = yes_votes / total_votes\n"
">>> '{:-9} YES votes  {:2.2%}'.format(yes_votes, percentage)\n"
"' 42572654 YES votes  49.67%'"
msgstr ""

#: ../../tutorial/inputoutput.rst:52
msgid ""
"Notice how the ``yes_votes`` are padded with spaces and a negative sign "
"only for negative numbers. The example also prints ``percentage`` "
"multiplied by 100, with 2 decimal places and followed by a percent sign "
"(see :ref:`formatspec` for details)."
msgstr ""

#: ../../tutorial/inputoutput.rst:57
msgid ""
"Finally, you can do all the string handling yourself by using string "
"slicing and concatenation operations to create any layout you can "
"imagine.  The string type has some methods that perform useful operations"
" for padding strings to a given column width."
msgstr ""
"마지막으로, 문자열 슬라이싱 및 이어붙이기 연산을 사용하여 상상할 수 있는 모든 배치를 만듦으로써, 모든 문자열 처리를 스스로 "
"수행할 수 있습니다. 문자열형에는 주어진 열 너비로 문자열을 채우는 데 유용한 연산을 수행하는 몇 가지 메서드가 있습니다."

#: ../../tutorial/inputoutput.rst:62
msgid ""
"When you don't need fancy output but just want a quick display of some "
"variables for debugging purposes, you can convert any value to a string "
"with the :func:`repr` or :func:`str` functions."
msgstr ""
"장식적인 출력이 필요하지 않고 단지 디버깅을 위해 일부 변수를 빠르게 표시하려면, :func:`repr` 또는 :func:`str`"
" 함수를 사용하여 모든 값을 문자열로 변환할 수 있습니다."

#: ../../tutorial/inputoutput.rst:66
msgid ""
"The :func:`str` function is meant to return representations of values "
"which are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a "
":exc:`SyntaxError` if there is no equivalent syntax).  For objects which "
"don't have a particular representation for human consumption, :func:`str`"
" will return the same value as :func:`repr`.  Many values, such as "
"numbers or structures like lists and dictionaries, have the same "
"representation using either function.  Strings, in particular, have two "
"distinct representations."
msgstr ""
":func:`str` 함수는 어느 정도 사람이 읽기에 적합한 형태로 값의 표현을 돌려주게 되어있습니다. 반면에 "
":func:`repr` 은 인터프리터에 의해 읽힐 수 있는 형태를 만들게 되어있습니다 (또는 그렇게 표현할 수 있는 문법이 없으면 "
":exc:`SyntaxError` 를 일으키도록 구성됩니다). 사람이 소비하기 위한 특별한 표현이 없는 객체의 경우, "
":func:`str` 는 :func:`repr` 과 같은 값을 돌려줍니다. 많은 값, 숫자들이나 리스트와 딕셔너리와 같은 구조들, "
"은 두 함수를 쓸 때 같은 표현을 합니다. 특별히, 문자열은 두 가지 표현을 합니다."

#: ../../tutorial/inputoutput.rst:75
msgid "Some examples::"
msgstr "몇 가지 예를 듭니다::"

#: ../../tutorial/inputoutput.rst:77
msgid ""
">>> s = 'Hello, world.'\n"
">>> str(s)\n"
"'Hello, world.'\n"
">>> repr(s)\n"
"\"'Hello, world.'\"\n"
">>> str(1/7)\n"
"'0.14285714285714285'\n"
">>> x = 10 * 3.25\n"
">>> y = 200 * 200\n"
">>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'\n"
">>> print(s)\n"
"The value of x is 32.5, and y is 40000...\n"
">>> # The repr() of a string adds string quotes and backslashes:\n"
">>> hello = 'hello, world\\n'\n"
">>> hellos = repr(hello)\n"
">>> print(hellos)\n"
"'hello, world\\n'\n"
">>> # The argument to repr() may be any Python object:\n"
">>> repr((x, y, ('spam', 'eggs')))\n"
"\"(32.5, 40000, ('spam', 'eggs'))\""
msgstr ""

#: ../../tutorial/inputoutput.rst:98
msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class that "
"offers yet another way to substitute values into strings, using "
"placeholders like ``$x`` and replacing them with values from a "
"dictionary, but offers much less control of the formatting."
msgstr ""
":mod:`string` 모듈에는 문자열에 값을 치환하는 또 다른 방법을 제공하는 :class:`~string.Template` "
"클래스가 포함되어 있습니다. ``$x``\\와 같은 자리 표시자를 사용하고 이것들을 딕셔너리에서 오는 값으로 치환하지만, 포매팅에 "
"대한 제어를 훨씬 덜 제공합니다."

#: ../../tutorial/inputoutput.rst:114
msgid "Formatted String Literals"
msgstr "포맷 문자열 리터럴"

#: ../../tutorial/inputoutput.rst:116
#, python-brace-format
msgid ""
":ref:`Formatted string literals <f-strings>` (also called f-strings for "
"short) let you include the value of Python expressions inside a string by"
" prefixing the string with ``f`` or ``F`` and writing expressions as "
"``{expression}``."
msgstr ""
":ref:`포맷 문자열 리터럴 <f-strings>`\\(간단히 f-문자열이라고도 합니다)은 문자열에 ``f`` 또는 ``F`` "
"접두어를 붙이고 표현식을 ``{expression}``\\로 작성하여 문자열에 파이썬 표현식의 값을 삽입할 수 있게 합니다."

#: ../../tutorial/inputoutput.rst:121
msgid ""
"An optional format specifier can follow the expression. This allows "
"greater control over how the value is formatted. The following example "
"rounds pi to three places after the decimal::"
msgstr ""
"선택적인 포맷 지정자가 표현식 뒤에 올 수 있습니다. 이것으로 값이 포맷되는 방식을 더 정교하게 제어할 수 있습니다. 다음 예는 "
"원주율을 소수점 이하 세 자리로 반올림합니다."

#: ../../tutorial/inputoutput.rst:125
#, python-brace-format
msgid ""
">>> import math\n"
">>> print(f'The value of pi is approximately {math.pi:.3f}.')\n"
"The value of pi is approximately 3.142."
msgstr ""

#: ../../tutorial/inputoutput.rst:129
msgid ""
"Passing an integer after the ``':'`` will cause that field to be a "
"minimum number of characters wide.  This is useful for making columns "
"line up. ::"
msgstr "``':'`` 뒤에 정수를 전달하면 해당 필드의 최소 문자 폭이 됩니다. 열을 줄 맞춤할 때 편리합니다. ::"

#: ../../tutorial/inputoutput.rst:132
#, python-brace-format
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}\n"
">>> for name, phone in table.items():\n"
"...     print(f'{name:10} ==> {phone:10d}')\n"
"...\n"
"Sjoerd     ==>       4127\n"
"Jack       ==>       4098\n"
"Dcab       ==>       7678"
msgstr ""

#: ../../tutorial/inputoutput.rst:140
msgid ""
"Other modifiers can be used to convert the value before it is formatted. "
"``'!a'`` applies :func:`ascii`, ``'!s'`` applies :func:`str`, and "
"``'!r'`` applies :func:`repr`::"
msgstr ""
"다른 수정자를 사용하면 포맷되기 전에 값을 변환할 수 있습니다. ``'!a'``\\는 :func:`ascii`\\를, "
"``'!s'``\\는 :func:`str`\\을, ``'!r'``\\는 :func:`repr`\\을 적용합니다.::"

#: ../../tutorial/inputoutput.rst:144
#, python-brace-format
msgid ""
">>> animals = 'eels'\n"
">>> print(f'My hovercraft is full of {animals}.')\n"
"My hovercraft is full of eels.\n"
">>> print(f'My hovercraft is full of {animals!r}.')\n"
"My hovercraft is full of 'eels'."
msgstr ""

#: ../../tutorial/inputoutput.rst:150
msgid ""
"The ``=`` specifier can be used to expand an expression to the text of "
"the expression, an equal sign, then the representation of the evaluated "
"expression:"
msgstr ""

#: ../../tutorial/inputoutput.rst:159
#, fuzzy
msgid ""
"See :ref:`self-documenting expressions <bpo-36817-whatsnew>` for more "
"information on the ``=`` specifier. For a reference on these format "
"specifications, see the reference guide for the :ref:`formatspec`."
msgstr "이러한 포맷 사양에 대한 레퍼런스는 :ref:`formatspec`\\에 대한 레퍼런스 지침서를 참조하십시오."

#: ../../tutorial/inputoutput.rst:166
msgid "The String format() Method"
msgstr "문자열 format() 메서드"

#: ../../tutorial/inputoutput.rst:168
msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr ":meth:`str.format` 메서드의 기본적인 사용법은 이런 식입니다::"

#: ../../tutorial/inputoutput.rst:170
#, python-brace-format
msgid ""
">>> print('We are the {} who say \"{}!\"'.format('knights', 'Ni'))\n"
"We are the knights who say \"Ni!\""
msgstr ""

#: ../../tutorial/inputoutput.rst:173
msgid ""
"The brackets and characters within them (called format fields) are "
"replaced with the objects passed into the :meth:`str.format` method.  A "
"number in the brackets can be used to refer to the position of the object"
" passed into the :meth:`str.format` method. ::"
msgstr ""
"중괄호와 그 안에 있는 문자들 (포맷 필드라고 부른다) 은 :meth:`str.format` 메서드로 전달된 객체들로 치환됩니다. "
"중괄호 안의 숫자는 :meth:`str.format` 메서드로 전달된 객체들의 위치를 가리키는데 사용될 수 있습니다. ::"

#: ../../tutorial/inputoutput.rst:178
#, python-brace-format
msgid ""
">>> print('{0} and {1}'.format('spam', 'eggs'))\n"
"spam and eggs\n"
">>> print('{1} and {0}'.format('spam', 'eggs'))\n"
"eggs and spam"
msgstr ""

#: ../../tutorial/inputoutput.rst:183
msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their "
"values are referred to by using the name of the argument. ::"
msgstr ":meth:`str.format` 메서드에 키워드 인자가 사용되면, 그 값들은 인자의 이름을 사용해서 지정할 수 있습니다. ::"

#: ../../tutorial/inputoutput.rst:186
#, python-brace-format
msgid ""
">>> print('This {food} is {adjective}.'.format(\n"
"...       food='spam', adjective='absolutely horrible'))\n"
"This spam is absolutely horrible."
msgstr ""

#: ../../tutorial/inputoutput.rst:190
msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr "위치와 키워드 인자를 자유롭게 조합할 수 있습니다::"

#: ../../tutorial/inputoutput.rst:192
#, python-brace-format
msgid ""
">>> print('The story of {0}, {1}, and {other}.'.format('Bill', 'Manfred',"
"\n"
"...                                                    other='Georg'))\n"
"The story of Bill, Manfred, and Georg."
msgstr ""

#: ../../tutorial/inputoutput.rst:196
msgid ""
"If you have a really long format string that you don't want to split up, "
"it would be nice if you could reference the variables to be formatted by "
"name instead of by position.  This can be done by simply passing the dict"
" and using square brackets ``'[]'`` to access the keys. ::"
msgstr ""
"나누고 싶지 않은 정말 긴 포맷 문자열이 있을 때, 포맷할 변수들을 위치 대신에 이름으로 지정할 수 있다면 좋을 것입니다. 간단히 "
"딕셔너리를 넘기고 키를 액세스하는데 대괄호 ``'[]'`` 를 사용하면 됩니다. ::"

#: ../../tutorial/inputoutput.rst:201
#, python-brace-format
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {0[Jack]:d}; Sjoerd: {0[Sjoerd]:d}; '\n"
"...       'Dcab: {0[Dcab]:d}'.format(table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"
msgstr ""

#: ../../tutorial/inputoutput.rst:206
#, fuzzy
msgid ""
"This could also be done by passing the ``table`` dictionary as keyword "
"arguments with the ``**`` notation. ::"
msgstr "'**' 표기법을 사용해서 table을 키워드 인자로 전달해도 같은 결과를 얻을 수 있습니다. ::"

#: ../../tutorial/inputoutput.rst:209
#, python-brace-format
msgid ""
">>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}\n"
">>> print('Jack: {Jack:d}; Sjoerd: {Sjoerd:d}; Dcab: "
"{Dcab:d}'.format(**table))\n"
"Jack: 4098; Sjoerd: 4127; Dcab: 8637678"
msgstr ""

#: ../../tutorial/inputoutput.rst:213
#, fuzzy
msgid ""
"This is particularly useful in combination with the built-in function "
":func:`vars`, which returns a dictionary containing all local variables::"
msgstr "이 방법은 모든 지역 변수들을 담은 딕셔너리를 돌려주는 내장 함수 :func:`vars` 와 함께 사용할 때 특히 쓸모가 있습니다. "

#: ../../tutorial/inputoutput.rst:216
#, python-brace-format
msgid ""
">>> table = {k: str(v) for k, v in vars().items()}\n"
">>> message = \" \".join([f'{k}: ' + '{' + k +'};' for k in "
"table.keys()])\n"
">>> print(message.format(**table))\n"
"__name__: __main__; __doc__: None; __package__: None; __loader__: ..."
msgstr ""

#: ../../tutorial/inputoutput.rst:221
#, fuzzy
msgid ""
"As an example, the following lines produce a tidily aligned set of "
"columns giving integers and their squares and cubes::"
msgstr "예를 들어, 다음 줄은 정수와 그 제곱과 세제곱을 제공하는 빽빽하게 정렬된 열 집합을 생성합니다::"

#: ../../tutorial/inputoutput.rst:224
#, python-brace-format
msgid ""
">>> for x in range(1, 11):\n"
"...     print('{0:2d} {1:3d} {2:4d}'.format(x, x*x, x*x*x))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000"
msgstr ""

#: ../../tutorial/inputoutput.rst:238
msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see"
" :ref:`formatstrings`."
msgstr ":meth:`str.format` 를 사용한 문자열 포매팅의 완전한 개요는 :ref:`formatstrings` 을 보세요."

#: ../../tutorial/inputoutput.rst:243
msgid "Manual String Formatting"
msgstr "수동 문자열 포매팅"

#: ../../tutorial/inputoutput.rst:245
msgid "Here's the same table of squares and cubes, formatted manually::"
msgstr "여기 같은 제곱수와 세제곱수 표를 수동으로 포매팅했습니다::"

#: ../../tutorial/inputoutput.rst:247
msgid ""
">>> for x in range(1, 11):\n"
"...     print(repr(x).rjust(2), repr(x*x).rjust(3), end=' ')\n"
"...     # Note use of 'end' on previous line\n"
"...     print(repr(x*x*x).rjust(4))\n"
"...\n"
" 1   1    1\n"
" 2   4    8\n"
" 3   9   27\n"
" 4  16   64\n"
" 5  25  125\n"
" 6  36  216\n"
" 7  49  343\n"
" 8  64  512\n"
" 9  81  729\n"
"10 100 1000"
msgstr ""

#: ../../tutorial/inputoutput.rst:263
msgid ""
"(Note that the one space between each column was added by the way "
":func:`print` works: it always adds spaces between its arguments.)"
msgstr ""
"(:func:`print` 의 동작 방식으로 인해 각 칼럼 사이에 스페이스 하나가 추가되었음에 유의하세요: 항상 인자들 사이에 "
"스페이스를 추가합니다.)"

#: ../../tutorial/inputoutput.rst:266
msgid ""
"The :meth:`str.rjust` method of string objects right-justifies a string "
"in a field of a given width by padding it with spaces on the left. There "
"are similar methods :meth:`str.ljust` and :meth:`str.center`. These "
"methods do not write anything, they just return a new string. If the "
"input string is too long, they don't truncate it, but return it "
"unchanged; this will mess up your column lay-out but that's usually "
"better than the alternative, which would be lying about a value. (If you "
"really want truncation you can always add a slice operation, as in "
"``x.ljust(n)[:n]``.)"
msgstr ""
"문자열 객체의 :meth:`str.rjust` 메서드는 왼쪽에 스페이스를 채워서 주어진 폭으로 문자열을 우측 줄 맞춤합니다. 비슷한"
" 메서드 :meth:`str.ljust` 와 :meth:`str.center` 도 있습니다. 이 메서드들은 어떤 것도 출력하지 "
"않습니다, 단지 새 문자열을 돌려줍니다. 입력 문자열이 너무 길면, 자르지 않고, 변경 없이 그냥 돌려줍니다; 이것이 열 배치를 "
"엉망으로 만들겠지만, 보통 값에 대해 거짓말을 하게 될 대안보다는 낫습니다. (정말로 잘라내기를 원한다면, 항상 슬라이스 연산을 "
"추가할 수 있습니다, ``x.ljust(n)[:n]`` 처럼.)"

#: ../../tutorial/inputoutput.rst:275
msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string "
"on the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"다른 메서드도 있습니다, :meth:`str.zfill`. 숫자 문자열의 왼쪽에 0을 채웁니다. 플러스와 마이너스 부호도 "
"이해합니다:: "

#: ../../tutorial/inputoutput.rst:278
msgid ""
">>> '12'.zfill(5)\n"
"'00012'\n"
">>> '-3.14'.zfill(7)\n"
"'-003.14'\n"
">>> '3.14159265359'.zfill(5)\n"
"'3.14159265359'"
msgstr ""

#: ../../tutorial/inputoutput.rst:287
msgid "Old string formatting"
msgstr "예전의 문자열 포매팅"

#: ../../tutorial/inputoutput.rst:289
#, fuzzy, python-format
msgid ""
"The % operator (modulo) can also be used for string formatting. Given "
"``format % values`` (where *format* is a string), ``%`` conversion "
"specifications in *format* are replaced with zero or more elements of "
"*values*. This operation is commonly known as string interpolation. For "
"example::"
msgstr ""
"% 연산자(모듈로)는 문자열 포매팅에도 사용할 수 있습니다. ``'string' % values``\\가 주어지면, "
"``string``\\에 있는 ``%`` 인스턴스는 0개 이상의 ``values`` 요소로 대체됩니다. 이 연산을 흔히 문자열 "
"보간(interpolation)이라고 합니다. 예를 들면::"

#: ../../tutorial/inputoutput.rst:296
#, python-format
msgid ""
">>> import math\n"
">>> print('The value of pi is approximately %5.3f.' % math.pi)\n"
"The value of pi is approximately 3.142."
msgstr ""

#: ../../tutorial/inputoutput.rst:300
msgid "More information can be found in the :ref:`old-string-formatting` section."
msgstr "더 자세한 내용은 :ref:`old-string-formatting` 섹션에 나옵니다."

#: ../../tutorial/inputoutput.rst:306
msgid "Reading and Writing Files"
msgstr "파일을 읽고 쓰기"

#: ../../tutorial/inputoutput.rst:312
#, fuzzy
msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used "
"with two positional arguments and one keyword argument: ``open(filename, "
"mode, encoding=None)``"
msgstr ""
":func:`open` 은 :term:`파일 객체 <file object>` 를 돌려주고, 두 개의 인자를 주는 방식이 가장 많이 "
"사용됩니다: ``open(filename, mode)``."

#: ../../tutorial/inputoutput.rst:318
msgid ">>> f = open('workfile', 'w', encoding=\"utf-8\")"
msgstr ""

#: ../../tutorial/inputoutput.rst:325
msgid ""
"The first argument is a string containing the filename.  The second "
"argument is another string containing a few characters describing the way"
" in which the file will be used.  *mode* can be ``'r'`` when the file "
"will only be read, ``'w'`` for only writing (an existing file with the "
"same name will be erased), and ``'a'`` opens the file for appending; any "
"data written to the file is automatically added to the end.  ``'r+'`` "
"opens the file for both reading and writing. The *mode* argument is "
"optional; ``'r'`` will be assumed if it's omitted."
msgstr ""
"첫 번째 인자는 파일 이름을 담은 문자열입니다. 두 번째 인자는 파일이 사용될 방식을 설명하는 몇 개의 문자들을 담은 또 하나의 "
"문자열입니다. *mode* 는 파일을 읽기만 하면 ``'r'``, 쓰기만 하면 ``'w'`` (같은 이름의 이미 존재하는 파일은 "
"삭제됩니다) 가 되고, ``'a'`` 는 파일을 덧붙이기 위해 엽니다; 파일에 기록되는 모든 데이터는 자동으로 끝에 붙습니다. "
"``'r+'`` 는 파일을 읽고 쓰기 위해 엽니다. *mode* 인자는 선택적인데, 생략하면 ``'r'`` 이 가정됩니다."

#: ../../tutorial/inputoutput.rst:334
#, fuzzy
msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"*encoding*. If *encoding* is not specified, the default is platform "
"dependent (see :func:`open`). Because UTF-8 is the modern de-facto "
"standard, ``encoding=\"utf-8\"`` is recommended unless you know that you "
"need to use a different encoding. Appending a ``'b'`` to the mode opens "
"the file in :dfn:`binary mode`. Binary mode data is read and written as "
":class:`bytes` objects. You can not specify *encoding* when opening file "
"in binary mode."
msgstr ""
"보통, 파일은 :dfn:`텍스트 모드 (text mode)` 로 열리는데, 이 뜻은, 파일에 문자열을 읽고 쓰고, 파일에는 특정한 "
"인코딩으로 저장된다는 것입니다. 인코딩이 지정되지 않으면 기본값은 플랫폼 의존적입니다 (:func:`open` 을 보세요). "
"mode 에 덧붙여진 ``'b'`` 는 파일을 :dfn:`바이너리 모드 (binary mode)` 로 엽니다: 이제 데이터는 "
"바이트열 객체의 형태로 읽고 쓰입니다. 텍스트를 포함하지 않는 모든 파일에는 이 모드를 사용해야 합니다."

#: ../../tutorial/inputoutput.rst:344
msgid ""
"In text mode, the default when reading is to convert platform-specific "
"line endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  "
"When writing in text mode, the default is to convert occurrences of "
"``\\n`` back to platform-specific line endings.  This behind-the-scenes "
"modification to file data is fine for text files, but will corrupt binary"
" data like that in :file:`JPEG` or :file:`EXE` files.  Be very careful to"
" use binary mode when reading and writing such files."
msgstr ""
"텍스트 모드에서, 읽을 때의 기본 동작은 플랫폼 의존적인 줄 종료 (유닉스에서 ``\\n``, 윈도우에서 ``\\r\\n``) 를 "
"단지 ``\\n`` 로 변경하는 것입니다. 텍스트 모드로 쓸 때, 기본 동작은 ``\\n`` 를 다시 플랫폼 의존적인 줄 종료로 "
"변환하는 것입니다. 이 파일 데이터에 대한 무대 뒤의 수정은 텍스트 파일의 경우는 문제가 안 되지만, :file:`JPEG` 이나 "
":file:`EXE` 파일과 같은 바이너리 데이터를 망치게 됩니다. 그런 파일을 읽고 쓸 때 바이너리 모드를 사용하도록 주의하세요."

#: ../../tutorial/inputoutput.rst:352
msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after "
"its suite finishes, even if an exception is raised at some point.  Using "
":keyword:`!with` is also much shorter than writing equivalent "
":keyword:`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"파일 객체를 다룰 때 :keyword:`with` 키워드를 사용하는 것은 좋은 습관입니다. 혜택은 도중 예외가 발생하더라도 스위트가"
" 종료될 때 파일이 올바르게 닫힌다는 것입니다. :keyword:`!with` 를 사용하는 것은 동등한 "
":keyword:`try`\\ -\\ :keyword:`finally` 블록을 쓰는 것에 비교해 훨씬 짧기도 합니다::"

#: ../../tutorial/inputoutput.rst:358
msgid ""
">>> with open('workfile', encoding=\"utf-8\") as f:\n"
"...     read_data = f.read()\n"
"\n"
">>> # We can check that the file has been automatically closed.\n"
">>> f.closed\n"
"True"
msgstr ""

#: ../../tutorial/inputoutput.rst:365
msgid ""
"If you're not using the :keyword:`with` keyword, then you should call "
"``f.close()`` to close the file and immediately free up any system "
"resources used by it."
msgstr ""
":keyword:`with` 키워드를 사용하지 않으면, ``f.close()`` 를 호출해서 파일을 닫고 사용된 시스템 자원을 즉시"
" 반납해야 합니다."

#: ../../tutorial/inputoutput.rst:370
msgid ""
"Calling ``f.write()`` without using the :keyword:`!with` keyword or "
"calling ``f.close()`` **might** result in the arguments of ``f.write()`` "
"not being completely written to the disk, even if the program exits "
"successfully."
msgstr ""
":keyword:`!with` 키워드를 사용하거나 ``f.close()``\\를 호출하지 않고 ``f.write()``\\를 "
"호출하면 프로그램이 성공적으로 종료되더라도 ``f.write()``\\의 인자가 디스크에 완전히 기록되지 않을 **수** 있습니다."

#: ../../tutorial/inputoutput.rst:378
msgid ""
"After a file object is closed, either by a :keyword:`with` statement or "
"by calling ``f.close()``, attempts to use the file object will "
"automatically fail. ::"
msgstr ""
"파일 객체가 닫힌 후에는, :keyword:`with` 문이나 ``f.close()`` 를 호출하는 경우 모두, 파일 객체를 "
"사용하려는 시도는 자동으로 실패합니다. ::"

#: ../../tutorial/inputoutput.rst:382
msgid ""
">>> f.close()\n"
">>> f.read()\n"
"Traceback (most recent call last):\n"
"  File \"<stdin>\", line 1, in <module>\n"
"ValueError: I/O operation on closed file."
msgstr ""

#: ../../tutorial/inputoutput.rst:392
msgid "Methods of File Objects"
msgstr "파일 객체의 매소드"

#: ../../tutorial/inputoutput.rst:394
msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr "이 섹션의 나머지 예들은 ``f`` 라는 파일 객체가 이미 만들어졌다고 가정합니다."

#: ../../tutorial/inputoutput.rst:397
msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some "
"quantity of data and returns it as a string (in text mode) or bytes "
"object (in binary mode). *size* is an optional numeric argument.  When "
"*size* is omitted or negative, the entire contents of the file will be "
"read and returned; it's your problem if the file is twice as large as "
"your machine's memory. Otherwise, at most *size* characters (in text "
"mode) or *size* bytes (in binary mode) are read and returned. If the end "
"of the file has been reached, ``f.read()`` will return an empty string "
"(``''``).  ::"
msgstr ""
"파일의 내용을 읽으려면, ``f.read(size)`` 를 호출하는데, 일정량의 데이터를 읽고 문자열 (텍스트 모드 에서) 이나 "
"바이트열 (바이너리 모드에서) 로 돌려줍니다. *size* 는 선택적인 숫자 인자입니다. *size* 가 생략되거나 음수면 파일의 "
"내용 전체를 읽어서 돌려줍니다; 파일의 크기가 기계의 메모리보다 두 배 크다면 여러분이 감당할 문제입니다. 그렇지 않으면 최대 "
"*size* 문자(텍스트 모드에서)나 *size* 바이트(바이너리 모드에서)를 읽고 돌려줍니다. 파일의 끝에 도달하면, "
"``f.read()`` 는 빈 문자열 (``''``) 을 돌려줍니다. ::"

#: ../../tutorial/inputoutput.rst:406
msgid ""
">>> f.read()\n"
"'This is the entire file.\\n'\n"
">>> f.read()\n"
"''"
msgstr ""

#: ../../tutorial/inputoutput.rst:411
msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the "
"last line of the file if the file doesn't end in a newline.  This makes "
"the return value unambiguous; if ``f.readline()`` returns an empty "
"string, the end of the file has been reached, while a blank line is "
"represented by ``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` 은 파일에서 한 줄을 읽습니다; 개행 문자 (``\\n``) 는 문자열의 끝에 보존되고, 파일이 "
"개행문자로 끝나지 않는 때에만 파일의 마지막 줄에서만 생략됩니다. 이렇게 반환 값을 모호하지 않게 만듭니다; "
"``f.readline()`` 가 빈 문자열을 돌려주면, 파일의 끝에 도달한 것이지만, 빈 줄은 ``'\\n'``, 즉 하나의 "
"개행문자만을 포함하는 문자열로 표현됩니다. ::"

#: ../../tutorial/inputoutput.rst:418
msgid ""
">>> f.readline()\n"
"'This is the first line of the file.\\n'\n"
">>> f.readline()\n"
"'Second line of the file\\n'\n"
">>> f.readline()\n"
"''"
msgstr ""

#: ../../tutorial/inputoutput.rst:425
msgid ""
"For reading lines from a file, you can loop over the file object. This is"
" memory efficient, fast, and leads to simple code::"
msgstr "파일에서 줄들을 읽으려면, 파일 객체에 대해 루핑할 수 있습니다. 이것은 메모리 효율적이고, 빠르며 간단한 코드로 이어집니다::"

#: ../../tutorial/inputoutput.rst:428
msgid ""
">>> for line in f:\n"
"...     print(line, end='')\n"
"...\n"
"This is the first line of the file.\n"
"Second line of the file"
msgstr ""

#: ../../tutorial/inputoutput.rst:434
msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr "파일의 모든 줄을 리스트로 읽어 들이려면 ``list(f)`` 나 ``f.readlines()`` 를 쓸 수 있습니다."

#: ../../tutorial/inputoutput.rst:437
msgid ""
"``f.write(string)`` writes the contents of *string* to the file, "
"returning the number of characters written. ::"
msgstr "``f.write(string)`` 은 *string* 의 내용을 파일에 쓰고, 출력된 문자들의 개수를 돌려줍니다."

#: ../../tutorial/inputoutput.rst:440
msgid ""
">>> f.write('This is a test\\n')\n"
"15"
msgstr ""

#: ../../tutorial/inputoutput.rst:443
msgid ""
"Other types of objects need to be converted -- either to a string (in "
"text mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"다른 형의 객체들은 쓰기 전에 변환될 필요가 있습니다 -- 문자열 (텍스트 모드에서) 이나 바이트열 객체 (바이너리 모드에서) 로 "
"--::"

#: ../../tutorial/inputoutput.rst:446
msgid ""
">>> value = ('the answer', 42)\n"
">>> s = str(value)  # convert the tuple to string\n"
">>> f.write(s)\n"
"18"
msgstr ""

#: ../../tutorial/inputoutput.rst:451
msgid ""
"``f.tell()`` returns an integer giving the file object's current position"
" in the file represented as number of bytes from the beginning of the "
"file when in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` 은 파일의 현재 위치를 가리키는 정수를 돌려주는데, 바이너리 모드의 경우 파일의 처음부터의 바이트 수로 "
"표현되고 텍스트 모드의 경우는 불투명한 숫자입니다."

#: ../../tutorial/inputoutput.rst:455
msgid ""
"To change the file object's position, use ``f.seek(offset, whence)``.  "
"The position is computed from adding *offset* to a reference point; the "
"reference point is selected by the *whence* argument.  A *whence* value "
"of 0 measures from the beginning of the file, 1 uses the current file "
"position, and 2 uses the end of the file as the reference point.  "
"*whence* can be omitted and defaults to 0, using the beginning of the "
"file as the reference point. ::"
msgstr ""
"파일 객체의 위치를 바꾸려면, ``f.seek(offset, whence)`` 를 사용합니다. 위치는 기준점에 *offset* 을 "
"더해서 계산됩니다; 기준점은 *whence* 인자로 선택합니다. *whence* 값이 0이면 파일의 처음부터 측정하고, 1이면 현재"
" 파일 위치를 사용하고, 2 는 파일의 끝을 기준점으로 사용합니다. *whence* 는 생략될 수 있고, 기본값은 0이라서 파일의 "
"처음을 기준점으로 사용합니다. ::"

#: ../../tutorial/inputoutput.rst:462
msgid ""
">>> f = open('workfile', 'rb+')\n"
">>> f.write(b'0123456789abcdef')\n"
"16\n"
">>> f.seek(5)      # Go to the 6th byte in the file\n"
"5\n"
">>> f.read(1)\n"
"b'5'\n"
">>> f.seek(-3, 2)  # Go to the 3rd byte before the end\n"
"13\n"
">>> f.read(1)\n"
"b'd'"
msgstr ""

#: ../../tutorial/inputoutput.rst:474
msgid ""
"In text files (those opened without a ``b`` in the mode string), only "
"seeks relative to the beginning of the file are allowed (the exception "
"being seeking to the very file end with ``seek(0, 2)``) and the only "
"valid *offset* values are those returned from the ``f.tell()``, or zero. "
"Any other *offset* value produces undefined behaviour."
msgstr ""
"텍스트 파일에서는 (모드 문자열에 ``b`` 가 없이 열린 것들), 파일의 시작에 상대적인 위치 변경만 허락되고 (예외는 "
"``seek(0, 2)`` 를 사용해서 파일의 끝으로 위치를 변경하는 경우입니다), 올바른 *offset* 값은 "
"``f.tell()`` 이 돌려준 값과 0뿐입니다. 그 밖의 다른 *offset* 값은 정의되지 않은 결과를 낳습니다."

#: ../../tutorial/inputoutput.rst:480
#, fuzzy
msgid ""
"File objects have some additional methods, such as "
":meth:`~io.IOBase.isatty` and :meth:`~io.IOBase.truncate` which are less "
"frequently used; consult the Library Reference for a complete guide to "
"file objects."
msgstr ""
"파일 객체는 :meth:`~file.isatty` 나 :meth:`~file.truncate` 같은 몇 가지 메서드를 더 갖고 "
"있는데, 덜 자주 사용됩니다; 파일 객체에 대한 완전한 안내는 라이브러리 레퍼런스를 참조하세요."

#: ../../tutorial/inputoutput.rst:488
msgid "Saving structured data with :mod:`json`"
msgstr ":mod:`json` 으로 구조적인 데이터를 저장하기"

#: ../../tutorial/inputoutput.rst:492
#, fuzzy
msgid ""
"Strings can easily be written to and read from a file.  Numbers take a "
"bit more effort, since the :meth:`~io.TextIOBase.read` method only "
"returns strings, which will have to be passed to a function like "
":func:`int`, which takes a string like ``'123'`` and returns its numeric "
"value 123.  When you want to save more complex data types like nested "
"lists and dictionaries, parsing and serializing by hand becomes "
"complicated."
msgstr ""
"문자열은 파일에 쉽게 읽고 쓸 수 있습니다. 숫자는 약간의 수고를 해야 하는데, :meth:`read` 메서드가 문자열만을 돌려주기"
" 때문입니다. 이 문자열을 :func:`int` 같은 함수로 전달해야만 하는데, ``'123'`` 같은 문자열을 받고 숫자 값 "
"123을 돌려줍니다. 중첩된 리스트나 딕셔너리 같은 더 복잡한 데이터를 저장하려고 할 때, 수작업으로 파싱하고 직렬화하는 것이 "
"까다로울 수 있습니다."

#: ../../tutorial/inputoutput.rst:499
#, fuzzy
msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular "
"data interchange format called `JSON (JavaScript Object Notation) "
"<https://json.org>`_.  The standard module called :mod:`json` can take "
"Python data hierarchies, and convert them to string representations; this"
" process is called :dfn:`serializing`.  Reconstructing the data from the "
"string representation is called :dfn:`deserializing`.  Between "
"serializing and deserializing, the string representing the object may "
"have been stored in a file or data, or sent over a network connection to "
"some distant machine."
msgstr ""
"사용자가 반복적으로 복잡한 데이터형을 파일에 저장하는 코드를 작성하고 디버깅하도록 하는 대신, 파이썬은 `JSON "
"(JavaScript Object Notation) <http://json.org>`_ 이라는 널리 쓰이는 데이터 교환 형식을 "
"사용할 수 있게 합니다. :mod:`json` 이라는 표준 모듈은 파이썬 데이터 계층을 받아서 문자열 표현으로 바꿔줍니다; 이 "
"절차를 :dfn:`직렬화 (serializing)` 라고 부릅니다. 문자열 표현으로부터 데이터를 재구성하는 것은 :dfn:`역 "
"직렬화 (deserializing)` 라고 부릅니다. 직렬화와 역 직렬화 사이에서, 객체를 표현하는 문자열은 파일이나 데이터에 "
"저장되거나 네트워크 연결을 통해 원격 기계로 전송될 수 있습니다."

#: ../../tutorial/inputoutput.rst:510
msgid ""
"The JSON format is commonly used by modern applications to allow for data"
" exchange.  Many programmers are already familiar with it, which makes it"
" a good choice for interoperability."
msgstr ""
"JSON 형식은 데이터 교환을 위해 현대 응용 프로그램들이 자주 사용합니다. 많은 프로그래머가 이미 이것에 익숙하므로, 연동성을 "
"위한 좋은 선택이 됩니다."

#: ../../tutorial/inputoutput.rst:514
msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr "객체 ``x`` 가 있을 때, 간단한 한 줄의 코드로 그것의 JSON 문자열 표현을 볼 수 있습니다::"

#: ../../tutorial/inputoutput.rst:517
msgid ""
">>> import json\n"
">>> x = [1, 'simple', 'list']\n"
">>> json.dumps(x)\n"
"'[1, \"simple\", \"list\"]'"
msgstr ""

#: ../../tutorial/inputoutput.rst:522
msgid ""
"Another variant of the :func:`~json.dumps` function, called "
":func:`~json.dump`, simply serializes the object to a :term:`text file`."
"  So if ``f`` is a :term:`text file` object opened for writing, we can do"
" this::"
msgstr ""
":func:`~json.dump`\\라는 :func:`~json.dumps` 함수의 변종은 객체를 :term:`텍스트 파일 "
"<text file>` 로 직렬화합니다. 그래서 ``f`` 가 쓰기를 위해 열린 :term:`텍스트 파일 <text file>` "
"이면, 이렇게 할 수 있습니다::"

#: ../../tutorial/inputoutput.rst:526
msgid "json.dump(x, f)"
msgstr ""

#: ../../tutorial/inputoutput.rst:528
#, fuzzy
msgid ""
"To decode the object again, if ``f`` is a :term:`binary file` or "
":term:`text file` object which has been opened for reading::"
msgstr "객체를 다시 디코드하려면, ``f`` 가 읽기를 위해 열린 :term:`텍스트 파일 <text file>` 객체일 때::"

#: ../../tutorial/inputoutput.rst:531
msgid "x = json.load(f)"
msgstr ""

#: ../../tutorial/inputoutput.rst:534
msgid ""
"JSON files must be encoded in UTF-8. Use ``encoding=\"utf-8\"`` when "
"opening JSON file as a :term:`text file` for both of reading and writing."
msgstr ""

#: ../../tutorial/inputoutput.rst:537
msgid ""
"This simple serialization technique can handle lists and dictionaries, "
"but serializing arbitrary class instances in JSON requires a bit of extra"
" effort. The reference for the :mod:`json` module contains an explanation"
" of this."
msgstr ""
"이 간단한 직렬화 테크닉이 리스트와 딕셔너리를 다룰 수 있지만, 임의의 클래스 인스턴스를 JSON 으로 직렬화하기 위해서는 약간의 "
"수고가 더 필요합니다. :mod:`json` 모듈의 레퍼런스는 이 방법에 대한 설명을 담고 있습니다."

#: ../../tutorial/inputoutput.rst:543
msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - 피클 모듈"

#: ../../tutorial/inputoutput.rst:545
msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows "
"the serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: "
"deserializing pickle data coming from an untrusted source can execute "
"arbitrary code, if the data was crafted by a skilled attacker."
msgstr ""
":ref:`JSON <tut-json>` 에 반해, *pickle* 은 임의의 복잡한 파이썬 객체들을 직렬화할 수 있는 "
"프로토콜입니다. 파이썬에 국한되고 다른 언어로 작성된 응용 프로그램들과 통신하는데 사용될 수 없습니다. 기본적으로 안전하지 않기도 "
"합니다: 믿을 수 없는 소스에서 온 데이터를 역 직렬화할 때, 숙련된 공격자에 의해 데이터가 조작되었다면 임의의 코드가 실행될 수 "
"있습니다."

#: ../../tutorial/inputoutput.rst:103
#, fuzzy
msgid "formatted string literal"
msgstr "포맷 문자열 리터럴"

#: ../../tutorial/inputoutput.rst:103
#, fuzzy
msgid "interpolated string literal"
msgstr "포맷 문자열 리터럴"

#: ../../tutorial/inputoutput.rst:103
msgid "string"
msgstr ""

#: ../../tutorial/inputoutput.rst:103
#, fuzzy
msgid "formatted literal"
msgstr "포맷 문자열 리터럴"

#: ../../tutorial/inputoutput.rst:103
msgid "interpolated literal"
msgstr ""

#: ../../tutorial/inputoutput.rst:103
msgid "f-string"
msgstr ""

#: ../../tutorial/inputoutput.rst:103
msgid "fstring"
msgstr ""

#: ../../tutorial/inputoutput.rst:308
msgid "built-in function"
msgstr ""

#: ../../tutorial/inputoutput.rst:308
msgid "open"
msgstr ""

#: ../../tutorial/inputoutput.rst:308
msgid "object"
msgstr ""

#: ../../tutorial/inputoutput.rst:308
msgid "file"
msgstr ""

#: ../../tutorial/inputoutput.rst:490
msgid "module"
msgstr ""

#: ../../tutorial/inputoutput.rst:490
msgid "json"
msgstr ""

