# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/tutorial/inputoutput.rst:5
msgid "Input and Output"
msgstr "입력과 출력"

#: ../Doc/tutorial/inputoutput.rst:7
msgid ""
"There are several ways to present the output of a program; data can be "
"printed in a human-readable form, or written to a file for future use. "
"This chapter will discuss some of the possibilities."
msgstr ""
"프로그램의 출력을 표현하는 여러 가지 방법이 있다; 사람이 일기에 적합한 형태로 데이터를 인쇄할 수도 "
"있고, 나중에 사용하기 위해 파일에 쓸 수도 있다. 이 장에서는 몇 가지 가능성을 논한다."

#: ../Doc/tutorial/inputoutput.rst:15
msgid "Fancier Output Formatting"
msgstr "장식적인 출력 포매팅"

#: ../Doc/tutorial/inputoutput.rst:17
msgid ""
"So far we've encountered two ways of writing values: *expression "
"statements* and the :func:`print` function.  (A third way is using the "
":meth:`write` method of file objects; the standard output file can be "
"referenced as ``sys.stdout``. See the Library Reference for more "
"information on this.)"
msgstr ""
"지금까지 우리는 값을 쓰는 두 가지 방법을 만났다: *표현식 문장* 과 :func:`print` 함수다. "
"(세 번째 방법은 파일 객체의 :meth:`write` 메서드를 사용하는 것이다; 표준 출력 파일은 "
"``sys.stdout`` 로 참조할 수 있다. 이것에 대한 자세한 정보는 라이브러리 레퍼런스에 있다.)"

#: ../Doc/tutorial/inputoutput.rst:22
msgid ""
"Often you'll want more control over the formatting of your output than "
"simply printing space-separated values.  There are two ways to format "
"your output; the first way is to do all the string handling yourself; "
"using string slicing and concatenation operations you can create any "
"layout you can imagine.  The string type has some methods that perform "
"useful operations for padding strings to a given column width; these will"
" be discussed shortly.  The second way is to use :ref:`formatted string "
"literals <f-strings>`, or the :meth:`str.format` method."
msgstr ""
"종종 단순히 스페이스로 분리된 값들을 인쇄하기보다, 출력의 포맷을 좀 더 제어하고 싶기 마련이다. "
"출력을 포매팅하는 두 가지 방법이 있다; 첫 번째 방법은 여러분 스스로 모든 문자열 처리를 하는 것이다; "
"문자열 슬라이싱과 이어붙이기를 사용하면 여러분이 상상할 수 있는 어떤 배치라도 만들어 낼 수 있다. "
"문자열형은 문자열을 주어진 칼럼 폭으로 채워주는 편리한 연산들을 수행하는 메서드들을 제공한다; 이"
"것은 뒤에서 간단히 설명한다. 두 번째 방법은 :ref:`포맷 문자열 리터럴 <f-strings>` 이나 "
":meth:`str.format` 메서드를 사용하는 것이다."

#: ../Doc/tutorial/inputoutput.rst:31
msgid ""
"The :mod:`string` module contains a :class:`~string.Template` class which"
" offers yet another way to substitute values into strings."
msgstr ""
":mod:`string` 모듈은 :class:`~string.Template` 클래스를 포함하는데, 값을 문자열에 "
"치환하는 또 다른 방법을 제공한다."

#: ../Doc/tutorial/inputoutput.rst:34
msgid ""
"One question remains, of course: how do you convert values to strings? "
"Luckily, Python has ways to convert any value to a string: pass it to the"
" :func:`repr` or :func:`str` functions."
msgstr ""
"물론, 한가지 질문이 남아있다; 값을 어떻게 문자열로 변환하는가? 다행히도, 파이썬은 어떤 종류의 "
"값이라도 문자열로 변환하는 방법을 갖고 있다; 그 값을 :func:`repr` 나 :func:`str` 함수로 "
"전달한다."

#: ../Doc/tutorial/inputoutput.rst:38
msgid ""
"The :func:`str` function is meant to return representations of values "
"which are fairly human-readable, while :func:`repr` is meant to generate "
"representations which can be read by the interpreter (or will force a "
":exc:`SyntaxError` if there is no equivalent syntax).  For objects which "
"don't have a particular representation for human consumption, :func:`str`"
" will return the same value as :func:`repr`.  Many values, such as "
"numbers or structures like lists and dictionaries, have the same "
"representation using either function.  Strings, in particular, have two "
"distinct representations."
msgstr ""
":func:`str` 함수는 어느 정도 사람이 읽기에 적합한 형태로 값의 표현을 돌려주게 되어있다. "
"반면에 :func:`repr` 은 인터프리터에 의해 읽힐 수 있는 형태를 만들게 되어있다 (또는 그렇게 "
"표현할 수 있는 문법이 없으면 :exc:`SyntaxError` 를 일으키도록 구성된다). 사람이 "
"소비하기 위한 특별한 표현이 없는 객체의 경우, :func:`str` 는 :func:`repr` 과 같은 값을 "
"돌려준다. 많은 값, 숫자들이나 리스트와 딕셔너리와 같은 구조들, 은 두 함수를 쓸 때 같은 표현을 "
"한다. 특별히, 문자열은 두 가지 표현을 한다."

#: ../Doc/tutorial/inputoutput.rst:47
msgid "Some examples::"
msgstr "몇 가지 예를 든다::"

#: ../Doc/tutorial/inputoutput.rst:70
msgid "Here are two ways to write a table of squares and cubes::"
msgstr "여기 제곱수와 세제곱수의 표를 쓰는 두 가지 방법이 있다::"

#: ../Doc/tutorial/inputoutput.rst:102
msgid ""
"(Note that in the first example, one space between each column was added "
"by the way :func:`print` works: it always adds spaces between its "
"arguments.)"
msgstr ""
"(첫 번째 예에서, :func:`print` 의 동작 방식으로 인해 각 칼럼 사이에 스페이스 하나가 추가되었음에 "
"유의해야 한다; 항상 인자들 사이에 스페이스를 추가한다.)"

#: ../Doc/tutorial/inputoutput.rst:105
msgid ""
"This example demonstrates the :meth:`str.rjust` method of string objects,"
" which right-justifies a string in a field of a given width by padding it"
" with spaces on the left.  There are similar methods :meth:`str.ljust` "
"and :meth:`str.center`.  These methods do not write anything, they just "
"return a new string.  If the input string is too long, they don't "
"truncate it, but return it unchanged; this will mess up your column lay-"
"out but that's usually better than the alternative, which would be lying "
"about a value.  (If you really want truncation you can always add a slice"
" operation, as in ``x.ljust(n)[:n]``.)"
msgstr ""
"이 예는 문자열 객체의 :meth:`str.rjust` 메서드를 시연하는데, 왼쪽에 스페이스를 채워서 주어진 "
"폭으로 문자열을 우측 줄 맞춤한다. 비슷한 메서드 :meth:`str.ljust` 와 :meth:`str.center` "
"도 있다. 이 메서드들은 어떤 것도 출력하지 않는다, 단지 새 문자열을 돌려준다. 입력 문자열이 너무 길면, "
"자르지 않고, 변경 없이 그냥 돌려준다; 이것이 칼럼 배치를 엉망으로 만들겠지만, 보통 값에 대해 "
"거짓말을 하게 될 대안보다는 낫다. (정말로 잘라내기를 원한다면, 항상 슬라이스 연산을 추가할 수 있다, "
"``x.ljust(n)[:n]`` 처럼.)"

#: ../Doc/tutorial/inputoutput.rst:115
msgid ""
"There is another method, :meth:`str.zfill`, which pads a numeric string "
"on the left with zeros.  It understands about plus and minus signs::"
msgstr ""
"다른 메서드도 있다, :meth:`str.zfill`. 숫자 문자열의 왼쪽에 0을 채운다. 플러스와 마이너스 "
"부호도 이해한다:: "

#: ../Doc/tutorial/inputoutput.rst:125
msgid "Basic usage of the :meth:`str.format` method looks like this::"
msgstr ":meth:`str.format` 메서드의 기본적인 사용법은 이런 식이다::"

#: ../Doc/tutorial/inputoutput.rst:130
msgid ""
"The brackets and characters within them (called format fields) are "
"replaced with the objects passed into the :meth:`str.format` method.  A "
"number in the brackets can be used to refer to the position of the object"
" passed into the :meth:`str.format` method. ::"
msgstr ""
"중괄호와 그 안에 있는 문자들 (포맷 필드라고 부른다) 은 :meth:`str.format` 메서드로 전달된 "
"객체들로 치환된다. 중괄호 안의 숫자는 :meth:`str.format` 메서드로 전달된 객체들의 위치를 "
"가리키는데 사용될 수 있다. ::"

#: ../Doc/tutorial/inputoutput.rst:140
msgid ""
"If keyword arguments are used in the :meth:`str.format` method, their "
"values are referred to by using the name of the argument. ::"
msgstr ""
":meth:`str.format` 메서드에 키워드 인자가 사용되면, 그 값들은 인자의 이름을 사용해서 "
"지정할 수 있다. ::"

#: ../Doc/tutorial/inputoutput.rst:147
msgid "Positional and keyword arguments can be arbitrarily combined::"
msgstr "위치와 키워드 인자를 자유롭게 조합할 수 있다::"

#: ../Doc/tutorial/inputoutput.rst:153
msgid ""
"``'!a'`` (apply :func:`ascii`), ``'!s'`` (apply :func:`str`) and ``'!r'``"
" (apply :func:`repr`) can be used to convert the value before it is "
"formatted::"
msgstr ""
"``'!a'`` (:func:`ascii` 를 적용한다), ``'!s'`` (:func:`str` 을 적용한다), "
"``'!r'`` (:func:`repr` 을 적용한다) 은 포맷 전에 값을 변환하는 데 사용된다::"

#: ../Doc/tutorial/inputoutput.rst:162
msgid ""
"An optional ``':'`` and format specifier can follow the field name. This "
"allows greater control over how the value is formatted.  The following "
"example rounds Pi to three places after the decimal."
msgstr ""
"선택적인 ``':'`` 과 포맷 지정자가 필드 이름 뒤에 올 수 있다. 이것으로 값이 포맷되는 방식을 "
"더 정교하게 제어할 수 있다. 다음 예는 원주율을 소수점 이하 세 자리로 반올림한다."

#: ../Doc/tutorial/inputoutput.rst:170
msgid ""
"Passing an integer after the ``':'`` will cause that field to be a "
"minimum number of characters wide.  This is useful for making tables "
"pretty. ::"
msgstr ""
"``':'`` 뒤에 정수를 전달하면 해당 필드의 최소 문자 폭이 된다. 표를 예쁘게 만들 때 편리하다. ::"

#: ../Doc/tutorial/inputoutput.rst:181
msgid ""
"If you have a really long format string that you don't want to split up, "
"it would be nice if you could reference the variables to be formatted by "
"name instead of by position.  This can be done by simply passing the dict"
" and using square brackets ``'[]'`` to access the keys ::"
msgstr ""
"나누고 싶지 않은 정말 긴 포맷 문자열이 있을 때, 포맷할 변수들을 위치 대신에 이름으로 지정할 수 "
"있다면 좋을 것이다. 간단히 딕셔너리를 넘기고 키를 액세스하는데 꺾쇠괄호 ``'[]'`` 를 사용하면 된다 ::"

#: ../Doc/tutorial/inputoutput.rst:191
msgid ""
"This could also be done by passing the table as keyword arguments with "
"the '**' notation. ::"
msgstr ""
"'**' 표기법을 사용해서 table을 키워드 인자로 전달해도 같은 결과를 얻을 수 있다. ::"

#: ../Doc/tutorial/inputoutput.rst:198
msgid ""
"This is particularly useful in combination with the built-in function "
":func:`vars`, which returns a dictionary containing all local variables."
msgstr ""
"이 방법은 모든 지역 변수들을 담은 딕셔너리를 돌려주는 내장 함수 :func:`vars` 와 함께 사용할 "
"때 특히 쓸모가 있다. "

#: ../Doc/tutorial/inputoutput.rst:201
msgid ""
"For a complete overview of string formatting with :meth:`str.format`, see"
" :ref:`formatstrings`."
msgstr ""
":meth:`str.format` 를 사용한 문자열 포매팅의 완전한 개요는 :ref:`formatstrings` 에 나온다."

#: ../Doc/tutorial/inputoutput.rst:206
msgid "Old string formatting"
msgstr "예전의 문자열 포매팅"

#: ../Doc/tutorial/inputoutput.rst:208
msgid ""
"The ``%`` operator can also be used for string formatting. It interprets "
"the left argument much like a :c:func:`sprintf`\\ -style format string to"
" be applied to the right argument, and returns the string resulting from "
"this formatting operation. For example::"
msgstr ""
"``%`` 연산자도 문자열 포매팅에 사용될 수 있다. 왼쪽 인자를 오른쪽 인자에 적용되는 "
":c:func:`sprintf`\\ -스타일 포맷 문자열로 해석하고, 이 포매팅 연산의 결과로 얻어지는 문자열을 "
"돌려준다. 예를 들어::"

#: ../Doc/tutorial/inputoutput.rst:217
msgid "More information can be found in the :ref:`old-string-formatting` section."
msgstr "더 자세한 내용은 :ref:`old-string-formatting` 섹션에 나온다."

#: ../Doc/tutorial/inputoutput.rst:223
msgid "Reading and Writing Files"
msgstr "파일을 읽고 쓰기"

#: ../Doc/tutorial/inputoutput.rst:229
msgid ""
":func:`open` returns a :term:`file object`, and is most commonly used "
"with two arguments: ``open(filename, mode)``."
msgstr ""
":func:`open` 은 :term:`파일 객체 <file object>` 를 돌려주고, 두 개의 인자를 주는 방식이 "
"가장 많이 사용된다: ``open(filename, mode)``."

#: ../Doc/tutorial/inputoutput.rst:241
msgid ""
"The first argument is a string containing the filename.  The second "
"argument is another string containing a few characters describing the way"
" in which the file will be used.  *mode* can be ``'r'`` when the file "
"will only be read, ``'w'`` for only writing (an existing file with the "
"same name will be erased), and ``'a'`` opens the file for appending; any "
"data written to the file is automatically added to the end.  ``'r+'`` "
"opens the file for both reading and writing. The *mode* argument is "
"optional; ``'r'`` will be assumed if it's omitted."
msgstr ""
"첫 번째 인자는 파일 이름을 담은 문자열이다. 두 번째 인자는 파일이 사용될 방식을 설명하는 몇 개의 "
"문자들을 담은 또 하나의 문자열이다. *mode* 는 파일을 읽기만 하면 ``'r'``, 쓰기만 하면 "
"``'w'`` (같은 이름의 이미 존재하는 파일은 삭제된다) 가 되고, ``'a'`` 는 파일을 덧붙이기 위해 "
"연다; 파일에 기록되는 모든 데이터는 자동으로 끝에 붙는다. ``'r+'`` 는 파일을 읽고 쓰기 위해 "
"연다. *mode* 인자는 선택적인데, 생략하면 ``'r'`` 이 가정된다."

#: ../Doc/tutorial/inputoutput.rst:250
msgid ""
"Normally, files are opened in :dfn:`text mode`, that means, you read and "
"write strings from and to the file, which are encoded in a specific "
"encoding. If encoding is not specified, the default is platform dependent"
" (see :func:`open`). ``'b'`` appended to the mode opens the file in "
":dfn:`binary mode`: now the data is read and written in the form of bytes"
" objects.  This mode should be used for all files that don't contain "
"text."
msgstr ""
"보통, 파일은 :dfn:`텍스트 모드 (text mode)` 로 열리는데, 이 뜻은, 파일에 문자열을 읽고 쓰고, "
"파일에는 특정한 인코딩으로 저장된다는 것이다. 인코딩이 지정되지 않으면 기본값은 플랫폼 의존적이다 "
"(:func:`open` 을 보세요). mode 에 덧붙여진 ``'b'`` 는 파일을 :dfn:`바이너리 모드 "
"(binary mode)` 로 연다: 이제 데이터는 바이트열 객체의 형태로 읽고 쓰인다. 텍스트를 포함하지 "
"않는 모든 파일에는 이 모드를 사용해야 한다."

#: ../Doc/tutorial/inputoutput.rst:257
msgid ""
"In text mode, the default when reading is to convert platform-specific "
"line endings (``\\n`` on Unix, ``\\r\\n`` on Windows) to just ``\\n``.  "
"When writing in text mode, the default is to convert occurrences of "
"``\\n`` back to platform-specific line endings.  This behind-the-scenes "
"modification to file data is fine for text files, but will corrupt binary"
" data like that in :file:`JPEG` or :file:`EXE` files.  Be very careful to"
" use binary mode when reading and writing such files."
msgstr ""
"텍스트 모드에서, 읽을 때의 기본 동작은 플랫폼 의존적인 줄 종료 (유닉스에서 ``\\n``, 윈도우에서 "
"``\\r\\n``) 를 단지 ``\\n`` 로 변경하는 것이다. 텍스트 모드로 쓸 때, 기본 동작은 ``\\n`` "
"를 다시 플랫폼 의존적인 줄 종료로 변환하는 것이다. 이 파일 데이터에 대한 무대 뒤의 수정은 텍스트 "
"파일의 경우는 문제가 안 되지만, :file:`JPEG` 이나 :file:`EXE` 파일과 같은 바이너리 데이터를 "
"망치게 된다. 그런 파일을 읽고 쓸 때 바이너리 모드를 사용하도록 주의해야 한다."

#: ../Doc/tutorial/inputoutput.rst:265
msgid ""
"It is good practice to use the :keyword:`with` keyword when dealing with "
"file objects.  The advantage is that the file is properly closed after "
"its suite finishes, even if an exception is raised at some point.  Using "
":keyword:`with` is also much shorter than writing equivalent "
":keyword:`try`\\ -\\ :keyword:`finally` blocks::"
msgstr ""
"파일 객체를 다룰 때 :keyword:`with` 키워드를 사용하는 것은 좋은 습관이다. 혜택은 도중 예외가 "
"발생하더라도 스위트가 종료될 때 파일이 올바르게 닫힌다는 것이다. :keyword:`with` 를 사용하는 "
"것은 동등한 :keyword:`try`\\ -\\ :keyword:`finally` 블록을 쓰는 것에 비교해 훨씬 짧기도 "
"하다::"

#: ../Doc/tutorial/inputoutput.rst:276
msgid ""
"If you're not using the :keyword:`with` keyword, then you should call "
"``f.close()`` to close the file and immediately free up any system "
"resources used by it. If you don't explicitly close a file, Python's "
"garbage collector will eventually destroy the object and close the open "
"file for you, but the file may stay open for a while.  Another risk is "
"that different Python implementations will do this clean-up at different "
"times."
msgstr ""
":keyword:`with` 키워드를 사용하지 않으면, ``f.close()`` 를 호출해서 파일을 닫고 사용된 "
"시스템 자원을 즉시 반납해야 한다. 명시적으로 파일을 닫지 않으면, 파이썬의 가비지 수거기가 결국에는 "
"객체를 파괴하고 여러분을 대신해서 파일을 닫게 되지만, 파일이 한동안 열린 상태로 남아있게 된다. "
"또 다른 위험은 다른 파이썬 구현들은 이 뒷정리를 서로 다른 시점에 수행한다는 것이다."

#: ../Doc/tutorial/inputoutput.rst:284
msgid ""
"After a file object is closed, either by a :keyword:`with` statement or "
"by calling ``f.close()``, attempts to use the file object will "
"automatically fail. ::"
msgstr ""
"파일 객체가 닫힌 후에는, :keyword:`with` 문이나 ``f.close()`` 를 호출하는 경우 모두, "
"파일 객체를 사용하려는 시도는 자동으로 실패한다. ::"

#: ../Doc/tutorial/inputoutput.rst:298
msgid "Methods of File Objects"
msgstr "파일 객체의 매소드"

#: ../Doc/tutorial/inputoutput.rst:300
msgid ""
"The rest of the examples in this section will assume that a file object "
"called ``f`` has already been created."
msgstr ""
"이 섹션의 나머지 예들은 ``f`` 라는 파일 객체가 이미 만들어졌다고 가정한다."

#: ../Doc/tutorial/inputoutput.rst:303
msgid ""
"To read a file's contents, call ``f.read(size)``, which reads some "
"quantity of data and returns it as a string (in text mode) or bytes "
"object (in binary mode). *size* is an optional numeric argument.  When "
"*size* is omitted or negative, the entire contents of the file will be "
"read and returned; it's your problem if the file is twice as large as "
"your machine's memory. Otherwise, at most *size* bytes are read and "
"returned. If the end of the file has been reached, ``f.read()`` will "
"return an empty string (``''``).  ::"
msgstr ""
"파일의 내용을 읽으려면, ``f.read(size)`` 를 호출하는데, 일정량의 데이터를 읽고 문자열 "
"(텍스트 모드 에서) 이나 바이트열 (바이너리 모드에서) 로 돌려준다. *size* 는 선택적인 숫자 "
"인자다. *size* 가 생략되거나 음수면 파일의 내용 전체를 읽어서 돌려준다; 파일의 크기가 기계의 "
"메모리보다 두 배 크다면 여러분이 감당할 문제다. 그렇지 않으면 최대 *size* 바이트를 읽고 "
"돌려준다. 파일의 끝에 도달하면, ``f.read()`` 는 빈 문자열 (``''``) 을 돌려준다. ::"

#: ../Doc/tutorial/inputoutput.rst:317
msgid ""
"``f.readline()`` reads a single line from the file; a newline character "
"(``\\n``) is left at the end of the string, and is only omitted on the "
"last line of the file if the file doesn't end in a newline.  This makes "
"the return value unambiguous; if ``f.readline()`` returns an empty "
"string, the end of the file has been reached, while a blank line is "
"represented by ``'\\n'``, a string containing only a single newline.  ::"
msgstr ""
"``f.readline()`` 은 파일에서 한 줄을 읽는다; 개행 문자 (``\\n``) 는 문자열의 끝에 "
"보존되고, 파일이 개행문자로 끝나지 않는 때에만 파일의 마지막 줄에서만 생략된다. 이렇게 "
"반환 값을 모호하지 않게 만든다; ``f.readline()`` 가 빈 문자열을 돌려주면, 파일의 끝에 도달한 "
"것이지만, 빈 줄은 ``'\\n'``, 즉 하나의 개행문자만을 포함하는 문자열로 표현된다. ::"

#: ../Doc/tutorial/inputoutput.rst:331
msgid ""
"For reading lines from a file, you can loop over the file object. This is"
" memory efficient, fast, and leads to simple code::"
msgstr ""
"파일에서 줄들을 읽으려면, 파일 객체에 대해 루핑할 수 있다. 이것은 메모리 효율적이고, 빠르며 "
"간단한 코드로 이어진다::"

#: ../Doc/tutorial/inputoutput.rst:340
msgid ""
"If you want to read all the lines of a file in a list you can also use "
"``list(f)`` or ``f.readlines()``."
msgstr ""
"파일의 모든 줄을 리스트로 읽어 들이려면 ``list(f)`` 나 ``f.readlines()`` 를 쓸 수 있다."

#: ../Doc/tutorial/inputoutput.rst:343
msgid ""
"``f.write(string)`` writes the contents of *string* to the file, "
"returning the number of characters written. ::"
msgstr ""
"``f.write(string)`` 은 *string* 의 내용을 파일에 쓰고, 출력된 문자들의 개수를 돌려준다."

#: ../Doc/tutorial/inputoutput.rst:349
msgid ""
"Other types of objects need to be converted -- either to a string (in "
"text mode) or a bytes object (in binary mode) -- before writing them::"
msgstr ""
"다른 형의 객체들은 쓰기 전에 변환될 필요가 있다 -- 문자열 (텍스트 모드에서) 이나 바이트열 객체 "
"(바이너리 모드에서) 로 --::"

#: ../Doc/tutorial/inputoutput.rst:357
msgid ""
"``f.tell()`` returns an integer giving the file object's current position"
" in the file represented as number of bytes from the beginning of the "
"file when in binary mode and an opaque number when in text mode."
msgstr ""
"``f.tell()`` 은 파일의 현재 위치를 가리키는 정수를 돌려주는데, 바이너리 모드의 경우 파일의 "
"처음부터의 바이트 수로 표현되고 텍스트 모드의 경우는 불투명한 숫자다."

#: ../Doc/tutorial/inputoutput.rst:361
msgid ""
"To change the file object's position, use ``f.seek(offset, from_what)``."
"  The position is computed from adding *offset* to a reference point; the"
" reference point is selected by the *from_what* argument.  A *from_what* "
"value of 0 measures from the beginning of the file, 1 uses the current "
"file position, and 2 uses the end of the file as the reference point.  "
"*from_what* can be omitted and defaults to 0, using the beginning of the "
"file as the reference point. ::"
msgstr ""
"파일 객체의 위치를 바꾸려면, ``f.seek(offset, from_what)`` 를 사용한다. 위치는 기준점에 "
"*offset* 을 더해서 계산된다; 기준점은 *from_what* 인자로 선택한다. *from_what* 값이 0"
"이면 파일의 처음부터 측정하고, 1이면 현재 파일 위치를 사용하고, 2 는 파일의 끝을 기준점으로 "
"사용한다. *from_what* 은 생략될 수 있고, 기본값은 0이라서 파일의 처음을 기준점으로 "
"사용한다. ::"

#: ../Doc/tutorial/inputoutput.rst:380
msgid ""
"In text files (those opened without a ``b`` in the mode string), only "
"seeks relative to the beginning of the file are allowed (the exception "
"being seeking to the very file end with ``seek(0, 2)``) and the only "
"valid *offset* values are those returned from the ``f.tell()``, or zero. "
"Any other *offset* value produces undefined behaviour."
msgstr ""
"텍스트 파일에서는 (모드 문자열에 ``b`` 가 없이 열린 것들), 파일의 시작에 상대적인 위치 변경만 "
"허락되고 (예외는 ``seek(0, 2)`` 를 사용해서 파일의 끝으로 위치를 변경하는 경우다), 올바른 "
"*offset* 값은 ``f.tell()`` 이 돌려준 값과 0뿐이다. 그 밖의 다른 *offset* 값은 정의되지 "
"않은 결과를 낳는다."

#: ../Doc/tutorial/inputoutput.rst:386
msgid ""
"File objects have some additional methods, such as :meth:`~file.isatty` "
"and :meth:`~file.truncate` which are less frequently used; consult the "
"Library Reference for a complete guide to file objects."
msgstr ""
"파일 객체는 :meth:`~file.isatty` 나 :meth:`~file.truncate` 같은 몇 가지 메서드를 더 "
"갖고 있는데, 덜 자주 사용된다; 파일 객체에 대한 완전한 안내는 라이브러리 레퍼런스에 나온다."

#: ../Doc/tutorial/inputoutput.rst:394
msgid "Saving structured data with :mod:`json`"
msgstr ":mod:`json` 으로 구조적인 데이터를 저장하기"

#: ../Doc/tutorial/inputoutput.rst:398
msgid ""
"Strings can easily be written to and read from a file.  Numbers take a "
"bit more effort, since the :meth:`read` method only returns strings, "
"which will have to be passed to a function like :func:`int`, which takes "
"a string like ``'123'`` and returns its numeric value 123.  When you want"
" to save more complex data types like nested lists and dictionaries, "
"parsing and serializing by hand becomes complicated."
msgstr ""
"문자열은 파일에 쉽게 읽고 쓸 수 있다. 숫자는 약간의 수고를 해야 하는데, :meth:`read` 메서드가 "
"문자열만을 돌려주기 때문이다. 이 문자열을 :func:`int` 같은 함수로 전달해야만 하는데, ``'123'`` "
"같은 문자열을 받고 숫자 값 123을 돌려준다. 중첩된 리스트나 딕셔너리 같은 더 복잡한 데이터를 "
"저장하려고 할 때, 수작업으로 파싱하고 직렬화하는 것이 까다로울 수 있다."

#: ../Doc/tutorial/inputoutput.rst:405
msgid ""
"Rather than having users constantly writing and debugging code to save "
"complicated data types to files, Python allows you to use the popular "
"data interchange format called `JSON (JavaScript Object Notation) "
"<http://json.org>`_.  The standard module called :mod:`json` can take "
"Python data hierarchies, and convert them to string representations; this"
" process is called :dfn:`serializing`.  Reconstructing the data from the "
"string representation is called :dfn:`deserializing`.  Between "
"serializing and deserializing, the string representing the object may "
"have been stored in a file or data, or sent over a network connection to "
"some distant machine."
msgstr ""
"사용자가 반복적으로 복잡한 데이터형을 파일에 저장하는 코드를 작성하고 디버깅하도록 하는 대신, "
"파이썬은 `JSON (JavaScript Object Notation) <http://json.org>`_ 이라는 널리 쓰이는 "
"데이터 교환 형식을 사용할 수 있게 한다. :mod:`json` 이라는 표준 모듈은 파이썬 데이터 계층을 "
"받아서 문자열 표현으로 바꿔준다; 이 절차를 :dfn:`직렬화 (serializing)` 라고 부른다. 문자열 "
"표현으로부터 데이터를 재구성하는 것은 :dfn:`역 직렬화 (deserializing)` 라고 부른다. 직렬화와 "
"역 직렬화 사이에서, 객체를 표현하는 문자열은 파일이나 데이터에 저장되거나 네트워크 연결을 통해 원격 "
"기계로 전송될 수 있다."

#: ../Doc/tutorial/inputoutput.rst:416
msgid ""
"The JSON format is commonly used by modern applications to allow for data"
" exchange.  Many programmers are already familiar with it, which makes it"
" a good choice for interoperability."
msgstr ""
"JSON 형식은 데이터 교환을 위해 현대 응용 프로그램들이 자주 사용한다. 많은 프로그래머가 이미 이것에 "
"익숙하므로, 연동성을 위한 좋은 선택이 된다."

#: ../Doc/tutorial/inputoutput.rst:420
msgid ""
"If you have an object ``x``, you can view its JSON string representation "
"with a simple line of code::"
msgstr ""
"객체 ``x`` 가 있을 때, 간단한 한 줄의 코드로 그것의 JSON 문자열 표현을 볼 수 있다::"

#: ../Doc/tutorial/inputoutput.rst:427
msgid ""
"Another variant of the :func:`~json.dumps` function, called "
":func:`~json.dump`, simply serializes the object to a :term:`text file`."
"  So if ``f`` is a :term:`text file` object opened for writing, we can do"
" this::"
msgstr ""
":func:`~json.dump` 라는 :func:`~json.dumps` 함수의 변종은 객체를 "
":term:`텍스트 파일 <text file>` 로 직렬화한다. 그래서 ``f`` 가 쓰기를 위해 열린 "
":term:`텍스트 파일 <text file>` 이면, 이렇게 할 수 있다::"

#: ../Doc/tutorial/inputoutput.rst:433
msgid ""
"To decode the object again, if ``f`` is a :term:`text file` object which "
"has been opened for reading::"
msgstr ""
"객체를 다시 디코드하려면, ``f`` 가 읽기를 위해 열린 :term:`텍스트 파일 <text file>` "
"객체일 때::"

#: ../Doc/tutorial/inputoutput.rst:438
msgid ""
"This simple serialization technique can handle lists and dictionaries, "
"but serializing arbitrary class instances in JSON requires a bit of extra"
" effort. The reference for the :mod:`json` module contains an explanation"
" of this."
msgstr ""
"이 간단한 직렬화 테크닉이 리스트와 딕셔너리를 다룰 수 있지만, 임의의 클래스 인스턴스를 JSON "
"으로 직렬화하기 위해서는 약간의 수고가 더 필요하다. :mod:`json` 모듈의 레퍼런스는 이 방법에 "
"대한 설명을 담고 있다."

#: ../Doc/tutorial/inputoutput.rst:444
msgid ":mod:`pickle` - the pickle module"
msgstr ":mod:`pickle` - 피클 모듈"

#: ../Doc/tutorial/inputoutput.rst:446
msgid ""
"Contrary to :ref:`JSON <tut-json>`, *pickle* is a protocol which allows "
"the serialization of arbitrarily complex Python objects.  As such, it is "
"specific to Python and cannot be used to communicate with applications "
"written in other languages.  It is also insecure by default: "
"deserializing pickle data coming from an untrusted source can execute "
"arbitrary code, if the data was crafted by a skilled attacker."
msgstr ""
":ref:`JSON <tut-json>` 에 반해, *pickle* 은 임의의 복잡한 파이썬 객체들을 직렬화할 수 "
"있는 프로토콜이다. 파이썬에 국한되고 다른 언어로 작성된 응용 프로그램들과 통신하는데 사용될 수 없다. "
"기본적으로 안전하지 않기도 하다: 믿을 수 없는 소스에서 온 데이터를 역 직렬화할 때, 숙련된 "
"공격자에 의해 데이터가 조작되었다면 임의의 코드가 실행될 수 있다."
