# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/tutorial/appendix.rst:5
msgid "Appendix"
msgstr "부록"

#: ../Doc/tutorial/appendix.rst:11
msgid "Interactive Mode"
msgstr "대화형 모드"

#: ../Doc/tutorial/appendix.rst:16
msgid "Error Handling"
msgstr "에러 처리"

#: ../Doc/tutorial/appendix.rst:18
msgid ""
"When an error occurs, the interpreter prints an error message and a stack"
" trace. In interactive mode, it then returns to the primary prompt; when "
"input came from a file, it exits with a nonzero exit status after "
"printing the stack trace. (Exceptions handled by an :keyword:`except` "
"clause in a :keyword:`try` statement are not errors in this context.)  "
"Some errors are unconditionally fatal and cause an exit with a nonzero "
"exit; this applies to internal inconsistencies and some cases of running "
"out of memory.  All error messages are written to the standard error "
"stream; normal output from executed commands is written to standard "
"output."
msgstr ""
"에러가 발생하면 인터프리터는 에러 메시지와 스택 트레이스를 인쇄한다. 대화형 모드에서는 기본 프롬프트로 돌아간다; 파일로부터 입력이 왔을"
" 때는, 스택 트레이스를 인쇄한 후 0이 아닌 종료 상태로 종료한다. (:keyword:`try` 문에서 :keyword:`except`"
" 절에 의해 처리되는 예외는 이 문맥에서 에러가 아니다.) 일부 에러는 무조건 치명적이며 0이 아닌 종료 상태의 종료를 유발한다; 이것은"
" 내부 불일치와 메모리 부족으로 인한 경우에 적용된다. 모든 에러 메시지는 표준 에러 스트림에 기록된다. 실행된 명령의 정상 출력은 표준"
" 출력에 기록된다."

#: ../Doc/tutorial/appendix.rst:28
msgid ""
"Typing the interrupt character (usually :kbd:`Control-C` or "
":kbd:`Delete`) to the primary or secondary prompt cancels the input and "
"returns to the primary prompt. [#]_ Typing an interrupt while a command "
"is executing raises the :exc:`KeyboardInterrupt` exception, which may be "
"handled by a :keyword:`try` statement."
msgstr ""
"기본 또는 보조 프롬프트에 인터럽트 문자 (일반적으로 :kbd:`Control-C` 또는 :kbd:`Delete`)를 입력하면 입력을 "
"취소하고 기본 프롬프트로 돌아간다. [#]_ 명령어가 실행되는 동안 인터럽트를 입력하면 :keyword:`try` 문에 의해 처리될 수 "
"있는 :exc:`KeyboardInterrupt` 예외가 발생한다."

#: ../Doc/tutorial/appendix.rst:38
msgid "Executable Python Scripts"
msgstr "실행 가능한 파이썬 스크립트"

#: ../Doc/tutorial/appendix.rst:40
msgid ""
"On BSD'ish Unix systems, Python scripts can be made directly executable, "
"like shell scripts, by putting the line ::"
msgstr ""
"BSD 스타일의 유닉스 시스템에서 파이썬 스크립트는 셸 스크립트처럼 직접 실행할 수 있게 만들 수 있다. 다음과 같은 줄 ::"

#: ../Doc/tutorial/appendix.rst:45
msgid ""
"(assuming that the interpreter is on the user's :envvar:`PATH`) at the "
"beginning of the script and giving the file an executable mode.  The "
"``#!`` must be the first two characters of the file.  On some platforms, "
"this first line must end with a Unix-style line ending (``'\\n'``), not a"
" Windows (``'\\r\\n'``) line ending.  Note that the hash, or pound, "
"character, ``'#'``, is used to start a comment in Python."
msgstr ""
"(인터프리터가 사용자의 :envvar:`PATH` 에 있다고 가정할 때)을 스크립트의 시작 부분에 넣고 파일에 실행 가능 모드를 준다. "
"``#!`` 는 반드시 파일의 처음 두 문자여야 한다. 일부 플랫폼에서는 이 첫 번째 줄이 유닉스 스타일의 줄 종료 "
"(``'\\n'``)로 끝나야 하며, 윈도우 줄 종료(``'\\r\\n'``)는 허락되지 않는다. 파이썬에서 해시, 또는 파운드, 문자 "
"``'#'`` 는 주석을 시작하는 데 사용된다."

#: ../Doc/tutorial/appendix.rst:52
msgid ""
"The script can be given an executable mode, or permission, using the "
":program:`chmod` command."
msgstr "스크립트는 :program:`chmod` 명령을 사용하여 실행 가능한 모드, 또는 권한, 을 부여받을 수 있다."

#: ../Doc/tutorial/appendix.rst:59
msgid ""
"On Windows systems, there is no notion of an \"executable mode\".  The "
"Python installer automatically associates ``.py`` files with "
"``python.exe`` so that a double-click on a Python file will run it as a "
"script.  The extension can also be ``.pyw``, in that case, the console "
"window that normally appears is suppressed."
msgstr ""
"윈도우 시스템에서는 \"실행 가능 모드\"라는 개념이 없다. 파이썬 설치 프로그램은 ``.py`` 파일을 ``python.exe``와 "
"자동으로 연결하여, 파이썬 파일을 이중 클릭하면 스크립트로 실행한다. 확장자는``.pyw`` 일 수도 있다. 이 경우, 일반적으로 "
"나타나는 콘솔 창은 표시되지 않는다."

#: ../Doc/tutorial/appendix.rst:69
msgid "The Interactive Startup File"
msgstr "대화형 시작 파일"

#: ../Doc/tutorial/appendix.rst:71
msgid ""
"When you use Python interactively, it is frequently handy to have some "
"standard commands executed every time the interpreter is started.  You "
"can do this by setting an environment variable named "
":envvar:`PYTHONSTARTUP` to the name of a file containing your start-up "
"commands.  This is similar to the :file:`.profile` feature of the Unix "
"shells."
msgstr ""
"파이썬을 대화형으로 사용할 때, 종종 인터프리터가 시작될 때마다 실행되는 표준 명령들이 있으면 편리하다. "
":envvar:`PYTHONSTARTUP` 환경 변수를 시작 명령이 들어있는 파일 이름으로 설정하면 된다. 이것은 유닉스 셸의 "
":file:`.profile` 기능과 유사하다."

#: ../Doc/tutorial/appendix.rst:77
msgid ""
"This file is only read in interactive sessions, not when Python reads "
"commands from a script, and not when :file:`/dev/tty` is given as the "
"explicit source of commands (which otherwise behaves like an interactive "
"session).  It is executed in the same namespace where interactive "
"commands are executed, so that objects that it defines or imports can be "
"used without qualification in the interactive session. You can also "
"change the prompts ``sys.ps1`` and ``sys.ps2`` in this file."
msgstr ""
"이 파일은 대화형 세션에서만 읽히며, 파이썬이 스크립트에서 명령을 읽을 때나, :file:`/dev/tty` 가 명령의 명시적 소스인 "
"경우(대화형 세션처럼 동작한다)에는 읽지 않는다. 대화형 명령이 실행되는 같은 이름 공간에서 실행되므로, 이 파일에서 정의하거나 "
"임포트하는 객체들을 대화형 세션에서 정규화하지 않은 이름으로 사용할 수 있다. 이 파일에서 ``sys.ps1`` 및 ``sys.ps2``"
" 프롬프트를 변경할 수도 있다."

#: ../Doc/tutorial/appendix.rst:85
msgid ""
"If you want to read an additional start-up file from the current "
"directory, you can program this in the global start-up file using code "
"like ``if os.path.isfile('.pythonrc.py'): "
"exec(open('.pythonrc.py').read())``. If you want to use the startup file "
"in a script, you must do this explicitly in the script::"
msgstr ""
"현재 디렉터리에서 추가 시작 파일을 읽으려면, 전역 시작 파일에서 ``if os.path.isfile('.pythonrc.py'): "
"exec(open('.pythonrc.py').read())`` 와 같은 코드를 사용해서 프로그램할 수 있다. 스크립트에서 시작 파일을 "
"사용하려면 스크립트에서 명시적으로 수행해야 한다::"

#: ../Doc/tutorial/appendix.rst:102
msgid "The Customization Modules"
msgstr "커스터마이제이션 모듈"

#: ../Doc/tutorial/appendix.rst:104
msgid ""
"Python provides two hooks to let you customize it: :mod:`sitecustomize` "
"and :mod:`usercustomize`.  To see how it works, you need first to find "
"the location of your user site-packages directory.  Start Python and run "
"this code::"
msgstr ""
"파이썬은 커스터마이즈할 수 있는 두 가지 훅을 제공한다: :mod:`sitecustomize` 와 :mod:`usercustomize`."
" 어떻게 작동하는지 보려면, 먼저 여러분의 사용자 site-packages 디렉터리의 위치를 ​​찾아야 한다. 파이썬을 시작하고 다음 "
"코드를 실행한다::"

#: ../Doc/tutorial/appendix.rst:112
msgid ""
"Now you can create a file named :file:`usercustomize.py` in that "
"directory and put anything you want in it.  It will affect every "
"invocation of Python, unless it is started with the :option:`-s` option "
"to disable the automatic import."
msgstr ""
"이제 그 디렉터리에 :file:`usercustomize.py` 라는 이름의 파일을 만들고 원하는 것들을 넣을 수 있다. 자동 임포트를 "
"비활성화하는 :option:`-s` 옵션으로 시작하지 않는 한, 이 파일은 모든 파이썬 실행에 영향을 준다."

#: ../Doc/tutorial/appendix.rst:116
msgid ""
":mod:`sitecustomize` works in the same way, but is typically created by "
"an administrator of the computer in the global site-packages directory, "
"and is imported before :mod:`usercustomize`.  See the documentation of "
"the :mod:`site` module for more details."
msgstr ""
":mod:`sitecustomize` 는 같은 방식으로 작동하지만, 일반적으로 전역 site-packages 디렉터리에 컴퓨터 관리자가 "
"만들고, :mod:`usercustomize` 전에 임포트된다. 자세한 내용은 :mod:`site` 모듈의 문서를 참고하면 된다."

#: ../Doc/tutorial/appendix.rst:123
msgid "Footnotes"
msgstr "각주"

#: ../Doc/tutorial/appendix.rst:124
msgid "A problem with the GNU Readline package may prevent this."
msgstr "GNU Readline 패키지에 있는 문제가 이것을 막을 수 있다."
