# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/tutorial/datastructures.rst:5
msgid "Data Structures"
msgstr "자료 구조"

#: ../Doc/tutorial/datastructures.rst:7
msgid ""
"This chapter describes some things you've learned about already in more "
"detail, and adds some new things as well."
msgstr ""
"이 장에서는 여러분이 이미 배운 것들을 좀 더 자세히 설명하고, 몇 가지 새로운 것들을 덧붙인다."

#: ../Doc/tutorial/datastructures.rst:13
msgid "More on Lists"
msgstr "리스트 더 보기"

#: ../Doc/tutorial/datastructures.rst:15
msgid ""
"The list data type has some more methods.  Here are all of the methods of"
" list objects:"
msgstr ""
"리스트 자료 형은 몇 가지 메서드들을 더 갖고 있다. 이것들이 리스트 객체의 모든 메서드 들이다:"

#: ../Doc/tutorial/datastructures.rst:22
msgid "Add an item to the end of the list.  Equivalent to ``a[len(a):] = [x]``."
msgstr "리스트의 끝에 항목을 더한다. ``a[len(a):] = [x]`` 와 동등하다."

#: ../Doc/tutorial/datastructures.rst:28
msgid ""
"Extend the list by appending all the items from the iterable.  Equivalent"
" to ``a[len(a):] = iterable``."
msgstr ""
"리스트의 끝에 이터러블의 모든 항목을 덧붙여서 확장한다. ``a[len(a):] = iterable`` 와 "
"동등하다."

#: ../Doc/tutorial/datastructures.rst:35
msgid ""
"Insert an item at a given position.  The first argument is the index of "
"the element before which to insert, so ``a.insert(0, x)`` inserts at the "
"front of the list, and ``a.insert(len(a), x)`` is equivalent to "
"``a.append(x)``."
msgstr ""
"주어진 위치에 항목을 삽입한다. 첫 번째 인자는 삽입되는 요소가 갖게 될 인덱스다. 그래서 "
"``a.insert(0, x)`` 는 리스트의 처음에 삽입하고, ``a.insert(len(a), x)`` 는 "
"``a.append(x)`` 와 동등하다."

#: ../Doc/tutorial/datastructures.rst:43
msgid ""
"Remove the first item from the list whose value is *x*.  It is an error "
"if there is no such item."
msgstr ""
"리스트에서 값이 *x* 인 첫 번째 항목을 삭제한다. 그런 항목이 없으면 에러다."

#: ../Doc/tutorial/datastructures.rst:50
msgid ""
"Remove the item at the given position in the list, and return it.  If no "
"index is specified, ``a.pop()`` removes and returns the last item in the "
"list.  (The square brackets around the *i* in the method signature denote"
" that the parameter is optional, not that you should type square brackets"
" at that position.  You will see this notation frequently in the Python "
"Library Reference.)"
msgstr ""
"리스트에서 주어진 위치에 있는 항목을 삭제하고, 그 항목을 돌려준다. 인덱스를 지정하지 않으면, "
"``a.pop()`` 은 리스트의 마지막 항목을 삭제하고 돌려준다. (메서드 시그니처에서 *i* 를 둘러싼 "
"꺾쇠괄호는 파라미터가 선택적임을 나타낸다. 그 위치에 꺾쇠괄호를 입력해야 한다는 뜻이 아니다. 이 "
"표기법은 파이썬 라이브러리 레퍼런스에서 지주 등장한다.)"

#: ../Doc/tutorial/datastructures.rst:60
msgid "Remove all items from the list.  Equivalent to ``del a[:]``."
msgstr "리스트의 모든 항목을 삭제한다. ``del a[:]`` 와 동등하다."

#: ../Doc/tutorial/datastructures.rst:66
msgid ""
"Return zero-based index in the list of the first item whose value is *x*."
" Raises a :exc:`ValueError` if there is no such item."
msgstr ""
"리스트에 있는 항목 중 값이 *x* 인 첫 번째 것의 0부터 시작하는 인덱스를 돌려준다. 그런 항목이 없으면 "
":exc:`ValueError` 를 일으킨다."

#: ../Doc/tutorial/datastructures.rst:69
msgid ""
"The optional arguments *start* and *end* are interpreted as in the slice "
"notation and are used to limit the search to a particular subsequence of "
"the list.  The returned index is computed relative to the beginning of "
"the full sequence rather than the *start* argument."
msgstr ""
"선택적인 인자 *start* 와 *end* 는 슬라이스 표기법처럼 해석되고, 검색을 리스트의 특별한 서브 시퀀스로 "
"제한하는 데 사용된다. 돌려주는 인덱스는 *start* 인자가 아니라 전체 시퀀스의 시작을 기준으로 한다."

#: ../Doc/tutorial/datastructures.rst:78
msgid "Return the number of times *x* appears in the list."
msgstr "리스트에서 *x* 가 등장하는 횟수를 돌려준다."

#: ../Doc/tutorial/datastructures.rst:84
msgid ""
"Sort the items of the list in place (the arguments can be used for sort "
"customization, see :func:`sorted` for their explanation)."
msgstr ""
"리스트의 항목들을 제자리에서 정렬한다 (인자들은 정렬 커스터마이제이션에 사용될 수 있다. 설명은 "
":func:`sorted` 에 나온다)."

#: ../Doc/tutorial/datastructures.rst:91
msgid "Reverse the elements of the list in place."
msgstr "리스트의 요소들을 제자리에서 뒤집는다."

#: ../Doc/tutorial/datastructures.rst:97
msgid "Return a shallow copy of the list.  Equivalent to ``a[:]``."
msgstr "리스트의 얕은 사본을 돌려준다. ``a[:]`` 와 동등하다."

#: ../Doc/tutorial/datastructures.rst:100
msgid "An example that uses most of the list methods::"
msgstr "리스트 메서드 대부분을 사용하는 예::"

#: ../Doc/tutorial/datastructures.rst:123
msgid ""
"You might have noticed that methods like ``insert``, ``remove`` or "
"``sort`` that only modify the list have no return value printed -- they "
"return the default ``None``. [1]_  This is a design principle for all "
"mutable data structures in Python."
msgstr ""
"아마도 여러분은 ``insert``, ``remove``, ``sort`` 같은 메서드들이 리스트를 수정할 뿐 "
"반환 값이 출력되지 않는 것을 알아챘을 것이다 -- 기본 ``None`` 을 돌려주고 있다. [1]_ 이"
"것은 파이썬에서 모든 가변 자료 구조들에 적용되는 설계 원리다."

#: ../Doc/tutorial/datastructures.rst:132
msgid "Using Lists as Stacks"
msgstr "리스트를 스택으로 사용하기"

#: ../Doc/tutorial/datastructures.rst:137
msgid ""
"The list methods make it very easy to use a list as a stack, where the "
"last element added is the first element retrieved (\"last-in, first-"
"out\").  To add an item to the top of the stack, use :meth:`append`.  To "
"retrieve an item from the top of the stack, use :meth:`pop` without an "
"explicit index.  For example::"
msgstr ""
"리스트 메서드들은 리스트를 스택으로 사용하기 쉽게 만드는데, 마지막에 넣은 요소가 처음으로 꺼내지는 요소다 "
"(\"last-in, first-out\"). 스택의 꼭대기에 항목을 넣으려면 :meth:`append` 를 사용한다. "
"스택의 꼭대기에서 값을 꺼내려면 명시적인 인덱스 없이 :meth:`pop` 을 사용한다. 예를 들어::"

#: ../Doc/tutorial/datastructures.rst:162
msgid "Using Lists as Queues"
msgstr "리스트를 큐로 사용하기"

#: ../Doc/tutorial/datastructures.rst:166
msgid ""
"It is also possible to use a list as a queue, where the first element "
"added is the first element retrieved (\"first-in, first-out\"); however, "
"lists are not efficient for this purpose.  While appends and pops from "
"the end of list are fast, doing inserts or pops from the beginning of a "
"list is slow (because all of the other elements have to be shifted by "
"one)."
msgstr ""
"리스트를 큐로 사용하는 것도 가능한데, 처음으로 넣은 요소가 처음으로 꺼내지는 요소다 (\"first-in, "
"first-out\"); 하지만, 리스트는 이 목적에는 효율적이지 않다. 리스트의 끝에 덧붙이거나, 끝에서 꺼내는 "
"것은 빠르지만, 리스트의 머리에 덧붙이거나 머리에서 꺼내는 것은 느리다 (다른 요소들을 모두 한 칸씩 이동"
"시켜야 하기 때문이다)."

#: ../Doc/tutorial/datastructures.rst:172
msgid ""
"To implement a queue, use :class:`collections.deque` which was designed "
"to have fast appends and pops from both ends.  For example::"
msgstr ""
"큐를 구현하려면, 양 끝에서의 덧붙이기와 꺼내기가 모두 빠르도록 설계된 :class:`collections.deque` "
"를 사용하기 바란다. 예를 들어::"

#: ../Doc/tutorial/datastructures.rst:190
msgid "List Comprehensions"
msgstr "리스트 컴프리헨션"

#: ../Doc/tutorial/datastructures.rst:192
msgid ""
"List comprehensions provide a concise way to create lists. Common "
"applications are to make new lists where each element is the result of "
"some operations applied to each member of another sequence or iterable, "
"or to create a subsequence of those elements that satisfy a certain "
"condition."
msgstr ""
"리스트 컴프리헨션은 리스트를 만드는 간결한 방법을 제공한다. 흔한 용도는, 각 요소가 다른 시퀀스나 "
"이터러블의 멤버들에 어떤 연산을 적용한 결과인 리스트를 만들거나, 어떤 조건을 만족하는 요소들로 구성된 "
"서브 시퀀스를 만드는 것이다."

#: ../Doc/tutorial/datastructures.rst:197
msgid "For example, assume we want to create a list of squares, like::"
msgstr "예를 들어, 제곱수의 리스트를 만들고 싶다고 가정하자, 이런 식이다::"

#: ../Doc/tutorial/datastructures.rst:206
msgid ""
"Note that this creates (or overwrites) a variable named ``x`` that still "
"exists after the loop completes.  We can calculate the list of squares "
"without any side effects using::"
msgstr ""
"이것은 ``x`` 라는 이름의 변수를 만들고 (또는 덮어쓰고) 루프가 종료된 후에도 남아있게 만든다는 것에 "
"유의해야 한다. 어떤 부수적 효과도 없이, 제곱수의 리스트를 이런 식으로 계산할 수 있다::"

#: ../Doc/tutorial/datastructures.rst:212
msgid "or, equivalently::"
msgstr "또는, 이렇게 할 수도 있다::"

#: ../Doc/tutorial/datastructures.rst:216
msgid "which is more concise and readable."
msgstr "이것이 더 간결하고 읽기 쉽다."

#: ../Doc/tutorial/datastructures.rst:218
msgid ""
"A list comprehension consists of brackets containing an expression "
"followed by a :keyword:`for` clause, then zero or more :keyword:`for` or "
":keyword:`if` clauses.  The result will be a new list resulting from "
"evaluating the expression in the context of the :keyword:`for` and "
":keyword:`if` clauses which follow it. For example, this listcomp "
"combines the elements of two lists if they are not equal::"
msgstr ""
"리스트 컴프리헨션은 표현식과 그 뒤를 따르는 :keyword:`for` 절과 없거나 여러 개의 "
":keyword:`for` 나 :keyword:`if` 절들을 감싸는 꺾쇠괄호로 구성된다. 그 결과는 새 "
"리스트인데, :keyword:`for` 와 :keyword:`if` 절의 문맥에서 표현식의 값을 구해서 "
"만들어진다. 예를 들어, 이 리스트 컴프리헨션은 두 리스트의 요소들을 서로 같지 않은 것끼리 결합한다::"

#: ../Doc/tutorial/datastructures.rst:228
msgid "and it's equivalent to::"
msgstr "그리고, 이것은 다음과 동등하다::"

#: ../Doc/tutorial/datastructures.rst:239
msgid ""
"Note how the order of the :keyword:`for` and :keyword:`if` statements is "
"the same in both these snippets."
msgstr ""
"두 코드 조각에서 :keyword:`for` 와 :keyword:`if` 문의 순서가 같음에 유의해야 한다."

#: ../Doc/tutorial/datastructures.rst:242
msgid ""
"If the expression is a tuple (e.g. the ``(x, y)`` in the previous "
"example), it must be parenthesized. ::"
msgstr ""
"표현식이 튜플이면 (즉 앞의 예에서 ``(x, y)``), 반드시 괄호로 둘러싸야 한다. ::"

#: ../Doc/tutorial/datastructures.rst:273
msgid "List comprehensions can contain complex expressions and nested functions::"
msgstr "리스트 컴프리헨션은 복잡한 표현식과 중첩된 함수들을 포함할 수 있다::"

#: ../Doc/tutorial/datastructures.rst:280
msgid "Nested List Comprehensions"
msgstr "중첩된 리스트 컴프리헨션"

#: ../Doc/tutorial/datastructures.rst:282
msgid ""
"The initial expression in a list comprehension can be any arbitrary "
"expression, including another list comprehension."
msgstr ""
"리스트 컴프리헨션의 첫 표현식으로 임의의 표현식이 올 수 있는데, 다른 리스트 컴프리헨션도 가능하다."

#: ../Doc/tutorial/datastructures.rst:285
msgid ""
"Consider the following example of a 3x4 matrix implemented as a list of 3"
" lists of length 4::"
msgstr ""
"다음과 같은 길이가 4인 리스트 3개의 리스트로 구현된 3x4 행렬의 예를 보자::"

#: ../Doc/tutorial/datastructures.rst:294
msgid "The following list comprehension will transpose rows and columns::"
msgstr "다음 리스트 컴프리헨션은 행과 열을 전치 시킨다::"

#: ../Doc/tutorial/datastructures.rst:299
msgid ""
"As we saw in the previous section, the nested listcomp is evaluated in "
"the context of the :keyword:`for` that follows it, so this example is "
"equivalent to::"
msgstr ""
"앞절에서 보았듯이, 중첩된 리스트 컴프리헨션은 뒤따르는 :keyword:`for` 의 문맥에서 값이 "
"구해진다. 그래서 이 예는 다음과 동등하다::"

#: ../Doc/tutorial/datastructures.rst:310
msgid "which, in turn, is the same as::"
msgstr "이것은 다시 다음과 같다::"

#: ../Doc/tutorial/datastructures.rst:323
msgid ""
"In the real world, you should prefer built-in functions to complex flow "
"statements. The :func:`zip` function would do a great job for this use "
"case::"
msgstr ""
"실제 세상에서는, 복잡한 흐름문보다 내장 함수들을 선호해야 한다. 이 경우에는 :func:`zip` 함수가 제 "
"역할을 할 수 있다::"

#: ../Doc/tutorial/datastructures.rst:329
msgid ""
"See :ref:`tut-unpacking-arguments` for details on the asterisk in this "
"line."
msgstr ""
"이 줄에 나오는 에스터리스크에 대한 자세한 내용은 :ref:`tut-unpacking-arguments` 에 나온다."

#: ../Doc/tutorial/datastructures.rst:334
msgid "The :keyword:`del` statement"
msgstr ":keyword:`del` 문"

#: ../Doc/tutorial/datastructures.rst:336
msgid ""
"There is a way to remove an item from a list given its index instead of "
"its value: the :keyword:`del` statement.  This differs from the "
":meth:`pop` method which returns a value.  The :keyword:`del` statement "
"can also be used to remove slices from a list or clear the entire list "
"(which we did earlier by assignment of an empty list to the slice).  For "
"example::"
msgstr ""
"리스트에서 값 대신에 인덱스를 사용해서 항목을 삭제하는 방법이 있다: :keyword:`del` 문이다. 이것은 "
"값을 돌려주는 :meth:`pop` 메서드와 다르다. :keyword:`del` 문은 리스트에서 슬라이스를 삭제하거나 "
"전체 리스트를 비우는 데도 사용될 수 있다 (앞에서 빈 리스트를 슬라이스에 대입해서 했던 일이다). 예를 들어::"

#: ../Doc/tutorial/datastructures.rst:353
msgid ":keyword:`del` can also be used to delete entire variables::"
msgstr ":keyword:`del` 는 변 자체를 삭제하는데에도 사용될 수 있다::"

#: ../Doc/tutorial/datastructures.rst:357
msgid ""
"Referencing the name ``a`` hereafter is an error (at least until another "
"value is assigned to it).  We'll find other uses for :keyword:`del` "
"later."
msgstr ""
"이후에 이름 ``a`` 를 참조하는 것은 에러다 (적어도 다른 값이 새로 대입되기 전까지). 뒤에서 "
":keyword:`del` 의 다른 용도를 보게 된다."

#: ../Doc/tutorial/datastructures.rst:364
msgid "Tuples and Sequences"
msgstr "튜플과 시퀀스"

#: ../Doc/tutorial/datastructures.rst:366
msgid ""
"We saw that lists and strings have many common properties, such as "
"indexing and slicing operations.  They are two examples of *sequence* "
"data types (see :ref:`typesseq`).  Since Python is an evolving language, "
"other sequence data types may be added.  There is also another standard "
"sequence data type: the *tuple*."
msgstr ""
"리스트와 문자열이 인덱싱과 슬라이싱 연산과 같은 많은 성질을 공유함을 보았다. 이것들은 *시퀀스* 자료 "
"형의 두 가지 예다 (:ref:`typesseq` 를 보세요). 파이썬은 진화하는 언어이기 때문에, 다른 시퀀스 "
"자료형이 추가될 수도 있다. 다른 표준 시퀀스 자료 형이 있다: *튜플* 이다."

#: ../Doc/tutorial/datastructures.rst:372
msgid "A tuple consists of a number of values separated by commas, for instance::"
msgstr "튜플은 쉼표로 구분되는 여러 값으로 구성된다. 예를 들어::"

#: ../Doc/tutorial/datastructures.rst:394
msgid ""
"As you see, on output tuples are always enclosed in parentheses, so that "
"nested tuples are interpreted correctly; they may be input with or "
"without surrounding parentheses, although often parentheses are necessary"
" anyway (if the tuple is part of a larger expression).  It is not "
"possible to assign to the individual items of a tuple, however it is "
"possible to create tuples which contain mutable objects, such as lists."
msgstr ""
"여러분이 보듯이, 출력되는 튜플은 항상 괄호로 둘러싸인다, 그래서 중첩된 튜플이 올바르게 해석된다; 종종 "
"괄호가 필요하기는 하지만 (튜플이 더 큰 표현식의 일부일 때), 둘러싼 괄호와 함께 또는 없이 입력될 수 "
"있다. 튜플의 개별 항목에 대입하는 것은 가능하지 않지만, 리스트 같은 가변 객체를 포함하는 튜플을 만들 "
"수는 있다."

#: ../Doc/tutorial/datastructures.rst:401
msgid ""
"Though tuples may seem similar to lists, they are often used in different"
" situations and for different purposes. Tuples are :term:`immutable`, and"
" usually contain a heterogeneous sequence of elements that are accessed "
"via unpacking (see later in this section) or indexing (or even by "
"attribute in the case of :func:`namedtuples <collections.namedtuple>`). "
"Lists are :term:`mutable`, and their elements are usually homogeneous and"
" are accessed by iterating over the list."
msgstr ""
"튜플이 리스트처럼 보인다 하더라도, 이것들은 다른 상황에서 다른 목적으로 사용된다. 튜플은 "
":term:`불변 <immutable>` 이고, 보통 이질적인 요소들의 시퀀스를 포함한다. 요소들은 언 패킹 (이 "
"섹션의 뒤에 나온다) 이나 인덱싱 (또는 :func:`네임드 튜플 <collections.namedtuple>` 의 경우는 "
"어트리뷰트로도) 으로 액세스한다. 리스트는 :term:`가변 <mutable>` 이고, 요소들은 보통 등질 적이고 "
"리스트에 대한 이터레이션으로 액세스 된다."

#: ../Doc/tutorial/datastructures.rst:409
msgid ""
"A special problem is the construction of tuples containing 0 or 1 items: "
"the syntax has some extra quirks to accommodate these.  Empty tuples are "
"constructed by an empty pair of parentheses; a tuple with one item is "
"constructed by following a value with a comma (it is not sufficient to "
"enclose a single value in parentheses). Ugly, but effective.  For "
"example::"
msgstr ""
"특별한 문제는 비었거나 하나의 항목을 갖는 튜플을 만드는 것이다: 이 경우를 수용하기 위해 문법은 추가적인 "
"예외 사항을 갖고 있다. 빈 튜플은 빈 괄호 쌍으로 만들어진다; 하나의 항목으로 구성된 튜플은 값 뒤에 "
"쉼표를 붙여서 만든다 (값 하나를 괄호로 둘러싸기만 하는 것으로는 충분하지 않다). 추하다, 하지만 "
"효과적이다. 예를 들어::"

#: ../Doc/tutorial/datastructures.rst:424
msgid ""
"The statement ``t = 12345, 54321, 'hello!'`` is an example of *tuple "
"packing*: the values ``12345``, ``54321`` and ``'hello!'`` are packed "
"together in a tuple. The reverse operation is also possible::"
msgstr ""
"문장 ``t = 12345, 54321, 'hello!'`` 는 *튜플 패킹* 의 예다: 값 ``12345``, ``54321``, "
"``'hello!'`` 는 함께 튜플로 패킹 된다. 반대 연산 또한 가능하다::"

#: ../Doc/tutorial/datastructures.rst:430
msgid ""
"This is called, appropriately enough, *sequence unpacking* and works for "
"any sequence on the right-hand side.  Sequence unpacking requires that "
"there are as many variables on the left side of the equals sign as there "
"are elements in the sequence.  Note that multiple assignment is really "
"just a combination of tuple packing and sequence unpacking."
msgstr ""
"이것은, 충분히 적절하게도, *시퀀스 언 패킹* 이라고 불리고 오른쪽에 어떤 시퀀스가 와도 된다. 시퀀스 "
"언 패킹은 등호의 좌변에 시퀀스에 있는 요소들과 같은 개수의 변수들이 올 것을 요구한다. 다중 대입은 사실 "
"튜플 패킹과 시퀀스 언 패킹의 조합일뿐이라는 것에 유의해야 한다."

#: ../Doc/tutorial/datastructures.rst:440
msgid "Sets"
msgstr "집합"

#: ../Doc/tutorial/datastructures.rst:442
msgid ""
"Python also includes a data type for *sets*.  A set is an unordered "
"collection with no duplicate elements.  Basic uses include membership "
"testing and eliminating duplicate entries.  Set objects also support "
"mathematical operations like union, intersection, difference, and "
"symmetric difference."
msgstr ""
"파이썬은 *집합* 을 위한 자료 형도 포함한다. 집합은 중복되는 요소가 없는 순서 없는 컬렉션이다. 기본적인 용도는 "
"멤버십 검사와 중복 엔트리 제거다. 집합 객체는 합집합, 교집합, 차집합, 대칭 차집합과 같은 수학적인 연산들도 지원한다."

#: ../Doc/tutorial/datastructures.rst:447
msgid ""
"Curly braces or the :func:`set` function can be used to create sets.  "
"Note: to create an empty set you have to use ``set()``, not ``{}``; the "
"latter creates an empty dictionary, a data structure that we discuss in "
"the next section."
msgstr ""
"집합을 만들 때는 중괄호나 :func:`set` 함수를 사용할 수 있다. 주의사항: 빈 집합을 만들려면 "
"``set()`` 을 사용해야 한다. ``{}`` 가 아니다; 후자는 빈 딕셔너리를 만드는데, 다음 섹션에서 다룬다."

#: ../Doc/tutorial/datastructures.rst:451
msgid "Here is a brief demonstration::"
msgstr "여기 간략한 실연이 있다::"

#: ../Doc/tutorial/datastructures.rst:476
msgid ""
"Similarly to :ref:`list comprehensions <tut-listcomps>`, set "
"comprehensions are also supported::"
msgstr ""
":ref:`리스트 컴프리헨션 <tut-listcomps>` 과 유사하게, 집합 컴프리헨션도 지원된다::"

#: ../Doc/tutorial/datastructures.rst:487
msgid "Dictionaries"
msgstr "딕셔너리"

#: ../Doc/tutorial/datastructures.rst:489
msgid ""
"Another useful data type built into Python is the *dictionary* (see "
":ref:`typesmapping`). Dictionaries are sometimes found in other languages"
" as \"associative memories\" or \"associative arrays\".  Unlike "
"sequences, which are indexed by a range of numbers, dictionaries are "
"indexed by *keys*, which can be any immutable type; strings and numbers "
"can always be keys.  Tuples can be used as keys if they contain only "
"strings, numbers, or tuples; if a tuple contains any mutable object "
"either directly or indirectly, it cannot be used as a key. You can't use "
"lists as keys, since lists can be modified in place using index "
"assignments, slice assignments, or methods like :meth:`append` and "
":meth:`extend`."
msgstr ""
"파이썬에 내장된 또 하나의 쓸모있는 자료 형은 *딕셔너리* 다 (:ref:`typesmapping` 를 보세요). "
"딕셔너리는 종종 다른 언어들에서 \"연관 메모리(associative memories)\" 나 "
"\"연관 배열(associative arrays)\" 의 형태로 발견된다. 숫자들로 인덱싱되는 시퀀스와 달리, "
"딕셔너리는 *키* 로 인덱싱되는데, 모든 불변형을 사용할 수 있다; 문자열과 숫자들은 항상 키가 될 수 있다. "
"튜플이 문자열, 숫자, 튜플들만 포함하면, 키로 사용될 수 있다; 튜플이 직접적이나 간접적으로 가변 객체를 "
"포함하면, 키로 사용될 수 없다. 리스트는 키로 사용할 수 없는데, 리스트는 인덱스 대입, 슬라이스 대입, "
":meth:`append` 나 :meth:`extend` 같은 메서드들로 값이 수정될 수 있기 때문이다."

#: ../Doc/tutorial/datastructures.rst:500
msgid ""
"It is best to think of a dictionary as an unordered set of *key: value* "
"pairs, with the requirement that the keys are unique (within one "
"dictionary). A pair of braces creates an empty dictionary: ``{}``. "
"Placing a comma-separated list of key:value pairs within the braces adds "
"initial key:value pairs to the dictionary; this is also the way "
"dictionaries are written on output."
msgstr ""
"딕셔너리를 (한 딕셔너리 안에서) 키가 중복되지 않는다는 제약 조건을 가진 *키: 값* 쌍의 순서 없는 "
"집합으로 생각하는 것이 최선이다. 중괄호 쌍은 빈 딕셔너리를 만든다: ``{}``. 중괄호 안에 쉼표로 분리된 "
"키:값 쌍들의 목록을 넣으면, 딕셔너리에 초기 키:값 쌍들을 제공한다; 이것이 딕셔너리가 출력되는 방식이기도 하다."

#: ../Doc/tutorial/datastructures.rst:506
msgid ""
"The main operations on a dictionary are storing a value with some key and"
" extracting the value given the key.  It is also possible to delete a "
"key:value pair with ``del``. If you store using a key that is already in "
"use, the old value associated with that key is forgotten.  It is an error"
" to extract a value using a non-existent key."
msgstr ""
"딕셔너리의 주 연산은 값을 키와 함께 저장하고 주어진 키로 값을 추출하는 것이다. ``del`` 로 키:값 쌍을 삭제하는 "
"것도 가능하다. 이미 사용하고 있는 키로 저장하면, 그 키로 저장된 예전 값은 잊힌다. 존재하지 않는 키로 값을 "
"추출하는 것은 에러다."

#: ../Doc/tutorial/datastructures.rst:512
msgid ""
"Performing ``list(d.keys())`` on a dictionary returns a list of all the "
"keys used in the dictionary, in arbitrary order (if you want it sorted, "
"just use ``sorted(d.keys())`` instead). [2]_  To check whether a single "
"key is in the dictionary, use the :keyword:`in` keyword."
msgstr ""
"딕셔러리에 ``list(d.keys())`` 를 수행하면 딕셔너리에서 사용되고 있는 모든 키의 리스트를 돌려준다. 그 순서는 "
"정해져 있지 않다 (정렬을 원하면 대신 ``sorted(d.keys())`` 를 사용하면 된다). [2]_ 하나의 키가 딕셔너리에 "
"있는지 검사하려면, :keyword:`in` 키워드들 사용한다."

#: ../Doc/tutorial/datastructures.rst:517
msgid "Here is a small example using a dictionary::"
msgstr "여기에 딕셔너리를 사용하는 조그마한 예가 있다::"

#: ../Doc/tutorial/datastructures.rst:538
msgid ""
"The :func:`dict` constructor builds dictionaries directly from sequences "
"of key-value pairs::"
msgstr ""
":func:`dict` 생성자는 키-값 쌍들의 시퀀스로 부터 직접 딕셔너리를 구성한다."

#: ../Doc/tutorial/datastructures.rst:544
msgid ""
"In addition, dict comprehensions can be used to create dictionaries from "
"arbitrary key and value expressions::"
msgstr ""
"이에 더해, 딕셔너리 컴프리헨션은 임의의 키와 값 표현식들로 부터 딕셔너리를 만드는데 사용될 수 있다::"

#: ../Doc/tutorial/datastructures.rst:550
msgid ""
"When the keys are simple strings, it is sometimes easier to specify pairs"
" using keyword arguments::"
msgstr ""
"키가 간단한 문자열일 때, 때로 키워드 인자들을 사용해서 쌍을 지정하기가 쉽다::"

#: ../Doc/tutorial/datastructures.rst:560
msgid "Looping Techniques"
msgstr "루프 테크닉"

#: ../Doc/tutorial/datastructures.rst:562
msgid ""
"When looping through dictionaries, the key and corresponding value can be"
" retrieved at the same time using the :meth:`items` method. ::"
msgstr ""
"딕셔너리로 루핑할 때, :meth:`items` 메서드를 사용하면 키와 거기에 대응하는 값을 동시에 얻을 수 "
"있다. ::"

#: ../Doc/tutorial/datastructures.rst:572
msgid ""
"When looping through a sequence, the position index and corresponding "
"value can be retrieved at the same time using the :func:`enumerate` "
"function. ::"
msgstr ""
"시퀀스를 루핑할 때, :func:`enumerate` 함수를 사용하면 위치 인덱스와 대응하는 값을 동시에 얻을 "
"수 있다. ::"

#: ../Doc/tutorial/datastructures.rst:582
msgid ""
"To loop over two or more sequences at the same time, the entries can be "
"paired with the :func:`zip` function. ::"
msgstr ""
"둘이나 그 이상의 시퀀스를 동시에 루핑하려면, :func:`zip` 함수로 엔트리들의 쌍을 만들 수 "
"있다. ::"

#: ../Doc/tutorial/datastructures.rst:594
msgid ""
"To loop over a sequence in reverse, first specify the sequence in a "
"forward direction and then call the :func:`reversed` function. ::"
msgstr ""
"시퀀스를 거꾸로 루핑하려면, 먼저 정방향으로 시퀀스를 지정한 다음에 :func:`reversed` 함수를 "
"호출한다. ::"

#: ../Doc/tutorial/datastructures.rst:606
msgid ""
"To loop over a sequence in sorted order, use the :func:`sorted` function "
"which returns a new sorted list while leaving the source unaltered. ::"
msgstr ""
"정렬된 순서로 시퀀스를 루핑하려면, :func:`sorted` 함수를 사용해서 소스를 변경하지 않고도 "
"정렬된 새 리스트를 받을 수 있다. ::"

#: ../Doc/tutorial/datastructures.rst:618
msgid ""
"It is sometimes tempting to change a list while you are looping over it; "
"however, it is often simpler and safer to create a new list instead. ::"
msgstr ""
"때로 루프를 돌고 있는 리스트를 변경하고픈 유혹을 느낀다; 하지만, 종종, 대신 새 리스트를 만드는 것이 "
"더 간단하고 더 안전하다. ::"

#: ../Doc/tutorial/datastructures.rst:635
msgid "More on Conditions"
msgstr "조건 더 보기"

#: ../Doc/tutorial/datastructures.rst:637
msgid ""
"The conditions used in ``while`` and ``if`` statements can contain any "
"operators, not just comparisons."
msgstr ""
"``while`` 과 ``if`` 문에서 사용되는 조건에는 비교뿐만 아니라 모든 연산자를 사용할 수 있다."

#: ../Doc/tutorial/datastructures.rst:640
msgid ""
"The comparison operators ``in`` and ``not in`` check whether a value "
"occurs (does not occur) in a sequence.  The operators ``is`` and ``is "
"not`` compare whether two objects are really the same object; this only "
"matters for mutable objects like lists.  All comparison operators have "
"the same priority, which is lower than that of all numerical operators."
msgstr ""
"비교 연산자 ``in`` 과 ``not in`` 은 값이 시퀀스에 있는지 (없는지) 검사한다. 연산자 ``is`` 와 ``is not`` "
"은 두 객체가 진짜로 같은 객체인지 비교한다; 이것은 리스트와 같은 가변 객체에서만 의미가 있다. 모든 비교 "
"연산자들은 같은 우선순위를 갖는데, 모든 산술 연산자들보다 낮다."

#: ../Doc/tutorial/datastructures.rst:646
msgid ""
"Comparisons can be chained.  For example, ``a < b == c`` tests whether "
"``a`` is less than ``b`` and moreover ``b`` equals ``c``."
msgstr ""
"비교는 연쇄할 수 있다. 예를 들어, ``a < b == c`` 는, ``a`` 가 ``b`` 보다 작고, 동시에 ``b`` 가 ``c`` "
"와 같은지 검사한다."

#: ../Doc/tutorial/datastructures.rst:649
msgid ""
"Comparisons may be combined using the Boolean operators ``and`` and "
"``or``, and the outcome of a comparison (or of any other Boolean "
"expression) may be negated with ``not``.  These have lower priorities "
"than comparison operators; between them, ``not`` has the highest priority"
" and ``or`` the lowest, so that ``A and not B or C`` is equivalent to "
"``(A and (not B)) or C``. As always, parentheses can be used to express "
"the desired composition."
msgstr ""
"비교는 논리 연산자 ``and`` 와 ``or`` 를 사용해서 결합할 수 있고, 비교의 결과는 (또는 그 밖의 모든 논리 "
"표현식은) ``not`` 으로 부정될 수 있다. 이것들은 비교 연산자보다 낮은 우선순위를 갖는다. 이것 간에는 "
"``not`` 이 가장 높은 우선순위를 갖고, ``or`` 가 가장 낮다. 그래서 ``A and not B or C`` 는 ``(A and "
"(not B)) or C`` 와 동등하다. 여느 때처럼, 원하는 조합을 표현하기 위해 괄호를 사용할 수 있다."

#: ../Doc/tutorial/datastructures.rst:656
msgid ""
"The Boolean operators ``and`` and ``or`` are so-called *short-circuit* "
"operators: their arguments are evaluated from left to right, and "
"evaluation stops as soon as the outcome is determined.  For example, if "
"``A`` and ``C`` are true but ``B`` is false, ``A and B and C`` does not "
"evaluate the expression ``C``.  When used as a general value and not as a"
" Boolean, the return value of a short-circuit operator is the last "
"evaluated argument."
msgstr ""
"논리 연산자 ``and`` 와 ``or`` 는 소위 *단락-회로(short-circuit)* 연산자다: 인자들은 "
"왼쪽에서 오른쪽으로 값이 구해지고, 결과가 결정되자마자 값 구하기는 중단된다. 예를 들어, ``A`` "
"와 ``C`` 가 참이고 ``B`` 가 거짓이면, ``A and B and C`` 는 표현식 ``C`` 의 값을 구하지 "
"않는다. 논리값이 아닌 일반 값으로 사용될 때, 단락-회로 연산자의 반환 값은 마지막으로 값이 구해진 "
"인자다."

#: ../Doc/tutorial/datastructures.rst:663
msgid ""
"It is possible to assign the result of a comparison or other Boolean "
"expression to a variable.  For example, ::"
msgstr ""
"비교의 결과나 다른 논리 표현식의 결과를 변수에 대입할 수 있다. 예를 들어, ::"

#: ../Doc/tutorial/datastructures.rst:671
msgid ""
"Note that in Python, unlike C, assignment cannot occur inside "
"expressions. C programmers may grumble about this, but it avoids a common"
" class of problems encountered in C programs: typing ``=`` in an "
"expression when ``==`` was intended."
msgstr ""
"파이썬에서, C와는 달리, 대입은 표현식 안에 등장할 수 없다. C 프로그래머들이 이 문제로 "
"투덜거리지만, C 프로그램에서 흔히 마주치는 부류의 문제들을 회피하도록 한다: ``==`` 를 사용할 "
"표현식에 ``=`` 를 입력하는 실수."

#: ../Doc/tutorial/datastructures.rst:680
msgid "Comparing Sequences and Other Types"
msgstr "시퀀스와 다른 형들을 비교하기"

#: ../Doc/tutorial/datastructures.rst:682
msgid ""
"Sequence objects may be compared to other objects with the same sequence "
"type. The comparison uses *lexicographical* ordering: first the first two"
" items are compared, and if they differ this determines the outcome of "
"the comparison; if they are equal, the next two items are compared, and "
"so on, until either sequence is exhausted. If two items to be compared "
"are themselves sequences of the same type, the lexicographical comparison"
" is carried out recursively.  If all items of two sequences compare "
"equal, the sequences are considered equal. If one sequence is an initial "
"sub-sequence of the other, the shorter sequence is the smaller (lesser) "
"one.  Lexicographical ordering for strings uses the Unicode code point "
"number to order individual characters.  Some examples of comparisons "
"between sequences of the same type::"
msgstr ""
"시퀀스 객체들은 같은 시퀀스 형의 다른 객체들과 비교될 수 있다. 비교는 *사전식* 순서를 사용한다: 먼저 첫 두 "
"항목을 비교해서 다르면 이것이 비교의 결과를 결정한다; 같으면, 다음 두 항목을 비교하고, 이런 식으로 어느 한 "
"시퀀스가 소진될 때까지 계속한다. 만약 비교되는 두 항목 자체가 같은 형의 시퀀스면, 사전식 비교가 재귀적으로 "
"수행된다. 두 시퀀스의 모든 항목이 같다고 비교되면, 시퀀스들은 같은 것으로 취급된다. 한 시퀀스가 다른 하나의 "
"머리 부분 서브 시퀀스면, 짧은 시퀀스가 작은 것이다. 문자열의 사전식 배열은 개별 문자들의 순서를 정하는데 유니코드 코드 "
"포인트 숫자를 사용한다. 같은 형의 시퀀스들 간의 비교의 몇 가지 예는 이렇다::"

#: ../Doc/tutorial/datastructures.rst:702
msgid ""
"Note that comparing objects of different types with ``<`` or ``>`` is "
"legal provided that the objects have appropriate comparison methods.  For"
" example, mixed numeric types are compared according to their numeric "
"value, so 0 equals 0.0, etc.  Otherwise, rather than providing an "
"arbitrary ordering, the interpreter will raise a :exc:`TypeError` "
"exception."
msgstr ""
"서로 다른 형의 객체들을 ``<`` 나 ``>`` 로 비교하는 것은, 그 객체들이 적절한 비교 메서드들을 갖고 있을 때만 "
"허락된다는 것에 유의해야 한다. 예를 들어, 서로 다른 숫자 형들은 그들의 숫자 값에 따라 비교된다. 그래서 0은 0.0과 "
"같고, 등등. 그렇지 않으면, 임의의 순서를 제공하는 대신, 인터프리터는 :exc:`TypeError` 를 일으킨다."

#: ../Doc/tutorial/datastructures.rst:710
msgid "Footnotes"
msgstr "각주"

#: ../Doc/tutorial/datastructures.rst:711
msgid ""
"Other languages may return the mutated object, which allows method "
"chaining, such as ``d->insert(\"a\")->remove(\"b\")->sort();``."
msgstr ""
"다른 언어들에서는 가변 객체를 돌려주기도 하는데, ``d->insert(\"a\")->remove(\"b\")->sort();`` 와 "
"같은 메서드 연쇄를 허락한다."

#: ../Doc/tutorial/datastructures.rst:714
msgid ""
"Calling ``d.keys()`` will return a :dfn:`dictionary view` object.  It "
"supports operations like membership test and iteration, but its contents "
"are not independent of the original dictionary -- it is only a *view*."
msgstr ""
"``d.keys()`` 를 호출하면 :dfn:`딕셔너리 뷰 (dictionary view)` 객체를 돌려준다. 이것은 멤버십 검사와 이터레이션 같은 "
"연산들을 지원하지만, 그 내용은 원래 딕셔너리와 독립적이지 않다 -- 이것은 *뷰* 일 뿐이다."

