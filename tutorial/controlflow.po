# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/tutorial/controlflow.rst:5
msgid "More Control Flow Tools"
msgstr "기타 제어 흐름 도구"

#: ../Doc/tutorial/controlflow.rst:7
msgid ""
"Besides the :keyword:`while` statement just introduced, Python knows the "
"usual control flow statements known from other languages, with some "
"twists."
msgstr ""
"방금 소개한 :keyword:`while` 문 외에도, 파이썬은 다른 언어들에서 알려진 일반적인 제어 흐름 "
"문들을 알고 있으며, 나름의 변형을 가하고 있다."

#: ../Doc/tutorial/controlflow.rst:14
msgid ":keyword:`if` Statements"
msgstr ":keyword:`if` 문"

#: ../Doc/tutorial/controlflow.rst:16
msgid ""
"Perhaps the most well-known statement type is the :keyword:`if` "
"statement.  For example::"
msgstr ""
"아마도 가장 잘 알려진 문장 형은 :keyword:`if` 문일 것이다. 예를 들어::"

#: ../Doc/tutorial/controlflow.rst:33
msgid ""
"There can be zero or more :keyword:`elif` parts, and the :keyword:`else` "
"part is optional.  The keyword ':keyword:`elif`' is short for 'else if', "
"and is useful to avoid excessive indentation.  An  :keyword:`if` ... "
":keyword:`elif` ... :keyword:`elif` ... sequence is a substitute for the "
"``switch`` or ``case`` statements found in other languages."
msgstr ""
"없거나 여러 개의 :keyword:`elif` 부가 있을 수 있고, :keyword:`else` 부는 선택적이다. "
"키워드 ':keyword:`elif`' 는 'else if' 의 줄임 표현인데, 과도한 들여쓰기를 피하는 데 "
"유용하다. :keyword:`if` ... :keyword:`elif` ... :keyword:`elif` ... 시퀀스는 "
"다른 언어들에서 발견되는 ``switch`` 나 ``case`` 문을 대신한다."

#: ../Doc/tutorial/controlflow.rst:43
msgid ":keyword:`for` Statements"
msgstr ":keyword:`for` 문"

#: ../Doc/tutorial/controlflow.rst:48
msgid ""
"The :keyword:`for` statement in Python differs a bit from what you may be"
" used to in C or Pascal.  Rather than always iterating over an arithmetic"
" progression of numbers (like in Pascal), or giving the user the ability "
"to define both the iteration step and halting condition (as C), Python's "
":keyword:`for` statement iterates over the items of any sequence (a list "
"or a string), in the order that they appear in the sequence.  For example"
" (no pun intended):"
msgstr ""
"파이썬에서 :keyword:`for` 문은 C 나 파스칼에서 사용하던 것과 약간 다르다. (파스칼처럼) "
"항상 숫자의 산술적인 진행을 통해 이터레이션 하거나, (C처럼) 사용자가 이터레이션 단계와 중지 "
"조건을 정의할 수 있도록 하는 대신, 파이썬의 :keyword:`for` 문은 임의의 시퀀스 (리스트나 "
"문자열)의 항목들을 그 시퀀스에 들어있는 순서대로 이터레이션 한다. 예를 들어 (말장난이 아니라):"

#: ../Doc/tutorial/controlflow.rst:69
msgid ""
"If you need to modify the sequence you are iterating over while inside "
"the loop (for example to duplicate selected items), it is recommended "
"that you first make a copy.  Iterating over a sequence does not "
"implicitly make a copy.  The slice notation makes this especially "
"convenient::"
msgstr ""
"루프 안에서 이터레이트하는 시퀀스를 수정할 필요가 있다면 (예를 들어 선택한 항목들을 중복시키기), "
"먼저 사본을 만들 것을 권한다. 시퀀스를 이터레이트할 때 묵시적으로 사본이 만들어지지는 않는다. "
"슬라이스 표기법은 이럴 때 특히 편리하다::"

#: ../Doc/tutorial/controlflow.rst:81
msgid ""
"With ``for w in words:``, the example would attempt to create an infinite"
" list, inserting ``defenestrate`` over and over again."
msgstr ""
"``for w in words:`` 를 쓰면, 위의 예는 ``defenestrate`` 를 반복해서 넣고 또 "
"넣음으로써, 무한한 리스트를 만들려고 시도하게 된다."

#: ../Doc/tutorial/controlflow.rst:88
msgid "The :func:`range` Function"
msgstr ":func:`range` 함수"

#: ../Doc/tutorial/controlflow.rst:90
msgid ""
"If you do need to iterate over a sequence of numbers, the built-in "
"function :func:`range` comes in handy.  It generates arithmetic "
"progressions::"
msgstr ""
"숫자들의 시퀀스로 이터레이트할 필요가 있으면, 내장 함수 :func:`range` 가 편리하다. "
"수열을 만든다::"

#: ../Doc/tutorial/controlflow.rst:102
msgid ""
"The given end point is never part of the generated sequence; "
"``range(10)`` generates 10 values, the legal indices for items of a "
"sequence of length 10.  It is possible to let the range start at another "
"number, or to specify a different increment (even negative; sometimes "
"this is called the 'step')::"
msgstr ""
"끝값은 만들어지는 수열에 포함되지 않는다; ``range(10)`` 은 10개의 값을 만드는데, 길이 "
"10인 시퀀스의 항목들을 가리키는 올바른 인덱스들이다. 범위가 다른 숫자로 시작하거나, 다른 증가분을 "
"(음수조차 가능하다; 때로 이것을 '스텝(step)'이라고 부른다) 지정하는 것도 가능하다::"

#: ../Doc/tutorial/controlflow.rst:116
msgid ""
"To iterate over the indices of a sequence, you can combine :func:`range` "
"and :func:`len` as follows::"
msgstr ""
"시퀀스의 인덱스들로 이터레이트 하려면, 다음처럼 :func:`range` 와 :func:`len` 을 결합할 수 "
"있다::"

#: ../Doc/tutorial/controlflow.rst:129
msgid ""
"In most such cases, however, it is convenient to use the "
":func:`enumerate` function, see :ref:`tut-loopidioms`."
msgstr ""
"하지만, 그럴 때 대부분은, :func:`enumerate` 함수를 쓰는 것이 편리하다, "
":ref:`tut-loopidioms` 를 참고하라."

#: ../Doc/tutorial/controlflow.rst:132
msgid "A strange thing happens if you just print a range::"
msgstr "범위를 그냥 인쇄하면 이상한 일이 일어난다::"

#: ../Doc/tutorial/controlflow.rst:137
msgid ""
"In many ways the object returned by :func:`range` behaves as if it is a "
"list, but in fact it isn't. It is an object which returns the successive "
"items of the desired sequence when you iterate over it, but it doesn't "
"really make the list, thus saving space."
msgstr ""
"많은 경우에 :func:`range` 가 돌려준 객체는 리스트인 것처럼 동작하지만, 사실 리스트가 아니다. "
"이터레이트할 때 원하는 시퀀스 항목들을 순서대로 돌려주는 객체이지만, 실제로 리스트를 만들지 않아서 "
"공간을 절약한다."

#: ../Doc/tutorial/controlflow.rst:142
msgid ""
"We say such an object is *iterable*, that is, suitable as a target for "
"functions and constructs that expect something from which they can obtain"
" successive items until the supply is exhausted. We have seen that the "
":keyword:`for` statement is such an *iterator*. The function :func:`list`"
" is another; it creates lists from iterables::"
msgstr ""
"이런 객체를 *이터러블* 이라고 부른다. 공급이 소진될 때까지 일련의 항목들을 얻을 수 있는 "
"무엇인가를 기대하는 함수와 구조물들의 타깃으로 적합하다. 우리는 :keyword:`for` 문이 그런 "
"구조물임을 보았다. 함수 :func:`list` 도 그런 것이다; 이터러블로 리스트를 만든다::"

#: ../Doc/tutorial/controlflow.rst:152
msgid ""
"Later we will see more functions that return iterables and take iterables"
" as argument."
msgstr ""
"나중에 이터러블을 돌려주고 이터러블을 인자로 받는 함수들을 더 보게 된다."

#: ../Doc/tutorial/controlflow.rst:158
msgid ""
":keyword:`break` and :keyword:`continue` Statements, and :keyword:`else` "
"Clauses on Loops"
msgstr ""
"루프의 :keyword:`break` 와 :keyword:`continue` 문, 그리고 :keyword:`else` 절"

#: ../Doc/tutorial/controlflow.rst:160
msgid ""
"The :keyword:`break` statement, like in C, breaks out of the innermost "
"enclosing :keyword:`for` or :keyword:`while` loop."
msgstr ""
":keyword:`break` 문은, C처럼, 가장 가까이서 둘러싸는 :keyword:`for` 나 "
":keyword:`while` 루프로부터 빠져나가게 만든다."

#: ../Doc/tutorial/controlflow.rst:163
msgid ""
"Loop statements may have an ``else`` clause; it is executed when the loop"
" terminates through exhaustion of the list (with :keyword:`for`) or when "
"the condition becomes false (with :keyword:`while`), but not when the "
"loop is terminated by a :keyword:`break` statement.  This is exemplified "
"by the following loop, which searches for prime numbers::"
msgstr ""
"루프 문은 ``else`` 절을 가질 수 있다; 루프가 리스트의 소진이나 (:keyword:`for` 의 경우) "
"조건이 거짓이 돼서 (:keyword:`while` 의 경우) 종료할 때 실행된다. 하지만 루프가 "
":keyword:`break` 문으로 종료할 때는 실행되지 않는다. 소수를 찾는 루프를 통해 다음에서 예시한다::"

#: ../Doc/tutorial/controlflow.rst:187
msgid ""
"(Yes, this is the correct code.  Look closely: the ``else`` clause "
"belongs to the :keyword:`for` loop, **not** the :keyword:`if` statement.)"
msgstr ""
"(이것은 올바른 코드다. 자세히 들여다보면: ``else`` 절은 :keyword:`if` 문이 **아니라** "
":keyword:`for` 루프에 속한다.)"

#: ../Doc/tutorial/controlflow.rst:190
msgid ""
"When used with a loop, the ``else`` clause has more in common with the "
"``else`` clause of a :keyword:`try` statement than it does that of "
":keyword:`if` statements: a :keyword:`try` statement's ``else`` clause "
"runs when no exception occurs, and a loop's ``else`` clause runs when no "
"``break`` occurs. For more on the :keyword:`try` statement and "
"exceptions, see :ref:`tut-handling`."
msgstr ""
"루프와 함께 사용될 때, ``else`` 절은 :keyword:`if` 문보다는 :keyword:`try` 문의 "
"``else`` 절과 비슷한 면이 많다: :keyword:`try` 문의 ``else`` 절은 예외가 발생하지 않을 "
"때 실행되고, 루프의 ``else`` 절은 ``break`` 가 발생하지 않을 때 실행된다. "
":keyword:`try` 문과 예외에 관한 자세한 내용은 :ref:`tut-handling` 에 나온다."

#: ../Doc/tutorial/controlflow.rst:197
msgid ""
"The :keyword:`continue` statement, also borrowed from C, continues with "
"the next iteration of the loop::"
msgstr ""
":keyword:`continue` 문은, 역시 C에서 빌렸다, 루프의 다음 이터레이션에서 계속하도록 만든다::"

#: ../Doc/tutorial/controlflow.rst:217
msgid ":keyword:`pass` Statements"
msgstr ":keyword:`pass` 문"

#: ../Doc/tutorial/controlflow.rst:219
msgid ""
"The :keyword:`pass` statement does nothing. It can be used when a "
"statement is required syntactically but the program requires no action. "
"For example::"
msgstr ""
":keyword:`pass` 문은 아무것도 하지 않는다. 문법적으로 문장이 필요하지만, 프로그램이 특별히 "
"할 일이 없을 때 사용할 수 있다. 예를 들어::"

#: ../Doc/tutorial/controlflow.rst:226
msgid "This is commonly used for creating minimal classes::"
msgstr "최소한의 클래스를 만들 때 흔히 사용된다::"

#: ../Doc/tutorial/controlflow.rst:232
msgid ""
"Another place :keyword:`pass` can be used is as a place-holder for a "
"function or conditional body when you are working on new code, allowing "
"you to keep thinking at a more abstract level.  The :keyword:`pass` is "
"silently ignored::"
msgstr ""
":keyword:`pass` 가 사용될 수 있는 다른 장소는 새 코드를 작업할 때 함수나 조건부 바디의 "
"자리를 채우는 것인데, 여러분이 더 추상적인 수준에서 생각할 수 있게 한다. :keyword:`pass` "
"는 조용히 무시된다::"

#: ../Doc/tutorial/controlflow.rst:243
msgid "Defining Functions"
msgstr "함수 정의하기"

#: ../Doc/tutorial/controlflow.rst:245
msgid ""
"We can create a function that writes the Fibonacci series to an arbitrary"
" boundary::"
msgstr ""
"피보나치 수열을 임의의 한도까지 출력하는 함수를 만들 수 있다::"

#: ../Doc/tutorial/controlflow.rst:265
msgid ""
"The keyword :keyword:`def` introduces a function *definition*.  It must "
"be followed by the function name and the parenthesized list of formal "
"parameters. The statements that form the body of the function start at "
"the next line, and must be indented."
msgstr ""
"키워드 :keyword:`def` 는 함수 *정의* 를 시작한다. 함수 이름과 괄호로 싸인 형식 파라미터들의 "
"목록이 뒤따른다. 함수의 바디를 형성하는 문장들이 다음 줄에서 시작되고, 반드시 들여쓰기 되어야 한다."

#: ../Doc/tutorial/controlflow.rst:270
msgid ""
"The first statement of the function body can optionally be a string "
"literal; this string literal is the function's documentation string, or "
":dfn:`docstring`. (More about docstrings can be found in the section :ref"
":`tut-docstrings`.) There are tools which use docstrings to automatically"
" produce online or printed documentation, or to let the user "
"interactively browse through code; it's good practice to include "
"docstrings in code that you write, so make a habit of it."
msgstr ""
"함수 바디의 첫 번째 문장은 선택적으로 문자열 리터럴이 될 수 있다; 이 문자열 리터럴은 함수의 "
"토큐멘테이션 문자열, 즉 :dfn:`독스트링 (docstring)` 이다. (독스트링에 대한 자세한 내용은 "
":ref:`tut-docstrings` 에 나온다.) 독스트링을 사용해서 온라인이나 인쇄된 도큐멘테이션을 "
"자동 생성하거나, 사용자들이 대화형으로 코드를 열람할 수 있도록 하는 도구들이 있다; 여러분이 "
"작성하는 코드에 독스트링을 첨부하는 것은 좋은 관습이다, 그러니 버릇을 들이는 것이 좋다."

#: ../Doc/tutorial/controlflow.rst:277
msgid ""
"The *execution* of a function introduces a new symbol table used for the "
"local variables of the function.  More precisely, all variable "
"assignments in a function store the value in the local symbol table; "
"whereas variable references first look in the local symbol table, then in"
" the local symbol tables of enclosing functions, then in the global "
"symbol table, and finally in the table of built-in names. Thus, global "
"variables cannot be directly assigned a value within a function (unless "
"named in a :keyword:`global` statement), although they may be referenced."
msgstr ""
"함수의 *실행* 은 함수의 지역 변수들을 위한 새 심볼 테이블을 만든다. 좀 더 구체적으로, 함수에서의 "
"모든 변수 대입들은 값을 지역 심볼 테이블에 저장한다; 반면에 변수 참조는 먼저 지역 심볼 테이블을 본 "
"다음, 전역 심볼 테이블을 본 후, 마지막으로 내장 이름들의 테이블을 살핀다. 그래서, 참조될 수는 "
"있다 하더라도, 전역 변수들은 함수 내에서 (:keyword:`global` 문으로 명시하지 않는 이상) 직접 "
"값이 대입될 수 없다."

#: ../Doc/tutorial/controlflow.rst:286
msgid ""
"The actual parameters (arguments) to a function call are introduced in "
"the local symbol table of the called function when it is called; thus, "
"arguments are passed using *call by value* (where the *value* is always "
"an object *reference*, not the value of the object). [#]_ When a function"
" calls another function, a new local symbol table is created for that "
"call."
msgstr ""
"함수 호출로 전달되는 실제 파라미터들 (인자들)은 호출될 때 호출되는 함수의 지역 심볼 테이블에 "
"만들어진다; 그래서 인자들은 *값에 의한 호출 (call by value)* 로 전달된다 (*값* 은 항상 "
"객체의 값이 아니라 객체 *참조* 다). [#]_ 함수가 다른 함수를 호출할 때, 그 호출을 위한 새 지역 "
"심볼 테이블이 만들어진다."

#: ../Doc/tutorial/controlflow.rst:292
msgid ""
"A function definition introduces the function name in the current symbol "
"table. The value of the function name has a type that is recognized by "
"the interpreter as a user-defined function.  This value can be assigned "
"to another name which can then also be used as a function.  This serves "
"as a general renaming mechanism::"
msgstr ""
"함수 정의는 현재 심볼 테이블에 함수 이름을 만든다. 함수 이름의 값은 인터프리터가 사용자 정의 "
"함수로 인식하는 형이다. 이 값은 다른 이름에 대입될 수 있는데, 이 역시 함수로 사용될 수 있다. 이"
"것이 이름을 바꾸는 일반적인 방법이다::"

#: ../Doc/tutorial/controlflow.rst:304
msgid ""
"Coming from other languages, you might object that ``fib`` is not a "
"function but a procedure since it doesn't return a value.  In fact, even "
"functions without a :keyword:`return` statement do return a value, albeit"
" a rather boring one.  This value is called ``None`` (it's a built-in "
"name).  Writing the value ``None`` is normally suppressed by the "
"interpreter if it would be the only value written. You can see it if you "
"really want to using :func:`print`::"
msgstr ""
"다른 언어들을 사용했다면, ``fib`` 가 값을 돌려주지 않기 때문에 함수가 아니라 프로시저라고 생각할 "
"수 있다. 사실, :keyword:`return` 문이 없는 함수도 값을 돌려준다, 비록 따분한 값이기는 "
"하지만. 이 값은 ``None`` 이라고 불린다 (내장 이름이다). ``None`` 이 출력할 유일한 값이라면, "
"인터프리터는 보통 ``None`` 값 출력을 억제한다. 꼭 보길 원한다면 :func:`print` 를 사용할 수 "
"있다::"

#: ../Doc/tutorial/controlflow.rst:315
msgid ""
"It is simple to write a function that returns a list of the numbers of "
"the Fibonacci series, instead of printing it::"
msgstr ""
"인쇄하는 대신, 피보나치 수열의 숫자들 리스트를 돌려주는 함수를 작성하는 것도 간단하다::"

#: ../Doc/tutorial/controlflow.rst:331
msgid "This example, as usual, demonstrates some new Python features:"
msgstr "여느 때처럼, 이 예는 몇 가지 새 파이썬 기능을 보여준다:"

#: ../Doc/tutorial/controlflow.rst:333
msgid ""
"The :keyword:`return` statement returns with a value from a function. "
":keyword:`return` without an expression argument returns ``None``. "
"Falling off the end of a function also returns ``None``."
msgstr ""
":keyword:`return` 문은 함수로부터 값을 갖고 복귀하게 만든다. 표현식 인자 없는 "
":keyword:`return` 은 ``None`` 을 돌려준다. 함수의 끝으로 떨어지면 역시 ``None`` "
"을 돌려준다."

#: ../Doc/tutorial/controlflow.rst:337
msgid ""
"The statement ``result.append(a)`` calls a *method* of the list object "
"``result``.  A method is a function that 'belongs' to an object and is "
"named ``obj.methodname``, where ``obj`` is some object (this may be an "
"expression), and ``methodname`` is the name of a method that is defined "
"by the object's type. Different types define different methods.  Methods "
"of different types may have the same name without causing ambiguity.  (It"
" is possible to define your own object types and methods, using "
"*classes*, see :ref:`tut-classes`) The method :meth:`append` shown in the"
" example is defined for list objects; it adds a new element at the end of"
" the list.  In this example it is equivalent to ``result = result + "
"[a]``, but more efficient."
msgstr ""
"문장 ``result.append(a)`` 은 리스트 객체 ``result`` 의 *메서드* 를 호출한다. 메서드는 "
"객체에 '속하는' 함수이고 ``obj.methodname`` 라고 이름 붙여지는데, ``obj`` 는 어떤 객체이고 "
"(표현식이 될 수 있다), ``methodname`` 는 객체의 형에 의해 정의된 메서드의 이름이다. 다른 "
"형은 다른 메서드들을 정의한다. 서로 다른 형들의 메서드는 모호함 없이 같은 이름을 가질 수 있다. "
"(*클래스* 를 사용해서 여러분 자신의 형과 메서드를 정의하는 것이 가능하다, :ref:`tut-classes` "
"를 보면 된다) 예에 나오는 메서드 :meth:`append` 는 리스트 객체들에 정의되어 있다; 요소를 "
"리스트의 끝에 덧붙인다. 이 예에서는 ``result = result + [a]`` 와 동등하지만, 더 효율적이다."

#: ../Doc/tutorial/controlflow.rst:352
msgid "More on Defining Functions"
msgstr "함수 정의 더 보기"

#: ../Doc/tutorial/controlflow.rst:354
msgid ""
"It is also possible to define functions with a variable number of "
"arguments. There are three forms, which can be combined."
msgstr "정해지지 않은 개수의 인자들로 함수를 정의하는 것도 가능하다. 세 가지 형식이 있는데, 조합할 수 있다."

#: ../Doc/tutorial/controlflow.rst:361
msgid "Default Argument Values"
msgstr "기본 인자 값"

#: ../Doc/tutorial/controlflow.rst:363
msgid ""
"The most useful form is to specify a default value for one or more "
"arguments. This creates a function that can be called with fewer "
"arguments than it is defined to allow.  For example::"
msgstr "가장 쓸모 있는 형식은 하나나 그 이상 인자들의 기본값을 지정하는 것이다. 정의된 "
"것보다 더 적은 개수의 인자들로 호출될 수 있는 함수를 만든다. 예를 들어::"

#: ../Doc/tutorial/controlflow.rst:379
msgid "This function can be called in several ways:"
msgstr "이 함수는 여러 가지 방법으로 호출될 수 있다:"

#: ../Doc/tutorial/controlflow.rst:381
msgid ""
"giving only the mandatory argument: ``ask_ok('Do you really want to "
"quit?')``"
msgstr ""
"오직 꼭 필요한 인자만 전달해서: ``ask_ok('정말 끝내길 원하세요?')``"

#: ../Doc/tutorial/controlflow.rst:383
msgid ""
"giving one of the optional arguments: ``ask_ok('OK to overwrite the "
"file?', 2)``"
msgstr ""
"선택적 인자 하나를 제공해서: ``ask_ok('파일을 덮어써도 좋습니까?', 2)``"

#: ../Doc/tutorial/controlflow.rst:385
msgid ""
"or even giving all arguments: ``ask_ok('OK to overwrite the file?', 2, "
"'Come on, only yes or no!')``"
msgstr ""
"또는 모든 인자를 제공해서: ``ask_ok('파일을 덮어써도 좋습니까?', 2, '자, 예나 아니요로만 답하세요!')``"

#: ../Doc/tutorial/controlflow.rst:388
msgid ""
"This example also introduces the :keyword:`in` keyword. This tests "
"whether or not a sequence contains a certain value."
msgstr ""
"이 예는 :keyword:`in` 키워드도 소개하고 있다. 시퀀스가 어떤 값을 가졌는지 아닌지를 검사한다."

#: ../Doc/tutorial/controlflow.rst:391
msgid ""
"The default values are evaluated at the point of function definition in "
"the *defining* scope, so that ::"
msgstr ""
"기본값은 함수 정의 시점에 *정의되고 있는* 스코프에서 구해진다, 그래서 ::"

#: ../Doc/tutorial/controlflow.rst:402
msgid "will print ``5``."
msgstr "는 ``5`` 를 인쇄한다."

#: ../Doc/tutorial/controlflow.rst:404
msgid ""
"**Important warning:**  The default value is evaluated only once. This "
"makes a difference when the default is a mutable object such as a list, "
"dictionary, or instances of most classes.  For example, the following "
"function accumulates the arguments passed to it on subsequent calls::"
msgstr ""
"**중요한 주의사항:** 기본값은 오직 한 번만 값이 구해진다. 이것은 기본값이 리스트나 딕셔너리나 "
"대부분 클래스의 인스턴스와 같은 가변 객체일 때 차이를 만든다. 예를 들어, 다음 함수는 계속되는 "
"호출로 전달된 인자들을 누적한다::"

#: ../Doc/tutorial/controlflow.rst:417
msgid "This will print ::"
msgstr "다음과 같은 것을 인쇄한다 ::"

#: ../Doc/tutorial/controlflow.rst:423
msgid ""
"If you don't want the default to be shared between subsequent calls, you "
"can write the function like this instead::"
msgstr "연속된 호출 간에 기본값이 공유되지 않기를 원한다면, 대신 함수를 이런 식으로 쓸 수 있다::"

#: ../Doc/tutorial/controlflow.rst:436
msgid "Keyword Arguments"
msgstr "키워드 인자"

#: ../Doc/tutorial/controlflow.rst:438
msgid ""
"Functions can also be called using :term:`keyword arguments <keyword "
"argument>` of the form ``kwarg=value``.  For instance, the following "
"function::"
msgstr ""
"함수는 ``kwarg=value`` 형식의 :term:`키워드 인자 <keyword argument>` 를 사용해서 "
"호출될 수 있다. 예를 들어, 다음 함수는::"

#: ../Doc/tutorial/controlflow.rst:447
msgid ""
"accepts one required argument (``voltage``) and three optional arguments "
"(``state``, ``action``, and ``type``).  This function can be called in "
"any of the following ways::"
msgstr ""
"하나의 필수 인자 (``voltage``) 와 세 개의 선택적 인자 (``state``, ``action``, "
"``type``) 를 받아들인다. 이 함수는 다음과 같은 방법 중 아무것으로나 호출될 수 있다."

#: ../Doc/tutorial/controlflow.rst:458
msgid "but all the following calls would be invalid::"
msgstr "하지만 다음과 같은 호출들은 모두 올바르지 않다::"

#: ../Doc/tutorial/controlflow.rst:465
msgid ""
"In a function call, keyword arguments must follow positional arguments. "
"All the keyword arguments passed must match one of the arguments accepted"
" by the function (e.g. ``actor`` is not a valid argument for the "
"``parrot`` function), and their order is not important.  This also "
"includes non-optional arguments (e.g. ``parrot(voltage=1000)`` is valid "
"too). No argument may receive a value more than once. Here's an example "
"that fails due to this restriction::"
msgstr ""
"함수 호출에서, 키워드 인자는 위치 인자 뒤에 나와야 한다. 전달된 모든 키워드 인자는 함수가 "
"받아들이는 인자 중 하나와 맞아야 하며 (예를 들어, ``actor`` 는 ``parrot`` 함수의 올바른 "
"인자가 아니다), 그 순서는 중요하지 않다. 이것들에는 필수 인자들도 포함된다 (예를 들어, "
"``parrot(voltage=1000)`` 도 올바르다). 어떤 인자도 두 개 이상의 값을 받을 수 없다. 여기, "
"이 제약 때문에 실패하는 예가 있다::"

#: ../Doc/tutorial/controlflow.rst:481
msgid ""
"When a final formal parameter of the form ``**name`` is present, it "
"receives a dictionary (see :ref:`typesmapping`) containing all keyword "
"arguments except for those corresponding to a formal parameter.  This may"
" be combined with a formal parameter of the form ``*name`` (described in "
"the next subsection) which receives a tuple containing the positional "
"arguments beyond the formal parameter list.  (``*name`` must occur before"
" ``**name``.) For example, if we define a function like this::"
msgstr ""
"``**name`` 형식의 마지막 형식 파라미터가 존재하면, 형식 파라미터들에 대응하지 않는 모든 키워드 "
"인자들을 담은 딕셔너리 (:ref:`typesmapping` 를 보세요) 를 받는다. 이것은 ``*name`` "
"(다음 서브섹션에서 설명한다) 형식의 형식 파라미터와 조합될 수 있는데, 형식 파라미터 목록 밖의 위치 "
"인자들을 담은 튜플을 받는다. (``*name`` 은 ``**name`` 앞에 나와야 한다.) 예를 들어, 이런 "
"함수를 정의하면::"

#: ../Doc/tutorial/controlflow.rst:498
msgid "It could be called like this::"
msgstr "이런 식으로 호출될 수 있다::"

#: ../Doc/tutorial/controlflow.rst:506
msgid "and of course it would print:"
msgstr "그리고 당연히 이렇게 인쇄한다:"

#: ../Doc/tutorial/controlflow.rst:519
msgid ""
"Note that the order in which the keyword arguments are printed is "
"guaranteed to match the order in which they were provided in the function"
" call."
msgstr ""
"인쇄되는 키워드 인자들의 순서 함수 호출로 전달된 순서와 일치함이 보장됨에 주목하라."

#: ../Doc/tutorial/controlflow.rst:526
msgid "Arbitrary Argument Lists"
msgstr "임의의 인자 목록"

#: ../Doc/tutorial/controlflow.rst:531
msgid ""
"Finally, the least frequently used option is to specify that a function "
"can be called with an arbitrary number of arguments.  These arguments "
"will be wrapped up in a tuple (see :ref:`tut-tuples`).  Before the "
"variable number of arguments, zero or more normal arguments may occur. ::"
msgstr ""
"마지막으로, 가장 덜 사용되는 옵션은 함수가 임의의 개수 인자로 호출될 수 있도록 지정하는 것이다. "
"이 인자들은 튜플로 묶인다 (:ref:`tut-tuples` 을 보세요). 가변 길이 인자 앞에, 없거나 "
"여러 개의 일반 인자들이 올 수 있다."

#: ../Doc/tutorial/controlflow.rst:540
msgid ""
"Normally, these ``variadic`` arguments will be last in the list of formal"
" parameters, because they scoop up all remaining input arguments that are"
" passed to the function. Any formal parameters which occur after the "
"``*args`` parameter are 'keyword-only' arguments, meaning that they can "
"only be used as keywords rather than positional arguments. ::"
msgstr ""
"보통, 이 ``가변 길이`` 인자들은 형식 파라미터 목록의 마지막에 온다, 함수로 전달된 남은 입력 "
"인자들 전부를 그러모으기 때문이다. ``*args`` 파라미터 뒤에 등장하는 형식 파라미터들은 모두 "
"'키워드-전용' 인자들인데, 위치 인자 대신 키워드 인자로만 사용될 수 있다는 뜻이다. ::"

#: ../Doc/tutorial/controlflow.rst:557
msgid "Unpacking Argument Lists"
msgstr "인자 목록 언 패킹"

#: ../Doc/tutorial/controlflow.rst:559
msgid ""
"The reverse situation occurs when the arguments are already in a list or "
"tuple but need to be unpacked for a function call requiring separate "
"positional arguments.  For instance, the built-in :func:`range` function "
"expects separate *start* and *stop* arguments.  If they are not available"
" separately, write the function call with the  ``*``\\ -operator to "
"unpack the arguments out of a list or tuple::"
msgstr ""
"인자들이 이미 리스트나 튜플에 있지만, 분리된 위치 인자들을 요구하는 함수 호출을 위해 언 패킹 해야 "
"하는 경우 반대 상황이 벌어진다. 예를 들어, 내장 :func:`range` 함수는 별도의 *start* 와 "
"*stop* 인자를 기대한다. 그것들이 따로 있지 않으면, 리스트와 튜플로부터 인자를 언 패킹하기 "
"위해 ``*``\\ -연산자를 사용해서 함수를 호출하면 된다::"

#: ../Doc/tutorial/controlflow.rst:575
msgid ""
"In the same fashion, dictionaries can deliver keyword arguments with the "
"``**``\\ -operator::"
msgstr ""
"같은 방식으로 딕셔너리도 ``**``\\ -연산자를 써서 키워드 인자를 전달할 수 있다::"

#: ../Doc/tutorial/controlflow.rst:591
msgid "Lambda Expressions"
msgstr "람다 표현식"

#: ../Doc/tutorial/controlflow.rst:593
msgid ""
"Small anonymous functions can be created with the :keyword:`lambda` "
"keyword. This function returns the sum of its two arguments: ``lambda a, "
"b: a+b``. Lambda functions can be used wherever function objects are "
"required.  They are syntactically restricted to a single expression.  "
"Semantically, they are just syntactic sugar for a normal function "
"definition.  Like nested function definitions, lambda functions can "
"reference variables from the containing scope::"
msgstr ""
":keyword:`lambda` 키워드들 사용해서 작고 이름 없는 함수를 만들 수 있다. 이 함수는 두 인자의 "
"합을 돌려준다: ``lambda a, b: a+b``. 함수 객체가 있어야 하는 곳이면 어디나 람다 함수가 "
"사용될 수 있다. 문법적으로는 하나의 표현식으로 제한된다. 의미적으로는, 일반적인 함수 정의의 편의 "
"문법일 뿐이다. 중첩된 함수 정의처럼, 람다 함수는 둘러싸는 스코프에 있는 변수들을 참조할 수 있다::"

#: ../Doc/tutorial/controlflow.rst:610
msgid ""
"The above example uses a lambda expression to return a function.  Another"
" use is to pass a small function as an argument::"
msgstr ""
"위의 예는 함수를 돌려주기 위해 람다 표현식을 사용한다. 또 다른 용도는 작은 함수를 인자로 전달하는 "
"것이다::"

#: ../Doc/tutorial/controlflow.rst:622
msgid "Documentation Strings"
msgstr "도큐멘테이션 문자열"

#: ../Doc/tutorial/controlflow.rst:629
msgid ""
"Here are some conventions about the content and formatting of "
"documentation strings."
msgstr ""
"여기에 도큐멘테이션 문자열의 내용과 포매팅에 관한 몇 가지 관례가 있다."

#: ../Doc/tutorial/controlflow.rst:632
msgid ""
"The first line should always be a short, concise summary of the object's "
"purpose.  For brevity, it should not explicitly state the object's name "
"or type, since these are available by other means (except if the name "
"happens to be a verb describing a function's operation).  This line "
"should begin with a capital letter and end with a period."
msgstr ""
"첫 줄은 항상 객체의 목적을 짧고, 간결하게 요약해야 한다. 간결함을 위해, 객체의 이름이나 형을 "
"명시적으로 언급하지 않아야 하는데, 이것들은 다른 방법으로 제공되기 때문이다 (이름이 함수의 작업을 "
"설명하는 동사라면 예외다). 이 줄은 대문자로 시작하고 마침표로 끝나야 한다."

#: ../Doc/tutorial/controlflow.rst:638
msgid ""
"If there are more lines in the documentation string, the second line "
"should be blank, visually separating the summary from the rest of the "
"description.  The following lines should be one or more paragraphs "
"describing the object's calling conventions, its side effects, etc."
msgstr ""
"도큐멘테이션 문자열에 여러 줄이 있다면, 두 번째 줄은 비어있어서, 시각적으로 요약과 나머지 "
"설명을 분리해야 한다. 뒤따르는 줄들은 하나나 그 이상의 문단으로, 객체의 호출 규약, 부수적 "
"효과 등을 설명해야 한다."

#: ../Doc/tutorial/controlflow.rst:643
msgid ""
"The Python parser does not strip indentation from multi-line string "
"literals in Python, so tools that process documentation have to strip "
"indentation if desired.  This is done using the following convention. The"
" first non-blank line *after* the first line of the string determines the"
" amount of indentation for the entire documentation string.  (We can't "
"use the first line since it is generally adjacent to the string's opening"
" quotes so its indentation is not apparent in the string literal.)  "
"Whitespace \"equivalent\" to this indentation is then stripped from the "
"start of all lines of the string.  Lines that are indented less should "
"not occur, but if they occur all their leading whitespace should be "
"stripped.  Equivalence of whitespace should be tested after expansion of "
"tabs (to 8 spaces, normally)."
msgstr ""
"파이썬 파서는 여러 줄 문자열 리터럴에서 들여쓰기를 제거하지 않기 때문에, 도큐멘테이션을 처리하는 "
"도구들은 필요하면 들여쓰기를 제거한다. 이것은 다음과 같은 관례를 사용한다. 문자열의 첫줄 "
"*뒤에 오는* 첫 번째 비어있지 않은 줄이 전체 도튜멘테이션 문자열의 들여쓰기 수준을 결정한다. "
"(우리는 첫 줄을 사용할 수 없는데, 일반적으로 문자열을 시작하는 따옴표에 붙어있어서 들여쓰기가 "
"문자열 리터럴의 것을 반영하지 않기 때문이다.) 이 들여쓰기와 \"동등한\" 공백이 문자열의 모든 줄의 "
"시작 부분에서 제거된다. 덜 들여쓰기 된 줄이 나타나지는 말아야 하지만, 나타난다면 모든 앞부분의 "
"공백이 제거된다. 공백의 동등성은 탭 확장 (보통 8개의 스페이스) 후에 검사된다."

#: ../Doc/tutorial/controlflow.rst:655
msgid "Here is an example of a multi-line docstring::"
msgstr "여기 여러 줄 독스트링의 예가 있다::"

#: ../Doc/tutorial/controlflow.rst:673
msgid "Function Annotations"
msgstr "함수 어노테이션"

#: ../Doc/tutorial/controlflow.rst:680
msgid ""
":ref:`Function annotations <function>` are completely optional metadata "
"information about the types used by user-defined functions (see "
":pep:`484` for more information)."
msgstr ""
":ref:`함수 어노테이션 <function>` 은 사용자 정의 함수가 사용하는 형들에 대한 완전히 선택적인 "
"메타데이터 정보다 (자세한 내용은 :pep:`484` 에 나온다)."

#: ../Doc/tutorial/controlflow.rst:684
msgid ""
"Annotations are stored in the :attr:`__annotations__` attribute of the "
"function as a dictionary and have no effect on any other part of the "
"function.  Parameter annotations are defined by a colon after the "
"parameter name, followed by an expression evaluating to the value of the "
"annotation.  Return annotations are defined by a literal ``->``, followed"
" by an expression, between the parameter list and the colon denoting the "
"end of the :keyword:`def` statement.  The following example has a "
"positional argument, a keyword argument, and the return value annotated::"
msgstr ""
"어노테이션은 함수의 :attr:`__annotations__` 어트리뷰트에 딕셔너리로 저장되고 함수의 다른 "
"부분에는 아무런 영향을 미치지 않는다. 파라미터 어노테이션은 파라미터 이름 뒤에 오는 콜론으로 "
"정의되는데, 값을 구할 때 어노테이션의 값을 주는 표현식이 뒤따른다. 반환 값 어노테이션은 리터럴 "
"``->`` 와 그 뒤를 따르는 표현식으로 정의되는데, 파라미터 목록과 :keyword:`def` 문의 끝을 "
"나타내는 콜론 사이에 놓인다. 다음 예에서 위치 인자, 키워드 인자, 반환 값이 어노테이트 된다::"

#: ../Doc/tutorial/controlflow.rst:706
msgid "Intermezzo: Coding Style"
msgstr "막간극: 코딩 스타일"

#: ../Doc/tutorial/controlflow.rst:711
msgid ""
"Now that you are about to write longer, more complex pieces of Python, it"
" is a good time to talk about *coding style*.  Most languages can be "
"written (or more concise, *formatted*) in different styles; some are more"
" readable than others. Making it easy for others to read your code is "
"always a good idea, and adopting a nice coding style helps tremendously "
"for that."
msgstr ""
"이제 여러분은 파이썬의 더 길고, 더 복잡한 조각들을 작성하려고 한다, *코딩 스타일* 에 대해 말할 "
"적절한 시간이다. 대부분 언어는 서로 다른 스타일로 작성될 (또는 더 간략하게, *포맷될*) 수 "
"있다; 어떤 것들은 다른 것들보다 더 읽기 쉽다. 다른 사람들이 여러분의 코드를 읽기 쉽게 만드는 것은 "
"항상 좋은 생각이고, 훌륭한 코딩 스타일을 도입하는 것은 그렇게 하는 데 큰 도움을 준다."

#: ../Doc/tutorial/controlflow.rst:717
msgid ""
"For Python, :pep:`8` has emerged as the style guide that most projects "
"adhere to; it promotes a very readable and eye-pleasing coding style.  "
"Every Python developer should read it at some point; here are the most "
"important points extracted for you:"
msgstr ""
"파이썬을 위해, 대부분 프로젝트가 고수하는 스타일 가이드로 :pep:`8` 이 나왔다; 이것은 매우 "
"읽기 쉽고 눈이 편안한 코딩 스타일을 장려한다. 모든 파이썬 개발자는 언젠가는 이 문서를 읽어야 한다; "
"여러분을 위해 가장 중요한 부분들을 추려봤다::"

#: ../Doc/tutorial/controlflow.rst:722
msgid "Use 4-space indentation, and no tabs."
msgstr "들려 쓰기에 4-스페이스를 사용하고, 탭을 사용하지 말라."

#: ../Doc/tutorial/controlflow.rst:724
msgid ""
"4 spaces are a good compromise between small indentation (allows greater "
"nesting depth) and large indentation (easier to read).  Tabs introduce "
"confusion, and are best left out."
msgstr ""
"4개의 스페이스는 작은 들여쓰기 (더 많은 중첩 도를 허락한다) 와 큰 들여쓰기 (읽기 쉽다) 사이의 좋은 "
"절충이다. 탭은 혼란을 일으키고, 없애는 것이 최선이다."

#: ../Doc/tutorial/controlflow.rst:728
msgid "Wrap lines so that they don't exceed 79 characters."
msgstr "79자를 넘지 않도록 줄 넘김 하라."

#: ../Doc/tutorial/controlflow.rst:730
msgid ""
"This helps users with small displays and makes it possible to have "
"several code files side-by-side on larger displays."
msgstr ""
"이것은 작은 화면을 가진 사용자를 돕고 큰 화면에서는 여러 코드 파일들을 나란히 볼 수 있게 한다."

#: ../Doc/tutorial/controlflow.rst:733
msgid ""
"Use blank lines to separate functions and classes, and larger blocks of "
"code inside functions."
msgstr ""
"함수, 클래스, 함수 내의 큰 코드 블록 사이에 빈 줄을 넣어 분리하라."

#: ../Doc/tutorial/controlflow.rst:736
msgid "When possible, put comments on a line of their own."
msgstr "가능하다면, 주석은 별도의 줄로 넣어라."

#: ../Doc/tutorial/controlflow.rst:738
msgid "Use docstrings."
msgstr "독스트링을 사용하라."

#: ../Doc/tutorial/controlflow.rst:740
msgid ""
"Use spaces around operators and after commas, but not directly inside "
"bracketing constructs: ``a = f(1, 2) + g(3, 4)``."
msgstr ""
"연산자들 주변과 콤마 뒤에 스페이스를 넣고, 괄호 바로 안쪽에는 스페이스를 넣지 마라: "
"``a = f(1, 2) + g(3, 4)``."

#: ../Doc/tutorial/controlflow.rst:743
msgid ""
"Name your classes and functions consistently; the convention is to use "
"``CamelCase`` for classes and ``lower_case_with_underscores`` for "
"functions and methods.  Always use ``self`` as the name for the first "
"method argument (see :ref:`tut-firstclasses` for more on classes and "
"methods)."
msgstr ""
"클래스와 함수들에 일관성 있는 이름을 붙여라; 관례는 클래스의 경우 ``CamelCase``, 함수와 "
"메서드의 경우 ``lower_case_with_underscores`` 다. 첫 번째 메서드 인자의 이름으로는 "
"항상 ``self`` 를 사용하라 (클래스와 메서드에 대한 자세한 내용은 :ref:`tut-firstclasses` "
"에서 다룬다)."

#: ../Doc/tutorial/controlflow.rst:748
msgid ""
"Don't use fancy encodings if your code is meant to be used in "
"international environments.  Python's default, UTF-8, or even plain ASCII"
" work best in any case."
msgstr ""
"여러분의 코드를 국제적인 환경에서 사용하려고 한다면 특별한 인코딩을 사용하지 말라. 어떤 경우에도 "
"파이썬의 기본, UTF-8, 또는 단순 ASCII조차, 이 최선이다."

#: ../Doc/tutorial/controlflow.rst:752
msgid ""
"Likewise, don't use non-ASCII characters in identifiers if there is only "
"the slightest chance people speaking a different language will read or "
"maintain the code."
msgstr ""
"마찬가지로, 다른 언어를 사용하는 사람이 코드를 읽거나 유지할 약간의 가능성만 있더라도, 식별자에 "
"ASCII 이외의 문자를 사용하지 말라."

#: ../Doc/tutorial/controlflow.rst:758
msgid "Footnotes"
msgstr "각주"

#: ../Doc/tutorial/controlflow.rst:759
msgid ""
"Actually, *call by object reference* would be a better description, since"
" if a mutable object is passed, the caller will see any changes the "
"callee makes to it (items inserted into a list)."
msgstr ""
"실제로, *객체 참조에 의한 호출 (call by object reference)* 이 더 좋은 표현인데, 가변 "
"객체가 전달되면, 호출자는 피호출자가 만든 변경을 볼 수 있기 때문이다 (가령 리스트에 항목을 추가한다)."

