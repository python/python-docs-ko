# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-07-08 11:36+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/tutorial/modules.rst:5
msgid "Modules"
msgstr "모듈"

#: ../Doc/tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the "
"definitions you have made (functions and variables) are lost. Therefore, "
"if you want to write a somewhat longer program, you are better off using "
"a text editor to prepare the input for the interpreter and running it "
"with that file as input instead.  This is known as creating a *script*.  "
"As your program gets longer, you may want to split it into several files "
"for easier maintenance.  You may also want to use a handy function that "
"you've written in several programs without copying its definition into "
"each program."
msgstr ""
"파이썬 인터프리터를 종료한 후에 다시 들어가면, 여러분이 만들었던 정의들이 사라집니다 (함수나 변수들). 그래서, 좀 긴 프로그램을"
" 쓰고자 한다면, 대신 인터프리터 입력을 편집기를 사용해서 준비한 후에 그 파일을 입력으로 사용해서 실행하는 것이 좋습니다. 이렇게"
" 하는 것을 *스크립트* 를 만든다고 합니다. 프로그램이 길어짐에 따라, 유지를 쉽게 하려고 여러 개의 파일로 나누고 싶을 수 "
"있습니다. 여러 프로그램에서 썼던 편리한 함수를 각 프로그램에 정의를 복사하지 않고도 사용하고 싶을 수도 있습니다."

#: ../Doc/tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use "
"them in a script or in an interactive instance of the interpreter. Such a"
" file is called a *module*; definitions from a module can be *imported* "
"into other modules or into the *main* module (the collection of variables"
" that you have access to in a script executed at the top level and in "
"calculator mode)."
msgstr ""
"이런 것을 지원하기 위해, 파이썬은 정의들을 파일에 넣고 스크립트나 인터프리터의 대화형 모드에서 사용할 수 있는 방법을 제공합니다."
" 그런 파일을 *모듈* 이라고 부릅니다; 모듈로부터 정의들이 다른 모듈이나 *메인* 모듈로 *임포트* 될 수 있습니다 (메인 모듈은"
" 최상위 수준에서 실행되는 스크립트나 계산기 모드에서 액세스하는 변수들의 컬렉션입니다)."

#: ../Doc/tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The "
"file name is the module name with the suffix :file:`.py` appended.  "
"Within a module, the module's name (as a string) is available as the "
"value of the global variable ``__name__``.  For instance, use your "
"favorite text editor to create a file called :file:`fibo.py` in the "
"current directory with the following contents::"
msgstr ""
"모듈은 파이썬 정의와 문장들을 담고 있는 파일입니다. 파일의 이름은 모듈 이름에 확장자 :file:`.py` 를 붙입니다. 모듈 "
"내에서, 모듈의 이름은 전역 변수 ``__name__`` 으로 제공됩니다. 예를 들어, 여러분이 좋아하는 편집기로 "
":file:`fibo.py` 라는 이름의 파일을 현재 디렉터리에 만들고 다음과 같은 내용으로 채웁니다::"

#: ../Doc/tutorial/modules.rst:45
msgid ""
"Now enter the Python interpreter and import this module with the "
"following command::"
msgstr "이제 파이썬 인터프리터에 들어가서 이 모듈을 다음과 같은 명령으로 임포트 합니다::"

#: ../Doc/tutorial/modules.rst:50
msgid ""
"This does not enter the names of the functions defined in ``fibo``  "
"directly in the current symbol table; it only enters the module name "
"``fibo`` there. Using the module name you can access the functions::"
msgstr ""
"이렇게 한다고 ``fibo`` 에 정의된 함수들의 이름이 현재 심볼 테이블에 직접 들어가지는 않습니다; 오직 모듈 이름 "
"``fibo`` 만 들어갈 뿐입니다. 이 모듈 이름을 사용해서 함수들을 액세스할 수 있습니다::"

#: ../Doc/tutorial/modules.rst:61
msgid "If you intend to use a function often you can assign it to a local name::"
msgstr "함수를 자주 사용할 거라면 지역 이름으로 대입할 수 있습니다::"

#: ../Doc/tutorial/modules.rst:71
msgid "More on Modules"
msgstr "모듈 더 보기"

#: ../Doc/tutorial/modules.rst:73
msgid ""
"A module can contain executable statements as well as function "
"definitions. These statements are intended to initialize the module. They"
" are executed only the *first* time the module name is encountered in an "
"import statement. [#]_ (They are also run if the file is executed as a "
"script.)"
msgstr ""
"모듈은 함수 정의뿐만 아니라 실행 가능한 문장들도 포함할 수 있습니다. 이 문장들은 모듈을 초기화하는 데 사용됩니다. 이것들은 "
"임포트 문에서 모듈 이름이 *처음* 등장할 때만 실행됩니다. [#]_ (이것들은 파일이 스크립트로 실행될 때도 실행됩니다.)"

#: ../Doc/tutorial/modules.rst:78
msgid ""
"Each module has its own private symbol table, which is used as the global"
" symbol table by all functions defined in the module. Thus, the author of"
" a module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if "
"you know what you are doing you can touch a module's global variables "
"with the same notation used to refer to its functions, "
"``modname.itemname``."
msgstr ""
"각 모듈은 자신만의 심볼 테이블을 갖고 있는데, 그 모듈에서 정의된 함수들의 전역 심볼 테이블로 사용됩니다. 그래서, 모듈의 저자는"
" 사용자의 전역 변수와 우연히 충돌할 것을 걱정하지 않고 전역 변수를 사용할 수 있습니다. 반면에, 여러분이 무얼 하는지 안다면, "
"모듈의 함수를 참조하는데 사용된 것과 같은 표기법으로 모듈의 전역 변수들을 건드릴 수 있습니다, "
"``modname.itemname``."

#: ../Doc/tutorial/modules.rst:85
msgid ""
"Modules can import other modules.  It is customary but not required to "
"place all :keyword:`import` statements at the beginning of a module (or "
"script, for that matter).  The imported module names are placed in the "
"importing module's global symbol table."
msgstr ""
"모듈은 다른 모듈들을 임포트할 수 있습니다. 모든 :keyword:`import` 문들을 모듈의 처음에 놓는 것이 관례지만 반드시 "
"그래야 하는 것은 아닙니다 (그 점에 관한 한 스크립트도 마찬가집니다). 임포트되는 모듈 이름은 임포트하는 모듈의 전역 심볼 "
"테이블에 들어갑니다."

#: ../Doc/tutorial/modules.rst:90
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's symbol table.  For "
"example::"
msgstr ""
"모듈에 들어있는 이름들을 직접 임포트하는 모듈의 심볼 테이블로 임포트하는 :keyword:`import` 문의 변종이 있습니다. "
"예를 들어::"

#: ../Doc/tutorial/modules.rst:97
msgid ""
"This does not introduce the module name from which the imports are taken "
"in the local symbol table (so in the example, ``fibo`` is not defined)."
msgstr "이것은 지역 심볼 테이블에 임포트되는 모듈의 이름을 만들지 않습니다 (그래서 이 예에서는, ``fibo`` 가 정의되지 않습니다)."

#: ../Doc/tutorial/modules.rst:100
msgid "There is even a variant to import all names that a module defines::"
msgstr "모듈이 정의하는 모든 이름을 임포트하는 변종도 있습니다::"

#: ../Doc/tutorial/modules.rst:106
msgid ""
"This imports all names except those beginning with an underscore (``_``)."
" In most cases Python programmers do not use this facility since it "
"introduces an unknown set of names into the interpreter, possibly hiding "
"some things you have already defined."
msgstr ""
"이것은 밑줄 (``_``) 로 시작하는 것들을 제외한 모든 이름을 임포트 합니다. 대부분 파이썬 프로그래머들은 이 기능을 사용하지 "
"않는데, 인터프리터로 알려지지 않은 이름들의 집합을 도입하게 되어, 여러분이 이미 정의한 것들을 가리게 될 수 있기 때문입니다."

#: ../Doc/tutorial/modules.rst:111
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"일반적으로 모듈이나 패키지에서 ``*`` 를 임포트하는 것은 눈살을 찌푸리게 한다는 것에 유의하세요, 종종 읽기에 편하지 않은 "
"코드를 만들기 때문입니다. 하지만, 대화형 세션에서 입력을 줄이고자 사용하는 것은 상관없습니다."

#: ../Doc/tutorial/modules.rst:115
msgid ""
"If the module name is followed by :keyword:`as`, then the name following "
":keyword:`as` is bound directly to the imported module."
msgstr "모듈 이름 다음에 :keyword:`as` 가 올 경우, :keyword:`as` 다음의 이름을 임포트한 모듈에 직접 연결합니다."

#: ../Doc/tutorial/modules.rst:124
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as "
"``fib``."
msgstr ""
"이것은 ``import fibo`` 가하는 것과 같은 방식으로 모듈을 임포트 하는데, 유일한 차이점은 그 모듈을 ``fib`` 라는"
" 이름으로 사용할 수 있다는 것입니다."

#: ../Doc/tutorial/modules.rst:127
msgid "It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ":keyword:`from`\\을 써서 비슷한 효과를 낼 때도 사용할 수 있습니다::"

#: ../Doc/tutorial/modules.rst:136
msgid ""
"For efficiency reasons, each module is only imported once per interpreter"
" session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test "
"interactively, use :func:`importlib.reload`, e.g. ``import importlib; "
"importlib.reload(modulename)``."
msgstr ""
"효율성의 이유로, 각 모듈은 인터프리터 세션마다 한 번만 임포트됩니다. 그래서, 여러분이 모듈을 수정하면, 인터프리터를 다시 "
"시작시켜야 합니다 --- 또는, 대화형으로 시험하는 모듈이 하나뿐이라면, :func:`importlib.reload` 를 "
"사용하세요. 예를 들어, ``import importlib; importlib.reload(modulename)``."

#: ../Doc/tutorial/modules.rst:146
msgid "Executing modules as scripts"
msgstr "모듈을 스크립트로 실행하기"

#: ../Doc/tutorial/modules.rst:148
msgid "When you run a Python module with ::"
msgstr "여러분이 파이썬 모듈을 이렇게 실행하면 ::"

#: ../Doc/tutorial/modules.rst:152
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding"
" this code at the end of your module::"
msgstr ""
"모듈에 있는 코드는, 그것을 임포트할 때처럼 실행됩니다. 하지만 ``__name__`` 은 ``\"__main__\"`` 로 "
"설정됩니다. 이것은, 이 코드를 모듈의 끝에 붙여서::"

#: ../Doc/tutorial/modules.rst:160
msgid ""
"you can make the file usable as a script as well as an importable module,"
" because the code that parses the command line only runs if the module is"
" executed as the \"main\" file:"
msgstr ""
"파일을 임포트할 수 있는 모듈뿐만 아니라 스크립트로도 사용할 수 있도록 만들 수 있음을 의미하는데, 오직 모듈이 \"메인\" 파일로"
" 실행될 때만 명령행을 파싱하는 코드가 실행되기 때문입니다:"

#: ../Doc/tutorial/modules.rst:169
msgid "If the module is imported, the code is not run::"
msgstr "모듈이 임포트될 때, 코드는 실행되지 않습니다::"

#: ../Doc/tutorial/modules.rst:174
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes "
"a test suite)."
msgstr ""
"이것은 종종 모듈에 대한 편리한 사용자 인터페이스를 제공하거나 테스트 목적으로 사용됩니다 (모듈을 스크립트로 실행하면 테스트 "
"스위트를 실행하기)."

#: ../Doc/tutorial/modules.rst:181
msgid "The Module Search Path"
msgstr "모듈 검색 경로"

#: ../Doc/tutorial/modules.rst:185
msgid ""
"When a module named :mod:`spam` is imported, the interpreter first "
"searches for a built-in module with that name. If not found, it then "
"searches for a file named :file:`spam.py` in a list of directories given "
"by the variable :data:`sys.path`.  :data:`sys.path` is initialized from "
"these locations:"
msgstr ""
":mod:`spam` 이라는 이름의 모듈이 임포트될 때, 인터프리터는 먼저 그 이름의 내장 모듈을 찾습니다. 발견되지 않으면, 변수"
" :data:`sys.path` 로 주어지는 디렉터리들에서 :file:`spam.py` 라는 이름의 파일을 찾습니다. "
":data:`sys.path` 는 이 위치들로 초기화됩니다:"

#: ../Doc/tutorial/modules.rst:190
msgid ""
"The directory containing the input script (or the current directory when "
"no file is specified)."
msgstr "입력 스크립트를 포함하는 디렉터리 (또는 파일이 지정되지 않았을 때는 현재 디렉터리)."

#: ../Doc/tutorial/modules.rst:192
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as "
"the shell variable :envvar:`PATH`)."
msgstr ":envvar:`PYTHONPATH` (디렉터리 이름들의 목록, 셸 변수 :envvar:`PATH` 와 같은 문법)."

#: ../Doc/tutorial/modules.rst:194
msgid "The installation-dependent default."
msgstr "설치 의존적인 기본값"

#: ../Doc/tutorial/modules.rst:197
msgid ""
"On file systems which support symlinks, the directory containing the "
"input script is calculated after the symlink is followed. In other words "
"the directory containing the symlink is **not** added to the module "
"search path."
msgstr ""
"심볼릭 링크를 지원하는 파일 시스템에서, 입력 스크립트를 포함하는 디렉터리는 심볼릭 링크를 변환한 후에 계산됩니다. 다른 말로, "
"심볼릭 링크를 포함하는 디렉터리는 모듈 검색 경로에 포함되지 **않습니다**."

#: ../Doc/tutorial/modules.rst:201
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of "
"the search path, ahead of the standard library path. This means that "
"scripts in that directory will be loaded instead of modules of the same "
"name in the library directory. This is an error unless the replacement is"
" intended.  See section :ref:`tut-standardmodules` for more information."
msgstr ""
"초기화 후에, 파이썬 프로그램은 :data:`sys.path` 를 수정할 수 있습니다. 스크립트를 포함하는 디렉터리는 검색 경로의 "
"처음에, 표준 라이브러리 경로의 앞에 놓입니다. 이것은 같은 이름일 경우 라이브러리 디렉터리에 있는 것 대신 스크립트를 포함하는 "
"디렉터리의 것이 로드된다는 뜻입니다. 이 치환이 의도된 것이 아니라면 에러입니다. 더 자세한 정보는 :ref:`tut-"
"standardmodules` 을 보세요."

#: ../Doc/tutorial/modules.rst:212
msgid "\"Compiled\" Python files"
msgstr "\"컴파일된\" 파이썬 파일"

#: ../Doc/tutorial/modules.rst:214
msgid ""
"To speed up loading modules, Python caches the compiled version of each "
"module in the ``__pycache__`` directory under the name "
":file:`module.{version}.pyc`, where the version encodes the format of the"
" compiled file; it generally contains the Python version number.  For "
"example, in CPython release 3.3 the compiled version of spam.py would be "
"cached as ``__pycache__/spam.cpython-33.pyc``.  This naming convention "
"allows compiled modules from different releases and different versions of"
" Python to coexist."
msgstr ""
"모듈 로딩을 빠르게 하려고, 파이썬은 ``__pycache__`` 디렉터리에 각 모듈의 컴파일된 버전을 "
":file:`module.{version}.pyc` 라는 이름으로 캐싱합니다. version 은 컴파일된 파일의 형식을 지정합니다;"
" 일반적으로 파이썬의 버전 번호를 포함합니다. 예를 들어, CPython 배포 3.3 에서 spam.py 의 컴파일된 버전은 "
"``__pycache__/spam.cpython-33.pyc`` 로 캐싱 됩니다. 이 명명법은 서로 다른 파이썬 배포와 버전의 "
"컴파일된 모듈들이 공존할 수 있도록 합니다."

#: ../Doc/tutorial/modules.rst:222
msgid ""
"Python checks the modification date of the source against the compiled "
"version to see if it's out of date and needs to be recompiled.  This is a"
" completely automatic process.  Also, the compiled modules are platform-"
"independent, so the same library can be shared among systems with "
"different architectures."
msgstr ""
"파이썬은 소스의 수정 시간을 컴파일된 버전과 비교해서 시효가 지나 다시 컴파일해야 하는지 검사합니다. 이것은 완전히 자동화된 "
"과정입니다. 또한, 컴파일된 모듈은 플랫폼 독립적이기 때문에, 같은 라이브러리를 서로 다른 아키텍처를 갖는 시스템들에서 공유할 수 "
"있습니다."

#: ../Doc/tutorial/modules.rst:227
msgid ""
"Python does not check the cache in two circumstances.  First, it always "
"recompiles and does not store the result for the module that's loaded "
"directly from the command line.  Second, it does not check the cache if "
"there is no source module.  To support a non-source (compiled only) "
"distribution, the compiled module must be in the source directory, and "
"there must not be a source module."
msgstr ""
"파이썬은 두 가지 상황에서 캐시를 검사하지 않습니다. 첫째로, 명령행에서 직접 로드되는 모듈들은 항상 재컴파일하고 그 결과를 "
"저장하지 않습니다. 둘째로, 소스 모듈이 없으면 캐시를 검사하지 않습니다. 소스 없는 (컴파일된 파일만 있는) 배포를 지원하려면, "
"컴파일된 모듈이 소스 디렉터리에 있어야 하고, 소스 모듈이 없어야 합니다."

#: ../Doc/tutorial/modules.rst:234
msgid "Some tips for experts:"
msgstr "전문가를 위한 몇 가지 팁"

#: ../Doc/tutorial/modules.rst:236
msgid ""
"You can use the :option:`-O` or :option:`-OO` switches on the Python "
"command to reduce the size of a compiled module.  The ``-O`` switch "
"removes assert statements, the ``-OO`` switch removes both assert "
"statements and __doc__ strings.  Since some programs may rely on having "
"these available, you should only use this option if you know what you're "
"doing.  \"Optimized\" modules have an ``opt-`` tag and are usually "
"smaller.  Future releases may change the effects of optimization."
msgstr ""
"컴파일된 모듈의 크기를 줄이려면 파이썬 명령에 :option:`-O` 나 :option:`-OO` 스위치를 사용할 수 있습니다. "
"``-O`` 스위치는 assert 문을 제거하고, ``-OO`` 스위치는 assert 문과 __doc__ 문자열을 모두 제거합니다."
" 어떤 프로그램들은 이것들에 의존하기 때문에, 무엇을 하고 있는지 아는 경우만 이 옵션을 사용해야 합니다. \"최적화된\" 모듈은 "
"``opt-`` 태그를 갖고, 보통 더 작습니다. 미래의 배포에서는 최적화의 효과가 변경될 수 있습니다."

#: ../Doc/tutorial/modules.rst:244
msgid ""
"A program doesn't run any faster when it is read from a ``.pyc`` file "
"than when it is read from a ``.py`` file; the only thing that's faster "
"about ``.pyc`` files is the speed with which they are loaded."
msgstr ""
"``.py`` 파일에서 읽을 때보다 ``.pyc`` 파일에서 읽을 때 프로그램이 더 빨리 실행되지는 않습니다; ``.pyc`` "
"파일에서 더 빨라지는 것은 로드되는 속도뿐입니다."

#: ../Doc/tutorial/modules.rst:248
msgid ""
"The module :mod:`compileall` can create .pyc files for all modules in a "
"directory."
msgstr "모듈 :mod:`compileall` 은 디렉터리에 있는 모든 모듈의 .pyc 파일들을 만들 수 있습니다."

#: ../Doc/tutorial/modules.rst:251
msgid ""
"There is more detail on this process, including a flow chart of the "
"decisions, in :pep:`3147`."
msgstr "이 절차에 대한 더 자세한 정보, 결정들의 순서도를 포함합니다, 는 :pep:`3147` 에 나옵니다."

#: ../Doc/tutorial/modules.rst:258
msgid "Standard Modules"
msgstr "표준 모듈들"

#: ../Doc/tutorial/modules.rst:262
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter)."
"  Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such "
"modules is a configuration option which also depends on the underlying "
"platform.  For example, the :mod:`winreg` module is only provided on "
"Windows systems. One particular module deserves some attention: "
":mod:`sys`, which is built into every Python interpreter.  The variables "
"``sys.ps1`` and ``sys.ps2`` define the strings used as primary and "
"secondary prompts::"
msgstr ""
"파이썬은 표준 모듈들의 라이브러리가 함께 오는데, 별도의 문서 파이썬 라이브러리 레퍼런스 (이후로는 \"라이브러리 레퍼런스\") "
"에서 설명합니다. 어떤 모듈들은 인터프리터에 내장됩니다; 이것들은 언어의 핵심적인 부분은 아니지만 그런데도 내장된 연산들에 대한 "
"액세스를 제공하는데, 효율이나 시스템 호출과 같은 운영 체제 기본 요소들에 대한 액세스를 제공하기 위함입니다. 그런 모듈들의 집합은"
" 설정 옵션인데 기반 플랫폼 의존적입니다. 예를 들어, :mod:`winreg` 모듈은 윈도우 시스템에서만 제공됩니다. 특별한 모듈"
" 하나는 주목을 받을 필요가 있습니다: :mod:`sys`. 모든 파이썬 인터프리터에 내장됩니다. 변수 ``sys.ps1`` 와 "
"``sys.ps2`` 는 기본과 보조 프롬프트로 사용되는 문자열을 정의합니다::"

#: ../Doc/tutorial/modules.rst:285
msgid ""
"These two variables are only defined if the interpreter is in interactive"
" mode."
msgstr "이 두 개의 변수들은 인터프리터가 대화형 모드일 때만 정의됩니다."

#: ../Doc/tutorial/modules.rst:287
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default "
"path taken from the environment variable :envvar:`PYTHONPATH`, or from a "
"built-in default if :envvar:`PYTHONPATH` is not set.  You can modify it "
"using standard list operations::"
msgstr ""
"변수 ``sys.path`` 는 인터프리터의 모듈 검색 경로를 결정하는 문자열들의 리스트입니다. 환경 변수 "
":envvar:`PYTHONPATH` 에서 취한 기본 경로나, :envvar:`PYTHONPATH` 가 설정되지 않는 경우 내장 "
"기본값으로 초기화됩니다. 표준 리스트 연산을 사용해서 수정할 수 있습니다::"

#: ../Doc/tutorial/modules.rst:300
msgid "The :func:`dir` Function"
msgstr ":func:`dir` 함수"

#: ../Doc/tutorial/modules.rst:302
msgid ""
"The built-in function :func:`dir` is used to find out which names a "
"module defines.  It returns a sorted list of strings::"
msgstr "내장 함수 :func:`dir` 은 모듈이 정의하는 이름들을 찾는 데 사용됩니다. 문자열들의 정렬된 리스트를 돌려줍니다::"

#: ../Doc/tutorial/modules.rst:327
msgid ""
"Without arguments, :func:`dir` lists the names you have defined "
"currently::"
msgstr "인자가 없으면, :func:`dir` 는 현재 정의한 이름들을 나열합니다::"

#: ../Doc/tutorial/modules.rst:335
msgid "Note that it lists all types of names: variables, modules, functions, etc."
msgstr "모든 형의 이름을 나열한다는 것에 유의해야 합니다: 변수, 모듈, 함수, 등등."

#: ../Doc/tutorial/modules.rst:339
msgid ""
":func:`dir` does not list the names of built-in functions and variables."
"  If you want a list of those, they are defined in the standard module "
":mod:`builtins`::"
msgstr ""
":func:`dir` 은 내장 함수와 변수들의 이름을 나열하지 않습니다. 그것들의 목록을 원한다면, 표준 모듈 "
":mod:`builtins` 에 정의되어 있습니다::"

#: ../Doc/tutorial/modules.rst:378
msgid "Packages"
msgstr "패키지"

#: ../Doc/tutorial/modules.rst:380
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` "
"designates a submodule named ``B`` in a package named ``A``.  Just like "
"the use of modules saves the authors of different modules from having to "
"worry about each other's global variable names, the use of dotted module "
"names saves the authors of multi-module packages like NumPy or Pillow "
"from having to worry about each other's module names."
msgstr ""
"패키지는 \"점으로 구분된 모듈 이름\" 를 써서 파이썬의 모듈 이름 공간을 구조화하는 방법입니다. 예를 들어, 모듈 이름 "
":mod:`A.B` 는 ``A`` 라는 이름의 패키지에 있는 ``B`` 라는 이름의 서브 모듈을 가리킵니다. 모듈의 사용이 다른 "
"모듈의 저자들이 서로의 전역 변수 이름들을 걱정할 필요 없게 만드는 것과 마찬가지로, 점으로 구분된 모듈의 이름들은 NumPy 나 "
"Pillow 과 같은 다중 모듈 패키지들의 저자들이 서로의 모듈 이름들을 걱정할 필요 없게 만듭니다."

#: ../Doc/tutorial/modules.rst:388
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for "
"the uniform handling of sound files and sound data.  There are many "
"different sound file formats (usually recognized by their extension, for "
"example: :file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to "
"create and maintain a growing collection of modules for the conversion "
"between the various file formats. There are also many different "
"operations you might want to perform on sound data (such as mixing, "
"adding echo, applying an equalizer function, creating an artificial "
"stereo effect), so in addition you will be writing a never-ending stream "
"of modules to perform these operations.  Here's a possible structure for "
"your package (expressed in terms of a hierarchical filesystem):"
msgstr ""
"음향 파일과 과 음향 데이터의 일관된 처리를 위한 모듈들의 컬렉션 (\"패키지\") 을 설계하길 원한다고 합시다. 여러 종류의 음향"
" 파일 형식이 있으므로 (보통 확장자로 구분됩니다, 예를 들어: :file:`.wav`, :file:`.aiff`, "
":file:`.au`), 다양한 파일 형식 간의 변환을 위해 계속 늘어나는 모듈들의 컬렉션을 만들고 유지할 필요가 있습니다. 또한,"
" 음향 데이터에 적용하고자 하는 많은 종류의 연산들도 있으므로 (믹싱, 에코 넣기, 이퀄라이저 기능 적용, 인공적인 스테레오 효과 "
"만들기와 같은), 이 연산들을 수행하기 위한 모듈들을 끊임없이 작성하게 될 것입니다. 패키지를 이렇게 구성해 볼 수 있습니다 "
"(계층적 파일 시스템으로 표현했습니다):"

#: ../Doc/tutorial/modules.rst:425
msgid ""
"When importing the package, Python searches through the directories on "
"``sys.path`` looking for the package subdirectory."
msgstr "패키지를 임포트할 때, 파이썬은 ``sys.path`` 에 있는 디렉터리들을 검색하면서 패키지 서브 디렉터리를 찾습니다."

#: ../Doc/tutorial/modules.rst:428
msgid ""
"The :file:`__init__.py` files are required to make Python treat the "
"directories as containing packages; this is done to prevent directories "
"with a common name, such as ``string``, from unintentionally hiding valid"
" modules that occur later on the module search path. In the simplest "
"case, :file:`__init__.py` can just be an empty file, but it can also "
"execute initialization code for the package or set the ``__all__`` "
"variable, described later."
msgstr ""
"파이썬이 디렉터리를 패키지로 취급하게 만들기 위해서 :file:`__init__.py` 파일이 필요합니다; 이렇게 하는 이유는 "
"``string`` 처럼 흔히 쓰는 이름의 디렉터리가, 의도하지 않게 모듈 검색 경로의 뒤에 등장하는 올바른 모듈들을 가리는 일을 "
"방지하기 위함입니다. 가장 간단한 경우, :file:`__init__.py` 는 그냥 빈 파일일 수 있지만, 패키지의 초기화 코드를"
" 실행하거나 뒤에서 설명하는 ``__all__`` 변수를 설정할 수 있습니다."

#: ../Doc/tutorial/modules.rst:435
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr "패키지 사용자는 패키지로부터 개별 모듈을 임포트할 수 있습니다, 예를 들어::"

#: ../Doc/tutorial/modules.rst:440
msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be "
"referenced with its full name. ::"
msgstr "이것은 서브 모듈 :mod:`sound.effects.echo` 를 로드합니다. 전체 이름으로 참조되어야 합니다. ::"

#: ../Doc/tutorial/modules.rst:445
msgid "An alternative way of importing the submodule is::"
msgstr "서브 모듈을 임포트하는 다른 방법은 이렇습니다::"

#: ../Doc/tutorial/modules.rst:449
msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without"
" its package prefix, so it can be used as follows::"
msgstr ""
"이것도 서브 모듈 :mod:`echo` 를 로드하고, 패키지 접두어 없이 사용할 수 있게 합니다. 그래서 이런 식으로 사용할 수 "
"있습니다::"

#: ../Doc/tutorial/modules.rst:454
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr "또 다른 방법은 원하는 함수나 변수를 직접 임포트하는 것입니다::"

#: ../Doc/tutorial/modules.rst:458
msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function "
":func:`echofilter` directly available::"
msgstr ""
"또다시, 이것은 서브 모듈 :mod:`echo` 를 로드하지만, 함수 :func:`echofilter` 를 직접 사용할 수 있게 "
"만듭니다::"

#: ../Doc/tutorial/modules.rst:463
msgid ""
"Note that when using ``from package import item``, the item can be either"
" a submodule (or subpackage) of the package, or some  other name defined "
"in the package, like a function, class or variable.  The ``import`` "
"statement first tests whether the item is defined in the package; if not,"
" it assumes it is a module and attempts to load it.  If it fails to find "
"it, an :exc:`ImportError` exception is raised."
msgstr ""
"``from package import item`` 를 사용할 때, item은 패키지의 서브 모듈 (또는 서브 패키지)일 수도 있고"
" 함수, 클래스, 변수 등 패키지에 정의된 다른 이름들일 수도 있음에 유의하세요. ``import`` 문은 먼저 item이 패키지에"
" 정의되어 있는지 검사하고, 그렇지 않으면 모듈이라고 가정하고 로드를 시도합니다. 찾지 못한다면, :exc:`ImportError`"
" 예외를 일으킵니다."

#: ../Doc/tutorial/modules.rst:470
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, "
"each item except for the last must be a package; the last item can be a "
"module or a package but can't be a class or function or variable defined "
"in the previous item."
msgstr ""
"이에 반하여, ``import item.subitem.subsubitem`` 와 같은 문법을 사용할 때, 마지막 것을 제외한 각 "
"항목은 반드시 패키지여야 합니다; 마지막 항목은 모듈이나 패키지가 될 수 있지만, 앞의 항목에서 정의된 클래스, 함수, 변수 등이 "
"될 수는 없습니다."

#: ../Doc/tutorial/modules.rst:479
msgid "Importing \\* From a Package"
msgstr "패키지에서 \\* 임포트 하기"

#: ../Doc/tutorial/modules.rst:483
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, "
"finds which submodules are present in the package, and imports them all."
"  This could take a long time and importing sub-modules might have "
"unwanted side-effects that should only happen when the sub-module is "
"explicitly imported."
msgstr ""
"이제 ``from sound.effects import *`` 라고 쓰면 어떻게 될까? 이상적으로는, 어떻게든 파일 시스템에서 "
"패키지에 어떤 모듈들이 들어있는지 찾은 다음, 그것들 모두를 임포트 하기를 원할 것입니다. 이렇게 하는 데는 시간이 오래 걸리고 "
"서브 모듈을 임포트 함에 따라 어떤 서브 모듈을 명시적으로 임포트할 경우만 일어나야만 하는 원하지 않는 부수적 효과가 발생할 수 "
"있습니다."

#: ../Doc/tutorial/modules.rst:489
msgid ""
"The only solution is for the package author to provide an explicit index "
"of the package.  The :keyword:`import` statement uses the following "
"convention: if a package's :file:`__init__.py` code defines a list named "
"``__all__``, it is taken to be the list of module names that should be "
"imported when ``from package import *`` is encountered.  It is up to the "
"package author to keep this list up-to-date when a new version of the "
"package is released.  Package authors may also decide not to support it, "
"if they don't see a use for importing \\* from their package.  For "
"example, the file :file:`sound/effects/__init__.py` could contain the "
"following code::"
msgstr ""
"유일한 해결책은 패키지 저자가 패키지의 색인을 명시적으로 제공하는 것입니다. :keyword:`import` 문은 다음과 같은 "
"관례가 있습니다: 패키지의 :file:`__init__.py` 코드가 ``__all__`` 이라는 이름의 목록을 제공하면, 이것을 "
"``from package import *`` 를 만날 때 임포트 해야만 하는 모듈 이름들의 목록으로 받아들입니다. 새 버전의 "
"패키지를 출시할 때 이 목록을 최신 상태로 유지하는 것은 패키지 저자의 책임입니다. 패키지 저자가 패키지에서 \\* 를 임포트하는 "
"용도가 없다고 판단한다면, 이것을 지원하지 않기로 할 수도 있습니다. 예를 들어, 파일 "
":file:`sound/effects/__init__.py` 는 다음과 같은 코드를 포함할 수 있습니다::"

#: ../Doc/tutorial/modules.rst:501
msgid ""
"This would mean that ``from sound.effects import *`` would import the "
"three named submodules of the :mod:`sound` package."
msgstr ""
"이것은 ``from sound.effects import *`` 이 :mod:`sound.effects` 패키지의 세 서브 모듈들을"
" 임포트하게 됨을 의미합니다."

#: ../Doc/tutorial/modules.rst:504
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import "
"*`` does *not* import all submodules from the package "
":mod:`sound.effects` into the current namespace; it only ensures that the"
" package :mod:`sound.effects` has been imported (possibly running any "
"initialization code in :file:`__init__.py`) and then imports whatever "
"names are defined in the package.  This includes any names defined (and "
"submodules explicitly loaded) by :file:`__init__.py`.  It also includes "
"any submodules of the package that were explicitly loaded by previous "
":keyword:`import` statements.  Consider this code::"
msgstr ""
"``__all__`` 이 정의되지 않으면, 문장 ``from sound.effects import *`` 은 패키지 "
":mod:`sound.effects` 의 모든 서브 모듈들을 현재 이름 공간으로 임포트 하지 *않습니다*; 이것은 오직 패키지 "
":mod:`sound.effects` 가 임포트 되도록 만들고 (:file:`__init__.py` 에 있는 초기화 코드들이 수행될"
" 수 있습니다), 그 패키지가 정의하는 이름들을 임포트 합니다. 이 이름들은 :file:`__init__.py` 가 정의하는 모든 "
"이름 (그리고 명시적으로 로드된 서브 모듈들)을 포함합니다. 이 이름들에는 사전에 :keyword:`import` 문으로 명시적으로"
" 로드된 패키지의 서브 모듈들 역시 포함됩니다. 이 코드를 생각해봅시다::"

#: ../Doc/tutorial/modules.rst:517
msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported"
" in the current namespace because they are defined in the "
":mod:`sound.effects` package when the ``from...import`` statement is "
"executed.  (This also works when ``__all__`` is defined.)"
msgstr ""
"이 예에서, :mod:`echo` 와 :mod:`surround` 모듈이 현재 이름 공간으로 임포트 되는데, "
"``from...import`` 문이 실행될 때 :mod:`sound.effects` 패키지에 정의되기 때문입니다. "
"(``__all__`` 이 정의될 때도 마찬가집니다.)"

#: ../Doc/tutorial/modules.rst:522
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"설사 어떤 모듈이 ``import *`` 를 사용할 때 특정 패턴을 따르는 이름들만 익스포트 하도록 설계되었다 하더라도, 프로덕션 "
"코드에서는 여전히 좋지 않은 사례로 여겨집니다."

#: ../Doc/tutorial/modules.rst:526
msgid ""
"Remember, there is nothing wrong with using ``from Package import "
"specific_submodule``!  In fact, this is the recommended notation unless "
"the importing module needs to use submodules with the same name from "
"different packages."
msgstr ""
"``from Package import specific_submodule`` 을 사용하는데 잘못된 것은 없다는 것을 기억하세요! "
"사실, 임포트하는 모듈이 다른 패키지에서 같은 이름의 서브 모듈을 사용할 필요가 없는 한 권장되는 표기법입니다."

#: ../Doc/tutorial/modules.rst:533
msgid "Intra-package References"
msgstr "패키지 내부 간의 참조"

#: ../Doc/tutorial/modules.rst:535
msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to "
"submodules of siblings packages.  For example, if the module "
":mod:`sound.filters.vocoder` needs to use the :mod:`echo` module in the "
":mod:`sound.effects` package, it can use ``from sound.effects import "
"echo``."
msgstr ""
"패키지가 서브 패키지들로 구조화될 때 (예에서 나온 :mod:`sound` 패키지처럼), 이웃 패키지의 서브 모듈을 가리키는데 절대"
" 임포트를 사용할 수 있습니다. 예를 들어, 모듈 :mod:`sound.filters.vocoder` 이 "
":mod:`sound.effects` 패키지의 :mod:`echo` 모듈이 필요하면, ``from sound.effects "
"import echo`` 를 사용할 수 있습니다."

#: ../Doc/tutorial/modules.rst:541
msgid ""
"You can also write relative imports, with the ``from module import name``"
" form of import statement.  These imports use leading dots to indicate "
"the current and parent packages involved in the relative import.  From "
"the :mod:`surround` module for example, you might use::"
msgstr ""
"상대 임포트를 쓸 수도 있는데, ``from module import name`` 형태의 임포트 문을 사용합니다. 이 임포트는 상대"
" 임포트에 수반되는 현재와 부모 패키지를 가리키기 위해 앞에 붙는 점을 사용합니다. 예를 들어, :mod:`surround` "
"모듈에서, 이렇게 사용할 수 있습니다::"

#: ../Doc/tutorial/modules.rst:550
msgid ""
"Note that relative imports are based on the name of the current module.  "
"Since the name of the main module is always ``\"__main__\"``, modules "
"intended for use as the main module of a Python application must always "
"use absolute imports."
msgstr ""
"상대 임포트가 현재 모듈의 이름에 기반을 둔다는 것에 주의하세요. 메인 모듈의 이름은 항상 ``\"__main__\"`` 이기 "
"때문에, 파이썬 응용 프로그램의 메인 모듈로 사용될 목적의 모듈들은 반드시 절대 임포트를 사용해야 합니다."

#: ../Doc/tutorial/modules.rst:556
msgid "Packages in Multiple Directories"
msgstr "여러 디렉터리에 있는 패키지"

#: ../Doc/tutorial/modules.rst:558
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the"
" package's :file:`__init__.py` before the code in that file is executed."
"  This variable can be modified; doing so affects future searches for "
"modules and subpackages contained in the package."
msgstr ""
"패키지는 특별한 어트리뷰트 하나를 더 지원합니다, :attr:`__path__`. 이것은 패키지의 "
":file:`__init__.py` 파일을 실행하기 전에, 이 파일이 들어있는 디렉터리의 이름을 포함하는 리스트로 초기화됩니다. 이"
" 변수는 수정할 수 있습니다; 그렇게 하면 그 이후로 패키지에 포함된 모듈과 서브 패키지를 검색하는 데 영향을 주게 됩니다."

#: ../Doc/tutorial/modules.rst:564
msgid ""
"While this feature is not often needed, it can be used to extend the set "
"of modules found in a package."
msgstr "이 기능이 자주 필요하지는 않지만, 패키지에서 발견되는 모듈의 집합을 확장하는 데 사용됩니다."

#: ../Doc/tutorial/modules.rst:569
msgid "Footnotes"
msgstr "각주"

#: ../Doc/tutorial/modules.rst:570
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; "
"the execution of a module-level function definition enters the function "
"name in the module's global symbol table."
msgstr "사실 함수 정의도 '실행' 되는 '문장' 입니다; 모듈 수준의 함수 정의를 실행하면 함수의 이름이 전역 심볼 테이블에 들어갑니다."

