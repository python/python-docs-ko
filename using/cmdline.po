# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2018-10-23 06:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/using/cmdline.rst:9
msgid "Command line and environment"
msgstr "명령 줄과 환경"

#: ../Doc/using/cmdline.rst:11
msgid ""
"The CPython interpreter scans the command line and the environment for "
"various settings."
msgstr "CPython 인터프리터는 명령 줄과 환경에서 다양한 설정을 찾습니다."

#: ../Doc/using/cmdline.rst:16
msgid ""
"Other implementations' command line schemes may differ.  See "
":ref:`implementations` for further resources."
msgstr "다른 구현의 명령 줄 체계는 다를 수 있습니다. 자세한 내용은 :ref:`implementations` 참조하십시오."

#: ../Doc/using/cmdline.rst:23
msgid "Command line"
msgstr "명령 줄"

#: ../Doc/using/cmdline.rst:25
msgid "When invoking Python, you may specify any of these options::"
msgstr "파이썬을 호출할 때 다음 옵션들을 지정할 수 있습니다::"

#: ../Doc/using/cmdline.rst:29
msgid "The most common use case is, of course, a simple invocation of a script::"
msgstr "물론, 가장 일반적인 사용 사례는 간단한 스크립트 호출입니다::"

#: ../Doc/using/cmdline.rst:37
msgid "Interface options"
msgstr "인터페이스 옵션"

#: ../Doc/using/cmdline.rst:39
msgid ""
"The interpreter interface resembles that of the UNIX shell, but provides "
"some additional methods of invocation:"
msgstr "인터프리터 인터페이스는 유닉스 셸의 인터페이스와 비슷하지만, 몇 가지 추가 호출 방법을 제공합니다:"

#: ../Doc/using/cmdline.rst:42
msgid ""
"When called with standard input connected to a tty device, it prompts for"
" commands and executes them until an EOF (an end-of-file character, you "
"can produce that with :kbd:`Ctrl-D` on UNIX or :kbd:`Ctrl-Z, Enter` on "
"Windows) is read."
msgstr ""
"tty 장치에 연결된 표준 입력으로 호출하면, 명령을 입력하라는 프롬프트를 준 후 EOF(파일 끝 문자, 유닉스에서는 "
":kbd:`Ctrl-D`, 윈도우에서는 :kbd:`Ctrl-Z, Enter`\\로 만들 수 있습니다)가 읽힐 때까지 실행합니다."

#: ../Doc/using/cmdline.rst:45
msgid ""
"When called with a file name argument or with a file as standard input, "
"it reads and executes a script from that file."
msgstr "파일 이름 인자나 파일을 표준 입력으로 사용해서 호출하면, 해당 파일에서 스크립트를 읽고 실행합니다."

#: ../Doc/using/cmdline.rst:47
msgid ""
"When called with a directory name argument, it reads and executes an "
"appropriately named script from that directory."
msgstr "디렉터리 이름 인자로 호출되면, 해당 디렉터리에서 적절히 이름 붙은 스크립트를 읽고 실행합니다."

#: ../Doc/using/cmdline.rst:49
msgid ""
"When called with ``-c command``, it executes the Python statement(s) "
"given as *command*.  Here *command* may contain multiple statements "
"separated by newlines. Leading whitespace is significant in Python "
"statements!"
msgstr ""
"``-c command`` 로 호출되면, *command*\\로 주어지는 파이썬 문장을 실행합니다. 여기서 *command*\\는 "
"개행 문자로 구분된 여러 개의 문장을 포함할 수 있습니다. 선행 공백은 파이썬 문장에서 중요합니다!"

#: ../Doc/using/cmdline.rst:52
msgid ""
"When called with ``-m module-name``, the given module is located on the "
"Python module path and executed as a script."
msgstr "``-m module-name`` 으로 호출되면, 주어진 모듈을 파이썬 모듈 경로에서 찾은 후에 스크립트로 실행합니다."

#: ../Doc/using/cmdline.rst:55
msgid "In non-interactive mode, the entire input is parsed before it is executed."
msgstr "비대화형 모드에서는, 실행하기 전에 전체 입력을 구문 분석합니다."

#: ../Doc/using/cmdline.rst:57
msgid ""
"An interface option terminates the list of options consumed by the "
"interpreter, all consecutive arguments will end up in :data:`sys.argv` --"
" note that the first element, subscript zero (``sys.argv[0]``), is a "
"string reflecting the program's source."
msgstr ""
"인터페이스 옵션은 인터프리터에 의해 소비되는 옵션의 목록을 종료합니다, 뒤따르는 모든 인자는 :data:`sys.argv` 로 "
"들어갑니다 -- 첫 번째 요소, 서브 스크립트 0(``sys.argv[0]``)은 프로그램 소스를 반영하는 문자열임에 유의하세요."

#: ../Doc/using/cmdline.rst:64
msgid ""
"Execute the Python code in *command*.  *command* can be one or more "
"statements separated by newlines, with significant leading whitespace as "
"in normal module code."
msgstr ""
"*command* 의 파이썬 코드를 실행합니다. *command* 는 개행 문자로 구분된 하나 이상의 문장일 수 있는데, 일반 모듈"
" 코드에서와같이 선행 공백은 의미가 있습니다."

#: ../Doc/using/cmdline.rst:68
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"``\"-c\"`` and the current directory will be added to the start of "
":data:`sys.path` (allowing modules in that directory to be imported as "
"top level modules)."
msgstr ""
"이 옵션을 주면, :data:`sys.argv` 의 첫 번째 요소는 ``\"-c\"`` 가 되고, 현재 디렉터리를 "
":data:`sys.path` 의 시작 부분에 추가합니다 (그 디렉터리에 있는 모듈을 최상위 모듈로 임포트 할 수 있게 합니다)."

#: ../Doc/using/cmdline.rst:76
msgid ""
"Search :data:`sys.path` for the named module and execute its contents as "
"the :mod:`__main__` module."
msgstr "제공된 이름의 모듈을 :data:`sys.path` 에서 검색하고 그 내용을 :mod:`__main__` 모듈로서 실행합니다."

#: ../Doc/using/cmdline.rst:79
msgid ""
"Since the argument is a *module* name, you must not give a file extension"
" (``.py``).  The module name should be a valid absolute Python module "
"name, but the implementation may not always enforce this (e.g. it may "
"allow you to use a name that includes a hyphen)."
msgstr ""
"인자가 *모듈* 이름이기 때문에, 파일 확장자(``.py``)를 주지 않아야 합니다. 모듈 이름은 유효한 절대 파이썬 모듈 "
"이름이어야 하지만, 구현이 항상 이를 강제하는 것은 아닙니다 (예를 들어, 하이픈을 포함하는 이름을 허락할 수도 있습니다)."

#: ../Doc/using/cmdline.rst:84
msgid ""
"Package names (including namespace packages) are also permitted. When a "
"package name is supplied instead of a normal module, the interpreter will"
" execute ``<pkg>.__main__`` as the main module. This behaviour is "
"deliberately similar to the handling of directories and zipfiles that are"
" passed to the interpreter as the script argument."
msgstr ""
"패키지 이름(이름 공간 패키지 포함)도 허용됩니다. 일반 모듈 대신 패키지 이름이 제공되면, 인터프리터는 "
"``<pkg>.__main__`` 을 메인 모듈로 실행합니다. 이 동작은 인터프리터에 스크립트 인자로 전달되는 디렉터리 및 zip "
"파일의 처리와 의도적으로 유사합니다."

#: ../Doc/using/cmdline.rst:93
msgid ""
"This option cannot be used with built-in modules and extension modules "
"written in C, since they do not have Python module files. However, it can"
" still be used for precompiled modules, even if the original source file "
"is not available."
msgstr ""
"이 옵션은 내장 모듈이나 확장 모듈에는 사용될 수 없는데, 이것들은 파이썬 모듈 파일을 갖고 있지 않기 때문입니다. 그러나, 원래 "
"소스 파일이 없는 사전 컴파일된 모듈에는 여전히 사용할 수 있습니다."

#: ../Doc/using/cmdline.rst:98
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"the full path to the module file (while the module file is being located,"
" the first element will be set to ``\"-m\"``). As with the :option:`-c` "
"option, the current directory will be added to the start of "
":data:`sys.path`."
msgstr ""
"이 옵션을 주면, :data:`sys.argv` 의 첫 번째 요소는 모듈 파일의 전체 경로가 됩니다 (모듈 파일을 찾는 동안에는 첫"
" 번째 요소를 ``\"-m\"`` 으로 설정합니다). :option:`-c` 옵션과 마찬가지로, 현재 디렉터리가 "
":data:`sys.path` 의 시작 부분에 추가됩니다."

#: ../Doc/using/cmdline.rst:103
msgid ""
"Many standard library modules contain code that is invoked on their "
"execution as a script.  An example is the :mod:`timeit` module::"
msgstr "많은 표준 라이브러리 모듈에는 스크립트로 실행할 때 호출되는 코드가 들어 있습니다. 한 예는 :mod:`timeit` 모듈입니다::"

#: ../Doc/using/cmdline.rst:111
msgid ":func:`runpy.run_module`"
msgstr ":func:`runpy.run_module`"

#: ../Doc/using/cmdline.rst:111 ../Doc/using/cmdline.rst:153
msgid "Equivalent functionality directly available to Python code"
msgstr "파이썬 코드에서 직접 사용할 수 있는 동등한 기능"

#: ../Doc/using/cmdline.rst:113
msgid ":pep:`338` -- Executing modules as scripts"
msgstr ":pep:`338` -- 모듈을 스크립트로 실행하기"

#: ../Doc/using/cmdline.rst:116
msgid "Supply the package name to run a ``__main__`` submodule."
msgstr "``__main__`` 서브 모듈을 실행할 패키지 이름을 제공할 수 있습니다."

#: ../Doc/using/cmdline.rst:119
msgid "namespace packages are also supported"
msgstr "이름 공간 패키지도 지원됩니다."

#: ../Doc/using/cmdline.rst:125
msgid ""
"Read commands from standard input (:data:`sys.stdin`).  If standard input"
" is a terminal, :option:`-i` is implied."
msgstr ""
"표준 입력(:data:`sys.stdin`)에서 명령을 읽습니다. 표준 입력이 터미널이면, :option:`-i` 가 묵시적으로 "
"적용됩니다."

#: ../Doc/using/cmdline.rst:128
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"``\"-\"`` and the current directory will be added to the start of "
":data:`sys.path`."
msgstr ""
"이 옵션을 주면, :data:`sys.argv` 의 첫 번째 요소는 ``\"-\"`` 이 되고, 현재 디렉터리가 "
":data:`sys.path` 의 처음에 추가됩니다."

#: ../Doc/using/cmdline.rst:135
msgid ""
"Execute the Python code contained in *script*, which must be a filesystem"
" path (absolute or relative) referring to either a Python file, a "
"directory containing a ``__main__.py`` file, or a zipfile containing a "
"``__main__.py`` file."
msgstr ""
"*script* 에 담긴 파이썬 코드를 실행합니다. *script* 는 파이썬 파일이나 ``__main__.py`` 파일이 들어있는"
" 디렉터리나 ``__main__.py`` 파일을 포함하는 zip 파일을 가리키는 파일 시스템 경로(절대나 상대)여야 합니다."

#: ../Doc/using/cmdline.rst:140
msgid ""
"If this option is given, the first element of :data:`sys.argv` will be "
"the script name as given on the command line."
msgstr "이 옵션을 주면, :data:`sys.argv` 의 첫 번째 요소는 명령 줄에서 주어진 스크립트 이름이 됩니다."

#: ../Doc/using/cmdline.rst:143
msgid ""
"If the script name refers directly to a Python file, the directory "
"containing that file is added to the start of :data:`sys.path`, and the "
"file is executed as the :mod:`__main__` module."
msgstr ""
"스크립트 이름이 파이썬 파일을 직접 가리키면, 해당 파일을 포함하는 디렉터리가 :data:`sys.path` 의 시작 부분에 "
"추가되고, 파일은 :mod:`__main__` 모듈로 실행됩니다."

#: ../Doc/using/cmdline.rst:147
msgid ""
"If the script name refers to a directory or zipfile, the script name is "
"added to the start of :data:`sys.path` and the ``__main__.py`` file in "
"that location is executed as the :mod:`__main__` module."
msgstr ""
"스크립트 이름이 디렉터리 나 zip 파일을 가리키면, 스크립트 이름이 :data:`sys.path` 의 시작 부분에 추가되고, 해당"
" 위치의 ``__main__.py`` 파일을 :mod:`__main__` 모듈로 실행합니다."

#: ../Doc/using/cmdline.rst:152
msgid ":func:`runpy.run_path`"
msgstr ":func:`runpy.run_path`"

#: ../Doc/using/cmdline.rst:156
msgid ""
"If no interface option is given, :option:`-i` is implied, ``sys.argv[0]``"
" is an empty string (``\"\"``) and the current directory will be added to"
" the start of :data:`sys.path`.  Also, tab-completion and history editing"
" is automatically enabled, if available on your platform (see :ref"
":`rlcompleter-config`)."
msgstr ""
"인터페이스 옵션을 주지 않으면, :option:`-i` 가 묵시적으로 적용되고, ``sys.argv[0]`` 는 빈 "
"문자열(``\"\"``)이 되고, 현재 디렉터리가 :data:`sys.path` 의 처음에 추가됩니다. 또한, 플랫폼에서 사용 "
"가능한 경우 (:ref:`rlcompleter-config` 를 참조하세요), 탭 완성 및 히스토리 편집이 자동으로 활성화됩니다."

#: ../Doc/using/cmdline.rst:162
msgid ":ref:`tut-invoking`"
msgstr ":ref:`tut-invoking`"

#: ../Doc/using/cmdline.rst:164
msgid "Automatic enabling of tab-completion and history editing."
msgstr "탭 완성과 히스토리 편집의 자동 활성화."

#: ../Doc/using/cmdline.rst:169
msgid "Generic options"
msgstr "일반 옵션"

#: ../Doc/using/cmdline.rst:175
msgid "Print a short description of all command line options."
msgstr "모든 명령 줄 옵션에 대한 간단한 설명을 인쇄합니다."

#: ../Doc/using/cmdline.rst:181
msgid "Print the Python version number and exit.  Example output could be:"
msgstr "파이썬 버전 번호를 출력하고 종료합니다. 출력 예는 다음과 같습니다:"

#: ../Doc/using/cmdline.rst:187
msgid "When given twice, print more information about the build, like:"
msgstr "두 번 지정하면, 다음과 같이 빌드에 관한 추가 정보를 인쇄합니다:"

#: ../Doc/using/cmdline.rst:194
msgid "The ``-VV`` option."
msgstr "``-VV`` 옵션."

#: ../Doc/using/cmdline.rst:200
msgid "Miscellaneous options"
msgstr "기타 옵션"

#: ../Doc/using/cmdline.rst:204
msgid ""
"Issue a warning when comparing :class:`bytes` or :class:`bytearray` with "
":class:`str` or :class:`bytes` with :class:`int`.  Issue an error when "
"the option is given twice (:option:`!-bb`)."
msgstr ""
":class:`bytes` 나 :class:`bytearray` 를 :class:`str`\\과, :class:`bytes`\\를 "
":class:`int`\\와 비교할 때 경고를 합니다. 옵션이 두 번 주어지면 (:option:`!-bb`) 에러를 줍니다."

#: ../Doc/using/cmdline.rst:208
msgid "Affects comparisons of :class:`bytes` with :class:`int`."
msgstr ":class:`bytes` 와 :class:`int` 비교에도 적용됩니다."

#: ../Doc/using/cmdline.rst:213
msgid ""
"If given, Python won't try to write ``.pyc`` files on the import of "
"source modules.  See also :envvar:`PYTHONDONTWRITEBYTECODE`."
msgstr ""
"주어지면, 파이썬은 소스 모듈을 임포트 할 때 ``.pyc`` 파일을 쓰려고 하지 않습니다. "
":envvar:`PYTHONDONTWRITEBYTECODE` 도 참조하십시오."

#: ../Doc/using/cmdline.rst:219
msgid ""
"Control the validation behavior of hash-based ``.pyc`` files. See :ref"
":`pyc-invalidation`. When set to ``default``, checked and unchecked hash-"
"based bytecode cache files are validated according to their default "
"semantics. When set to ``always``, all hash-based ``.pyc`` files, whether"
" checked or unchecked, are validated against their corresponding source "
"file. When set to ``never``, hash-based ``.pyc`` files are not validated "
"against their corresponding source files."
msgstr ""
"해시 기반 ``.pyc`` 파일의 검증 동작을 제어합니다. :ref:`pyc-invalidation`\\를 참조하세요. "
"``default`` 로 설정하면, 검사형과 비검사형 해시 기반 바이트 코드 캐시 파일은 기본 의미에 따라 유효성이 검사됩니다. "
"``always`` 로 설정하면, 모든 해시 기반 ``.pyc`` 파일들은, 검사형과 비검사형을 가리지 않고, 해당 소스 파일에 "
"대해 유효성이 검사됩니다. ``never`` 로 설정되면, 해시 기반 ``.pyc`` 파일은 해당 소스 파일에 대해 유효성이 "
"검사되지 않습니다."

#: ../Doc/using/cmdline.rst:227
msgid ""
"The semantics of timestamp-based ``.pyc`` files are unaffected by this "
"option."
msgstr "타임스탬프 기반 ``.pyc`` 파일의 의미는 이 옵션의 영향을 받지 않습니다."

#: ../Doc/using/cmdline.rst:233
msgid ""
"Turn on parser debugging output (for expert only, depending on "
"compilation options).  See also :envvar:`PYTHONDEBUG`."
msgstr ""
"파서 디버깅 출력을 켭니다 (컴파일 옵션에 따라 전문가만을 위한 기능입니다). :envvar:`PYTHONDEBUG` 도 "
"참조하십시오."

#: ../Doc/using/cmdline.rst:239
msgid ""
"Ignore all :envvar:`PYTHON*` environment variables, e.g. "
":envvar:`PYTHONPATH` and :envvar:`PYTHONHOME`, that might be set."
msgstr ""
"설정되었을 수 있는 모든 :envvar:`PYTHON*` 환경 변수를 무시합니다, 예를 들어 :envvar:`PYTHONPATH` "
"와 :envvar:`PYTHONHOME`."

#: ../Doc/using/cmdline.rst:245
msgid ""
"When a script is passed as first argument or the :option:`-c` option is "
"used, enter interactive mode after executing the script or the command, "
"even when :data:`sys.stdin` does not appear to be a terminal.  The "
":envvar:`PYTHONSTARTUP` file is not read."
msgstr ""
"스크립트가 첫 번째 인자로 전달되거나 :option:`-c` 옵션이 사용되면, :data:`sys.stdin` 가 터미널로 보이지 "
"않을 때도, 스크립트나 명령을 실행한 후에 대화형 모드에 진입합니다. :envvar:`PYTHONSTARTUP` 파일은 읽지 "
"않습니다."

#: ../Doc/using/cmdline.rst:250
msgid ""
"This can be useful to inspect global variables or a stack trace when a "
"script raises an exception.  See also :envvar:`PYTHONINSPECT`."
msgstr ""
"이것은 스크립트가 예외를 발생시킬 때 전역 변수나 스택 트레이스를 검사하는 데 유용할 수 있습니다. "
":envvar:`PYTHONINSPECT` 도 참조하십시오."

#: ../Doc/using/cmdline.rst:256
msgid ""
"Run Python in isolated mode. This also implies -E and -s. In isolated "
"mode :data:`sys.path` contains neither the script's directory nor the "
"user's site-packages directory. All :envvar:`PYTHON*` environment "
"variables are ignored, too. Further restrictions may be imposed to "
"prevent the user from injecting malicious code."
msgstr ""
"격리된 모드로 파이썬을 실행합니다. 이것은 또한 -E와 -s를 묵시적으로 적용합니다. 격리 모드에서 :data:`sys.path` "
"는 스크립트 디렉터리나 사용자의 site-packages 디렉터리를 포함하지 않습니다. 모든 :envvar:`PYTHON*` 환경 "
"변수도 무시됩니다. 사용자가 악성 코드를 주입하는 것을 방지하기 위해 추가 제한이 부과될 수 있습니다."

#: ../Doc/using/cmdline.rst:267
msgid ""
"Remove assert statements and any code conditional on the value of "
":const:`__debug__`.  Augment the filename for compiled (:term:`bytecode`)"
" files by adding ``.opt-1`` before the ``.pyc`` extension (see "
":pep:`488`).  See also :envvar:`PYTHONOPTIMIZE`."
msgstr ""
"assert 문과 :const:`__debug__` 의 값에 대한 조건부 코드를 제거합니다. ``.pyc`` 확장자 앞에 "
"``.opt-1`` 을 추가하여 컴파일된 (:term:`바이트 코드 <bytecode>`) 파일의 이름을 구분합니다 "
"(:pep:`488`\\을 참조하세요). :envvar:`PYTHONOPTIMIZE` 도 참조하십시오."

#: ../Doc/using/cmdline.rst:272 ../Doc/using/cmdline.rst:282
msgid "Modify ``.pyc`` filenames according to :pep:`488`."
msgstr ":pep:`488` 에 따라 ``.pyc`` 파일명을 수정합니다."

#: ../Doc/using/cmdline.rst:278
msgid ""
"Do :option:`-O` and also discard docstrings.  Augment the filename for "
"compiled (:term:`bytecode`) files by adding ``.opt-2`` before the "
"``.pyc`` extension (see :pep:`488`)."
msgstr ""
":option:`-O`\\를 적용하고 독스트링도 버립니다. ``.pyc`` 확장자 앞에 ``.opt-2`` 를 추가하여 컴파일 "
"된(:term:`바이트 코드 <bytecode>`) 파일의 이름을 구분합니다 (참조 :pep:`488`\\을 참조하세요)."

#: ../Doc/using/cmdline.rst:288
msgid "Don't display the copyright and version messages even in interactive mode."
msgstr "대화형 모드에서도 저작권과 버전 메시지를 표시하지 않습니다."

#: ../Doc/using/cmdline.rst:295
msgid ""
"Turn on hash randomization. This option only has an effect if the "
":envvar:`PYTHONHASHSEED` environment variable is set to ``0``, since hash"
" randomization is enabled by default."
msgstr ""
"해시 무작위화를 켭니다. 이 옵션은 :envvar:`PYTHONHASHSEED` 환경 변수가 ``0`` 으로 설정된 경우에만 효과가"
" 있습니다, 해시 무작위화는 기본적으로 활성화되기 때문입니다."

#: ../Doc/using/cmdline.rst:299
msgid ""
"On previous versions of Python, this option turns on hash randomization, "
"so that the :meth:`__hash__` values of str, bytes and datetime are "
"\"salted\" with an unpredictable random value.  Although they remain "
"constant within an individual Python process, they are not predictable "
"between repeated invocations of Python."
msgstr ""
"이전 버전의 파이썬에서는, 이 옵션이 해시 무작위화를 켜서, str, bytes, datetime의 :meth:`__hash__` "
"값이 예측할 수 없는 난수로 \"솔트(salt)\" 됩니다. 개별 파이썬 프로세스 내에서 상수로 유지되지만, 반복되는 파이썬 실행 "
"간에는 예측할 수 없습니다."

#: ../Doc/using/cmdline.rst:305
msgid ""
"Hash randomization is intended to provide protection against a denial-of-"
"service caused by carefully-chosen inputs that exploit the worst case "
"performance of a dict construction, O(n^2) complexity.  See "
"http://www.ocert.org/advisories/ocert-2011-003.html for details."
msgstr ""
"해시 무작위화는 신중하게 선택된 입력으로 딕셔너리 구성의 성능을 최악의 O(n^2) 복잡도를 갖도록 만드는 서비스 거부에 대한 "
"보호를 제공하기 위한 것입니다. 자세한 내용은 "
"http://www.ocert.org/advisories/ocert-2011-003.html 을 참조하십시오."

#: ../Doc/using/cmdline.rst:310
msgid ""
":envvar:`PYTHONHASHSEED` allows you to set a fixed value for the hash "
"seed secret."
msgstr ":envvar:`PYTHONHASHSEED` 는 해시 시드 시크릿에 고정값을 설정할 수 있게 합니다."

#: ../Doc/using/cmdline.rst:313
msgid "The option is no longer ignored."
msgstr "이 옵션은 더는 무시되지 않습니다."

#: ../Doc/using/cmdline.rst:321
msgid ""
"Don't add the :data:`user site-packages directory <site.USER_SITE>` to "
":data:`sys.path`."
msgstr ""
":data:`사용자 site-packages 디렉터리 <site.USER_SITE>` 를 :data:`sys.path` 에 추가하지"
" 않습니다."

#: ../Doc/using/cmdline.rst:326 ../Doc/using/cmdline.rst:634
#: ../Doc/using/cmdline.rst:646
msgid ":pep:`370` -- Per user site-packages directory"
msgstr ":pep:`370` -- 사용자별 site-packages 디렉터리"

#: ../Doc/using/cmdline.rst:331
msgid ""
"Disable the import of the module :mod:`site` and the site-dependent "
"manipulations of :data:`sys.path` that it entails.  Also disable these "
"manipulations if :mod:`site` is explicitly imported later (call "
":func:`site.main` if you want them to be triggered)."
msgstr ""
":mod:`site` 모듈의 임포트와 이 모듈이 수반하는 :data:`sys.path` 의 사이트 의존적 조작을 비활성화합니다. "
"또한 :mod:`site` 가 나중에 명시적으로 임포트될 때도 이 조작을 비활성화합니다 (조작하기를 원하면 "
":func:`site.main` 을 호출하십시오)."

#: ../Doc/using/cmdline.rst:339
msgid ""
"Force the stdout and stderr streams to be unbuffered.  This option has no"
" effect on the stdin stream."
msgstr "stdout 과 stderr 스트림을 버퍼링하지 않도록 만듭니다. 이 옵션은 stdin 스트림에는 영향을 미치지 않습니다."

#: ../Doc/using/cmdline.rst:342
msgid "See also :envvar:`PYTHONUNBUFFERED`."
msgstr ":envvar:`PYTHONUNBUFFERED` 도 참조하세요."

#: ../Doc/using/cmdline.rst:344
msgid "The text layer of the stdout and stderr streams now is unbuffered."
msgstr "stdout 과 stderr 스트림의 텍스트 계층은 이제 버퍼링 되지 않습니다."

#: ../Doc/using/cmdline.rst:350
msgid ""
"Print a message each time a module is initialized, showing the place "
"(filename or built-in module) from which it is loaded.  When given twice "
"(:option:`!-vv`), print a message for each file that is checked for when "
"searching for a module.  Also provides information on module cleanup at "
"exit. See also :envvar:`PYTHONVERBOSE`."
msgstr ""
"모듈이 초기화될 때마다 메시지를 인쇄하여, 로드된 위치(파일명이나 내장 모듈)를 표시합니다. 두 번 주어지면 "
"(:option:`!-vv`), 모듈을 검색할 때 검사되는 각 파일에 대한 메시지를 인쇄합니다. 종료 시 모듈 정리에 대한 정보도 "
"제공합니다. :envvar:`PYTHONVERBOSE` 도 참조하십시오."

#: ../Doc/using/cmdline.rst:360
msgid ""
"Warning control.  Python's warning machinery by default prints warning "
"messages to :data:`sys.stderr`.  A typical warning message has the "
"following form:"
msgstr ""
"경고 제어. 파이썬의 경고 장치는 기본적으로 :data:`sys.stderr` 로 경고 메시지를 인쇄합니다. 일반적인 경고 메시지의"
" 형식은 다음과 같습니다:"

#: ../Doc/using/cmdline.rst:368
msgid ""
"By default, each warning is printed once for each source line where it "
"occurs.  This option controls how often warnings are printed."
msgstr "기본적으로, 각 경고는 발생하는 각 소스 행마다 한 번씩 인쇄됩니다. 이 옵션은 경고 인쇄 빈도를 제어합니다."

#: ../Doc/using/cmdline.rst:371
msgid ""
"Multiple :option:`-W` options may be given; when a warning matches more "
"than one option, the action for the last matching option is performed.  "
"Invalid :option:`-W` options are ignored (though, a warning message is "
"printed about invalid options when the first warning is issued)."
msgstr ""
"다중 :option:`-W` 옵션이 주어질 수 있습니다; 경고가 두 개 이상의 옵션과 일치하면 마지막으로 일치하는 옵션의 액션이 "
"수행됩니다. 유효하지 않은 :option:`-W` 옵션은 무시됩니다 (하지만, 최초의 경고가 발생할 때 유효하지 않은 옵션에 관한 "
"경고 메시지가 출력됩니다)."

#: ../Doc/using/cmdline.rst:376
msgid ""
"Warnings can also be controlled using the :envvar:`PYTHONWARNINGS` "
"environment variable and from within a Python program using the "
":mod:`warnings` module."
msgstr ""
"경고는 :envvar:`PYTHONWARNINGS` 환경 변수와 파이썬 프로그램 내에서 :mod:`warnings` 모듈을 사용해서"
" 제어할 수도 있습니다."

#: ../Doc/using/cmdline.rst:380 ../Doc/using/cmdline.rst:662
msgid ""
"The simplest settings apply a particular action unconditionally to all "
"warnings emitted by a process (even those that are otherwise ignored by "
"default)::"
msgstr "가장 단순한 설정은 프로세스가 만드는 모든 경고에 무조건 특정 액션을 적용합니다 (그렇지 않으면 기본적으로 무시되는 경고조차도)::"

#: ../Doc/using/cmdline.rst:391
msgid ""
"The action names can be abbreviated as desired (e.g. ``-Wi``, ``-Wd``, "
"``-Wa``, ``-We``) and the interpreter will resolve them to the "
"appropriate action name."
msgstr ""
"액션 이름은 원하면 줄일 수 있고 (예, ``-Wi``, ``-Wd``, ``-Wa``, ``-We``), 인터프리터는 이를 적절한"
" 액션 이름으로 해석합니다."

#: ../Doc/using/cmdline.rst:395 ../Doc/using/cmdline.rst:673
msgid ""
"See :ref:`warning-filter` and :ref:`describing-warning-filters` for more "
"details."
msgstr ""
"자세한 내용은 :ref:`warning-filter`\\와 :ref:`describing-warning-filters`\\를 "
"참조하십시오."

#: ../Doc/using/cmdline.rst:401
msgid ""
"Skip the first line of the source, allowing use of non-Unix forms of "
"``#!cmd``.  This is intended for a DOS specific hack only."
msgstr ""
"소스의 첫 번째 줄을 건너 뛰어서, 유닉스 이외의 형식의 ``#!cmd`` 을 사용할 수 있게 합니다. 이것은 DOS 전용 "
"핵(hack)을 위한 것입니다."

#: ../Doc/using/cmdline.rst:407
msgid ""
"Reserved for various implementation-specific options.  CPython currently "
"defines the following possible values:"
msgstr "다양한 구현 특정 옵션을 위해 예약되어 있습니다. CPython은 현재 다음과 같은 가능한 값을 정의합니다:"

#: ../Doc/using/cmdline.rst:410
msgid "``-X faulthandler`` to enable :mod:`faulthandler`;"
msgstr "``-X faulthandler`` 는 :mod:`faulthandler` 를 활성화합니다;"

#: ../Doc/using/cmdline.rst:411
msgid ""
"``-X showrefcount`` to output the total reference count and number of "
"used memory blocks when the program finishes or after each statement in "
"the interactive interpreter. This only works on debug builds."
msgstr ""
"``-X showrefcount`` 는 프로그램이 끝나거나 대화형 인터프리터에서 각각의 문장 뒤에서, 총 참조 카운트와 사용된 "
"메모리 블록의 수를 출력합니다. 이것은 디버그 빌드에서만 작동합니다."

#: ../Doc/using/cmdline.rst:414
msgid ""
"``-X tracemalloc`` to start tracing Python memory allocations using the "
":mod:`tracemalloc` module. By default, only the most recent frame is "
"stored in a traceback of a trace. Use ``-X tracemalloc=NFRAME`` to start "
"tracing with a traceback limit of *NFRAME* frames. See the "
":func:`tracemalloc.start` for more information."
msgstr ""
"``-X tracemalloc`` 은 :mod:`tracemalloc` 모듈을 사용하여 파이썬 메모리 할당 추적을 시작합니다. "
"기본적으로, 가장 최근 프레임만 추적의 트레이스백에 저장됩니다. *NFRAME* 프레임의 트레이스백 한도로 추적을 시작하려면 "
"``-X tracemalloc=NFRAME`` 을 사용하십시오. 자세한 정보는 :func:`tracemalloc.start` 를 "
"참조하십시오."

#: ../Doc/using/cmdline.rst:419
msgid ""
"``-X showalloccount`` to output the total count of allocated objects for "
"each type when the program finishes. This only works when Python was "
"built with ``COUNT_ALLOCS`` defined."
msgstr ""
"``-X showalloccount`` 은 프로그램이 끝날 때 형별로 할당된 객체의 총수를 출력합니다. 이것은 파이썬이 "
"``COUNT_ALLOCS`` 이 정의 된 상태로 빌드되었을 때만 작동합니다."

#: ../Doc/using/cmdline.rst:422
msgid ""
"``-X importtime`` to show how long each import takes. It shows module "
"name, cumulative time (including nested imports) and self time (excluding"
" nested imports).  Note that its output may be broken in multi-threaded "
"application.  Typical usage is ``python3 -X importtime -c 'import "
"asyncio'``.  See also :envvar:`PYTHONPROFILEIMPORTTIME`."
msgstr ""
"``-X importtime`` 은 각 임포트가 얼마나 오래 걸렸는지 보여줍니다. 모듈 이름, 누적 시간(중첩된 임포트 포함), "
"자체 시간(중첩 임포트 제외)을 표시합니다. 다중 스레드 응용 프로그램에서 출력이 깨질 수 있음에 유의하십시오. 일반적인 사용법은 "
"``python3 -X importtime -c 'import asyncio'`` 입니다. "
":envvar:`PYTHONPROFILEIMPORTTIME` 도 참조하십시오."

#: ../Doc/using/cmdline.rst:427
msgid ""
"``-X dev``: enable CPython's \"development mode\", introducing additional"
" runtime checks which are too expensive to be enabled by default. It "
"should not be more verbose than the default if the code is correct: new "
"warnings are only emitted when an issue is detected. Effect of the "
"developer mode:"
msgstr ""
"``-X dev``: CPython의 \"개발 모드\"를 활성화해서, 기본적으로 활성화하기에는 너무 비싼 추가적인 실행시간 검사를 "
"도입합니다. 코드가 올바르면 기본값보다 더 상세하지는 않아야 합니다: 문제가 감지되었을 때만 새로운 경고가 발생합니다. 개발자 "
"모드의 효과는 다음과 같습니다:"

#: ../Doc/using/cmdline.rst:432
msgid "Add ``default`` warning filter, as :option:`-W` ``default``."
msgstr ":option:`-W` ``default`` 처럼, ``default`` 경고 필터를 추가합니다."

#: ../Doc/using/cmdline.rst:433
msgid ""
"Install debug hooks on memory allocators: see the "
":c:func:`PyMem_SetupDebugHooks` C function."
msgstr "메모리 할당자에 디버그 훅을 설치합니다: :c:func:`PyMem_SetupDebugHooks` C 함수를 참조하십시오."

#: ../Doc/using/cmdline.rst:435
msgid ""
"Enable the :mod:`faulthandler` module to dump the Python traceback on a "
"crash."
msgstr "충돌 시에 파이썬 트레이스백을 덤프하도록 :mod:`faulthandler` 모듈을 활성화합니다."

#: ../Doc/using/cmdline.rst:437
msgid "Enable :ref:`asyncio debug mode <asyncio-debug-mode>`."
msgstr ":ref:`asyncio 디버그 모드 <asyncio-debug-mode>` 를 활성화합니다."

#: ../Doc/using/cmdline.rst:438
msgid ""
"Set the :attr:`~sys.flags.dev_mode` attribute of :attr:`sys.flags` to "
"``True``"
msgstr ":attr:`sys.flags` 의 :attr:`~sys.flags.dev_mode` 어트리뷰트를 ``True`` 로 설정합니다"

#: ../Doc/using/cmdline.rst:441
msgid ""
"``-X utf8`` enables UTF-8 mode for operating system interfaces, "
"overriding the default locale-aware mode. ``-X utf8=0`` explicitly "
"disables UTF-8 mode (even when it would otherwise activate "
"automatically). See :envvar:`PYTHONUTF8` for more details."
msgstr ""
"``-X utf8`` 은 운영 체제 인터페이스를 위한 UTF-8 모드를 활성화하여, 기본 로케일 인식 모드를 대체합니다. ``-X "
"utf8=0`` 은 명시적으로 UTF-8 모드를 비활성화합니다 (그렇지 않으면 자동으로 활성화될 때조차). 자세한 내용은 "
":envvar:`PYTHONUTF8` 을 참조하십시오."

#: ../Doc/using/cmdline.rst:446
msgid ""
"It also allows passing arbitrary values and retrieving them through the "
":data:`sys._xoptions` dictionary."
msgstr "또한 :data:`sys._xoptions` 딕셔너리를 통해 임의의 값을 전달하고 조회할 수 있도록 합니다."

#: ../Doc/using/cmdline.rst:449
msgid "The :option:`-X` option was added."
msgstr ":option:`-X` 옵션이 추가되었습니다."

#: ../Doc/using/cmdline.rst:452
msgid "The ``-X faulthandler`` option."
msgstr "``-X faulthandler`` 옵션."

#: ../Doc/using/cmdline.rst:455
msgid "The ``-X showrefcount`` and ``-X tracemalloc`` options."
msgstr "``-X showrefcount`` 와 ``-X tracemalloc`` 옵션."

#: ../Doc/using/cmdline.rst:458
msgid "The ``-X showalloccount`` option."
msgstr "``-X showalloccount`` 옵션."

#: ../Doc/using/cmdline.rst:461
msgid "The ``-X importtime``, ``-X dev`` and ``-X utf8`` options."
msgstr "``-X importtime``, ``-X dev``, ``-X utf8`` 옵션."

#: ../Doc/using/cmdline.rst:466
msgid "Options you shouldn't use"
msgstr "사용해서는 안 되는 옵션"

#: ../Doc/using/cmdline.rst:470
msgid "Reserved for use by Jython_."
msgstr "Jython_ 이 사용하기 위해 예약되었습니다."

#: ../Doc/using/cmdline.rst:478
msgid "Environment variables"
msgstr "환경 변수"

#: ../Doc/using/cmdline.rst:480
msgid ""
"These environment variables influence Python's behavior, they are "
"processed before the command-line switches other than -E or -I.  It is "
"customary that command-line switches override environmental variables "
"where there is a conflict."
msgstr ""
"이 환경 변수들은 파이썬의 동작에 영향을 주며, -E와 -I 이외의 명령 줄 스위치보다 먼저 처리됩니다. 충돌하면 명령 줄 스위치가"
" 환경 변수에 우선하는 것이 관례입니다."

#: ../Doc/using/cmdline.rst:487
msgid ""
"Change the location of the standard Python libraries.  By default, the "
"libraries are searched in :file:`{prefix}/lib/python{version}` and "
":file:`{exec_prefix}/lib/python{version}`, where :file:`{prefix}` and "
":file:`{exec_prefix}` are installation-dependent directories, both "
"defaulting to :file:`/usr/local`."
msgstr ""
"표준 파이썬 라이브러리의 위치를 변경합니다. 기본적으로, 라이브러리는 "
":file:`{prefix}/lib/python{version}`\\과 "
":file:`{exec_prefix}/lib/python{version}`\\에서 검색되는데, :file:`{prefix}` 와 "
":file:`{exec_prefix}` 는 설치 의존적인 디렉터리이고, 둘 다 기본값은 :file:`/usr/local` 입니다."

#: ../Doc/using/cmdline.rst:493
msgid ""
"When :envvar:`PYTHONHOME` is set to a single directory, its value "
"replaces both :file:`{prefix}` and :file:`{exec_prefix}`.  To specify "
"different values for these, set :envvar:`PYTHONHOME` to "
":file:`{prefix}:{exec_prefix}`."
msgstr ""
":envvar:`PYTHONHOME` 이 하나의 디렉터리로 설정되면, 그 값은 :file:`{prefix}` 와 "
":file:`{exec_prefix}` 를 모두 대체합니다. 이들에 대해 다른 값을 지정하려면, "
":envvar:`PYTHONHOME` 을 :file:`{prefix}:{exec_prefix}` 로 설정하십시오."

#: ../Doc/using/cmdline.rst:500
msgid ""
"Augment the default search path for module files.  The format is the same"
" as the shell's :envvar:`PATH`: one or more directory pathnames separated"
" by :data:`os.pathsep` (e.g. colons on Unix or semicolons on Windows). "
"Non-existent directories are silently ignored."
msgstr ""
"모듈 파일의 기본 검색 경로를 보강합니다. 형식은 셸의 :envvar:`PATH` 와 같습니다: 하나 이상의 디렉터리 경로명이 "
":data:`os.pathsep` (예를 들어, 유닉스에서는 콜론, 윈도우에서는 세미콜론) 로 구분됩니다. 존재하지 않는 디렉터리는"
" 조용히 무시됩니다."

#: ../Doc/using/cmdline.rst:505
msgid ""
"In addition to normal directories, individual :envvar:`PYTHONPATH` "
"entries may refer to zipfiles containing pure Python modules (in either "
"source or compiled form). Extension modules cannot be imported from "
"zipfiles."
msgstr ""
"일반 디렉터리 외에도, 개별 :envvar:`PYTHONPATH` 엔트리는 순수 파이썬 모듈(소스 또는 컴파일된 형식)을 포함하는 "
"zip 파일을 가리킬 수 있습니다. 확장 모듈은 zip 파일에서 임포트될 수 없습니다."

#: ../Doc/using/cmdline.rst:509
msgid ""
"The default search path is installation dependent, but generally begins "
"with :file:`{prefix}/lib/python{version}` (see :envvar:`PYTHONHOME` "
"above).  It is *always* appended to :envvar:`PYTHONPATH`."
msgstr ""
"기본 검색 경로는 설치 의존적이지만, 일반적으로 :file:`{prefix}/lib/python{version}`\\으로 시작합니다"
" (위의 :envvar:`PYTHONHOME` 을 참조하세요). *항상* :envvar:`PYTHONPATH` 에 추가됩니다."

#: ../Doc/using/cmdline.rst:513
msgid ""
"An additional directory will be inserted in the search path in front of "
":envvar:`PYTHONPATH` as described above under :ref:`using-on-interface-"
"options`. The search path can be manipulated from within a Python program"
" as the variable :data:`sys.path`."
msgstr ""
"위에서 설명한 대로 :ref:`using-on-interface-options` 하에서는 :envvar:`PYTHONPATH` 앞에"
" 검색 경로에 추가 디렉터리가 삽입됩니다. 검색 경로는 파이썬 프로그램 내에서 :data:`sys.path` 변수로 조작할 수 "
"있습니다."

#: ../Doc/using/cmdline.rst:521
msgid ""
"If this is the name of a readable file, the Python commands in that file "
"are executed before the first prompt is displayed in interactive mode.  "
"The file is executed in the same namespace where interactive commands are"
" executed so that objects defined or imported in it can be used without "
"qualification in the interactive session.  You can also change the "
"prompts :data:`sys.ps1` and :data:`sys.ps2` and the hook "
":data:`sys.__interactivehook__` in this file."
msgstr ""
"이것이 읽을 수 있는 파일의 이름이면, 첫 번째 프롬프트가 대화형 모드에 표시되기 전에, 해당 파일의 파이썬 명령이 실행됩니다. 이"
" 파일은 대화형 명령이 실행되는 것과 같은 이름 공간에서 실행되므로, 여기에서 정의되거나 임포트 한 객체를 대화형 세션에서 그대로 "
"사용할 수 있습니다. 이 파일에서 프롬프트 :data:`sys.ps1` 과 :data:`sys.ps2` 와 훅 "
":data:`sys.__interactivehook__` 도 바꿀 수 있습니다."

#: ../Doc/using/cmdline.rst:531
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-O` option.  If set to an integer, it is equivalent to "
"specifying :option:`-O` multiple times."
msgstr ""
"비어 있지 않은 문자열로 설정하면 :option:`-O` 옵션을 지정하는 것과 같습니다. 정수로 설정하면, "
":option:`-O`\\를 여러 번 지정하는 것과 같습니다."

#: ../Doc/using/cmdline.rst:538
msgid ""
"If this is set, it names a callable using dotted-path notation.  The "
"module containing the callable will be imported and then the callable "
"will be run by the default implementation of :func:`sys.breakpointhook` "
"which itself is called by built-in :func:`breakpoint`.  If not set, or "
"set to the empty string, it is equivalent to the value \"pdb.set_trace\"."
"  Setting this to the string \"0\" causes the default implementation of "
":func:`sys.breakpointhook` to do nothing but return immediately."
msgstr ""
"설정되면, 점으로 구분된 경로 표기법을 사용하여 콜러블의 이름을 지정합니다. 콜러블을 포함하는 모듈이 임포트 된 후에 콜러블은, "
"내장 :func:`breakpoint` 에 의해 호출되는 :func:`sys.breakpointhook` 의 기본 구현이 "
"실행합니다. 설정되지 않았거나 빈 문자열로 설정하면, 값 \"pdb.set_trace\"와 동등합니다. 문자열 \"0\"으로 "
"설정하면, :func:`sys.breakpointhook` 의 기본 구현은 아무것도 하지 않고 즉시 반환합니다."

#: ../Doc/using/cmdline.rst:550
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-d` option.  If set to an integer, it is equivalent to "
"specifying :option:`-d` multiple times."
msgstr ""
"비어 있지 않은 문자열로 설정하면, :option:`-d` 옵션을 지정하는 것과 같습니다. 정수로 설정하면, "
":option:`-d`\\를 여러 번 지정하는 것과 같습니다."

#: ../Doc/using/cmdline.rst:557
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-i` option."
msgstr "비어 있지 않은 문자열로 설정하면, :option:`-i` 옵션을 지정하는 것과 같습니다."

#: ../Doc/using/cmdline.rst:560
msgid ""
"This variable can also be modified by Python code using "
":data:`os.environ` to force inspect mode on program termination."
msgstr ""
"이 변수는 프로그램 종료 시 검사 모드를 강제하기 위해, :data:`os.environ` 을 사용해서 파이썬 코드에 의해 수정될 "
"수도 있습니다."

#: ../Doc/using/cmdline.rst:566
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-u` option."
msgstr "비어 있지 않은 문자열로 설정하면, :option:`-u` 옵션을 지정하는 것과 같습니다."

#: ../Doc/using/cmdline.rst:572
msgid ""
"If this is set to a non-empty string it is equivalent to specifying the "
":option:`-v` option.  If set to an integer, it is equivalent to "
"specifying :option:`-v` multiple times."
msgstr ""
"비어 있지 않은 문자열로 설정하면, :option:`-v` 옵션을 지정하는 것과 같습니다. 정수로 설정하면 "
":option:`-v`\\를 여러 번 지정하는 것과 같습니다."

#: ../Doc/using/cmdline.rst:579
msgid ""
"If this is set, Python ignores case in :keyword:`import` statements.  "
"This only works on Windows and OS X."
msgstr "설정되면, 파이썬은 :keyword:`import` 문에서 대소 문자를 무시합니다. 이것은 윈도우와 OS X에서만 작동합니다."

#: ../Doc/using/cmdline.rst:585
msgid ""
"If this is set to a non-empty string, Python won't try to write ``.pyc`` "
"files on the import of source modules.  This is equivalent to specifying "
"the :option:`-B` option."
msgstr ""
"비어 있지 않은 문자열로 설정되면, 파이썬은 소스 모듈을 임포트 할 때 ``.pyc`` 파일을 쓰지 않습니다. 이는 "
":option:`-B` 옵션을 지정하는 것과 같습니다."

#: ../Doc/using/cmdline.rst:592
msgid ""
"If this variable is not set or set to ``random``, a random value is used "
"to seed the hashes of str, bytes and datetime objects."
msgstr ""
"이 변수가 설정되어 있지 않거나 ``random`` 으로 설정되면, str, bytes, datetime 객체의 해시 시드에 난수가"
" 사용됩니다."

#: ../Doc/using/cmdline.rst:595
msgid ""
"If :envvar:`PYTHONHASHSEED` is set to an integer value, it is used as a "
"fixed seed for generating the hash() of the types covered by the hash "
"randomization."
msgstr ""
":envvar:`PYTHONHASHSEED` 가 정숫값으로 설정되면, 해시 무작위화가 적용되는 형의 hash()를 생성하기 위한 "
"고정 시드로 사용됩니다."

#: ../Doc/using/cmdline.rst:599
msgid ""
"Its purpose is to allow repeatable hashing, such as for selftests for the"
" interpreter itself, or to allow a cluster of python processes to share "
"hash values."
msgstr ""
"목적은 인터프리터 자체에 대한 셀프 테스트와 같은 이유로 반복 가능한 해싱을 허용하거나, 파이썬 프로세스 클러스터가 해시값을 "
"공유하도록 허용하는 것입니다."

#: ../Doc/using/cmdline.rst:603
msgid ""
"The integer must be a decimal number in the range [0,4294967295].  "
"Specifying the value 0 will disable hash randomization."
msgstr "정수는 [0,4294967295] 범위의 십진수여야 합니다. 값 0을 지정하면 해시 무작위화가 비활성화됩니다."

#: ../Doc/using/cmdline.rst:611
msgid ""
"If this is set before running the interpreter, it overrides the encoding "
"used for stdin/stdout/stderr, in the syntax "
"``encodingname:errorhandler``.  Both the ``encodingname`` and the "
"``:errorhandler`` parts are optional and have the same meaning as in "
":func:`str.encode`."
msgstr ""
"인터프리터를 실행하기 전에 이것이 설정되면, stdin/stdout/stderr에 사용되는 인코딩을 대체합니다. 문법은 "
"``encodingname:errorhandler`` 형식입니다. ``encodingname`` 과 ``:errorhandler``"
" 부분은 모두 선택 사항이며 :func:`str.encode` 에서와 같은 의미입니다."

#: ../Doc/using/cmdline.rst:616
msgid ""
"For stderr, the ``:errorhandler`` part is ignored; the handler will "
"always be ``'backslashreplace'``."
msgstr ""
"stderr의 경우, ``:errorhandler`` 부분은 무시됩니다; 처리기는 항상 ``'backslashreplace'`` "
"입니다."

#: ../Doc/using/cmdline.rst:619
msgid "The ``encodingname`` part is now optional."
msgstr "``encodingname`` 부분은 이제 선택적입니다."

#: ../Doc/using/cmdline.rst:622
msgid ""
"On Windows, the encoding specified by this variable is ignored for "
"interactive console buffers unless :envvar:`PYTHONLEGACYWINDOWSSTDIO` is "
"also specified. Files and pipes redirected through the standard streams "
"are not affected."
msgstr ""
"Windows에서, :envvar:`PYTHONLEGACYWINDOWSSTDIO` 도 지정하지 않는 한, 대화형 콘솔 버퍼에서 이 "
"변수로 지정된 인코딩이 무시됩니다. 표준 스트림을 통해 리디렉션 된 파일과 파이프는 영향을 받지 않습니다."

#: ../Doc/using/cmdline.rst:629
msgid ""
"If this is set, Python won't add the :data:`user site-packages directory "
"<site.USER_SITE>` to :data:`sys.path`."
msgstr ""
"설정되면, 파이썬은 :data:`사용자 site-packages 디렉터리 <site.USER_SITE>` 를 "
":data:`sys.path` 에 추가하지 않습니다."

#: ../Doc/using/cmdline.rst:639
msgid ""
"Defines the :data:`user base directory <site.USER_BASE>`, which is used "
"to compute the path of the :data:`user site-packages directory "
"<site.USER_SITE>` and :ref:`Distutils installation paths <inst-alt-"
"install-user>` for ``python setup.py install --user``."
msgstr ""
"``python setup.py install --user`` 에서 :data:`사용자 site-packages 디렉터리 "
"<site.USER_SITE>` 의 경로와 :ref:`Distutils 설치 경로 <inst-alt-install-user>` 를 "
"계산하기 위해 사용되는 :data:`사용자 베이스 디렉터리 <site.USER_BASE>` 를 정의합니다."

#: ../Doc/using/cmdline.rst:651
msgid ""
"If this environment variable is set, ``sys.argv[0]`` will be set to its "
"value instead of the value got through the C runtime.  Only works on Mac "
"OS X."
msgstr ""
"이 환경 변수가 설정되면, ``sys.argv[0]`` 는 C 런타임을 통해 얻은 값 대신에 이 값으로 설정됩니다. 맥 OS "
"X에서만 작동합니다."

#: ../Doc/using/cmdline.rst:657
msgid ""
"This is equivalent to the :option:`-W` option. If set to a comma "
"separated string, it is equivalent to specifying :option:`-W` multiple "
"times, with filters later in the list taking precedence over those "
"earlier in the list."
msgstr ""
":option:`-W` 옵션과 동등합니다. 쉼표로 구분된 문자열로 설정하면, :option:`-W`\\를 여러 번 지정하는 것과 "
"같습니다. 목록의 뒷부분에 있는 필터는 목록의 이전 필터보다 우선합니다."

#: ../Doc/using/cmdline.rst:679
msgid ""
"If this environment variable is set to a non-empty string, "
":func:`faulthandler.enable` is called at startup: install a handler for "
":const:`SIGSEGV`, :const:`SIGFPE`, :const:`SIGABRT`, :const:`SIGBUS` and "
":const:`SIGILL` signals to dump the Python traceback.  This is equivalent"
" to :option:`-X` ``faulthandler`` option."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, :func:`faulthandler.enable` 이 시작 시에 호출됩니다: "
"파이썬 트레이스백을 덤프하는 :const:`SIGSEGV`, :const:`SIGFPE`, :const:`SIGABRT`, "
":const:`SIGBUS` 그리고 :const:`SIGILL` 시그널 처리기를 설치합니다. 이는 :option:`-X` "
"``faulthandler`` 옵션과 동등합니다."

#: ../Doc/using/cmdline.rst:690
msgid ""
"If this environment variable is set to a non-empty string, start tracing "
"Python memory allocations using the :mod:`tracemalloc` module. The value "
"of the variable is the maximum number of frames stored in a traceback of "
"a trace. For example, ``PYTHONTRACEMALLOC=1`` stores only the most recent"
" frame. See the :func:`tracemalloc.start` for more information."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, :mod:`tracemalloc` 모듈을 사용하여 파이썬 메모리 할당 추적을 "
"시작합니다. 변수의 값은 추적의 트레이스백에 저장되는 최대 프레임 수입니다. 예를 들어, ``PYTHONTRACEMALLOC=1``"
" 은 가장 최근의 프레임만을 저장합니다. 자세한 정보는 :func:`tracemalloc.start` 를 참조하십시오."

#: ../Doc/using/cmdline.rst:701
msgid ""
"If this environment variable is set to a non-empty string, Python will "
"show how long each import takes.  This is exactly equivalent to setting "
"``-X importtime`` on the command line."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, 파이썬은 각 임포트에 걸리는 시간을 보여줍니다. 이는 명령 줄에서 ``-X "
"importtime`` 을 설정하는 것과 정확히 같습니다."

#: ../Doc/using/cmdline.rst:710
msgid ""
"If this environment variable is set to a non-empty string, enable the "
":ref:`debug mode <asyncio-debug-mode>` of the :mod:`asyncio` module."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, :mod:`asyncio` 모듈의 :ref:`디버그 모드 <asyncio-"
"debug-mode>` 를 활성화합니다."

#: ../Doc/using/cmdline.rst:718
msgid "Set the Python memory allocators and/or install debug hooks."
msgstr "파이썬 메모리 할당자를 설정하거나 디버그 훅을 설치합니다."

#: ../Doc/using/cmdline.rst:720
msgid "Set the family of memory allocators used by Python:"
msgstr "파이썬이 사용하는 메모리 할당자를 설정합니다:"

#: ../Doc/using/cmdline.rst:722
msgid ""
"``default``: use the :ref:`default memory allocators <default-memory-"
"allocators>`."
msgstr "``default``: :ref:`기본 메모리 할당자 <default-memory-allocators>` 를 사용합니다."

#: ../Doc/using/cmdline.rst:724
msgid ""
"``malloc``: use the :c:func:`malloc` function of the C library for all "
"domains (:c:data:`PYMEM_DOMAIN_RAW`, :c:data:`PYMEM_DOMAIN_MEM`, "
":c:data:`PYMEM_DOMAIN_OBJ`)."
msgstr ""
"``malloc``: 모든 영역(:c:data:`PYMEM_DOMAIN_RAW`, :c:data:`PYMEM_DOMAIN_MEM`,"
" :c:data:`PYMEM_DOMAIN_OBJ`)에서 C 라이브러리의 :c:func:`malloc` 함수를 사용합니다."

#: ../Doc/using/cmdline.rst:727
msgid ""
"``pymalloc``: use the :ref:`pymalloc allocator <pymalloc>` for "
":c:data:`PYMEM_DOMAIN_MEM` and :c:data:`PYMEM_DOMAIN_OBJ` domains and use"
" the :c:func:`malloc` function for the :c:data:`PYMEM_DOMAIN_RAW` domain."
msgstr ""
"``pymalloc``: :c:data:`PYMEM_DOMAIN_MEM`\\과 :c:data:`PYMEM_DOMAIN_OBJ` "
"영역에서 :ref:`pymalloc 할당자 <pymalloc>` 를 사용하고, :c:data:`PYMEM_DOMAIN_RAW` "
"영역에서 :c:func:`malloc` 함수를 사용합니다."

#: ../Doc/using/cmdline.rst:731
msgid "Install debug hooks:"
msgstr "디버그 훅을 설치합니다:"

#: ../Doc/using/cmdline.rst:733
msgid ""
"``debug``: install debug hooks on top of the :ref:`default memory "
"allocators <default-memory-allocators>`."
msgstr "``debug``: :ref:`기본 메모리 할당자 <default-memory-allocators>` 위에 디버그 훅을 설치합니다."

#: ../Doc/using/cmdline.rst:735
msgid "``malloc_debug``: same as ``malloc`` but also install debug hooks"
msgstr "``malloc_debug``: ``malloc`` 과 같지만, 디버그 훅도 설치합니다"

#: ../Doc/using/cmdline.rst:736
msgid "``pymalloc_debug``: same as ``pymalloc`` but also install debug hooks"
msgstr "``pymalloc_debug``: ``pymalloc`` 과 같지만, 디버그 훅도 설치합니다"

#: ../Doc/using/cmdline.rst:738
msgid ""
"See the :ref:`default memory allocators <default-memory-allocators>` and "
"the :c:func:`PyMem_SetupDebugHooks` function (install debug hooks on "
"Python memory allocators)."
msgstr ""
":ref:`기본 메모리 할당자 <default-memory-allocators>` 와 "
":c:func:`PyMem_SetupDebugHooks` 함수(파이썬 메모리 할당자에 디버그 훅을 설치합니다)도 참조하세요."

#: ../Doc/using/cmdline.rst:742
msgid "Added the ``\"default\"`` allocator."
msgstr "``\"default\"`` 할당자를 추가했습니다."

#: ../Doc/using/cmdline.rst:750
msgid ""
"If set to a non-empty string, Python will print statistics of the "
":ref:`pymalloc memory allocator <pymalloc>` every time a new pymalloc "
"object arena is created, and on shutdown."
msgstr ""
"비어 있지 않은 문자열로 설정되면, 파이썬은 새로운 pymalloc 객체 영역이 생성될 때마다, 그리고 종료할 때 "
":ref:`pymalloc 메모리 할당자 <pymalloc>` 의 통계를 인쇄합니다."

#: ../Doc/using/cmdline.rst:754
msgid ""
"This variable is ignored if the :envvar:`PYTHONMALLOC` environment "
"variable is used to force the :c:func:`malloc` allocator of the C "
"library, or if Python is configured without ``pymalloc`` support."
msgstr ""
":envvar:`PYTHONMALLOC` 환경 변수를 사용하여 C 라이브러리의 :c:func:`malloc` 할당자를 강제로 "
"사용하거나, ``pymalloc`` 지원 없이 파이썬을 구성하면, 이 변수는 무시됩니다."

#: ../Doc/using/cmdline.rst:758
msgid ""
"This variable can now also be used on Python compiled in release mode. It"
" now has no effect if set to an empty string."
msgstr "이 변수는 이제 배포 모드로 컴파일된 파이썬에서도 사용할 수 있습니다. 이제 빈 문자열로 설정하면 효과가 없습니다."

#: ../Doc/using/cmdline.rst:765
msgid ""
"If set to a non-empty string, the default filesystem encoding and errors "
"mode will revert to their pre-3.6 values of 'mbcs' and 'replace', "
"respectively. Otherwise, the new defaults 'utf-8' and 'surrogatepass' are"
" used."
msgstr ""
"비어 있지 않은 문자열로 설정하면, 기본 파일 시스템 인코딩과 에러 모드를 3.6 이전의 값인 'mbcs'와 'replace'로 "
"각각 되돌립니다. 그렇지 않으면, 새 기본값 'utf-8'과 'surrogatepass'가 사용됩니다."

#: ../Doc/using/cmdline.rst:769
msgid ""
"This may also be enabled at runtime with "
":func:`sys._enablelegacywindowsfsencoding()`."
msgstr ""
"이것은 또한 실행 시간에 :func:`sys._enablelegacywindowsfsencoding()` 으로 활성화 될 수 "
"있습니다."

#: ../Doc/using/cmdline.rst:773 ../Doc/using/cmdline.rst:787
msgid "Availability: Windows."
msgstr "가용성: 윈도우."

#: ../Doc/using/cmdline.rst:774
msgid "See :pep:`529` for more details."
msgstr "자세한 내용은 :pep:`529`\\를 참조하십시오."

#: ../Doc/using/cmdline.rst:779
msgid ""
"If set to a non-empty string, does not use the new console reader and "
"writer. This means that Unicode characters will be encoded according to "
"the active console code page, rather than using utf-8."
msgstr ""
"비어 있지 않은 문자열로 설정하면, 새 콘솔 입력기와 출력기를 사용하지 않습니다. 이것은 유니코드 문자가 utf-8을 사용하는 대신"
" 활성 콘솔 코드 페이지에 따라 인코딩됨을 의미합니다."

#: ../Doc/using/cmdline.rst:783
msgid ""
"This variable is ignored if the standard streams are redirected (to files"
" or pipes) rather than referring to console buffers."
msgstr "이 변수는 표준 스트림이 콘솔 버퍼를 참조하는 대신 리디렉트 된 (파일 또는 파이프로) 경우 무시됩니다."

#: ../Doc/using/cmdline.rst:793
msgid ""
"If set to the value ``0``, causes the main Python command line "
"application to skip coercing the legacy ASCII-based C and POSIX locales "
"to a more capable UTF-8 based alternative."
msgstr ""
"값 ``0`` 으로 설정하면, 주 파이썬 명령 줄 응용 프로그램이 레거시 ASCII 기반 C와 POSIX 로케일을 보다 유능한 "
"UTF-8 기반 대안으로 강제 변환하지 않습니다."

#: ../Doc/using/cmdline.rst:797
msgid ""
"If this variable is *not* set (or is set to a value other than ``0``), "
"the ``LC_ALL`` locale override environment variable is also not set, and "
"the current locale reported for the ``LC_CTYPE`` category is either the "
"default ``C`` locale, or else the explicitly ASCII-based ``POSIX`` "
"locale, then the Python CLI will attempt to configure the following "
"locales for the ``LC_CTYPE`` category in the order listed before loading "
"the interpreter runtime:"
msgstr ""
"이 변수가 설정되지 *않고* (또는 ``0`` 이외의 값으로 설정되고), 환경 변수에 우선하는 ``LC_ALL`` 로케일도 설정되지"
" 않고, ``LC_CTYPE`` 범주에 대해 보고되는 현재 로케일이 기본 ``C`` 로케일이거나 명시적인 ASCII 기반의 "
"``POSIX`` 로케일이면, 파이썬 CLI는 인터프리터 런타임을 로드하기 전에 ``LC_CTYPE`` 범주에 대해 다음 로케일을 "
"나열된 순서대로 구성하려고 시도합니다:"

#: ../Doc/using/cmdline.rst:805
msgid "``C.UTF-8``"
msgstr "``C.UTF-8``"

#: ../Doc/using/cmdline.rst:806
msgid "``C.utf8``"
msgstr "``C.utf8``"

#: ../Doc/using/cmdline.rst:807
msgid "``UTF-8``"
msgstr "``UTF-8``"

#: ../Doc/using/cmdline.rst:809
msgid ""
"If setting one of these locale categories succeeds, then the ``LC_CTYPE``"
" environment variable will also be set accordingly in the current process"
" environment before the Python runtime is initialized. This ensures that "
"in addition to being seen by both the interpreter itself and other "
"locale-aware components running in the same process (such as the GNU "
"``readline`` library), the updated setting is also seen in subprocesses "
"(regardless of whether or not those processes are running a Python "
"interpreter), as well as in operations that query the environment rather "
"than the current C locale (such as Python's own "
":func:`locale.getdefaultlocale`)."
msgstr ""
"이러한 로케일 범주 중 하나를 설정하는 데 성공하면, 파이썬 런타임이 초기화되기 전에 ``LC_CTYPE`` 환경 변수도 현재 "
"프로세스 환경에서 적절히 설정됩니다. 이렇게 하면 인터프리터 자신과 같은 프로세스에서 실행되는 다른 로케일 인식 구성 요소(가령 "
"GNU ``readline`` 라이브러리)가 볼 수 있는 것에 더해, 갱신된 설정을 현재 C 로케일이 아닌 환경을 조회하는 "
"연산(가령 파이썬 자체의 :func:`locale.getdefaultlocale`)뿐만 아니라, 자식 프로세스에서도 (이 프로세스가"
" 파이썬 인터프리터를 실행하는지에 관계없이) 볼 수 있습니다."

#: ../Doc/using/cmdline.rst:819
msgid ""
"Configuring one of these locales (either explicitly or via the above "
"implicit locale coercion) automatically enables the ``surrogateescape`` "
":ref:`error handler <error-handlers>` for :data:`sys.stdin` and "
":data:`sys.stdout` (:data:`sys.stderr` continues to use "
"``backslashreplace`` as it does in any other locale). This stream "
"handling behavior can be overridden using :envvar:`PYTHONIOENCODING` as "
"usual."
msgstr ""
"이러한 로케일 중 하나를 구성하면 (명시적으로나 위의 묵시적 로케일 강제 변경을 통해) :data:`sys.stdin` 과 "
":data:`sys.stdout` 에 대해 ``surrogateescape`` :ref:`에러 처리기 <error-"
"handlers>` 를 자동으로 활성화합니다 (:data:`sys.stderr` 는 다른 로케일에서처럼 "
"``backslashreplace`` 를 계속 사용합니다). 이 스트림 처리 동작은 평소처럼 "
":envvar:`PYTHONIOENCODING`\\을 사용하여 대체할 수 있습니다."

#: ../Doc/using/cmdline.rst:826
msgid ""
"For debugging purposes, setting ``PYTHONCOERCECLOCALE=warn`` will cause "
"Python to emit warning messages on ``stderr`` if either the locale "
"coercion activates, or else if a locale that *would* have triggered "
"coercion is still active when the Python runtime is initialized."
msgstr ""
"디버깅을 위해, ``PYTHONCOERCECLOCALE=warn`` 을 설정하면, 로케일 강제 변경이 일어나거나, 그렇지 않고 강제"
" 변경을 *유발할* 로케일이 파이썬 런타임이 초기화될 때 여전히 활성 상태면 파이썬은 ``stderr`` 로 경고 메시지를 "
"보냅니다."

#: ../Doc/using/cmdline.rst:831
msgid ""
"Also note that even when locale coercion is disabled, or when it fails to"
" find a suitable target locale, :envvar:`PYTHONUTF8` will still activate "
"by default in legacy ASCII-based locales. Both features must be disabled "
"in order to force the interpreter to use ``ASCII`` instead of ``UTF-8`` "
"for system interfaces."
msgstr ""
"또한, 로케일 강제 변환이 비활성화되거나 적절한 대상 로케일을 찾지 못할 때도, 레거시 ASCII 기반 로케일에서 "
":envvar:`PYTHONUTF8` 은 기본적으로 활성화됨에 유의하십시오. 인터프리터가 시스템 인터페이스에 대해 ``UTF-8``"
" 대신에 ``ASCII`` 를 사용하게 하려면, 두 가지 기능을 모두 비활성화시켜야 합니다."

#: ../Doc/using/cmdline.rst:838 ../Doc/using/cmdline.rst:899
msgid "Availability: *nix."
msgstr "가용성: 유닉스"

#: ../Doc/using/cmdline.rst:839
msgid "See :pep:`538` for more details."
msgstr "자세한 내용은 :pep:`538`\\을 참조하십시오."

#: ../Doc/using/cmdline.rst:845
msgid ""
"If this environment variable is set to a non-empty string, enable the "
"CPython \"development mode\". See the :option:`-X` ``dev`` option."
msgstr ""
"이 환경 변수가 비어 있지 않은 문자열로 설정되면, CPython \"개발 모드\"를 활성화합니다. :option:`-X` "
"``dev`` 옵션을 보십시오."

#: ../Doc/using/cmdline.rst:852
msgid ""
"If set to ``1``, enables the interpreter's UTF-8 mode, where ``UTF-8`` is"
" used as the text encoding for system interfaces, regardless of the "
"current locale setting."
msgstr ""
"``1`` 로 설정하면, 인터프리터의 UTF-8 모드가 활성화됩니다. 이 모드에서는 현재 로케일 설정에 상관없이, 시스템 "
"인터페이스의 텍스트 인코딩으로 ``UTF-8`` 이 사용됩니다."

#: ../Doc/using/cmdline.rst:856
msgid "This means that:"
msgstr "이는 다음을 의미합니다:"

#: ../Doc/using/cmdline.rst:858
msgid ""
":func:`sys.getfilesystemencoding()` returns ``'UTF-8'`` (the locale "
"encoding is ignored)."
msgstr ""
":func:`sys.getfilesystemencoding()` 은 ``'UTF-8'`` 을 반환합니다 (로케일 인코딩은 "
"무시됩니다)."

#: ../Doc/using/cmdline.rst:860
msgid ""
":func:`locale.getpreferredencoding()` returns ``'UTF-8'`` (the locale "
"encoding is ignored, and the function's ``do_setlocale`` parameter has no"
" effect)."
msgstr ""
":func:`locale.getpreferredencoding()` 은 ``'UTF-8'`` 을 반환합니다 (로케일 인코딩은 "
"무시되고, 함수의 ``do_setlocale`` 매개 변수는 아무런 효과가 없습니다)."

#: ../Doc/using/cmdline.rst:863
msgid ""
":data:`sys.stdin`, :data:`sys.stdout`, and :data:`sys.stderr` all use "
"UTF-8 as their text encoding, with the ``surrogateescape`` :ref:`error "
"handler <error-handlers>` being enabled for :data:`sys.stdin` and "
":data:`sys.stdout` (:data:`sys.stderr` continues to use "
"``backslashreplace`` as it does in the default locale-aware mode)"
msgstr ""
":data:`sys.stdin`, :data:`sys.stdout`, :data:`sys.stderr` 모두 텍스트 인코딩으로 "
"UTF-8을 사용하고, :data:`sys.stdin` 과 :data:`sys.stdout` 은 ``surrogateescape``"
" :ref:`에러 처리기 <error-handlers>` 가 활성화됩니다 (:data:`sys.stderr` 은 기본 로케일 인식 "
"모드와 같이 ``backslashreplace`` 를 계속 사용합니다)"

#: ../Doc/using/cmdline.rst:869
msgid ""
"As a consequence of the changes in those lower level APIs, other higher "
"level APIs also exhibit different default behaviours:"
msgstr "이러한 하위 수준 API의 변경으로 인해, 다른 상위 수준 API도 다른 기본 동작을 수행합니다:"

#: ../Doc/using/cmdline.rst:872
msgid ""
"Command line arguments, environment variables and filenames are decoded "
"to text using the UTF-8 encoding."
msgstr "명령 줄 인자, 환경 변수 및 파일명은 UTF-8 인코딩을 사용하여 텍스트로 디코딩됩니다."

#: ../Doc/using/cmdline.rst:874
msgid ":func:`os.fsdecode()` and :func:`os.fsencode()` use the UTF-8 encoding."
msgstr ":func:`os.fsdecode()`\\와 :func:`os.fsencode()` 는 UTF-8 인코딩을 사용합니다."

#: ../Doc/using/cmdline.rst:875
msgid ""
":func:`open()`, :func:`io.open()`, and :func:`codecs.open()` use the "
"UTF-8 encoding by default. However, they still use the strict error "
"handler by default so that attempting to open a binary file in text mode "
"is likely to raise an exception rather than producing nonsense data."
msgstr ""
":func:`open()`, :func:`io.open()`, :func:`codecs.open()` 은 기본적으로 UTF-8 "
"인코딩을 사용합니다. 그러나, 이들은 기본적으로 여전히 strict 에러 처리기를 사용하므로, 바이너리 파일을 텍스트 모드로 열려고"
" 하면 말도 안 되는 데이터가 생성되는 대신 예외가 발생합니다."

#: ../Doc/using/cmdline.rst:880
msgid ""
"Note that the standard stream settings in UTF-8 mode can be overridden by"
" :envvar:`PYTHONIOENCODING` (just as they can be in the default locale-"
"aware mode)."
msgstr ""
"UTF-8 모드에서 표준 스트림 설정은 :envvar:`PYTHONIOENCODING` 의해 대체될 수 있습니다 (기본 로케일 인식"
" 모드에서와 마찬가지로)."

#: ../Doc/using/cmdline.rst:884
msgid "If set to ``0``, the interpreter runs in its default locale-aware mode."
msgstr "``0`` 으로 설정하면, 인터프리터는 기본 로케일 인식 모드로 실행됩니다."

#: ../Doc/using/cmdline.rst:886
msgid ""
"Setting any other non-empty string causes an error during interpreter "
"initialisation."
msgstr "다른 모든 비어 있지 않은 문자열로 설정하면, 인터프리터를 초기화하는 동안 에러가 발생합니다."

#: ../Doc/using/cmdline.rst:889
msgid ""
"If this environment variable is not set at all, then the interpreter "
"defaults to using the current locale settings, *unless* the current "
"locale is identified as a legacy ASCII-based locale (as described for "
":envvar:`PYTHONCOERCECLOCALE`), and locale coercion is either disabled or"
" fails. In such legacy locales, the interpreter will default to enabling "
"UTF-8 mode unless explicitly instructed not to do so."
msgstr ""
"이 환경 변수가 전혀 설정되지 않으면, 인터프리터는 현재 로케일이 레거시 ASCII 기반 "
"로케일(:envvar:`PYTHONCOERCECLOCALE` 에서 설명하는 것처럼)로 식별되고, 로케일 강제 변경이 비활성화되거나 "
"실패하지 지 *않는 한*, 인터프리터는 현재 로케일 설정을 사용합니다. 이러한 레거시 로케일에서, 명시적으로 그렇게 하지 말라고 "
"지시하지 않는 한, 인터프리터는 기본적으로 UTF-8 모드를 활성화합니다."

#: ../Doc/using/cmdline.rst:896
msgid "Also available as the :option:`-X` ``utf8`` option."
msgstr ":option:`-X` ``utf8`` 옵션으로도 사용 가능합니다."

#: ../Doc/using/cmdline.rst:900
msgid "See :pep:`540` for more details."
msgstr "자세한 내용은 :pep:`540`\\을 참조하십시오."

#: ../Doc/using/cmdline.rst:905
msgid "Debug-mode variables"
msgstr "디버그 모드 변수"

#: ../Doc/using/cmdline.rst:907
msgid ""
"Setting these variables only has an effect in a debug build of Python, "
"that is, if Python was configured with the ``--with-pydebug`` build "
"option."
msgstr ""
"이 변수들을 설정하는 것은 파이썬의 디버그 빌드에서만 효과가 있습니다. 즉, 파이썬이 ``--with-pydebug`` 빌드 "
"옵션으로 구성되었어야 합니다."

#: ../Doc/using/cmdline.rst:912
msgid "If set, Python will print threading debug info."
msgstr "설정되면, 파이썬은 스레딩 디버그 정보를 인쇄합니다."

#: ../Doc/using/cmdline.rst:917
msgid ""
"If set, Python will dump objects and reference counts still alive after "
"shutting down the interpreter."
msgstr "설정되면, 파이썬은 인터프리터를 종료한 후에도 살아있는 객체와 참조 카운트를 덤프합니다."

