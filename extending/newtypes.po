# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-12-19 18:31+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.7.0\n"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:7
msgid "Defining Extension Types: Assorted Topics"
msgstr "확장형 정의하기: 여러 가지 주제"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:11
msgid ""
"This section aims to give a quick fly-by on the various type methods you "
"can implement and what they do."
msgstr "이 섹션은 구현할 수 있는 다양한 형 메서드와 그것이 하는 일에 대해 훑어보기를 제공하기 위한 것입니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:14
msgid ""
"Here is the definition of :c:type:`PyTypeObject`, with some fields only "
"used in debug builds omitted:"
msgstr "다음은 디버그 빌드에서만 사용되는 일부 필드가 생략된 :c:type:`PyTypeObject`\\의 정의입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:20
msgid ""
"Now that's a *lot* of methods.  Don't worry too much though -- if you "
"have a type you want to define, the chances are very good that you will "
"only implement a handful of these."
msgstr "이제 메서드가 아주 *많습니다*. 너무 걱정하지 마십시오 -- 정의하려는 형이 있으면, 이 중 일부만 구현할 가능성이 매우 높습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:24
msgid ""
"As you probably expect by now, we're going to go over this and give more "
"information about the various handlers.  We won't go in the order they "
"are defined in the structure, because there is a lot of historical "
"baggage that impacts the ordering of the fields.  It's often easiest to "
"find an example that includes the fields you need and then change the "
"values to suit your new type. ::"
msgstr ""
"아마 지금까지 예상했듯이, 이것에 대해 살펴보고 다양한 처리기에 대한 자세한 정보를 제공할 것입니다. 필드의 순서에 영향을 미치는 "
"많은 과거의 짐이 있어서, 구조체에 정의된 순서대로 진행하지 않을 것입니다. 필요한 필드가 포함된 예제를 찾은 다음 새 형에 맞게 "
"값을 변경하기가 종종 가장 쉽습니다. ::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:33
msgid ""
"The name of the type -- as mentioned in the previous chapter, this will "
"appear in various places, almost entirely for diagnostic purposes. Try to"
" choose something that will be helpful in such a situation! ::"
msgstr ""
"형의 이름 -- 이전 장에서 언급했듯이, 이것은 여러 곳에서 나타나는데, 거의 진단 목적입니다. 그러한 상황에서 도움이 될만한 것을"
" 선택하십시오! ::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:39
msgid ""
"These fields tell the runtime how much memory to allocate when new "
"objects of this type are created.  Python has some built-in support for "
"variable length structures (think: strings, tuples) which is where the "
":c:member:`~PyTypeObject.tp_itemsize` field comes in.  This will be dealt"
" with later. ::"
msgstr ""
"이 필드는 이 형의 새 객체가 만들어질 때 할당할 메모리양을 런타임에 알려줍니다. 파이썬은 가변 길이 구조(생각하세요: 문자열, "
"튜플)에 대한 지원을 내장하고 있는데, 이때 :c:member:`~PyTypeObject.tp_itemsize` 필드가 참여합니다."
" 이것은 나중에 다룰 것입니다. ::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:46
msgid ""
"Here you can put a string (or its address) that you want returned when "
"the Python script references ``obj.__doc__`` to retrieve the doc string."
msgstr ""
"여기에 파이썬 스크립트가 ``obj.__doc__``\\을 참조하여 독스트링을 꺼낼 때 반환할 문자열(또는 문자열의 주소)을 넣을 "
"수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:49
msgid ""
"Now we come to the basic type methods -- the ones most extension types "
"will implement."
msgstr "이제 기본 형 메서드에 대해 살펴보겠습니다 -- 대부분의 확장형이 구현할 것들입니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:54
msgid "Finalization and De-allocation"
msgstr "파이널리제이션과 할당 해제"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:66
msgid ""
"This function is called when the reference count of the instance of your "
"type is reduced to zero and the Python interpreter wants to reclaim it.  "
"If your type has memory to free or other clean-up to perform, you can put"
" it here.  The object itself needs to be freed here as well.  Here is an "
"example of this function::"
msgstr ""
"이 함수는 형의 인스턴스의 참조 횟수가 0으로 줄어들고 파이썬 인터프리터가 그것을 재활용하고자 할 때 호출됩니다. 여러분의 형에 "
"해제할 메모리가 있거나 수행할 기타 정리 작업이 있으면, 여기에 넣을 수 있습니다. 객체 자체도 여기서 해제해야 합니다. 이 함수의"
" 예는 다음과 같습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:83
msgid ""
"One important requirement of the deallocator function is that it leaves "
"any pending exceptions alone.  This is important since deallocators are "
"frequently called as the interpreter unwinds the Python stack; when the "
"stack is unwound due to an exception (rather than normal returns), "
"nothing is done to protect the deallocators from seeing that an exception"
" has already been set.  Any actions which a deallocator performs which "
"may cause additional Python code to be executed may detect that an "
"exception has been set.  This can lead to misleading errors from the "
"interpreter.  The proper way to protect against this is to save a pending"
" exception before performing the unsafe action, and restoring it when "
"done.  This can be done using the :c:func:`PyErr_Fetch` and "
":c:func:`PyErr_Restore` functions::"
msgstr ""
"할당 해제 함수의 중요한 요구 사항 중 하나는 계류 중인 예외를 그대로 남겨 두어야 한다는 것입니다. 인터프리터가 파이썬 스택을 "
"되감을 때 할당 해제기가 자주 호출되기 때문에 중요합니다; 스택이 (정상적인 반환이 아닌) 예외로 인해 되감길 때, 할당 해제기가 "
"예외가 이미 설정되어 있음을 알 수 없도록 하는 것은 아무것도 수행되지 않습니다. 할당 해제기가 수행하는 추가 파이썬 코드가 실행될"
" 수 있도록 하는 추가 조치는 예외가 설정되었음을 감지할 수 있습니다. 이는 인터프리터가 혼동하도록 할 수 있습니다. 이를 방지하는"
" 올바른 방법은 안전하지 않은 조치를 수행하기 전에 계류 중인 예외를 저장하고 완료되면 복원하는 것입니다. "
":c:func:`PyErr_Fetch`\\와 :c:func:`PyErr_Restore` 함수를 사용하여 수행할 수 있습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:122
msgid ""
"There are limitations to what you can safely do in a deallocator "
"function. First, if your type supports garbage collection (using "
":c:member:`~PyTypeObject.tp_traverse` and/or "
":c:member:`~PyTypeObject.tp_clear`), some of the object's members can "
"have been cleared or finalized by the time "
":c:member:`~PyTypeObject.tp_dealloc` is called.  Second, in "
":c:member:`~PyTypeObject.tp_dealloc`, your object is in an unstable "
"state: its reference count is equal to zero.  Any call to a non-trivial "
"object or API (as in the example above) might end up calling "
":c:member:`~PyTypeObject.tp_dealloc` again, causing a double free and a "
"crash."
msgstr ""
"할당 해제 함수에서 안전하게 수행할 수 있는 작업에는 제한이 있습니다. 먼저, 형이 가비지 수거를 지원하면 "
"(:c:member:`~PyTypeObject.tp_traverse` 및/또는 "
":c:member:`~PyTypeObject.tp_clear`\\를 사용해서), "
":c:member:`~PyTypeObject.tp_dealloc`\\이 호출될 때 객체의 일부 멤버가 지워지거나 파이널라이즈 될 수"
" 있습니다. 둘째, :c:member:`~PyTypeObject.tp_dealloc`\\에서, 객체는 불안정한 상태에 있습니다: "
"참조 횟수가 0입니다. (위의 예에서와같이) 사소하지 않은 객체나 API를 호출하면 "
":c:member:`~PyTypeObject.tp_dealloc`\\을 다시 호출하게 되어, 이중 해제와 충돌이 발생할 수 "
"있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:131
msgid ""
"Starting with Python 3.4, it is recommended not to put any complex "
"finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead "
"use the new :c:member:`~PyTypeObject.tp_finalize` type method."
msgstr ""
"파이썬 3.4부터는, :c:member:`~PyTypeObject.tp_dealloc`\\에 복잡한 파이널리제이션 코드를 넣지 "
"말고, 대신 새로운 :c:member:`~PyTypeObject.tp_finalize` 형 메서드를 사용하는 것이 좋습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:136
msgid ":pep:`442` explains the new finalization scheme."
msgstr ":pep:`442`\\는 새로운 파이널리제이션 체계를 설명합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:143
msgid "Object Presentation"
msgstr "객체 표현"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:145
msgid ""
"In Python, there are two ways to generate a textual representation of an "
"object: the :func:`repr` function, and the :func:`str` function.  (The "
":func:`print` function just calls :func:`str`.)  These handlers are both "
"optional."
msgstr ""
"파이썬에서, 객체의 텍스트 표현을 생성하는 두 가지 방법이 있습니다: :func:`repr` 함수와 :func:`str` 함수. "
"(:func:`print` 함수는 단지 :func:`str`\\을 호출합니다.) 이 처리기들은 모두 선택적입니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:154
msgid ""
"The :c:member:`~PyTypeObject.tp_repr` handler should return a string "
"object containing a representation of the instance for which it is "
"called.  Here is a simple example::"
msgstr ""
":c:member:`~PyTypeObject.tp_repr` 처리기는 호출된 인스턴스의 표현을 포함하는 문자열 객체를 반환해야 "
"합니다. 다음은 간단한 예입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:165
msgid ""
"If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the "
"interpreter will supply a representation that uses the type's "
":c:member:`~PyTypeObject.tp_name` and a uniquely-identifying value for "
"the object."
msgstr ""
":c:member:`~PyTypeObject.tp_repr` 처리기가 지정되지 않으면, 인터프리터는 형의 "
":c:member:`~PyTypeObject.tp_name`\\과 객체의 고유 식별 값을 사용하는 표현을 제공합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:169
msgid ""
"The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the "
":c:member:`~PyTypeObject.tp_repr` handler described above is to "
":func:`repr`; that is, it is called when Python code calls :func:`str` on"
" an instance of your object.  Its implementation is very similar to the "
":c:member:`~PyTypeObject.tp_repr` function, but the resulting string is "
"intended for human consumption.  If :c:member:`~PyTypeObject.tp_str` is "
"not specified, the :c:member:`~PyTypeObject.tp_repr` handler is used "
"instead."
msgstr ""
":c:member:`~PyTypeObject.tp_str` 처리기는 :func:`str`\\에 대한 것이고, 위에서 설명한 "
":c:member:`~PyTypeObject.tp_repr` 처리기와 :func:`repr` 간의 관계와 같은 관계입니다; 즉, "
"파이썬 코드가 객체의 인스턴스에서 :func:`str`\\을 호출할 때 호출됩니다. 구현은 "
":c:member:`~PyTypeObject.tp_repr` 함수와 매우 유사하지만, 결과 문자열은 사람이 사용하기 위한 것입니다."
" :c:member:`~PyTypeObject.tp_str`\\을 지정하지 않으면, "
":c:member:`~PyTypeObject.tp_repr` 처리기가 대신 사용됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:176
msgid "Here is a simple example::"
msgstr "다음은 간단한 예입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:188
msgid "Attribute Management"
msgstr "어트리뷰트 관리"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:190
msgid ""
"For every object which can support attributes, the corresponding type "
"must provide the functions that control how the attributes are resolved."
"  There needs to be a function which can retrieve attributes (if any are "
"defined), and another to set attributes (if setting attributes is "
"allowed).  Removing an attribute is a special case, for which the new "
"value passed to the handler is ``NULL``."
msgstr ""
"어트리뷰트를 지원할 수 있는 모든 객체에 대해, 해당 형은 어트리뷰트가 결정되는(resolved) 방법을 제어하는 함수를 제공해야 "
"합니다. 어트리뷰트를 꺼낼 수 있는 함수와 (뭔가 정의되어 있다면), 어트리뷰트를 설정하는 다른 함수(어트리뷰트 설정이 "
"허용된다면)가 있어야 합니다. 어트리뷰트 제거는 특별한 경우이며, 처리기에 전달된 새 값이 ``NULL``\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:196
msgid ""
"Python supports two pairs of attribute handlers; a type that supports "
"attributes only needs to implement the functions for one pair.  The "
"difference is that one pair takes the name of the attribute as a "
":c:type:`char\\*`, while the other accepts a :c:type:`PyObject\\*`.  Each"
" type can use whichever pair makes more sense for the implementation's "
"convenience. ::"
msgstr ""
"파이썬은 두 쌍의 어트리뷰트 처리기를 지원합니다; 어트리뷰트를 지원하는 형은 한 쌍의 함수만 구현하면 됩니다. 차이점은 한 쌍은 "
"어트리뷰트 이름을 :c:type:`char\\*`\\로 취하고, 다른 쌍은 :c:type:`PyObject\\*`\\를 받아들인다는"
" 것입니다. 각 형은 구현의 편의에 더 적합한 쌍을 사용할 수 있습니다. ::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:208
msgid ""
"If accessing attributes of an object is always a simple operation (this "
"will be explained shortly), there are generic implementations which can "
"be used to provide the :c:type:`PyObject\\*` version of the attribute "
"management functions. The actual need for type-specific attribute "
"handlers almost completely disappeared starting with Python 2.2, though "
"there are many examples which have not been updated to use some of the "
"new generic mechanism that is available."
msgstr ""
"객체의 어트리뷰트에 액세스하는 것이 항상 간단한 연산이면 (짧게 설명할 것입니다), 어트리뷰트 관리 함수의 "
":c:type:`PyObject\\*` 버전을 제공하는 데 사용할 수 있는 일반적인 구현이 있습니다. 파이썬 2.2부터 형별 "
"어트리뷰트 처리기에 대한 실제 필요성은 거의 완전히 사라졌지만, 사용 가능한 새로운 일반 메커니즘을 사용하도록 갱신되지 않은 예제가"
" 많이 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:219
msgid "Generic Attribute Management"
msgstr "범용 어트리뷰트 관리"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:221
msgid ""
"Most extension types only use *simple* attributes.  So, what makes the "
"attributes simple?  There are only a couple of conditions that must be "
"met:"
msgstr ""
"대부분의 확장형은 *간단한* 어트리뷰트만 사용합니다. 그렇다면, 어트리뷰트를 간단하게 만드는 것은 무엇입니까? 충족해야 하는 몇 "
"가지 조건만 있습니다:"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:224
msgid ""
"The name of the attributes must be known when :c:func:`PyType_Ready` is "
"called."
msgstr ":c:func:`PyType_Ready`\\가 호출될 때 어트리뷰트의 이름을 알아야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:227
msgid ""
"No special processing is needed to record that an attribute was looked up"
" or set, nor do actions need to be taken based on the value."
msgstr "어트리뷰트를 찾거나 설정했음을 기록하는 데 특별한 처리가 필요하지 않으며 값을 기반으로 조처를 하지 않아도 됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:230
msgid ""
"Note that this list does not place any restrictions on the values of the "
"attributes, when the values are computed, or how relevant data is stored."
msgstr "이 목록은 어트리뷰트 값, 값을 계산하는 시점 또는 관련 데이터가 저장되는 방법에 제한을 두지 않음에 유의하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:233
msgid ""
"When :c:func:`PyType_Ready` is called, it uses three tables referenced by"
" the type object to create :term:`descriptor`\\s which are placed in the "
"dictionary of the type object.  Each descriptor controls access to one "
"attribute of the instance object.  Each of the tables is optional; if all"
" three are ``NULL``, instances of the type will only have attributes that"
" are inherited from their base type, and should leave the "
":c:member:`~PyTypeObject.tp_getattro` and "
":c:member:`~PyTypeObject.tp_setattro` fields ``NULL`` as well, allowing "
"the base type to handle attributes."
msgstr ""
":c:func:`PyType_Ready`\\가 호출될 때, 형 객체가 참조하는 3개의 테이블을 사용하여 형 객체의 딕셔너리에 "
"배치되는 :term:`디스크립터 <descriptor>`\\를 만듭니다. 각 디스크립터는 인스턴스 객체의 한 어트리뷰트에 대한 "
"액세스를 제어합니다. 각 테이블은 선택적입니다; 세 개 모두가 ``NULL``\\이면, 형의 인스턴스는 베이스형에서 상속된 "
"어트리뷰트만 갖게 되며, :c:member:`~PyTypeObject.tp_getattro`\\와 "
":c:member:`~PyTypeObject.tp_setattro` 필드도 ``NULL``\\로 남겨두어야 베이스형이 어트리뷰트를 "
"처리할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:241
msgid "The tables are declared as three fields of the type object::"
msgstr "테이블은 형 객체의 세 필드로 선언됩니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:247
msgid ""
"If :c:member:`~PyTypeObject.tp_methods` is not ``NULL``, it must refer to"
" an array of :c:type:`PyMethodDef` structures.  Each entry in the table "
"is an instance of this structure::"
msgstr ""
":c:member:`~PyTypeObject.tp_methods`\\가 ``NULL``\\이 아니면, "
":c:type:`PyMethodDef` 구조체의 배열을 참조해야 합니다. 테이블의 각 항목은 다음 구조체의 인스턴스입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:258
msgid ""
"One entry should be defined for each method provided by the type; no "
"entries are needed for methods inherited from a base type.  One "
"additional entry is needed at the end; it is a sentinel that marks the "
"end of the array.  The :attr:`ml_name` field of the sentinel must be "
"``NULL``."
msgstr ""
"형에서 제공되는 각 메서드에 대해 하나의 항목을 정의해야 합니다; 베이스형에서 상속된 메서드에는 항목이 필요하지 않습니다. 마지막에"
" 하나의 추가 항목이 필요합니다; 배열의 끝을 나타내는 센티넬(sentinel)입니다. 센티넬의 :attr:`ml_name` 필드는"
" ``NULL``\\이어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:263
msgid ""
"The second table is used to define attributes which map directly to data "
"stored in the instance.  A variety of primitive C types are supported, "
"and access may be read-only or read-write.  The structures in the table "
"are defined as::"
msgstr ""
"두 번째 테이블은 인스턴스에 저장된 데이터에 직접 매핑되는 어트리뷰트를 정의하는 데 사용됩니다. 다양한 기본 C형이 지원되며, "
"액세스는 읽기 전용이거나 읽고 쓰기일 수 있습니다. 테이블의 구조체는 다음과 같이 정의됩니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:275
msgid ""
"For each entry in the table, a :term:`descriptor` will be constructed and"
" added to the type which will be able to extract a value from the "
"instance structure.  The :attr:`type` field should contain one of the "
"type codes defined in the :file:`structmember.h` header; the value will "
"be used to determine how to convert Python values to and from C values.  "
"The :attr:`flags` field is used to store flags which control how the "
"attribute can be accessed."
msgstr ""
"테이블의 각 항목에 대해, :term:`디스크립터 <descriptor>`\\가 구성되고 형에 추가되어 인스턴스 구조체에서 값을 "
"추출할 수 있게 됩니다. :attr:`type` 필드는 :file:`structmember.h` 헤더에 정의된 형 코드 중 하나를 "
"포함해야 합니다; 이 값은 파이썬 값과 C값 간에 변환하는 방법을 결정하는 데 사용됩니다. :attr:`flags` 필드는 "
"어트리뷰트에 액세스하는 방법을 제어하는 플래그를 저장하는 데 사용됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:282
msgid ""
"The following flag constants are defined in :file:`structmember.h`; they "
"may be combined using bitwise-OR."
msgstr "다음 플래그 상수는 :file:`structmember.h`\\에 정의되어 있습니다; 비트별 OR를 사용하여 결합할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:286
msgid "Constant"
msgstr "상수"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:286
msgid "Meaning"
msgstr "의미"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:288
msgid ":const:`READONLY`"
msgstr ":const:`READONLY`"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:288
msgid "Never writable."
msgstr "쓸 수 없습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:290
msgid ":const:`READ_RESTRICTED`"
msgstr ":const:`READ_RESTRICTED`"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:290
msgid "Not readable in restricted mode."
msgstr "제한된 모드에서는 읽을 수 없습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:292
msgid ":const:`WRITE_RESTRICTED`"
msgstr ":const:`WRITE_RESTRICTED`"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:292
msgid "Not writable in restricted mode."
msgstr "제한된 모드에서는 쓸 수 없습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:294
msgid ":const:`RESTRICTED`"
msgstr ":const:`RESTRICTED`"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:294
msgid "Not readable or writable in restricted mode."
msgstr "제한된 모드에서는 읽거나 쓸 수 없습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:303
msgid ""
"An interesting advantage of using the "
":c:member:`~PyTypeObject.tp_members` table to build descriptors that are "
"used at runtime is that any attribute defined this way can have an "
"associated doc string simply by providing the text in the table.  An "
"application can use the introspection API to retrieve the descriptor from"
" the class object, and get the doc string using its :attr:`__doc__` "
"attribute."
msgstr ""
":c:member:`~PyTypeObject.tp_members` 테이블을 사용하여 실행 시간에 사용되는 디스크립터를 구축하는 것의"
" 흥미로운 이점은 이 방법으로 정의된 모든 어트리뷰트가 단순히 테이블에 텍스트를 제공하는 것으로 연관된 독스트링을 가질 수 있다는 "
"것입니다. 응용 프로그램은 내부 검사(introspection) API를 사용하여 클래스 객체에서 디스크립터를 꺼내고, 그것의 "
":attr:`__doc__` 어트리뷰트를 사용하여 독스트링을 얻을 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:309
msgid ""
"As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry "
"with a :attr:`name` value of ``NULL`` is required."
msgstr ""
":c:member:`~PyTypeObject.tp_methods` 테이블과 마찬가지로, :attr:`name` 값이 "
"``NULL``\\인 센티넬 항목이 필요합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:323
msgid "Type-specific Attribute Management"
msgstr "형별 어트리뷰트 관리"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:325
msgid ""
"For simplicity, only the :c:type:`char\\*` version will be demonstrated "
"here; the type of the name parameter is the only difference between the "
":c:type:`char\\*` and :c:type:`PyObject\\*` flavors of the interface. "
"This example effectively does the same thing as the generic example "
"above, but does not use the generic support added in Python 2.2.  It "
"explains how the handler functions are called, so that if you do need to "
"extend their functionality, you'll understand what needs to be done."
msgstr ""
"간단히 하기 위해, :c:type:`char\\*` 버전 만 여기에서 예시합니다; name 매개 변수의 형이 인터페이스의 "
":c:type:`char\\*`\\와 :c:type:`PyObject\\*` 버전 간의 유일한 차이점입니다. 이 예제는 위의 범용 "
"예제와 효과적으로 같은 것을 수행하지만, 파이썬 2.2에 추가된 범용 지원은 사용하지 않습니다. 처리기 함수가 호출되는 방식을 "
"설명하므로, 기능을 확장해야 한다면, 무엇을 해야 할지 이해할 수 있을 겁니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:333
msgid ""
"The :c:member:`~PyTypeObject.tp_getattr` handler is called when the "
"object requires an attribute look-up.  It is called in the same "
"situations where the :meth:`__getattr__` method of a class would be "
"called."
msgstr ""
":c:member:`~PyTypeObject.tp_getattr` 처리기는 객체에 어트리뷰트 조회가 필요할 때 호출됩니다. 클래스의"
" :meth:`__getattr__` 메서드가 호출되는 것과 같은 상황에서 호출됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:337
msgid "Here is an example::"
msgstr "예는 다음과 같습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:353
msgid ""
"The :c:member:`~PyTypeObject.tp_setattr` handler is called when the "
":meth:`__setattr__` or :meth:`__delattr__` method of a class instance "
"would be called.  When an attribute should be deleted, the third "
"parameter will be ``NULL``.  Here is an example that simply raises an "
"exception; if this were really all you wanted, the "
":c:member:`~PyTypeObject.tp_setattr` handler should be set to ``NULL``. "
"::"
msgstr ""
":c:member:`~PyTypeObject.tp_setattr` 처리기는 클래스 인스턴스의 "
":meth:`__setattr__`\\이나 :meth:`__delattr__` 메서드가 호출될 때 호출됩니다. 어트리뷰트를 삭제해야"
" 하면, 세 번째 매개 변수는 ``NULL``\\이 됩니다. 다음은 단순히 예외를 발생시키는 예입니다; 이것이 정말로 여러분이 "
"원하는 전부라면, :c:member:`~PyTypeObject.tp_setattr` 처리기는 ``NULL``\\로 설정되어야 "
"합니다. ::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:367
msgid "Object Comparison"
msgstr "객체 비교"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:373
msgid ""
"The :c:member:`~PyTypeObject.tp_richcompare` handler is called when "
"comparisons are needed.  It is analogous to the :ref:`rich comparison "
"methods <richcmpfuncs>`, like :meth:`__lt__`, and also called by "
":c:func:`PyObject_RichCompare` and :c:func:`PyObject_RichCompareBool`."
msgstr ""
":c:member:`~PyTypeObject.tp_richcompare` 처리기는 비교가 필요할 때 호출됩니다. "
":meth:`__lt__`\\와 같은 :ref:`풍부한 비교 메서드 <richcmpfuncs>`\\에 해당하며, "
":c:func:`PyObject_RichCompare`\\와 :c:func:`PyObject_RichCompareBool`\\에 "
"의해서도 호출됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:378
msgid ""
"This function is called with two Python objects and the operator as "
"arguments, where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, "
"``Py_GT``, ``Py_LT`` or ``Py_GT``.  It should compare the two objects "
"with respect to the specified operator and return ``Py_True`` or "
"``Py_False`` if the comparison is successful, ``Py_NotImplemented`` to "
"indicate that comparison is not implemented and the other object's "
"comparison method should be tried, or ``NULL`` if an exception was set."
msgstr ""
"이 함수는 두 개의 파이썬 객체와 연산자를 인자로 사용하여 호출됩니다, 여기서 연산자는 ``Py_EQ``, ``Py_NE``, "
"``Py_LE``, ``Py_GT``, ``Py_LT`` 또는 ``Py_GT`` 중 하나입니다. 지정된 연산자로 두 객체를 비교하고"
" 비교에 성공하면 ``Py_True``\\나 ``Py_False``\\를, 비교가 구현되지 않았으며 다른 객체의 비교 메서드를 "
"시도해야 한다는 것을 나타내려면 ``Py_NotImplemented``\\를, 예외가 설정되면 ``NULL``\\을 반환해야 "
"합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:386
msgid ""
"Here is a sample implementation, for a datatype that is considered equal "
"if the size of an internal pointer is equal::"
msgstr "내부 포인터의 크기가 같으면 같다고 간주하는 데이터형에 대한 샘플 구현은 다음과 같습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:416
msgid "Abstract Protocol Support"
msgstr "추상 프로토콜 지원"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:418
msgid ""
"Python supports a variety of *abstract* 'protocols;' the specific "
"interfaces provided to use these interfaces are documented in "
":ref:`abstract`."
msgstr ""
"파이썬은 다양한 *추상* '프로토콜'을 지원합니다; 이러한 인터페이스를 사용하기 위해 제공되는 구체적인 인터페이스는 "
":ref:`abstract`\\에 설명되어 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:422
msgid ""
"A number of these abstract interfaces were defined early in the "
"development of the Python implementation.  In particular, the number, "
"mapping, and sequence protocols have been part of Python since the "
"beginning.  Other protocols have been added over time.  For protocols "
"which depend on several handler routines from the type implementation, "
"the older protocols have been defined as optional blocks of handlers "
"referenced by the type object.  For newer protocols there are additional "
"slots in the main type object, with a flag bit being set to indicate that"
" the slots are present and should be checked by the interpreter.  (The "
"flag bit does not indicate that the slot values are non-``NULL``. The "
"flag may be set to indicate the presence of a slot, but a slot may still "
"be unfilled.) ::"
msgstr ""
"이러한 추상 인터페이스 중 다수는 파이썬 구현 개발 초기에 정의되었습니다. 특히, 숫자, 매핑 및 시퀀스 프로토콜은 처음부터 "
"파이썬의 일부였습니다. 다른 프로토콜은 시간이 지남에 따라 추가되었습니다. 형 구현의 여러 처리기 루틴에 의존하는 프로토콜의 경우,"
" 이전 프로토콜은 형 객체가 참조하는 선택적 처리기 블록으로 정의되었습니다. 최신 프로토콜의 경우 메인 형 객체에 추가 슬롯이 "
"있으며, 슬롯이 존재하고 인터프리터가 확인해야 함을 나타내는 플래그 비트가 설정됩니다. (플래그 비트는 슬롯 값이 "
"``NULL``\\이 아님을 나타내지 않습니다. 플래그는 슬롯의 존재를 나타내도록 설정될 수 있지만, 슬롯은 여전히 채워지지 않을 "
"수 있습니다.) ::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:437
msgid ""
"If you wish your object to be able to act like a number, a sequence, or a"
" mapping object, then you place the address of a structure that "
"implements the C type :c:type:`PyNumberMethods`, "
":c:type:`PySequenceMethods`, or :c:type:`PyMappingMethods`, respectively."
" It is up to you to fill in this structure with appropriate values. You "
"can find examples of the use of each of these in the :file:`Objects` "
"directory of the Python source distribution. ::"
msgstr ""
"여러분의 객체가 숫자, 시퀀스 또는 매핑 객체처럼 작동하도록 하려면, C형 :c:type:`PyNumberMethods`, "
":c:type:`PySequenceMethods` 또는 :c:type:`PyMappingMethods`\\를 각각 구현하는 구조체의"
" 주소를 배치합니다. 이 구조체를 적절한 값으로 채우는 것은 여러분의 책임입니다. 파이썬 소스 배포의 :file:`Objects` "
"디렉터리에서 이들 각각의 사용 예를 찾을 수 있습니다. ::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:446
msgid ""
"This function, if you choose to provide it, should return a hash number "
"for an instance of your data type. Here is a simple example::"
msgstr "여러분이 제공하기로 선택했다면, 이 함수는 데이터형의 인스턴스에 대한 해시 숫자를 반환해야 합니다. 다음은 간단한 예입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:459
msgid ""
":c:type:`Py_hash_t` is a signed integer type with a platform-varying "
"width. Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates "
"an error, which is why you should be careful to avoid returning it when "
"hash computation is successful, as seen above."
msgstr ""
":c:type:`Py_hash_t`\\는 플랫폼에 따라 변하는 너비의 부호 있는 정수 형입니다. "
":c:member:`~PyTypeObject.tp_hash`\\에서 ``-1``\\을 반환하면 에러를 표시해서, 위와 같이 해시 "
"계산에 성공했을 때 반환하지 않도록 주의해야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:468
msgid ""
"This function is called when an instance of your data type is \"called\","
" for example, if ``obj1`` is an instance of your data type and the Python"
" script contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call`"
" handler is invoked."
msgstr ""
"이 함수는 데이터형의 인스턴스가 \"호출\"될 때 호출됩니다, 예를 들어, ``obj1``\\이 데이터형의 인스턴스이고 파이썬 "
"스크립트에 ``obj1('hello')``\\가 포함되어 있으면 :c:member:`~PyTypeObject.tp_call` "
"처리기가 호출됩니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:472
msgid "This function takes three arguments:"
msgstr "이 함수는 세 개의 인자를 취합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:474
msgid ""
"*self* is the instance of the data type which is the subject of the call."
" If the call is ``obj1('hello')``, then *self* is ``obj1``."
msgstr ""
"*self*\\는 호출의 대상인 데이터형의 인스턴스입니다. 호출이 ``obj1('hello')``\\이면, *self*\\는 "
"``obj1``\\입니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:477
msgid ""
"*args* is a tuple containing the arguments to the call.  You can use "
":c:func:`PyArg_ParseTuple` to extract the arguments."
msgstr ""
"*args*\\는 호출에 대한 인자를 포함하는 튜플입니다. :c:func:`PyArg_ParseTuple`\\을 사용하여 인자를 "
"추출할 수 있습니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:480
msgid ""
"*kwds* is a dictionary of keyword arguments that were passed. If this is "
"non-``NULL`` and you support keyword arguments, use "
":c:func:`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you "
"do not want to support keyword arguments and this is non-``NULL``, raise "
"a :exc:`TypeError` with a message saying that keyword arguments are not "
"supported."
msgstr ""
"*kwds*\\는 전달된 키워드 인자의 딕셔너리입니다. 이것이 ``NULL``\\이 아니고 키워드 인자를 지원하면 "
":c:func:`PyArg_ParseTupleAndKeywords`\\를 사용하여 인자를 추출하십시오. 키워드 인자를 지원하지 않고"
" 이것이 ``NULL``\\이 아니면, 키워드 인자가 지원되지 않는다는 메시지와 함께 :exc:`TypeError`\\를 "
"발생시키십시오."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:486
msgid "Here is a toy ``tp_call`` implementation::"
msgstr "장난감 ``tp_call`` 구현은 다음과 같습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:512
msgid ""
"These functions provide support for the iterator protocol.  Both handlers"
" take exactly one parameter, the instance for which they are being "
"called, and return a new reference.  In the case of an error, they should"
" set an exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter`"
" corresponds to the Python :meth:`__iter__` method, while "
":c:member:`~PyTypeObject.tp_iternext` corresponds to the Python "
":meth:`~iterator.__next__` method."
msgstr ""
"이 함수는 이터레이터 프로토콜 지원을 제공합니다. 두 처리기 모두 정확히 하나의 매개 변수, 호출되는 인스턴스를 취하고 새 참조를 "
"반환합니다. 에러가 발생하면, 예외를 설정하고 ``NULL``\\을 반환해야 합니다. "
":c:member:`~PyTypeObject.tp_iter`\\는 파이썬 :meth:`__iter__` 메서드에 해당하고, "
":c:member:`~PyTypeObject.tp_iternext`\\는 파이썬 :meth:`~iterator.__next__` "
"메서드에 해당합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:519
msgid ""
"Any :term:`iterable` object must implement the "
":c:member:`~PyTypeObject.tp_iter` handler, which must return an "
":term:`iterator` object.  Here the same guidelines apply as for Python "
"classes:"
msgstr ""
"모든 :term:`이터러블 <iterable>` 객체는 :term:`이터레이터 <iterator>` 객체를 반환해야 하는 "
":c:member:`~PyTypeObject.tp_iter` 처리기를 구현해야 합니다. 다음은 파이썬 클래스에도 적용되는 공통 "
"지침입니다:"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:523
msgid ""
"For collections (such as lists and tuples) which can support multiple "
"independent iterators, a new iterator should be created and returned by "
"each call to :c:member:`~PyTypeObject.tp_iter`."
msgstr ""
"여러 개의 독립 이터레이터를 지원할 수 있는 컬렉션(가령 리스트와 튜플)의 경우, "
":c:member:`~PyTypeObject.tp_iter`\\를 호출할 때마다 새 이터레이터가 만들어지고 반환되어야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:526
msgid ""
"Objects which can only be iterated over once (usually due to side effects"
" of iteration, such as file objects) can implement "
":c:member:`~PyTypeObject.tp_iter` by returning a new reference to "
"themselves -- and should also therefore implement the "
":c:member:`~PyTypeObject.tp_iternext`  handler."
msgstr ""
"한 번만 이터레이트 될 수 있는 (보통 파일 객체처럼 이터레이션의 부작용으로 인해) 객체는 스스로에 대한 새로운 참조를 반환하여 "
":c:member:`~PyTypeObject.tp_iter`\\를 구현할 수 있습니다 -- 따라서 "
":c:member:`~PyTypeObject.tp_iternext` 처리기도 구현해야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:531
msgid ""
"Any :term:`iterator` object should implement both "
":c:member:`~PyTypeObject.tp_iter` and "
":c:member:`~PyTypeObject.tp_iternext`.  An iterator's "
":c:member:`~PyTypeObject.tp_iter` handler should return a new reference "
"to the iterator.  Its :c:member:`~PyTypeObject.tp_iternext` handler "
"should return a new reference to the next object in the iteration, if "
"there is one. If the iteration has reached the end, "
":c:member:`~PyTypeObject.tp_iternext` may return ``NULL`` without setting"
" an exception, or it may set :exc:`StopIteration` *in addition* to "
"returning ``NULL``; avoiding the exception can yield slightly better "
"performance.  If an actual error occurs, "
":c:member:`~PyTypeObject.tp_iternext` should always set an exception and "
"return ``NULL``."
msgstr ""
"모든 :term:`이터레이터 <iterator>` 객체는 :c:member:`~PyTypeObject.tp_iter`\\와 "
":c:member:`~PyTypeObject.tp_iternext`\\를 모두 구현해야 합니다. 이터레이터의 "
":c:member:`~PyTypeObject.tp_iter` 처리기는 이터레이터에 대한 새로운 참조를 반환해야 합니다. "
":c:member:`~PyTypeObject.tp_iternext` 처리기는 이터레이션의 다음 객체(있다면)에 대한 새 참조를 "
"반환해야 합니다. 이터레이션이 끝에 도달하면, :c:member:`~PyTypeObject.tp_iternext`\\는 예외를 "
"설정하지 않고 ``NULL``\\을 반환하거나, ``NULL``\\을 반환하는 것에 *더해* "
":exc:`StopIteration`\\을 설정할 수 있습니다; 예외를 피하면 성능이 약간 향상될 수 있습니다. 실제 에러가 "
"발생하면, :c:member:`~PyTypeObject.tp_iternext`\\는 항상 예외를 설정하고, ``NULL``\\을 "
"반환해야 합니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:547
msgid "Weak Reference Support"
msgstr "약한 참조 지원"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:549
msgid ""
"One of the goals of Python's weak reference implementation is to allow "
"any type to participate in the weak reference mechanism without incurring"
" the overhead on performance-critical objects (such as numbers)."
msgstr ""
"파이썬의 약한 참조 구현의 목표 중 하나는 성능에 중요한 객체(가령 숫자)에 대한 부하를 발생시키지 않고 모든 형이 약한 참조 "
"메커니즘에 참여할 수 있도록 하는 것입니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:554
msgid "Documentation for the :mod:`weakref` module."
msgstr ":mod:`weakref` 모듈에 대한 설명서."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:556
msgid ""
"For an object to be weakly referencable, the extension type must do two "
"things:"
msgstr "객체가 약하게 참조될 수 있으려면, 확장형이 두 가지 작업을 수행해야 합니다:"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:558
msgid ""
"Include a :c:type:`PyObject\\*` field in the C object structure dedicated"
" to the weak reference mechanism.  The object's constructor should leave "
"it ``NULL`` (which is automatic when using the default "
":c:member:`~PyTypeObject.tp_alloc`)."
msgstr ""
"약한 참조 메커니즘 전용 C 객체 구조체에 :c:type:`PyObject\\*` 필드를 포함하십시오. 객체의 생성자는 이것을 "
"``NULL``\\로 남겨 두어야 합니다 (기본 :c:member:`~PyTypeObject.tp_alloc`\\을 사용할 때는 "
"자동입니다)."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:563
msgid ""
"Set the :c:member:`~PyTypeObject.tp_weaklistoffset` type member to the "
"offset of the aforementioned field in the C object structure, so that the"
" interpreter knows how to access and modify that field."
msgstr ""
"인터프리터가 해당 필드에 액세스하고 수정하는 방법을 알 수 있도록, "
":c:member:`~PyTypeObject.tp_weaklistoffset` 형 멤버를 C 객체 구조체에서 위에서 언급한 필드의 "
"오프셋으로 설정하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:567
msgid ""
"Concretely, here is how a trivial object structure would be augmented "
"with the required field::"
msgstr "구체적으로, 다음은 필수 필드로 사소한 객체 구조체를 확장하는 방법입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:575
msgid "And the corresponding member in the statically-declared type object::"
msgstr "그리고 정적으로 선언된 형 객체의 해당 멤버::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:583
msgid ""
"The only further addition is that ``tp_dealloc`` needs to clear any weak "
"references (by calling :c:func:`PyObject_ClearWeakRefs`) if the field is "
"non-``NULL``::"
msgstr ""
"유일한 추가 사항은 필드가 ``NULL``\\이 아니면 ``tp_dealloc``\\이 "
"(:c:func:`PyObject_ClearWeakRefs`\\를 호출하여) 모든 약한 참조를 지울 필요가 있다는 것입니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:599
msgid "More Suggestions"
msgstr "추가 제안"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:601
msgid ""
"In order to learn how to implement any specific method for your new data "
"type, get the :term:`CPython` source code.  Go to the :file:`Objects` "
"directory, then search the C source files for ``tp_`` plus the function "
"you want (for example, ``tp_richcompare``).  You will find examples of "
"the function you want to implement."
msgstr ""
"새 데이터형에 특정 메서드를 구현하는 방법을 배우려면, :term:`CPython` 소스 코드를 구하십시오. "
":file:`Objects` 디렉터리로 이동한 다음, C 소스 파일에서 ``tp_``\\에 원하는 기능을 더한 것(예를 들어, "
"``tp_richcompare``)을 검색하십시오. 구현하려는 함수의 예를 찾을 수 있을 겁니다."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:607
msgid ""
"When you need to verify that an object is a concrete instance of the type"
" you are implementing, use the :c:func:`PyObject_TypeCheck` function.  A "
"sample of its use might be something like the following::"
msgstr ""
"객체가 구현 중인 형의 구상 인스턴스인지 확인해야 하면, :c:func:`PyObject_TypeCheck` 함수를 사용하십시오. "
"사용 예는 다음과 같습니다::"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:618
msgid "Download CPython source releases."
msgstr "CPython 소스 릴리스를 다운로드하십시오."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:618
msgid "https://www.python.org/downloads/source/"
msgstr "https://www.python.org/downloads/source/"

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:620
msgid "The CPython project on GitHub, where the CPython source code is developed."
msgstr "GitHub의 CPython 프로젝트, CPython 소스 코드가 개발되는 곳."

#: /Users/flowdas/works/docs/python/src/Doc/extending/newtypes.rst:621
msgid "https://github.com/python/cpython"
msgstr "https://github.com/python/cpython"

