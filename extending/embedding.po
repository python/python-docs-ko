# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-11-26 18:49+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (https://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/extending/embedding.rst:8
msgid "Embedding Python in Another Application"
msgstr "다른 응용 프로그램에 파이썬 내장하기"

#: ../Doc/extending/embedding.rst:10
msgid ""
"The previous chapters discussed how to extend Python, that is, how to "
"extend the functionality of Python by attaching a library of C functions "
"to it.  It is also possible to do it the other way around: enrich your "
"C/C++ application by embedding Python in it.  Embedding provides your "
"application with the ability to implement some of the functionality of "
"your application in Python rather than C or C++. This can be used for "
"many purposes; one example would be to allow users to tailor the "
"application to their needs by writing some scripts in Python.  You can "
"also use it yourself if some of the functionality can be written in "
"Python more easily."
msgstr ""
"이전 장에서는 파이썬을 확장하는 방법, 즉 C 함수의 라이브러리를 파이썬에 연결하여 파이썬의 기능을 확장하는 방법에 관해 설명했습니다. "
"다른 방법도 가능합니다: 파이썬을 내장시켜 C/C++ 응용 프로그램을 풍부하게 만들 수 있습니다. 내장은 C 나 C++가 아닌 파이썬으로"
" 응용 프로그램의 일부 기능을 구현하는 능력을 응용 프로그램에 제공합니다. 이것은 여러 목적으로 사용될 수 있습니다; 한 가지 예는 "
"사용자가 파이썬으로 스크립트를 작성하여 응용 프로그램을 필요에 맞게 조정할 수 있게 하는 것입니다. 일부 기능을 파이썬으로 작성하기가 더"
" 쉽다면 직접 사용할 수도 있습니다."

#: ../Doc/extending/embedding.rst:20
msgid ""
"Embedding Python is similar to extending it, but not quite.  The "
"difference is that when you extend Python, the main program of the "
"application is still the Python interpreter, while if you embed Python, "
"the main program may have nothing to do with Python --- instead, some "
"parts of the application occasionally call the Python interpreter to run "
"some Python code."
msgstr ""
"파이썬을 내장하는 것은 파이썬을 확장하는 것과 유사합니다만, 아주 같지는 않습니다. 차이점은, 파이썬을 확장할 때 응용 프로그램의 주 "
"프로그램은 여전히 파이썬 인터프리터입니다. 반면에 파이썬을 내장하면 주 프로그램은 파이썬과 아무 관련이 없습니다 --- 대신 응용 "
"프로그램 일부에서 간혹 파이썬 코드를 실행하기 위해 파이썬 인터프리터를 호출합니다."

#: ../Doc/extending/embedding.rst:26
msgid ""
"So if you are embedding Python, you are providing your own main program."
"  One of the things this main program has to do is initialize the Python "
"interpreter.  At the very least, you have to call the function "
":c:func:`Py_Initialize`.  There are optional calls to pass command line "
"arguments to Python.  Then later you can call the interpreter from any "
"part of the application."
msgstr ""
"그래서 파이썬을 내장한다면, 여러분은 자신의 메인 프로그램을 제공하게 됩니다. 이 메인 프로그램이해야 할 일 중 하나는 파이썬 "
"인터프리터를 초기화하는 것입니다. 최소한, :c:func:`Py_Initialize` 함수를 호출해야 합니다. 파이썬에 명령 줄 인자를 "
"전달하는 선택적 호출이 있습니다. 그런 다음 나중에 응용 프로그램의 어느 부분에서나 인터프리터를 호출할 수 있습니다."

#: ../Doc/extending/embedding.rst:32
msgid ""
"There are several different ways to call the interpreter: you can pass a "
"string containing Python statements to :c:func:`PyRun_SimpleString`, or "
"you can pass a stdio file pointer and a file name (for identification in "
"error messages only) to :c:func:`PyRun_SimpleFile`.  You can also call "
"the lower-level operations described in the previous chapters to "
"construct and use Python objects."
msgstr ""
"인터프리터를 호출하는 방법에는 여러 가지가 있습니다: 파이썬 문장을 포함하는 문자열을 "
":c:func:`PyRun_SimpleString`\\에 전달하거나, stdio 파일 포인터와 파일명(에러 메시지에서의 식별만을 위해)을"
" :c:func:`PyRun_SimpleFile`\\에 전달할 수 있습니다. 또한, 이전 장에서 설명한 저수준의 연산을 호출하여 파이썬 "
"객체를 만들고 사용할 수 있습니다."

#: ../Doc/extending/embedding.rst:42
msgid ":ref:`c-api-index`"
msgstr ":ref:`c-api-index`"

#: ../Doc/extending/embedding.rst:42
msgid ""
"The details of Python's C interface are given in this manual. A great "
"deal of necessary information can be found here."
msgstr "파이썬의 C 인터페이스에 대한 자세한 내용은 이 매뉴얼에 있습니다. 필요한 정보가 많이 있습니다."

#: ../Doc/extending/embedding.rst:49
msgid "Very High Level Embedding"
msgstr "매우 고수준의 내장"

#: ../Doc/extending/embedding.rst:51
msgid ""
"The simplest form of embedding Python is the use of the very high level "
"interface. This interface is intended to execute a Python script without "
"needing to interact with the application directly. This can for example "
"be used to perform some operation on a file. ::"
msgstr ""
"파이썬을 내장하는 가장 간단한 형태는 매우 고수준의 인터페이스를 사용하는 것입니다. 이 인터페이스는 응용 프로그램과 직접 상호 작용할 "
"필요 없이 파이썬 스크립트를 실행하기 위한 것입니다. 이것은 예를 들어 파일에 대해 어떤 연산을 수행하는 데 사용될 수 있습니다. ::"

#: ../Doc/extending/embedding.rst:77
msgid ""
"The :c:func:`Py_SetProgramName` function should be called before "
":c:func:`Py_Initialize` to inform the interpreter about paths to Python "
"run-time libraries.  Next, the Python interpreter is initialized with "
":c:func:`Py_Initialize`, followed by the execution of a hard-coded Python"
" script that prints the date and time.  Afterwards, the "
":c:func:`Py_FinalizeEx` call shuts the interpreter down, followed by the "
"end of the program.  In a real program, you may want to get the Python "
"script from another source, perhaps a text-editor routine, a file, or a "
"database.  Getting the Python code from a file can better be done by "
"using the :c:func:`PyRun_SimpleFile` function, which saves you the "
"trouble of allocating memory space and loading the file contents."
msgstr ""
":c:func:`Py_SetProgramName` 함수는 파이썬 런타임 라이브러리에 대한 경로를 인터프리터에게 알리기 위해 "
":c:func:`Py_Initialize`\\보다 먼저 호출되어야 합니다. 다음으로, 파이썬 인터프리터는 "
":c:func:`Py_Initialize`\\로 초기화되고, 날짜와 시간을 인쇄하는 하드 코딩된 파이썬 스크립트가 실행됩니다. 그런 "
"다음, :c:func:`Py_FinalizeEx` 호출이 인터프리터를 종료하고 프로그램이 끝납니다. 실제 프로그램에서는 파이썬 스크립트를"
" 다른 소스(아마도 텍스트 편집기 루틴, 파일 또는 데이터베이스)에서 가져올 수 있습니다. 파일에서 파이썬 코드를 얻는 것은 "
":c:func:`PyRun_SimpleFile` 함수를 사용하면 더 잘할 수 있는데, 메모리 공간을 할당하고 파일 내용을 로드하는 "
"번거로움을 덜어줍니다."

#: ../Doc/extending/embedding.rst:92
msgid "Beyond Very High Level Embedding: An overview"
msgstr "매우 고수준 내장을 넘어서: 개요"

#: ../Doc/extending/embedding.rst:94
msgid ""
"The high level interface gives you the ability to execute arbitrary "
"pieces of Python code from your application, but exchanging data values "
"is quite cumbersome to say the least. If you want that, you should use "
"lower level calls. At the cost of having to write more C code, you can "
"achieve almost anything."
msgstr ""
"고수준 인터페이스는 응용 프로그램에서 임의의 파이썬 코드를 실행할 수 있는 능력을 제공하지만, 최소한 데이터 값을 교환하는 것이 꽤 "
"번거롭습니다. 그러길 원한다면 저수준의 호출을 사용해야 합니다. 더 많은 C 코드를 작성해야 하는 대신, 거의 모든 것을 달성할 수 "
"있습니다."

#: ../Doc/extending/embedding.rst:99
msgid ""
"It should be noted that extending Python and embedding Python is quite "
"the same activity, despite the different intent. Most topics discussed in"
" the previous chapters are still valid. To show this, consider what the "
"extension code from Python to C really does:"
msgstr ""
"파이썬을 확장하는 것과 파이썬을 내장하는 것은 다른 의도에도 불구하고 꽤 똑같은 활동이라는 점에 유의해야 합니다. 이전 장에서 논의된 "
"대부분 주제는 여전히 유효합니다. 이것을 보시려면, 파이썬에서 C로의 확장 코드가 실제로 하는 일을 생각해보십시오:"

#: ../Doc/extending/embedding.rst:104
msgid "Convert data values from Python to C,"
msgstr "데이터값을 파이썬에서 C로 변환하고,"

#: ../Doc/extending/embedding.rst:106
msgid "Perform a function call to a C routine using the converted values, and"
msgstr "변환된 값을 사용하여 C 루틴으로 함수 호출을 수행하고,"

#: ../Doc/extending/embedding.rst:108
msgid "Convert the data values from the call from C to Python."
msgstr "그 호출에서 얻은 데이터값을 C에서 파이썬으로 변환합니다."

#: ../Doc/extending/embedding.rst:110
msgid "When embedding Python, the interface code does:"
msgstr "파이썬을 내장할 때, 인터페이스 코드는 다음을 수행합니다:"

#: ../Doc/extending/embedding.rst:112
msgid "Convert data values from C to Python,"
msgstr "데이터값을 C에서 파이썬으로 변환하고,"

#: ../Doc/extending/embedding.rst:114
msgid ""
"Perform a function call to a Python interface routine using the converted"
" values, and"
msgstr "변환된 값을 사용하여 파이썬 인터페이스 루틴으로 함수 호출을 수행하고,"

#: ../Doc/extending/embedding.rst:117
msgid "Convert the data values from the call from Python to C."
msgstr "그 호출에서 얻은 데이터 값을 파이썬에서 C로 변환합니다."

#: ../Doc/extending/embedding.rst:119
msgid ""
"As you can see, the data conversion steps are simply swapped to "
"accommodate the different direction of the cross-language transfer. The "
"only difference is the routine that you call between both data "
"conversions. When extending, you call a C routine, when embedding, you "
"call a Python routine."
msgstr ""
"보시다시피, 데이터 변환 단계가 언어 간 전송의 다른 방향을 수용하기 위해 단순히 교환됩니다. 유일한 차이점은 두 데이터 변환 간에 "
"호출하는 루틴입니다. 확장할 때는 C 루틴을 호출하고, 내장할 때는 파이썬 루틴을 호출합니다."

#: ../Doc/extending/embedding.rst:124
msgid ""
"This chapter will not discuss how to convert data from Python to C and "
"vice versa.  Also, proper use of references and dealing with errors is "
"assumed to be understood.  Since these aspects do not differ from "
"extending the interpreter, you can refer to earlier chapters for the "
"required information."
msgstr ""
"이 장에서는 파이썬에서 C로 데이터를 변환하는 방법과 그 반대로 데이터를 변환하는 방법에 관해서는 설명하지 않습니다. 또한, 참조의 "
"올바른 사용과 에러를 다루는 것을 이해하고 있다고 가정합니다. 이러한 측면은 인터프리터를 확장하는 것과 다르지 않으므로, 이전 장에서 "
"필요한 정보를 참조할 수 있습니다."

#: ../Doc/extending/embedding.rst:133
msgid "Pure Embedding"
msgstr "순수한 내장"

#: ../Doc/extending/embedding.rst:135
msgid ""
"The first program aims to execute a function in a Python script. Like in "
"the section about the very high level interface, the Python interpreter "
"does not directly interact with the application (but that will change in "
"the next section)."
msgstr ""
"첫 번째 프로그램은 파이썬 스크립트에 있는 함수를 실행하는 것을 목표로 합니다. 매우 고수준의 인터페이스에 관한 절에서와같이, 파이썬 "
"인터프리터는 애플리케이션과 직접 상호 작용하지 않습니다 (하지만 다음 절에서 바뀔 것입니다)."

#: ../Doc/extending/embedding.rst:140
msgid "The code to run a function defined in a Python script is:"
msgstr "파이썬 스크립트에서 정의된 함수를 실행하는 코드는 다음과 같습니다:"

#: ../Doc/extending/embedding.rst:145
msgid ""
"This code loads a Python script using ``argv[1]``, and calls the function"
" named in ``argv[2]``.  Its integer arguments are the other values of the"
" ``argv`` array.  If you :ref:`compile and link <compiling>` this program"
" (let's call the finished executable :program:`call`), and use it to "
"execute a Python script, such as:"
msgstr ""
"이 코드는 ``argv[1]``\\를 사용하여 파이썬 스크립트를 로드하고, ``argv[2]``\\에서 명명된 함수를 호출합니다. 정수 "
"인자는 ``argv`` 배열의 남은 값들입니다. 이 프로그램을 :ref:`컴파일하고 링크하면 <compiling>` (완성된 실행 파일을"
" :program:`call`\\이라고 부릅시다), 다음과 같은 파이썬 스크립트를 실행하는 데 사용합니다:"

#: ../Doc/extending/embedding.rst:160
msgid "then the result should be:"
msgstr "그러면 결과는 다음과 같아야 합니다:"

#: ../Doc/extending/embedding.rst:168
msgid ""
"Although the program is quite large for its functionality, most of the "
"code is for data conversion between Python and C, and for error "
"reporting.  The interesting part with respect to embedding Python starts "
"with ::"
msgstr ""
"프로그램이 기능보다 상당히 큰 편이지만, 대부분 코드는 파이썬과 C 사이의 데이터 변환과 에러 보고를 위한 것입니다. 파이썬 내장과 "
"관련된 흥미로운 부분은 다음처럼 시작합니다 ::"

#: ../Doc/extending/embedding.rst:177
msgid ""
"After initializing the interpreter, the script is loaded using "
":c:func:`PyImport_Import`.  This routine needs a Python string as its "
"argument, which is constructed using the :c:func:`PyUnicode_FromString` "
"data conversion routine. ::"
msgstr ""
"인터프리터를 초기화한 후, 스크립트는 :c:func:`PyImport_Import`\\를 사용하여 로드됩니다. 이 루틴은 인자로 파이썬 "
"문자열을 요구하는데, :c:func:`PyUnicode_FromString` 데이터 변환 루틴을 사용하여 구성됩니다. ::"

#: ../Doc/extending/embedding.rst:190
msgid ""
"Once the script is loaded, the name we're looking for is retrieved using "
":c:func:`PyObject_GetAttrString`.  If the name exists, and the object "
"returned is callable, you can safely assume that it is a function.  The "
"program then proceeds by constructing a tuple of arguments as normal.  "
"The call to the Python function is then made with::"
msgstr ""
"일단 스크립트가 로드되면, 우리가 찾고 있는 이름이 :c:func:`PyObject_GetAttrString`\\를 사용하여 검색됩니다."
" 이름이 존재하고, 반환된 객체가 콜러블이면, 그것이 함수라고 안전하게 가정할 수 있습니다. 그런 다음 프로그램은 인자의 튜플을 일반적인"
" 방법으로 구성하여 진행합니다. 그런 다음 파이썬 함수 호출은 이렇게 이루어집니다::"

#: ../Doc/extending/embedding.rst:198
msgid ""
"Upon return of the function, ``pValue`` is either *NULL* or it contains a"
" reference to the return value of the function.  Be sure to release the "
"reference after examining the value."
msgstr ""
"함수가 반환되면, ``pValue``\\는 *NULL*\\이거나 함수의 반환 값에 대한 참조를 포함합니다. 값을 검토한 후 참조를 "
"해제해야 합니다."

#: ../Doc/extending/embedding.rst:206
msgid "Extending Embedded Python"
msgstr "내장된 파이썬을 확장하기"

#: ../Doc/extending/embedding.rst:208
msgid ""
"Until now, the embedded Python interpreter had no access to functionality"
" from the application itself.  The Python API allows this by extending "
"the embedded interpreter.  That is, the embedded interpreter gets "
"extended with routines provided by the application. While it sounds "
"complex, it is not so bad.  Simply forget for a while that the "
"application starts the Python interpreter.  Instead, consider the "
"application to be a set of subroutines, and write some glue code that "
"gives Python access to those routines, just like you would write a normal"
" Python extension.  For example::"
msgstr ""
"지금까지 내장된 파이썬 인터프리터는 애플리케이션 자체의 기능에 액세스할 수 없었습니다. 파이썬 API는 내장된 인터프리터를 확장함으로써 "
"이것을 허용합니다. 즉, 내장된 인터프리터는 응용 프로그램에서 제공하는 루틴으로 확장됩니다. 복잡하게 들리지만, 그렇게 나쁘지는 "
"않습니다. 잠시 응용 프로그램이 파이썬 인터프리터를 시작한다는 것을 잊어버리십시오. 대신, 응용 프로그램을 서브 루틴의 집합으로 "
"간주하고, 일반 파이썬 확장을 작성하는 것처럼 파이썬에서 해당 루틴에 액세스할 수 있도록 연결 코드를 작성하십시오. 예를 들면::"

#: ../Doc/extending/embedding.rst:245
msgid ""
"Insert the above code just above the :c:func:`main` function. Also, "
"insert the following two statements before the call to "
":c:func:`Py_Initialize`::"
msgstr ""
"위의 코드를 :c:func:`main` 함수 바로 위에 삽입하십시오. 또한, :c:func:`Py_Initialize`\\에 대한 호출 "
"전에 다음 두 문장을 삽입하십시오::"

#: ../Doc/extending/embedding.rst:251
msgid ""
"These two lines initialize the ``numargs`` variable, and make the "
":func:`emb.numargs` function accessible to the embedded Python "
"interpreter. With these extensions, the Python script can do things like"
msgstr ""
"이 두 줄은 ``numargs`` 변수를 초기화하고, :func:`emb.numargs` 함수를 내장된 파이썬 인터프리터가 액세스할 수 "
"있도록 만듭니다. 이러한 확장을 통해, 파이썬 스크립트는 다음과 같은 작업을 수행할 수 있습니다"

#: ../Doc/extending/embedding.rst:260
msgid ""
"In a real application, the methods will expose an API of the application "
"to Python."
msgstr "실제 응용 프로그램에서, 이 방법은 응용 프로그램의 API를 파이썬에 노출합니다."

#: ../Doc/extending/embedding.rst:270
msgid "Embedding Python in C++"
msgstr "C++로 파이썬 내장하기"

#: ../Doc/extending/embedding.rst:272
msgid ""
"It is also possible to embed Python in a C++ program; precisely how this "
"is done will depend on the details of the C++ system used; in general you"
" will need to write the main program in C++, and use the C++ compiler to "
"compile and link your program.  There is no need to recompile Python "
"itself using C++."
msgstr ""
"파이썬을 C++ 프로그램에 내장하는 것도 가능합니다; 이것이 어떻게 수행되는지는 사용된 C++ 시스템의 세부 사항에 달려 있습니다; "
"일반적으로 C++로 메인 프로그램을 작성하고, C++ 컴파일러를 사용하여 프로그램을 컴파일하고 링크해야 합니다. C++을 사용하여 파이썬"
" 자체를 다시 컴파일할 필요는 없습니다."

#: ../Doc/extending/embedding.rst:281
msgid "Compiling and Linking under Unix-like systems"
msgstr "유닉스 계열 시스템에서 컴파일과 링크하기"

#: ../Doc/extending/embedding.rst:283
msgid ""
"It is not necessarily trivial to find the right flags to pass to your "
"compiler (and linker) in order to embed the Python interpreter into your "
"application, particularly because Python needs to load library modules "
"implemented as C dynamic extensions (:file:`.so` files) linked against "
"it."
msgstr ""
"파이썬 인터프리터를 응용 프로그램에 내장하기 위해 컴파일러(와 링커)에 적절한 플래그를 찾는 것이 늘 간단하지는 않습니다. 특히, 특히 "
"파이썬이 자신에게 링크된 C 동적 확장(:file:`.so` 파일)으로 구현된 라이브러리 모듈을 로드해야 하기 때문입니다."

#: ../Doc/extending/embedding.rst:289
msgid ""
"To find out the required compiler and linker flags, you can execute the "
":file:`python{X.Y}-config` script which is generated as part of the "
"installation process (a :file:`python3-config` script may also be "
"available).  This script has several options, of which the following will"
" be directly useful to you:"
msgstr ""
"필요한 컴파일러와 링커 플래그를 찾으려면, 설치 절차의 일부로 생성된 :file:`python{X.Y}-config` 스크립트를 실행할 "
"수 있습니다 (:file:`python3-config` 스크립트도 사용 가능할 수 있습니다). 이 스크립트에는 여러 옵션이 있으며, "
"다음과 같은 것들은 여러분에 직접 유용할 것입니다:"

#: ../Doc/extending/embedding.rst:295
msgid ""
"``pythonX.Y-config --cflags`` will give you the recommended flags when "
"compiling:"
msgstr "``pythonX.Y-config --cflags``\\는 컴파일 할 때의 권장 플래그를 제공합니다:"

#: ../Doc/extending/embedding.rst:303
msgid ""
"``pythonX.Y-config --ldflags`` will give you the recommended flags when "
"linking:"
msgstr "``pythonX.Y-config --ldflags``\\는 링크 할 때의 권장 플래그를 제공합니다:"

#: ../Doc/extending/embedding.rst:312
msgid ""
"To avoid confusion between several Python installations (and especially "
"between the system Python and your own compiled Python), it is "
"recommended that you use the absolute path to :file:`python{X.Y}-config`,"
" as in the above example."
msgstr ""
"여러 파이썬 설치 간의 (특히 시스템 파이썬과 여러분이 직접 컴파일한 파이썬 간의) 혼란을 피하려면, 위의 예와 같이 "
":file:`python{X.Y}-config`\\의 절대 경로를 사용하는 것이 좋습니다."

#: ../Doc/extending/embedding.rst:317
msgid ""
"If this procedure doesn't work for you (it is not guaranteed to work for "
"all Unix-like platforms; however, we welcome :ref:`bug reports "
"<reporting-bugs>`) you will have to read your system's documentation "
"about dynamic linking and/or examine Python's :file:`Makefile` (use "
":func:`sysconfig.get_makefile_filename` to find its location) and "
"compilation options.  In this case, the :mod:`sysconfig` module is a "
"useful tool to programmatically extract the configuration values that you"
" will want to combine together.  For example:"
msgstr ""
"이 절차가 여러분을 위해 작동하지 않는다면 (모든 유닉스 계열 플랫폼에서 작동하는 것은 보장되지 않습니다; 하지만, :ref:`버그 보고"
" <reporting-bugs>`\\를 환영합니다), 동적 링크에 관한 시스템의 설명서를 읽는 것과/이나 파이썬의 "
":file:`Makefile`\\과 (그 위치를 찾으려면 :func:`sysconfig.get_makefile_filename`\\를 "
"사용하십시오) 컴파일 옵션을 검사해야 합니다. 이때, :mod:`sysconfig` 모듈은 여러분이 결합하려는 구성 값을 프로그래밍 "
"방식으로 추출하는 데 유용한 도구입니다. 예를 들어:"
