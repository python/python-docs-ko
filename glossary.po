# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2017, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2017.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.6\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2017-12-23 11:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dong-gweon Oh <flowdas@gmail.com>\n"
"Language-Team: Korean (http://python.flowdas.com)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.5.1\n"

#: ../Doc/glossary.rst:5
msgid "Glossary"
msgstr "용어집"

#: ../Doc/glossary.rst:10
msgid "``>>>``"
msgstr "``>>>``"

#: ../Doc/glossary.rst:12
msgid ""
"The default Python prompt of the interactive shell.  Often seen for code "
"examples which can be executed interactively in the interpreter."
msgstr "대화형 셸의 기본 파이썬 프롬프트. 인터프리터에서 대화형으로 실행될 수 있는 코드 예에서 자주 볼 수 있다."

#: ../Doc/glossary.rst:14
msgid "``...``"
msgstr "``...``"

#: ../Doc/glossary.rst:16
msgid ""
"The default Python prompt of the interactive shell when entering code for"
" an indented code block or within a pair of matching left and right "
"delimiters (parentheses, square brackets or curly braces)."
msgstr ""
"들여쓰기 된 코드 블록이나, 쌍을 이루는 구분자 (괄호, 꺾쇠괄호, 중괄호) 안에 코드를 입력할 때 대화형 셸의 기본 파이썬 "
"프롬프트."

#: ../Doc/glossary.rst:19
msgid "2to3"
msgstr "2to3"

#: ../Doc/glossary.rst:21
msgid ""
"A tool that tries to convert Python 2.x code to Python 3.x code by "
"handling most of the incompatibilities which can be detected by parsing "
"the source and traversing the parse tree."
msgstr ""
"파이썬 2.x 코드를 파이썬 3.x 코드로 변환하려고 시도하는 도구인데, 소스를 파싱하고 파스 트리를 탐색해서 감지할 수 있는 "
"대부분의 비호환성을 다룬다."

#: ../Doc/glossary.rst:25
msgid ""
"2to3 is available in the standard library as :mod:`lib2to3`; a standalone"
" entry point is provided as :file:`Tools/scripts/2to3`.  See "
":ref:`2to3-reference`."
msgstr ""
"2to3 는 표준 라이브러리에서 :mod:`lib2to3` 로 제공된다; 독립적으로 실행할 수 있는 스크립트는 "
":file:`Tools/scripts/2to3` 로 제공된다. :ref:`2to3-reference` 를 보세요."

#: ../Doc/glossary.rst:28
msgid "abstract base class"
msgstr "abstract base class (추상 베이스 클래스)"

#: ../Doc/glossary.rst:30
msgid ""
"Abstract base classes complement :term:`duck-typing` by providing a way "
"to define interfaces when other techniques like :func:`hasattr` would be "
"clumsy or subtly wrong (for example with :ref:`magic methods <special-"
"lookup>`).  ABCs introduce virtual subclasses, which are classes that "
"don't inherit from a class but are still recognized by :func:`isinstance`"
" and :func:`issubclass`; see the :mod:`abc` module documentation.  Python"
" comes with many built-in ABCs for data structures (in the "
":mod:`collections.abc` module), numbers (in the :mod:`numbers` module), "
"streams (in the :mod:`io` module), import finders and loaders (in the "
":mod:`importlib.abc` module).  You can create your own ABCs with the "
":mod:`abc` module."
msgstr ""
"추상 베이스 클래스는 :func:`hasattr` 같은 다른 테크닉들이 불편하거나 미묘하게 잘못된 (예를 들어, :ref:`매직 "
"메서드 <special-lookup>`) 경우, 인터페이스를 정의하는 방법을 제공함으로써 :term:`덕 타이핑 <duck-"
"typing>` 을 보완한다. ABC는 가상 서브 클래스를 도입하는데, 클래스를 계승하지 않으면서도 "
":func:`isinstance` 와 :func:`issubclass` 에 의해 감지될 수 있는 클래스들이다; :mod:`abc` "
"모듈 도큐멘테이션을 보세요. 파이썬에는 많은 내장 ABC 들이 따라오는데 다음과 같은 것들이 있다: 자료 구조 "
"(:mod:`collections.abc` 모듈에서), 숫자 (:mod:`numbers` 모듈에서), 스트림 (:mod:`io`"
" 모듈에서), 임포트 파인더와 로더 (:mod:`importlib.abc` 모듈에서). :mod:`abc` 모듈을 사용해서 "
"자신만의 ABC를 만들 수도 있다."

#: ../Doc/glossary.rst:41
msgid "argument"
msgstr "argument (인자)"

#: ../Doc/glossary.rst:43
msgid ""
"A value passed to a :term:`function` (or :term:`method`) when calling the"
" function.  There are two kinds of argument:"
msgstr ""
"함수를 호출할 때 :term:`함수 <function>` (또는 :term:`메서드 <method>`) 로 전달되는 값. 두 종류의"
" 인자가 있다:"

#: ../Doc/glossary.rst:46
msgid ""
":dfn:`keyword argument`: an argument preceded by an identifier (e.g. "
"``name=``) in a function call or passed as a value in a dictionary "
"preceded by ``**``.  For example, ``3`` and ``5`` are both keyword "
"arguments in the following calls to :func:`complex`::"
msgstr ""
":dfn:`키워드 인자 (keyword argument)`: 함수 호출 때 식별자가 앞에 붙은 인자 (예를 들어, "
"``name=``) 또는 ``**`` 를 앞에 붙인 딕셔너리로 전달되는 인자. 예를 들어, 다음과 같은 :func:`complex`"
" 호출에서 ``3`` 과 ``5`` 는 모두 키워드 인자다::"

#: ../Doc/glossary.rst:54
msgid ""
":dfn:`positional argument`: an argument that is not a keyword argument. "
"Positional arguments can appear at the beginning of an argument list "
"and/or be passed as elements of an :term:`iterable` preceded by ``*``. "
"For example, ``3`` and ``5`` are both positional arguments in the "
"following calls::"
msgstr ""
":dfn:`위치 인자 (positional argument)`: 키워드 인자가 아닌 인자. 위치 인자들은 인자 목록의 처음에 "
"나오거나 :term:`이터러블 <iterable>` 의 앞에 ``*`` 를 붙여 전달할 수 있다. 예를 들어, 다음과 같은 호출에서"
" ``3`` 과 ``5`` 는 모두 위치 인자다."

#: ../Doc/glossary.rst:63
msgid ""
"Arguments are assigned to the named local variables in a function body. "
"See the :ref:`calls` section for the rules governing this assignment. "
"Syntactically, any expression can be used to represent an argument; the "
"evaluated value is assigned to the local variable."
msgstr ""
"인자는 함수 바의 이름 붙은 지역 변수에 대입된다. 이 대입에 적용되는 규칙들에 대해서는 :ref:`calls` 섹션을 보세요. "
"문법적으로, 어떤 표현식이건 인자로 사용될 수 있다; 구해진 값이 지역 변수에 대입된다."

#: ../Doc/glossary.rst:68
msgid ""
"See also the :term:`parameter` glossary entry, the FAQ question on "
":ref:`the difference between arguments and parameters <faq-argument-vs-"
"parameter>`, and :pep:`362`."
msgstr ""
"용어집의 :term:`파라미터 <parameter>` 항목과 FAQ 질문 :ref:`인자와 파라미터의 차이 <faq-"
"argument-vs-parameter>` 와 :pep:`362` 도 보세요."

#: ../Doc/glossary.rst:71
msgid "asynchronous context manager"
msgstr "asynchronous context manager (비동기 컨텍스트 매니저)"

#: ../Doc/glossary.rst:73
msgid ""
"An object which controls the environment seen in an :keyword:`async with`"
" statement by defining :meth:`__aenter__` and :meth:`__aexit__` methods."
"  Introduced by :pep:`492`."
msgstr ""
":meth:`__aenter__` 와 :meth:`__aexit__` 메서드를 정의함으로써 :keyword:`async with` "
"문에서 보이는 환경을 제어하는 객체. :pep:`492` 로 도입되었다."

#: ../Doc/glossary.rst:76
msgid "asynchronous generator"
msgstr "asynchronous generator (비동기 제너레이터)"

#: ../Doc/glossary.rst:78
msgid ""
"A function which returns an :term:`asynchronous generator iterator`.  It "
"looks like a coroutine function defined with :keyword:`async def` except "
"that it contains :keyword:`yield` expressions for producing a series of "
"values usable in an :keyword:`async for` loop."
msgstr ""
":term:`비동기 제너레이터 이터레이터 <asynchronous generator iterator>` 를 돌려주는 함수. "
":keyword:`async def` 로 정의되는 코루틴 함수처럼 보이는데, :keyword:`async for` 루프가 사용할 수"
" 있는 일련의 값들을 만드는 :keyword:`yield` 표현식을 포함한다는 점이 다르다."

#: ../Doc/glossary.rst:83
msgid ""
"Usually refers to a asynchronous generator function, but may refer to an "
"*asynchronous generator iterator* in some contexts.  In cases where the "
"intended meaning isn't clear, using the full terms avoids ambiguity."
msgstr ""
"보통 비동기 제너레이터 함수를 가리키지만, 어떤 문맥에서는 *비동기 제너레이터 이터레이터* 를 가리킨다. 의도하는 의미가 명확하지 "
"않은 경우는, 완전한 용어를 써서 모호함을 없앤다."

#: ../Doc/glossary.rst:87
msgid ""
"An asynchronous generator function may contain :keyword:`await` "
"expressions as well as :keyword:`async for`, and :keyword:`async with` "
"statements."
msgstr ""
"비동기 제너레이터 함수는 :keyword:`await` 표현식과, :keyword:`async for` 문과, "
":keyword:`async with` 문을 포함할 수 있다."

#: ../Doc/glossary.rst:90
msgid "asynchronous generator iterator"
msgstr "asynchronous generator iterator (비동기 제너레이터 이터레이터)"

#: ../Doc/glossary.rst:92
msgid "An object created by a :term:`asynchronous generator` function."
msgstr ":term:`비동기 제너레이터 <asynchronous generator>` 함수가 만드는 객체."

#: ../Doc/glossary.rst:94
msgid ""
"This is an :term:`asynchronous iterator` which when called using the "
":meth:`__anext__` method returns an awaitable object which will execute "
"that the body of the asynchronous generator function until the next "
":keyword:`yield` expression."
msgstr ""
":term:`비동기 이터레이터 <asynchronous iterator>` 인데 :meth:`__anext__` 를 호출하면 "
"어웨이터블 객체를 돌려주고, 이것은 다음 :keyword:`yield` 표현식 까지 비동기 제너레이터 함수의 바디를 실행한다."

#: ../Doc/glossary.rst:99
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *asynchronous generator iterator* effectively "
"resumes with another awaitable returned by :meth:`__anext__`, it picks-up"
" where it left-off.  See :pep:`492` and :pep:`525`."
msgstr ""
"각 :keyword:`yield` 는 일시적으로 처리를 중단하고, 그 위치의 (지역 변수들과 대기 중인 try-문들을 포함하는) 실행"
" 상태를 기억한다. *비동기 제너레이터 이터레이터* 가 :meth:`__anext__` 가 돌려주는 또 하나의 어웨이터블로 "
"재개되면, 떠난 곳으로 복귀한다. :pep:`492` 와 :pep:`525` 를 보세요."

#: ../Doc/glossary.rst:104
msgid "asynchronous iterable"
msgstr "asynchronous iterable (비동기 이터러블)"

#: ../Doc/glossary.rst:106
msgid ""
"An object, that can be used in an :keyword:`async for` statement. Must "
"return an :term:`asynchronous iterator` from its :meth:`__aiter__` "
"method.  Introduced by :pep:`492`."
msgstr ""
":keyword:`async for` 문에서 사용될 수 있는 객체. :meth:`__aiter__` 메서드는 :term:`비동기 "
"이터레이터 <asynchronous iterator>` 를 돌려줘야 한다. :pep:`492` 로 도입되었다."

#: ../Doc/glossary.rst:109
msgid "asynchronous iterator"
msgstr "asynchronous iterator (비동기 이터레이터)"

#: ../Doc/glossary.rst:111
msgid ""
"An object that implements :meth:`__aiter__` and :meth:`__anext__` "
"methods.  ``__anext__`` must return an :term:`awaitable` object. "
":keyword:`async for` resolves awaitable returned from asynchronous "
"iterator's :meth:`__anext__` method until it raises "
":exc:`StopAsyncIteration` exception.  Introduced by :pep:`492`."
msgstr ""
":meth:`__aiter__` 와 :meth:`__anext__` 메서드를 구현하는 객체. ``__anext__`` 는 "
":term:`어웨이터블 <awaitable>` 객체를 돌려줘야 한다. :keyword:`async for` 는 "
":exc:`StopAsyncIteration` 예외가 발생할 때까지 비동기 이터레이터의 :meth:`__anext__` 메서드가 "
"돌려주는 어웨이터블을 푼다. :pep:`492` 로 도입되었다."

#: ../Doc/glossary.rst:116
msgid "attribute"
msgstr "attribute (어트리뷰트)"

#: ../Doc/glossary.rst:118
msgid ""
"A value associated with an object which is referenced by name using "
"dotted expressions.  For example, if an object *o* has an attribute *a* "
"it would be referenced as *o.a*."
msgstr ""
"점표현식을 사용하는 이름으로 참조되는 객체와 결합한 값. 예를 들어, 객체 *o* 가 어트리뷰트 *a* 를 가지면, *o.a* 처럼"
" 참조된다."

#: ../Doc/glossary.rst:121
msgid "awaitable"
msgstr "awaitable (어웨이터블)"

#: ../Doc/glossary.rst:123
msgid ""
"An object that can be used in an :keyword:`await` expression.  Can be a "
":term:`coroutine` or an object with an :meth:`__await__` method. See also"
" :pep:`492`."
msgstr ""
":keyword:`await` 표현식에 사용할 수 있는 객체. :term:`코루틴 <coroutine>` 이나 "
":meth:`__await__` 메서드를 가진 객체가 될 수 있다. :pep:`492` 를 보세요."

#: ../Doc/glossary.rst:126
msgid "BDFL"
msgstr "BDFL"

#: ../Doc/glossary.rst:128
msgid ""
"Benevolent Dictator For Life, a.k.a. `Guido van Rossum "
"<https://www.python.org/~guido/>`_, Python's creator."
msgstr ""
"자비로운 종신 독재자 (Benevolent Dictator For Life), 즉 `Guido van Rossum "
"<https://www.python.org/~guido/>`_, 파이썬의 창시자."

#: ../Doc/glossary.rst:130
msgid "binary file"
msgstr "binary file (바이너리 파일)"

#: ../Doc/glossary.rst:132
msgid ""
"A :term:`file object` able to read and write :term:`bytes-like objects "
"<bytes-like object>`. Examples of binary files are files opened in binary"
" mode (``'rb'``, ``'wb'`` or ``'rb+'``), :data:`sys.stdin.buffer`, "
":data:`sys.stdout.buffer`, and instances of :class:`io.BytesIO` and "
":class:`gzip.GzipFile`."
msgstr ""
":term:`바이트열류 객체들 <bytes-like object>` 을 읽고 쓸 수 있는 :term:`파일 객체 <file "
"object>`. 바이너리 파일의 예로는 바이너리 모드 (``'rb'``, ``'wb'`` 또는 ``'rb+'``) 로 열린 파일,"
" :data:`sys.stdin.buffer`, :data:`sys.stdout.buffer`, :class:`io.BytesIO`"
" 와 :class:`gzip.GzipFile` 의 인스턴스를 들 수 있다."

#: ../Doc/glossary.rst:140
msgid "A :term:`text file` reads and writes :class:`str` objects."
msgstr ":term:`텍스트 파일 <text file>` 은 :class:`str` 객체들을 읽고 쓴다."

#: ../Doc/glossary.rst:141
msgid "bytes-like object"
msgstr "bytes-like object (바이트열류 객체)"

#: ../Doc/glossary.rst:143
msgid ""
"An object that supports the :ref:`bufferobjects` and can export a "
"C-:term:`contiguous` buffer. This includes all :class:`bytes`, "
":class:`bytearray`, and :class:`array.array` objects, as well as many "
"common :class:`memoryview` objects.  Bytes-like objects can be used for "
"various operations that work with binary data; these include compression,"
" saving to a binary file, and sending over a socket."
msgstr ""
":ref:`bufferobjects` 를 지원하고 C-:term:`연속 <contiguous>` 버퍼를 익스포트 할 수 있다. 여러 "
"공통 :class:`memoryview` 객체들은 물론이고 :class:`bytes`, :class:`bytearray`, "
":class:`array.array` 객체들을 포함한다. 바이트열류 객체들은 바이너리 데이터를 다루는 여러 가지 연산들에 사용될 수 "
"있다; 압축, 바이너리 파일로 저장, 소켓을 통한 전송 같은 것들이 있다."

#: ../Doc/glossary.rst:150
msgid ""
"Some operations need the binary data to be mutable.  The documentation "
"often refers to these as \"read-write bytes-like objects\".  Example "
"mutable buffer objects include :class:`bytearray` and a "
":class:`memoryview` of a :class:`bytearray`. Other operations require the"
" binary data to be stored in immutable objects (\"read-only bytes-like "
"objects\"); examples of these include :class:`bytes` and a "
":class:`memoryview` of a :class:`bytes` object."
msgstr ""
"어떤 연산들은 바이너리 데이터가 가변적일 필요가 있다. 이런 경우에 도큐멘테이션은 종종 \"읽고-쓰기 바이트열류 객체\"라고 "
"표현한다. 가변 버퍼 객체의 예로는 :class:`bytearray` 와 :class:`bytearray` 의 "
":class:`memoryview` 가 있다. 다른 연산들은 바이너리 데이터가 불변 객체 (\"읽기 전용 바이트열류 객체\")에 "
"저장되도록 요구한다; 이런 것들의 예로는 :class:`bytes` 와 :class:`bytes` 객체의 "
":class:`memoryview` 가 있다."

#: ../Doc/glossary.rst:158
msgid "bytecode"
msgstr "bytecode (바이트 코드)"

#: ../Doc/glossary.rst:160
msgid ""
"Python source code is compiled into bytecode, the internal representation"
" of a Python program in the CPython interpreter.  The bytecode is also "
"cached in ``.pyc`` files so that executing the same file is faster the "
"second time (recompilation from source to bytecode can be avoided).  This"
" \"intermediate language\" is said to run on a :term:`virtual machine` "
"that executes the machine code corresponding to each bytecode. Do note "
"that bytecodes are not expected to work between different Python virtual "
"machines, nor to be stable between Python releases."
msgstr ""
"파이썬 소스 코드는 바이트 코드로 컴파일되는데, CPython 인터프리터에서 파이썬 프로그램의 내부 표현이다. 바이트 코드는 "
"``.pyc`` 파일에 캐시 되어, 같은 파일을 두 번째 실행할 때 더 빨라지게 만든다 (소스에서 바이트 코드로의 재컴파일을 피할 수 "
"있다). 이 \"중간 언어\" 는 각 바이트 코드에 대응하는 기계를 실행하는 :term:`가상 기계 <virtual machine>`"
" 에서 실행된다고 말한다. 바이트 코드는 서로 다른 파이썬 가상 기계에서 작동할 것으로 기대하지도, 파이썬 배포 간에 안정적이지도 "
"않다는 것에 주의해야 한다."

#: ../Doc/glossary.rst:170
msgid ""
"A list of bytecode instructions can be found in the documentation for "
":ref:`the dis module <bytecodes>`."
msgstr "바이트 코드 명령어들의 목록은 :ref:`dis 모듈 <bytecodes>` 도큐멘테이션에 나온다."

#: ../Doc/glossary.rst:172
msgid "class"
msgstr "class (클래스)"

#: ../Doc/glossary.rst:174
msgid ""
"A template for creating user-defined objects. Class definitions normally "
"contain method definitions which operate on instances of the class."
msgstr "사용자 정의 객체들을 만들기 위한 주형. 클래스 정의는 보통 클래스의 인스턴스를 대상으로 연산하는 메서드 정의들을 포함한다."

#: ../Doc/glossary.rst:177
msgid "coercion"
msgstr "coercion (코어션)"

#: ../Doc/glossary.rst:179
msgid ""
"The implicit conversion of an instance of one type to another during an "
"operation which involves two arguments of the same type.  For example, "
"``int(3.15)`` converts the floating point number to the integer ``3``, "
"but in ``3+4.5``, each argument is of a different type (one int, one "
"float), and both must be converted to the same type before they can be "
"added or it will raise a ``TypeError``.  Without coercion, all arguments "
"of even compatible types would have to be normalized to the same value by"
" the programmer, e.g., ``float(3)+4.5`` rather than just ``3+4.5``."
msgstr ""
"같은 형의 두 인자를 수반하는 연산이 일어나는 동안, 한 형의 인스턴스를 다른 형으로 묵시적으로 변환하는 것. 예를 들어, "
"``int(3.15)`` 는 실수를 정수 ``3`` 으로 변환한다. 하지만, ``3+4.5`` 에서, 각 인자는 다른 형이고 "
"(하나는 int, 다른 하나는 float), 둘을 더하기 전에 같은 형으로 변환해야 한다. 그렇지 않으면 ``TypeError`` "
"를 일으킨다. 코어션 없이는, 호환되는 형들조차도 프로그래머가 같은 형으로 정규화해주어야 한다, 예를 들어, 그냥 "
"``3+4.5`` 하는 대신 ``float(3)+4.5``."

#: ../Doc/glossary.rst:187
msgid "complex number"
msgstr "complex number (복소수)"

#: ../Doc/glossary.rst:189
msgid ""
"An extension of the familiar real number system in which all numbers are "
"expressed as a sum of a real part and an imaginary part.  Imaginary "
"numbers are real multiples of the imaginary unit (the square root of "
"``-1``), often written ``i`` in mathematics or ``j`` in engineering.  "
"Python has built-in support for complex numbers, which are written with "
"this latter notation; the imaginary part is written with a ``j`` suffix, "
"e.g., ``3+1j``.  To get access to complex equivalents of the :mod:`math` "
"module, use :mod:`cmath`.  Use of complex numbers is a fairly advanced "
"mathematical feature.  If you're not aware of a need for them, it's "
"almost certain you can safely ignore them."
msgstr ""
"익숙한 실수 시스템의 확장인데, 모든 숫자가 실수부와 허수부의 합으로 표현된다. 허수부는 실수에 허수 단위 (``-1`` 의 "
"제곱근)를 곱한 것인데, 종종 수학에서는 ``i`` 로, 공학에서는 ``j`` 로 표기한다. 파이썬은 후자의 표기법을 쓰는 복소수를 "
"기본 지원한다; 허수부는 ``j`` 접미사를 붙여서 표기한다, 예를 들어, ``3+1j``. :mod:`math` 모듈의 복소수 "
"버전이 필요하면, :mod:`cmath` 를 사용한다. 복소수의 활용은 꽤 수준 높은 수학적 기능이다. 필요하다고 느끼지 못한다면,"
" 거의 확실히 무시해도 좋다."

#: ../Doc/glossary.rst:199
msgid "context manager"
msgstr "context manager (컨텍스트 매니저)"

#: ../Doc/glossary.rst:201
msgid ""
"An object which controls the environment seen in a :keyword:`with` "
"statement by defining :meth:`__enter__` and :meth:`__exit__` methods. See"
" :pep:`343`."
msgstr ""
":meth:`__enter__` 와 :meth:`__exit__` 메서드를 정의함으로써 :keyword:`with` 문에서 보이는"
" 환경을 제어하는 객체. :pep:`343` 로 도입되었다."

#: ../Doc/glossary.rst:204
msgid "contiguous"
msgstr "contiguous (연속)"

#: ../Doc/glossary.rst:208
msgid ""
"A buffer is considered contiguous exactly if it is either *C-contiguous* "
"or *Fortran contiguous*.  Zero-dimensional buffers are C and Fortran "
"contiguous.  In one-dimensional arrays, the items must be laid out in "
"memory next to each other, in order of increasing indexes starting from "
"zero.  In multidimensional C-contiguous arrays, the last index varies the"
" fastest when visiting items in order of memory address.  However, in "
"Fortran contiguous arrays, the first index varies the fastest."
msgstr ""
"버퍼는 정확히 *C-연속 (C-contiguous)* 이거나 *포트란 연속 (Fortran contiguous)* 일 때 연속이라고"
" 여겨진다. 영차원 버퍼는 C-연속이면서 포트란 연속이다. 일차원 배열에서, 항목들은 서로에 인접하고, 0에서 시작하는 오름차순"
" 인덱스의 순서대로 메모리에 배치되어야 한다. 다차원 C-연속 배열에서, 메모리 주소의 순서대로 항목들을 방문할 때 마지막 인덱스가"
" 가장 빨리 변한다. 하지만, 포트란 연속 배열에서는, 첫 번째 인덱스가 가장 빨리 변한다."

#: ../Doc/glossary.rst:216
msgid "coroutine"
msgstr "coroutine (코루틴)"

#: ../Doc/glossary.rst:218
msgid ""
"Coroutines is a more generalized form of subroutines. Subroutines are "
"entered at one point and exited at another point.  Coroutines can be "
"entered, exited, and resumed at many different points.  They can be "
"implemented with the :keyword:`async def` statement.  See also "
":pep:`492`."
msgstr ""
"코루틴은 서브루틴의 더 일반화된 형태다. 서브루틴은 한 지점에서 진입하고 다른 지점에서 탈출한다. 코루틴은 여러 다른 지점에서 "
"진입하고, 탈출하고, 재개할 수 있다. 이것들은 :keyword:`async def` 문으로 구현할 수 있다. :pep:`492`"
" 를 보세요."

#: ../Doc/glossary.rst:223
msgid "coroutine function"
msgstr "coroutine function (코루틴 함수)"

#: ../Doc/glossary.rst:225
msgid ""
"A function which returns a :term:`coroutine` object.  A coroutine "
"function may be defined with the :keyword:`async def` statement, and may "
"contain :keyword:`await`, :keyword:`async for`, and :keyword:`async with`"
" keywords.  These were introduced by :pep:`492`."
msgstr ""
":term:`코루틴 <coroutine>` 객체를 돌려주는 함수. 코루틴 함수는 :keyword:`async def` 문으로 정의될"
" 수 있고, :keyword:`await` 와 :keyword:`async for` 와 :keyword:`async with` "
"키워드를 포함할 수 있다. 이것들은 :pep:`492` 에 의해 도입되었다. "

#: ../Doc/glossary.rst:230
msgid "CPython"
msgstr "CPython"

#: ../Doc/glossary.rst:232
msgid ""
"The canonical implementation of the Python programming language, as "
"distributed on `python.org <https://www.python.org>`_.  The term "
"\"CPython\" is used when necessary to distinguish this implementation "
"from others such as Jython or IronPython."
msgstr ""
"파이썬 프로그래밍 언어의 규범적인 구현인데, `python.org <https://www.python.org>`_ 에서 배포된다. "
"이 구현을 Jython 이나 IronPython 과 같은 다른 것들과 구별할 필요가 있을 때 용어 \"CPython\" 이 "
"사용된다."

#: ../Doc/glossary.rst:236
msgid "decorator"
msgstr "decorator (데코레이터)"

#: ../Doc/glossary.rst:238
msgid ""
"A function returning another function, usually applied as a function "
"transformation using the ``@wrapper`` syntax.  Common examples for "
"decorators are :func:`classmethod` and :func:`staticmethod`."
msgstr ""
"다른 함수를 돌려주는 함수인데, 보통 ``@wrapper`` 문법을 사용한 함수 변환으로 적용된다. 데코레이터의 흔한 예는 "
":func:`classmethod` 과 :func:`staticmethod` 다."

#: ../Doc/glossary.rst:242
msgid ""
"The decorator syntax is merely syntactic sugar, the following two "
"function definitions are semantically equivalent::"
msgstr "데코레이터 문법은 단지 편의 문법일 뿐이다. 다음 두 함수 정의는 의미상으로 동등하다::"

#: ../Doc/glossary.rst:253
msgid ""
"The same concept exists for classes, but is less commonly used there.  "
"See the documentation for :ref:`function definitions <function>` and "
":ref:`class definitions <class>` for more about decorators."
msgstr ""
"같은 개념이 클래스에도 존재하지만, 덜 자주 쓰인다. 데코레이터에 대한 더 자세한 내용은 :ref:`함수 정의 <function>`"
" 와 :ref:`클래스 정의 <class>` 의 도큐멘테이션을 보면 된다."

#: ../Doc/glossary.rst:256
msgid "descriptor"
msgstr "descriptor (디스크립터)"

#: ../Doc/glossary.rst:258
msgid ""
"Any object which defines the methods :meth:`__get__`, :meth:`__set__`, or"
" :meth:`__delete__`.  When a class attribute is a descriptor, its special"
" binding behavior is triggered upon attribute lookup.  Normally, using "
"*a.b* to get, set or delete an attribute looks up the object named *b* in"
" the class dictionary for *a*, but if *b* is a descriptor, the respective"
" descriptor method gets called.  Understanding descriptors is a key to a "
"deep understanding of Python because they are the basis for many features"
" including functions, methods, properties, class methods, static methods,"
" and reference to super classes."
msgstr ""
"메서드 :meth:`__get__` 이나 :meth:`__set__` 이나 :meth:`__delete__` 를 정의하는 객체. "
"클래스 어트리뷰트가 디스크립터일 때, 어트리뷰트 조회는 특별한 연결 작용을 일으킨다. 보통, *a.b* 를 읽거나, 쓰거나, "
"삭제하는데 사용할 때, *a* 의 클래스 딕셔너리에서 *b* 라고 이름 붙여진 객체를 찾는다. 하지만 *b* 가 디스크립터면, "
"해당하는 디스크립터 메서드가 호출된다. 디스크립터를 이해하는 것은 파이썬에 대한 깊은 이해의 열쇠인데, 함수, 메서드, 프라퍼티, "
"클래스 메서드, 스태틱 메서드, 슈퍼클래스 참조 등의 많은 기능의 기초를 이루고 있기 때문이다."

#: ../Doc/glossary.rst:268
msgid "For more information about descriptors' methods, see :ref:`descriptors`."
msgstr "디스크립터의 메서드들에 대한 자세한 내용은 :ref:`descriptors` 에 나온다."

#: ../Doc/glossary.rst:269
msgid "dictionary"
msgstr "dictionary (딕셔너리)"

#: ../Doc/glossary.rst:271
msgid ""
"An associative array, where arbitrary keys are mapped to values.  The "
"keys can be any object with :meth:`__hash__` and :meth:`__eq__` methods. "
"Called a hash in Perl."
msgstr ""
"임의의 키를 값에 대응시키는 연관 배열 (associative array). 키는 :meth:`__hash__` 와 "
":meth:`__eq__` 메서드를 갖는 모든 객체가 될 수 있다. 펄에서 해시라고 부른다."

#: ../Doc/glossary.rst:274
msgid "dictionary view"
msgstr "dictionary view (딕셔너리 뷰)"

#: ../Doc/glossary.rst:276
msgid ""
"The objects returned from :meth:`dict.keys`, :meth:`dict.values`, and "
":meth:`dict.items` are called dictionary views. They provide a dynamic "
"view on the dictionary’s entries, which means that when the dictionary "
"changes, the view reflects these changes. To force the dictionary view to"
" become a full list use ``list(dictview)``.  See :ref:`dict-views`."
msgstr ""
":meth:`dict.keys`, :meth:`dict.values`, :meth:`dict.items` 메서드가 돌려주는 객체들을"
" 딕셔너리 뷰라고 부른다. 이것들은 딕셔너리 항목들에 대한 동적인 뷰를 제공하는데, 딕셔너리가 변경될 때, 뷰가 이 변화를 "
"반영한다는 뜻이다. 딕셔너리 뷰를 완전한 리스트로 바꾸려면 ``list(dictview)`` 를 사용하면 된다. :ref"
":`dict-views` 를 보세요."

#: ../Doc/glossary.rst:282
msgid "docstring"
msgstr "docstring (독스트링)"

#: ../Doc/glossary.rst:284
msgid ""
"A string literal which appears as the first expression in a class, "
"function or module.  While ignored when the suite is executed, it is "
"recognized by the compiler and put into the :attr:`__doc__` attribute of "
"the enclosing class, function or module.  Since it is available via "
"introspection, it is the canonical place for documentation of the object."
msgstr ""
"클래스, 함수, 모듈에서 첫 번째 표현식으로 나타나는 문자열 리터럴. 스위트가 실행될 때는 무시되지만, 컴파일러에 의해 인지되어 둘러싼"
" 클래스, 함수, 모듈의 :attr:`__doc__` 어트리뷰트로 삽입된다. 인트로스팩션을 통해 사용할 수 있으므로, 객체의 "
"도큐멘테이션을 위한 규범적인 장소다."

#: ../Doc/glossary.rst:290
msgid "duck-typing"
msgstr "duck-typing (덕 타이핑)"

#: ../Doc/glossary.rst:292
msgid ""
"A programming style which does not look at an object's type to determine "
"if it has the right interface; instead, the method or attribute is simply"
" called or used (\"If it looks like a duck and quacks like a duck, it "
"must be a duck.\")  By emphasizing interfaces rather than specific types,"
" well-designed code improves its flexibility by allowing polymorphic "
"substitution.  Duck-typing avoids tests using :func:`type` or "
":func:`isinstance`.  (Note, however, that duck-typing can be complemented"
" with :term:`abstract base classes <abstract base class>`.)  Instead, it "
"typically employs :func:`hasattr` tests or :term:`EAFP` programming."
msgstr ""
"올바른 인터페이스를 가졌는지 판단하는데 객체의 형을 보지 않는 프로그래밍 스타일; 대신, 단순히 메서드나 어트리뷰트가 호출되거나"
" 사용된다 (\"오리처럼 보이고 오리처럼 꽥꽥댄다면, 그것은 오리다.\") 특정한 형 대신에 인터페이스를 강조함으로써, 잘 설계된"
" 코드는 다형적인 치환을 허락함으로써 유연성을 개선할 수 있다. 덕 타이핑은 :func:`type` 이나 "
":func:`isinstance` 을 사용한 검사를 피한다. (하지만, 덕 타이핑이 :term:`추상 베이스 클래스 "
"<abstract base class>` 로 보완될 수 있음에 유의해야 한다.) 대신에, :func:`hasattr` 검사나 "
":term:`EAFP` 프로그래밍을 쓴다."

#: ../Doc/glossary.rst:301
msgid "EAFP"
msgstr "EAFP"

#: ../Doc/glossary.rst:303
msgid ""
"Easier to ask for forgiveness than permission.  This common Python coding"
" style assumes the existence of valid keys or attributes and catches "
"exceptions if the assumption proves false.  This clean and fast style is "
"characterized by the presence of many :keyword:`try` and "
":keyword:`except` statements.  The technique contrasts with the "
":term:`LBYL` style common to many other languages such as C."
msgstr ""
"허락보다는 용서를 구하기가 쉽다 (Easier to ask for forgiveness than permission). 이 흔히"
" 볼 수 있는 파이썬 코딩 스타일은, 올바른 키나 어트리뷰트의 존재를 가정하고, 그 가정이 틀리면 예외를 잡는다. 이 깔끔하고 "
"빠른 스타일은 많은 :keyword:`try` 와 :keyword:`except` 문의 존재로 특징지어진다. 이 테크닉은 C와 "
"같은 다른 많은 언어에서 자주 사용되는 :term:`LBYL` 스타일과 대비된다."

#: ../Doc/glossary.rst:309
msgid "expression"
msgstr "expression (표현식)"

#: ../Doc/glossary.rst:311
msgid ""
"A piece of syntax which can be evaluated to some value.  In other words, "
"an expression is an accumulation of expression elements like literals, "
"names, attribute access, operators or function calls which all return a "
"value.  In contrast to many other languages, not all language constructs "
"are expressions.  There are also :term:`statement`\\s which cannot be "
"used as expressions, such as :keyword:`if`.  Assignments are also "
"statements, not expressions."
msgstr ""
"어떤 값으로 구해질 수 있는 문법적인 조각. 다른 말로 표현하면, 표현식은 리터럴, 이름, 어트리뷰트 액세스, 연산자, 함수들과 "
"같은 값을 돌려주는 표현 요소들을 쌓아 올린 것이다. 다른 많은 언어와 대조적으로, 모든 언어 구성물들이 표현식인 것은 아니다. "
":keyword:`if` 처럼, 표현식으로 사용할 수 없는 :term:`문장 <statement>` 들이 있다. 대입 또한 "
"문장이고, 표현식이 아니다."

#: ../Doc/glossary.rst:318
msgid "extension module"
msgstr "extension module (확장 모듈)"

#: ../Doc/glossary.rst:320
msgid ""
"A module written in C or C++, using Python's C API to interact with the "
"core and with user code."
msgstr "C 나 C++ 로 작성된 모듈인데, 파이썬의 C API를 사용해서 핵심이나 사용자 코드와 상호 작용한다."

#: ../Doc/glossary.rst:322
msgid "f-string"
msgstr "f-string (f-문자열)"

#: ../Doc/glossary.rst:324
msgid ""
"String literals prefixed with ``'f'`` or ``'F'`` are commonly called "
"\"f-strings\" which is short for :ref:`formatted string literals "
"<f-strings>`.  See also :pep:`498`."
msgstr ""
"``'f'`` 나 ``'F'`` 를 앞에 붙인 문자열 리터럴들을 흔히 \"f-문자열\"이라고 부르는데, :ref:`포맷 문자열 "
"리터럴 <f-strings>` 의 줄임말이다. :pep:`498` 을 보세요."

#: ../Doc/glossary.rst:327
msgid "file object"
msgstr "file object (파일 객체)"

#: ../Doc/glossary.rst:329
msgid ""
"An object exposing a file-oriented API (with methods such as "
":meth:`read()` or :meth:`write()`) to an underlying resource.  Depending "
"on the way it was created, a file object can mediate access to a real on-"
"disk file or to another type of storage or communication device (for "
"example standard input/output, in-memory buffers, sockets, pipes, etc.)."
"  File objects are also called :dfn:`file-like objects` or "
":dfn:`streams`."
msgstr ""
"하부 자원에 대해 파일 지향적 API (:meth:`read()` 나 :meth:`write()` 같은 메서드들) 를 드러내는 "
"객체. 만들어진 방법에 따라, 파일 객체는 실제 디스크 상의 파일이나 다른 저장장치나 통신 장치 (예를 들어, 표준 입출력, "
"인-메모리 버퍼, 소켓, 파이프, 등등)에 대한 액세스를 중계할 수 있다. 파일 객체는 :dfn:`파일류 객체 (file-like "
"objects)` 나 :dfn:`스트림 (streams)` 이라고도 불린다."

#: ../Doc/glossary.rst:337
msgid ""
"There are actually three categories of file objects: raw :term:`binary "
"files <binary file>`, buffered :term:`binary files <binary file>` and "
":term:`text files <text file>`. Their interfaces are defined in the "
":mod:`io` module.  The canonical way to create a file object is by using "
"the :func:`open` function."
msgstr ""
"실제로는 세 부류의 파일 객체들이 있다. 날(raw) :term:`바이너리 파일 <binary file>`, "
"버퍼드(buffered) :term:`바이너리 파일 <binary file>`, :term:`텍스트 파일 <text file>`. "
"이들의 인터페이스는 :mod:`io` 모듈에서 정의된다. 파일 객체를 만드는 규범적인 방법은 :func:`open` 함수를 쓰는 "
"것이다."

#: ../Doc/glossary.rst:342
msgid "file-like object"
msgstr "file-like object (파일류 객체)"

#: ../Doc/glossary.rst:344
msgid "A synonym for :term:`file object`."
msgstr ":term:`파일 객체 <file object>` 의 비슷한 말."

#: ../Doc/glossary.rst:345
msgid "finder"
msgstr "finder (파인더)"

#: ../Doc/glossary.rst:347
msgid ""
"An object that tries to find the :term:`loader` for a module that is "
"being imported."
msgstr "임포트될 모듈을 위한 :term:`로더 <loader>` 를 찾으려고 시도하는 객체."

#: ../Doc/glossary.rst:350
msgid ""
"Since Python 3.3, there are two types of finder: :term:`meta path finders"
" <meta path finder>` for use with :data:`sys.meta_path`, and :term:`path "
"entry finders <path entry finder>` for use with :data:`sys.path_hooks`."
msgstr ""
"파이썬 3.3. 이후로, 두 종류의 파인더가 있다: :data:`sys.meta_path` 와 함께 사용하는 :term:`메타 경로"
" 파인더 <meta path finder>` 와 :data:`sys.path_hooks` 과 함께 사용하는 :term:`경로 엔트리"
" 파인더 <path entry finder>`."

#: ../Doc/glossary.rst:354
msgid "See :pep:`302`, :pep:`420` and :pep:`451` for much more detail."
msgstr "더 자세한 내용은 :pep:`302`, :pep:`420`, :pep:`451` 에 나온다."

#: ../Doc/glossary.rst:355
msgid "floor division"
msgstr "floor division (정수 나눗셈)"

#: ../Doc/glossary.rst:357
msgid ""
"Mathematical division that rounds down to nearest integer.  The floor "
"division operator is ``//``.  For example, the expression ``11 // 4`` "
"evaluates to ``2`` in contrast to the ``2.75`` returned by float true "
"division.  Note that ``(-11) // 4`` is ``-3`` because that is ``-2.75`` "
"rounded *downward*. See :pep:`238`."
msgstr ""
"가장 가까운 정수로 내림하는 수학적 나눗셈. 정수 나눗셈 연산자는 ``//`` 다. 예를 들어, 표현식 ``11 // 4`` 의 "
"값은 ``2`` 가 되지만, 실수 나눗셈은 ``2.75`` 를 돌려준다. ``(-11) // 4`` 가 ``-2.75`` 를 "
"*내림* 한 ``-3`` 이 됨에 유의해야 한다. :pep:`238` 를 보세요."

#: ../Doc/glossary.rst:362
msgid "function"
msgstr "function (함수)"

#: ../Doc/glossary.rst:364
msgid ""
"A series of statements which returns some value to a caller. It can also "
"be passed zero or more :term:`arguments <argument>` which may be used in "
"the execution of the body. See also :term:`parameter`, :term:`method`, "
"and the :ref:`function` section."
msgstr ""
"호출자에게 어떤 값을 돌려주는 일련의 문장들. 없거나 그 이상의 :term:`인자 <argument>` 가 전달될 수 있는데, "
"바디의 실행에 사용될 수 있다. :term:`파라미터 <parameter>` 와 :term:`메서드 <method>` 와 "
":ref:`function` 섹션도 보세요."

#: ../Doc/glossary.rst:368
msgid "function annotation"
msgstr "function annotation (함수 어노테이션)"

#: ../Doc/glossary.rst:370
msgid ""
"An arbitrary metadata value associated with a function parameter or "
"return value. Its syntax is explained in section :ref:`function`.  "
"Annotations may be accessed via the :attr:`__annotations__` special "
"attribute of a function object."
msgstr ""
"함수 파라미터나 반환 값에 결합한 임의의 메타데이터 값. 문법은 섹션 :ref:`function` 에서 설명한다. 어노테이션은 함수 "
"객체의 :attr:`__annotations__` 특수 어트리뷰트를 통해 액세스 될 수 있다."

#: ../Doc/glossary.rst:375
msgid ""
"Python itself does not assign any particular meaning to function "
"annotations. They are intended to be interpreted by third-party libraries"
" or tools.  See :pep:`3107`, which describes some of their potential "
"uses."
msgstr ""
"파이썬 자체는 함수 어노테이션에 어떤 특별한 의미도 부여하지 않는다. 제삼자 라이브러리나 도구들에 의해 해석되는 것이 목적이다. "
":pep:`3107` 은 몇 가지 잠재적인 사용에 관해 기술하고 있다."

#: ../Doc/glossary.rst:378
msgid "__future__"
msgstr "__future__"

#: ../Doc/glossary.rst:380
msgid ""
"A pseudo-module which programmers can use to enable new language features"
" which are not compatible with the current interpreter."
msgstr "프로그래머가 현재 인터프리터와 호환되지 않는 새 언어 기능들을 활성화할 수 있도록 하는 가상 모듈."

#: ../Doc/glossary.rst:383
msgid ""
"By importing the :mod:`__future__` module and evaluating its variables, "
"you can see when a new feature was first added to the language and when "
"it becomes the default::"
msgstr ""
":mod:`__future__` 모듈을 임포트하고 그 변수들의 값들을 구해서, 새 기능이 언제 처음으로 언어에 추가되었고, 언제"
"부터 그것이 기본이 되는지 볼 수 있다::"

#: ../Doc/glossary.rst:390
msgid "garbage collection"
msgstr "garbage collection (가비지 수거)"

#: ../Doc/glossary.rst:392
msgid ""
"The process of freeing memory when it is not used anymore.  Python "
"performs garbage collection via reference counting and a cyclic garbage "
"collector that is able to detect and break reference cycles."
msgstr ""
"더 사용되지 않는 메모리를 반납하는 절차. 파이썬은 참조 횟수 추적과 참조 순환을 감지하고 끊을 수 있는 순환 가비지 수거기를"
" 통해 가비지 수거를 수행한다."

#: ../Doc/glossary.rst:397
msgid "generator"
msgstr "generator (제너레이터)"

#: ../Doc/glossary.rst:399
msgid ""
"A function which returns a :term:`generator iterator`.  It looks like a "
"normal function except that it contains :keyword:`yield` expressions for "
"producing a series of values usable in a for-loop or that can be "
"retrieved one at a time with the :func:`next` function."
msgstr ""
":term:`제너레이터 이터레이터 <generator iterator>` 를 돌려주는 함수. 일반 함수처럼 보이는데, 일련의 값들을"
" 만드는 :keyword:`yield` 표현식을 포함한다는 점이 다르다. 이 값들은 for-루프로 사용하거나 :func:`next`"
" 함수로 한 번에 하나씩 꺼낼 수 있다."

#: ../Doc/glossary.rst:404
msgid ""
"Usually refers to a generator function, but may refer to a *generator "
"iterator* in some contexts.  In cases where the intended meaning isn't "
"clear, using the full terms avoids ambiguity."
msgstr ""
"보통 제너레이터 함수를 가리키지만, 어떤 문맥에서는 *제너레이터 이터레이터* 를 가리킨다. 의도하는 의미가 명확하지 않은 경우는, "
"완전한 용어를 써서 모호함을 없앤다."

#: ../Doc/glossary.rst:407
msgid "generator iterator"
msgstr "generator iterator (제너레이터 이터레이터)"

#: ../Doc/glossary.rst:409
msgid "An object created by a :term:`generator` function."
msgstr ":term:`제너레이터 <generator>` 함수가 만드는 객체."

#: ../Doc/glossary.rst:411
msgid ""
"Each :keyword:`yield` temporarily suspends processing, remembering the "
"location execution state (including local variables and pending try-"
"statements).  When the *generator iterator* resumes, it picks-up where it"
" left-off (in contrast to functions which start fresh on every "
"invocation)."
msgstr ""
"각 :keyword:`yield` 는 일시적으로 처리를 중단하고, 그 위치의 (지역 변수들과 대기 중인 try-문들을 포함하는) 실행"
" 상태를 기억한다. *제너레이터 이터레이터* 가 재개되면, 떠난 곳으로 복귀한다 (호출마다 새로 시작하는 함수와 대비된다)."

#: ../Doc/glossary.rst:418
msgid "generator expression"
msgstr "generator expression (제너레이터 표현식)"

#: ../Doc/glossary.rst:420
msgid ""
"An expression that returns an iterator.  It looks like a normal "
"expression followed by a :keyword:`for` expression defining a loop "
"variable, range, and an optional :keyword:`if` expression.  The combined "
"expression generates values for an enclosing function::"
msgstr ""
"이터레이터를 돌려주는 표현식. 루프 변수와 범위를 정의하는 :keyword:`for` 표현식과 생략 가능한 :keyword:`if`"
" 표현식이 뒤에 붙는 일반 표현식 처럼 보인다. 결합한 표현식은 둘러싼 함수를 위한 값들을 만들어낸다::"

#: ../Doc/glossary.rst:427
msgid "generic function"
msgstr "generic function (제네릭 함수)"

#: ../Doc/glossary.rst:429
msgid ""
"A function composed of multiple functions implementing the same operation"
" for different types. Which implementation should be used during a call "
"is determined by the dispatch algorithm."
msgstr ""
"같은 연산을 서로 다른 형들에 대해 구현한 여러 함수로 구성된 함수. 호출 때 어떤 구현이 사용될지는 디스패치 알고리즘에 의해 "
"결정된다."

#: ../Doc/glossary.rst:433
msgid ""
"See also the :term:`single dispatch` glossary entry, the "
":func:`functools.singledispatch` decorator, and :pep:`443`."
msgstr ""
":term:`싱글 디스패치 <single dispatch>` 용어집 항목과 "
":func:`functools.singledispatch` 데코레이터와 :pep:`443` 도 보세요."

#: ../Doc/glossary.rst:436
msgid "GIL"
msgstr "GIL"

#: ../Doc/glossary.rst:438
msgid "See :term:`global interpreter lock`."
msgstr ":term:`전역 인터프리터 록 <global interpreter lock>` 을 보세요."

#: ../Doc/glossary.rst:439
msgid "global interpreter lock"
msgstr "global interpreter lock (전역 인터프리터 록)"

#: ../Doc/glossary.rst:441
msgid ""
"The mechanism used by the :term:`CPython` interpreter to assure that only"
" one thread executes Python :term:`bytecode` at a time. This simplifies "
"the CPython implementation by making the object model (including critical"
" built-in types such as :class:`dict`) implicitly safe against concurrent"
" access.  Locking the entire interpreter makes it easier for the "
"interpreter to be multi-threaded, at the expense of much of the "
"parallelism afforded by multi-processor machines."
msgstr ""
"한 번에 오직 하나의 스레드가 파이썬 :term:`바이트 코드 <bytecode>` 를 실행하도록 보장하기 위해 "
":term:`CPython` 인터프리터가 사용하는 메커니즘. (:class:`dict` 와 같은 중요한 내장형들을 포함하는) 객체"
" 모델이 묵시적으로 동시 액세스에 대해 안전하도록 만들어서 CPython 구현을 단순하게 만든다. 인터프리터 전체를 로킹하는 것은 "
"인터프리터를 다중스레드화하기 쉽게 만드는 대신, 다중 프로세서 기계가 제공하는 병렬성의 많은 부분을 희생한다."

#: ../Doc/glossary.rst:450
msgid ""
"However, some extension modules, either standard or third-party, are "
"designed so as to release the GIL when doing computationally-intensive "
"tasks such as compression or hashing.  Also, the GIL is always released "
"when doing I/O."
msgstr ""
"하지만, 어떤 확장 모듈들은, 표준이나 제삼자 모두, 압축이나 해싱 같은 계산 집약적인 작업을 수행할 때는 GIL 을 반납하도록 "
"설계되었다. 또한, I/O를 할 때는 항상 GIL 을 반납한다."

#: ../Doc/glossary.rst:455
msgid ""
"Past efforts to create a \"free-threaded\" interpreter (one which locks "
"shared data at a much finer granularity) have not been successful because"
" performance suffered in the common single-processor case. It is believed"
" that overcoming this performance issue would make the implementation "
"much more complicated and therefore costlier to maintain."
msgstr ""
"(훨씬 더 미세하게 공유 데이터를 로킹하는) \"스레드에 자유로운(free-threaded)\" 인터프리터를 만들고자 하는 과거의 "
"노력은 성공적이지 못했는데, 흔한 단일 프로세서 경우의 성능 저하가 심하기 때문이다. 이 성능 이슈를 극복하는 것은 구현을 훨씬 "
"복잡하게 만들어서 유지 비용이 더 들어갈 것으로 여겨지고 있다."

#: ../Doc/glossary.rst:460
msgid "hashable"
msgstr "hashable (해시 가능)"

#: ../Doc/glossary.rst:462
msgid ""
"An object is *hashable* if it has a hash value which never changes during"
" its lifetime (it needs a :meth:`__hash__` method), and can be compared "
"to other objects (it needs an :meth:`__eq__` method).  Hashable objects "
"which compare equal must have the same hash value."
msgstr ""
"객체가 일생 그 값이 변하지 않는 해시값을 갖고 (:meth:`__hash__` 메서드가 필요하다), 다른 객체와 비교될 수 "
"있으면 (:meth:`__eq__` 메서드가 필요하다), *해시 가능* 하다고 한다. 같다고 비교되는 해시 가능한 객체들의 해시값은 "
"같아야 한다."

#: ../Doc/glossary.rst:467
msgid ""
"Hashability makes an object usable as a dictionary key and a set member, "
"because these data structures use the hash value internally."
msgstr "해시 가능성은 객체를 딕셔너리의 키나 집합의 멤버로 사용할 수 있게 하는데, 이 자료 구조들이 내부적으로 해시값을 사용하기 때문이다."

#: ../Doc/glossary.rst:470
msgid ""
"All of Python's immutable built-in objects are hashable; mutable "
"containers (such as lists or dictionaries) are not.  Objects which are "
"instances of user-defined classes are hashable by default.  They all "
"compare unequal (except with themselves), and their hash value is derived"
" from their :func:`id`."
msgstr ""
"모든 파이썬의 불변 내장 객체들은 해시 가능하다. (리스트나 딕셔너리 같은) 가변 컨테이너들은 그렇지 않다. 사용자 정의 클래스의 "
"인스턴스 객체들은 기본적으로 해시 가능하다. (자기 자신을 제외하고는) 모두 다르다고 비교되고, 해시값은 :func:`id` 로 "
"부터 만들어진다."

#: ../Doc/glossary.rst:475
msgid "IDLE"
msgstr "IDLE"

#: ../Doc/glossary.rst:477
msgid ""
"An Integrated Development Environment for Python.  IDLE is a basic editor"
" and interpreter environment which ships with the standard distribution "
"of Python."
msgstr ""
"파이썬을 위한 통합 개발 환경 (Integrated Development Environment). IDLE은 파이썬의 표준 "
"배포판에 따라오는 기초적인 편집기와 인터프리터 환경이다."

#: ../Doc/glossary.rst:480
msgid "immutable"
msgstr "immutable (불변)"

#: ../Doc/glossary.rst:482
msgid ""
"An object with a fixed value.  Immutable objects include numbers, strings"
" and tuples.  Such an object cannot be altered.  A new object has to be "
"created if a different value has to be stored.  They play an important "
"role in places where a constant hash value is needed, for example as a "
"key in a dictionary."
msgstr ""
"고정된 값을 갖는 객체. 불변 객체는 숫자, 문자열, 튜플을 포함한다. 이런 객체들은 변경될 수 없다. 새 값을 저장하려면 새 "
"객체를 만들어야 한다. 변하지 않는 해시값이 있어야 하는 곳에서 중요한 역할을 한다, 예를 들어, 딕셔너리의 키."

#: ../Doc/glossary.rst:487
msgid "import path"
msgstr "import path (임포트 경로)"

#: ../Doc/glossary.rst:489
msgid ""
"A list of locations (or :term:`path entries <path entry>`) that are "
"searched by the :term:`path based finder` for modules to import. During "
"import, this list of locations usually comes from :data:`sys.path`, but "
"for subpackages it may also come from the parent package's ``__path__`` "
"attribute."
msgstr ""
":term:`경로 기반 파인더 <path based finder>` 가 임포트할 모듈을 찾기 위해 검색하는 장소들 (또는 "
":term:`경로 엔트리 <path entry>`) 의 목록. 임포트하는 동안, 이 장소들의 목록은 보통 "
":data:`sys.path` 로부터 온다, 하지만 서브 패키지의 경우 부모 패키지의 ``__path__`` 어트리뷰트로부터 올 수도"
" 있다."

#: ../Doc/glossary.rst:494
msgid "importing"
msgstr "importing (임포팅)"

#: ../Doc/glossary.rst:496
msgid ""
"The process by which Python code in one module is made available to "
"Python code in another module."
msgstr "한 모듈의 파이썬 코드가 다른 모듈의 파이썬 코드에서 사용될 수 있도록 하는 절차."

#: ../Doc/glossary.rst:498
msgid "importer"
msgstr "importer (임포터)"

#: ../Doc/glossary.rst:500
msgid ""
"An object that both finds and loads a module; both a :term:`finder` and "
":term:`loader` object."
msgstr ""
"모듈을 찾기도 하고 로드 하기도 하는 객체; 동시에 :term:`파인더 <finder>` 이자 :term:`로더 <loader>` "
"객체다."

#: ../Doc/glossary.rst:502
msgid "interactive"
msgstr "interactive (대화형)"

#: ../Doc/glossary.rst:504
msgid ""
"Python has an interactive interpreter which means you can enter "
"statements and expressions at the interpreter prompt, immediately execute"
" them and see their results.  Just launch ``python`` with no arguments "
"(possibly by selecting it from your computer's main menu). It is a very "
"powerful way to test out new ideas or inspect modules and packages "
"(remember ``help(x)``)."
msgstr ""
"파이썬은 대화형 인터프리터를 갖고 있는데, 인터프리터 프롬프트에서 문장과 표현식을 입력할 수 있고, 즉각 실행된 결과를 볼 수 "
"있다는 뜻이다. 인자 없이 단지 ``python`` 을 실행하라 (컴퓨터의 주메뉴에서 선택하는 것도 가능할 수 있다). 새 "
"아이디어를 검사하거나 모듈과 패키지를 들여다보는 매우 강력한 방법이다 (``help(x)`` 를 기억하세요)."

#: ../Doc/glossary.rst:510
msgid "interpreted"
msgstr "interpreted (인터프리티드)"

#: ../Doc/glossary.rst:512
msgid ""
"Python is an interpreted language, as opposed to a compiled one, though "
"the distinction can be blurry because of the presence of the bytecode "
"compiler.  This means that source files can be run directly without "
"explicitly creating an executable which is then run. Interpreted "
"languages typically have a shorter development/debug cycle than compiled "
"ones, though their programs generally also run more slowly.  See also "
":term:`interactive`."
msgstr ""
"바이트 코드 컴파일러의 존재 때문에 그 구분이 흐릿해지기는 하지만, 파이썬은 컴파일 언어가 아니라 인터프리터 언어다. 이것은 "
"명시적으로 실행 파일을 만들지 않고도, 소스 파일을 직접 실행할 수 있다는 뜻이다. 그 프로그램이 좀 더 천천히 실행되기는 하지만,"
" 인터프리터 언어는 보통 컴파일 언어보다 짧은 개발/디버깅 주기를 갖는다. :term:`대화형 <interactive>` 도 "
"보세요."

#: ../Doc/glossary.rst:519
msgid "interpreter shutdown"
msgstr "interpreter shutdown (인터프리터 종료)"

#: ../Doc/glossary.rst:521
msgid ""
"When asked to shut down, the Python interpreter enters a special phase "
"where it gradually releases all allocated resources, such as modules and "
"various critical internal structures.  It also makes several calls to the"
" :term:`garbage collector <garbage collection>`. This can trigger the "
"execution of code in user-defined destructors or weakref callbacks. Code "
"executed during the shutdown phase can encounter various exceptions as "
"the resources it relies on may not function anymore (common examples are "
"library modules or the warnings machinery)."
msgstr ""
"종료하라는 요청을 받을 때, 파이썬 인터프리터는 특별한 시기에 진입하는데, 모듈이나 여러 가지 중요한 내부 구조들과 같은 모든 할당된"
" 자원들을 단계적으로 반납한다. 또한, :term:`가비지 수거기 <garbage collection>` 를 여러 번 호출한다. "
"사용자 정의 파괴자나 weakref 콜백에 있는 코드들의 실행을 시작시킬 수 있다. 종료 시기 동안 실행되는 코드는 다양한 예외들을"
" 만날 수 있는데, 그것이 의존하는 자원들이 더 기능하지 않을 수 있기 때문이다 (흔한 예는 라이브러리 모듈이나 경고 "
"장치들이다)."

#: ../Doc/glossary.rst:530
msgid ""
"The main reason for interpreter shutdown is that the ``__main__`` module "
"or the script being run has finished executing."
msgstr "인터프리터 종료의 주된 원인은 실행되는 ``__main__`` 모듈이나 스크립트가 실행을 끝내는 것이다."

#: ../Doc/glossary.rst:532
msgid "iterable"
msgstr "iterable (이터러블)"

#: ../Doc/glossary.rst:534
msgid ""
"An object capable of returning its members one at a time. Examples of "
"iterables include all sequence types (such as :class:`list`, "
":class:`str`, and :class:`tuple`) and some non-sequence types like "
":class:`dict`, :term:`file objects <file object>`, and objects of any "
"classes you define with an :meth:`__iter__` method or with a "
":meth:`__getitem__` method that implements :term:`Sequence` semantics."
msgstr ""
"멤버들을 한 번에 하나씩 돌려줄 수 있는 객체. "
"이터러블의 예로는 모든 (:class:`list`, :class:`str`, "
":class:`tuple` 같은) 시퀀스 형들, :class:`dict` "
"같은 몇몇 비시퀀스 형들, :term:`파일 객체들 <file"
" object>`, :meth:`__iter__` 나 :term:`시퀀스 <Sequence>` 개념을 구현하는 :meth:`__getitem__`"
" 메서드를 써서 정의한 모든 클래스의 객체들이 있다."

#: ../Doc/glossary.rst:541
msgid ""
"Iterables can be used in a :keyword:`for` loop and in many other places "
"where a sequence is needed (:func:`zip`, :func:`map`, ...).  When an "
"iterable object is passed as an argument to the built-in function "
":func:`iter`, it returns an iterator for the object.  This iterator is "
"good for one pass over the set of values.  When using iterables, it is "
"usually not necessary to call :func:`iter` or deal with iterator objects "
"yourself.  The ``for`` statement does that automatically for you, "
"creating a temporary unnamed variable to hold the iterator for the "
"duration of the loop.  See also :term:`iterator`, :term:`sequence`, and "
":term:`generator`."
msgstr ""
"이터러블은 :keyword:`for` 루프에 사용될 수 있고,"
" 시퀀스를 필요로 하는 다른 많은 곳 "
"(:func:`zip`, :func:`map`, ...) 에 사용될 수"
" 있다. 이터러블 객체가 내장 함수 :func:`iter` "
"에 인자로 전달되면, 그 객체의 이터레이터를 돌려준다. "
"이 이터레이터는 값들의 집합을 한 번 거치는 동안"
" 유효하다. 이터러블을 사용할 때, 보통은 :func:`iter`"
" 를 호출하거나, 이터레이터 객체를 직접 다룰 필요는"
" 없다. ``for`` 문은 이것들을 여러분을 대신해서"
" 자동으로 해주는데, 루프를 도는 동안 이터레이터를 "
"잡아둘 이름 없는 변수를 만든다. :term:`이터레이터 "
"<iterator>`, :term:`시퀀스 <sequence>`, :term:`제너레이터"
" <generator>` 도 보세요."

#: ../Doc/glossary.rst:551
msgid "iterator"
msgstr "iterator (이터레이터)"

#: ../Doc/glossary.rst:553
msgid ""
"An object representing a stream of data.  Repeated calls to the "
"iterator's :meth:`~iterator.__next__` method (or passing it to the built-"
"in function :func:`next`) return successive items in the stream.  When no"
" more data are available a :exc:`StopIteration` exception is raised "
"instead.  At this point, the iterator object is exhausted and any further"
" calls to its :meth:`__next__` method just raise :exc:`StopIteration` "
"again.  Iterators are required to have an :meth:`__iter__` method that "
"returns the iterator object itself so every iterator is also iterable and"
" may be used in most places where other iterables are accepted.  One "
"notable exception is code which attempts multiple iteration passes.  A "
"container object (such as a :class:`list`) produces a fresh new iterator "
"each time you pass it to the :func:`iter` function or use it in a "
":keyword:`for` loop.  Attempting this with an iterator will just return "
"the same exhausted iterator object used in the previous iteration pass, "
"making it appear like an empty container."
msgstr ""
"데이터의 스트림을 표현하는 객체. 이터레이터의 :meth:`~iterator.__next__` 메서드를 반복적으로 호출하면 (또는 "
"내장 함수 :func:`next` 로 전달하면) 스트림에 있는 항목들을 차례대로 돌려준다. 더 이상의 데이터가 없을 때는 대신 "
":exc:`StopIteration` 예외를 일으킨다. 이 지점에서, 이터레이터 객체는 소진되고, 이후의 모든 "
":meth:`__next__` 메서드 호출은 :exc:`StopIteration` 예외를 다시 일으키기만 한다. 이터레이터는 "
"이터레이터 객체 자신을 돌려주는 :meth:`__iter__` 메서드를 가질 것이 요구되기 때문에, 이터레이터는 이터러블이기도 하고"
" 다른 이터러블들을 받아들이는 대부분의 곳에서 사용될 수 있다. 중요한 예외는 여러 번의 이터레이션을 시도하는 코드다. "
"(:class:`list` 같은) 컨테이너 객체는 :func:`iter` 함수로 전달하거나 :keyword:`for` 루프에 사용할"
" 때마다 새 이터레이터를 만든다. 이런 것을 이터레이터에 대해서 수행하려고 하면, 지난 이터레이션에 사용된 이미 소진된 이터레이터를"
" 돌려줘서, 빈 컨테이너처럼 보이게 만든다."

#: ../Doc/glossary.rst:568
msgid "More information can be found in :ref:`typeiter`."
msgstr ":ref:`typeiter` 에 더 자세한 내용이 있다."

#: ../Doc/glossary.rst:569
msgid "key function"
msgstr "key function (키 함수)"

#: ../Doc/glossary.rst:571
msgid ""
"A key function or collation function is a callable that returns a value "
"used for sorting or ordering.  For example, :func:`locale.strxfrm` is "
"used to produce a sort key that is aware of locale specific sort "
"conventions."
msgstr ""
"키 함수 또는 콜레이션(collation) 함수는 정렬(sorting)이나 배열(ordering)에 사용되는 값을 돌려주는 "
"콜러블이다. 예를 들어, :func:`locale.strxfrm` 은 로케일 특정 방식을 따르는 정렬 키를 만드는 데 사용된다."

#: ../Doc/glossary.rst:576
msgid ""
"A number of tools in Python accept key functions to control how elements "
"are ordered or grouped.  They include :func:`min`, :func:`max`, "
":func:`sorted`, :meth:`list.sort`, :func:`heapq.merge`, "
":func:`heapq.nsmallest`, :func:`heapq.nlargest`, and "
":func:`itertools.groupby`."
msgstr ""
"파이썬의 많은 도구가 요소들이 어떻게 순서 지어지고 묶이는지를 제어하기 위해 키 함수를 받아들인다. 이런 것들에는 "
":func:`min`, :func:`max`, :func:`sorted`, :meth:`list.sort`, "
":func:`heapq.merge`, :func:`heapq.nsmallest`, :func:`heapq.nlargest`, "
":func:`itertools.groupby` 이 있다."

#: ../Doc/glossary.rst:582
msgid ""
"There are several ways to create a key function.  For example. the "
":meth:`str.lower` method can serve as a key function for case insensitive"
" sorts.  Alternatively, a key function can be built from a "
":keyword:`lambda` expression such as ``lambda r: (r[0], r[2])``.  Also, "
"the :mod:`operator` module provides three key function constructors: "
":func:`~operator.attrgetter`, :func:`~operator.itemgetter`, and "
":func:`~operator.methodcaller`.  See the :ref:`Sorting HOW TO "
"<sortinghowto>` for examples of how to create and use key functions."
msgstr ""
"키 함수를 만드는 데는 여러 방법이 있다. 예를 들어, :meth:`str.lower` 메서드는 케이스 구분 없는 정렬을 위한 키 "
"함수로 사용될 수 있다. 대안적으로, 키 함수는 :keyword:`lambda` 표현식으로 만들 수도 있는데, 이런 식이다: "
"``lambda r: (r[0], r[2])``. 또한, :mod:`operator` 모듈은 세 개의 키 함수 생성자를 제공한다: "
":func:`~operator.attrgetter`, :func:`~operator.itemgetter`, "
":func:`~operator.methodcaller`. 키 함수를 만들고 사용하는 법에 대한 예로 :ref:`Sorting HOW"
" TO <sortinghowto>` 를 보세요."

#: ../Doc/glossary.rst:590
msgid "keyword argument"
msgstr "keyword argument (키워드 인자)"

#: ../Doc/glossary.rst:592 ../Doc/glossary.rst:836
msgid "See :term:`argument`."
msgstr ":term:`인자 <argument>` 를 보세요."

#: ../Doc/glossary.rst:593
msgid "lambda"
msgstr "lambda (람다)"

#: ../Doc/glossary.rst:595
msgid ""
"An anonymous inline function consisting of a single :term:`expression` "
"which is evaluated when the function is called.  The syntax to create a "
"lambda function is ``lambda [arguments]: expression``"
msgstr ""
"호출될 때 값이 구해지는 하나의 :term:`표현식 <expression>` 으로 구성된 이름 없는 인라인 함수. 람다 함수를 "
"만드는 문법은 ``lambda [arguments]: expression`` 이다."

#: ../Doc/glossary.rst:598
msgid "LBYL"
msgstr "LBYL"

#: ../Doc/glossary.rst:600
msgid ""
"Look before you leap.  This coding style explicitly tests for pre-"
"conditions before making calls or lookups.  This style contrasts with the"
" :term:`EAFP` approach and is characterized by the presence of many "
":keyword:`if` statements."
msgstr ""
"뛰기 전에 보라 (Look before you leap). 이 코딩 스타일은 호출이나 조회를 하기 전에 명시적으로 사전 조건들을 "
"검사한다. 이 스타일은 :term:`EAFP` 접근법과 대비되고, 많은 :keyword:`if` 문의 존재로 특징지어진다."

#: ../Doc/glossary.rst:605
msgid ""
"In a multi-threaded environment, the LBYL approach can risk introducing a"
" race condition between \"the looking\" and \"the leaping\".  For "
"example, the code, ``if key in mapping: return mapping[key]`` can fail if"
" another thread removes *key* from *mapping* after the test, but before "
"the lookup. This issue can be solved with locks or by using the EAFP "
"approach."
msgstr ""
"다중 스레드 환경에서, LBYL 접근법은 \"보기\"와 \"뛰기\" 간에 경쟁 조건을 만들게 될 위험이 있다. 예를 들어, 코드 "
"``if key in mapping: return mapping[key]`` 는 검사 후에, 하지만 조회 전에, 다른 스레드가 "
"*key* 를 *mapping* 에서 제거하면 실패할 수 있다. 이런 이슈는 록이나 EAFP 접근법을 사용함으로써 해결될 수 있다."

#: ../Doc/glossary.rst:610
msgid "list"
msgstr "list (리스트)"

#: ../Doc/glossary.rst:612
msgid ""
"A built-in Python :term:`sequence`.  Despite its name it is more akin to "
"an array in other languages than to a linked list since access to "
"elements are O(1)."
msgstr ""
"내장 파이썬 :term:`시퀀스 <sequence>`. 그 이름에도 불구하고, 원소에 대한 액세스가 O(1)이기 때문에, 연결 "
"리스트(linked list)보다는 다른 언어의 배열과 유사하다."

#: ../Doc/glossary.rst:615
msgid "list comprehension"
msgstr "list comprehension (리스트 컴프리헨션)"

#: ../Doc/glossary.rst:617
msgid ""
"A compact way to process all or part of the elements in a sequence and "
"return a list with the results.  ``result = ['{:#04x}'.format(x) for x in"
" range(256) if x % 2 == 0]`` generates a list of strings containing even "
"hex numbers (0x..) in the range from 0 to 255. The :keyword:`if` clause "
"is optional.  If omitted, all elements in ``range(256)`` are processed."
msgstr ""
"시퀀스의 요소들 전부 또는 일부를 처리하고 그 결과를 리스트로 돌려주는 간결한 방법. ``result = "
"['{:#04x}'.format(x) for x in range(256) if x % 2 == 0]`` 는 0에서 255 사이에 "
"있는 짝수들의 16진수 (0x..) 들을 포함하는 문자열의 리스트를 만든다. :keyword:`if` 절은 생략할 수 있다. "
"생략하면, ``range(256)`` 에 있는 모든 요소가 처리된다."

#: ../Doc/glossary.rst:623
msgid "loader"
msgstr "loader (로더)"

#: ../Doc/glossary.rst:625
msgid ""
"An object that loads a module. It must define a method named "
":meth:`load_module`. A loader is typically returned by a :term:`finder`. "
"See :pep:`302` for details and :class:`importlib.abc.Loader` for an "
":term:`abstract base class`."
msgstr ""
"모듈을 로드하는 객체. :meth:`load_module` 이라는 이름의 메서드를 정의해야 한다. 로더는 보통 :term:`파인더 "
"<finder>` 가 돌려준다. 자세한 내용은 :pep:`302` 를, :term:`추상 베이스 클래스 <abstract base "
"class>` 는 :class:`importlib.abc.Loader` 를 보세요."

#: ../Doc/glossary.rst:629
msgid "mapping"
msgstr "mapping (매핑)"

#: ../Doc/glossary.rst:631
msgid ""
"A container object that supports arbitrary key lookups and implements the"
" methods specified in the :class:`~collections.abc.Mapping` or "
":class:`~collections.abc.MutableMapping` :ref:`abstract base classes "
"<collections-abstract-base-classes>`.  Examples include :class:`dict`, "
":class:`collections.defaultdict`, :class:`collections.OrderedDict` and "
":class:`collections.Counter`."
msgstr ""
"임의의 키 조회를 지원하고 :class:`~collections.abc.Mapping` 이나 "
":class:`~collections.abc.MutableMapping` :ref:`추상 베이스 클래스 <collections-"
"abstract-base-classes>` 에 지정된 메서드들을 구현하는 컨테이너 객체. 예로는 :class:`dict`, "
":class:`collections.defaultdict`, :class:`collections.OrderedDict`, "
":class:`collections.Counter` 를 들 수 있다."

#: ../Doc/glossary.rst:637
msgid "meta path finder"
msgstr "meta path finder (메타 경로 파인더)"

#: ../Doc/glossary.rst:639
msgid ""
"A :term:`finder` returned by a search of :data:`sys.meta_path`.  Meta "
"path finders are related to, but different from :term:`path entry finders"
" <path entry finder>`."
msgstr ""
":data:`sys.meta_path` 의 검색이 돌려주는 :term:`파인더 <finder>`. 메타 경로 파인더는 "
":term:`경로 엔트리 파인더 <path entry finder>` 와 관련되어 있기는 하지만 다르다."

#: ../Doc/glossary.rst:643
msgid ""
"See :class:`importlib.abc.MetaPathFinder` for the methods that meta path "
"finders implement."
msgstr "메타 경로 파인더가 구현하는 메서드들에 대해서는 :class:`importlib.abc.MetaPathFinder` 를 보면 된다."

#: ../Doc/glossary.rst:645
msgid "metaclass"
msgstr "metaclass (메타 클래스)"

#: ../Doc/glossary.rst:647
msgid ""
"The class of a class.  Class definitions create a class name, a class "
"dictionary, and a list of base classes.  The metaclass is responsible for"
" taking those three arguments and creating the class.  Most object "
"oriented programming languages provide a default implementation.  What "
"makes Python special is that it is possible to create custom metaclasses."
"  Most users never need this tool, but when the need arises, metaclasses "
"can provide powerful, elegant solutions.  They have been used for logging"
" attribute access, adding thread-safety, tracking object creation, "
"implementing singletons, and many other tasks."
msgstr ""
"클래스의 클래스. 클래스 정의는 클래스 이름, 클래스 딕셔너리, 베이스 클래스들의 목록을 만든다. 메타 클래스는 이 세 인자를 "
"받아서 클래스를 만드는 책임을 진다. 대부분의 객체 지향형 프로그래밍 언어들은 기본 구현을 제공한다. 파이썬을 특별하게 만드는 것은"
" 커스텀 메타 클래스를 만들 수 있다는 것이다. 대부분 사용자에게는 이 도구가 전혀 필요 없지만, 필요가 생길 때, 메타 클래스는 "
"강력하고 우아한 해법을 제공한다. 어트리뷰트 액세스의 로깅(logging), 스레드 안전성의 추가, 객체 생성 추적, 싱글톤 구현과"
" 많은 다른 작업에 사용됐다."

#: ../Doc/glossary.rst:657
msgid "More information can be found in :ref:`metaclasses`."
msgstr ":ref:`metaclasses` 에서 더 자세한 내용을 찾을 수 있다."

#: ../Doc/glossary.rst:658
msgid "method"
msgstr "method (메서드)"

#: ../Doc/glossary.rst:660
msgid ""
"A function which is defined inside a class body.  If called as an "
"attribute of an instance of that class, the method will get the instance "
"object as its first :term:`argument` (which is usually called ``self``). "
"See :term:`function` and :term:`nested scope`."
msgstr ""
"클래스 바디 안에서 정의되는 함수. 그 클래스의 인스턴스의 어트리뷰트로서 호출되면, 그 메서드는 첫 번째 :term:`인자 "
"<argument>` (보통 ``self`` 라고 불린다) 로 인스턴스 객체를 받는다. :term:`함수 <function>` 와 "
":term:`중첩된 스코프 <nested scope>` 를 보세요."

#: ../Doc/glossary.rst:664
msgid "method resolution order"
msgstr "method resolution order (메서드 결정 순서)"

#: ../Doc/glossary.rst:666
msgid ""
"Method Resolution Order is the order in which base classes are searched "
"for a member during lookup. See `The Python 2.3 Method Resolution Order "
"<https://www.python.org/download/releases/2.3/mro/>`_ for details of the "
"algorithm used by the Python interpreter since the 2.3 release."
msgstr ""
"메서드 결정 순서는 조회하는 동안 멤버를 검색하는 베이스 클래스들의 순서다. 2.3 릴리스부터 파이썬 인터프리터에 사용된 "
"알고리즘의 상세한 내용은 `The Python 2.3 Method Resolution Order "
"<https://www.python.org/download/releases/2.3/mro/>`_ 를 보면 된다."

#: ../Doc/glossary.rst:670
msgid "module"
msgstr "module (모듈)"

#: ../Doc/glossary.rst:672
msgid ""
"An object that serves as an organizational unit of Python code.  Modules "
"have a namespace containing arbitrary Python objects.  Modules are loaded"
" into Python by the process of :term:`importing`."
msgstr ""
"파이썬 코드의 조직화 단위를 담당하는 객체. 모듈은 임의의 파이썬 객체들을 담는 이름 공간을 갖는다. 모듈은 :term:`임포팅 "
"<importing>` 절차에 의해 파이썬으로 로드된다."

#: ../Doc/glossary.rst:676
msgid "See also :term:`package`."
msgstr ":term:`패키지 <package>` 도 보세요."

#: ../Doc/glossary.rst:677
msgid "module spec"
msgstr "module spec (모듈 스펙)"

#: ../Doc/glossary.rst:679
msgid ""
"A namespace containing the import-related information used to load a "
"module. An instance of :class:`importlib.machinery.ModuleSpec`."
msgstr ""
"모듈을 로드하는데 사용되는 임포트 관련 정보들을 담고 있는 이름 공간. "
":class:`importlib.machinery.ModuleSpec` 의 인스턴스."

#: ../Doc/glossary.rst:681
msgid "MRO"
msgstr "MRO"

#: ../Doc/glossary.rst:683
msgid "See :term:`method resolution order`."
msgstr ":term:`메서드 결정 순서 <method resolution order>` 를 보세요."

#: ../Doc/glossary.rst:684
msgid "mutable"
msgstr "mutable (가변)"

#: ../Doc/glossary.rst:686
msgid ""
"Mutable objects can change their value but keep their :func:`id`.  See "
"also :term:`immutable`."
msgstr "가변 객체는 값이 변할 수 있지만 :func:`id` 는 일정하게 유지한다. :term:`불변 <immutable>` 도 보세요."

#: ../Doc/glossary.rst:688
msgid "named tuple"
msgstr "named tuple (네임드 튜플)"

#: ../Doc/glossary.rst:690
msgid ""
"Any tuple-like class whose indexable elements are also accessible using "
"named attributes (for example, :func:`time.localtime` returns a tuple-"
"like object where the *year* is accessible either with an index such as "
"``t[0]`` or with a named attribute like ``t.tm_year``)."
msgstr ""
"인덱싱할 수 있는 요소들을 이름 붙은 어트리뷰트로도 액세스할 수 있는 모든 튜플류 클래스 (예를 들어, "
":func:`time.localtime` 은 *year* 가 ``t[0]`` 처럼 인덱스로도, ``t.tm_year`` 처럼 "
"어트리뷰트로도 액세스할 수 있는 튜플류 객체를 돌려준다.)"

#: ../Doc/glossary.rst:695
msgid ""
"A named tuple can be a built-in type such as :class:`time.struct_time`, "
"or it can be created with a regular class definition.  A full featured "
"named tuple can also be created with the factory function "
":func:`collections.namedtuple`.  The latter approach automatically "
"provides extra features such as a self-documenting representation like "
"``Employee(name='jones', title='programmer')``."
msgstr ""
"네임드 튜플은 :class:`time.struct_time` 같은 내장형일 수도, 일반 클래스 정의로 만들 수도 있다. 모든 "
"기능이 구현된 네임드 튜플을 팩토리 함수 :func:`collections.namedtuple` 로도 만들 수 있다. 마지막 "
"접근법은 ``Employee(name='jones', title='programmer')`` 와 같은 스스로 문서로 만드는 repr 과"
" 같은 확장 기능도 자동 제공한다."

#: ../Doc/glossary.rst:701
msgid "namespace"
msgstr "namespace (이름 공간)"

#: ../Doc/glossary.rst:703
msgid ""
"The place where a variable is stored.  Namespaces are implemented as "
"dictionaries.  There are the local, global and built-in namespaces as "
"well as nested namespaces in objects (in methods).  Namespaces support "
"modularity by preventing naming conflicts.  For instance, the functions "
":func:`builtins.open <.open>` and :func:`os.open` are distinguished by "
"their namespaces.  Namespaces also aid readability and maintainability by"
" making it clear which module implements a function.  For instance, "
"writing :func:`random.seed` or :func:`itertools.islice` makes it clear "
"that those functions are implemented by the :mod:`random` and "
":mod:`itertools` modules, respectively."
msgstr ""
"변수가 저장되는 장소. 이름 공간은 딕셔너리로 구현된다. 객체에 중첩된 이름 공간 (메서드 에서) 뿐만 아니라 지역, 전역, 내장 "
"이름 공간이 있다. 이름 공간은 이름 충돌을 방지해서 모듈성을 지원한다. 예를 들어, 함수 :func:`builtins.open "
"<.open>` 과 :func:`os.open` 은 그들의 이름 공간에 의해 구별된다. 또한, 이름 공간은 어떤 모듈이 함수를 "
"구현하는지를 분명하게 만들어서 가독성과 유지 보수성에 도움을 준다. 예를 들어, :func:`random.seed` 또는 "
":func:`itertools.islice` 라고 쓰면 그 함수들이 각각 :mod:`random` 과 :mod:`itertools`"
" 모듈에 의해 구현되었음이 명확해진다."

#: ../Doc/glossary.rst:713
msgid "namespace package"
msgstr "namespace package (이름 공간 패키지)"

#: ../Doc/glossary.rst:715
msgid ""
"A :pep:`420` :term:`package` which serves only as a container for "
"subpackages.  Namespace packages may have no physical representation, and"
" specifically are not like a :term:`regular package` because they have no"
" ``__init__.py`` file."
msgstr ""
"오직 서브 패키지들의 컨테이너로만 기능하는 :pep:`420` :term:`패키지 <package>`. 이름 공간 패키지는 물리적인 "
"실체가 없을 수도 있고, 특히 ``__init__.py`` 파일이 없으므로 :term:`정규 패키지 <regular "
"package>` 와는 다르다."

#: ../Doc/glossary.rst:720
msgid "See also :term:`module`."
msgstr ":term:`모듈 <module>` 도 보세요."

#: ../Doc/glossary.rst:721
msgid "nested scope"
msgstr "nested scope (중첩된 스코프)"

#: ../Doc/glossary.rst:723
msgid ""
"The ability to refer to a variable in an enclosing definition.  For "
"instance, a function defined inside another function can refer to "
"variables in the outer function.  Note that nested scopes by default work"
" only for reference and not for assignment.  Local variables both read "
"and write in the innermost scope.  Likewise, global variables read and "
"write to the global namespace.  The :keyword:`nonlocal` allows writing to"
" outer scopes."
msgstr ""
"둘러싼 정의에서 변수를 참조하는 능력. 예를 들어, 다른 함수 내부에서 정의된 함수는 바깥 함수에 있는 변수들을 참조할 수 있다. "
"중첩된 스코프는 기본적으로는 참조만 가능할 뿐, 대입은 되지 않는다는 것에 주의해야 한다. 지역 변수들은 가장 내부의 스코프에서 "
"읽고 쓴다. 마찬가지로, 전역 변수들은 전역 이름 공간에서 읽고 쓴다. :keyword:`nonlocal` 은 바깥 스코프에 쓰는 "
"것을 허락한다."

#: ../Doc/glossary.rst:730
msgid "new-style class"
msgstr "new-style class (뉴스타일 클래스)"

#: ../Doc/glossary.rst:732
msgid ""
"Old name for the flavor of classes now used for all class objects.  In "
"earlier Python versions, only new-style classes could use Python's newer,"
" versatile features like :attr:`~object.__slots__`, descriptors, "
"properties, :meth:`__getattribute__`, class methods, and static methods."
msgstr ""
"지금은 모든 클래스 객체에 사용되고 있는 클래스 버전의 예전 이름. 초기의 파이썬 버전에서는, 오직 뉴스타일 클래스만 "
":attr:`~object.__slots__`, 디스크립터, 프라퍼티, :meth:`__getattribute__`, 클래스 "
"메서드, 스태틱 메서드와 같은 파이썬의 새롭고 다양한 기능들을 사용할 수 있었다."

#: ../Doc/glossary.rst:736
msgid "object"
msgstr "object (객체)"

#: ../Doc/glossary.rst:738
msgid ""
"Any data with state (attributes or value) and defined behavior (methods)."
"  Also the ultimate base class of any :term:`new-style class`."
msgstr ""
"상태 (어트리뷰트나 값) 를 갖고 동작 (메서드) 이 정의된 모든 데이터. 또한, 모든 :term:`뉴스타일 클래스 <new-"
"style class>` 의 최종적인 베이스 클래스다."

#: ../Doc/glossary.rst:741
msgid "package"
msgstr "package (패키지)"

#: ../Doc/glossary.rst:743
msgid ""
"A Python :term:`module` which can contain submodules or recursively, "
"subpackages.  Technically, a package is a Python module with an "
"``__path__`` attribute."
msgstr ""
"서브 모듈들이나, 재귀적으로 서브 패키지들을 포함할 수 있는 파이썬 :term:`모듈 <module>`. 기술적으로, 패키지는 "
"``__path__`` 어트리뷰트가 있는 파이썬 모듈이다."

#: ../Doc/glossary.rst:747
msgid "See also :term:`regular package` and :term:`namespace package`."
msgstr ""
":term:`정규 패키지 <regular package>` 와 :term:`이름 공간 패키지 <namespace package>` 도"
" 보세요."

#: ../Doc/glossary.rst:748
msgid "parameter"
msgstr "parameter (파라미터)"

#: ../Doc/glossary.rst:750
msgid ""
"A named entity in a :term:`function` (or method) definition that "
"specifies an :term:`argument` (or in some cases, arguments) that the "
"function can accept.  There are five kinds of parameter:"
msgstr ""
":term:`함수 <function>` (또는 메서드) 정의에서 함수가 받을 수 있는 :term:`인자 <argument>` (또는"
" 어떤 경우 인자들) 를 지정하는 이름 붙은 엔티티. 다섯 종류의 파라미터가 있다:"

#: ../Doc/glossary.rst:754
msgid ""
":dfn:`positional-or-keyword`: specifies an argument that can be passed "
"either :term:`positionally <argument>` or as a :term:`keyword argument "
"<argument>`.  This is the default kind of parameter, for example *foo* "
"and *bar* in the following::"
msgstr ""
":dfn:`위치-키워드 (positional-or-keyword)`: :term:`위치 인자 <positional "
"argument>` 나 :term:`키워드 인자 <keyword argument>` 로 전달될 수 있는 인자를 지정한다. 이것이 "
"기본 형태의 파라미터다, 예를 들어 다음에서 *foo* 와 *bar*::"

#: ../Doc/glossary.rst:763
msgid ""
":dfn:`positional-only`: specifies an argument that can be supplied only "
"by position.  Python has no syntax for defining positional-only "
"parameters.  However, some built-in functions have positional-only "
"parameters (e.g. :func:`abs`)."
msgstr ""
":dfn:`위치-전용 (positional-only)`: 위치로만 제공될 수 있는 인자를 지정한다. 파이썬은 위치-전용 파라미터를 "
"정의하는 문법을 갖고 있지 않다. 하지만, 어떤 매장 함수들은 위치-전용 파라미터를 갖는다 (예를 들어, :func:`abs`)."

#: ../Doc/glossary.rst:770
msgid ""
":dfn:`keyword-only`: specifies an argument that can be supplied only by "
"keyword.  Keyword-only parameters can be defined by including a single "
"var-positional parameter or bare ``*`` in the parameter list of the "
"function definition before them, for example *kw_only1* and *kw_only2* in"
" the following::"
msgstr ""
":dfn:`키워드-전용 (keyword-only)`: 키워드로만 제공될 수 있는 인자를 지정한다. 키워드-전용 파라미터는 함수 "
"정의의 파라미터 목록에서 앞에 하나의 가변-위치 파라미터나 ``*`` 를 그대로 포함해서 정의할 수 있다. 예를 들어, 다음에서 "
"*kw_only1* 와 *kw_only2*::"

#: ../Doc/glossary.rst:778
msgid ""
":dfn:`var-positional`: specifies that an arbitrary sequence of positional"
" arguments can be provided (in addition to any positional arguments "
"already accepted by other parameters).  Such a parameter can be defined "
"by prepending the parameter name with ``*``, for example *args* in the "
"following::"
msgstr ""
":dfn:`가변-위치 (var-positional)`: (다른 파라미터들에 의해서 이미 받아들여진 위치 인자들에 더해) 제공될 수 "
"있는 위치 인자들의 임의의 시퀀스를 지정한다. 이런 파라미터는 파라미터 이름에 ``*`` 를 앞에 붙여서 정의될 수 있다, 예를 "
"들어 다음에서 *args*::"

#: ../Doc/glossary.rst:786
msgid ""
":dfn:`var-keyword`: specifies that arbitrarily many keyword arguments can"
" be provided (in addition to any keyword arguments already accepted by "
"other parameters).  Such a parameter can be defined by prepending the "
"parameter name with ``**``, for example *kwargs* in the example above."
msgstr ""
":dfn:`가변-키워드 (var-keyword)`: (다른 파라미터들에 의해서 이미 받아들여진 키워드 인자들에 더해) 제공될 수 "
"있는 임의의 개수 키워드 인자들을 지정한다. 이런 파라미터는 파라미터 이름에 ``**`` 를 앞에 붙여서 정의될 수 있다, 예를 "
"들어 위의 예 에서 *kwargs*."

#: ../Doc/glossary.rst:792
msgid ""
"Parameters can specify both optional and required arguments, as well as "
"default values for some optional arguments."
msgstr "파라미터는 선택적 인자들을 위한 기본값뿐만 아니라 선택적이거나 필수 인자들을 지정할 수 있다."

#: ../Doc/glossary.rst:795
msgid ""
"See also the :term:`argument` glossary entry, the FAQ question on "
":ref:`the difference between arguments and parameters <faq-argument-vs-"
"parameter>`, the :class:`inspect.Parameter` class, the :ref:`function` "
"section, and :pep:`362`."
msgstr ""
":term:`인자 <argument>` 용어집 항목, :ref:`인자와 파라미터의 차이 <faq-argument-vs-"
"parameter>` 에 나오는 FAQ 질문, :class:`inspect.Parameter` 클래스, :ref:`function`"
" 섹션, :pep:`362` 도 보세요."

#: ../Doc/glossary.rst:799
msgid "path entry"
msgstr "path entry (경로 엔트리)"

#: ../Doc/glossary.rst:801
msgid ""
"A single location on the :term:`import path` which the :term:`path based "
"finder` consults to find modules for importing."
msgstr ""
":term:`경로 기반 파인더 <path based finder>` 가 임포트할 모듈들을 찾기 위해 참고하는 :term:`임포트 경로"
" <import path>` 상의 하나의 장소."

#: ../Doc/glossary.rst:803
msgid "path entry finder"
msgstr "path entry finder (경로 엔트리 파인더)"

#: ../Doc/glossary.rst:805
msgid ""
"A :term:`finder` returned by a callable on :data:`sys.path_hooks` (i.e. a"
" :term:`path entry hook`) which knows how to locate modules given a "
":term:`path entry`."
msgstr ""
":data:`sys.path_hooks` 에 있는 콜러블 (즉, :term:`경로 엔트리 훅 <path entry hook>`) 이"
" 돌려주는 :term:`파인더 <finder>` 인데, 주어진 :term:`경로 엔트리 <path entry>` 로 모듈을 찾는 "
"방법을 알고 있다."

#: ../Doc/glossary.rst:809
msgid ""
"See :class:`importlib.abc.PathEntryFinder` for the methods that path "
"entry finders implement."
msgstr "경로 엔트리 파인더들이 구현하는 메서드들은 :class:`importlib.abc.PathEntryFinder` 에 나온다."

#: ../Doc/glossary.rst:811
msgid "path entry hook"
msgstr "path entry hook (경로 엔트리 훅)"

#: ../Doc/glossary.rst:813
msgid ""
"A callable on the :data:`sys.path_hook` list which returns a :term:`path "
"entry finder` if it knows how to find modules on a specific :term:`path "
"entry`."
msgstr ""
":data:`sys.path_hook` 리스트에 있는 콜러블인데, 특정 :term:`경로 엔트리 <path entry>` 에서 "
"모듈을 찾는 법을 알고 있다면 :term:`경로 엔트리 파인더 <path entry finder>` 를 돌려준다."

#: ../Doc/glossary.rst:816
msgid "path based finder"
msgstr "path based finder (경로 기반 파인더)"

#: ../Doc/glossary.rst:818
msgid ""
"One of the default :term:`meta path finders <meta path finder>` which "
"searches an :term:`import path` for modules."
msgstr ""
"기본 :term:`메타 경로 파인더들 <meta path finder>` 중 하나인데, :term:`임포트 경로 <import "
"path>` 에서 모듈을 찾는다."

#: ../Doc/glossary.rst:820
msgid "path-like object"
msgstr "path-like object (경로류 객체)"

#: ../Doc/glossary.rst:822
msgid ""
"An object representing a file system path. A path-like object is either a"
" :class:`str` or :class:`bytes` object representing a path, or an object "
"implementing the :class:`os.PathLike` protocol. An object that supports "
"the :class:`os.PathLike` protocol can be converted to a :class:`str` or "
":class:`bytes` file system path by calling the :func:`os.fspath` "
"function; :func:`os.fsdecode` and :func:`os.fsencode` can be used to "
"guarantee a :class:`str` or :class:`bytes` result instead, respectively. "
"Introduced by :pep:`519`."
msgstr ""
"파일 시스템 경로를 나타내는 객체. 경로류 객체는 경로를 나타내는 :class:`str` 나 :class:`bytes` 객체이거나 "
":class:`os.PathLike` 프로토콜을 구현하는 객체다. :class:`os.PathLike` 프로토콜을 지원하는 객체는 "
":func:`os.fspath` 함수를 호출해서 :class:`str` 나 :class:`bytes` 파일 시스템 경로로 변환될 수"
" 있다; 대신 :func:`os.fsdecode` 와 :func:`os.fsencode` 는 각각 :class:`str` 나 "
":class:`bytes` 결과를 보장하는데 사용될 수 있다. :pep:`519` 로 도입되었다."

#: ../Doc/glossary.rst:830
msgid "portion"
msgstr "portion (포션)"

#: ../Doc/glossary.rst:832
msgid ""
"A set of files in a single directory (possibly stored in a zip file) that"
" contribute to a namespace package, as defined in :pep:`420`."
msgstr ""
":pep:`420` 에서 정의한 것처럼, 이름 공간 패키지에 이바지하는 하나의 디렉터리에 들어있는 파일들의 집합 (zip 파일에 "
"저장되는 것도 가능하다)."

#: ../Doc/glossary.rst:834
msgid "positional argument"
msgstr "positional argument (위치 인자)"

#: ../Doc/glossary.rst:837
msgid "provisional API"
msgstr "provisional API (잠정 API)"

#: ../Doc/glossary.rst:839
msgid ""
"A provisional API is one which has been deliberately excluded from the "
"standard library's backwards compatibility guarantees.  While major "
"changes to such interfaces are not expected, as long as they are marked "
"provisional, backwards incompatible changes (up to and including removal "
"of the interface) may occur if deemed necessary by core developers.  Such"
" changes will not be made gratuitously -- they will occur only if serious"
" fundamental flaws are uncovered that were missed prior to the inclusion "
"of the API."
msgstr ""
"잠정 API는 표준 라이브러리의 과거 호환성 보장으로부터 신중히 제외된 것이다. 인터페이스의 큰 변화가 예상되지는 않지만, "
"잠정적이라고 표시되는 한, 코어 개발자들이 필요하다고 생각한다면 과거 호환성이 유지되지 않는 변경이 일어날 수 있다. 그런 변경은 "
"불필요한 방식으로 일어나지는 않을 것이다 --- API를 포함하기 전에 놓친 중대하고 근본적인 결함이 발견된 경우에만 일어날 "
"것이다."

#: ../Doc/glossary.rst:848
msgid ""
"Even for provisional APIs, backwards incompatible changes are seen as a "
"\"solution of last resort\" - every attempt will still be made to find a "
"backwards compatible resolution to any identified problems."
msgstr ""
"잠정 API에서조차도, 과거 호환성이 유지되지 않는 변경은 \"최후의 수단\"으로 여겨진다 - 모든 식별된 문제들에 대해 과거"
" 호환성을 유지하는 해법을 찾으려는 모든 시도가 선행된다."

#: ../Doc/glossary.rst:852
msgid ""
"This process allows the standard library to continue to evolve over time,"
" without locking in problematic design errors for extended periods of "
"time.  See :pep:`411` for more details."
msgstr ""
"이 절차는 표준 라이브러리가 오랜 시간 동안 잘못된 설계 오류에 발목 잡히지 않고 발전할 수 있도록 만든다. 더 자세한 내용은 "
":pep:`411` 를 보면 된다."

#: ../Doc/glossary.rst:855
msgid "provisional package"
msgstr "provisional package (잠정 패키지)"

#: ../Doc/glossary.rst:857
msgid "See :term:`provisional API`."
msgstr ":term:`잠정 API <provisional API>` 를 보세요."

#: ../Doc/glossary.rst:858
msgid "Python 3000"
msgstr "Python 3000 (파이썬 3000)"

#: ../Doc/glossary.rst:860
msgid ""
"Nickname for the Python 3.x release line (coined long ago when the "
"release of version 3 was something in the distant future.)  This is also "
"abbreviated \"Py3k\"."
msgstr ""
"파이썬 3.x 배포 라인의 별명 (버전 3의 배포가 먼 미래의 이야기던 시절에 만들어진 이름이다.) 이것을 \"Py3k\" 로"
" 줄여 쓰기도 한다."

#: ../Doc/glossary.rst:863
msgid "Pythonic"
msgstr "Pythonic (파이썬다운)"

#: ../Doc/glossary.rst:865
msgid ""
"An idea or piece of code which closely follows the most common idioms of "
"the Python language, rather than implementing code using concepts common "
"to other languages.  For example, a common idiom in Python is to loop "
"over all elements of an iterable using a :keyword:`for` statement.  Many "
"other languages don't have this type of construct, so people unfamiliar "
"with Python sometimes use a numerical counter instead::"
msgstr ""
"다른 언어들에서 일반적인 개념들을 사용해서 코드를 구현하는 대신, 파이썬 언어에서 가장 자주 사용되는 이디엄들을 가까이 따르는 "
"아이디어나 코드 조작. 예를 들어, 파이썬에서 자주 쓰는 이디엄은 :keyword:`for` 문을 사용해서 이터러블의 모든 요소로"
" 루핑하는 것이다. 다른 많은 언어에는 이런 종류의 구성물이 없으므로, 파이썬에 익숙하지 않은 사람들은 대신에 숫자 카운터를 "
"사용하기도 한다::"

#: ../Doc/glossary.rst:875
msgid "As opposed to the cleaner, Pythonic method::"
msgstr "더 깔끔한, 파이썬다운 방법은 이렇다::"

#: ../Doc/glossary.rst:879
msgid "qualified name"
msgstr "qualified name (정규화된 이름)"

#: ../Doc/glossary.rst:881
msgid ""
"A dotted name showing the \"path\" from a module's global scope to a "
"class, function or method defined in that module, as defined in "
":pep:`3155`.  For top-level functions and classes, the qualified name is "
"the same as the object's name::"
msgstr ""
"모듈의 전역 스코프에서 모듈에 정의된 클래스, 함수, 메서드에 이르는 \"경로\"를 보여주는 점으로 구분된 이름. "
":pep:`3155` 에서 정의된다. 최상위 함수와 클래스의 경우에, 정규화된 이름은 객체의 이름과 같다::"

#: ../Doc/glossary.rst:898
msgid ""
"When used to refer to modules, the *fully qualified name* means the "
"entire dotted path to the module, including any parent packages, e.g. "
"``email.mime.text``::"
msgstr ""
"모듈을 가리키는데 사용될 때, *완전히 정규화된 이름(fully qualified name)* 은 모든 부모 패키지들을 포함해서 "
"모듈로 가는 점으로 분리된 이름을 의미한다, 예를 들어, ``email.mime.text``::"

#: ../Doc/glossary.rst:905
msgid "reference count"
msgstr "reference count (참조 횟수)"

#: ../Doc/glossary.rst:907
msgid ""
"The number of references to an object.  When the reference count of an "
"object drops to zero, it is deallocated.  Reference counting is generally"
" not visible to Python code, but it is a key element of the "
":term:`CPython` implementation.  The :mod:`sys` module defines a "
":func:`~sys.getrefcount` function that programmers can call to return the"
" reference count for a particular object."
msgstr ""
"객체에 대한 참조의 개수. 객체의 참조 횟수가 0으로 떨어지면, 메모리가 반납된다. 참조 횟수 추적은 일반적으로 파이썬 코드에 "
"노출되지는 않지만, :term:`CPython` 구현의 핵심 요소다. :mod:`sys` 모듈은 특정 객체의 참조 횟수를 돌려주는 "
":func:`~sys.getrefcount` 을 정의한다."

#: ../Doc/glossary.rst:913
msgid "regular package"
msgstr "regular package (정규 패키지)"

#: ../Doc/glossary.rst:915
msgid ""
"A traditional :term:`package`, such as a directory containing an "
"``__init__.py`` file."
msgstr "``__init__.py`` 파일을 포함하는 디렉터리와 같은 전통적인 :term:`패키지 <package>`."

#: ../Doc/glossary.rst:918
msgid "See also :term:`namespace package`."
msgstr ":term:`이름 공간 패키지 <namespace package>` 도 보세요."

#: ../Doc/glossary.rst:919
msgid "__slots__"
msgstr "__slots__"

#: ../Doc/glossary.rst:921
msgid ""
"A declaration inside a class that saves memory by pre-declaring space for"
" instance attributes and eliminating instance dictionaries.  Though "
"popular, the technique is somewhat tricky to get right and is best "
"reserved for rare cases where there are large numbers of instances in a "
"memory-critical application."
msgstr ""
"클래스 내부의 선언인데, 인스턴스 어트리뷰트들을 위한 공간을 미리 선언하고 인스턴스 딕셔너리를 제거함으로써 메모리를 절감하는 효과를"
" 준다. 인기 있기는 하지만, 이 테크닉은 올바르게 사용하기가 좀 까다로운 편이라서, 메모리에 민감한 응용 프로그램에서 많은 수의 인스턴스가"
" 있는 특별한 경우로 한정하는 것이 좋다."

#: ../Doc/glossary.rst:926
msgid "sequence"
msgstr "sequence (시퀀스)"

#: ../Doc/glossary.rst:928
msgid ""
"An :term:`iterable` which supports efficient element access using integer"
" indices via the :meth:`__getitem__` special method and defines a "
":meth:`__len__` method that returns the length of the sequence. Some "
"built-in sequence types are :class:`list`, :class:`str`, :class:`tuple`, "
"and :class:`bytes`. Note that :class:`dict` also supports "
":meth:`__getitem__` and :meth:`__len__`, but is considered a mapping "
"rather than a sequence because the lookups use arbitrary "
":term:`immutable` keys rather than integers."
msgstr ""
":meth:`__getitem__` 특수 메서드를 통해 정수 인덱스를 사용한 빠른 요소 액세스를 지원하고, 시퀀스의 길이를 돌려주는"
" :meth:`__len__` 메서드를 정의하는 :term:`이터러블 <iterable>`. 몇몇 내장 시퀀스들을 나열해보면, "
":class:`list`, :class:`str`, :class:`tuple`, :class:`bytes` 가 있다. "
":class:`dict` 또한 :meth:`__getitem__` 과 :meth:`__len__` 을 지원하지만, 조회에 정수 대신"
" 임의의 :term:`불변 <immutable>` 키를 사용하기 때문에 시퀀스가 아니라 매핑으로 취급된다는 것에 주의해야 한다."

#: ../Doc/glossary.rst:937
msgid ""
"The :class:`collections.abc.Sequence` abstract base class defines a much "
"richer interface that goes beyond just :meth:`__getitem__` and "
":meth:`__len__`, adding :meth:`count`, :meth:`index`, "
":meth:`__contains__`, and :meth:`__reversed__`. Types that implement this"
" expanded interface can be registered explicitly using "
":func:`~abc.register`."
msgstr ""
":class:`collections.abc.Sequence` 추상 베이스 클래스는 :meth:`__getitem__` 과 "
":meth:`__len__` 를 넘어서 훨씬 풍부한 인터페이스를 정의하는데, :meth:`count`, :meth:`index`, "
":meth:`__contains__`, :meth:`__reversed__` 를 추가한다. 이 확장된 인터페이스를 구현한 형을 "
":func:`~abc.register` 를 사용해서 명시적으로 등록할 수 있다."

#: ../Doc/glossary.rst:944
msgid "single dispatch"
msgstr "single dispatch (싱글 디스패치)"

#: ../Doc/glossary.rst:946
msgid ""
"A form of :term:`generic function` dispatch where the implementation is "
"chosen based on the type of a single argument."
msgstr "구현이 하나의 인자의 형에 기초해서 결정되는 :term:`제네릭 함수 <generic function>` 디스패치의 한 형태."

#: ../Doc/glossary.rst:948
msgid "slice"
msgstr "slice (슬라이스)"

#: ../Doc/glossary.rst:950
msgid ""
"An object usually containing a portion of a :term:`sequence`.  A slice is"
" created using the subscript notation, ``[]`` with colons between numbers"
" when several are given, such as in ``variable_name[1:3:5]``.  The "
"bracket (subscript) notation uses :class:`slice` objects internally."
msgstr ""
"보통 :term:`시퀀스 <sequence>` 의 일부를 포함하는 객체. 슬라이스는 서브 스크립트 표기법을 사용해서 만든다. "
"``variable_name[1:3:5]`` 처럼, ``[]`` 안에서 여러 개의 숫자를 콜론으로 분리한다. 꺾쇠괄호 "
"(서브 스크립트) 표기법은 내부적으로 :class:`slice` 객체를 사용한다."

#: ../Doc/glossary.rst:954
msgid "special method"
msgstr "special method (특수 메서드)"

#: ../Doc/glossary.rst:956
msgid ""
"A method that is called implicitly by Python to execute a certain "
"operation on a type, such as addition.  Such methods have names starting "
"and ending with double underscores.  Special methods are documented in "
":ref:`specialnames`."
msgstr ""
"파이썬이 형에 어떤 연산을, 덧셈 같은, 실행할 때 묵시적으로 호출되는 메서드. 이런 메서드는 두 개의 밑줄로 시작하고 끝나는 이름을"
" 갖고 있다. 특수 메서드는 :ref:`specialnames` 에 문서로 만들어져 있다."

#: ../Doc/glossary.rst:960
msgid "statement"
msgstr "statement (문장)"

#: ../Doc/glossary.rst:962
msgid ""
"A statement is part of a suite (a \"block\" of code).  A statement is "
"either an :term:`expression` or one of several constructs with a keyword,"
" such as :keyword:`if`, :keyword:`while` or :keyword:`for`."
msgstr ""
"문장은 스위트 (코드의 \"블록(block)\") 를 구성하는 부분이다. 문장은 :term:`표현식 <expression>` 이거나"
" 키워드를 사용하는 여러 가지 구조물 중의 하나다. 가령 :keyword:`if`, :keyword:`while`, "
":keyword:`for`."

#: ../Doc/glossary.rst:965
msgid "struct sequence"
msgstr "struct sequence (구조체 시퀀스)"

#: ../Doc/glossary.rst:967
msgid ""
"A tuple with named elements. Struct sequences expose an interface similar"
" to :term:`named tuple` in that elements can either be accessed either by"
" index or as an attribute. However, they do not have any of the named "
"tuple methods like :meth:`~collections.somenamedtuple._make` or "
":meth:`~collections.somenamedtuple._asdict`. Examples of struct sequences"
" include :data:`sys.float_info` and the return value of :func:`os.stat`."
msgstr ""
"이름 붙은 요소들을 가진 튜플. 구조체 시퀀스는 :term:`네임드 튜플 <named tuple>` 과 비슷한 인터페이스를 "
"드러내는데, 요소들이 인덱스나 어트리뷰트로 액세스 될 수 있다. 하지만, 이것은 "
":meth:`~collections.somenamedtuple._make` 나 "
":meth:`~collections.somenamedtuple._asdict` 같은 네임드 튜플의 메서드들을 갖고 있지 않다. "
"구조체 시퀀스의 예로는 :data:`sys.float_info` 과 :func:`os.stat` 의 반환 값을 들 수 있다."

#: ../Doc/glossary.rst:973
msgid "text encoding"
msgstr "text encoding (텍스트 인코딩)"

#: ../Doc/glossary.rst:975
msgid "A codec which encodes Unicode strings to bytes."
msgstr "유니코드 문자열을 바이트열로 인코딩하는 코덱."

#: ../Doc/glossary.rst:976
msgid "text file"
msgstr "text file (텍스트 파일)"

#: ../Doc/glossary.rst:978
msgid ""
"A :term:`file object` able to read and write :class:`str` objects. Often,"
" a text file actually accesses a byte-oriented datastream and handles the"
" :term:`text encoding` automatically. Examples of text files are files "
"opened in text mode (``'r'`` or ``'w'``), :data:`sys.stdin`, "
":data:`sys.stdout`, and instances of :class:`io.StringIO`."
msgstr ""
":class:`str` 객체를 읽고 쓸 수 있는 :term:`파일 객체 <file object>`. 종종, 텍스트 파일은 실제로는 "
"바이트 지향 데이터스트림을 액세스하고 :term:`텍스트 인코딩 <text encoding>` 을 자동 처리한다. 텍스트 파일의 "
"예로는 텍스트 모드 (``'r'`` 또는 ``'w'``) 로 열린 파일, :data:`sys.stdin`, "
":data:`sys.stdout`, :class:`io.StringIO` 의 인스턴스를 들 수 있다."

#: ../Doc/glossary.rst:986
msgid "A :term:`binary file` reads and write :class:`bytes` objects."
msgstr ":term:`바이너리 파일 <binary file>` 은 :class:`bytes` 객체를 읽고 쓴다."

#: ../Doc/glossary.rst:987
msgid "triple-quoted string"
msgstr "triple-quoted string (삼중 따옴표 된 문자열)"

#: ../Doc/glossary.rst:989
msgid ""
"A string which is bound by three instances of either a quotation mark "
"(\") or an apostrophe (').  While they don't provide any functionality "
"not available with single-quoted strings, they are useful for a number of"
" reasons.  They allow you to include unescaped single and double quotes "
"within a string and they can span multiple lines without the use of the "
"continuation character, making them especially useful when writing "
"docstrings."
msgstr ""
"따옴표 (\") 나 작은따옴표 (') 세 개로 둘러싸인 문자열. 그냥 따옴표 하나로 둘러싸인 문자열에 없는 기능을 제공하지는 "
"않지만, 여러 가지 이유에서 쓸모가 있다. 이스케이프 되지 않은 작은따옴표나 큰따옴표를 문자열 안에 포함할 수 있도록 하고, 연결"
" 문자를 쓰지 않고도 여러 줄에 걸칠 수 있는데, 독스트링을 쓸 때 특히 쓸모 있다."

#: ../Doc/glossary.rst:996
msgid "type"
msgstr "type (형)"

#: ../Doc/glossary.rst:998
msgid ""
"The type of a Python object determines what kind of object it is; every "
"object has a type.  An object's type is accessible as its "
":attr:`~instance.__class__` attribute or can be retrieved with "
"``type(obj)``."
msgstr ""
"파이썬 객체의 형은 그것이 어떤 종류의 객체인지를 결정한다; 모든 객체는 형이 있다. 객체의 형은 "
":attr:`~instance.__class__` 어트리뷰트로 액세스할 수 있거나 ``type(obj)`` 로 얻을 수 있다."

#: ../Doc/glossary.rst:1002
msgid "universal newlines"
msgstr "universal newlines (유니버설 줄 넘김)"

#: ../Doc/glossary.rst:1004
msgid ""
"A manner of interpreting text streams in which all of the following are "
"recognized as ending a line: the Unix end-of-line convention ``'\\n'``, "
"the Windows convention ``'\\r\\n'``, and the old Macintosh convention "
"``'\\r'``.  See :pep:`278` and :pep:`3116`, as well as "
":func:`bytes.splitlines` for an additional use."
msgstr ""
"다음과 같은 것들을 모두 줄의 끝으로 인식하는, 텍스트 스트림을 해석하는 태도: 유닉스 개행 문자 관례 ``'\\n'``, 윈도우즈"
" 관례 ``'\\r\\n'``, 예전의 매킨토시 관례 ``'\\r'``. 추가적인 사용에 관해서는 "
":func:`bytes.splitlines` 뿐만 아니라 :pep:`278` 와 :pep:`3116` 도 보세요."

#: ../Doc/glossary.rst:1009
msgid "variable annotation"
msgstr "variable annotation (변수 어노테이션)"

#: ../Doc/glossary.rst:1011
msgid ""
"A type metadata value associated with a module global variable or a class"
" attribute. Its syntax is explained in section :ref:`annassign`. "
"Annotations are stored in the :attr:`__annotations__` special attribute "
"of a class or module object and can be accessed using "
":func:`typing.get_type_hints`."
msgstr ""
"모듈 전역 변수나 클래스 어트리뷰트와 결합한 형 메타데이터 값. 문법은 섹션 :ref:`annassign` 에서 설명한다. "
"어노테이션은 클래스나 모듈 객체의 :attr:`__annotations__` 특수 어트리뷰트에 저장되고, "
":func:`typing.get_type_hints` 를 사용해서 액세스할 수 있다."

#: ../Doc/glossary.rst:1017
msgid ""
"Python itself does not assign any particular meaning to variable "
"annotations. They are intended to be interpreted by third-party libraries"
" or type checking tools. See :pep:`526`, :pep:`484` which describe some "
"of their potential uses."
msgstr ""
"파이썬 자체는 변수 어노테이션에 어떤 특별한 의미도 부여하지 않는다. 제삼자 라이브러리나 형 검사 도구들에 의해 해석되는 것이 "
"목적이다. :pep:`526` 과 :pep:`484` 은 몇 가지 잠재적인 사용에 관해 기술하고 있다."

#: ../Doc/glossary.rst:1021
msgid "virtual environment"
msgstr "virtual environment (가상 환경)"

#: ../Doc/glossary.rst:1023
msgid ""
"A cooperatively isolated runtime environment that allows Python users and"
" applications to install and upgrade Python distribution packages without"
" interfering with the behaviour of other Python applications running on "
"the same system."
msgstr ""
"파이썬 사용자와 응용 프로그램이, 같은 시스템에서 실행되는 다른 파이썬 응용 프로그램들의 동작에 영향을 주지 않으면서, 파이썬 배포 패키지들을 "
"설치하거나 업그레이드하는 것을 가능하게 하는, 협력적으로 격리된 실행 환경."

#: ../Doc/glossary.rst:1028
msgid "See also :mod:`venv`."
msgstr ":mod:`venv` 도 보세요."

#: ../Doc/glossary.rst:1029
msgid "virtual machine"
msgstr "virtual machine (가상 기계)"

#: ../Doc/glossary.rst:1031
msgid ""
"A computer defined entirely in software.  Python's virtual machine "
"executes the :term:`bytecode` emitted by the bytecode compiler."
msgstr ""
"소프트웨어만으로 정의된 컴퓨터. 파이썬의 가상 기계는 바이트 코드 컴파일러가 출력하는 :term:`바이트 코드 <bytecode>` "
"를 실행한다."

#: ../Doc/glossary.rst:1033
msgid "Zen of Python"
msgstr "Zen of Python (파이썬 젠)"

#: ../Doc/glossary.rst:1035
msgid ""
"Listing of Python design principles and philosophies that are helpful in "
"understanding and using the language.  The listing can be found by typing"
" \"``import this``\" at the interactive prompt."
msgstr ""
"파이썬 디자인 원리와 철학들의 목록인데, 인어를 이해하고 사용하는 데 도움이 된다. 이 목록은 대화형 프롬프트에서 \"``import"
" this``\" 를 입력하면 보인다."
